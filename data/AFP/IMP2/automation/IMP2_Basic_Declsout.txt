Loading theory "Draft.IMP2_Utils" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.IMP2_Basic_Decls" via "Draft.IMP2_Basic_Simpset")
Loading theory "Draft.Syntax" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.IMP2_Basic_Decls" via "Draft.IMP2_Basic_Simpset" via "Draft.Semantics")
Loading theory "Draft.Named_Simpsets" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.IMP2_Basic_Decls" via "Draft.IMP2_Basic_Simpset")
Loading theory "HOL-Eisbach.Eisbach" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.IMP2_Basic_Decls" via "Draft.IMP2_Basic_Simpset" via "Draft.Semantics" via "HOL-Eisbach.Eisbach_Tools")
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
structure Det_Goal_Refine:
  sig
    val apply: string -> tactic -> thm -> thm
    val apply1: string -> (int -> tactic) -> thm -> thm
    val apply_on_thm: string -> tactic -> thm -> thm
    val seq_first: string -> 'a Seq.seq -> 'a
  end
structure HOLOption:
  sig
    val mk_None: typ -> term
    val mk_Some: term -> term
    val mk_fun_upd: term * term -> term -> term
    val mk_map_empty: typ -> typ -> term
    val mk_map_list: typ -> typ -> (term * term) list -> term
    val mk_map_sng: term * term -> term
    val mk_map_upd: term * term -> term -> term
  end
structure Thm_Mapping:
  sig
    val map_all_prems_tac: rule -> Proof.context -> int -> tactic
    val map_prems_tac: rule list -> Proof.context -> int -> tactic
    val map_thms: Proof.context -> rule list -> thm list -> thm list
    type rule = Proof.context -> thm -> thm
    val thin_fst_prem_tac: Proof.context -> int -> tactic
    val thin_fst_prems_tac: int -> Proof.context -> int -> tactic
  end
infix 0 RS_fst
val RS_fst = fn: thm * thm list -> thm
### theory "Draft.IMP2_Utils"
### 0.064s elapsed time, 0.248s cpu time, 0.000s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
signature NAMED_SIMPSETS =
  sig
    val add_attr: string -> attribute
    val add_cong: string -> thm -> Context.generic -> Context.generic
    val add_cong_attr: string -> attribute
    val add_simp: string -> thm -> Context.generic -> Context.generic
    val add_split: string -> thm -> Context.generic -> Context.generic
    val add_split_attr: string -> attribute
    val check: Proof.context -> xstring * Position.T -> string
    val clear: string -> Context.generic -> Context.generic
    val declare: binding -> simpset option -> local_theory -> local_theory
    val declare_cmd:
       binding ->
         (xstring * Position.T) option -> local_theory -> local_theory
    val del_attr: string -> attribute
    val del_cong: string -> thm -> Context.generic -> Context.generic
    val del_cong_attr: string -> attribute
    val del_simp: string -> thm -> Context.generic -> Context.generic
    val del_split: string -> thm -> Context.generic -> Context.generic
    val del_split_attr: string -> attribute
    val get: Proof.context -> string -> simpset
    val get_all: Proof.context -> simpset Name_Space.table
    val map:
       string -> (simpset -> simpset) -> Context.generic -> Context.generic
    val map_ctxt:
       string ->
         (Proof.context -> Proof.context) ->
           Context.generic -> Context.generic
    val put: string -> Proof.context -> Proof.context
  end
structure Named_Simpsets: NAMED_SIMPSETS
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
locale experiment5310274
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
### theory "Draft.Named_Simpsets"
### 0.149s elapsed time, 0.574s cpu time, 0.029s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
structure Eisbach_Rule_Insts: sig end
### theory "HOL-Library.Function_Algebras"
### 0.176s elapsed time, 0.687s cpu time, 0.029s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "size_list size <*mlex*> {}"
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
Found termination order: "{}"
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
### theory "HOL-Library.Nat_Bijection"
### 0.399s elapsed time, 1.570s cpu time, 0.138s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Eisbach.Eisbach"
### 0.568s elapsed time, 2.215s cpu time, 0.166s GC time
Loading theory "HOL-Eisbach.Eisbach_Tools" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.IMP2_Basic_Decls" via "Draft.IMP2_Basic_Simpset" via "Draft.Semantics")
val try_map = fn: 'a Seq.seq -> 'a Seq.seq -> 'a Seq.seq
val uncurry_rule = fn: thm -> thm
val curry_rule = fn: thm -> thm
### theory "HOL-Library.Set_Algebras"
### 0.349s elapsed time, 1.364s cpu time, 0.138s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Eisbach.Eisbach_Tools"
### 0.038s elapsed time, 0.157s cpu time, 0.000s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 1.120s elapsed time, 4.261s cpu time, 0.927s GC time
simplification rules:
simplification procedures:
congruences:
loopers:
unsafe solvers: "Rtranclp" "Tranclp" "Rtrancl" "Trancl" "lin_arith"
  "Transitivity" "ASSUMPTION" "HOL unsafe"
safe solvers: "HOL safe"
simplification rules:
  (!!x. ?a = x ==> PROP ?P x) == PROP ?P ?a
  (!!x. x = ?a ==> PROP ?P x) == PROP ?P ?a
  (!!x. PROP ?V) == PROP ?V
  THE x. x = ?y == ?y
  THE y. ?y = y == ?y
  ~ False == True
  ~ True == False
  ~ ~ ?y == ?y
  ~ (ALL x. ?P1 x) == EX x. ~ ?P1 x
  \<nexists>x. ?P1 x == ALL x. ~ ?P1 x
  ~ (?P1 --> ?Q1) == ?P1 & ~ ?Q1
  ~ (?P1 | ?Q1) == ~ ?P1 & ~ ?Q1
  ~ (?P1 & ?Q1) == ~ ?P1 | ~ ?Q1
  ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
  ALL x. ?t1 ~= x == False
  ALL x. x ~= ?t1 == False
  ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
  ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
  ALL x. ?y == ?y
  ALL x. ?P1 --> ?Q1 x == ?P1 --> (ALL x. ?Q1 x)
  ALL x. ?P1 x --> ?Q1 == (EX x. ?P1 x) --> ?Q1
  ALL x. ?P1 | ?Q1 x == ?P1 | (ALL x. ?Q1 x)
  ALL x. ?P1 x | ?Q1 == (ALL x. ?P1 x) | ?Q1
  ALL x. ?P1 & ?Q1 x == ?P1 & (ALL x. ?Q1 x)
  ALL x. ?P1 x & ?Q1 == (ALL x. ?P1 x) & ?Q1
  EX x. ?t1 = x & ?P1 x == ?P1 ?t1
  EX x. x = ?t1 & ?P1 x == ?P1 ?t1
  EX x. x = ?t1 == True
  EX x. ?y == ?y
  EX x. ?P1 --> ?Q1 x == ?P1 --> (EX x. ?Q1 x)
  EX x. ?P1 x --> ?Q1 == (ALL x. ?P1 x) --> ?Q1
  EX x. ?P1 | ?Q1 x == ?P1 | (EX x. ?Q1 x)
  EX x. ?P1 x | ?Q1 == (EX x. ?P1 x) | ?Q1
  EX x. ?P1 & ?Q1 x == ?P1 & (EX x. ?Q1 x)
  EX x. ?P1 x & ?Q1 == (EX x. ?P1 x) & ?Q1
  EX x. ?t1 = x == True
  False --> ?P1 == True
  True --> ?y == ?y
  ?P1 --> False == ~ ?P1
  ?P1 --> True == True
  ?P1 --> ?P1 == True
  ?P1 --> ~ ?P1 == ~ ?P1
  ?P1 | ?Q1 --> ?R1 == (?P1 --> ?R1) & (?Q1 --> ?R1)
  (PROP ?P ==> True) == True
  (False ==> ?P) == True
  (True ==> PROP ?P) == PROP ?P
  False | ?y == ?y
  True | ?P1 == True
  ?y | False == ?y
  ?P1 | True == True
  ?y | ?y == ?y
  ?P1 | ~ ?P1 == True
  ?Q1 | (?P1 --> ?R1) == ?P1 --> ?Q1 | ?R1
  ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
  ~ ?P1 | ?P1 == True
  ~ ?P1 | ?Q1 == ?P1 --> ?Q1
  (?P1 --> ?Q1) | ?R1 == ?P1 --> ?Q1 | ?R1
  (?P1 | ?Q1) | ?R1 == ?P1 | ?Q1 | ?R1
  False & ?P1 == False
  True & ?y == ?y
  ?P1 & False == False
  ?y & True == ?y
  ?y & ?y == ?y
  ?P1 & ~ ?P1 == False
  ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
  ~ ?P1 & ?P1 == False
  (?P1 --> ?y) & (~ ?P1 --> ?y) == ?y
  (?P1 & ?Q1) & ?R1 == ?P1 & ?Q1 & ?R1
  False = ?P1 == ~ ?P1
  True = ?y == ?y
  ?P1 = False == ~ ?P1
  ?y = True == ?y
  ?x1 = ?x1 == True
  ?P1 = (~ ?P1) == False
  (~ ?P1) = ?P1 == False
  (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
  if False then ?x1 else ?y == ?y
  if True then ?y else ?y1 == ?y
  if ?c1 then ?y else ?y == ?y
  if ?y = ?y1 then ?y1 else ?y == ?y
simplification procedures:
  HOL.defined_All:
    ALL x. ?P x
  defined_Ex:
    EX x. ?P x
  defined_all:
    !!x. PROP ?P x
  eliminate_false_implies:
    False ==> PROP ?P
  let_simp:
    Let ?x ?f
  neq:
    ?x = ?y
congruences:
  (-->): [| ?P == ?P'; ?P' ==> ?Q == ?Q' |] ==> ?P --> ?Q == ?P' --> ?Q'
  (=simp=>):
    [| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q == PROP ?Q' |]
    ==> (PROP ?P =simp=> PROP ?Q) == (PROP ?P' =simp=> PROP ?Q')
loopers: "split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun"
unsafe solvers: "HOL unsafe"
safe solvers: "HOL safe"
simplification rules:
simplification procedures:
congruences:
loopers:
unsafe solvers: "HOL unsafe"
safe solvers: "HOL safe"
simplification rules:
  (!!x. ?a = x ==> PROP ?P x) == PROP ?P ?a
  (!!x. x = ?a ==> PROP ?P x) == PROP ?P ?a
  (!!x. PROP ?V) == PROP ?V
  THE x. x = ?y == ?y
  THE y. ?y = y == ?y
  ~ False == True
  ~ True == False
  ~ ~ ?y == ?y
  ~ (ALL x. ?P1 x) == EX x. ~ ?P1 x
  \<nexists>x. ?P1 x == ALL x. ~ ?P1 x
  ~ (?P1 --> ?Q1) == ?P1 & ~ ?Q1
  ~ (?P1 | ?Q1) == ~ ?P1 & ~ ?Q1
  ~ (?P1 & ?Q1) == ~ ?P1 | ~ ?Q1
  ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
  ALL x. ?t1 ~= x == False
  ALL x. x ~= ?t1 == False
  ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
  ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
  ALL x. ?y == ?y
  ALL x. ?P1 --> ?Q1 x == ?P1 --> (ALL x. ?Q1 x)
  ALL x. ?P1 x --> ?Q1 == (EX x. ?P1 x) --> ?Q1
  ALL x. ?P1 | ?Q1 x == ?P1 | (ALL x. ?Q1 x)
  ALL x. ?P1 x | ?Q1 == (ALL x. ?P1 x) | ?Q1
  ALL x. ?P1 & ?Q1 x == ?P1 & (ALL x. ?Q1 x)
  ALL x. ?P1 x & ?Q1 == (ALL x. ?P1 x) & ?Q1
  EX x. ?t1 = x & ?P1 x == ?P1 ?t1
  EX x. x = ?t1 & ?P1 x == ?P1 ?t1
  EX x. x = ?t1 == True
  EX x. ?y == ?y
  EX x. ?P1 --> ?Q1 x == ?P1 --> (EX x. ?Q1 x)
  EX x. ?P1 x --> ?Q1 == (ALL x. ?P1 x) --> ?Q1
  EX x. ?P1 | ?Q1 x == ?P1 | (EX x. ?Q1 x)
  EX x. ?P1 x | ?Q1 == (EX x. ?P1 x) | ?Q1
  EX x. ?P1 & ?Q1 x == ?P1 & (EX x. ?Q1 x)
  EX x. ?P1 x & ?Q1 == (EX x. ?P1 x) & ?Q1
  EX x. ?t1 = x == True
  False --> ?P1 == True
  True --> ?y == ?y
  ?P1 --> False == ~ ?P1
  ?P1 --> True == True
  ?P1 --> ?P1 == True
  ?P1 --> ~ ?P1 == ~ ?P1
  ?P1 | ?Q1 --> ?R1 == (?P1 --> ?R1) & (?Q1 --> ?R1)
  (PROP ?P ==> True) == True
  (False ==> ?P) == True
  (True ==> PROP ?P) == PROP ?P
  False | ?y == ?y
  True | ?P1 == True
  ?y | False == ?y
  ?P1 | True == True
  ?y | ?y == ?y
  ?P1 | ~ ?P1 == True
  ?Q1 | (?P1 --> ?R1) == ?P1 --> ?Q1 | ?R1
  ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
  ~ ?P1 | ?P1 == True
  ~ ?P1 | ?Q1 == ?P1 --> ?Q1
  (?P1 --> ?Q1) | ?R1 == ?P1 --> ?Q1 | ?R1
  (?P1 | ?Q1) | ?R1 == ?P1 | ?Q1 | ?R1
  False & ?P1 == False
  True & ?y == ?y
  ?P1 & False == False
  ?y & True == ?y
  ?y & ?y == ?y
  ?P1 & ~ ?P1 == False
  ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
  ~ ?P1 & ?P1 == False
  (?P1 --> ?y) & (~ ?P1 --> ?y) == ?y
  (?P1 & ?Q1) & ?R1 == ?P1 & ?Q1 & ?R1
  False = ?P1 == ~ ?P1
  True = ?y == ?y
  ?P1 = False == ~ ?P1
  ?y = True == ?y
  ?x1 = ?x1 == True
  ?P1 = (~ ?P1) == False
  (~ ?P1) = ?P1 == False
  (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
  if False then ?x1 else ?y == ?y
  if True then ?y else ?y1 == ?y
  if ?c1 then ?y else ?y == ?y
  if ?y = ?y1 then ?y1 else ?y == ?y
simplification procedures:
  HOL.defined_All:
    ALL x. ?P x
  defined_Ex:
    EX x. ?P x
  defined_all:
    !!x. PROP ?P x
  eliminate_false_implies:
    False ==> PROP ?P
  let_simp:
    Let ?x ?f
  neq:
    ?x = ?y
congruences:
  (-->): [| ?P == ?P'; ?P' ==> ?Q == ?Q' |] ==> ?P --> ?Q == ?P' --> ?Q'
  (=simp=>):
    [| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q == PROP ?Q' |]
    ==> (PROP ?P =simp=> PROP ?Q) == (PROP ?P' =simp=> PROP ?Q')
loopers: "split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun"
unsafe solvers: "HOL unsafe"
safe solvers: "HOL safe"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Stream"
### 1.227s elapsed time, 4.697s cpu time, 0.927s GC time
val ctxt = <context>: Proof.context
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
simplification rules:
  euclidean_size == nat o abs
  euclidean_size == id
  normalize == id
  normalize == abs
  normalize == id
  unit_factor == id
  unit_factor == id
  unit_factor == sgn
  natural_of_nat == of_nat
  integer_of_int == of_int
  Sup == %_. a\<^sub>1
  Inf == %_. a\<^sub>1
  inverse == %_. a\<^sub>1
  of_nat == id
  integer_of_num == numeral
  uminus == %_. a\<^sub>1
  uminus == Not
  (mod) == %_ _. a\<^sub>1
  (/) == %_ _. a\<^sub>1
  (*) == %_ _. a\<^sub>1
  (-) == %_ _. a\<^sub>1
  enum_class.enum_all == All
  top == a\<^sub>1
  top == a\<^sub>2
  top == a\<^sub>3
  top == a\<^sub>4
  top == a\<^sub>5
  top == True
  bot == a\<^sub>1
  bot == a\<^sub>1
  bot == a\<^sub>1
  bot == a\<^sub>1
  bot == a\<^sub>1
  bot == False
  of_int == id
  enum_class.enum_ex == Ex
  sup == %_ _. a\<^sub>1
  sup == max
  inf == %_ _. a\<^sub>1
  inf == min
  0 == a\<^sub>1
  0 == a\<^sub>1
  0 == a\<^sub>1
  (+) == %_ _. a\<^sub>1
  size_nat == nat_of_natural
  Code_Numeral.positive == numeral
  Code_Numeral.negative == uminus o numeral
  sgn == %_. a\<^sub>1
  1 == a\<^sub>1
  1 == a\<^sub>2
  1 == a\<^sub>2
  1 == Suc 0
  abs == %_. a\<^sub>1
  Code_Numeral.Pos == numeral
  String.Literal' == String.Literal
  Int.Pos == numeral
  %u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y
  %u. EX x y. u = (x, y) & ?y (x, y) == ?y
  %a. ?y () == ?y
  %A f. Inf (f ` A) == Ball
  %A f. Sup (f ` A) == Bex
  division_segment (1::?'a1) == 1::?'a1
  division_segment ?x1 == 1
  division_segment ?x1 == 1
  division_segment ?n1 == 1
  division_segment (of_nat ?n1) == 1::?'a1
  division_segment (numeral ?k1) == 1::?'a1
  char_of (of_char ?y) == ?y
  char_of (of_nat ?n1) == char_of ?n1
  char_of (?n1 mod (256::?'a1)) == char_of ?n1
  divides_aux (?q1, ?r1) == ?r1 = (0::?'a1)
  euclidean_size (0::?'a1) == 0
  euclidean_size (1::?'a1) == 1
  euclidean_size ?x1 == case ?x1 of a\<^sub>1 => 0 | a\<^sub>2 => 1
  euclidean_size ?x1 == case ?x1 of a\<^sub>1 => 0 | _ => 1
  euclidean_size ?x1 == euclidean_size (nat_of_natural ?x1)
  euclidean_size ?x1 == euclidean_size (int_of_integer ?x1)
  euclidean_size (of_nat ?y) == ?y
  euclidean_size (numeral ?k1) == numeral ?k1
  bdd_below {} == True
  bdd_below ?A1 == True
  finite ?A1 ==> bdd_below ?A1 == True
  bdd_below {?a1<..} == True
  finite ?I1 ==>
  bdd_below (\<Union> (?A1 ` ?I1)) == ALL i:?I1. bdd_below (?A1 i)
  bdd_below {?a1..} == True
  bdd_below {?a1<..<?b1} == True
  bdd_below {?a1<..?b1} == True
  bdd_below {?a1..<?b1} == True
  bdd_below {?a1..?b1} == True
  bdd_below (?A1 Un ?B1) == bdd_below ?A1 & bdd_below ?B1
  bdd_below ?A1 ==> bdd_below (?A1 Int ?B1) == True
  bdd_below ?B1 ==> bdd_below (?A1 Int ?B1) == True
  bdd_below (insert ?a1 ?A1) == bdd_below ?A1
  bdd_below (uminus ` ?X1) == bdd_above ?X1
  bdd_below ((%x. inf (?f1 x) (?g1 x)) ` ?A1) ==
  bdd_below (?f1 ` ?A1) & bdd_below (?g1 ` ?A1)
  bdd_above {} == True
  bdd_above ?A1 == True
  finite ?A1 ==> bdd_above ?A1 == True
  bdd_above {..<?b1} == True
  finite ?I1 ==>
  bdd_above (\<Union> (?A1 ` ?I1)) == ALL i:?I1. bdd_above (?A1 i)
  bdd_above {..?b1} == True
  bdd_above {?a1<..<?b1} == True
  bdd_above {?a1<..?b1} == True
  bdd_above {?a1..<?b1} == True
  bdd_above {?a1..?b1} == True
  bdd_above (?A1 Un ?B1) == bdd_above ?A1 & bdd_above ?B1
  bdd_above ?A1 ==> bdd_above (?A1 Int ?B1) == True
  bdd_above ?B1 ==> bdd_above (?A1 Int ?B1) == True
  bdd_above (insert ?a1 ?A1) == bdd_above ?A1
  bdd_above (uminus ` ?X1) == bdd_below ?X1
  bdd_above ((%x. sup (?f1 x) (?g1 x)) ` ?A1) ==
  bdd_above (?f1 ` ?A1) & bdd_above (?g1 ` ?A1)
  push_bit 0 == id
  drop_bit 0 == id
  lazy_sequence_of_list (list_of_lazy_sequence ?y) == ?y
  mask 0 == 0::?'a1
  mask (Suc 0) == 1::?'a1
  not (0::?'a1) == - (1::?'a1)
  not (1::?'a1) == - (2::?'a1)
  not (not ?y) == ?y
  not (- (1::?'a1)) == 0::?'a1
  not (- numeral ?n1) == neg_numeral_class.sub ?n1 num.One
  not (numeral ?n1) == - numeral (Num.inc ?n1)
  not (and ?x1 ?y1) == or (not ?x1) (not ?y1)
  not (or ?x1 ?y1) == and (not ?x1) (not ?y1)
  normalize (0::?'a1) == 0::?'a1
  normalize (0::?'a1) == 0::?'a1
  normalize (1::?'a1) == 1::?'a1
  normalize (1::?'a1) == 1::?'a1
  normalize ?x1 == case ?x1 of a\<^sub>3 => a\<^sub>2 | _ => ?x1
  normalize (normalize ?a1) == normalize ?a1
  ?a1 ~= (0::?'a1) ==> normalize (unit_factor ?a1) == 1::?'a1
  normalize (Lcm\<^sub>f\<^sub>i\<^sub>n ?A1) ==
  Lcm\<^sub>f\<^sub>i\<^sub>n ?A1
  normalize (Gcd\<^sub>f\<^sub>i\<^sub>n ?A1) ==
  Gcd\<^sub>f\<^sub>i\<^sub>n ?A1
  normalize (Lcm ?A1) == Lcm ?A1
  normalize (Gcd ?A1) == Gcd ?A1
  is_unit ?b1 ==> normalize (?a1 * ?b1) == normalize ?a1
  is_unit ?a1 ==> normalize (?a1 * ?b1) == normalize ?b1
  normalize (?a1 * normalize ?b1) == normalize (?a1 * ?b1)
  normalize (normalize ?a1 * ?b1) == normalize (?a1 * ?b1)
  normalize (lcm ?a1 ?b1) == lcm ?a1 ?b1
  normalize (gcd ?a1 ?b1) == gcd ?a1 ?b1
  \<Squnion>\<^sub>f\<^sub>i\<^sub>n {?y} == ?y
  [| finite ?A1; ?A1 ~= {} |]
  ==> \<Squnion>\<^sub>f\<^sub>i\<^sub>n insert ?x1 ?A1 ==
      sup ?x1 (\<Squnion>\<^sub>f\<^sub>i\<^sub>n ?A1)
  \<Sqinter>\<^sub>f\<^sub>i\<^sub>n {?y} == ?y
  [| finite ?A1; ?A1 ~= {} |]
  ==> \<Sqinter>\<^sub>f\<^sub>i\<^sub>n insert ?x1 ?A1 ==
      inf ?x1 (\<Sqinter>\<^sub>f\<^sub>i\<^sub>n ?A1)
  small_lazy ?d1 ==
  Lazy_Sequence.append (Lazy_Sequence.single [])
   (if 0 < ?d1
    then Lazy_Sequence.bind
          (Lazy_Sequence.product (small_lazy (?d1 - 1))
            (small_lazy (?d1 - 1)))
          (%(x, xs). Lazy_Sequence.single (x # xs))
    else Lazy_Sequence.empty)
  prod_list [] == 1::?'a1
  prod_list (rev ?xs1) == prod_list ?xs1
  prod_list (?x1 # ?xs1) == ?x1 * prod_list ?xs1
  prod_list (?xs1 @ ?ys1) == prod_list ?xs1 * prod_list ?ys1
  sorted_list_of_set {} == []
  infinite ?A1 ==> sorted_list_of_set ?A1 == []
  sorted_list_of_set {..<Suc ?k1} == sorted_list_of_set {..<?k1} @ [?k1]
  sorted_list_of_set {..Suc ?k1} == sorted_list_of_set {..?k1} @ [Suc ?k1]
  sorted_list_of_set {?m1..<?n1} == [?m1..<?n1]
  finite ?A1 ==>
  sorted_list_of_set (insert ?x1 ?A1) ==
  insort ?x1 (sorted_list_of_set (?A1 - {?x1}))
  [| finite ?A1; ?x1 ~: ?A1 |]
  ==> sorted_list_of_set (insert ?x1 ?A1) ==
      insort ?x1 (sorted_list_of_set ?A1)
  bit (0::?'a1) == bot
  sum_list [] == 0::?'a1
  sum_list (rev ?xs1) == sum_list ?xs1
  sum_list (?x1 # ?xs1) == ?x1 + sum_list ?xs1
  SUM x<-?xs1. (0::?'a1) == 0::?'a1
  sum_list (?xs1 @ ?ys1) == sum_list ?xs1 + sum_list ?ys1
  ?m1 <= ?n1 ==> sum_list [?m1..<?n1] == \<Sum> {?m1..<?n1}
  of_char (char_of ?a1) == ?a1 mod (256::?'a1)
  of_char (String.ascii_of ?c1) == take_bit 7 (of_char ?c1)
  of_char (Char ?b0.1 ?b1.1 ?b2.1 ?b3.1 ?b4.1 ?b5.1 ?b6.1 ?b7.1) ==
  horner_sum of_bool (2::?'a1)
   [?b0.1, ?b1.1, ?b2.1, ?b3.1, ?b4.1, ?b5.1, ?b6.1, ?b7.1]
  fact 0 == 1::?'a1
  fact 1 == 1::?'a1
  fact 2 == 2::?'a1
  fact (Suc 0) == 1::?'a1
  fact (Suc ?n1) == of_nat (Suc ?n1) * fact ?n1
  unit_factor 0 == 0
  unit_factor (0::?'a1) == 0::?'a1
  unit_factor (1::?'a1) == 1::?'a1
  ?a1 ~= (0::?'a1) ==> unit_factor (normalize ?a1) == 1::?'a1
  unit_factor (unit_factor ?a1) == unit_factor ?a1
  unit_factor (Suc ?n1) == 1
  ?a1 dvd (1::?'a1) ==> unit_factor (?b1 * ?a1) == unit_factor ?b1 * ?a1
  ?a1 dvd (1::?'a1) ==> unit_factor (?a1 * ?b1) == ?a1 * unit_factor ?b1
  unit_factor (lcm ?a1 ?b1) ==
  if ?a1 = (0::?'a1) | ?b1 = (0::?'a1) then 0::?'a1 else (1::?'a1)
  list_of_lazy_sequence hit_bound == [None]
  list_of_lazy_sequence Lazy_Sequence.empty == []
  list_of_lazy_sequence (lazy_sequence_of_list ?y) == ?y
  list_of_lazy_sequence (Lazy_Sequence ?f1) ==
  case ?f1 () of None => [] | Some (x, xq) => x # list_of_lazy_sequence xq
  list_of_lazy_sequence (hb_flat ?xqq1) ==
  concat
   (map ((%x. case x of None => [None] | Some xs => xs) o
         map_option list_of_lazy_sequence)
     (list_of_lazy_sequence ?xqq1))
  list_of_lazy_sequence (Lazy_Sequence.single ?x1) == [?x1]
  list_of_lazy_sequence (Lazy_Sequence.flat ?xqq1) ==
  concat (map list_of_lazy_sequence (list_of_lazy_sequence ?xqq1))
  list_of_lazy_sequence (Lazy_Sequence.append ?xq1 ?yq1) ==
  list_of_lazy_sequence ?xq1 @ list_of_lazy_sequence ?yq1
  list_of_lazy_sequence (Lazy_Sequence.map ?f1 ?xq1) ==
  map ?f1 (list_of_lazy_sequence ?xq1)
  natural_of_nat (nat_of_natural ?y) == ?y
  nat_of_natural 0 == 0
  nat_of_natural 1 == 1
  nat_of_natural (division_segment ?x1) ==
  division_segment (nat_of_natural ?x1)
  nat_of_natural (natural_of_nat ?y) == ?y
  nat_of_natural (of_nat ?y) == ?y
  nat_of_natural (numeral ?k1) == numeral ?k1
  nat_of_natural (Code_Numeral.Suc ?x1) == Suc (nat_of_natural ?x1)
  nat_of_natural (?x1 mod ?xa1) ==
  nat_of_natural ?x1 mod nat_of_natural ?xa1
  nat_of_natural (?x1 div ?xa1) ==
  nat_of_natural ?x1 div nat_of_natural ?xa1
  nat_of_natural (?x1 * ?xa1) == nat_of_natural ?x1 * nat_of_natural ?xa1
  nat_of_natural (?x1 - ?xa1) == nat_of_natural ?x1 - nat_of_natural ?xa1
  nat_of_natural (min ?k1 ?l1) ==
  min (nat_of_natural ?k1) (nat_of_natural ?l1)
  nat_of_natural (max ?k1 ?l1) ==
  max (nat_of_natural ?k1) (nat_of_natural ?l1)
  nat_of_natural (?x1 + ?xa1) == nat_of_natural ?x1 + nat_of_natural ?xa1
  integer_of_int (int_of_integer ?y) == ?y
  int_of_integer 0 == 0
  int_of_integer 1 == 1
  int_of_integer (division_segment ?x1) ==
  division_segment (int_of_integer ?x1)
  int_of_integer (integer_of_int ?y) == ?y
  int_of_integer (integer_of_natural ?n1) == int (nat_of_natural ?n1)
  int_of_integer (of_nat ?n1) == int ?n1
  int_of_integer (integer_of_nat ?n1) == int ?n1
  int_of_integer (- ?x1) == - int_of_integer ?x1
  int_of_integer (numeral ?k1) == numeral ?k1
  int_of_integer (of_int ?y) == ?y
  int_of_integer (sgn ?x1) == sgn (int_of_integer ?x1)
  int_of_integer \<bar>?x1\<bar> == \<bar>int_of_integer ?x1\<bar>
  int_of_integer (?x1 mod ?xa1) ==
  int_of_integer ?x1 mod int_of_integer ?xa1
  int_of_integer (?x1 div ?xa1) ==
  int_of_integer ?x1 div int_of_integer ?xa1
  int_of_integer (neg_numeral_class.sub ?k1 ?l1) ==
  neg_numeral_class.sub ?k1 ?l1
  int_of_integer (?x1 * ?xa1) == int_of_integer ?x1 * int_of_integer ?xa1
  int_of_integer (?x1 - ?xa1) == int_of_integer ?x1 - int_of_integer ?xa1
  int_of_integer (min ?k1 ?l1) ==
  min (int_of_integer ?k1) (int_of_integer ?l1)
  int_of_integer (max ?k1 ?l1) ==
  max (int_of_integer ?k1) (int_of_integer ?l1)
  int_of_integer (?x1 + ?xa1) == int_of_integer ?x1 + int_of_integer ?xa1
  CHAR(?'a1) == 0
  typerep_of ?x1 == TYPEREP(?'a1)
  of_bool False == 0::?'a1
  of_bool True == 1::?'a1
  of_bool (~ ?P1) == (1::?'a1) - of_bool ?P1
  of_bool (?P1 | ?Q1) == max (of_bool ?P1) (of_bool ?Q1)
  {..<0} == {}
  Min {?y} == ?y
  [| finite ?A1; ?A1 ~= {} |] ==> Min (insert ?x1 ?A1) == min ?x1 (Min ?A1)
  [| finite ?A1; ?A1 ~= {} |] ==> MIN _\<in>?A1. ?y == ?y
  ?n1 ~= 0 ==> Max {d. d dvd ?n1} == \<bar>?n1\<bar>
  ?y ~= 0 ==> Max {d. d dvd ?y} == ?y
  Max {?y} == ?y
  [| finite ?A1; ?A1 ~= {} |] ==> Max (insert ?x1 ?A1) == max ?x1 (Max ?A1)
  [| finite ?A1; ?A1 ~= {} |] ==> MAX _\<in>?A1. ?y == ?y
  Sup UNIV == top
  Sup {} == 0
  Sup {} == bot
  Sup ?uu1 == ()
  Sup ?A1 == True : ?A1
  ?x1 < top ==> Sup {?x1<..} == top
  Sup {..<?y} == ?y
  Sup {..<?y} == ?y
  Sup {?x1..} == top
  Sup {..?y} == ?y
  Sup {..?y} == ?y
  \<Union> (Pow ?y) == ?y
  ?y1 < ?y ==> Sup {?y1<..<?y} == ?y
  ?x1 < ?y ==> Sup {?x1<..<?y} == ?y
  ?y1 < ?y ==> Sup {?y1<..?y} == ?y
  ?x1 < ?y ==> Sup {?x1<..?y} == ?y
  ?y1 < ?y ==> Sup {?y1..<?y} == ?y
  ?x1 < ?y ==> Sup {?x1..<?y} == ?y
  ?y1 <= ?y ==> Sup {?y1..?y} == ?y
  ?x1 <= ?y ==> Sup {?x1..?y} == ?y
  \<Union> (?A1 Un ?B1) == \<Union> ?A1 Un \<Union> ?B1
  Sup {?y} == ?y
  Sup {?y} == ?y
  Sup (insert ?a1 ?A1) == sup ?a1 (Sup ?A1)
  Sup (id ` ?A1) == Sup ?A1
  ?A1 ~= {} ==> SUP x\<in>?A1. ?y == ?y
  SUP i\<in>?I1. principal (?A1 i) == principal (\<Union> (?A1 ` ?I1))
  SUP x\<in>?A1. x == Sup ?A1
  ?A1 ~= {} ==> SUP i\<in>?A1. ?y == ?y
  SUP x\<in>?A1. bot == bot
  UN y:?A1. ?c1 == if ?A1 = {} then {} else ?c1
  UN x:?y. {x} == ?y
  UN x:?C1. insert ?a1 (?B1 x) ==
  if ?C1 = {} then {} else insert ?a1 (\<Union> (?B1 ` ?C1))
  UN x:?C1. ?A1 x Un ?B1 ==
  if ?C1 = {} then {} else \<Union> (?A1 ` ?C1) Un ?B1
  UN x:?C1. ?A1 Un ?B1 x ==
  if ?C1 = {} then {} else ?A1 Un \<Union> (?B1 ` ?C1)
  UN x:?C1. ?A1 x Int ?B1 == \<Union> (?A1 ` ?C1) Int ?B1
  UN x:?C1. ?A1 Int ?B1 x == ?A1 Int \<Union> (?B1 ` ?C1)
  UN x:?C1. ?A1 x - ?B1 == \<Union> (?A1 ` ?C1) - ?B1
  UN x:?C1. ?A1 - ?B1 x == ?A1 - \<Inter> (?B1 ` ?C1)
  \<Union> (?B1 ` \<Union> ?A1) == UN y:?A1. \<Union> (?B1 ` y)
  \<Union> (?C1 ` \<Union> (?B1 ` ?A1)) == UN x:?A1. \<Union> (?C1 ` ?B1 x)
  \<Union> (?M1 ` (?A1 Un ?B1)) ==
  \<Union> (?M1 ` ?A1) Un \<Union> (?M1 ` ?B1)
  \<Union> (?B1 ` insert ?a1 ?A1) == ?B1 ?a1 Un \<Union> (?B1 ` ?A1)
  \<Union> (?B1 ` ?f1 ` ?A1) == UN a:?A1. ?B1 (?f1 a)
  Inf UNIV == bot
  Inf {} == top
  Inf ?uu1 == ()
  Inf ?A1 == False ~: ?A1
  Inf {?y<..} == ?y
  Inf {?y<..} == ?y
  top < ?x1 ==> Inf {..<?x1} == bot
  Inf {?y..} == ?y
  Inf {?y..} == ?y
  Inf {..?x1} == bot
  ?y < ?x1 ==> Inf {?y<..<?x1} == ?y
  ?y < ?y1 ==> Inf {?y<..<?y1} == ?y
  ?y < ?x1 ==> Inf {?y<..?x1} == ?y
  ?y < ?y1 ==> Inf {?y<..?y1} == ?y
  ?y < ?x1 ==> Inf {?y..<?x1} == ?y
  ?y < ?y1 ==> Inf {?y..<?y1} == ?y
  ?y <= ?x1 ==> Inf {?y..?x1} == ?y
  ?y <= ?y1 ==> Inf {?y..?y1} == ?y
  Inf {?y} == ?y
  Inf (insert ?a1 ?A1) == inf ?a1 (Inf ?A1)
  Inf (id ` ?A1) == Inf ?A1
  ?A1 ~= {} ==> INF x\<in>?A1. ?y == ?y
  INF x\<in>?A1. x == Inf ?A1
  ?A1 ~= {} ==> INF i\<in>?A1. ?y == ?y
  INF x\<in>?A1. top == top
  INT y:?A1. ?c1 == if ?A1 = {} then UNIV else ?c1
  INT x:?C1. ?A1 x Int ?B1 ==
  if ?C1 = {} then UNIV else \<Inter> (?A1 ` ?C1) Int ?B1
  INT x:?C1. ?A1 Int ?B1 x ==
  if ?C1 = {} then UNIV else ?A1 Int \<Inter> (?B1 ` ?C1)
  INT x:?C1. ?A1 x - ?B1 ==
  if ?C1 = {} then UNIV else \<Inter> (?A1 ` ?C1) - ?B1
  INT x:?C1. ?A1 - ?B1 x ==
  if ?C1 = {} then UNIV else ?A1 - \<Union> (?B1 ` ?C1)
  INT x:?C1. insert ?a1 (?B1 x) == insert ?a1 (\<Inter> (?B1 ` ?C1))
  INT x:?C1. ?A1 x Un ?B1 == \<Inter> (?A1 ` ?C1) Un ?B1
  INT x:?C1. ?A1 Un ?B1 x == ?A1 Un \<Inter> (?B1 ` ?C1)
  \<Inter> (?B1 ` \<Union> ?A1) == INT y:?A1. \<Inter> (?B1 ` y)
  \<Inter> (?C1 ` \<Union> (?B1 ` ?A1)) == INT x:?A1. \<Inter> (?C1 ` ?B1 x)
  \<Inter> (?B1 ` insert ?a1 ?A1) == ?B1 ?a1 Int \<Inter> (?B1 ` ?A1)
  \<Inter> (?B1 ` ?f1 ` ?A1) == INT a:?A1. ?B1 (?f1 a)
  natural_of_integer (integer_of_natural ?y) == ?y
  integer_of_natural (natural_of_integer ?k1) == max 0 ?k1
  integer_of_natural (of_nat ?n1) == of_nat ?n1
  {{}..} == UNIV
  {0..} == UNIV
  ??.Quickcheck_Narrowing.non_empty (Narrowing_sum_of_products ?ps1) ==
  ~ List.null ?ps1
  Lcm\<^sub>f\<^sub>i\<^sub>n {} == 1::?'a1
  finite ?A1 ==> Lcm\<^sub>f\<^sub>i\<^sub>n ?A1 == Lcm ?A1
  infinite ?A1 ==> Lcm\<^sub>f\<^sub>i\<^sub>n ?A1 == 0::?'a1
  Lcm\<^sub>f\<^sub>i\<^sub>n (insert ?a1 ?A1) ==
  lcm ?a1 (Lcm\<^sub>f\<^sub>i\<^sub>n ?A1)
  Gcd\<^sub>f\<^sub>i\<^sub>n {} == 0::?'a1
  finite ?A1 ==> Gcd\<^sub>f\<^sub>i\<^sub>n ?A1 == Gcd ?A1
  infinite ?A1 ==> Gcd\<^sub>f\<^sub>i\<^sub>n ?A1 == 1::?'a1
  Gcd\<^sub>f\<^sub>i\<^sub>n (insert ?a1 ?A1) ==
  gcd ?a1 (Gcd\<^sub>f\<^sub>i\<^sub>n ?A1)
  {..UNIV} == UNIV
  {..0} == {0}
  neg_numeral_class.dbl_inc (0::?'a1) == 1::?'a1
  neg_numeral_class.dbl_inc (1::?'a1) == 3::?'a1
  neg_numeral_class.dbl_inc (- (1::?'a1)) == - (1::?'a1)
  neg_numeral_class.dbl_inc (- numeral ?k1) ==
  - neg_numeral_class.dbl_dec (numeral ?k1)
  neg_numeral_class.dbl_inc (numeral ?k1) == numeral (num.Bit1 ?k1)
  neg_numeral_class.dbl_dec (0::?'a1) == - (1::?'a1)
  neg_numeral_class.dbl_dec (1::?'a1) == 1::?'a1
  neg_numeral_class.dbl_dec (- (1::?'a1)) == - (3::?'a1)
  neg_numeral_class.dbl_dec (- numeral ?k1) ==
  - neg_numeral_class.dbl_inc (numeral ?k1)
  neg_numeral_class.dbl_dec (numeral ?k1) == numeral (Num.BitM ?k1)
  size_typerep (typerep.Typerep ?x1.1 ?x2.1) ==
  size_list size_typerep ?x2.1 + Suc 0
  inverse (0::?'a1) == 0::?'a1
  inverse (1::?'a1) == 1::?'a1
  inverse (inverse ?y) == ?y
  inverse (- ?a1) == - inverse ?a1
  inverse (- numeral ?w1) == (1::?'a1) / - numeral ?w1
  inverse (numeral ?w1) == (1::?'a1) / numeral ?w1
  inverse (sgn ?a1) == sgn ?a1
  inverse (?a1 / ?b1) == ?b1 / ?a1
  inverse (?a1 * ?b1) == inverse ?a1 * inverse ?b1
  ?r1^**^** == ?r1^**
  ?R1^++^** == ?R1^**
  (equivclp ?r1)^** == equivclp ?r1
  ?R1^==^** == ?R1^**
  %(x, y). (x, y) == id
  %(a, b). ?P1 & ?Q1 a b == %ab. ?P1 & (case ab of (x, xa) => ?Q1 x xa)
  %(x, y). curry ?y x y == ?y
  of_nat 0 == 0::?'a1
  of_nat 1 == 1::?'a1
  of_nat ?y == ?y
  of_nat (fact ?n1) == fact ?n1
  of_nat (nat_of_natural ?y) == ?y
  of_nat CHAR(?'a1) == 0::?'a1
  of_nat (of_bool ?P1) == of_bool ?P1
  of_nat (nat_of_integer ?k1) == max 0 ?k1
  of_nat (numeral ?n1) == numeral ?n1
  of_nat (Suc ?m1) == (1::?'a1) + of_nat ?m1
  0 <= ?z1 ==> of_nat (nat ?z1) == of_int ?z1
  int (nat ?z1) == if 0 <= ?z1 then ?z1 else 0
  of_nat (nat (take_bit ?n1 ?k1)) == of_int (take_bit ?n1 ?k1)
  of_nat (prod ?f1 ?A1) == PROD x:?A1. of_nat (?f1 x)
  of_nat (sum ?f1 ?A1) == SUM x:?A1. of_nat (?f1 x)
  of_nat (?m1 * ?n1) == of_nat ?m1 * of_nat ?n1
  of_nat (?m1 ^ ?n1) == of_nat ?m1 ^ ?n1
  of_nat (?m1 + ?n1) == of_nat ?m1 + of_nat ?n1
  ?k1 <= 0 ==> nat_of_integer ?k1 == 0
  nat_of_integer (of_nat ?y) == ?y
  nat_of_integer (integer_of_nat ?y) == ?y
  ?R1^**^++ == ?R1^**
  (equivclp ?r1)^++ == equivclp ?r1
  {}^* == Id
  (?r1^*)^* == ?r1^*
  (?R1^+)^* == ?R1^*
  (?R1^=)^* == ?R1^*
  acyclic (?r1^-1) == acyclic ?r1
  acyclicP ?r1^--1 == acyclicP ?r1
  acyclic (insert (?y1, ?x1) ?r1) == acyclic ?r1 & (?x1, ?y1) ~: ?r1^*
  - top == bot
  - bot == top
  - (0::?'a1) == 0::?'a1
  - ?uu1 == ()
  - not (numeral ?n1) == numeral (Num.inc ?n1)
  - {?k1<..} == {..?k1}
  - {..<?k1} == {?k1..}
  [| finite ?S1; ?S1 ~= {} |] ==> - Min ?S1 == Max (uminus ` ?S1)
  [| finite ?S1; ?S1 ~= {} |] ==> - Max ?S1 == Min (uminus ` ?S1)
  - \<Union> (?B1 ` ?A1) == INT x:?A1. - ?B1 x
  - \<Inter> (?B1 ` ?A1) == UN x:?A1. - ?B1 x
  - {?k1..} == {..<?k1}
  - {..?k1} == {?k1<..}
  - (- ?y) == ?y
  - (- ?y) == ?y
  - (?A1 - ?B1) == - ?A1 Un ?B1
  - (?a1 - ?b1) == ?b1 - ?a1
  - sup ?x1 ?y1 == inf (- ?x1) (- ?y1)
  - inf ?x1 ?y1 == sup (- ?x1) (- ?y1)
  - (?a1 + ?b1) == - ?a1 + - ?b1
  - (UNIV \<times> ?A1) == UNIV \<times> - ?A1
  - (?A1 \<times> UNIV) == (- ?A1) \<times> UNIV
  {}^+ == {}
  trans ?y ==> ?y^+ == ?y
  (?R1^*)^+ == ?R1^*
  (?r1^=)^+ == ?r1^*
  symclp (symclp ?r1) == symclp ?r1
  symclp (equivclp ?r1) == equivclp ?r1
  symclp ?r1^--1 == symclp ?r1
  ?P1 0 ==> Least ?P1 == 0
  Numeral1 == 1::?'a1
  2 == a\<^sub>1
  2 == a\<^sub>3
  neg_numeral_class.dbl (0::?'a1) == 0::?'a1
  neg_numeral_class.dbl (1::?'a1) == 2::?'a1
  neg_numeral_class.dbl (- (1::?'a1)) == - (2::?'a1)
  neg_numeral_class.dbl (- numeral ?k1) ==
  - neg_numeral_class.dbl (numeral ?k1)
  neg_numeral_class.dbl (numeral ?k1) == numeral (num.Bit0 ?k1)
  String.literal_of_asciis [] == STR ''''
  String.literal_of_asciis (String.asciis_of_literal ?y) == ?y
  String.literal_of_asciis (?k1 # ?ks1) ==
  case char_of ?k1 of
  Char b0 b1 b2 b3 b4 b5 b6 b7 =>
    String.Literal b0 b1 b2 b3 b4 b5 b6 (String.literal_of_asciis ?ks1)
  String.asciis_of_literal STR '''' == []
  String.asciis_of_literal
   (String.Literal ?b0.1 ?b1.1 ?b2.1 ?b3.1 ?b4.1 ?b5.1 ?b6.1 ?s1) ==
  of_char (Char ?b0.1 ?b1.1 ?b2.1 ?b3.1 ?b4.1 ?b5.1 ?b6.1 False) #
  String.asciis_of_literal ?s1
  set_option None == {}
  set_option (Some ?x2.1) == {?x2.1}
  set_option (Option.bind ?x1 ?f1) ==
  \<Union> ((set_option o ?f1) ` set_option ?x1)
  equivclp (symclp ?r1) == equivclp ?r1
  equivclp ?r1^--1 == equivclp ?r1
  single_valuedp bot == True
  top ?x1 == top
  bot ?x1 == bot
  iszero (0::?'a1) == True
  iszero (1::?'a1) == False
  iszero (- (1::?'a1)) == False
  iszero (- numeral ?w1) == iszero (numeral ?w1)
  iszero (numeral ?w1) == False
  of_int 0 == 0::?'a1
  of_int 1 == 1::?'a1
  of_int (fact ?n1) == fact ?n1
  of_int (int_of_integer ?y) == ?y
  of_int (of_bool ?P1) == of_bool ?P1
  of_int (int ?n1) == of_nat ?n1
  of_int (- ?z1) == - of_int ?z1
  of_int (numeral ?k1) == numeral ?k1
  of_int \<bar>?x1\<bar> == \<bar>of_int ?x1\<bar>
  of_int (prod ?f1 ?A1) == PROD x:?A1. of_int (?f1 x)
  of_int (sum ?f1 ?A1) == SUM x:?A1. of_int (?f1 x)
  of_int (?w1 * ?z1) == of_int ?w1 * of_int ?z1
  of_int (?w1 - ?z1) == of_int ?w1 - of_int ?z1
  of_int (?z1 ^ ?n1) == of_int ?z1 ^ ?n1
  of_int (?w1 + ?z1) == of_int ?w1 + of_int ?z1
  literal.explode (String.implode ?cs1) == map String.ascii_of ?cs1
  single_valued {} == True
  single_valued Id == True
  single_valued (Id_on ?A1) == True
  prod.swap (prod.swap ?y) == ?y
  prod.swap (?x1, ?y1) == (?y1, ?x1)
  Filter.abstract_filter ?f1 == ?f1 ()
  equivp (symclp ?r1)^** == True
  equivp (equivclp ?r1) == True
  right_unique ?A1^--1 == left_unique ?A1
  size_char (Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1) == 0
  snd (prod.swap ?x1) == fst ?x1
  snd (divmod_integer ?k1 ?l1) == ?k1 mod ?l1
  snd (Code_Numeral.divmod_abs ?k1 ?l1) ==
  \<bar>?k1\<bar> mod \<bar>?l1\<bar>
  snd (apsnd ?f1 ?x1) == ?f1 (snd ?x1)
  snd (apfst ?f1 ?x1) == snd ?x1
  snd (divmod_nat ?m1 ?n1) == ?m1 mod ?n1
  snd (?x1.1, ?y) == ?y
  snd (map_prod ?f1 ?g1 ?x1) == ?g1 (snd ?x1)
  fst (prod.swap ?x1) == snd ?x1
  fst (divmod_integer ?k1 ?l1) == ?k1 div ?l1
  fst (Code_Numeral.divmod_abs ?k1 ?l1) ==
  \<bar>?k1\<bar> div \<bar>?l1\<bar>
  fst (apsnd ?f1 ?x1) == fst ?x1
  fst (apfst ?f1 ?x1) == ?f1 (fst ?x1)
  fst (divmod_nat ?m1 ?n1) == ?m1 div ?n1
  fst (?y, ?x2.1) == ?y
  fst (map_prod ?f1 ?g1 ?x1) == ?f1 (fst ?x1)
  Predicate.pred_of_seq seq.Empty == bot
  Predicate.pred_of_seq (seq.Insert ?x1 ?P1) ==
  sup (Predicate.single ?x1) ?P1
  Predicate.pred_of_seq (seq.Join ?P1 ?xq1) ==
  sup ?P1 (Predicate.pred_of_seq ?xq1)
  right_total ?A1^--1 == left_total ?A1
  left_unique ?A1^--1 == right_unique ?A1
  sgn (0::?'a1) == 0::?'a1
  sgn (1::?'a1) == 1::?'a1
  ?a1 < (0::?'a1) ==> sgn ?a1 == - (1::?'a1)
  (0::?'a1) < ?a1 ==> sgn ?a1 == 1::?'a1
  sgn (inverse ?a1) == inverse (sgn ?a1)
  sgn (of_nat ?n1) == of_bool (0 < ?n1)
  sgn (- ?a1) == - sgn ?a1
  sgn (sgn ?a1) == sgn ?a1
  sgn \<bar>?a1\<bar> == of_bool (?a1 ~= (0::?'a1))
  sgn (?a1 / ?b1) == sgn ?a1 / sgn ?b1
  sgn (?a1 ^ ?n1) == sgn ?a1 ^ ?n1
  sgn (?a1 powi ?n1) == sgn ?a1 powi ?n1
  \<bar>0::?'a1\<bar> == 0::?'a1
  \<bar>0::?'a1\<bar> == 0::?'a1
  \<bar>1::?'a1\<bar> == 1::?'a1
  ?a1 <= (0::?'a1) ==> \<bar>?a1\<bar> == - ?a1
  (0::?'a1) <= ?y ==> \<bar>?y\<bar> == ?y
  \<bar>division_segment ?k1\<bar> == 1
  \<bar>of_bool ?P1\<bar> == of_bool ?P1
  \<bar>inverse ?a1\<bar> == inverse \<bar>?a1\<bar>
  \<bar>of_nat ?n1\<bar> == of_nat ?n1
  \<bar>- (1::?'a1)\<bar> == 1::?'a1
  \<bar>- ?a1\<bar> == \<bar>?a1\<bar>
  \<bar>- ?a1\<bar> == \<bar>?a1\<bar>
  \<bar>- numeral ?n1\<bar> == numeral ?n1
  \<bar>numeral ?n1\<bar> == numeral ?n1
  ?a1 ~= (0::?'a1) ==> \<bar>sgn ?a1\<bar> == 1::?'a1
  \<bar>sgn ?a1\<bar> == of_bool (?a1 ~= (0::?'a1))
  \<bar>\<bar>?a1\<bar>\<bar> == \<bar>?a1\<bar>
  \<bar>\<bar>?a1\<bar>\<bar> == \<bar>?a1\<bar>
  \<bar>Lcm ?K1\<bar> == Lcm ?K1
  \<bar>Gcd ?K1\<bar> == Gcd ?K1
  \<bar>SUM a:?A1. \<bar>?f1 a\<bar>\<bar> == SUM a:?A1. \<bar>?f1 a\<bar>
  \<bar>?a1 / ?b1\<bar> == \<bar>?a1\<bar> / \<bar>?b1\<bar>
  \<bar>?a1\<^sup>2\<bar> == ?a1\<^sup>2
  \<bar>(- ?a1) ^ ?n1\<bar> == \<bar>?a1 ^ ?n1\<bar>
  \<bar>\<bar>?a1\<bar> + \<bar>?b1\<bar>\<bar> ==
  \<bar>?a1\<bar> + \<bar>?b1\<bar>
  \<bar>lcm ?i1 ?j1\<bar> == lcm ?i1 ?j1
  \<bar>gcd ?x1 ?y1\<bar> == gcd ?x1 ?y1
  \<bar>(- ?a1) powi ?n1\<bar> == \<bar>?a1 powi ?n1\<bar>
  left_total ?A1^--1 == right_total ?A1
  pred.eval top == top
  pred.eval bot == bot
  pred.eval (Sup ?A1) == Sup (pred.eval ` ?A1)
  pred.eval (Sup (?f1 ` ?A1)) == Sup ((pred.eval o ?f1) ` ?A1)
  pred.eval (Inf ?A1) == Inf (pred.eval ` ?A1)
  pred.eval (Inf (?f1 ` ?A1)) == Inf ((pred.eval o ?f1) ` ?A1)
  pred.eval (- ?P1) == - pred.eval ?P1
  pred.eval (pred.Pred ?y) == ?y
  pred.eval (Predicate.single ?x1) == (=) ?x1
  pred.eval (?P1 - ?Q1) == pred.eval ?P1 - pred.eval ?Q1
  pred.eval (sup ?P1 ?Q1) == sup (pred.eval ?P1) (pred.eval ?Q1)
  pred.eval (inf ?P1 ?Q1) == inf (pred.eval ?P1) (pred.eval ?Q1)
  pred.eval (Predicate.bind ?P1 ?f1) ==
  pred.eval (Sup (?f1 ` {x. pred.eval ?P1 x}))
  pred.eval (Predicate.map ?f1 ?P1) ==
  SUP x\<in>{x. pred.eval ?P1 x}. (=) (?f1 x)
  pred.Pred (pred.eval ?y) == ?y
  size None == Suc 0
  length [] == 0
  size num.One == 0
  size ?y == ?y
  length (sorted_list_of_set ?A1) == card ?A1
  size (Some ?x2.1) == Suc 0
  size (Inr ?x2.1) == Suc 0
  size (Inl ?x1.1) == Suc 0
  size (num.Bit1 ?x3.1) == size ?x3.1 + Suc 0
  size (num.Bit0 ?x2.1) == size ?x2.1 + Suc 0
  length (rotate1 ?xs1) == length ?xs1
  length (tl ?xs1) == length ?xs1 - 1
  length (butlast ?xs1) == length ?xs1 - 1
  length (concat (rev ?xs1)) == length (concat ?xs1)
  length (rev ?xs1) == length ?xs1
  size (tuple_isomorphism.Tuple_Isomorphism ?x1.1 ?x2.1) == Suc 0
  length (sort_key ?f1 ?xs1) == length ?xs1
  size (typerep.Typerep ?x1.1 ?x2.1) == size_list size ?x2.1 + Suc 0
  size (?x1.1, ?x2.1) == Suc 0
  length (replicate ?y ?x1) == ?y
  length (?x21.1 # ?x22.1) == length ?x22.1 + Suc 0
  length (enumerate ?n1 ?xs1) == length ?xs1
  length (map ?f1 ?xs1) == length ?xs1
  length (List.product ?xs1 ?ys1) == length ?xs1 * length ?ys1
  length (splice ?xs1 ?ys1) == length ?xs1 + length ?ys1
  length (rotate ?n1 ?xs1) == length ?xs1
  length (filter ?P1 (map ?f1 ?xs1)) == length (filter (?P1 o ?f1) ?xs1)
  length (?xs1 @ ?ys1) == length ?xs1 + length ?ys1
  length [?i1..?j1] == nat (?j1 - ?i1 + 1)
  length (take ?n1 ?xs1) == min (length ?xs1) ?n1
  length (drop ?n1 ?xs1) == length ?xs1 - ?n1
  length (zip ?xs1 ?ys1) == min (length ?xs1) (length ?ys1)
  length [?i1..<?j1] == ?j1 - ?i1
  length (insort_key ?f1 ?x1 ?xs1) == Suc (length ?xs1)
  length (?xs1[?i1 := ?x1]) == length ?xs1
  size (Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1) == 0
  Lazy_Sequence.yield (Lazy_Sequence ?f1) == ?f1 ()
  bi_unique ?R1^--1 == bi_unique ?R1
  projr (Inr ?y) == ?y
  projl (Inl ?y) == ?y
  digit7 (String.ascii_of ?c1) == False
  digit7 (Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?y) == ?y
  digit6 (Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?y ?x8.1) == ?y
  digit5 (Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?y ?x7.1 ?x8.1) == ?y
  digit4 (Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?y ?x6.1 ?x7.1 ?x8.1) == ?y
  digit3 (Char ?x1.1 ?x2.1 ?x3.1 ?y ?x5.1 ?x6.1 ?x7.1 ?x8.1) == ?y
  digit2 (Char ?x1.1 ?x2.1 ?y ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1) == ?y
  digit1 (Char ?x1.1 ?y ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1) == ?y
  digit0 (Char ?y ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1) == ?y
  (=)^--1 == (=)
  (~=)^--1 == (~=)
  ?y^--1^--1 == ?y
  curry (%(x, y). ?y x y) == ?y
  apsnd id == id
  apfst id == id
  ?y ~= None ==> Some (the ?y) == ?y
  product_lists [] == [[]]
  product_lists (?xs1 # ?xss1) ==
  concat (map (%x. map ((#) x) (product_lists ?xss1)) ?xs1)
  SOME y. y = ?y == ?y
  SOME (x', y'). ?x1 = x' & ?y1 = y' == (?x1, ?y1)
  SOME y. ?y = y == ?y
  Divides.adjust_div (?q1, ?r1) == ?q1 + of_bool (?r1 ~= 0)
  bi_total ?R1^--1 == bi_total ?R1
  UNIV^-1 == UNIV
  {}^-1 == {}
  Id^-1 == Id
  (?y^-1)^-1 == ?y
  (Id_on ?A1)^-1 == Id_on ?A1
  (inv_image ?R1 ?f1)^-1 == inv_image (?R1^-1) ?f1
  antisymp bot == True
  antisymp (=) == True
  the (Some ?y) == ?y
  distinct_adj [] == True
  distinct_adj (remdups_adj ?xs1) == True
  distinct_adj (rev ?xs1) == distinct_adj ?xs1
  distinct_adj [?x1] == True
  distinct_adj (?x1 # ?y1 # ?xs1) == ?x1 ~= ?y1 & distinct_adj (?y1 # ?xs1)
  Lcm UNIV == 0::?'a1
  Lcm {} == 1::?'a1
  0 : ?A1 ==> Lcm ?A1 == 0
  Lcm {?a1} == normalize ?a1
  Lcm (insert ?a1 ?A1) == lcm ?a1 (Lcm ?A1)
  Lcm {?a1, ?b1} == lcm ?a1 ?b1
  Lcm (int ` ?N1) == int (Lcm ?N1)
  Lcm (abs ` ?K1) == Lcm ?K1
  LCM k\<in>?K1. nat \<bar>k\<bar> == nat (Lcm ?K1)
  Gcd UNIV == 1::?'a1
  Gcd {} == 0::?'a1
  Gcd {?a1} == normalize ?a1
  Gcd (insert ?a1 ?A1) == gcd ?a1 (Gcd ?A1)
  Gcd {?a1, ?b1} == gcd ?a1 ?b1
  Gcd (normalize ` ?A1) == Gcd ?A1
  Gcd (int ` ?N1) == int (Gcd ?N1)
  Gcd (abs ` ?K1) == Gcd ?K1
  GCD k\<in>?K1. nat \<bar>k\<bar> == nat (Gcd ?K1)
  finite UNIV == False
  finite UNIV == finite UNIV
  finite UNIV == False
  finite UNIV == finite UNIV & finite UNIV
  finite {} == True
  finite ?A1 == True
  finite {..<?k1} == True
  [| finite ?A1; !!M. M : ?A1 ==> finite M |]
  ==> finite (\<Union> ?A1) == True
  finite ?A1 ==> finite (\<Union> (?B1 ` ?A1)) == ALL x:?A1. finite (?B1 x)
  finite {..?k1} == True
  finite ?A1 ==> finite (- ?A1) == finite UNIV
  finite (?r1^+) == finite ?r1
  finite (?r1^-1) == finite ?r1
  finite (set ?xs1) == True
  ?i1 ~= 0 ==> finite {d. d dvd ?i1} == True
  0 < ?m1 ==> finite {d. d dvd ?m1} == True
  finite {i. ?a1 < i & i < ?b1} == True
  finite {i. ?a1 < i & i <= ?b1} == True
  finite {i. ?a1 <= i & i < ?b1} == True
  finite {i. ?a1 <= i & i <= ?b1} == True
  finite ?A1 ==> finite {B. B <= ?A1} == True
  finite {y. ?P1 y} ==>
  finite {x. EX y. ?P1 y & ?Q1 x y} == ALL y. ?P1 y --> finite {x. ?Q1 x y}
  finite ?A1 ==>
  finite {x. EX y:?A1. ?Q1 x y} == ALL y:?A1. finite {x. ?Q1 x y}
  finite {x. ?P1 x} ==> finite {?f1 x |x. ?P1 x} == True
  finite {x. ?P1 x} ==> finite {x. ~ ?P1 x} == finite UNIV
  finite {x. ?P1 x | ?Q1 x} == finite {x. ?P1 x} & finite {x. ?Q1 x}
  finite {x. ?P1 x} | finite {x. ?Q1 x} ==>
  finite {x. ?P1 x & ?Q1 x} == True
  finite {n. n <= ?k1} == True
  finite {n. n < ?k1} == True
  finite (Map.graph ?m1) == finite (dom ?m1)
  finite (Pow ?A1) == finite ?A1
  finite {?l1<..<?u1} == True
  finite {?l1<..<?u1} == True
  finite {?l1<..?u1} == True
  finite {?l1<..?u1} == True
  finite {?l1..<?u1} == True
  finite {?l1..<?u1} == True
  finite {?l1..?u1} == True
  finite {?l1..?u1} == True
  finite ?B1 ==> finite (?A1 - ?B1) == finite ?A1
  finite ?A1 ==> finite (?A1 - ?B1) == True
  finite (?A1 - insert ?a1 ?B1) == finite (?A1 - ?B1)
  finite (?F1 Un ?G1) == finite ?F1 & finite ?G1
  finite ?F1 | finite ?G1 ==> finite (?F1 Int ?G1) == True
  [| finite ?A1; !!a. a : ?A1 ==> finite (?B1 a) |]
  ==> finite (Sigma ?A1 ?B1) == True
  [| finite ?R1; finite ?S1 |] ==> finite (?R1 O ?S1) == True
  finite ?R1 ==> finite (?R1 `` ?A1) == True
  [| finite ?R1; finite ?A1 |] ==> finite (?R1^* `` ?A1) == True
  finite (?A1 <+> ?B1) == finite ?A1 & finite ?B1
  finite (shuffles ?xs1 ?ys1) == True
  finite (insert ?a1 ?A1) == finite ?A1
  finite ?A1 ==> finite (insert ?a1 ?A1) == True
  finite ?S1 ==> finite (Set.filter ?P1 ?S1) == True
  [| finite ?R1; 0 < ?n1 |] ==> finite (?R1 ^^ ?n1) == True
  finite ?F1 ==> finite (?h1 ` ?F1) == True
  isl (Inr ?x2.1) == False
  isl (Inl ?x1.1) == True
  is_singleton {?x1} == True
  antisym {} == True
  antisym (?r1^-1) == antisym ?r1
  antisym (Id_on ?A1) == True
  antisym (?r1^=) == antisym ?r1
  antisym {?x1} == True
  pred_numeral num.One == 0
  pred_numeral (num.Bit1 ?k1) == numeral (num.Bit0 ?k1)
  pred_numeral (num.Bit0 ?k1) == numeral (Num.BitM ?k1)
  pred_numeral (Num.inc ?k1) == numeral ?k1
  size_num num.One == 0
  size_num (num.Bit1 ?x3.1) == size_num ?x3.1 + Suc 0
  size_num (num.Bit0 ?x2.1) == size_num ?x2.1 + Suc 0
  remdups_adj [] == []
  remdups_adj (rev ?xs1) == rev (remdups_adj ?xs1)
  remdups_adj [?x1] == [?x1]
  remdups_adj (?x1 # ?y1 # ?xs1) ==
  if ?x1 = ?y1 then remdups_adj (?x1 # ?xs1)
  else ?x1 # remdups_adj (?y1 # ?xs1)
  principal UNIV == top
  principal {} == bot
  filtermap id == id
  filtermap (%x. x) == %F. F
  Code_Numeral.Neg ?n1 == - Code_Numeral.Pos ?n1
  wfP (%x y. False) == True
  String.ascii_of (Char ?b0.1 ?b1.1 ?b2.1 ?b3.1 ?b4.1 ?b5.1 ?b6.1 ?b7.1) ==
  Char ?b0.1 ?b1.1 ?b2.1 ?b3.1 ?b4.1 ?b5.1 ?b6.1 False
  transp (<=) == True
  transp (<) == True
  transp (=) == True
  transp (%x y. y < x) == True
  transp (%x y. y <= x) == True
  transp (%x y. x = ?a1 & y = ?a1) == True
  transp (%x y. False) == True
  transp ?R1^** == True
  transp (equivclp ?r1) == True
  irrefl (?r1 - Id) == True
  Domain {} == {}
  Domain Id == UNIV
  Domain (?R1^*) == UNIV
  Domain (?r1^+) == Domain ?r1
  Domain (?r1^-1) == Range ?r1
  Domain (Id_on ?y) == ?y
  Domain {(x, y). ?P1 x y} == {x. EX y. ?P1 x y}
  Domain (insert (?a1, ?b1) ?r1) == insert ?a1 (Domain ?r1)
  card UNIV == 2
  card UNIV == 1
  card {} == 0
  infinite ?A1 ==> card ?A1 == 0
  card {..<?y} == ?y
  card {..?u1} == Suc ?u1
  card (?R1^-1) == card ?R1
  card {i. i <= ?n1} == Suc ?n1
  card {i. i < ?y} == ?y
  card {?l1<..<?u1} == ?u1 - Suc ?l1
  card {?l1<..<?u1} == nat (?u1 - (?l1 + 1))
  card {?l1<..?u1} == ?u1 - ?l1
  card {?l1<..?u1} == nat (?u1 - ?l1)
  card {?l1..<?u1} == ?u1 - ?l1
  card {?l1..<?u1} == nat (?u1 - ?l1)
  card {?l1..?u1} == Suc ?u1 - ?l1
  card {?l1..?u1} == nat (?u1 - ?l1 + 1)
  [| ?a1 : ?A1; ?a1 ~: ?B1 |]
  ==> card (?A1 - insert ?a1 ?B1) == card (?A1 - ?B1) - 1
  [| finite ?A1; ALL a:?A1. finite (?B1 a) |]
  ==> card (Sigma ?A1 ?B1) == SUM a:?A1. card (?B1 a)
  [| finite ?A1; ?x1 ~: ?A1 |] ==> card (insert ?x1 ?A1) == Suc (card ?A1)
  Basic_BNFs.snds (?x1, ?y1) == {?y1}
  Basic_BNFs.setr (Inr ?x1) == {?x1}
  Basic_BNFs.setr (Inl ?x1) == {}
  Basic_BNFs.setl (Inr ?x1) == {}
  Basic_BNFs.setl (Inl ?x1) == {?x1}
  Basic_BNFs.fsts (?x1, ?y1) == {?x1}
  rel_set ?A1^--1 == (rel_set ?A1)^--1
  wf finite_psubset == True
  wf {} == True
  wf less_than == True
  wf pair_less == True
  wf (measure ?f1) == True
  wf (measures ?fs1) == True
  wf (listrel1 ?r1) == wf ?r1
  wf ?r1 ==> wf (inv_image ?r1 ?f1) == True
  wf (insert (?y1, ?x1) ?r1) == wf ?r1 & (?x1, ?y1) ~: ?r1^*
  String.implode (literal.explode ?y) == ?y
  trans {} == True
  trans less_than == True
  trans pair_less == True
  trans (?r1^+) == True
  trans (?r1^-1) == trans ?r1
  trans (Id_on ?A1) == True
  trans ?r1 ==> trans (?r1^=) == True
  [| trans ?R1.1; trans ?R2.1 |] ==> trans (?R1.1 <*lex*> ?R2.1) == True
  trans {(?a1, ?a1)} == True
  reflp (=) == True
  reflp ?R1^** == True
  reflp (equivclp ?r1) == True
  Range {} == {}
  Range Id == UNIV
  Range (?R1^*) == UNIV
  Range (?r1^+) == Range ?r1
  Range (?r1^-1) == Domain ?r1
  Range (Id_on ?y) == ?y
  Range {(x, y). ?P1 x y} == {y. EX x. ?P1 x y}
  Range (insert (?a1, ?b1) ?r1) == insert ?b1 (Range ?r1)
  Id_on {} == {}
  Field {} == {}
  Field (\<Union> ?R1) == \<Union> (Field ` ?R1)
  Field (?r1^-1) == Field ?r1
  Field (?r1 Un ?s1) == Field ?r1 Un Field ?s1
  Field (?y \<times> ?y) == ?y
  Field (insert (?a1, ?b1) ?r1) == {?a1, ?b1} Un Field ?r1
  Predicate.null seq.Empty == True
  Predicate.null (seq.Insert ?x1 ?P1) == False
  Predicate.null (seq.Join ?P1 ?xq1) ==
  Predicate.is_empty ?P1 & Predicate.null ?xq1
  Option.is_none None == True
  Option.is_none (Some ?x1) == False
  Option.is_none (map_option ?f1 ?x1) == Option.is_none ?x1
  num_of_nat 0 == num.One
  num_of_nat (numeral ?y) == ?y
  num_of_nat (Suc ?n1) ==
  if 0 < ?n1 then Num.inc (num_of_nat ?n1) else num.One
  nat_of_num num.One == Suc 0
  nat_of_num (num.Bit1 ?x1) == Suc (nat_of_num ?x1 + nat_of_num ?x1)
  nat_of_num (num.Bit0 ?x1) == nat_of_num ?x1 + nat_of_num ?x1
  transpose [] == []
  transpose ([] # ?xss1) == transpose ?xss1
  transpose ((?x1 # ?xs1) # ?xss1) ==
  (?x1 # concat (map (case_list [] (%h t. [h])) ?xss1)) #
  transpose (?xs1 # concat (map (case_list [] (%h t. [t])) ?xss1))
  symp (symclp ?r1)^** == True
  symp (symclp ?r1) == True
  symp (equivclp ?r1) == True
  min_list (?x1 # ?xs1) ==
  case ?xs1 of [] => ?x1 | a # list => min ?x1 (min_list ?xs1)
  set [] == {}
  finite ?y ==> set (sorted_list_of_set ?y) == ?y
  set (remdups_adj ?xs1) == set ?xs1
  set (rotate1 ?xs1) == set ?xs1
  set (remdups ?xs1) == set ?xs1
  set (concat ?xs1) == \<Union> (set ` set ?xs1)
  set (rev ?xs1) == set ?xs1
  set (sort_key ?f1 ?xs1) == set ?xs1
  ?n1 ~= 0 ==> set (replicate ?n1 ?x1) == {?x1}
  set (removeAll ?x1 ?xs1) == set ?xs1 - {?x1}
  set (?x21.1 # ?x22.1) == insert ?x21.1 (set ?x22.1)
  set (map ?f1 ?xs1) == ?f1 ` set ?xs1
  distinct ?xs1 ==> set (remove1 ?x1 ?xs1) == set ?xs1 - {?x1}
  set (List.product ?xs1 ?ys1) == set ?xs1 \<times> set ?ys1
  set (rotate ?n1 ?xs1) == set ?xs1
  set (List.insert ?x1 ?xs1) == insert ?x1 (set ?xs1)
  set (filter ?P1 ?xs1) == {x: set ?xs1. ?P1 x}
  set (?xs1 @ ?ys1) == set ?xs1 Un set ?ys1
  set (List.union ?xs1 ?ys1) == set ?xs1 Un set ?ys1
  set [?i1..?j1] == {?i1..?j1}
  set [?i1..<?j1] == {?i1..<?j1}
  [| ?i1 < length ?xs1; ?j1 < length ?xs1 |]
  ==> set (?xs1[?i1 := ?xs1 ! ?j1, ?j1 := ?xs1 ! ?i1]) == set ?xs1
  map id == id
  map (%x. x) == %xs. xs
  distinct [] == True
  distinct (sorted_list_of_set ?A1) == True
  distinct (rotate1 ?xs1) == distinct ?xs1
  distinct (remdups ?xs1) == True
  distinct (rev ?xs1) == distinct ?xs1
  distinct (sort_key ?f1 ?xs1) == distinct ?xs1
  distinct ?xs1 ==> distinct (takeWhile ?P1 ?xs1) == True
  distinct (?x1 # ?xs1) == ?x1 ~: set ?xs1 & distinct ?xs1
  distinct (enumerate ?n1 ?xs1) == True
  distinct ?xs1 ==> distinct (dropWhile ?P1 ?xs1) == True
  distinct ?xs1 ==> distinct (remove1 ?x1 ?xs1) == True
  distinct (rotate ?n1 ?xs1) == distinct ?xs1
  distinct (List.insert ?x1 ?xs1) == distinct ?xs1
  distinct ?xs1 ==> distinct (filter ?P1 ?xs1) == True
  distinct (?xs1 @ ?ys1) ==
  distinct ?xs1 & distinct ?ys1 & set ?xs1 Int set ?ys1 = {}
  distinct (List.union ?xs1 ?ys1) == distinct ?ys1
  distinct [?i1..?j1] == True
  distinct ?xs1 ==> distinct (take ?i1 ?xs1) == True
  distinct ?xs1 ==> distinct (nths ?xs1 ?I1) == True
  distinct ?xs1 ==> distinct (drop ?i1 ?xs1) == True
  distinct [?i1..<?j1] == True
  [| ?i1 < length ?xs1; ?j1 < length ?xs1 |]
  ==> distinct (?xs1[?i1 := ?xs1 ! ?j1, ?j1 := ?xs1 ! ?i1]) == distinct ?xs1
  ~ isl ?y ==> Inr (projr ?y) == ?y
  isl ?y ==> Inl (projl ?y) == ?y
  the_elem {?y} == ?y
  sym (?r1^-1) == sym ?r1
  sym (Id_on ?A1) == True
  Option.these {} == {}
  Option.these (insert None ?A1) == Option.these ?A1
  Option.these (insert (Some ?x1) ?A1) == insert ?x1 (Option.these ?A1)
  Option.these (Some ` ?y) == ?y
  nat.pred 0 == 0
  nat.pred (Suc ?y) == ?y
  subseqs [] == [[]]
  subseqs (?x1 # ?xs1) == let xss = subseqs ?xs1 in map ((#) ?x1) xss @ xss
  rotate1 [] == []
  length ?y <= 1 ==> rotate1 ?y == ?y
  rotate1 (?x1 # ?xs1) == ?xs1 @ [?x1]
  remdups [] == []
  remdups (?x1 # ?xs1) ==
  if ?x1 : set ?xs1 then remdups ?xs1 else ?x1 # remdups ?xs1
  remdups [?m1..<?n1] == [?m1..<?n1]
  listset [] == {[]}
  listset (?A1 # ?As1) == set_Cons ?A1 (listset ?As1)
  tl [] == []
  tl (replicate ?n1 ?x1) == replicate (?n1 - 1) ?x1
  tl (?x21.1 # ?y) == ?y
  ?xs1 ~= [] ==> tl (?xs1 @ ?ys1) == tl ?xs1 @ ?ys1
  tl [?m1..<?n1] == [Suc ?m1..<?n1]
  hd (remdups_adj ?xs1) == hd ?xs1
  ?n1 ~= 0 ==> hd (replicate ?n1 ?y) == ?y
  hd (?y # ?x22.1) == ?y
  ?xs1 ~= [] ==> hd (?xs1 @ ?ys1) == hd ?xs1
  0 < ?j1 ==> hd (take ?j1 ?xs1) == hd ?xs1
  ?y < ?j1 ==> hd [?y..<?j1] == ?y
  butlast [] == []
  butlast (rev ?xs1) == rev (tl ?xs1)
  butlast (?x1 # ?xs1) == if ?xs1 = [] then [] else ?x1 # butlast ?xs1
  butlast (?y @ [?x1]) == ?y
  {s. ?P1} == if ?P1 then UNIV else {}
  {x. x = ?a1} == {?a1}
  {x. x : ?y} == ?y
  {(a, b). ?P1 a & ?Q1 b} == Collect ?P1 \<times> Collect ?Q1
  {(a, b). ?P1} == if ?P1 then UNIV else {}
  {x. ?a1 = x} == {?a1}
  Record.repr (tuple_isomorphism.Tuple_Isomorphism ?y ?a1) == ?y
  Record.abst (tuple_isomorphism.Tuple_Isomorphism ?r1 ?y) == ?y
  Random.next (?v1, ?w1) ==
  let k = ?v1 div 53668;
      v' = Random.minus_shift 2147483563 (?v1 mod 53668 * 40014)
            (k * 12211);
      l = ?w1 div 52774;
      w' = Random.minus_shift 2147483399 (?w1 mod 52774 * 40692) (l * 3791);
      z = Random.minus_shift 2147483562 v' (w' + 1) + 1
  in (z, v', w')
  rotate 0 == id
  listsp (%x. ?A1 x & ?B1 x) == %x. listsp ?A1 x & listsp ?B1 x
  listsp (inf ?A1 ?B1) == inf (listsp ?A1) (listsp ?B1)
  concat [] == []
  concat (replicate ?i1 []) == []
  concat (?x1 # ?xs1) == ?x1 @ concat ?xs1
  concat (map (%x. [?f1 x]) ?xs1) == map ?f1 ?xs1
  concat (?xs1 @ ?ys1) == concat ?xs1 @ concat ?ys1
  (-`) id == id
  map_of [] == Map.empty
  map_of (?p1 # ?ps1) == map_of ?ps1(fst ?p1 |-> snd ?p1)
  map_of (?xs1 @ ?ys1) == map_of ?ys1 ++ map_of ?xs1
  those [] == Some []
  those (?x1 # ?xs1) ==
  case ?x1 of None => None | Some y => map_option ((#) y) (those ?xs1)
  lists UNIV == UNIV
  lists {} == {[]}
  lists (?A1 Int ?B1) == lists ?A1 Int lists ?B1
  List.coset ?xs1 == - set ?xs1
  (`) id == id
  Map.graph Map.empty == {}
  Map.graph (?m1.1 \<circ>\<^sub>m ?m2.1) ==
  Map.graph ?m2.1 O Map.graph ?m1.1
  Map.graph (?m1(?k1 |-> ?v1)) ==
  insert (?k1, ?v1) (Map.graph (?m1(?k1 := None)))
  take 0 == %xs. []
  last (remdups_adj ?xs1) == last ?xs1
  ?n1 ~= 0 ==> last (replicate ?n1 ?y) == ?y
  last (?x1 # ?xs1) == if ?xs1 = [] then ?x1 else last ?xs1
  ?ys1 ~= [] ==> last (?xs1 @ ?ys1) == last ?ys1
  ?ys1 = [] ==> last (?xs1 @ ?ys1) == last ?xs1
  last (?xs1 @ [?y]) == ?y
  ?n1 < length ?xs1 ==> last (drop ?n1 ?xs1) == last ?xs1
  ?i1 < ?j1 ==> last [?i1..<?j1] == ?j1 - 1
  drop 0 == %x. x
  (!!x. ?a = x ==> PROP ?P x) == PROP ?P ?a
  (!!x. x = ?a ==> PROP ?P x) == PROP ?P ?a
  (!!x. PROP ?V) == PROP ?V
  Num.BitM num.One == num.One
  Num.BitM (num.Bit1 ?n1) == num.Bit1 (num.Bit0 ?n1)
  Num.BitM (num.Bit0 ?n1) == num.Bit1 (Num.BitM ?n1)
  rev [] == []
  rev (rev ?y) == ?y
  rev (replicate ?n1 ?x1) == replicate ?n1 ?x1
  rev (?x1 # ?xs1) == rev ?xs1 @ [?x1]
  rev (?xs1 @ ?ys1) == rev ?ys1 @ rev ?xs1
  Pow UNIV == UNIV
  Pow {} == {{}}
  Pow (?A1 Int ?B1) == Pow ?A1 Int Pow ?B1
  Num.sqr num.One == num.One
  Num.sqr (num.Bit1 ?n1) == num.Bit1 (num.Bit0 (Num.sqr ?n1 + ?n1))
  Num.sqr (num.Bit0 ?n1) == num.Bit0 (num.Bit0 (Num.sqr ?n1))
  Num.inc num.One == num.Bit0 num.One
  Num.inc (num.Bit1 ?x1) == num.Bit0 (Num.inc ?x1)
  Num.inc (num.Bit0 ?x1) == num.Bit1 ?x1
  Suc 1 == 2
  Suc (numeral ?n1) == numeral (?n1 + num.One)
  ?y ~= 0 ==> Suc (nat.pred ?y) == ?y
  0 < ?y ==> Suc (?y - 1) == ?y
  odd ?y ==> Suc (?y - Suc 0) == ?y
  0 < ?y ==> Suc (?y - Suc 0) == ?y
  ran Map.empty == {}
  ?m1 ?a1 = None ==> ran (?m1(?a1 |-> ?b1)) == insert ?b1 (ran ?m1)
  dom Map.empty == {}
  dom (%x. Some (?f1 x)) == UNIV
  length ?xs1 = length ?ys1 ==> dom (map_of (zip ?xs1 ?ys1)) == set ?xs1
  dom (?m1 |` ?A1) == dom ?m1 Int ?A1
  dom (?m1 ++ ?n1) == dom ?n1 Un dom ?m1
  dom (map_option ?g1 o ?m1) == dom ?m1
  dom (override_on ?f1 ?g1 ?A1) ==
  dom ?f1 - {a. a : ?A1 - dom ?g1} Un {a. a : ?A1 Int dom ?g1}
  dom (?m1(?xs1 [|->] ?ys1)) == set (take (length ?ys1) ?xs1) Un dom ?m1
  dom (?f1(?x1 := ?y1)) ==
  if ?y1 = None then dom ?f1 - {?x1} else insert ?x1 (dom ?f1)
  nat 0 == 0
  nat 1 == Suc 0
  ?z1 <= 0 ==> nat ?z1 == 0
  nat (of_bool ?P1) == of_bool ?P1
  nat (int ?y) == ?y
  nat (- int ?n1) == 0
  nat (- numeral ?k1) == 0
  nat (numeral ?k1) == numeral ?k1
  Int.dup ?k1 == ?k1 + ?k1
  Int.Neg ?n1 == - Int.Pos ?n1
  THE x. x = ?y == ?y
  THE (x', y'). ?x1 = x' & ?y1 = y' == (?x1, ?y1)
  THE y. ?y = y == ?y
  ~ False == True
  ~ True == False
  infinite {?a1<..<?b1} == ?a1 < ?b1
  infinite {?a1<..?b1} == ?a1 < ?b1
  infinite {?a1..<?b1} == ?a1 < ?b1
  infinite {?a1..?b1} == ?a1 < ?b1
  ~ ~ ?y == ?y
  ~ (ALL x. ?P1 x) == EX x. ~ ?P1 x
  \<nexists>x. ?P1 x == ALL x. ~ ?P1 x
  ~ - (1::?'a1) <= - numeral ?m1 == ?m1 ~= num.One
  ~ (0::?'a1) < ?n1 == ?n1 = (0::?'a1)
  odd (of_bool ?y) == ?y
  odd (?a1 + ?b1) == odd ?a1 ~= odd ?b1
  ~ (?P1 --> ?Q1) == ?P1 & ~ ?Q1
  False ~: ?P1 ` ?A1 == Ball ?A1 ?P1
  ~ (ALL x:?A1. ?P1 x) == EX x:?A1. ~ ?P1 x
  ~ (?P1 | ?Q1) == ~ ?P1 & ~ ?Q1
  ~ (?P1 & ?Q1) == ~ ?P1 | ~ ?Q1
  ~ (EX x:?A1. ?P1 x) == ALL x:?A1. ~ ?P1 x
  a\<^sub>2 ~= ?x1 == ?x1 = a\<^sub>1
  a\<^sub>1 ~= ?x1 == ?x1 = a\<^sub>2
  ?x1 ~= a\<^sub>2 == ?x1 = a\<^sub>1
  ?x1 ~= a\<^sub>1 == ?x1 = a\<^sub>2
  ?n1 ~= 0 == 0 < ?n1
  ?x1 ~= None == EX y. ?x1 = Some y
  ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
  ?a1 mod (2::?'a1) ~= (0::?'a1) == ?a1 mod (2::?'a1) = (1::?'a1)
  ?a1 mod (2::?'a1) ~= (1::?'a1) == ?a1 mod (2::?'a1) = (0::?'a1)
  ?n1 mod 2 ~= Suc 0 == ?n1 mod 2 = 0
  EX! x. x = ?t1 == True
  EX! x. ?t1 = x == True
  ALL y. ?x1 ~= Some y == ?x1 = None
  ALL x. ?P1 x == ALL a b. ?P1 (a, b)
  ALL x. x ~: ?A1 == ?A1 = {}
  ALL x. ?t1 ~= x == False
  ALL x. x ~= ?t1 == False
  ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
  ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
  ALL x. ?y == ?y
  ALL x. ?P1 --> ?Q1 x == ?P1 --> (ALL x. ?Q1 x)
  ALL x. ?P1 x --> ?Q1 == (EX x. ?P1 x) --> ?Q1
  ALL x. ?P1 | ?Q1 x == ?P1 | (ALL x. ?Q1 x)
  ALL x. ?P1 x | ?Q1 == (ALL x. ?P1 x) | ?Q1
  ALL x. ?P1 & ?Q1 x == ?P1 & (ALL x. ?Q1 x)
  ALL x. ?P1 x & ?Q1 == (ALL x. ?P1 x) & ?Q1
  EX x. ?P1 x == EX a b. ?P1 (a, b)
  EX x y. ?p1 = (x, y) == True
  EX x. x : ?f1 ` ?A1 & ?P1 x == EX x:?A1. ?P1 (?f1 x)
  EX x. x : ?f1 ` ?A1 == ?A1 ~= {}
  EX x. ?t1 = x & ?P1 x == ?P1 ?t1
  EX x. x = ?t1 & ?P1 x == ?P1 ?t1
  EX x. x = ?t1 == True
  EX x. ?y == ?y
  EX x. ?P1 --> ?Q1 x == ?P1 --> (EX x. ?Q1 x)
  EX x. ?P1 x --> ?Q1 == (ALL x. ?P1 x) --> ?Q1
  EX x. ?P1 | ?Q1 x == ?P1 | (EX x. ?Q1 x)
  EX x. ?P1 x | ?Q1 == (EX x. ?P1 x) | ?Q1
  EX x. ?P1 & ?Q1 x == ?P1 & (EX x. ?Q1 x)
  EX x. ?P1 x & ?Q1 == (EX x. ?P1 x) & ?Q1
  EX x. ?t1 = x == True
  id ?y == ?y
  xor_num num.One num.One == None
  xor_num num.One (num.Bit1 ?n1) == Some (num.Bit0 ?n1)
  xor_num num.One (num.Bit0 ?n1) == Some (num.Bit1 ?n1)
  xor_num (num.Bit1 ?m1) num.One == Some (num.Bit0 ?m1)
  xor_num (num.Bit1 ?m1) (num.Bit1 ?n1) ==
  map_option num.Bit0 (xor_num ?m1 ?n1)
  xor_num (num.Bit1 ?m1) (num.Bit0 ?n1) ==
  Some (case xor_num ?m1 ?n1 of None => num.One | Some x => num.Bit1 x)
  xor_num (num.Bit0 ?m1) num.One == Some (num.Bit1 ?m1)
  xor_num (num.Bit0 ?m1) (num.Bit1 ?n1) ==
  Some (case xor_num ?m1 ?n1 of None => num.One | Some x => num.Bit1 x)
  xor_num (num.Bit0 ?m1) (num.Bit0 ?n1) ==
  map_option num.Bit0 (xor_num ?m1 ?n1)
  and_num num.One num.One == Some num.One
  and_num num.One (num.Bit1 ?n1) == Some num.One
  and_num num.One (num.Bit0 ?n1) == None
  and_num (num.Bit1 ?m1) num.One == Some num.One
  and_num (num.Bit1 ?m1) (num.Bit1 ?n1) ==
  case and_num ?m1 ?n1 of None => Some num.One
  | Some n' => Some (num.Bit1 n')
  and_num (num.Bit1 ?m1) (num.Bit0 ?n1) ==
  map_option num.Bit0 (and_num ?m1 ?n1)
  and_num (num.Bit0 ?m1) num.One == None
  and_num (num.Bit0 ?m1) (num.Bit1 ?n1) ==
  map_option num.Bit0 (and_num ?m1 ?n1)
  and_num (num.Bit0 ?m1) (num.Bit0 ?n1) ==
  map_option num.Bit0 (and_num ?m1 ?n1)
  or_num num.One num.One == num.One
  or_num num.One (num.Bit1 ?n1) == num.Bit1 ?n1
  or_num num.One (num.Bit0 ?n1) == num.Bit1 ?n1
  or_num (num.Bit1 ?m1) num.One == num.Bit1 ?m1
  or_num (num.Bit1 ?m1) (num.Bit1 ?n1) == num.Bit1 (or_num ?m1 ?n1)
  or_num (num.Bit1 ?m1) (num.Bit0 ?n1) == num.Bit1 (or_num ?m1 ?n1)
  or_num (num.Bit0 ?m1) num.One == num.Bit1 ?m1
  or_num (num.Bit0 ?m1) (num.Bit1 ?n1) == num.Bit1 (or_num ?m1 ?n1)
  or_num (num.Bit0 ?m1) (num.Bit0 ?n1) == num.Bit0 (or_num ?m1 ?n1)
  full_exhaustive_class.full_exhaustive ?f1 ?i1 ==
  if ?i1 = 0 then None
  else Quickcheck_Exhaustive.orelse (?f1 valterm_emptyset)
        (full_exhaustive_class.full_exhaustive
          (%A. Quickcheck_Exhaustive.orelse (?f1 A)
                (full_exhaustive_class.full_exhaustive
                  (%x. if fst x : fst A then None
                       else ?f1 (valtermify_insert x A))
                  (?i1 - 1)))
          (?i1 - 1))
  divmod_step ?l1 (?q1, ?r1) ==
  if numeral ?l1 <= ?r1
  then ((2::?'a1) * ?q1 + (1::?'a1), ?r1 - numeral ?l1)
  else ((2::?'a1) * ?q1, ?r1)
  signed_take_bit 0 ?a1 == - (?a1 mod (2::?'a1))
  signed_take_bit ?n1 (0::?'a1) == 0::?'a1
  signed_take_bit ?n1 (- (1::?'a1)) == - (1::?'a1)
  signed_take_bit ?m1 (signed_take_bit ?n1 ?a1) ==
  signed_take_bit (min ?m1 ?n1) ?a1
  signed_take_bit (numeral ?k1) (1::?'a1) == 1::?'a1
  signed_take_bit (numeral ?l1) (- numeral (num.Bit1 ?k1)) ==
  signed_take_bit (pred_numeral ?l1) (- numeral ?k1 - 1) * 2 + 1
  signed_take_bit (numeral ?l1) (- numeral (num.Bit0 ?k1)) ==
  signed_take_bit (pred_numeral ?l1) (- numeral ?k1) * 2
  signed_take_bit (numeral ?l1) (numeral (num.Bit1 ?k1)) ==
  signed_take_bit (pred_numeral ?l1) (numeral ?k1) * 2 + 1
  signed_take_bit (numeral ?l1) (numeral (num.Bit0 ?k1)) ==
  signed_take_bit (pred_numeral ?l1) (numeral ?k1) * 2
  signed_take_bit (Suc ?n1) (1::?'a1) == 1::?'a1
  signed_take_bit (Suc ?n1) (- numeral (num.Bit1 ?k1)) ==
  signed_take_bit ?n1 (- numeral ?k1 - 1) * 2 + 1
  signed_take_bit (Suc ?n1) (- numeral (num.Bit0 ?k1)) ==
  signed_take_bit ?n1 (- numeral ?k1) * 2
  signed_take_bit (Suc ?n1) (numeral (num.Bit1 ?k1)) ==
  signed_take_bit ?n1 (numeral ?k1) * 2 + 1
  signed_take_bit (Suc ?n1) (numeral (num.Bit0 ?k1)) ==
  signed_take_bit ?n1 (numeral ?k1) * 2
  case Narrowing_sum_of_products ?x1 of
  Narrowing_sum_of_products x => ?f1 x ==
  ?f1 ?x1
  case ??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons ?x1.1 ?x2.1 of
  ??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons x xa => ?f1 x xa ==
  ?f1 ?x1.1 ?x2.1
  rec_narrowing_type ?f1 (Narrowing_sum_of_products ?x1) ==
  ?f1 (map (map (%narrowing_type.
                    (narrowing_type,
                     rec_narrowing_type ?f1 narrowing_type)))
        ?x1)
  rec_narrowing_cons ?f1
   (??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons ?x1.1 ?x2.1) ==
  ?f1 ?x1.1 ?x2.1
  divmod num.One (num.Bit1 ?n1) == (0::?'a1, Numeral1)
  divmod num.One (num.Bit0 ?n1) == (0::?'a1, Numeral1)
  divmod ?m1 num.One == (numeral ?m1, 0::?'a1)
  divmod (num.Bit1 ?m1) (num.Bit1 ?n1) ==
  if ?m1 < ?n1 then (0::?'a1, numeral (num.Bit1 ?m1))
  else divmod_step (num.Bit1 ?n1)
        (divmod (num.Bit1 ?m1) (num.Bit0 (num.Bit1 ?n1)))
  divmod (num.Bit1 ?m1) (num.Bit0 ?n1) ==
  case divmod ?m1 ?n1 of (q, r) => (q, (2::?'a1) * r + (1::?'a1))
  divmod (num.Bit0 ?m1) (num.Bit1 ?n1) ==
  if ?m1 <= ?n1 then (0::?'a1, numeral (num.Bit0 ?m1))
  else divmod_step (num.Bit1 ?n1)
        (divmod (num.Bit0 ?m1) (num.Bit0 (num.Bit1 ?n1)))
  divmod (num.Bit0 ?m1) (num.Bit0 ?n1) ==
  case divmod ?m1 ?n1 of (q, r) => (q, (2::?'a1) * r)
  divmod (Num.BitM ?m1) (num.Bit0 num.One) == (numeral ?m1 - 1, 1)
  unset_bit 0 ?a1 == (2::?'a1) * (?a1 div (2::?'a1))
  take_bit 0 ?a1 == 0::?'a1
  take_bit ?n1 (0::?'a1) == 0::?'a1
  take_bit ?n1 (1::?'a1) == of_bool (0 < ?n1)
  take_bit ?m1 (mask ?n1) == mask (min ?m1 ?n1)
  take_bit ?n1 (- (1::?'a1)) == mask ?n1
  take_bit ?n1 (2::?'a1) == of_bool (2 <= ?n1) * (2::?'a1)
  take_bit ?n1 (Suc 0) == of_bool (0 < ?n1)
  take_bit ?m1 (take_bit ?n1 ?a1) == take_bit (min ?m1 ?n1) ?a1
  take_bit ?n1 (xor ?a1 ?b1) == xor (take_bit ?n1 ?a1) (take_bit ?n1 ?b1)
  take_bit ?n1 (and ?a1 ?b1) == and (take_bit ?n1 ?a1) (take_bit ?n1 ?b1)
  take_bit ?n1 (or ?a1 ?b1) == or (take_bit ?n1 ?a1) (take_bit ?n1 ?b1)
  take_bit ?m1 ((2::?'a1) ^ ?n1) == of_bool (?n1 < ?m1) * (2::?'a1) ^ ?n1
  take_bit (numeral ?l1) (1::?'a1) == 1::?'a1
  take_bit (numeral ?m1) (- numeral ?n1) ==
  case take_bit_num (numeral ?m1) ?n1 of None => 0
  | Some q => take_bit (numeral ?m1) (2 ^ numeral ?m1 - numeral q)
  take_bit (numeral ?m1) (numeral ?n1) ==
  case take_bit_num (numeral ?m1) ?n1 of None => 0::?'a1
  | Some q => numeral q
  take_bit (Suc 0) ?a1 == ?a1 mod (2::?'a1)
  take_bit (Suc ?n1) (1::?'a1) == 1::?'a1
  push_bit ?n1 (0::?'a1) == 0::?'a1
  push_bit ?n1 (1::?'a1) == (2::?'a1) ^ ?n1
  push_bit ?n1 (- (1::?'a1)) == not (mask ?n1)
  push_bit ?n1 (Suc 0) == 2 ^ ?n1
  push_bit ?m1 (push_bit ?n1 ?a1) == push_bit (?m1 + ?n1) ?a1
  push_bit ?n1 (xor ?a1 ?b1) == xor (push_bit ?n1 ?a1) (push_bit ?n1 ?b1)
  push_bit ?n1 (and ?a1 ?b1) == and (push_bit ?n1 ?a1) (push_bit ?n1 ?b1)
  push_bit ?n1 (or ?a1 ?b1) == or (push_bit ?n1 ?a1) (push_bit ?n1 ?b1)
  push_bit (numeral ?n1) (- (1::?'a1)) == - ((2::?'a1) ^ numeral ?n1)
  push_bit (numeral ?l1) (- numeral ?k1) ==
  push_bit (pred_numeral ?l1) (- numeral (num.Bit0 ?k1))
  push_bit (numeral ?l1) (numeral ?k1) ==
  push_bit (pred_numeral ?l1) (numeral (num.Bit0 ?k1))
  push_bit (Suc ?n1) ?a1 == push_bit ?n1 (?a1 * (2::?'a1))
  push_bit (Suc ?n1) (- numeral ?k1) ==
  push_bit ?n1 (- numeral (num.Bit0 ?k1))
  push_bit (Suc ?n1) (numeral ?k1) == push_bit ?n1 (numeral (num.Bit0 ?k1))
  flip_bit 0 ?a1 == of_bool (even ?a1) + (2::?'a1) * (?a1 div (2::?'a1))
  drop_bit ?n1 (0::?'a1) == 0::?'a1
  drop_bit ?n1 (1::?'a1) == of_bool (?n1 = 0)
  drop_bit ?n1 (of_bool ?b1) == of_bool (?n1 = 0 & ?b1)
  drop_bit ?n1 (- 1) == - 1
  drop_bit ?n1 (Suc 0) == of_bool (?n1 = 0)
  drop_bit ?m1 (drop_bit ?n1 ?a1) == drop_bit (?m1 + ?n1) ?a1
  drop_bit ?n1 (xor ?a1 ?b1) == xor (drop_bit ?n1 ?a1) (drop_bit ?n1 ?b1)
  drop_bit ?n1 (and ?a1 ?b1) == and (drop_bit ?n1 ?a1) (drop_bit ?n1 ?b1)
  drop_bit ?n1 (or ?a1 ?b1) == or (drop_bit ?n1 ?a1) (drop_bit ?n1 ?b1)
  drop_bit (numeral ?l1) (- numeral (num.Bit1 ?k1)) ==
  drop_bit (pred_numeral ?l1) (- numeral (Num.inc ?k1))
  drop_bit (numeral ?l1) (- numeral (num.Bit0 ?k1)) ==
  drop_bit (pred_numeral ?l1) (- numeral ?k1)
  drop_bit (numeral ?l1) (numeral (num.Bit1 ?k1)) ==
  drop_bit (pred_numeral ?l1) (numeral ?k1)
  drop_bit (numeral ?l1) (numeral (num.Bit0 ?k1)) ==
  drop_bit (pred_numeral ?l1) (numeral ?k1)
  drop_bit (Suc ?n1) (- numeral (num.Bit1 ?k1)) ==
  drop_bit ?n1 (- numeral (Num.inc ?k1))
  drop_bit (Suc ?n1) (- numeral (num.Bit0 ?k1)) ==
  drop_bit ?n1 (- numeral ?k1)
  drop_bit (Suc ?n1) (numeral (num.Bit1 ?k1)) == drop_bit ?n1 (numeral ?k1)
  drop_bit (Suc ?n1) (numeral (num.Bit0 ?k1)) == drop_bit ?n1 (numeral ?k1)
  set_bit 0 ?a1 == (1::?'a1) + (2::?'a1) * (?a1 div (2::?'a1))
  exhaustive_class.exhaustive ?f1 ?i1 ==
  if ?i1 = 0 then None
  else Quickcheck_Exhaustive.orelse (?f1 {})
        (exhaustive_class.exhaustive
          (%A. Quickcheck_Exhaustive.orelse (?f1 A)
                (exhaustive_class.exhaustive
                  (%x. if x : A then None else ?f1 (insert x A)) (?i1 - 1)))
          (?i1 - 1))
  xor (0::?'a1) ?y == ?y
  xor (1::?'a1) (numeral (num.Bit1 ?y1)) == numeral (num.Bit0 ?y1)
  xor (1::?'a1) (numeral (num.Bit0 ?y1)) == numeral (num.Bit1 ?y1)
  xor ?y (0::?'a1) == ?y
  xor ?x1 ?x1 == 0::?'a1
  xor ?a1 ?a1 == 0::?'a1
  xor ?x1 (not ?x1) == - (1::?'a1)
  xor ?x1 (not ?y1) == not (xor ?x1 ?y1)
  xor ?x1 (- (1::?'a1)) == not ?x1
  xor ?k1 (- numeral ?n1) ==
  not (xor ?k1 (neg_numeral_class.sub ?n1 num.One))
  xor ?x1 (xor ?x1 ?y) == ?y
  xor (not ?x1) ?x1 == - (1::?'a1)
  xor (not ?x1) ?y1 == not (xor ?x1 ?y1)
  xor (- (1::?'a1)) ?x1 == not ?x1
  xor (- numeral ?n1) ?k1 ==
  not (xor (neg_numeral_class.sub ?n1 num.One) ?k1)
  xor (numeral (num.Bit1 ?x1)) (1::?'a1) == numeral (num.Bit0 ?x1)
  xor (numeral (num.Bit1 ?x1)) (numeral (num.Bit1 ?y1)) ==
  (2::?'a1) * xor (numeral ?x1) (numeral ?y1)
  xor (numeral (num.Bit1 ?x1)) (numeral (num.Bit0 ?y1)) ==
  (1::?'a1) + (2::?'a1) * xor (numeral ?x1) (numeral ?y1)
  xor (numeral (num.Bit1 ?x1)) (Suc 0) == numeral (num.Bit0 ?x1)
  xor (numeral (num.Bit0 ?x1)) (1::?'a1) == numeral (num.Bit1 ?x1)
  xor (numeral (num.Bit0 ?x1)) (numeral (num.Bit1 ?y1)) ==
  (1::?'a1) + (2::?'a1) * xor (numeral ?x1) (numeral ?y1)
  xor (numeral (num.Bit0 ?x1)) (numeral (num.Bit0 ?y1)) ==
  (2::?'a1) * xor (numeral ?x1) (numeral ?y1)
  xor (numeral (num.Bit0 ?x1)) (Suc 0) == numeral (num.Bit1 ?x1)
  xor (Suc 0) (numeral (num.Bit1 ?y1)) == numeral (num.Bit0 ?y1)
  xor (Suc 0) (numeral (num.Bit0 ?y1)) == numeral (num.Bit1 ?y1)
  and (0::?'a1) ?x1 == 0::?'a1
  and (0::?'a1) ?a1 == 0::?'a1
  and 1 (- numeral (num.Bit1 ?n1)) == 1
  and 1 (- numeral (num.Bit0 ?n1)) == 0
  and (1::?'a1) (numeral (num.Bit1 ?y1)) == 1::?'a1
  and (1::?'a1) (numeral (num.Bit0 ?y1)) == 0::?'a1
  and ?x1 (0::?'a1) == 0::?'a1
  and ?a1 (0::?'a1) == 0::?'a1
  and ?y ?y == ?y
  and ?x1 (not ?x1) == 0::?'a1
  and ?y (- (1::?'a1)) == ?y
  and ?n1 (Suc 0) == ?n1 mod 2
  and ?a1 (and ?a1 ?b1) == and ?a1 ?b1
  and (not ?x1) ?x1 == 0::?'a1
  and (- (1::?'a1)) ?y == ?y
  and (- numeral ?m1) (- numeral ?n1) ==
  not (or (numeral ?m1 - 1) (numeral ?n1 - 1))
  and (- numeral (num.Bit1 ?n1)) 1 == 1
  and (- numeral (num.Bit1 ?n1)) (numeral ?m1) ==
  case and_not_num ?m1 (num.Bit0 ?n1) of None => 0 | Some n' => numeral n'
  and (- numeral (num.Bit0 ?n1)) 1 == 0
  and (- numeral (num.Bit0 ?n1)) (numeral ?m1) ==
  case and_not_num ?m1 (Num.BitM ?n1) of None => 0 | Some n' => numeral n'
  and (numeral ?m1) (- numeral (num.Bit1 ?n1)) ==
  case and_not_num ?m1 (num.Bit0 ?n1) of None => 0 | Some n' => numeral n'
  and (numeral ?m1) (- numeral (num.Bit0 ?n1)) ==
  case and_not_num ?m1 (Num.BitM ?n1) of None => 0 | Some n' => numeral n'
  and (numeral (num.Bit1 ?x1)) (1::?'a1) == 1::?'a1
  and (numeral (num.Bit1 ?x1)) (numeral (num.Bit1 ?y1)) ==
  (1::?'a1) + (2::?'a1) * and (numeral ?x1) (numeral ?y1)
  and (numeral (num.Bit1 ?x1)) (numeral (num.Bit0 ?y1)) ==
  (2::?'a1) * and (numeral ?x1) (numeral ?y1)
  and (numeral (num.Bit1 ?x1)) (Suc 0) == 1
  and (numeral (num.Bit0 ?x1)) (1::?'a1) == 0::?'a1
  and (numeral (num.Bit0 ?x1)) (numeral (num.Bit1 ?y1)) ==
  (2::?'a1) * and (numeral ?x1) (numeral ?y1)
  and (numeral (num.Bit0 ?x1)) (numeral (num.Bit0 ?y1)) ==
  (2::?'a1) * and (numeral ?x1) (numeral ?y1)
  and (numeral (num.Bit0 ?x1)) (Suc 0) == 0
  and (Suc 0) ?n1 == ?n1 mod 2
  and (Suc 0) (numeral (num.Bit1 ?y1)) == 1
  and (Suc 0) (numeral (num.Bit0 ?y1)) == 0
  and (and ?a1 ?b1) ?b1 == and ?a1 ?b1
  case tuple_isomorphism.Tuple_Isomorphism ?x1.1 ?x2.1 of
  tuple_isomorphism.Tuple_Isomorphism x xa => ?f1 x xa ==
  ?f1 ?x1.1 ?x2.1
  possible_bit TYPE(int) ?n1 == True
  possible_bit TYPE(nat) ?n1 == True
  possible_bit ?ty1 0 == True
  possible_bit ?tyrep1 (min ?i1 ?j1) ==
  possible_bit ?tyrep1 ?i1 | possible_bit ?tyrep1 ?j1
  or (0::?'a1) ?y == ?y
  or 1 (- numeral (num.Bit1 ?n1)) == - numeral (num.Bit1 ?n1)
  or 1 (- numeral (num.Bit0 ?n1)) ==
  - numeral (or_not_num_neg num.One (Num.BitM ?n1))
  or (1::?'a1) (numeral (num.Bit1 ?y1)) == numeral (num.Bit1 ?y1)
  or (1::?'a1) (numeral (num.Bit0 ?y1)) == numeral (num.Bit1 ?y1)
  or ?y (0::?'a1) == ?y
  or ?y ?y == ?y
  or ?x1 (not ?x1) == - (1::?'a1)
  or ?x1 (- (1::?'a1)) == - (1::?'a1)
  or ?a1 (or ?a1 ?b1) == or ?a1 ?b1
  or (not ?x1) ?x1 == - (1::?'a1)
  or (- (1::?'a1)) ?x1 == - (1::?'a1)
  or (- numeral ?m1) (- numeral ?n1) ==
  not (and (numeral ?m1 - 1) (numeral ?n1 - 1))
  or (- numeral (num.Bit1 ?n1)) 1 == - numeral (num.Bit1 ?n1)
  or (- numeral (num.Bit1 ?n1)) (numeral ?m1) ==
  - numeral (or_not_num_neg ?m1 (num.Bit0 ?n1))
  or (- numeral (num.Bit0 ?n1)) 1 ==
  - numeral (or_not_num_neg num.One (Num.BitM ?n1))
  or (- numeral (num.Bit0 ?n1)) (numeral ?m1) ==
  - numeral (or_not_num_neg ?m1 (Num.BitM ?n1))
  or (numeral ?m1) (- numeral (num.Bit1 ?n1)) ==
  - numeral (or_not_num_neg ?m1 (num.Bit0 ?n1))
  or (numeral ?m1) (- numeral (num.Bit0 ?n1)) ==
  - numeral (or_not_num_neg ?m1 (Num.BitM ?n1))
  or (numeral (num.Bit1 ?x1)) (1::?'a1) == numeral (num.Bit1 ?x1)
  or (numeral (num.Bit1 ?x1)) (numeral (num.Bit1 ?y1)) ==
  (1::?'a1) + (2::?'a1) * or (numeral ?x1) (numeral ?y1)
  or (numeral (num.Bit1 ?x1)) (numeral (num.Bit0 ?y1)) ==
  (1::?'a1) + (2::?'a1) * or (numeral ?x1) (numeral ?y1)
  or (numeral (num.Bit1 ?x1)) (Suc 0) == numeral (num.Bit1 ?x1)
  or (numeral (num.Bit0 ?x1)) (1::?'a1) == numeral (num.Bit1 ?x1)
  or (numeral (num.Bit0 ?x1)) (numeral (num.Bit1 ?y1)) ==
  (1::?'a1) + (2::?'a1) * or (numeral ?x1) (numeral ?y1)
  or (numeral (num.Bit0 ?x1)) (numeral (num.Bit0 ?y1)) ==
  (2::?'a1) * or (numeral ?x1) (numeral ?y1)
  or (numeral (num.Bit0 ?x1)) (Suc 0) == numeral (num.Bit1 ?x1)
  or (Suc 0) (numeral (num.Bit1 ?y1)) == numeral (num.Bit1 ?y1)
  or (Suc 0) (numeral (num.Bit0 ?y1)) == numeral (num.Bit1 ?y1)
  or (or ?a1 ?b1) ?b1 == or ?a1 ?b1
  rec_tuple_isomorphism ?f1
   (tuple_isomorphism.Tuple_Isomorphism ?x1.1 ?x2.1) ==
  ?f1 ?x1.1 ?x2.1
  case ?xq1 of lazy_sequence_of_list x => ?f1 x ==
  ?f1 (list_of_lazy_sequence ?xq1)
  case lazy_sequence_of_list ?x1 of lazy_sequence_of_list x => ?f1 x ==
  ?f1 ?x1
  rec_lazy_sequence ?f1 ?xq1 == ?f1 (list_of_lazy_sequence ?xq1)
  rec_lazy_sequence ?f1 (lazy_sequence_of_list ?x1) == ?f1 ?x1
  ?l1 <= ?k1 ==> {?k1<..<?l1} == {}
  pochhammer ?a1 0 == 1::?'a1
  pochhammer ?y 1 == ?y
  pochhammer ?y (Suc 0) == ?y
  ?l1 <= ?k1 ==> {?k1<..?l1} == {}
  Quickcheck_Exhaustive.check_all_subsets ?f1 [] == ?f1 valterm_emptyset
  Quickcheck_Exhaustive.check_all_subsets ?f1 (?x1 # ?xs1) ==
  Quickcheck_Exhaustive.check_all_subsets
   (%s. case ?f1 s of None => ?f1 (valtermify_insert ?x1 s)
        | Some x => Some x)
   ?xs1
  Quickcheck_Exhaustive.check_all_n_lists ?f1 ?n1 ==
  if ?n1 = 0 then ?f1 ([], %_. [])
  else check_all_class.check_all
        (%(x, xt).
            Quickcheck_Exhaustive.check_all_n_lists
             (%(xs, xst). ?f1 (x # xs, %_. xt () # xst ())) (?n1 - 1))
  prod' ?p1 {} == 1::?'a1
  finite ?I1 ==> prod' ?p1 ?I1 == prod ?p1 ?I1
  finite {x: ?I1. ?p1 x ~= (1::?'a1)} ==>
  prod' ?p1 (insert ?i1 ?I1) ==
  if ?i1 : ?I1 then prod' ?p1 ?I1 else ?p1 ?i1 * prod' ?p1 ?I1
  ?b1 <= ?a1 ==> {?a1..<?b1} == {}
  {?m1..<Suc ?m1} == {?m1}
  prod ?g1 {} == 1::?'a1
  PROD x:?A1. ?y1 == ?y1 ^ card ?A1
  finite ?S1 ==>
  PROD k:?S1. if ?a1 = k then ?b1 k else (1::?'a1) ==
  if ?a1 : ?S1 then ?b1 ?a1 else (1::?'a1)
  finite ?S1 ==>
  PROD k:?S1. if k = ?a1 then ?b1 k else (1::?'a1) ==
  if ?a1 : ?S1 then ?b1 ?a1 else (1::?'a1)
  PROD _:?A1. (1::?'a1) == 1::?'a1
  infinite ?A1 ==> prod ?g1 ?A1 == 1::?'a1
  prod ?g1 {..<Suc ?n1} == prod ?g1 {..<?n1} * ?g1 ?n1
  prod ?g1 {..Suc ?n1} == prod ?g1 {..?n1} * ?g1 (Suc ?n1)
  prod ?g1 {?m1..<Suc ?n1} ==
  if ?n1 < ?m1 then 1::?'a1 else prod ?g1 {?m1..<?n1} * ?g1 ?n1
  prod ?g1 {?m1..Suc ?n1} ==
  if Suc ?n1 < ?m1 then 1::?'a1 else prod ?g1 {?m1..?n1} * ?g1 (Suc ?n1)
  [| finite ?A1; ?x1 ~: ?A1 |]
  ==> prod ?g1 (insert ?x1 ?A1) == ?g1 ?x1 * prod ?g1 ?A1
  bit (1::?'a1) (numeral ?n1) == False
  bit (1::?'a1) (Suc ?n1) == False
  bit ?a1 0 == odd ?a1
  bit (- (1::?'a1)) ?n1 == possible_bit TYPE(?'a1) ?n1
  bit (- numeral (num.Bit1 ?w1)) (numeral ?n1) ==
  ~ bit (numeral ?w1) (pred_numeral ?n1)
  bit (- numeral (num.Bit1 ?w1)) (Suc ?n1) == ~ bit (numeral ?w1) ?n1
  bit (- (2::?'a1)) ?n1 == possible_bit TYPE(?'a1) ?n1 & 0 < ?n1
  bit (- numeral (num.Bit0 ?w1)) (numeral ?n1) ==
  bit (- numeral ?w1) (pred_numeral ?n1)
  bit (- numeral (num.Bit0 ?w1)) (Suc ?n1) == bit (- numeral ?w1) ?n1
  bit (numeral (num.Bit1 ?w1)) (numeral ?n1) ==
  bit (numeral ?w1) (pred_numeral ?n1)
  bit (numeral (num.Bit1 ?m1)) (Suc ?n1) == bit (numeral ?m1) ?n1
  bit (numeral (num.Bit0 ?w1)) (numeral ?n1) ==
  bit (numeral ?w1) (pred_numeral ?n1)
  bit (numeral (num.Bit0 ?m1)) (Suc ?n1) == bit (numeral ?m1) ?n1
  bit (Suc 0) (numeral ?n1) == False
  bit (Suc 0) (Suc ?n1) == False
  bit (?a1 mod (2::?'a1)) ?n1 == ?n1 = 0 & odd ?a1
  coprime (0::?'a1) ?a1 == is_unit ?a1
  coprime (1::?'a1) ?a1 == True
  coprime ?a1 (0::?'a1) == is_unit ?a1
  coprime ?a1 (1::?'a1) == True
  coprime ?a1 ?a1 == is_unit ?a1
  coprime ?a1 (normalize ?b1) == coprime ?a1 ?b1
  coprime ?a1 (- ?b1) == coprime ?a1 ?b1
  coprime ?a1 (2::?'a1) == odd ?a1
  coprime ?k1 \<bar>?l1\<bar> == coprime ?k1 ?l1
  coprime ?n1 (Suc 0) == True
  coprime ?n1 (Suc ?n1) == True
  coprime ?n1 (nat \<bar>?k1\<bar>) == coprime (int ?n1) ?k1
  ?a1 ~= (0::?'a1) ==> coprime ?a1 (?b1 mod ?a1) == coprime ?a1 ?b1
  coprime ?c1 (?a1 * ?b1) == coprime ?c1 ?a1 & coprime ?c1 ?b1
  0 < ?n1 ==> coprime ?n1 (?n1 - 1) == True
  coprime ?a1 (?a1 - (1::?'a1)) == True
  coprime ?a1 (?b1 ^ ?n1) == coprime ?a1 ?b1 | ?n1 = 0
  coprime ?a1 (?a1 + (1::?'a1)) == True
  coprime (normalize ?a1) ?b1 == coprime ?a1 ?b1
  coprime (int ?m1) (int ?n1) == coprime ?m1 ?n1
  coprime (- ?a1) ?b1 == coprime ?a1 ?b1
  coprime (2::?'a1) ?a1 == odd ?a1
  coprime \<bar>?k1\<bar> ?l1 == coprime ?k1 ?l1
  coprime (Suc 0) ?n1 == True
  coprime (Suc ?n1) ?n1 == True
  coprime (nat \<bar>?k1\<bar>) ?n1 == coprime ?k1 (int ?n1)
  ?b1 ~= (0::?'a1) ==> coprime (?a1 mod ?b1) ?b1 == coprime ?a1 ?b1
  coprime (?a1 * ?b1) ?c1 == coprime ?a1 ?c1 & coprime ?b1 ?c1
  coprime (?a1 * ?c1) (?b1 * ?c1) == is_unit ?c1 & coprime ?a1 ?b1
  coprime (?c1 * ?a1) (?c1 * ?b1) == is_unit ?c1 & coprime ?a1 ?b1
  0 < ?n1 ==> coprime (?n1 - 1) ?n1 == True
  coprime (?a1 - (1::?'a1)) ?a1 == True
  coprime (?a1 ^ ?n1) ?b1 == coprime ?a1 ?b1 | ?n1 = 0
  coprime (?a1 + (1::?'a1)) ?a1 == True
  check_all_char' ?f1 [] == None
  check_all_char' ?f1 (?c1 # ?cs1) ==
  Quickcheck_Exhaustive.orelse (?f1 (?c1, %_. term_of_class.term_of ?c1))
   (check_all_char' ?f1 ?cs1)
  sum' ?p1 {} == 0::?'a1
  finite ?I1 ==> sum' ?p1 ?I1 == sum ?p1 ?I1
  finite {x: ?I1. ?p1 x ~= (0::?'a1)} ==>
  sum' ?p1 (insert ?i1 ?I1) ==
  if ?i1 : ?I1 then sum' ?p1 ?I1 else ?p1 ?i1 + sum' ?p1 ?I1
  ?b1 < ?a1 ==> {?a1..?b1} == {}
  {?a1..?a1} == {?a1}
  sum ?g1 {} == 0::?'a1
  SUM i:?A1. ?c1 i * (0::?'a1) ^ i / ?d1 i ==
  if finite ?A1 & 0 : ?A1 then ?c1 0 / ?d1 0 else (0::?'a1)
  SUM i:?A1. ?c1 i * (0::?'a1) ^ i ==
  if finite ?A1 & 0 : ?A1 then ?c1 0 else (0::?'a1)
  finite ?A1 ==>
  SUM x:?A1. of_bool (?P1 x) * ?f1 x == sum ?f1 (?A1 Int {x. ?P1 x})
  finite ?A1 ==>
  SUM x:?A1. ?f1 x * of_bool (?P1 x) == sum ?f1 (?A1 Int {x. ?P1 x})
  [| finite ?A1; finite ?A1 |]
  ==> SUM x:?A1. of_bool (?P1 x) == of_nat (card (?A1 Int {x. ?P1 x}))
  SUM x:?A1. ?y1 == of_nat (card ?A1) * ?y1
  finite ?S1 ==>
  SUM k:?S1. if ?a1 = k then ?b1 k else (0::?'a1) ==
  if ?a1 : ?S1 then ?b1 ?a1 else (0::?'a1)
  finite ?S1 ==>
  SUM k:?S1. if k = ?a1 then ?b1 k else (0::?'a1) ==
  if ?a1 : ?S1 then ?b1 ?a1 else (0::?'a1)
  SUM _:?A1. (0::?'a1) == 0::?'a1
  infinite ?A1 ==> sum ?g1 ?A1 == 0::?'a1
  sum ?g1 {..<Suc ?n1} == sum ?g1 {..<?n1} + ?g1 ?n1
  sum ?g1 {..Suc ?n1} == sum ?g1 {..?n1} + ?g1 (Suc ?n1)
  sum ?g1 {?m1..<Suc ?n1} ==
  if ?n1 < ?m1 then 0::?'a1 else sum ?g1 {?m1..<?n1} + ?g1 ?n1
  sum ?g1 {?m1..Suc ?n1} ==
  if Suc ?n1 < ?m1 then 0::?'a1 else sum ?g1 {?m1..?n1} + ?g1 (Suc ?n1)
  [| finite ?A1; ?x1 ~: ?A1 |]
  ==> sum ?g1 (insert ?x1 ?A1) == ?g1 ?x1 + sum ?g1 ?A1
  case cfun.Constant ?x1 of cfun.Constant x => ?f1 x == ?f1 ?x1
  rec_cfun ?f1 (cfun.Constant ?x1) == ?f1 ?x1
  random_aux_set 0 ?j1 ==
  Quickcheck_Random.collapse
   (Random.select_weight [(1, Pair valterm_emptyset)])
  random_aux_set (Code_Numeral.Suc ?i1) ?j1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, Pair valterm_emptyset),
      (Code_Numeral.Suc ?i1,
       scomp (random_class.random ?j1)
        (%x. scomp (random_aux_set ?i1 ?j1)
              (%s. Pair (valtermify_insert x s))))])
  partial_order_on {} {} == True
  partial_order_on ?A1 (?r1^-1) == partial_order_on ?A1 ?r1
  Sup ?A1 ?x1 == SUP f\<in>?A1. f ?x1
  Sup (?f1 ` ?A1) ?x1 == SUP y\<in>?A1. ?f1 y ?x1
  Inf ?A1 ?x1 == INF f\<in>?A1. f ?x1
  Inf (?f1 ` ?A1) ?x1 == INF y\<in>?A1. ?f1 y ?x1
  Quickcheck_Narrowing.eval_ffun (ffun.Constant ?y) ?x1 == ?y
  Quickcheck_Narrowing.eval_ffun (ffun.Update ?x'1 ?y1 ?f1) ?x1 ==
  if ?x1 = ?x'1 then ?y1 else Quickcheck_Narrowing.eval_ffun ?f1 ?x1
  Quickcheck_Narrowing.eval_cfun (cfun.Constant ?y) ?y1 == ?y
  old.rec_unit ?y () == ?y
  old.rec_prod ?f1.1 (?a1, ?b1) == ?f1.1 ?a1 ?b1
  linear_order_on {} {} == True
  linear_order_on ?A1 (?r1^-1) == linear_order_on ?A1 ?r1
  linear_order_on {?x1} {(?x1, ?x1)} == True
  case pair_box.PairBox ?x1.1 ?x2.1 of pair_box.PairBox x xa => ?f1 x xa ==
  ?f1 ?x1.1 ?x2.1
  case ??.Code_Evaluation.term.dummy_term of
  ??.Code_Evaluation.term.dummy_term => ?y ==
  ?y
  ??.Quickcheck_Narrowing.map_cons ?f1
   (??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons ?ty1 ?cs1) ==
  ??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons ?ty1
   (map ((o) ?f1) ?cs1)
  rec_pair_box ?f1 (pair_box.PairBox ?x1.1 ?x2.1) == ?f1 ?x1.1 ?x2.1
  rec_term ?y ??.Code_Evaluation.term.dummy_term == ?y
  or_not_num_neg num.One num.One == num.One
  or_not_num_neg num.One (num.Bit1 ?m1) == num.Bit1 ?m1
  or_not_num_neg num.One (num.Bit0 ?m1) == num.Bit1 ?m1
  or_not_num_neg (num.Bit1 ?n1) num.One == num.One
  or_not_num_neg (num.Bit1 ?n1) (num.Bit1 ?m1) ==
  Num.BitM (or_not_num_neg ?n1 ?m1)
  or_not_num_neg (num.Bit1 ?n1) (num.Bit0 ?m1) ==
  Num.BitM (or_not_num_neg ?n1 ?m1)
  or_not_num_neg (num.Bit0 ?n1) num.One == num.Bit0 num.One
  or_not_num_neg (num.Bit0 ?n1) (num.Bit1 ?m1) ==
  num.Bit0 (or_not_num_neg ?n1 ?m1)
  or_not_num_neg (num.Bit0 ?n1) (num.Bit0 ?m1) ==
  Num.BitM (or_not_num_neg ?n1 ?m1)
  case typerep.Typerep ?x1.1 ?x2.1 of typerep.Typerep x xa => ?f1 x xa ==
  ?f1 ?x1.1 ?x2.1
  well_order_on {} {} == True
  case fun_box.FunBox ?x1 of fun_box.FunBox x => ?f1 x == ?f1 ?x1
  sort_key ?f1 [] == []
  sort_key ?f1 (?x1 # ?xs1) == insort_key ?f1 ?x1 (sort_key ?f1 ?xs1)
  sort [?i1..?j1] == [?i1..?j1]
  sort [?m1..<?n1] == [?m1..<?n1]
  rec_typerep ?f1 (typerep.Typerep ?x1.1 ?x2.1) ==
  ?f1 ?x1.1 (map (%typerep. (typerep, rec_typerep ?f1 typerep)) ?x2.1)
  case () of () => ?y == ?y
  case prod.swap ?p1 of (y, x) => ?f1 x y == case ?p1 of (x, y) => ?f1 x y
  case (?a1, ?b1) of (c, d) => ?f1 c d == ?f1 ?a1 ?b1
  case (?x1.1, ?x2.1) of (x, xa) => ?f1 x xa == ?f1 ?x1.1 ?x2.1
  UNIV <= {?l1..} == False
  UNIV <= {..?h1} == False
  UNIV <= {?l1..?h1} == False
  {} <= ?A1 == True
  bot <= ?a1 == True
  (0::?'a1) <= (1::?'a1) == True
  (0::?'a1) <= (1::?'a1) == True
  0 <= ?a1 == True
  (0::?'a1) <= ?x1 == True
  0 <= mask ?n1 == True
  0 <= not ?k1 == ?k1 < 0
  (0::?'a1) <= fact ?n1 == True
  (0::?'a1) <= of_bool ?P1 == True
  (0::?'a1) <= inverse ?a1 == (0::?'a1) <= ?a1
  (0::?'a1) <= of_nat ?n1 == True
  (0::?'a1) <= - (1::?'a1) == False
  (0::?'a1) <= - ?a1 == ?a1 <= (0::?'a1)
  0 <= - int (Suc ?n1) == False
  (0::?'a1) <= - numeral ?n1 == False
  (0::?'a1) <= numeral ?n1 == True
  (0::?'a1) <= of_int ?z1 == 0 <= ?z1
  (0::?'a1) <= \<bar>?a1\<bar> == True
  0 <= Lcm ?K1 == True
  0 <= Gcd ?K1 == True
  0 <= signed_take_bit ?n1 ?k1 == ~ bit ?k1 ?n1
  0 <= unset_bit ?n1 ?k1 == 0 <= ?k1
  0 <= take_bit ?n1 ?k1 == True
  0 <= push_bit ?n1 ?k1 == 0 <= ?k1
  0 <= flip_bit ?n1 ?k1 == 0 <= ?k1
  0 <= drop_bit ?n1 ?k1 == 0 <= ?k1
  0 <= set_bit ?n1 ?k1 == 0 <= ?k1
  [| 0 <= ?x1; 0 <= ?y1 |] ==> 0 <= xor ?x1 ?y1 == True
  0 <= xor ?k1 ?l1 == (0 <= ?k1) = (0 <= ?l1)
  0 <= ?x1 ==> 0 <= and ?x1 ?y1 == True
  0 <= and ?k1 ?l1 == 0 <= ?k1 | 0 <= ?l1
  [| 0 <= ?x1; 0 <= ?y1 |] ==> 0 <= or ?x1 ?y1 == True
  0 <= or ?k1 ?l1 == 0 <= ?k1 & 0 <= ?l1
  (0::?'b1) <= (SUM i:?A1. \<bar>?f1 i\<bar>) == True
  0 < ?l1 ==> 0 <= ?k1 mod ?l1 == True
  (0::?'a1) <= (1::?'a1) / ?a1 == (0::?'a1) <= ?a1
  [| (0::?'a1) <= ?x1; (0::?'a1) <= ?y1 |]
  ==> (0::?'a1) <= ?x1 / ?y1 == True
  0 <= ?k1 div 2 == 0 <= ?k1
  (0::?'a1) <= ?a1 / \<bar>?b1\<bar> == (0::?'a1) <= ?a1 | ?b1 = (0::?'a1)
  (0::?'a1) <= numeral ?w1 / ?b1 ==
  (0::?'a1) <= numeral ?w1 & (0::?'a1) <= ?b1 |
  numeral ?w1 <= (0::?'a1) & ?b1 <= (0::?'a1)
  (0::?'a1) <= ?a1 * ?a1 == True
  [| (0::?'a1) <= ?a1; (0::?'a1) <= ?b1 |]
  ==> (0::?'a1) <= ?a1 * ?b1 == True
  (0::?'a1) <= ?a1 - ?b1 == ?b1 <= ?a1
  (0::?'a1) <= ?a1 ==> (0::?'a1) <= ?a1 ^ ?n1 == True
  (0::?'a1) <= ?a1 ^ numeral ?w1 ==
  even (numeral ?w1) | odd (numeral ?w1) & (0::?'a1) <= ?a1
  (0::?'a1) <= ?a1\<^sup>2 == True
  (0::?'a1) <= ?a1 ^ (2 * ?n1) == True
  (0::?'a1) <= \<bar>?a1\<bar> ^ ?n1 == True
  (0::?'a1) <= ?a1 + ?a1 == (0::?'a1) <= ?a1
  [| (0::?'a1) <= ?a1; (0::?'a1) <= ?b1 |]
  ==> (0::?'a1) <= ?a1 + ?b1 == True
  0 <= lcm ?x1 ?y1 == True
  0 <= gcd ?x1 ?y1 == True
  (0::?'a1) <= ?x1 ==> (0::?'a1) <= ?x1 powi ?n1 == True
  0 <= concat_bit ?n1 ?k1 ?l1 == 0 <= ?l1
  (1::?'a1) <= (0::?'a1) == False
  (1::?'a1) <= fact ?n1 == True
  (1::?'a1) <= - (1::?'a1) == False
  (1::?'a1) <= - ?b1 == ?b1 <= - (1::?'a1)
  (1::?'a1) <= - numeral ?m1 == False
  (1::?'a1) <= numeral ?n1 == True
  (1::?'a1) <= of_int ?z1 == 1 <= ?z1
  (0::?'a1) < ?a1 ==> (1::?'a1) <= ?b1 / ?a1 == ?a1 <= ?b1
  ?a1 < (0::?'a1) ==> (1::?'a1) <= ?b1 / ?a1 == ?b1 <= ?a1
  (1::?'a1) <= ?a1 ==> (1::?'a1) <= ?a1 ^ ?n1 == True
  [| (1::?'a1) <= ?x1; 0 <= ?n1 |] ==> (1::?'a1) <= ?x1 powi ?n1 == True
  num.One <= ?n1 == True
  ?a1 <= top == True
  ?A1 <= {} == ?A1 = {}
  ?n1 <= (0::?'a1) == ?n1 = (0::?'a1)
  ?u1 <= ?v1 == True
  ?P1 <= ?Q1 == ?P1 --> ?Q1
  ?x1 <= ?x1 == True
  [| finite ?A1; ?A1 ~= {} |] ==> ?x1 <= Min ?A1 == ALL a:?A1. ?x1 <= a
  [| finite ?A1; ?x1 : ?A1 |] ==> ?x1 <= Max ?A1 == True
  ?a1 <= - ?a1 == ?a1 <= (0::?'a1)
  ?A1 <= - {?b1} == ?b1 ~: ?A1
  ?a1 <= ?b1 / - numeral ?w1 == ?b1 <= ?a1 * - numeral ?w1
  ?a1 <= ?b1 / numeral ?w1 == ?a1 * numeral ?w1 <= ?b1
  ?w1 <= ?z1 - 1 == ?w1 < ?z1
  2 <= ?k1 ==> ?m1 <= ?k1 ^ ?m1 == True
  ?a1 <= min ?b1 ?c1 == ?a1 <= ?b1 & ?a1 <= ?c1
  ?b1 <= max ?a1 ?b1 == True
  ?a1 <= max ?a1 ?b1 == True
  ?b1 <= sup ?a1 ?b1 == True
  ?a1 <= sup ?a1 ?b1 == True
  ?y1 <= sup ?x1 ?y1 == True
  ?x1 <= sup ?x1 ?y1 == True
  ?C1 <= ?A1 Int ?B1 == ?C1 <= ?A1 & ?C1 <= ?B1
  ?a1 <= inf ?b1 ?c1 == ?a1 <= ?b1 & ?a1 <= ?c1
  ?a1 <= ?b1 + ?a1 == (0::?'a1) <= ?b1
  ?a1 <= ?a1 + ?b1 == (0::?'a1) <= ?b1
  [| finite ?A1; ?A1 ~= {} |]
  ==> \<Sqinter>\<^sub>f\<^sub>i\<^sub>n ?A1
      <= \<Squnion>\<^sub>f\<^sub>i\<^sub>n ?A1 ==
      True
  {?x1<..} <= {?y1<..} == ?y1 <= ?x1
  of_bool ?P1 <= (1::?'a1) == True
  of_bool ?P1 <= of_bool ?Q1 == ?P1 --> ?Q1
  {..<?x1} <= {..<?y1} == ?x1 <= ?y1
  [| finite ?A1; ?x1 : ?A1 |] ==> Min ?A1 <= ?x1 == True
  [| finite ?A1; ?A1 ~= {} |] ==> Max ?A1 <= ?x1 == ALL a:?A1. a <= ?x1
  {?x1..} <= {?y1..} == ?y1 <= ?x1
  {?l1..} <= {..?h'1} == False
  {?l1..} <= {?l'1..?h'1} == False
  {..?h1} <= {?l'1..} == False
  {..?x1} <= {..?y1} == ?x1 <= ?y1
  {..?h1} <= {?l'1..?h'1} == False
  inverse ?a1 <= (0::?'a1) == ?a1 <= (0::?'a1)
  [| (0::?'a1) < ?a1; (0::?'a1) < ?b1 |]
  ==> inverse ?a1 <= inverse ?b1 == ?b1 <= ?a1
  [| ?a1 < (0::?'a1); ?b1 < (0::?'a1) |]
  ==> inverse ?a1 <= inverse ?b1 == ?b1 <= ?a1
  of_nat ?m1 <= (0::?'a1) == ?m1 = 0
  ?i1 <= ?j1 ==> of_nat ?i1 <= of_nat ?j1 == True
  of_nat ?m1 <= of_nat ?n1 == ?m1 <= ?n1
  of_nat ?x1 <= of_nat ?b1 ^ ?w1 == ?x1 <= ?b1 ^ ?w1
  of_nat ?x1 <= numeral ?i1 ^ ?n1 == ?x1 <= numeral ?i1 ^ ?n1
  - (1::?'a1) <= (0::?'a1) == True
  - (1::?'a1) <= (1::?'a1) == True
  - (1::?'a1) <= numeral ?m1 == True
  - ?a1 <= (0::?'a1) == (0::?'a1) <= ?a1
  - ?a1 <= (1::?'a1) == - (1::?'a1) <= ?a1
  - ?a1 <= ?a1 == (0::?'a1) <= ?a1
  - ?A1 <= - ?B1 == ?B1 <= ?A1
  - ?x1 <= - ?y1 == ?y1 <= ?x1
  - ?b1 <= - ?a1 == ?a1 <= ?b1
  - int ?n1 <= int ?m1 == True
  - numeral ?n1 <= (0::?'a1) == True
  - numeral ?m1 <= (1::?'a1) == True
  - numeral ?m1 <= - (1::?'a1) == True
  - numeral ?m1 <= - numeral ?n1 == ?n1 <= ?m1
  - numeral ?m1 <= numeral ?n1 == True
  - (2 ^ ?n1) <= signed_take_bit ?n1 ?k1 == True
  numeral ?n1 <= (0::?'a1) == False
  numeral ?n1 <= (1::?'a1) == ?n1 <= num.One
  numeral ?m1 <= - (1::?'a1) == False
  numeral ?m1 <= - numeral ?n1 == False
  numeral ?m1 <= numeral ?n1 == ?m1 <= ?n1
  numeral ?n1 <= of_int ?z1 == numeral ?n1 <= ?z1
  numeral ?k1 <= Suc ?n1 == pred_numeral ?k1 <= ?n1
  of_int ?z1 <= (0::?'a1) == ?z1 <= 0
  of_int ?z1 <= (1::?'a1) == ?z1 <= 1
  of_int ?z1 <= numeral ?n1 == ?z1 <= numeral ?n1
  of_int ?w1 <= of_int ?z1 == ?w1 <= ?z1
  of_int ?a1 <= (- numeral ?x1) ^ ?n1 == ?a1 <= (- numeral ?x1) ^ ?n1
  of_int ?a1 <= numeral ?x1 ^ ?n1 == ?a1 <= numeral ?x1 ^ ?n1
  of_int ?x1 <= of_int ?b1 ^ ?w1 == ?x1 <= ?b1 ^ ?w1
  \<bar>?a1\<bar> <= (0::?'a1) == ?a1 = (0::?'a1)
  \<bar>?a1\<bar> <= ?a1 == (0::?'a1) <= ?a1
  \<bar>sum ?f1 ?A1\<bar> <= (SUM i:?A1. \<bar>?f1 i\<bar>) == True
  length (remdups_adj ?xs1) <= length ?xs1 == True
  length (remdups ?xs1) <= length ?xs1 == True
  length (removeAll ?x1 ?xs1) <= length ?xs1 == True
  length (filter ?P1 ?xs1) <= length ?xs1 == True
  ?r1^--1 <= ?s1^--1 == ?r1 <= ?s1
  ?r1^-1 <= ?s1^-1 == ?r1 <= ?s1
  principal ?A1 <= principal ?B1 == ?A1 <= ?B1
  set (filter ?P1 ?xs1) <= set ?xs1 == True
  num.Bit1 ?m1 <= num.One == False
  num.Bit1 ?m1 <= num.Bit1 ?n1 == ?m1 <= ?n1
  num.Bit1 ?m1 <= num.Bit0 ?n1 == ?m1 < ?n1
  num.Bit0 ?m1 <= num.One == False
  num.Bit0 ?m1 <= num.Bit1 ?n1 == ?m1 <= ?n1
  num.Bit0 ?m1 <= num.Bit0 ?n1 == ?m1 <= ?n1
  {x: ?A1. ?P1 x} <= ?A1 == True
  Suc 0 <= fact ?n1 == True
  ?xs1 ~= [] ==> Suc 0 <= length (remdups_adj ?xs1) == True
  Suc 0 <= ?m1 * ?n1 == Suc 0 <= ?m1 & Suc 0 <= ?n1
  Suc 0 <= ?i1 ==> Suc 0 <= ?i1 ^ ?n1 == True
  Suc ?n1 <= numeral ?k1 == ?n1 <= pred_numeral ?k1
  Suc ?n1 <= Suc ?m1 == ?n1 <= ?m1
  nat ?a1 <= numeral ?x1 ^ ?n1 == ?a1 <= numeral ?x1 ^ ?n1
  take_bit ?n1 ?m1 <= ?m1 == True
  [| 0 <= ?y1; ?y1 <= ?z1 |] ==> and ?x1 ?y1 <= ?z1 == True
  0 <= ?y1 ==> and ?x1 ?y1 <= ?y1 == True
  [| 0 <= ?y1; ?y1 <= ?z1 |] ==> and ?y1 ?ya1 <= ?z1 == True
  0 <= ?x1 ==> and ?x1 ?y1 <= ?x1 == True
  {?i1..<?j1} <= {?m1..<?n1} == ?j1 <= ?i1 | ?m1 <= ?i1 & ?j1 <= ?n1
  {?l1..?h1} <= {?l'1..} == ~ ?l1 <= ?h1 | ?l'1 <= ?l1
  {?l1..?h1} <= {..?h'1} == ~ ?l1 <= ?h1 | ?h1 <= ?h'1
  {?a1..?b1} <= {?c1..?d1} == ~ ?a1 <= ?b1 | ?c1 <= ?a1 & ?b1 <= ?d1
  ?l1 < 0 ==> ?k1 mod ?l1 <= 0 == True
  ?m1 mod ?n1 <= ?m1 == True
  0 < ?n1 ==> ?m1 mod ?n1 <= ?n1 == True
  ?m1 mod Suc ?n1 <= ?n1 == True
  (1::?'a1) / ?a1 <= (0::?'a1) == ?a1 <= (0::?'a1)
  (0::?'a1) < ?a1 ==> ?b1 / ?a1 <= (1::?'a1) == ?b1 <= ?a1
  ?a1 < (0::?'a1) ==> ?b1 / ?a1 <= (1::?'a1) == ?a1 <= ?b1
  ?m1 div ?n1 <= ?m1 == True
  ?m1 div ?n1 <= Suc ?m1 div ?n1 == True
  ?b1 / - numeral ?w1 <= ?a1 == ?a1 * - numeral ?w1 <= ?b1
  ?b1 / numeral ?w1 <= ?a1 == ?b1 <= ?a1 * numeral ?w1
  ?a1 / \<bar>?b1\<bar> <= (0::?'a1) == ?a1 <= (0::?'a1) | ?b1 = (0::?'a1)
  numeral ?w1 / ?b1 <= (0::?'a1) ==
  (0::?'a1) <= numeral ?w1 & ?b1 <= (0::?'a1) |
  numeral ?w1 <= (0::?'a1) & (0::?'a1) <= ?b1
  ?k1 * ?m1 <= ?k1 * ?n1 == 0 < ?k1 --> ?m1 <= ?n1
  ?m1 * ?k1 <= ?n1 * ?k1 == 0 < ?k1 --> ?m1 <= ?n1
  ?a1 * numeral ?v1 <= ?b1 * numeral ?v1 ==
  ((0::?'a1) < numeral ?v1 --> ?a1 <= ?b1) &
  (numeral ?v1 < (0::?'a1) --> ?b1 <= ?a1)
  ?n1 * (?m1 div ?n1) <= ?m1 == True
  numeral ?v1 * ?a1 <= numeral ?v1 * ?b1 ==
  ((0::?'a1) < numeral ?v1 --> ?a1 <= ?b1) &
  (numeral ?v1 < (0::?'a1) --> ?b1 <= ?a1)
  ?m1 div ?n1 * ?n1 <= ?m1 == True
  ?a1 - ?b1 <= (0::?'a1) == ?a1 <= ?b1
  ?m1 - ?n1 <= ?m1 == True
  ?A1 - ?B1 <= ?A1 == True
  2 <= ?k1 ==> ?m1 - ?n1 <= ?k1 ^ ?m1 - ?k1 ^ ?n1 == True
  (1::?'a1) < ?b1 ==> ?b1 ^ ?x1 <= ?b1 ^ ?y1 == ?x1 <= ?y1
  [| (0::?'a1) < ?b1; ?b1 < (1::?'a1) |]
  ==> ?b1 ^ ?m1 <= ?b1 ^ ?n1 == ?n1 <= ?m1
  [| (0::?'a1) <= ?a1; (0::?'a1) <= ?b1; 0 < ?n1 |]
  ==> ?a1 ^ ?n1 <= ?b1 ^ ?n1 == ?a1 <= ?b1
  ?a1 ^ numeral ?w1 <= (0::?'a1) ==
  0 < numeral ?w1 &
  (odd (numeral ?w1) & ?a1 <= (0::?'a1) |
   even (numeral ?w1) & ?a1 = (0::?'a1))
  ?a1\<^sup>2 <= (0::?'a1) == ?a1 = (0::?'a1)
  of_nat ?b1 ^ ?w1 <= of_nat ?x1 == ?b1 ^ ?w1 <= ?x1
  (- numeral ?x1) ^ ?n1 <= of_int ?a1 == (- numeral ?x1) ^ ?n1 <= ?a1
  numeral ?i1 ^ ?n1 <= of_nat ?x1 == numeral ?i1 ^ ?n1 <= ?x1
  numeral ?x1 ^ ?n1 <= of_int ?a1 == numeral ?x1 ^ ?n1 <= ?a1
  numeral ?x1 ^ ?n1 <= nat ?a1 == numeral ?x1 ^ ?n1 <= ?a1
  2 ^ ?n1 <= 0 == False
  of_int ?b1 ^ ?w1 <= of_int ?x1 == ?b1 ^ ?w1 <= ?x1
  min ?a1 ?b1 <= ?b1 == True
  min ?a1 ?b1 <= ?a1 == True
  max ?b1 ?c1 <= ?a1 == ?b1 <= ?a1 & ?c1 <= ?a1
  ?A1 Un ?B1 <= ?C1 == ?A1 <= ?C1 & ?B1 <= ?C1
  sup ?b1 ?c1 <= ?a1 == ?b1 <= ?a1 & ?c1 <= ?a1
  inf ?a1 ?b1 <= ?b1 == True
  inf ?a1 ?b1 <= ?a1 == True
  inf ?x1 ?y1 <= ?y1 == True
  inf ?x1 ?y1 <= ?x1 == True
  ?a1 + ?a1 <= (0::?'a1) == ?a1 <= (0::?'a1)
  ?a1 + ?b1 <= ?b1 == ?a1 <= (0::?'a1)
  ?b1 + ?a1 <= ?b1 == ?a1 <= (0::?'a1)
  ?k1 + ?m1 <= ?k1 + ?n1 == ?m1 <= ?n1
  ?a1 + ?c1 <= ?b1 + ?c1 == ?a1 <= ?b1
  ?c1 + ?a1 <= ?c1 + ?b1 == ?a1 <= ?b1
  0 < ?b1 ==> gcd ?a1 ?b1 <= ?b1 == True
  0 < ?a1 ==> gcd ?a1 ?b1 <= ?a1 == True
  ?b1 ~= 0 ==> gcd ?a1 ?b1 <= ?b1 == True
  ?a1 ~= 0 ==> gcd ?a1 ?b1 <= ?a1 == True
  [| (0::?'a1) <= ?a1; (0::?'a1) <= ?b1; 0 < ?n1 |]
  ==> ?a1 powi ?n1 <= ?b1 powi ?n1 == ?a1 <= ?b1
  insert ?x1 ?A1 <= ?B1 == ?x1 : ?B1 & ?A1 <= ?B1
  rec_fun_box ?f1 (fun_box.FunBox ?x1) == ?f1 ?x1
  case a\<^sub>1 of a\<^sub>1 => ?y == ?y
  take_bit_num 0 ?m1 == None
  take_bit_num (numeral ?r1) num.One == Some num.One
  take_bit_num (numeral ?r1) (num.Bit1 ?m1) ==
  Some
   (case take_bit_num (pred_numeral ?r1) ?m1 of None => num.One
    | Some q => num.Bit1 q)
  take_bit_num (numeral ?r1) (num.Bit0 ?m1) ==
  case take_bit_num (pred_numeral ?r1) ?m1 of None => None
  | Some q => Some (num.Bit0 q)
  take_bit_num (Suc ?n1) num.One == Some num.One
  take_bit_num (Suc ?n1) (num.Bit1 ?m1) ==
  Some (case take_bit_num ?n1 ?m1 of None => num.One | Some q => num.Bit1 q)
  take_bit_num (Suc ?n1) (num.Bit0 ?m1) ==
  case take_bit_num ?n1 ?m1 of None => None | Some q => Some (num.Bit0 q)
  ntrancl 0 ?y == ?y
  ntrancl (Suc ?n1) ?R1 == ntrancl ?n1 ?R1 O (Id Un ?R1)
  preorder_on {} {} == True
  preorder_on ?A1 (?r1^-1) == preorder_on ?A1 ?r1
  (- ?A1) ?x1 == - ?A1 ?x1
  rec_finite_1 ?y a\<^sub>1 == ?y
  and_not_num num.One num.One == None
  and_not_num num.One (num.Bit1 ?n1) == None
  and_not_num num.One (num.Bit0 ?n1) == Some num.One
  and_not_num (num.Bit1 ?m1) num.One == Some (num.Bit0 ?m1)
  and_not_num (num.Bit1 ?m1) (num.Bit1 ?n1) ==
  map_option num.Bit0 (and_not_num ?m1 ?n1)
  and_not_num (num.Bit1 ?m1) (num.Bit0 ?n1) ==
  case and_not_num ?m1 ?n1 of None => Some num.One
  | Some n' => Some (num.Bit1 n')
  and_not_num (num.Bit0 ?m1) num.One == Some (num.Bit0 ?m1)
  and_not_num (num.Bit0 ?m1) (num.Bit1 ?n1) ==
  map_option num.Bit0 (and_not_num ?m1 ?n1)
  and_not_num (num.Bit0 ?m1) (num.Bit0 ?n1) ==
  map_option num.Bit0 (and_not_num ?m1 ?n1)
  (0::?'a1) mod ?a1 == 0::?'a1
  (0::?'a1) mod ?a1 == 0::?'a1
  1 mod - numeral ?n1 ==
  - Divides.adjust_mod (numeral ?n1) (snd (divmod num.One ?n1))
  (1::?'a1) mod numeral ?n1 == snd (divmod num.One ?n1)
  (1::?'a1) mod (2::?'a1) == 1::?'a1
  (1::?'a1) mod (2::?'a1) == 1::?'a1
  (1::?'a1) mod (2::?'a1) ^ ?n1 == of_bool (0 < ?n1)
  ?y mod (0::?'a1) == ?y
  ?a1 mod (1::?'a1) == 0::?'a1
  ?a1 mod (1::?'a1) == 0::?'a1
  [| ?y <= 0; ?l1 < ?y |] ==> ?y mod ?l1 == ?y
  [| 0 <= ?y; ?y < ?l1 |] ==> ?y mod ?l1 == ?y
  ?y < ?n1 ==> ?y mod ?n1 == ?y
  ?a1 dvd ?b1 ==> ?b1 mod ?a1 == 0::?'a1
  ?a1 mod ?a1 == 0::?'a1
  ?a1 mod - (1::?'a1) == 0::?'a1
  ?m1 mod Suc 0 == 0
  ?m1 mod Suc (Suc (Suc ?n1)) == ?m1 mod (3 + ?n1)
  of_char ?c1 mod (256::?'a1) == of_char ?c1
  - 1 mod numeral ?n1 ==
  Divides.adjust_mod (numeral ?n1) (snd (divmod num.One ?n1))
  - (1::?'a1) mod (2::?'a1) == 1::?'a1
  - (1::?'a1) mod (2::?'a1) == 1::?'a1
  - ?a1 mod - ?b1 == - (?a1 mod ?b1)
  - numeral ?m1 mod numeral ?n1 ==
  Divides.adjust_mod (numeral ?n1) (snd (divmod ?m1 ?n1))
  numeral ?m1 mod - numeral ?n1 ==
  - Divides.adjust_mod (numeral ?n1) (snd (divmod ?m1 ?n1))
  numeral ?k1 mod numeral ?l1 == snd (divmod ?k1 ?l1)
  numeral (num.Bit1 ?v1) mod numeral (num.Bit0 ?w1) ==
  2 * (numeral ?v1 mod numeral ?w1) + 1
  numeral (num.Bit0 ?v1) mod numeral (num.Bit0 ?w1) ==
  2 * (numeral ?v1 mod numeral ?w1)
  Suc 0 mod ?n1 == of_bool (?n1 ~= Suc 0)
  Suc 0 mod numeral ?k1 == snd (divmod num.One ?k1)
  Suc (Suc ?m1) mod 2 == ?m1 mod 2
  Suc (Suc (Suc ?m1)) mod numeral ?v1 == (3 + ?m1) mod numeral ?v1
  numeral ?k1 ~= 1 ==> Suc (numeral ?k1 * ?n1) mod numeral ?k1 == 1
  Suc (?m1 + ?n1 * ?k1) mod ?n1 == Suc ?m1 mod ?n1
  Suc (?m1 + ?k1 * ?n1) mod ?n1 == Suc ?m1 mod ?n1
  Suc (?n1 * ?k1 + ?m1) mod ?n1 == Suc ?m1 mod ?n1
  Suc (?k1 * ?n1 + ?m1) mod ?n1 == Suc ?m1 mod ?n1
  ?a1 mod ?b1 mod ?b1 == ?a1 mod ?b1
  ?a1 * ?b1 mod ?b1 == 0::?'a1
  ?b1 * ?a1 mod ?b1 == 0::?'a1
  (?b1 - ?a1) mod ?b1 == - ?a1 mod ?b1
  (?a1 - ?b1) mod ?b1 == ?a1 mod ?b1
  [| even ?a1; 0 < ?n1 |]
  ==> ((1::?'a1) + ?a1) mod (2::?'a1) ^ ?n1 ==
      (1::?'a1) + ?a1 mod (2::?'a1) ^ ?n1
  (?a1 + ?b1) mod ?b1 == ?a1 mod ?b1
  (?b1 + ?a1) mod ?b1 == ?a1 mod ?b1
  (?m1 + ?m1) mod 2 == 0
  (?a1 + ?b1 * ?c1) mod ?b1 == ?a1 mod ?b1
  (?a1 + ?c1 * ?b1) mod ?b1 == ?a1 mod ?b1
  (?b1 * ?c1 + ?a1) mod ?b1 == ?a1 mod ?b1
  (?c1 * ?b1 + ?a1) mod ?b1 == ?a1 mod ?b1
  (0::?'a1) div ?a1 == 0::?'a1
  (0::?'a1) div ?a1 == 0::?'a1
  1 div - numeral ?n1 == - Divides.adjust_div (divmod num.One ?n1)
  (1::?'a1) div numeral ?n1 == fst (divmod num.One ?n1)
  (1::?'a1) div (2::?'a1) == 0::?'a1
  (1::?'a1) div (2::?'a1) == 0::?'a1
  is_unit ?y ==> (1::?'a1) div ((1::?'a1) div ?y) == ?y
  (1::?'a1) div (2::?'a1) ^ ?n1 == of_bool (?n1 = 0)
  (1::?'a1) div (2::?'a1) ^ ?n1 == of_bool (?n1 = 0)
  ?a1 div (0::?'a1) == 0::?'a1
  ?a1 div (0::?'a1) == 0::?'a1
  ?a1 / (0::?'a1) == 0::?'a1
  ?y div (1::?'a1) == ?y
  ?y div (1::?'a1) == ?y
  [| ?k1 <= 0; ?l1 < ?k1 |] ==> ?k1 div ?l1 == 0
  [| 0 <= ?k1; ?k1 < ?l1 |] ==> ?k1 div ?l1 == 0
  ?m1 < ?n1 ==> ?m1 div ?n1 == 0
  ?a1 ~= (0::?'a1) ==> ?a1 div ?a1 == 1::?'a1
  ?a1 ~= (0::?'a1) ==> ?a1 / ?a1 == 1::?'a1
  ?a1 / ?a1 == if ?a1 = (0::?'a1) then 0::?'a1 else (1::?'a1)
  ?a1 div normalize ?a1 == unit_factor ?a1
  ?a1 div unit_factor ?a1 == normalize ?a1
  ?a1 div - (1::?'a1) == - ?a1
  ?x1 / - (1::?'a1) == - ?x1
  ?a1 / - ?b1 == - (?a1 / ?b1)
  ?a1 / sgn ?b1 == ?a1 * sgn ?b1
  ?y div Suc 0 == ?y
  ?m1 div Suc (Suc (Suc ?n1)) == ?m1 div (3 + ?n1)
  ?a1 / (?b1 / ?c1) == ?a1 * ?c1 / ?b1
  ?b1 ~= (0::?'a1) ==> ?b1 / (?a1 * ?b1) == (1::?'a1) / ?a1
  ?a1 ~= (0::?'a1) ==> ?a1 / (?a1 * ?b1) == (1::?'a1) / ?b1
  normalize ?a1 div ?a1 == (1::?'a1) div unit_factor ?a1
  of_bool ?b1 div (2::?'a1) == 0::?'a1
  - 1 div numeral ?n1 == - Divides.adjust_div (divmod num.One ?n1)
  - (1::?'a1) div (2::?'a1) == - (1::?'a1)
  - ?a1 / ?b1 == - (?a1 / ?b1)
  - ?a1 div - ?b1 == ?a1 div ?b1
  - numeral ?m1 div numeral ?n1 == - Divides.adjust_div (divmod ?m1 ?n1)
  numeral ?m1 div - numeral ?n1 == - Divides.adjust_div (divmod ?m1 ?n1)
  numeral ?k1 div numeral ?l1 == fst (divmod ?k1 ?l1)
  numeral (num.Bit1 ?v1) div numeral (num.Bit0 ?w1) ==
  numeral ?v1 div numeral ?w1
  numeral (num.Bit0 ?v1) div numeral (num.Bit0 ?w1) ==
  numeral ?v1 div numeral ?w1
  Suc 0 div numeral ?k1 == fst (divmod num.One ?k1)
  odd ?n1 ==> Suc ?n1 div 2 == Suc (?n1 div 2)
  even ?n1 ==> Suc ?n1 div 2 == ?n1 div 2
  Suc (Suc ?m1) div 2 == Suc (?m1 div 2)
  Suc (Suc (Suc ?m1)) div numeral ?v1 == (3 + ?m1) div numeral ?v1
  ?a1 mod ?b1 div ?b1 == 0::?'a1
  ?a1 mod ?b1 div ?b1 == 0::?'a1
  ?a1 / ?b1 / ?c1 == ?a1 / (?b1 * ?c1)
  0 < ?n1 ==> ?n1 * ?y div ?n1 == ?y
  0 < ?n1 ==> ?y * ?n1 div ?n1 == ?y
  ?a1 ~= (0::?'a1) ==> ?a1 * ?y div ?a1 == ?y
  ?b1 ~= (0::?'a1) ==> ?y * ?b1 div ?b1 == ?y
  ?k1 * ?m1 div (?k1 * ?n1) == if ?k1 = 0 then 0 else ?m1 div ?n1
  ?c1 * ?a1 div (?c1 * ?b1) ==
  if ?c1 = (0::?'a1) then 0::?'a1 else ?a1 div ?b1
  ?c1 ~= (0::?'a1) ==> ?a1 * ?c1 div (?b1 * ?c1) == ?a1 div ?b1
  ?c1 ~= (0::?'a1) ==> ?c1 * ?a1 div (?c1 * ?b1) == ?a1 div ?b1
  ?c1 ~= (0::?'a1) ==> ?c1 * ?a1 / (?c1 * ?b1) == ?a1 / ?b1
  ?c1 ~= (0::?'a1) ==> ?a1 * ?c1 / (?b1 * ?c1) == ?a1 / ?b1
  ?c1 ~= (0::?'a1) ==> ?c1 * ?a1 / (?b1 * ?c1) == ?a1 / ?b1
  ?c1 ~= (0::?'a1) ==> ?a1 * ?c1 / (?c1 * ?b1) == ?a1 / ?b1
  ?c1 * ?a1 / (?c1 * ?b1) == if ?c1 = (0::?'a1) then 0::?'a1 else ?a1 / ?b1
  [| ?c1 dvd ?a1; ?c1 dvd ?b1 |]
  ==> (?a1 - ?b1) div ?c1 == ?a1 div ?c1 - ?b1 div ?c1
  even ?a1 ==> ((1::?'a1) + ?a1) div (2::?'a1) == ?a1 div (2::?'a1)
  [| even ?a1; 0 < ?n1 |]
  ==> ((1::?'a1) + ?a1) div (2::?'a1) ^ ?n1 == ?a1 div (2::?'a1) ^ ?n1
  odd ?a1 ==>
  (?a1 + (1::?'a1)) div (2::?'a1) == ?a1 div (2::?'a1) + (1::?'a1)
  even ?a1 ==> (?a1 + (1::?'a1)) div (2::?'a1) == ?a1 div (2::?'a1)
  [| ?c1 dvd ?a1; ?c1 dvd ?b1 |]
  ==> (?a1 + ?b1) div ?c1 == ?a1 div ?c1 + ?b1 div ?c1
  (?y + ?y) div 2 == ?y
  ?b1 ~= (0::?'a1) ==> (?a1 + ?b1 * ?c1) div ?b1 == ?c1 + ?a1 div ?b1
  ?b1 ~= (0::?'a1) ==> (?a1 + ?c1 * ?b1) div ?b1 == ?c1 + ?a1 div ?b1
  ?b1 ~= (0::?'a1) ==> (?b1 * ?c1 + ?a1) div ?b1 == ?c1 + ?a1 div ?b1
  ?b1 ~= (0::?'a1) ==> (?c1 * ?b1 + ?a1) div ?b1 == ?c1 + ?a1 div ?b1
  ??.Quickcheck_Narrowing.conv ?cs1
   (narrowing_term.Narrowing_constructor ?i1 ?xs1) ==
  ??.Quickcheck_Narrowing.nth ?cs1 ?i1 ?xs1
  ??.Quickcheck_Narrowing.conv ?cs1
   (narrowing_term.Narrowing_variable ?p1 ?uu1) ==
  ??.Quickcheck_Narrowing.error
   (??.Quickcheck_Narrowing.marker # map ??.Quickcheck_Narrowing.toEnum ?p1)
  size_option ?x1 None == Suc 0
  size_option ?x1 (Some ?x2.1) == ?x1 ?x2.1 + Suc 0
  pred_option ?P1 None == True
  pred_option ?P1 (Some ?a1) == ?P1 ?a1
  neg_numeral_class.sub num.One num.One == 0::?'a1
  neg_numeral_class.sub num.One (num.Bit1 ?l1) == - numeral (num.Bit0 ?l1)
  neg_numeral_class.sub num.One (num.Bit0 ?l1) == - numeral (Num.BitM ?l1)
  neg_numeral_class.sub (num.Bit1 ?k1) num.One == numeral (num.Bit0 ?k1)
  neg_numeral_class.sub (num.Bit1 ?k1) (num.Bit1 ?l1) ==
  neg_numeral_class.dbl (neg_numeral_class.sub ?k1 ?l1)
  neg_numeral_class.sub (num.Bit1 ?k1) (num.Bit0 ?l1) ==
  neg_numeral_class.dbl_inc (neg_numeral_class.sub ?k1 ?l1)
  neg_numeral_class.sub (num.Bit0 ?k1) num.One == numeral (Num.BitM ?k1)
  neg_numeral_class.sub (num.Bit0 ?k1) (num.Bit1 ?l1) ==
  neg_numeral_class.dbl_dec (neg_numeral_class.sub ?k1 ?l1)
  neg_numeral_class.sub (num.Bit0 ?k1) (num.Bit0 ?l1) ==
  neg_numeral_class.dbl (neg_numeral_class.sub ?k1 ?l1)
  lexordp_eq [] ?ys1 == True
  lexordp_eq ?xs1 [] == ?xs1 = []
  lexordp_eq (?x1 # ?xs1) [] == False
  lexordp_eq (?x1 # ?xs1) (?y1 # ?ys1) ==
  ?x1 < ?y1 | ~ ?y1 < ?x1 & lexordp_eq ?xs1 ?ys1
  small_lazy' ?d1 ?i1 ==
  if ?d1 < ?i1 then Lazy_Sequence.empty
  else Lazy_Sequence.append (Lazy_Sequence.single ?i1)
        (small_lazy' ?d1 (?i1 + 1))
  case pred.Pred ?x1 of pred.Pred x => ?f1 x == ?f1 ?x1
  top < ?a1 == False
  (0::?'a1) < (1::?'a1) == True
  0 < euclidean_size ?b1 == ?b1 ~= (0::?'a1)
  0 < mask ?n1 == 0 < ?n1
  (0::?'a1) < fact ?n1 == True
  (0::?'a1) < of_bool ?y == ?y
  (0::?'a1) < inverse ?a1 == (0::?'a1) < ?a1
  (0::?'a1) < of_nat ?n1 == 0 < ?n1
  (0::?'a1) < - (1::?'a1) == False
  (0::?'a1) < - ?a1 == ?a1 < (0::?'a1)
  (0::?'a1) < - numeral ?n1 == False
  (0::?'a1) < numeral ?n1 == True
  (0::?'a1) < of_int ?z1 == 0 < ?z1
  (0::?'a1) < sgn ?a1 == (0::?'a1) < ?a1
  (0::?'a1) < \<bar>?a1\<bar> == ?a1 ~= (0::?'a1)
  0 < length ?xs1 == ?xs1 ~= []
  0 < Suc ?n1 == True
  0 < nat ?z1 == 0 < ?z1
  finite ?A1 ==> 0 < prod ?f1 ?A1 == ALL a:?A1. 0 < ?f1 a
  0 < ?m1 mod 2 == ?m1 mod 2 = 1
  (0::?'a1) < (1::?'a1) / ?a1 == (0::?'a1) < ?a1
  [| (0::?'a1) < ?x1; (0::?'a1) < ?y1 |] ==> (0::?'a1) < ?x1 / ?y1 == True
  Suc 0 < ?n1 ==> 0 < ?n1 div 2 == True
  (0::?'a1) < ?a1 ==> (0::?'a1) < ?a1 / (2::?'a1) == True
  (0::?'a1) < numeral ?w1 / ?b1 ==
  (0::?'a1) < numeral ?w1 & (0::?'a1) < ?b1 |
  numeral ?w1 < (0::?'a1) & ?b1 < (0::?'a1)
  0 < ?n1 ==> 0 < Suc ?n1 div 2 == True
  [| (0::?'a1) < ?a1; (0::?'a1) < ?b1 |] ==> (0::?'a1) < ?a1 * ?b1 == True
  0 < ?m1 * ?n1 == 0 < ?m1 & 0 < ?n1
  0 < ?n1 - ?m1 == ?m1 < ?n1
  (0::?'a1) < ?a1 - ?b1 == ?b1 < ?a1
  0 < ?x1 ^ ?n1 == 0 < ?x1 | ?n1 = 0
  (0::?'a1) < ?a1 ==> (0::?'a1) < ?a1 ^ ?n1 == True
  (0::?'a1) < ?a1 ^ numeral ?w1 ==
  numeral ?w1 = 0 |
  even (numeral ?w1) & ?a1 ~= (0::?'a1) |
  odd (numeral ?w1) & (0::?'a1) < ?a1
  (0::?'a1) < ?a1\<^sup>2 == ?a1 ~= (0::?'a1)
  (0::?'a1) < of_nat ?x1 ^ ?n1 == 0 < ?x1 | ?n1 = 0
  (0::?'a1) < \<bar>?a1\<bar> ^ ?n1 == ?a1 ~= (0::?'a1) | ?n1 = 0
  0 < ?m1 + ?n1 == 0 < ?m1 | 0 < ?n1
  (0::?'a1) < ?a1 + ?a1 == (0::?'a1) < ?a1
  0 < gcd ?m1 ?n1 == ?m1 ~= 0 | ?n1 ~= 0
  0 < gcd ?m1 ?n1 == ?m1 ~= 0 | ?n1 ~= 0
  0 < ?n1 choose ?k1 == ?k1 <= ?n1
  (0::?'a1) < ?x1 ==> (0::?'a1) < ?x1 powi ?n1 == True
  (1::?'a1) < (0::?'a1) == False
  (1::?'a1) < - (1::?'a1) == False
  (1::?'a1) < - ?b1 == ?b1 < - (1::?'a1)
  (1::?'a1) < - numeral ?m1 == False
  (1::?'a1) < numeral ?n1 == num.One < ?n1
  (1::?'a1) < of_int ?z1 == 1 < ?z1
  (0::?'a1) < ?a1 ==> (1::?'a1) < ?b1 / ?a1 == ?a1 < ?b1
  ?a1 < (0::?'a1) ==> (1::?'a1) < ?b1 / ?a1 == ?b1 < ?a1
  [| (1::?'a1) < ?a1; 0 < ?n1 |] ==> (1::?'a1) < ?a1 ^ ?n1 == True
  num.One < num.Bit1 ?n1 == True
  num.One < num.Bit0 ?n1 == True
  ?A1 < {} == False
  ?a1 < bot == False
  ?a1 < 0 == False
  ?n1 < (0::?'a1) == False
  ?n1 < 1 == ?n1 = 0
  ?m1 < num.One == False
  ?u1 < ?v1 == False
  ?P1 < ?Q1 == ~ ?P1 & ?Q1
  ?x1 < ?x1 == False
  [| finite ?A1; ?A1 ~= {} |] ==> ?x1 < Min ?A1 == ALL a:?A1. ?x1 < a
  ?a1 < - ?a1 == ?a1 < (0::?'a1)
  ?n1 < Suc 0 == ?n1 = 0
  ?n1 < Suc ?n1 == True
  ?l1 < 0 ==> ?l1 < ?k1 mod ?l1 == True
  ?a1 < ?b1 / - numeral ?w1 == ?b1 < ?a1 * - numeral ?w1
  ?a1 < ?b1 / numeral ?w1 == ?a1 * numeral ?w1 < ?b1
  ?n1 < 2 ^ ?n1 == True
  ?z1 < min ?x1 ?y1 == ?z1 < ?x1 & ?z1 < ?y1
  ?w1 < ?z1 + 1 == ?w1 <= ?z1
  ?a1 < ?b1 + ?a1 == (0::?'a1) < ?b1
  ?a1 < ?a1 + ?b1 == (0::?'a1) < ?b1
  mask ?n1 < 0 == False
  mask ?n1 < 2 ^ ?n1 == True
  not ?k1 < 0 == 0 <= ?k1
  of_char ?c1 < 256 == True
  fact ?n1 < (0::?'a1) == False
  of_bool ?P1 < (1::?'a1) == ~ ?P1
  of_bool ?P1 < of_bool ?Q1 == ~ ?P1 & ?Q1
  [| finite ?A1; ?A1 ~= {} |] ==> Max ?A1 < ?x1 == ALL a:?A1. a < ?x1
  inverse ?a1 < (0::?'a1) == ?a1 < (0::?'a1)
  [| (0::?'a1) < ?a1; (0::?'a1) < ?b1 |]
  ==> inverse ?a1 < inverse ?b1 == ?b1 < ?a1
  [| ?a1 < (0::?'a1); ?b1 < (0::?'a1) |]
  ==> inverse ?a1 < inverse ?b1 == ?b1 < ?a1
  of_nat ?m1 < (0::?'a1) == False
  of_nat ?m1 < of_nat ?n1 == ?m1 < ?n1
  int ?n1 < - int ?m1 == False
  of_nat ?x1 < of_nat ?b1 ^ ?w1 == ?x1 < ?b1 ^ ?w1
  of_nat ?x1 < numeral ?i1 ^ ?n1 == ?x1 < numeral ?i1 ^ ?n1
  - (1::?'a1) < (0::?'a1) == True
  - (1::?'a1) < (1::?'a1) == True
  - (1::?'a1) < - numeral ?m1 == False
  - (1::?'a1) < numeral ?m1 == True
  - ?a1 < (0::?'a1) == (0::?'a1) < ?a1
  - ?a1 < (1::?'a1) == - (1::?'a1) < ?a1
  - ?a1 < ?a1 == (0::?'a1) < ?a1
  - ?x1 < - ?y1 == ?y1 < ?x1
  - ?b1 < - ?a1 == ?a1 < ?b1
  - int (Suc ?n1) < int ?m1 == True
  - numeral ?n1 < (0::?'a1) == True
  - numeral ?m1 < (1::?'a1) == True
  - numeral ?m1 < - (1::?'a1) == ?m1 ~= num.One
  - numeral ?m1 < - numeral ?n1 == ?n1 < ?m1
  - numeral ?m1 < numeral ?n1 == True
  numeral ?n1 < (0::?'a1) == False
  numeral ?n1 < (1::?'a1) == False
  numeral ?m1 < - (1::?'a1) == False
  numeral ?m1 < - numeral ?n1 == False
  numeral ?m1 < numeral ?n1 == ?m1 < ?n1
  numeral ?n1 < of_int ?z1 == numeral ?n1 < ?z1
  numeral ?k1 < Suc ?n1 == pred_numeral ?k1 < ?n1
  of_int ?z1 < (0::?'a1) == ?z1 < 0
  of_int ?z1 < (1::?'a1) == ?z1 < 1
  of_int ?z1 < numeral ?n1 == ?z1 < numeral ?n1
  of_int ?w1 < of_int ?z1 == ?w1 < ?z1
  of_int ?a1 < (- numeral ?x1) ^ ?n1 == ?a1 < (- numeral ?x1) ^ ?n1
  of_int ?a1 < numeral ?x1 ^ ?n1 == ?a1 < numeral ?x1 ^ ?n1
  of_int ?x1 < of_int ?b1 ^ ?w1 == ?x1 < ?b1 ^ ?w1
  sgn ?a1 < (0::?'a1) == ?a1 < (0::?'a1)
  \<bar>?a1\<bar> < (0::?'a1) == False
  \<bar>?z1\<bar> < 1 == ?z1 = 0
  num.Bit1 ?m1 < num.Bit1 ?n1 == ?m1 < ?n1
  num.Bit1 ?m1 < num.Bit0 ?n1 == ?m1 < ?n1
  num.Bit0 ?m1 < num.Bit1 ?n1 == ?m1 <= ?n1
  num.Bit0 ?m1 < num.Bit0 ?n1 == ?m1 < ?n1
  Suc 0 < nat ?z1 == 1 < ?z1
  Suc ?n1 < numeral ?k1 == ?n1 < pred_numeral ?k1
  Suc ?m1 < Suc ?n1 == ?m1 < ?n1
  nat ?w1 < nat ?z1 == 0 < ?z1 & ?w1 < ?z1
  nat ?a1 < numeral ?x1 ^ ?n1 == ?a1 < numeral ?x1 ^ ?n1
  signed_take_bit ?n1 ?k1 < 0 == bit ?k1 ?n1
  signed_take_bit ?n1 ?k1 < 2 ^ ?n1 == True
  unset_bit ?n1 ?k1 < 0 == ?k1 < 0
  take_bit ?n1 ?k1 < 0 == False
  take_bit ?n1 ?m1 < 2 ^ ?n1 == True
  take_bit ?n1 ?k1 < 2 ^ ?n1 == True
  push_bit ?n1 ?k1 < 0 == ?k1 < 0
  flip_bit ?n1 ?k1 < 0 == ?k1 < 0
  drop_bit ?n1 ?k1 < 0 == ?k1 < 0
  set_bit ?n1 ?k1 < 0 == ?k1 < 0
  xor ?k1 ?l1 < 0 == (?k1 < 0) ~= (?l1 < 0)
  and ?k1 ?l1 < 0 == ?k1 < 0 & ?l1 < 0
  [| 0 <= ?y1; ?y1 < ?z1 |] ==> and ?x1 ?y1 < ?z1 == True
  [| 0 <= ?y1; ?y1 < ?z1 |] ==> and ?y1 ?ya1 < ?z1 == True
  or ?k1 ?l1 < 0 == ?k1 < 0 | ?l1 < 0
  0 < ?l1 ==> ?k1 mod ?l1 < ?l1 == True
  0 < ?n1 ==> ?m1 mod ?n1 < ?n1 == True
  (1::?'a1) / ?a1 < (0::?'a1) == ?a1 < (0::?'a1)
  (0::?'a1) < ?a1 ==> ?b1 / ?a1 < (1::?'a1) == ?b1 < ?a1
  ?a1 < (0::?'a1) ==> ?b1 / ?a1 < (1::?'a1) == ?a1 < ?b1
  [| 1 < ?n1; 0 < ?m1 |] ==> ?m1 div ?n1 < ?m1 == True
  ?b1 / - numeral ?w1 < ?a1 == ?a1 * - numeral ?w1 < ?b1
  ?b1 / numeral ?w1 < ?a1 == ?b1 < ?a1 * numeral ?w1
  ?k1 div 2 < 0 == ?k1 < 0
  numeral ?w1 / ?b1 < (0::?'a1) ==
  (0::?'a1) < numeral ?w1 & ?b1 < (0::?'a1) |
  numeral ?w1 < (0::?'a1) & (0::?'a1) < ?b1
  ?a1 * ?a1 < (0::?'a1) == False
  ?m1 * ?k1 < ?n1 * ?k1 == 0 < ?k1 & ?m1 < ?n1
  ?k1 * ?m1 < ?k1 * ?n1 == 0 < ?k1 & ?m1 < ?n1
  ?a1 * numeral ?v1 < ?b1 * numeral ?v1 ==
  ((0::?'a1) <= numeral ?v1 --> ?a1 < ?b1) &
  (numeral ?v1 <= (0::?'a1) --> ?b1 < ?a1)
  numeral ?v1 * ?a1 < numeral ?v1 * ?b1 ==
  ((0::?'a1) <= numeral ?v1 --> ?a1 < ?b1) &
  (numeral ?v1 <= (0::?'a1) --> ?b1 < ?a1)
  ?a1 - ?b1 < (0::?'a1) == ?a1 < ?b1
  [| 0 < ?n1; 0 < ?m1 |] ==> ?m1 - ?n1 < ?m1 == True
  0 < ?n1 ==> ?n1 - Suc ?i1 < ?n1 == True
  ?a1 ^ ?n1 < (0::?'a1) == odd ?n1 & ?a1 < (0::?'a1)
  (1::?'a1) < ?b1 ==> ?b1 ^ ?x1 < ?b1 ^ ?y1 == ?x1 < ?y1
  [| (0::?'a1) < ?b1; ?b1 < (1::?'a1) |]
  ==> ?b1 ^ ?m1 < ?b1 ^ ?n1 == ?n1 < ?m1
  ?a1 ^ numeral ?w1 < (0::?'a1) == odd (numeral ?w1) & ?a1 < (0::?'a1)
  ?a1\<^sup>2 < (0::?'a1) == False
  of_nat ?b1 ^ ?w1 < of_nat ?x1 == ?b1 ^ ?w1 < ?x1
  (- numeral ?x1) ^ ?n1 < of_int ?a1 == (- numeral ?x1) ^ ?n1 < ?a1
  numeral ?i1 ^ ?n1 < of_nat ?x1 == numeral ?i1 ^ ?n1 < ?x1
  numeral ?x1 ^ ?n1 < of_int ?a1 == numeral ?x1 ^ ?n1 < ?a1
  numeral ?x1 ^ ?n1 < nat ?a1 == numeral ?x1 ^ ?n1 < ?a1
  of_int ?b1 ^ ?w1 < of_int ?x1 == ?b1 ^ ?w1 < ?x1
  max ?x1 ?y1 < ?z1 == ?x1 < ?z1 & ?y1 < ?z1
  ?a1 + ?a1 < (0::?'a1) == ?a1 < (0::?'a1)
  ?i1 + ?j1 < ?i1 == False
  ?j1 + ?i1 < ?i1 == False
  ?a1 + ?b1 < ?b1 == ?a1 < (0::?'a1)
  ?b1 + ?a1 < ?b1 == ?a1 < (0::?'a1)
  ?k1 + ?m1 < ?k1 + ?n1 == ?m1 < ?n1
  ?a1 + ?c1 < ?b1 + ?c1 == ?a1 < ?b1
  ?c1 + ?a1 < ?c1 + ?b1 == ?a1 < ?b1
  concat_bit ?n1 ?k1 ?l1 < 0 == ?l1 < 0
  map_option ?f1 None == None
  map_option ?f1 (Some ?x2.1) == Some (?f1 ?x2.1)
  (0::?'a1) * ?a1 == 0::?'a1
  0 * ?n1 == 0
  (1::?'a1) * ?y == ?y
  num.One * ?y == ?y
  ?a1 * (0::?'a1) == 0::?'a1
  ?m1 * 0 == 0
  ?y * (1::?'a1) == ?y
  ?y * num.One == ?y
  ?a1 ~= (0::?'a1) ==> ?a1 * inverse ?a1 == 1::?'a1
  ?z1 * - (1::?'a1) == - ?z1
  ?a1 * - ?b1 == - (?a1 * ?b1)
  ?m1 * Suc ?n1 == ?m1 + ?m1 * ?n1
  is_unit ?a1 ==> ?b1 * ((1::?'a1) div ?a1) == ?b1 div ?a1
  ?a1 * ((1::?'a1) div unit_factor ?b1) == ?a1 div unit_factor ?b1
  ?a1 dvd ?y ==> ?a1 * (?y div ?a1) == ?y
  ?a1 * (?b1 / ?c1) == ?a1 * ?b1 / ?c1
  division_segment ?y * of_nat (euclidean_size ?y) == ?y
  normalize ?y * unit_factor ?y == ?y
  unit_factor ?y * normalize ?y == ?y
  ?a1 ~= (0::?'a1) ==> inverse ?a1 * ?a1 == 1::?'a1
  - (1::?'a1) * ?z1 == - ?z1
  - ?a1 * ?b1 == - (?a1 * ?b1)
  - ?a1 * - ?b1 == ?a1 * ?b1
  - numeral ?m1 * - numeral ?n1 == numeral (?m1 * ?n1)
  - numeral ?m1 * numeral ?n1 == - numeral (?m1 * ?n1)
  - numeral ?v1 * (- numeral ?w1 * ?y1) == numeral (?v1 * ?w1) * ?y1
  - numeral ?v1 * (numeral ?w1 * ?y1) == - numeral (?v1 * ?w1) * ?y1
  numeral ?m1 * - numeral ?n1 == - numeral (?m1 * ?n1)
  numeral ?m1 * numeral ?n1 == numeral (?m1 * ?n1)
  numeral ?v1 * (- numeral ?w1 * ?y1) == - numeral (?v1 * ?w1) * ?y1
  numeral ?v1 * (numeral ?w1 * ?z1) == numeral (?v1 * ?w1) * ?z1
  numeral ?v1 * (?b1 - ?c1) == numeral ?v1 * ?b1 - numeral ?v1 * ?c1
  numeral ?v1 * (?b1 + ?c1) == numeral ?v1 * ?b1 + numeral ?v1 * ?c1
  odd ?n1 ==> 2 * (?n1 div 2) == ?n1 - 1
  sgn ?a1 * sgn ?a1 == of_bool (?a1 ~= (0::?'a1))
  \<bar>?a1\<bar> * \<bar>?a1\<bar> == ?a1 * ?a1
  num.Bit1 ?m1 * num.Bit1 ?n1 == num.Bit1 (?m1 + ?n1 + num.Bit0 (?m1 * ?n1))
  num.Bit1 ?m1 * num.Bit0 ?n1 == num.Bit0 (num.Bit1 ?m1 * ?n1)
  num.Bit0 num.One * ?n1 == num.Bit0 ?n1
  num.Bit0 ?m1 * num.Bit1 ?n1 == num.Bit0 (?m1 * num.Bit1 ?n1)
  num.Bit0 ?m1 * num.Bit0 ?n1 == num.Bit0 (num.Bit0 (?m1 * ?n1))
  Suc ?m1 * ?n1 == ?n1 + ?m1 * ?n1
  is_unit ?a1 ==> ?y div ?a1 * ?a1 == ?y
  ?a1 dvd ?y ==> ?y div ?a1 * ?a1 == ?y
  ?b1 / ?c1 * ?a1 == ?b1 * ?a1 / ?c1
  (?a1 - ?b1) * numeral ?v1 == ?a1 * numeral ?v1 - ?b1 * numeral ?v1
  ?a1 ^ numeral ?m1 * (?a1 ^ numeral ?n1 * ?b1) ==
  ?a1 ^ numeral (?m1 + ?n1) * ?b1
  ?a1 ^ numeral ?m1 * ?a1 ^ numeral ?n1 == ?a1 ^ numeral (?m1 + ?n1)
  (- (1::?'a1)) ^ ?n1 * ((- (1::?'a1)) ^ ?n1 * ?y) == ?y
  (- (1::?'a1)) ^ ?n1 * (- (1::?'a1)) ^ ?n1 == 1::?'a1
  (?a1 + ?b1) * numeral ?v1 == ?a1 * numeral ?v1 + ?b1 * numeral ?v1
  lcm ?a1 ?b1 * gcd ?a1 ?b1 == normalize ?a1 * normalize ?b1
  gcd ?a1 ?b1 * lcm ?a1 ?b1 == normalize ?a1 * normalize ?b1
  ?x1 powi numeral ?m1 * (?x1 powi numeral ?n1 * ?b1) ==
  ?x1 powi numeral (?m1 + ?n1) * ?b1
  ?x1 powi numeral ?m1 * ?x1 powi numeral ?n1 ==
  ?x1 powi numeral (?m1 + ?n1)
  (- (1::?'a1)) powi ?m1 * ((- (1::?'a1)) powi ?m1 * ?y) == ?y
  (- (1::?'a1)) powi ?m1 * (- (1::?'a1)) powi ?m1 == 1::?'a1
  {} - ?A1 == {}
  0 - ?n1 == 0
  (0::?'a1) - ?a1 == - ?a1
  (0::?'a1) - ?a1 == 0::?'a1
  (1::?'a1) - (1::?'a1) == 0::?'a1
  (1::?'a1) - - (1::?'a1) == 2::?'a1
  (1::?'a1) - - numeral ?n1 == numeral (num.One + ?n1)
  (1::?'a1) - numeral ?n1 == neg_numeral_class.sub num.One ?n1
  ?A1 - UNIV == {}
  ?y - {} == ?y
  ?y - 0 == ?y
  ?y - (0::?'a1) == ?y
  ?y - (0::?'a1) == ?y
  ?m1 <= ?n1 ==> ?m1 - ?n1 == 0
  ?m1 - ?m1 == 0
  ?A1 - ?A1 == {}
  ?A1 - ?B1 == ?A1 & ~ ?B1
  ?a1 - ?a1 == 0::?'a1
  ?a1 - ?a1 == 0::?'a1
  ?A1 - - ?B1 == ?A1 Int ?B1
  ?a1 - - ?b1 == ?a1 + ?b1
  ?k1 <= ?j1 ==> ?i1 - Suc (?j1 - ?k1) == ?i1 + ?k1 - Suc ?j1
  ?y <= ?n1 ==> ?n1 - (?n1 - ?y) == ?y
  ?k1 <= ?j1 ==> ?i1 - (?j1 - ?k1) == ?i1 + ?k1 - ?j1
  ?a1 - (?a1 + ?b1) == 0::?'a1
  ?x1 ~: ?A1 ==> ?A1 - insert ?x1 ?B1 == ?A1 - ?B1
  {..<?n1} - {..<?m1} == {?m1..<?n1}
  - (1::?'a1) - (1::?'a1) == - (2::?'a1)
  - (1::?'a1) - - (1::?'a1) == 0::?'a1
  - (1::?'a1) - - numeral ?n1 == neg_numeral_class.sub ?n1 num.One
  - (1::?'a1) - numeral ?n1 == - numeral (Num.inc ?n1)
  - numeral ?m1 - (1::?'a1) == - numeral (?m1 + num.One)
  - numeral ?m1 - - (1::?'a1) == neg_numeral_class.sub num.One ?m1
  - numeral ?m1 - - numeral ?n1 == neg_numeral_class.sub ?n1 ?m1
  - numeral ?m1 - numeral ?n1 == - numeral (?m1 + ?n1)
  - neg_numeral_class.sub ?m1 num.One - (1::?'a1) == - numeral ?m1
  numeral ?v1 - 1 == nat (numeral ?v1 - 1)
  numeral ?m1 - (1::?'a1) == neg_numeral_class.sub ?m1 num.One
  numeral ?m1 - - (1::?'a1) == numeral (Num.inc ?m1)
  numeral ?m1 - - numeral ?n1 == numeral (?m1 + ?n1)
  numeral ?v1 - numeral ?v'1 == nat (numeral ?v1 - numeral ?v'1)
  numeral ?m1 - numeral ?n1 == neg_numeral_class.sub ?m1 ?n1
  numeral ?k1 - Suc ?n1 == pred_numeral ?k1 - ?n1
  Suc ?y - 1 == ?y
  Suc ?n1 - numeral ?k1 == ?n1 - pred_numeral ?k1
  Suc ?m1 - Suc ?n1 == ?m1 - ?n1
  ?k1 <= ?j1 ==> Suc (?j1 - ?k1) - ?i1 == Suc ?j1 - (?k1 + ?i1)
  ?i1 <= ?n1 ==> {?i1..<?m1} - {?i1..<?n1} == {?n1..<?m1}
  ?i1 - ?j1 - ?k1 == ?i1 - (?j1 + ?k1)
  ?A1 - ?B1 - ?B1 == ?A1 - ?B1
  Suc ?m1 - ?n1 - Suc ?k1 == ?m1 - ?n1 - ?k1
  ?y + ?b1 - ?b1 == ?y
  ?y + ?b1 - ?b1 == ?y
  ?a1 + ?y - ?a1 == ?y
  ?a1 + ?c1 - (?b1 + ?c1) == ?a1 - ?b1
  ?c1 + ?a1 - (?c1 + ?b1) == ?a1 - ?b1
  {?k1} - {..<?k1} == {?k1}
  ?x1 : ?B1 ==> insert ?x1 ?A1 - ?B1 == ?A1 - ?B1
  Rep_filter ?F1 ?P1 == eventually ?P1 ?F1
  {} // ?r1 == {}
  rec_pred ?f1 (pred.Pred ?x1) == ?f1 ?x1
  (0::?'a1) ^ numeral ?k1 == 0::?'a1
  (0::?'a1) ^ Suc ?n1 == 0::?'a1
  (1::?'a1) ^ ?n1 == 1::?'a1
  ?a1 ^ 0 == 1::?'a1
  ?y ^ 1 == ?y
  ?y ^ Suc 0 == ?y
  ?a1 ^ Suc ?n1 == ?a1 * ?a1 ^ ?n1
  odd ?n1 ==> (- (1::?'a1)) ^ ?n1 == - (1::?'a1)
  even ?n1 ==> (- (1::?'a1)) ^ ?n1 == 1::?'a1
  (- (1::?'a1)) ^ (2 * ?n1) == 1::?'a1
  odd ?n1 ==> (- ?a1) ^ ?n1 == - (?a1 ^ ?n1)
  even ?n1 ==> (- ?a1) ^ ?n1 == ?a1 ^ ?n1
  (- ?a1)\<^sup>2 == ?a1\<^sup>2
  (- ?a1) ^ (2 * ?n1) == ?a1 ^ (2 * ?n1)
  numeral ?k1 ^ numeral ?l1 == numeral (Num.pow ?k1 ?l1)
  even (numeral ?w1) ==> \<bar>?a1\<bar> ^ numeral ?w1 == ?a1 ^ numeral ?w1
  \<bar>?a1\<bar>\<^sup>2 == ?a1\<^sup>2
  Suc 0 ^ ?n1 == Suc 0
  (?a1 * numeral ?w1) ^ ?n1 == ?a1 ^ ?n1 * numeral ?w1 ^ ?n1
  (numeral ?w1 * ?b1) ^ ?n1 == numeral ?w1 ^ ?n1 * ?b1 ^ ?n1
  (?a1 ^ numeral ?m1) ^ numeral ?n1 == ?a1 ^ numeral (?m1 * ?n1)
  min top ?y == ?y
  min bot ?x1 == bot
  min (0::?'a1) (1::?'a1) == 0::?'a1
  min 0 ?n1 == 0
  min (0::?'a1) (numeral ?x1) == 0::?'a1
  min (1::?'a1) (0::?'a1) == 0::?'a1
  min (1::?'a1) (numeral ?x1) == 1::?'a1
  min ?y top == ?y
  min ?x1 bot == bot
  min ?n1 0 == 0
  ?y < ?a1 ==> min ?a1 ?y == ?y
  ?y < ?b1 ==> min ?y ?b1 == ?y
  ?y <= ?a1 ==> min ?a1 ?y == ?y
  ?y <= ?b1 ==> min ?y ?b1 == ?y
  min ?y ?y == ?y
  min ?a1 (min ?a1 ?b1) == min ?a1 ?b1
  min (- numeral ?u1) (- numeral ?v1) ==
  if - numeral ?u1 <= - numeral ?v1 then - numeral ?u1 else - numeral ?v1
  min (- numeral ?u1) (numeral ?v1) ==
  if - numeral ?u1 <= numeral ?v1 then - numeral ?u1 else numeral ?v1
  min (numeral ?x1) (0::?'a1) == 0::?'a1
  min (numeral ?x1) (1::?'a1) == 1::?'a1
  min (numeral ?u1) (- numeral ?v1) ==
  if numeral ?u1 <= - numeral ?v1 then numeral ?u1 else - numeral ?v1
  min (numeral ?u1) (numeral ?v1) ==
  if numeral ?u1 <= numeral ?v1 then numeral ?u1 else numeral ?v1
  min (numeral ?k1) (Suc ?n1) == Suc (min (pred_numeral ?k1) ?n1)
  min (Suc ?n1) (numeral ?k1) == Suc (min ?n1 (pred_numeral ?k1))
  min (Suc ?m1) (Suc ?n1) == Suc (min ?m1 ?n1)
  min (min ?a1 ?b1) ?b1 == min ?a1 ?b1
  max top ?x1 == top
  max bot ?y == ?y
  max (0::?'a1) (1::?'a1) == 1::?'a1
  max 0 ?y == ?y
  max (0::?'a1) (numeral ?x1) == numeral ?x1
  max (1::?'a1) (0::?'a1) == 1::?'a1
  max (1::?'a1) (numeral ?x1) == numeral ?x1
  max ?x1 top == top
  max ?y bot == ?y
  max ?y 0 == ?y
  ?a1 < ?y ==> max ?a1 ?y == ?y
  ?b1 < ?y ==> max ?y ?b1 == ?y
  ?a1 <= ?y ==> max ?a1 ?y == ?y
  ?b1 <= ?y ==> max ?y ?b1 == ?y
  max ?y ?y == ?y
  max ?y (min ?x1 ?y) == ?y
  max ?y (min ?y ?y1) == ?y
  max ?a1 (max ?a1 ?b1) == max ?a1 ?b1
  max (- numeral ?u1) (- numeral ?v1) ==
  if - numeral ?u1 <= - numeral ?v1 then - numeral ?v1 else - numeral ?u1
  max (- numeral ?u1) (numeral ?v1) ==
  if - numeral ?u1 <= numeral ?v1 then numeral ?v1 else - numeral ?u1
  max (numeral ?x1) (0::?'a1) == numeral ?x1
  max (numeral ?x1) (1::?'a1) == numeral ?x1
  max (numeral ?u1) (- numeral ?v1) ==
  if numeral ?u1 <= - numeral ?v1 then - numeral ?v1 else numeral ?u1
  max (numeral ?u1) (numeral ?v1) ==
  if numeral ?u1 <= numeral ?v1 then numeral ?v1 else numeral ?u1
  max (numeral ?k1) (Suc ?n1) == Suc (max (pred_numeral ?k1) ?n1)
  max (Suc ?n1) (numeral ?k1) == Suc (max ?n1 (pred_numeral ?k1))
  max (Suc ?m1) (Suc ?n1) == Suc (max ?m1 ?n1)
  max (min ?x1 ?y) ?y == ?y
  max (min ?y ?y1) ?y == ?y
  max (max ?a1 ?b1) ?b1 == max ?a1 ?b1
  inv id == id
  inv (%a. a) == %a. a
  Random_Sequence.Random ?g1 ?nrandom1 ==
  %size.
     if ?nrandom1 <= 0 then Pair Limited_Sequence.empty
     else scomp (?g1 size)
           (%r. scomp (Random_Sequence.Random ?g1 (?nrandom1 - 1) size)
                 (%rs. Pair
                        (Limited_Sequence.union
                          (Limited_Sequence.single (fst r)) rs)))
  case word.Word ?x1 of word.Word x => ?f1 x == ?f1 ?x1
  ord_class.lexordp [] ?ys1 == ?ys1 ~= []
  ord_class.lexordp ?xs1 [] == False
  ord_class.lexordp (?x1 # ?xs1) (?y1 # ?ys1) ==
  ?x1 < ?y1 | ~ ?y1 < ?x1 & ord_class.lexordp ?xs1 ?ys1
  sup top ?x1 == top
  sup top ?x1 == top
  sup bot ?y == ?y
  sup ?x1 top == top
  sup ?x1 top == top
  sup ?y bot == ?y
  sup ?uu1 ?uv1 == ()
  sup ?P1 ?Q1 == ?P1 | ?Q1
  sup ?y ?y == ?y
  sup ?x1 (- ?x1) == top
  ?A1 Un (?B1 - ?A1) == ?A1 Un ?B1
  sup ?x1 (sup ?x1 ?y1) == sup ?x1 ?y1
  sup ?a1 (sup ?a1 ?b1) == sup ?a1 ?b1
  sup ?x1 (sup (- ?x1) ?y1) == top
  ?y Un ?S1 Int ?y == ?y
  ?y Un ?y Int ?T1 == ?y
  sup ?y (inf ?y ?y1) == ?y
  ?A1 Un insert ?a1 ?B1 == insert ?a1 (?A1 Un ?B1)
  [| finite ?A1; ?y : ?A1 |]
  ==> sup (\<Sqinter>\<^sub>f\<^sub>i\<^sub>n ?A1) ?y == ?y
  ?R1^**^== == ?R1^**
  ?r1^++^== == ?r1^**
  (?R1^*)^= == ?R1^*
  sup (- ?x1) ?x1 == top
  sup (- ?x1) (sup ?x1 ?y1) == top
  (?r1^+)^= == ?r1^*
  sup (principal ?A1) (principal ?B1) == principal (?A1 Un ?B1)
  ?B1 - ?A1 Un ?A1 == ?B1 Un ?A1
  ?P1^==^== == ?P1^==
  sup (sup ?a1 ?b1) ?b1 == sup ?a1 ?b1
  ?S1 Int ?y Un ?y == ?y
  ?y Int ?T1 Un ?y == ?y
  insert ?a1 ?B1 Un ?C1 == insert ?a1 (?B1 Un ?C1)
  inf top ?y == ?y
  inf bot ?x1 == bot
  inf bot ?x1 == bot
  inf ?y top == ?y
  inf ?x1 bot == bot
  inf ?x1 bot == bot
  inf ?uu1 ?uv1 == ()
  inf ?P1 ?Q1 == ?P1 & ?Q1
  inf ?y ?y == ?y
  [| finite ?A1; ?y : ?A1 |]
  ==> inf ?y (\<Squnion>\<^sub>f\<^sub>i\<^sub>n ?A1) == ?y
  ?A1 Int - ?A1 == {}
  inf ?x1 (- ?x1) == bot
  ?A1 Int (?B1 - ?A1) == {}
  ?y Int (?S1 Un ?y) == ?y
  ?y Int (?y Un ?T1) == ?y
  inf ?y (sup ?y ?y1) == ?y
  inf ?a1 (inf ?a1 ?b1) == inf ?a1 ?b1
  inf ?x1 (inf ?y1 (- ?x1)) == bot
  inf ?x1 (inf (- ?x1) ?y1) == bot
  ?a1 : ?A1 ==> ?A1 Int insert ?a1 ?B1 == insert ?a1 (?A1 Int ?B1)
  ?a1 ~: ?A1 ==> ?A1 Int insert ?a1 ?B1 == ?A1 Int ?B1
  {?a1..} Int {?c1..?d1} == {max ?a1 ?c1..?d1}
  {..?a1} Int {..?b1} == {..min ?a1 ?b1}
  {..?b1} Int {?c1..?d1} == {?c1..min ?b1 ?d1}
  - ?A1 Int ?A1 == {}
  inf (- ?x1) ?x1 == bot
  inf (- ?x1) (inf ?x1 ?y1) == bot
  inf (principal ?A1) (principal ?B1) == principal (?A1 Int ?B1)
  {?a1<..<?b1} Int {?c1<..<?d1} == {max ?a1 ?c1<..<min ?b1 ?d1}
  {?a1<..?b1} Int {?c1<..?d1} == {max ?a1 ?c1<..min ?b1 ?d1}
  {?a1..<?b1} Int {?c1..<?d1} == {max ?a1 ?c1..<min ?b1 ?d1}
  {?a1..?b1} Int {?c1..} == {max ?a1 ?c1..?b1}
  {?a1..?b1} Int {..?d1} == {?a1..min ?b1 ?d1}
  {?a1..?b1} Int {?c1..?d1} == {max ?a1 ?c1..min ?b1 ?d1}
  (?S1 Un ?y) Int ?y == ?y
  (?y Un ?T1) Int ?y == ?y
  inf (inf ?a1 ?b1) ?b1 == inf ?a1 ?b1
  ?a1 : ?C1 ==> insert ?a1 ?B1 Int ?C1 == insert ?a1 (?B1 Int ?C1)
  ?a1 ~: ?C1 ==> insert ?a1 ?B1 Int ?C1 == ?B1 Int ?C1
  insert ?a1 ?A1 Int insert ?a1 ?B1 == insert ?a1 (?A1 Int ?B1)
  0 + ?y == ?y
  (0::?'a1) + ?y == ?y
  (1::?'a1) + (1::?'a1) == 2::?'a1
  (1::?'a1) + - (1::?'a1) == 0::?'a1
  (1::?'a1) + - numeral ?m1 == neg_numeral_class.sub num.One ?m1
  (1::?'a1) + numeral ?n1 == numeral (num.One + ?n1)
  num.One + num.One == num.Bit0 num.One
  num.One + num.Bit1 ?n1 == num.Bit0 (?n1 + num.One)
  num.One + num.Bit0 ?n1 == num.Bit1 ?n1
  ?y + 0 == ?y
  ?y + (0::?'a1) == ?y
  ?a1 + - ?a1 == 0::?'a1
  ?a1 + - ?b1 == ?a1 - ?b1
  ?n1 + 2 == Suc (Suc ?n1)
  ?m1 + Suc ?n1 == Suc (?m1 + ?n1)
  ?b1 <= ?y ==> ?b1 + (?y - ?b1) == ?y
  ?k1 <= ?j1 ==> ?i1 + (?j1 - ?k1) == ?i1 + ?j1 - ?k1
  ?a1 + (- ?a1 + ?y) == ?y
  - (1::?'a1) + (1::?'a1) == 0::?'a1
  - (1::?'a1) + - (1::?'a1) == - (2::?'a1)
  - (1::?'a1) + - numeral ?n1 == - numeral (Num.inc ?n1)
  - (1::?'a1) + numeral ?n1 == neg_numeral_class.sub ?n1 num.One
  - ?a1 + ?b1 == ?b1 - ?a1
  - ?a1 + ?a1 == 0::?'a1
  - ?a1 + (?a1 + ?y) == ?y
  - numeral ?m1 + (1::?'a1) == neg_numeral_class.sub num.One ?m1
  - numeral ?m1 + - (1::?'a1) == - numeral (Num.inc ?m1)
  - numeral ?m1 + - numeral ?n1 == - (numeral ?m1 + numeral ?n1)
  - numeral ?m1 + numeral ?n1 == neg_numeral_class.sub ?n1 ?m1
  - numeral ?v1 + (- numeral ?w1 + ?y1) == - numeral (?v1 + ?w1) + ?y1
  - numeral ?v1 + (numeral ?w1 + ?y1) == neg_numeral_class.sub ?w1 ?v1 + ?y1
  numeral ?n1 + (1::?'a1) == numeral (?n1 + num.One)
  numeral ?m1 + - (1::?'a1) == neg_numeral_class.sub ?m1 num.One
  numeral ?m1 + - numeral ?n1 == neg_numeral_class.sub ?m1 ?n1
  numeral ?m1 + numeral ?n1 == numeral (?m1 + ?n1)
  numeral ?v1 + (- numeral ?w1 + ?y1) == neg_numeral_class.sub ?v1 ?w1 + ?y1
  numeral ?v1 + (numeral ?w1 + ?z1) == numeral (?v1 + ?w1) + ?z1
  2 + ?n1 == Suc (Suc ?n1)
  num.Bit1 ?m1 + num.One == num.Bit0 (?m1 + num.One)
  num.Bit1 ?m1 + num.Bit1 ?n1 == num.Bit0 (?m1 + ?n1 + num.One)
  num.Bit1 ?m1 + num.Bit0 ?n1 == num.Bit1 (?m1 + ?n1)
  num.Bit0 ?m1 + num.One == num.Bit1 ?m1
  num.Bit0 ?m1 + num.Bit1 ?n1 == num.Bit1 (?m1 + ?n1)
  num.Bit0 ?m1 + num.Bit0 ?n1 == num.Bit0 (?m1 + ?n1)
  Suc ?m1 + ?n1 == Suc (?m1 + ?n1)
  odd ?y ==> (2::?'a1) * (?y div (2::?'a1)) + (1::?'a1) == ?y
  ?b1 <= ?y ==> ?y - ?b1 + ?b1 == ?y
  ?k1 <= ?j1 ==> ?j1 - ?k1 + ?i1 == ?j1 + ?i1 - ?k1
  ?y - ?b1 + ?b1 == ?y
  case_sum (%x. ?y2) (%x. ?y2) == %x. ?y2
  case Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1 of
  Char x xa xb xc xd xe xf xg => ?f1 x xa xb xc xd xe xf xg ==
  ?f1 ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1
  map_prod (%x. x) (%y. y) == %z. z
  rec_word ?f1 (word.Word ?x1) == ?f1 ?x1
  equal_class.equal ?P1 ?Q1 == ?P1 = ?Q1
  rec_char ?f1 (Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1) ==
  ?f1 ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1
  is_unit (0::?'a1) == False
  (0::?'a1) dvd ?a1 == ?a1 = (0::?'a1)
  (1::?'a1) dvd ?a1 == True
  ?a1 dvd 0 == True
  ?a1 dvd (0::?'a1) == True
  is_unit ?x1 == \<bar>?x1\<bar> = 1
  is_unit ?m1 == ?m1 = 1
  ?a1 dvd ?a1 == True
  ?a1 dvd normalize ?b1 == ?a1 dvd ?b1
  ?x1 dvd - ?y1 == ?x1 dvd ?y1
  ?m1 dvd \<bar>?k1\<bar> == ?m1 dvd ?k1
  ?m1 : ?M1 ==> ?m1 dvd Lcm ?M1 == True
  ?m1 : ?M1 ==> ?m1 dvd Lcm ?M1 == True
  (!!b. b : ?A1 ==> ?a1 dvd b) ==> ?a1 dvd Gcd ?A1 == True
  (!!b. b : ?A1 ==> ?a1 dvd b) ==> ?a1 dvd Gcd ?A1 == True
  ?m1 dvd Suc 0 == ?m1 = Suc 0
  ?n1 dvd nat \<bar>?k1\<bar> == int ?n1 dvd ?k1
  ?a1 dvd ?a1 * ?b1 == True
  ?a1 dvd ?b1 * ?a1 == True
  ?a1 dvd ?b1 ==> ?a1 dvd ?b1 * ?c1 == True
  ?a1 dvd ?c1 ==> ?a1 dvd ?b1 * ?c1 == True
  ?l1 dvd ?k1 * sgn ?r1 == ?l1 dvd ?k1 | ?r1 = 0
  ?l1 dvd sgn ?r1 * ?k1 == ?l1 dvd ?k1 | ?r1 = 0
  [| ?x1 dvd ?y1; ?x1 dvd ?z1 |] ==> ?x1 dvd ?y1 - ?z1 == True
  [| ?k1 dvd ?m1; ?k1 dvd ?n1 |] ==> ?k1 dvd ?m1 - ?n1 == True
  ?b1 dvd ?a1 - ?a1 mod ?b1 == True
  0 < ?n1 | ?x1 = (1::?'a1) ==> ?x1 dvd ?x1 ^ ?n1 == True
  ?a1 dvd ?b1 + ?a1 == ?a1 dvd ?b1
  ?a1 dvd ?a1 + ?b1 == ?a1 dvd ?b1
  [| ?a1 dvd ?b1; ?a1 dvd ?c1 |] ==> ?a1 dvd ?b1 + ?c1 == True
  ?a1 dvd ?b1 + ?c1 * ?a1 == ?a1 dvd ?b1
  ?a1 dvd ?c1 * ?a1 + ?b1 == ?a1 dvd ?b1
  ?i1 dvd ?n1 ==> ?i1 dvd lcm ?m1 ?n1 == True
  ?i1 dvd ?m1 ==> ?i1 dvd lcm ?m1 ?n1 == True
  ?k1 dvd ?n1 ==> ?k1 dvd lcm ?m1 ?n1 == True
  ?k1 dvd ?m1 ==> ?k1 dvd lcm ?m1 ?n1 == True
  ?b1 dvd lcm ?a1 ?b1 == True
  ?a1 dvd lcm ?a1 ?b1 == True
  ?a1 dvd gcd ?b1 ?c1 == ?a1 dvd ?b1 & ?a1 dvd ?c1
  ?a1 dvd gcd ?b1 ?c1 == ?a1 dvd ?b1 & ?a1 dvd ?c1
  is_unit (division_segment ?a1) == True
  normalize ?a1 dvd ?b1 == ?a1 dvd ?b1
  ?a1 ~= (0::?'a1) ==> is_unit (unit_factor ?a1) == True
  unit_factor ?a1 dvd ?a1 == True
  ?a1 ~= (0::?'a1) ==> unit_factor ?a1 dvd ?b1 == True
  is_unit (Lcm\<^sub>f\<^sub>i\<^sub>n ?A1) ==
  Lcm\<^sub>f\<^sub>i\<^sub>n ?A1 = (1::?'a1)
  is_unit (Gcd\<^sub>f\<^sub>i\<^sub>n ?A1) ==
  Gcd\<^sub>f\<^sub>i\<^sub>n ?A1 = (1::?'a1)
  int ?m1 dvd int ?n1 == ?m1 dvd ?n1
  - ?x1 dvd ?y1 == ?x1 dvd ?y1
  numeral ?m1 dvd numeral ?n1 == divides_aux (divmod ?n1 ?m1)
  even (0::?'a1) == True
  even (1::?'a1) == False
  even (not ?a1) == odd ?a1
  even (of_nat ?n1) == even ?n1
  even (numeral (num.Bit1 ?n1)) == False
  even (numeral (num.Bit0 ?n1)) == True
  even (numeral (Num.BitM ?w1)) == False
  even (Suc ?n1) == odd ?n1
  even (Suc (Suc ?n1)) == even ?n1
  even (take_bit ?n1 ?a1) == ?n1 = 0 | even ?a1
  even (push_bit ?n1 ?a1) == ?n1 ~= 0 | even ?a1
  even (?a1 mod (2::?'a1)) == even ?a1
  even (?a1 * ?b1) == even ?a1 | even ?b1
  even (?m1 - ?n1) == ?m1 < ?n1 | even (?m1 + ?n1)
  even (?a1 - ?b1) == even (?a1 + ?b1)
  even ((2::?'a1) ^ ?n1 - (1::?'a1)) == ?n1 = 0
  even (?a1 ^ ?n1) == even ?a1 & 0 < ?n1
  even (?a1 + (1::?'a1)) == odd ?a1
  even (?a1 + ?b1) == even ?a1 = even ?b1
  \<bar>?m1\<bar> dvd ?k1 == ?m1 dvd ?k1
  (!!b. b : ?A1 ==> b dvd ?a1) ==> Lcm ?A1 dvd ?a1 == True
  ALL m:?M1. m dvd ?n1 ==> Lcm ?M1 dvd ?n1 == True
  ?a1 : ?A1 ==> Gcd ?A1 dvd ?a1 == True
  ?a1 : ?A1 ==> Gcd ?A1 dvd ?a1 == True
  Suc 0 dvd ?k1 == True
  nat \<bar>?k1\<bar> dvd ?n1 == ?k1 dvd int ?n1
  is_unit ?a1 ==> is_unit ((1::?'a1) div ?a1) == True
  [| ?a1 dvd ?b1; ?a1 dvd ?c1 |]
  ==> ?b1 div ?a1 dvd ?c1 div ?a1 == ?b1 dvd ?c1
  ?k1 * ?m1 dvd ?k1 * ?n1 == ?k1 = 0 | ?m1 dvd ?n1
  ?a1 ~= (0::?'a1) ==> ?b1 * ?a1 dvd ?c1 * ?a1 == ?b1 dvd ?c1
  ?a1 ~= (0::?'a1) ==> ?a1 * ?b1 dvd ?a1 * ?c1 == ?b1 dvd ?c1
  ?c1 * ?a1 dvd ?c1 * ?b1 == ?c1 = (0::?'a1) | ?a1 dvd ?b1
  ?a1 * ?c1 dvd ?b1 * ?c1 == ?c1 = (0::?'a1) | ?a1 dvd ?b1
  ?l1 * sgn ?r1 dvd ?k1 == ?l1 dvd ?k1 & (?r1 = 0 --> ?k1 = 0)
  sgn ?r1 * ?l1 dvd ?k1 == ?l1 dvd ?k1 & (?r1 = 0 --> ?k1 = 0)
  0 < ?n1 ==> ?a1 ^ ?n1 dvd ?b1 ^ ?n1 == ?a1 dvd ?b1
  lcm ?a1 ?b1 dvd ?c1 == ?a1 dvd ?c1 & ?b1 dvd ?c1
  is_unit (gcd ?a1 ?b1) == coprime ?a1 ?b1
  is_unit (gcd ?a1 ?b1) == gcd ?a1 ?b1 = (1::?'a1)
  gcd ?a1 ?b1 dvd ?b1 == True
  gcd ?a1 ?b1 dvd ?a1 == True
  gcd ?a1 ?b1 dvd ?b1 == True
  gcd ?a1 ?b1 dvd ?a1 == True
  gcd ?a1 ?b1 dvd lcm ?a1 ?b1 == True
  pred.eval (pred_of_set ?A1) ?x1 == ?x1 : ?A1
  contained seq.Empty ?Q1 == True
  contained (seq.Insert ?x1 ?P1) ?Q1 == pred.eval ?Q1 ?x1 & ?P1 <= ?Q1
  contained (seq.Join ?P1 ?xq1) ?Q1 == ?P1 <= ?Q1 & contained ?xq1 ?Q1
  size_list ?x1 [] == 0
  size_list ?x1 (?x21.1 # ?x22.1) ==
  ?x1 ?x21.1 + size_list ?x1 ?x22.1 + Suc 0
  size_list ?f1 (map ?g1 ?xs1) == size_list (?f1 o ?g1) ?xs1
  size_list ?f1 (?xs1 @ ?ys1) == size_list ?f1 ?xs1 + size_list ?f1 ?ys1
  pred_fun ?A1 ?B1 == %f. ALL x. ?A1 x --> ?B1 (f x)
  apsnd ?f1 (apfst ?g1 ?x1) == (?g1 (fst ?x1), ?f1 (snd ?x1))
  apsnd ?f1 (?x1, ?y1) == (?x1, ?f1 ?y1)
  apfst ?f1 (apsnd ?g1 ?x1) == (?f1 (fst ?x1), ?g1 (snd ?x1))
  apfst ?f1 (?x1, ?y1) == (?f1 ?x1, ?y1)
  UNIV \<times> UNIV == UNIV
  Sigma {} ?B1 == {}
  ?A1 \<times> {} == {}
  insert ?a1 ?A1 \<times> insert ?b1 ?B1 ==
  insert (?a1, ?b1)
   (?A1 \<times> insert ?b1 ?B1 Un insert ?a1 ?A1 \<times> ?B1)
  Predicate.the_only ?default1 seq.Empty == ?default1 ()
  Predicate.the_only ?default1 (seq.Insert ?x1 ?P1) ==
  if Predicate.is_empty ?P1 then ?x1
  else let y = Predicate.singleton ?default1 ?P1
       in if ?x1 = y then ?x1 else ?default1 ()
  Predicate.the_only ?default1 (seq.Join ?P1 ?xq1) ==
  if Predicate.is_empty ?P1 then Predicate.the_only ?default1 ?xq1
  else if Predicate.null ?xq1 then Predicate.singleton ?default1 ?P1
       else let x = Predicate.singleton ?default1 ?P1;
                y = Predicate.the_only ?default1 ?xq1
            in if x = y then x else ?default1 ()
  list_all ?P1 [] == True
  list_all ?P1 (rev ?xs1) == list_all ?P1 ?xs1
  list_all ?P1 (?a1 # ?aa1) == ?P1 ?a1 & list_all ?P1 ?aa1
  list_all ?P1 (?xs1 @ ?ys1) == list_all ?P1 ?xs1 & list_all ?P1 ?ys1
  filtercomap ?f1 top == top
  filtercomap ?f1 bot == bot
  filtercomap ?f1 (principal ?A1) == principal (?f1 -` ?A1)
  Divides.adjust_mod ?l1 ?r1 == if ?r1 = 0 then 0 else ?l1 - ?r1
  (0::?'b1) gchoose Suc ?k1 == 0::?'b1
  ?a1 gchoose 0 == 1::?'a1
  ?y gchoose 1 == ?y
  ?y gchoose Suc 0 == ?y
  Code.abort ?uu1 ?f1 == ?f1 ()
  [| total ?r1; total ?s1 |] ==> total (?r1 <*lex*> ?s1) == True
  total_on {} ?r1 == True
  total_on ?A1 less_than == True
  total_on ?A1 pair_less == True
  total_on ?A1 (?r1^-1) == total_on ?A1 ?r1
  total_on ?A1 (?r1 - Id) == total_on ?A1 ?r1
  [| total_on ?A1 ?r1; total_on ?B1 ?s1 |]
  ==> total_on (?A1 \<times> ?B1) (?r1 <*lex*> ?s1) == True
  total_on {?x1} {(?x1, ?x1)} == True
  bot OO ?R1 == bot
  ?R1 OO bot == bot
  ?R1 OO sup ?S1 ?T1 == sup (?R1 OO ?S1) (?R1 OO ?T1)
  sup ?S1 ?T1 OO ?R1 == sup (?S1 OO ?R1) (?T1 OO ?R1)
  (fst ?y, snd ?y) == ?y
  Predicate.adjunct ?P1 seq.Empty == seq.Join ?P1 seq.Empty
  Predicate.adjunct ?P1 (seq.Insert ?x1 ?Q1) == seq.Insert ?x1 (sup ?Q1 ?P1)
  Predicate.adjunct ?P1 (seq.Join ?Q1 ?xq1) ==
  seq.Join ?Q1 (Predicate.adjunct ?P1 ?xq1)
  successively ?P1 [] == True
  successively ?P1 (rev ?xs1) == successively (%x y. ?P1 y x) ?xs1
  successively ?P1 [?x1] == True
  successively ?P1 (?x1 # ?y1 # ?xs1) ==
  ?P1 ?x1 ?y1 & successively ?P1 (?y1 # ?xs1)
  arg_min_list ?f1 [?y] == ?y
  arg_min_list ?f1 (?x1 # ?y1 # ?zs1) ==
  let m = arg_min_list ?f1 (?y1 # ?zs1)
  in if ?f1 ?x1 <= ?f1 m then ?x1 else m
  lcm (0::?'a1) ?a1 == 0::?'a1
  lcm (1::?'a1) ?a1 == normalize ?a1
  lcm ?a1 (0::?'a1) == 0::?'a1
  lcm ?a1 (1::?'a1) == normalize ?a1
  ?x1 dvd ?y1 ==> lcm ?y1 ?x1 == \<bar>?y1\<bar>
  ?x1 dvd ?y ==> lcm ?y ?x1 == ?y
  ?x1 dvd ?y1 ==> lcm ?x1 ?y1 == \<bar>?y1\<bar>
  ?x1 dvd ?y ==> lcm ?x1 ?y == ?y
  lcm ?a1 ?a1 == normalize ?a1
  lcm ?a1 (normalize ?b1) == lcm ?a1 ?b1
  lcm ?a1 (- ?b1) == lcm ?a1 ?b1
  lcm ?a1 (- numeral ?n1) == lcm ?a1 (numeral ?n1)
  lcm ?x1 \<bar>?y1\<bar> == lcm ?x1 ?y1
  lcm ?n1 (nat \<bar>?k1\<bar>) == nat (lcm (int ?n1) ?k1)
  lcm ?a1 (lcm ?a1 ?b1) == lcm ?a1 ?b1
  lcm (normalize ?a1) ?b1 == lcm ?a1 ?b1
  lcm (int ?m1) (int ?n1) == int (lcm ?m1 ?n1)
  lcm (- ?a1) ?b1 == lcm ?a1 ?b1
  lcm (- numeral ?n1) ?a1 == lcm (numeral ?n1) ?a1
  lcm \<bar>?x1\<bar> ?y1 == lcm ?x1 ?y1
  lcm (nat \<bar>?k1\<bar>) ?n1 == nat (lcm ?k1 (int ?n1))
  lcm (lcm ?a1 ?b1) ?b1 == lcm ?a1 ?b1
  gcd 0 ?y == ?y
  gcd 0 ?x1 == \<bar>?x1\<bar>
  gcd (0::?'a1) ?a1 == normalize ?a1
  gcd (1::?'a1) ?a1 == 1::?'a1
  gcd ?y 0 == ?y
  gcd ?x1 0 == \<bar>?x1\<bar>
  gcd ?a1 (0::?'a1) == normalize ?a1
  gcd ?m1 1 == 1
  gcd ?m1 1 == 1
  gcd ?a1 (1::?'a1) == 1::?'a1
  ?y dvd ?x1 ==> gcd ?x1 ?y == ?y
  ?y dvd ?y1 ==> gcd ?y ?y1 == ?y
  ?y1 dvd ?x1 ==> gcd ?x1 ?y1 == \<bar>?y1\<bar>
  ?x1 dvd ?y1 ==> gcd ?x1 ?y1 == \<bar>?x1\<bar>
  gcd ?y ?y == ?y
  coprime ?a1 ?b1 ==> gcd ?a1 ?b1 == 1::?'a1
  gcd ?a1 ?a1 == normalize ?a1
  gcd ?a1 (normalize ?b1) == gcd ?a1 ?b1
  gcd ?x1 (- ?y1) == gcd ?x1 ?y1
  gcd ?a1 (- ?b1) == gcd ?a1 ?b1
  gcd ?x1 (- numeral ?n1) == gcd ?x1 (numeral ?n1)
  gcd ?a1 (- numeral ?n1) == gcd ?a1 (numeral ?n1)
  gcd ?x1 \<bar>?y1\<bar> == gcd ?x1 ?y1
  gcd ?m1 (Suc 0) == Suc 0
  gcd ?n1 (nat \<bar>?k1\<bar>) == nat (gcd (int ?n1) ?k1)
  gcd ?m1 (?m1 + ?n1) == gcd ?m1 ?n1
  gcd ?a1 (gcd ?a1 ?b1) == gcd ?a1 ?b1
  gcd ?a1 (gcd ?a1 ?b1) == gcd ?a1 ?b1
  gcd (normalize ?a1) ?b1 == gcd ?a1 ?b1
  gcd (int ?m1) (int ?n1) == int (gcd ?m1 ?n1)
  gcd (- ?x1) ?y1 == gcd ?x1 ?y1
  gcd (- ?a1) ?b1 == gcd ?a1 ?b1
  gcd (- numeral ?n1) ?x1 == gcd (numeral ?n1) ?x1
  gcd (- numeral ?n1) ?a1 == gcd (numeral ?n1) ?a1
  gcd \<bar>?x1\<bar> ?y1 == gcd ?x1 ?y1
  gcd (nat \<bar>?k1\<bar>) ?n1 == nat (gcd ?k1 (int ?n1))
  gcd (?a1 ^ ?n1) (?b1 ^ ?n1) == gcd ?a1 ?b1 ^ ?n1
  gcd (?m1 + ?n1) ?n1 == gcd ?m1 ?n1
  gcd (gcd ?a1 ?b1) ?b1 == gcd ?a1 ?b1
  gcd (gcd ?a1 ?b1) ?b1 == gcd ?a1 ?b1
  \<exists>\<^sub>F x in ?F1. False == False
  ?F1 ~= bot ==> \<exists>\<^sub>F x in ?F1. ?y == ?y
  eventually ?P1 top == ALL x. ?P1 x
  eventually ?P1 bot == True
  \<forall>\<^sub>F x in at_top. x ~= ?c1 == True
  \<forall>\<^sub>F n in sequentially. False == False
  \<forall>\<^sub>F i in sequentially. ?P1 (Suc i) ==
  eventually ?P1 sequentially
  \<forall>\<^sub>F n in sequentially. ?P1 (n + ?k1) ==
  eventually ?P1 sequentially
  \<forall>\<^sub>F x in at_bot. x <= ?c1 == True
  \<forall>\<^sub>F x in at_bot. x ~= ?c1 == True
  \<forall>\<^sub>F x in at_bot. x < ?c1 == True
  \<forall>\<^sub>F x in ?F1. True == True
  ?F1 ~= bot ==> \<forall>\<^sub>F x in ?F1. ?y == ?y
  eventually ((<=) ?c1) at_top == True
  eventually ((<) ?c1) at_top == True
  0 choose Suc ?k1 == 0
  ?n1 choose 0 == 1
  ?n1 choose ?n1 == 1
  ?y choose Suc 0 == ?y
  Suc ?n1 choose ?n1 == Suc ?n1
  Suc ?n1 choose Suc ?k1 == ?n1 choose ?k1 + (?n1 choose Suc ?k1)
  {} O ?R1 == {}
  Id O ?y == ?y
  ?R1 O {} == {}
  ?y O Id == ?y
  ?R1 O (?S1 Un ?T1) == ?R1 O ?S1 Un ?R1 O ?T1
  ?R1^* O ?R1^* == ?R1^*
  (?S1 Un ?T1) O ?R1 == ?S1 O ?R1 Un ?T1 O ?R1
  refl (?r1^=) == True
  refl_on {} {} == True
  refl_on ?A1 (?r1^-1) == refl_on ?A1 ?r1
  refl_on {?x1} {(?x1, ?x1)} == True
  Predicate.member seq.Empty ?x1 == False
  Predicate.member (seq.Insert ?y1 ?P1) ?x1 == ?x1 = ?y1 | pred.eval ?P1 ?x1
  Predicate.member (seq.Join ?P1 ?xq1) ?x1 ==
  pred.eval ?P1 ?x1 | Predicate.member ?xq1 ?x1
  ?m1 |` {} == Map.empty
  Map.empty |` ?D1 == Map.empty
  ?m1 |` ?A1 |` ?B1 == ?m1 |` (?A1 Int ?B1)
  [| length ?xs1 = length ?ys1; set ?xs1 <= ?D1 |]
  ==> ?m1(?xs1 [|->] ?ys1) |` ?D1 == (?m1 |` (?D1 - set ?xs1))(?xs1 [|->]
      ?ys1)
  ?m1(?x1 := ?y1) |` ?D1 ==
  if ?x1 : ?D1 then (?m1 |` (?D1 - {?x1}))(?x1 := ?y1) else ?m1 |` ?D1
  ?m1(?x1 |-> ?y1) |` (- {?x1}) == ?m1 |` (- {?x1})
  filtermap ?f1 bot == bot
  filtermap ?f1 (principal ?A1) == principal (?f1 ` ?A1)
  Predicate.apply ?f1 seq.Empty == seq.Empty
  Predicate.apply ?f1 (seq.Insert ?x1 ?P1) ==
  seq.Join (?f1 ?x1) (seq.Join (Predicate.bind ?P1 ?f1) seq.Empty)
  Predicate.apply ?f1 (seq.Join ?P1 ?xq1) ==
  seq.Join (Predicate.bind ?P1 ?f1) (Predicate.apply ?f1 ?xq1)
  sorted (sorted_list_of_set ?A1) == True
  sorted ?xs1 ==> sorted (remdups_adj ?xs1) == True
  sorted ?xs1 ==> sorted (remdups ?xs1) == True
  sorted (rev (map length (transpose ?xs1))) == True
  sorted (sort ?xs1) == True
  sorted (replicate ?n1 ?x1) == True
  sorted (map fst (enumerate ?n1 ?xs1)) == True
  sorted (map ?f1 (sort_key ?f1 ?xs1)) == True
  sorted [?m1..?n1] == True
  sorted [?m1..<?n1] == True
  sorted_wrt (<) (sorted_list_of_set ?A1) == True
  sorted_wrt (<) [?i1..?j1] == True
  sorted_wrt (<) [?m1..<?n1] == True
  sorted_wrt ?P1 [] == True
  sorted_wrt (%_ _. True) ?xs1 == True
  sorted_wrt ?P1 (?x1 # ?ys1) ==
  Ball (set ?ys1) (?P1 ?x1) & sorted_wrt ?P1 ?ys1
  count_list [] ?y1 == 0
  ?x1 ~: set ?xs1 ==> count_list ?xs1 ?x1 == 0
  count_list (?x1 # ?xs1) ?y1 ==
  if ?x1 = ?y1 then count_list ?xs1 ?y1 + 1 else count_list ?xs1 ?y1
  {} `` ?X1 == {}
  Id `` ?y == ?y
  ?R1 `` {} == {}
  Id_on ?A1 `` ?B1 == ?A1 Int ?B1
  listrel ?r1 `` {[]} == {[]}
  {(x, y). ?P1 x y} `` ?A1 == {y. EX x:?A1. ?P1 x y}
  takeWhile ?P1 [] == []
  takeWhile ?P1 (takeWhile ?P1 ?xs1) == takeWhile ?P1 ?xs1
  takeWhile ?P1 (replicate ?n1 ?x1) ==
  if ?P1 ?x1 then replicate ?n1 ?x1 else []
  takeWhile ?P1 (?x1 # ?xs1) ==
  if ?P1 ?x1 then ?x1 # takeWhile ?P1 ?xs1 else []
  (!!x. x : set ?xs1 ==> ?P1 x) ==>
  takeWhile ?P1 (?xs1 @ ?ys1) == ?xs1 @ takeWhile ?P1 ?ys1
  [| ?x1 : set ?xs1; ~ ?P1 ?x1 |]
  ==> takeWhile ?P1 (?xs1 @ ?ys1) == takeWhile ?P1 ?xs1
  replicate 0 ?x1 == []
  replicate (Suc ?n1) ?x1 == ?x1 # replicate ?n1 ?x1
  removeAll ?x1 [] == []
  ?x1 ~: set ?y ==> removeAll ?x1 ?y == ?y
  removeAll ?x1 (?y1 # ?xs1) ==
  if ?x1 = ?y1 then removeAll ?x1 ?xs1 else ?y1 # removeAll ?x1 ?xs1
  ~ ?P1 ?x1 ==> removeAll ?x1 (filter ?P1 ?xs1) == filter ?P1 ?xs1
  removeAll ?x1 (?xs1 @ ?ys1) == removeAll ?x1 ?xs1 @ removeAll ?x1 ?ys1
  partition ?f1 ?xs1 == (filter ?f1 ?xs1, filter (Not o ?f1) ?xs1)
  ?x1 # tl (remdups_adj (?x1 # ?xs1)) == remdups_adj (?x1 # ?xs1)
  ?y ~= [] ==> hd ?y # tl ?y == ?y
  enumerate ?n1 [] == []
  enumerate ?n1 (?x1 # ?xs1) == (?n1, ?x1) # enumerate (Suc ?n1) ?xs1
  dropWhile ?P1 [] == []
  dropWhile ?P1 (replicate ?n1 ?x1) ==
  if ?P1 ?x1 then [] else replicate ?n1 ?x1
  dropWhile ?P1 (?x1 # ?xs1) ==
  if ?P1 ?x1 then dropWhile ?P1 ?xs1 else ?x1 # ?xs1
  dropWhile ?P1 (dropWhile ?P1 ?xs1) == dropWhile ?P1 ?xs1
  (!!x. x : set ?xs1 ==> ?P1 x) ==>
  dropWhile ?P1 (?xs1 @ ?ys1) == dropWhile ?P1 ?ys1
  [| ?x1 : set ?xs1; ~ ?P1 ?x1 |]
  ==> dropWhile ?P1 (?xs1 @ ?ys1) == dropWhile ?P1 ?xs1 @ ?ys1
  Sum_Type.Sumr ?f1 (Inr ?x1) == ?f1 ?x1
  Sum_Type.Suml ?f1 (Inl ?x1) == ?f1 ?x1
  UNIV <+> UNIV == UNIV
  shuffles [] ?ys1 == {?ys1}
  shuffles ?xs1 [] == {?xs1}
  shuffles (?x1 # ?xs1) (?y1 # ?ys1) ==
  (#) ?x1 ` shuffles ?xs1 (?y1 # ?ys1) Un
  (#) ?y1 ` shuffles (?x1 # ?xs1) ?ys1
  set_Cons ?A1 {[]} == (%x. [x]) ` ?A1
  list_ex1 ?P1 [] == False
  list_ex1 ?P1 (?x1 # ?xs1) ==
  if ?P1 ?x1 then list_all (%y. ~ ?P1 y | ?x1 = y) ?xs1
  else list_ex1 ?P1 ?xs1
  map snd (enumerate ?n1 ?y) == ?y
  length ?xs1 = length ?y ==> map snd (zip ?xs1 ?y) == ?y
  map fst (enumerate ?n1 ?xs1) == [?n1..<?n1 + length ?xs1]
  length ?y = length ?ys1 ==> map fst (zip ?y ?ys1) == ?y
  map ?f1 [] == []
  map ?f1 (replicate ?n1 ?x1) == replicate ?n1 (?f1 ?x1)
  map ?f1 (?x21.1 # ?x22.1) == ?f1 ?x21.1 # map ?f1 ?x22.1
  map ?f1 (map ?g1 ?xs1) == map (?f1 o ?g1) ?xs1
  map ?f1 (?xs1 @ ?ys1) == map ?f1 ?xs1 @ map ?f1 ?ys1
  ?y1 ~: set ?xs1 ==> map (?f1(?y1 := ?v1)) ?xs1 == map ?f1 ?xs1
  ?m1 ~= 0 ==> (0::?'a1) powi ?m1 == 0::?'a1
  (1::?'a1) powi ?n1 == 1::?'a1
  ?x1 powi 0 == 1::?'b1
  ?y powi 1 == ?y
  ?x1 powi int ?n1 == ?x1 ^ ?n1
  ?y1 powi - 1 == inverse ?y1
  ?x1 powi numeral ?n1 == ?x1 ^ numeral ?n1
  odd ?n1 ==> (- ?a1) powi ?n1 == - (?a1 powi ?n1)
  even ?n1 ==> (- ?a1) powi ?n1 == ?a1 powi ?n1
  numeral ?m1 powi - numeral ?n1 == inverse (numeral (Num.pow ?m1 ?n1))
  (?x1 * numeral ?w1) powi ?m1 == ?x1 powi ?m1 * numeral ?w1 powi ?m1
  (numeral ?w1 * ?y1) powi ?m1 == numeral ?w1 powi ?m1 * ?y1 powi ?m1
  (?x1 powi numeral ?m1) powi numeral ?n1 == ?x1 powi numeral (?m1 * ?n1)
  pairwise ?P1 {} == True
  pairwise (%i j. j ~= i) ?I1 == True
  pairwise ?P1 {?A1} == True
  ?m1 \<circ>\<^sub>m Map.empty == Map.empty
  Map.empty \<circ>\<^sub>m ?m1 == Map.empty
  remove1 ?x1 [] == []
  remove1 ?x1 (?y1 # ?xs1) ==
  if ?x1 = ?y1 then ?xs1 else ?y1 # remove1 ?x1 ?xs1
  ~ ?P1 ?x1 ==> remove1 ?x1 (filter ?P1 ?xs1) == filter ?P1 ?xs1
  remove1 ?x1 (insort_key ?f1 ?x1 ?y) == ?y
  List.product [] ?uu1 == []
  List.product (?x1 # ?xs1) ?ys1 ==
  map (Pair ?x1) ?ys1 @ List.product ?xs1 ?ys1
  List.n_lists 0 ?xs1 == [[]]
  List.n_lists ?n1 [] == if ?n1 = 0 then [[]] else []
  List.n_lists (Suc ?n1) ?xs1 ==
  concat (map (%ys. map (%y. y # ys) ?xs1) (List.n_lists ?n1 ?xs1))
  list_ex ?P1 [] == False
  list_ex ?P1 (rev ?xs1) == list_ex ?P1 ?xs1
  list_ex ?P1 (?x1 # ?xs1) == ?P1 ?x1 | list_ex ?P1 ?xs1
  list_ex ?P1 (?xs1 @ ?ys1) == list_ex ?P1 ?xs1 | list_ex ?P1 ?ys1
  Random.pick (?x1 # ?xs1) ?i1 ==
  if ?i1 < fst ?x1 then snd ?x1 else Random.pick ?xs1 (?i1 - fst ?x1)
  Option.bind None ?f1 == None
  Option.bind ?y Some == ?y
  Option.bind ?x1 Map.empty == None
  Option.bind (Some ?x1) ?f1 == ?f1 ?x1
  Option.bind (Option.bind ?x1 ?f1) ?g1 ==
  Option.bind ?x1 (%y. Option.bind (?f1 y) ?g1)
  ?y ++ Map.empty == ?y
  Map.empty ++ ?y == ?y
  ?m1.1 ++ (?m2.1 ++ ?m3.1) == ?m1.1 ++ ?m2.1 ++ ?m3.1
  ?m1.1 ++ ?m2.1(?xs1 [|->] ?ys1) == (?m1.1 ++ ?m2.1)(?xs1 [|->] ?ys1)
  ?f1 ++ ?g1(?x1 |-> ?y1) == (?f1 ++ ?g1)(?x1 |-> ?y1)
  splice [] ?y == ?y
  splice ?y [] == ?y
  splice (replicate ?m1 ?x1) (replicate ?n1 ?x1) ==
  replicate (?m1 + ?n1) ?x1
  splice (?x1 # ?xs1) ?ys1 == ?x1 # splice ?ys1 ?xs1
  ?n1 mod length ?y = 0 ==> rotate ?n1 ?y == ?y
  length ?y <= 1 ==> rotate ?n1 ?y == ?y
  rotate (Suc ?n1) ?xs1 == rotate1 (rotate ?n1 ?xs1)
  listsp ?A1 [] == True
  [| ?A1 ?a1; listsp ?A1 ?l1 |] ==> listsp ?A1 (?a1 # ?l1) == True
  listsp ?A1 (?xs1 @ ?ys1) == listsp ?A1 ?xs1 & listsp ?A1 ?ys1
  List.insert ?x1 [] == [?x1]
  ?x1 ~: set ?xs1 ==> List.insert ?x1 ?xs1 == ?x1 # ?xs1
  ?x1 : set ?y ==> List.insert ?x1 ?y == ?y
  filter ?P1 [] == []
  ALL x:set ?xs1. ~ ?P1 x ==> filter ?P1 ?xs1 == []
  ALL x:set ?y. ?P1 x ==> filter ?P1 ?y == ?y
  filter ?P1 (?x1 # ?xs1) ==
  if ?P1 ?x1 then ?x1 # filter ?P1 ?xs1 else filter ?P1 ?xs1
  filter ?P1 (filter ?Q1 ?xs1) == filter (%x. ?Q1 x & ?P1 x) ?xs1
  filter ?P1 (?xs1 @ ?ys1) == filter ?P1 ?xs1 @ filter ?P1 ?ys1
  [] @ ?y == ?y
  ?y @ [] == ?y
  ?y ~= [] ==> butlast ?y @ [last ?y] == ?y
  takeWhile ?P1 ?y @ dropWhile ?P1 ?y == ?y
  (?x1 # ?xs1) @ ?ys1 == ?x1 # ?xs1 @ ?ys1
  (?xs1 @ ?ys1) @ ?zs1 == ?xs1 @ ?ys1 @ ?zs1
  take ?n1 ?y @ drop ?n1 ?y == ?y
  False --> ?P1 == True
  True --> ?y == ?y
  ?P1 --> False == ~ ?P1
  ?P1 --> True == True
  ?P1 --> ?P1 == True
  ?P1 --> ~ ?P1 == ~ ?P1
  ?P1 | ?Q1 --> ?R1 == (?P1 --> ?R1) & (?Q1 --> ?R1)
  ?f1 -` UNIV == UNIV
  ?f1 -` {} == {}
  (%x. x) -` ?y == ?y
  (%x. if x : ?B1 then ?c1 else ?d1) -` ?A1 ==
  if ?c1 : ?A1 then if ?d1 : ?A1 then UNIV else ?B1
  else if ?d1 : ?A1 then - ?B1 else {}
  (%x. ?c1) -` ?A1 == if ?c1 : ?A1 then UNIV else {}
  ?f1 -` Collect ?P1 == {y. ?P1 (?f1 y)}
  ?f1 -` (?A1 Un ?B1) == ?f1 -` ?A1 Un ?f1 -` ?B1
  ?f1 -` (?A1 Int ?B1) == ?f1 -` ?A1 Int ?f1 -` ?B1
  (0::?'a1) : \<nat> == True
  (0::?'a1) : \<int> == True
  0 : Suc ` ?A1 == False
  (1::?'a1) : \<nat> == True
  (1::?'a1) : \<int> == True
  None : Some ` ?A1 == False
  [] : lists ?A1 == True
  [] : shuffles ?xs1 ?ys1 == ?xs1 = [] & ?ys1 = []
  True : ?P1 ` ?A1 == Bex ?A1 ?P1
  ?x1 : UNIV == True
  ?c1 : {} == False
  ?i1 : {?k1<..} == ?k1 < ?i1
  ?i1 : {..<?k1} == ?i1 < ?k1
  ?A1 : \<Union> ?C1 == EX X:?C1. ?A1 : X
  ?b1 : \<Union> (?B1 ` ?A1) == EX x:?A1. ?b1 : ?B1 x
  ?A1 : \<Inter> ?C1 == ALL X:?C1. ?A1 : X
  ?b1 : \<Inter> (?B1 ` ?A1) == ALL x:?A1. ?b1 : ?B1 x
  ?i1 : {?k1..} == ?k1 <= ?i1
  ?i1 : {..?k1} == ?i1 <= ?k1
  ?c1 : - ?A1 == ?c1 ~: ?A1
  ?x1 : set_option ?xo1 == ?xo1 = Some ?x1
  ?x1 : set_of_pred ?P1 == pred.eval ?P1 ?x1
  ?x1 : set_of_seq ?xq1 == Predicate.member ?xq1 ?x1
  ?x1 : set (replicate ?n1 ?y1) == ?x1 = ?y1 & ?n1 ~= 0
  ?x1 ~: set ?xs1 ==> ?x1 : set (remove1 ?y1 ?xs1) == False
  ?a1 ~= ?b1 ==> ?a1 : set (remove1 ?b1 ?xs1) == ?a1 : set ?xs1
  ?x1 ~: set ?xs1 ==> ?x1 : set (nths ?xs1 ?I1) == False
  ?a1 : Collect ?P1 == ?P1 ?a1
  ?A1 : Pow ?B1 == ?A1 <= ?B1
  ?i1 : {?l1<..<?u1} == ?l1 < ?i1 & ?i1 < ?u1
  ?i1 : {?l1<..?u1} == ?l1 < ?i1 & ?i1 <= ?u1
  ?i1 : {?l1..<?u1} == ?l1 <= ?i1 & ?i1 < ?u1
  ?i1 : {?l1..?u1} == ?l1 <= ?i1 & ?i1 <= ?u1
  ?c1 : ?A1 - ?B1 == ?c1 : ?A1 & ?c1 ~: ?B1
  ?c1 : ?A1 Un ?B1 == ?c1 : ?A1 | ?c1 : ?B1
  ?c1 : ?A1 Int ?B1 == ?c1 : ?A1 & ?c1 : ?B1
  ?b1 : ?r1 `` {?a1} == (?a1, ?b1) : ?r1
  ?a1 : ?f1 -` ?B1 == ?f1 ?a1 : ?B1
  ?x1 : Set.remove ?y1 ?A1 == ?x1 : ?A1 & ?x1 ~= ?y1
  ?a1 : insert ?b1 ?A1 == ?a1 = ?b1 | ?a1 : ?A1
  ?x1 : Set.filter ?P1 ?A1 == ?x1 : ?A1 & ?P1 ?x1
  [| ?b1 = ?f1 ?x1; ?x1 : ?A1 |] ==> ?b1 : ?f1 ` ?A1 == True
  ?x1 : Set.bind ?A1 ?f1 == ?x1 : \<Union> (?f1 ` ?A1)
  [| finite ?A1; ?A1 ~= {} |] ==> Min ?A1 : ?A1 == True
  [| finite ?A1; ?A1 ~= {} |] ==> Max ?A1 : ?A1 == True
  of_nat ?n1 : \<nat> == True
  of_nat ?n1 : \<int> == True
  int ?n1 : range abs == True
  ?a1 : \<int> ==> - ?a1 : \<int> == True
  numeral ?w1 : \<nat> == True
  numeral ?n1 : \<int> == True
  of_int ?z1 : \<int> == True
  ?a1 : \<int> ==> \<bar>?a1\<bar> : \<int> == True
  ?xs1 ~= [] ==> hd ?xs1 : set ?xs1 == True
  ?as1 ~= [] ==> last ?as1 : set ?as1 == True
  [| ?a1 : \<nat>; ?b1 : \<nat> |] ==> ?a1 * ?b1 : \<nat> == True
  [| ?a1 : \<int>; ?b1 : \<int> |] ==> ?a1 * ?b1 : \<int> == True
  [| ?a1 : \<nat>; ?b1 : \<nat>; ?b1 <= ?a1 |]
  ==> ?a1 - ?b1 : \<nat> == True
  [| ?a1 : \<int>; ?b1 : \<int> |] ==> ?a1 - ?b1 : \<int> == True
  ?a1 : \<int> ==> ?a1 ^ ?n1 : \<int> == True
  [| ?a1 : \<nat>; ?b1 : \<nat> |] ==> ?a1 + ?b1 : \<nat> == True
  [| ?a1 : \<int>; ?b1 : \<int> |] ==> ?a1 + ?b1 : \<int> == True
  ([], ?xs1) : listrel1 ?r1 == False
  ([], ?y1) : lexord ?r1 == EX a x. ?y1 = a # x
  ([], ?ns1) : lenlex ?r1 == ?ns1 ~= []
  ([], ?ys1) : lex ?r1 == False
  (?xs1, []) : listrel1 ?r1 == False
  (?x1, []) : lexord ?r1 == False
  (?ns1, []) : lenlex ?r1 == False
  (?xs1, []) : lex ?r1 == False
  (?A1, ?B1) : finite_psubset == ?A1 < ?B1 & finite ?B1
  (?x1, ?y1) : less_than == ?x1 < ?y1
  ?r1 initial_segment_of ?r1 == True
  (?a1, ?b1) : Id == ?a1 = ?b1
  wf ?r1 ==> (?a1, ?a1) : ?r1 == False
  (?a1, ?a1) : ?r1^* == True
  (?x1, ?y1) : measure ?f1 == ?f1 ?x1 < ?f1 ?y1
  (?a1, ?b1) : ?r1^-1 == (?b1, ?a1) : ?r1
  (?x1, ?y1) : measures [] == False
  (?x1, ?y1) : measures (?f1 # ?fs1) ==
  ?f1 ?x1 < ?f1 ?y1 | ?f1 ?x1 = ?f1 ?y1 & (?x1, ?y1) : measures ?fs1
  (?xs1, ?xs1) : listrel (?r1^*) == True
  irrefl ?r1 ==> (?x1, ?x1) : lex ?r1 == False
  (?x1, ?y1) : inv_image ?r1 ?f1 == (?f1 ?x1, ?f1 ?y1) : ?r1
  (?a1, ?b1) : Sigma ?A1 ?B1 == ?a1 : ?A1 & ?b1 : ?B1 ?a1
  (?y1, ?x1) : prod.swap ` ?A1 == (?x1, ?y1) : ?A1
  ((?x1, ?y1), ?x1, ?z1) : pair_less == ?y1 < ?z1
  ((?a1, ?b1), ?a'1, ?b'1) : ?r1 <*lex*> ?s1 ==
  (?a1, ?a'1) : ?r1 | ?a1 = ?a'1 & (?b1, ?b'1) : ?s1
  (?x1 # ?xs1, ?y1 # ?ys1) : listrel1 ?r1 ==
  (?x1, ?y1) : ?r1 & ?xs1 = ?ys1 | ?x1 = ?y1 & (?xs1, ?ys1) : listrel1 ?r1
  (?a1 # ?x1, ?b1 # ?y1) : lexord ?r1 ==
  (?a1, ?b1) : ?r1 | ?a1 = ?b1 & (?x1, ?y1) : lexord ?r1
  (?x1 # ?xs1, ?y1 # ?ys1) : lex ?r1 ==
  (?x1, ?y1) : ?r1 & length ?xs1 = length ?ys1 |
  ?x1 = ?y1 & (?xs1, ?ys1) : lex ?r1
  irrefl ?r1 ==>
  (?xs1 @ ?ys1, ?xs1 @ ?zs1) : lexord ?r1 == (?ys1, ?zs1) : lexord ?r1
  irrefl ?R1 ==>
  (?us1 @ ?xs1, ?us1 @ ?ys1) : lenlex ?R1 == (?xs1, ?ys1) : lenlex ?R1
  ?x1 # ?xs1 : lists ?A1 == ?x1 : ?A1 & ?xs1 : lists ?A1
  [| ?a1 : ?A1; ?l1 : lists ?A1 |] ==> ?a1 # ?l1 : lists ?A1 == True
  splice ?xs1 ?ys1 : shuffles ?xs1 ?ys1 == True
  ?xs1 @ ?ys1 : lists ?A1 == ?xs1 : lists ?A1 & ?ys1 : lists ?A1
  ?n1 < length ?xs1 ==> ?xs1 ! ?n1 : set ?xs1 == True
  insert ?a1 (?A1 - {?a1}) == insert ?a1 ?A1
  insert ?x1 (insert ?x1 ?A1) == insert ?x1 ?A1
  ?x1 : ?A1 ==> insert (?f1 ?x1) (?f1 ` ?A1) == ?f1 ` ?A1
  disjnt {} ?A1 == True
  disjnt ?A1 {} == True
  disjnt ?S1 ?S1 == ?S1 = {}
  disjnt ?B1 (\<Union> ?\<A>1) == ALL A:?\<A>1. disjnt ?B1 A
  disjnt ?C1 (?A1 Un ?B1) == disjnt ?C1 ?A1 & disjnt ?C1 ?B1
  disjnt ?Y1 (insert ?a1 ?X1) == ?a1 ~: ?Y1 & disjnt ?Y1 ?X1
  disjnt (\<Union> ?\<A>1) ?B1 == ALL A:?\<A>1. disjnt A ?B1
  disjnt (?A1 Un ?B1) ?C1 == disjnt ?A1 ?C1 & disjnt ?B1 ?C1
  disjnt (?A1 \<times> ?C1) (?B1 \<times> ?C1) == ?C1 = {} | disjnt ?A1 ?B1
  disjnt (?C1 \<times> ?A1) (?C1 \<times> ?B1) == ?C1 = {} | disjnt ?A1 ?B1
  disjnt (insert ?a1 ?X1) ?Y1 == ?a1 ~: ?Y1 & disjnt ?X1 ?Y1
  Random.log ?b1 ?i1 ==
  if ?b1 <= 1 | ?i1 < ?b1 then 1 else 1 + Random.log ?b1 (?i1 div ?b1)
  ?R1 ^^ 0 == (=)
  ?R1 ^^ 0 == Id
  ?f1 ^^ 0 == id
  ?y ^^ 1 == ?y
  ?y ^^ 1 == ?y
  Suc ^^ ?n1 == (+) ?n1
  id ^^ ?n1 == id
  ?R1 ^^ Suc ?n1 == ?R1 ^^ ?n1 OO ?R1
  ?R1 ^^ Suc ?n1 == ?R1 ^^ ?n1 O ?R1
  ?f1 ^^ Suc ?n1 == ?f1 o ?f1 ^^ ?n1
  [| distinct (map fst ?xys1); (?x1, ?y1) : set ?xys1 |]
  ==> map_of ?xys1 ?x1 == Some ?y1
  Map.empty \<subseteq>\<^sub>m ?g1 == True
  ?f1 \<subseteq>\<^sub>m ?f1 == True
  ?f1 \<subseteq>\<^sub>m ?g1 ++ ?f1 == True
  ?f1 \<subseteq>\<^sub>m ?g1 ==>
  ?f1(?as1 [|->] ?bs1) \<subseteq>\<^sub>m ?g1(?as1 [|->] ?bs1) == True
  ?f1(?x1 := None) \<subseteq>\<^sub>m ?f1 == True
  ?m1.1 \<subseteq>\<^sub>m ?m2.1 ==>
  ?m1.1(?x1 := None) \<subseteq>\<^sub>m ?m2.1(?x1 |-> ?y1) == True
  ?f1 \<subseteq>\<^sub>m ?g1 ==>
  ?f1(?a1 := ?b1) \<subseteq>\<^sub>m ?g1(?a1 := ?b1) == True
  foldr ?f1 [] == id
  foldr ?f1 (replicate ?n1 ?x1) == ?f1 ?x1 ^^ ?n1
  foldr ?f1 (?x1 # ?xs1) == ?f1 ?x1 o foldr ?f1 ?xs1
  intrel (?x1, ?y1) (?u1, ?v1) == ?x1 + ?v1 = ?u1 + ?y1
  inj_on char_of {0..<256} == True
  inj_on of_nat ?N1 == True
  inj_on uminus ?A1 == True
  inj_on prod.swap ?A1 == True
  inj_on Some ?A1 == True
  inj_on Inr ?A1 == True
  inj_on Inl ?A1 == True
  inj_on rev ?A1 == True
  inj_on Suc ?N1 == True
  inj_on id ?A1 == True
  inj (%b. b / ?a1) == ?a1 ~= (0::?'a1)
  inj (%b. b - ?a1) == True
  inj_on ?f1 {} == True
  inj_on (%x. x) ?A1 == True
  inj_on (%x. {x}) ?A1 == True
  inj_on (%b. b + ?a1) ?A1 == True
  inj_on ?f1 (insert ?a1 ?A1) ==
  inj_on ?f1 ?A1 & ?f1 ?a1 ~: ?f1 ` (?A1 - {?a1})
  inj ((*) ?a1) == ?a1 ~= (0::?'a1)
  inj_on ((+) ?a1) ?A1 == True
  inj (apsnd ?f1) == inj ?f1
  inj_on (apsnd ?f1) (UNIV \<times> ?A1) == inj_on ?f1 ?A1
  inj (apfst ?f1) == inj ?f1
  inj_on (apfst ?f1) (?A1 \<times> UNIV) == inj_on ?f1 ?A1
  inj_on ((#) ?x1) ?A1 == True
  inj (map ?f1) == inj ?f1
  inj_on (?m1 ++ ?m'1) (dom ?m'1) == inj_on ?m'1 (dom ?m'1)
  inj ?f1 ==> inj (?f1 ^^ ?n1) == True
  uminus ` {?x1<..} == {..<- ?x1}
  uminus ` {..<?x1} == {- ?x1<..}
  uminus ` {?x1..} == {..- ?x1}
  uminus ` {..?x1} == {- ?x1..}
  uminus ` {?x1<..<?y1} == {- ?y1<..<- ?x1}
  uminus ` {?x1<..?y1} == {- ?y1..<- ?x1}
  uminus ` {?x1..<?y1} == {- ?y1<..- ?x1}
  uminus ` {?x1..?y1} == {- ?y1..- ?x1}
  range prod.swap == UNIV
  range snd == UNIV
  snd ` (?A1 \<times> ?B1) == if ?A1 = {} then {} else ?B1
  range fst == UNIV
  fst ` (?A1 \<times> ?B1) == if ?B1 = {} then {} else ?A1
  range abs == \<nat>
  Suc ` {?i1..<?j1} == {Suc ?i1..<Suc ?j1}
  Suc ` {?i1..?j1} == {Suc ?i1..Suc ?j1}
  range (%x. x - ?a1) == UNIV
  range (%_. ?x1) == {?x1}
  ?f1 ` {} == {}
  (%x. if ?P1 x then ?f1 x else ?g1 x) ` ?S1 ==
  ?f1 ` (?S1 Int {x. ?P1 x}) Un ?g1 ` (?S1 Int {x. ~ ?P1 x})
  (%x. x) ` ?y == ?y
  (%n. n + ?k1) ` {?i1..<?j1} == {?i1 + ?k1..<?j1 + ?k1}
  (%n. n + ?k1) ` {?i1..?j1} == {?i1 + ?k1..?j1 + ?k1}
  (%t. t - ?d1) ` {?a1..?b1} == {?a1 - ?d1..?b1 - ?d1}
  (0::?'a1) < ?d1 ==> (%c. c / ?d1) ` {?a1..?b1} == {?a1 / ?d1..?b1 / ?d1}
  ?f1 ` ?f1 -` ?A1 == ?A1 Int range ?f1
  ?f1 ` insert ?a1 ?B1 == insert (?f1 ?a1) (?f1 ` ?B1)
  (0::?'a1) < ?d1 ==> (*) ?d1 ` {?a1..?b1} == {?d1 * ?a1..?d1 * ?b1}
  (-) ?c1 ` {?a1..} == {..?c1 - ?a1}
  (-) ?c1 ` {..?b1} == {?c1 - ?b1..}
  (-) ?c1 ` {?a1<..?b1} == {?c1 - ?b1..<?c1 - ?a1}
  (-) ?c1 ` {?a1..<?b1} == {?c1 - ?b1<..?c1 - ?a1}
  (-) ?d1 ` {?a1..?b1} == {?d1 - ?b1..?d1 - ?a1}
  (+) (0::?'a1) ` ?y == ?y
  range ((+) ?a1) == UNIV
  (+) ?k1 ` {?i1..} == {?k1 + ?i1..}
  (+) ?c1 ` {..?a1} == {..?c1 + ?a1}
  (+) ?c1 ` {?a1<..?b1} == {?c1 + ?a1<..?c1 + ?b1}
  (+) ?k1 ` {?i1..<?j1} == {?i1 + ?k1..<?j1 + ?k1}
  (+) ?k1 ` {?i1..?j1} == {?i1 + ?k1..?j1 + ?k1}
  [| inj_on ?f1 ?A1; ?y <= ?A1 |] ==> inv_into ?A1 ?f1 ` ?f1 ` ?y == ?y
  inj_on ?f1 ?y ==> the_inv_into ?y ?f1 ` ?f1 ` ?y == ?y
  surj ?f1 ==> range (?f1 ^^ ?n1) == UNIV
  ?x1 ~: ?A1 ==> ?m1(?x1 |-> ?y1) ` ?A1 == ?m1 ` ?A1
  [?i1..?i1] == [?i1]
  ?j1 < ?i1 ==> [?i1..?j1] == []
  [- numeral ?m1..- numeral ?n1] ==
  if - numeral ?m1 <= - numeral ?n1
  then - numeral ?m1 # [- numeral ?m1 + 1..- numeral ?n1] else []
  [- numeral ?m1..numeral ?n1] ==
  if - numeral ?m1 <= numeral ?n1
  then - numeral ?m1 # [- numeral ?m1 + 1..numeral ?n1] else []
  [numeral ?m1..- numeral ?n1] ==
  if numeral ?m1 <= - numeral ?n1
  then numeral ?m1 # [numeral ?m1 + 1..- numeral ?n1] else []
  [numeral ?m1..numeral ?n1] ==
  if numeral ?m1 <= numeral ?n1
  then numeral ?m1 # [numeral ?m1 + 1..numeral ?n1] else []
  take ?n1 [] == []
  length ?y <= ?n1 ==> take ?n1 ?y == ?y
  take ?i1 (replicate ?k1 ?x1) == replicate (min ?i1 ?k1) ?x1
  take ?n1 (?xs1 @ ?ys1) == take ?n1 ?xs1 @ take (?n1 - length ?xs1) ?ys1
  take ?n1 (take ?m1 ?xs1) == take (min ?n1 ?m1) ?xs1
  ?i1 + ?m1 <= ?n1 ==> take ?m1 [?i1..<?n1] == [?i1..<?i1 + ?m1]
  ?n1 <= ?m1 ==> take ?n1 (?xs1[?m1 := ?y1]) == take ?n1 ?xs1
  take (numeral ?v1) (?x1 # ?xs1) == ?x1 # take (numeral ?v1 - 1) ?xs1
  take (Suc ?n1) (?x1 # ?xs1) == ?x1 # take ?n1 ?xs1
  nths [] ?A1 == []
  nths ?xs1 {} == []
  nths ?l1 {..<?n1} == take ?n1 ?l1
  nths [?x1] ?A1 == if 0 : ?A1 then [?x1] else []
  lexn ?r1 0 == {}
  lexn ?r1 (Suc ?n1) ==
  map_prod (%(x, xs). x # xs) (%(x, xs). x # xs) `
  (?r1 <*lex*> lexn ?r1 ?n1) Int
  {(xs, ys). length xs = Suc ?n1 & length ys = Suc ?n1}
  fold ?f1 [] == id
  fold ?f1 (replicate ?n1 ?x1) == ?f1 ?x1 ^^ ?n1
  fold ?f1 (?x1 # ?xs1) == fold ?f1 ?xs1 o ?f1 ?x1
  fold ?f1 (?xs1 @ ?ys1) == fold ?f1 ?ys1 o fold ?f1 ?xs1
  find ?uu1 [] == None
  find ?P1 (?x1 # ?xs1) == if ?P1 ?x1 then Some ?x1 else find ?P1 ?xs1
  drop ?n1 [] == []
  length ?xs1 <= ?n1 ==> drop ?n1 ?xs1 == []
  drop ?i1 (replicate ?k1 ?x1) == replicate (?k1 - ?i1) ?x1
  drop ?n1 (?xs1 @ ?ys1) == drop ?n1 ?xs1 @ drop (?n1 - length ?xs1) ?ys1
  drop ?n1 (drop ?m1 ?xs1) == drop (?n1 + ?m1) ?xs1
  drop ?m1 [?i1..<?j1] == [?i1 + ?m1..<?j1]
  ?n1 < ?m1 ==> drop ?m1 (?xs1[?n1 := ?x1]) == drop ?m1 ?xs1
  drop (numeral ?v1) (?x1 # ?xs1) == drop (numeral ?v1 - 1) ?xs1
  drop (Suc ?n1) (?x1 # ?xs1) == drop ?n1 ?xs1
  List.bind [] ?f1 == []
  List.bind (?x1 # ?xs1) ?f1 == ?f1 ?x1 @ List.bind ?xs1 ?f1
  fcomp id ?y == ?y
  fcomp ?y id == ?y
  bacc ?r1 0 == {x. ALL y. (y, x) ~: ?r1}
  bacc ?r1 (Suc ?n1) ==
  bacc ?r1 ?n1 Un {x. ALL y. (y, x) : ?r1 --> y : bacc ?r1 ?n1}
  Set.bind {} ?f1 == {}
  ALL x:UNIV. ?P1 x == ALL x. ?P1 x
  Ball UNIV ?P1 == All ?P1
  ALL x:{}. ?P1 x == True
  Ball {} ?P1 == True
  ALL x:?A1. ?P1 x --> ?Q1 == (EX x:?A1. ?P1 x) --> ?Q1
  ALL x:?A1. ?P1 --> ?Q1 x == ?P1 --> (ALL x:?A1. ?Q1 x)
  ALL x:?A1. ?P1 | ?Q1 x == ?P1 | (ALL x:?A1. ?Q1 x)
  ALL x:?A1. ?P1 x | ?Q1 == (ALL x:?A1. ?P1 x) | ?Q1
  ALL x:?A1. ?a1 = x --> ?P1 x == ?a1 : ?A1 --> ?P1 ?a1
  ALL x:?A1. x = ?a1 --> ?P1 x == ?a1 : ?A1 --> ?P1 ?a1
  ALL x:?A1. ?P1 == (EX x. x : ?A1) --> ?P1
  ALL x:\<Union> ?A1. ?P1 x == ALL y:?A1. ALL x:y. ?P1 x
  ALL x:\<Union> (?B1 ` ?A1). ?P1 x == ALL a:?A1. ALL x:?B1 a. ?P1 x
  ALL x:set (replicate ?n1 ?a1). ?P1 x == ?P1 ?a1 | ?n1 = 0
  ALL x:Collect ?Q1. ?P1 x == ALL x. ?Q1 x --> ?P1 x
  ALL z:Sigma ?A1 ?B1. ?P1 z == ALL x:?A1. ALL y:?B1 x. ?P1 (x, y)
  ALL x:insert ?a1 ?B1. ?P1 x == ?P1 ?a1 & (ALL x:?B1. ?P1 x)
  ALL x:?f1 ` ?A1. ?P1 x == ALL x:?A1. ?P1 (?f1 x)
  (PROP ?P ==> True) == True
  (False ==> ?P) == True
  (True ==> PROP ?P) == PROP ?P
  zip [] ?ys1 == []
  zip ?xs1 [] == []
  zip (replicate ?i1 ?x1) (replicate ?j1 ?y1) ==
  replicate (min ?i1 ?j1) (?x1, ?y1)
  zip (?x1 # ?xs1) (?y1 # ?ys1) == (?x1, ?y1) # zip ?xs1 ?ys1
  length ?xs1 = length ?us1 ==>
  zip (?xs1 @ ?ys1) (?us1 @ ?vs1) == zip ?xs1 ?us1 @ zip ?ys1 ?vs1
  [?i1..<0] == []
  ?j1 <= ?i1 ==> [?i1..<?j1] == []
  [?i1..<Suc ?j1] == if ?i1 <= ?j1 then [?i1..<?j1] @ [?j1] else []
  [numeral ?m1..<numeral ?n1] ==
  if numeral ?m1 < numeral ?n1
  then numeral ?m1 # [Suc (numeral ?m1)..<numeral ?n1] else []
  ?i1 < ?n1 ==> replicate ?n1 ?y ! ?i1 == ?y
  (?y # ?xs1) ! 0 == ?y
  0 < ?n1 ==> (?x1 # ?xs1) ! ?n1 == ?xs1 ! (?n1 - 1)
  (?x1 # ?xs1) ! numeral ?v1 == ?xs1 ! (numeral ?v1 - 1)
  (?x1 # ?xs1) ! Suc ?n1 == ?xs1 ! ?n1
  ?n1 < length ?xs1 ==> map ?f1 ?xs1 ! ?n1 == ?f1 (?xs1 ! ?n1)
  (?xs1 @ ?ys1) ! (length ?xs1 + ?n1) == ?ys1 ! ?n1
  (?xs1 @ ?y # ?ys1) ! length ?xs1 == ?y
  ?i1 + int ?k1 <= ?j1 ==> [?i1..?j1] ! ?k1 == ?i1 + int ?k1
  ?i1 < ?n1 ==> take ?n1 ?xs1 ! ?i1 == ?xs1 ! ?i1
  ?n1 <= length ?xs1 ==> drop ?n1 ?xs1 ! ?i1 == ?xs1 ! (?n1 + ?i1)
  [| ?i1 < length ?xs1; ?i1 < length ?ys1 |]
  ==> zip ?xs1 ?ys1 ! ?i1 == (?xs1 ! ?i1, ?ys1 ! ?i1)
  ?i1 + ?k1 < ?j1 ==> [?i1..<?j1] ! ?k1 == ?i1 + ?k1
  [| sorted (rev (map length ?xs1)); ?i1 < length (transpose ?xs1);
     ?j1 < length (filter (%ys. ?i1 < length ys) ?xs1) |]
  ==> transpose ?xs1 ! ?i1 ! ?j1 == ?xs1 ! ?j1 ! ?i1
  ?i1 ~= ?j1 ==> ?xs1[?i1 := ?x1] ! ?j1 == ?xs1 ! ?j1
  ?i1 < length ?xs1 ==> ?xs1[?i1 := ?y] ! ?i1 == ?y
  False | ?y == ?y
  True | ?P1 == True
  ?y | False == ?y
  ?P1 | True == True
  ?y | ?y == ?y
  ?P1 | ~ ?P1 == True
  ?Q1 | (?P1 --> ?R1) == ?P1 --> ?Q1 | ?R1
  ?a1 | ?a1 | ?b1 == ?a1 | ?b1
  ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
  ~ ?P1 | ?P1 == True
  ~ ?P1 | ?Q1 == ?P1 --> ?Q1
  (?P1 --> ?Q1) | ?R1 == ?P1 --> ?Q1 | ?R1
  (?a1 | ?b1) | ?b1 == ?a1 | ?b1
  (?P1 | ?Q1) | ?R1 == ?P1 | ?Q1 | ?R1
  False & ?P1 == False
  True & ?y == ?y
  ?P1 & False == False
  ?y & True == ?y
  ?y & ?y == ?y
  ?P1 & ~ ?P1 == False
  ?a1 & ?a1 & ?b1 == ?a1 & ?b1
  ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
  ~ ?P1 & ?P1 == False
  0 dvd ?a1 & 0 ~= ?a1 == False
  (?P1 --> ?y) & (~ ?P1 --> ?y) == ?y
  (?a1 & ?b1) & ?b1 == ?a1 & ?b1
  (?P1 & ?Q1) & ?R1 == ?P1 & ?Q1 & ?R1
  bezw ?x1 0 == (1, 0)
  char_of o of_char == id
  uminus o uminus == id
  uminus o uminus == id
  prod.swap o prod.swap == id
  snd o apsnd ?f1 == ?f1 o snd
  snd o apfst ?f1 == snd
  snd o map_prod ?f1 ?g1 == ?g1 o snd
  fst o apsnd ?f1 == fst
  fst o apfst ?f1 == ?f1 o fst
  fst o map_prod ?f1 ?g1 == ?f1 o fst
  the o Some == id
  id o ?y == ?y
  ?y o id == ?y
  map_option ?f1 o Map.empty == Map.empty
  map_option ?f1 o case_sum ?g1 ?h1 ==
  case_sum (map_option ?f1 o ?g1) (map_option ?f1 o ?h1)
  map_option ?f1 o ?m1(?a1 |-> ?b1) == (map_option ?f1 o ?m1)(?a1 |->
  ?f1 ?b1)
  map ?f1 o map ?g1 == map (?f1 o ?g1)
  inj ?f1 ==> inv ?f1 o ?f1 == id
  inj ?f1 ==> ?y o inv ?f1 o ?f1 == ?y
  EX x:UNIV. ?P1 x == EX x. ?P1 x
  Bex UNIV ?P1 == Ex ?P1
  EX x:{}. ?P1 x == False
  Bex {} ?P1 == False
  EX x:?A1. ?P1 & ?Q1 x == ?P1 & (EX x:?A1. ?Q1 x)
  EX x:?A1. ?P1 x & ?Q1 == (EX x:?A1. ?P1 x) & ?Q1
  EX x:?A1. ?a1 = x & ?P1 x == ?a1 : ?A1 & ?P1 ?a1
  EX x:?A1. x = ?a1 & ?P1 x == ?a1 : ?A1 & ?P1 ?a1
  EX x:?A1. x = ?a1 == ?a1 : ?A1
  EX x:?A1. ?P1 == (EX x. x : ?A1) & ?P1
  EX x:?A1. ?a1 = x == ?a1 : ?A1
  EX x:\<Union> ?A1. ?P1 x == EX y:?A1. EX x:y. ?P1 x
  EX x:\<Union> (?B1 ` ?A1). ?P1 x == EX a:?A1. EX x:?B1 a. ?P1 x
  EX x:set (replicate ?n1 ?a1). ?P1 x == ?P1 ?a1 & ?n1 ~= 0
  EX x:Collect ?Q1. ?P1 x == EX x. ?Q1 x & ?P1 x
  EX z:Sigma ?A1 ?B1. ?P1 z == EX x:?A1. EX y:?B1 x. ?P1 (x, y)
  EX x:insert ?a1 ?B1. ?P1 x == ?P1 ?a1 | (EX x:?B1. ?P1 x)
  EX x:?f1 ` ?A1. ?P1 x == EX x:?A1. ?P1 (?f1 x)
  Num.pow ?y num.One == ?y
  Num.pow ?x1 (num.Bit1 ?y1) == Num.sqr (Num.pow ?x1 ?y1) * ?x1
  Num.pow ?x1 (num.Bit0 ?y1) == Num.sqr (Num.pow ?x1 ?y1)
  Int.sub ?m1 ?n1 == numeral ?m1 - numeral ?n1
  Let (0::?'b1) ?f1 == ?f1 (0::?'b1)
  Let (1::?'b1) ?f1 == ?f1 (1::?'b1)
  Let (- numeral ?v1) ?f1 == ?f1 (- numeral ?v1)
  Let (numeral ?v1) ?f1 == ?f1 (numeral ?v1)
  Let (Suc ?n) ?f == ?f (Suc ?n)
  three_valued.Unknown_value = three_valued.No_value == False
  three_valued.Unknown_value = three_valued.Value ?x2.1 == False
  three_valued.No_value = three_valued.Unknown_value == False
  three_valued.No_value = three_valued.Value ?x2.1 == False
  unknown.Unknown = unknown.Known ?x2.1 == False
  Right = Left == False
  UNIV = {} == False
  top = Inf ?A1 == ALL x:?A1. x = top
  UNIV = \<Inter> ?A1 == ALL x:?A1. x = UNIV
  top = Inf (?B1 ` ?A1) == ALL x:?A1. ?B1 x = top
  UNIV = {?l'1..} == False
  UNIV = {..?h'1} == False
  UNIV = {?l'1..?h'1} == False
  top = inf ?a1 ?b1 == ?a1 = top & ?b1 = top
  {} = UNIV == False
  bot = Sup ?A1 == ALL x:?A1. x = bot
  bot = Sup (?B1 ` ?A1) == ALL x:?A1. ?B1 x = bot
  {} = {?l1..} == False
  {} = {..?h1} == False
  {} = set ?xs1 == ?xs1 = []
  {} = Collect ?P1 == ALL x. ~ ?P1 x
  {} = {?a1<..<?b1} == ?b1 <= ?a1
  {} = {?k1<..?l1} == ~ ?k1 < ?l1
  {} = {?a1..<?b1} == ~ ?a1 < ?b1
  {} = {?a1..?b1} == ~ ?a1 <= ?b1
  {} = ?A1 // ?r1 == ?A1 = {}
  bot = sup ?a1 ?b1 == ?a1 = bot & ?b1 = bot
  {} = ?A1 Int insert ?b1 ?B1 == ?b1 ~: ?A1 & {} = ?A1 Int ?B1
  {} = insert ?a1 ?A1 Int ?B1 == ?a1 ~: ?B1 & {} = ?A1 Int ?B1
  {} = insert ?a1 ?A1 == False
  {} = ?f1 ` ?A1 == ?A1 = {}
  Left = Right == False
  a\<^sub>5 = a\<^sub>4 == False
  a\<^sub>5 = a\<^sub>3 == False
  a\<^sub>5 = a\<^sub>2 == False
  a\<^sub>5 = a\<^sub>1 == False
  a\<^sub>4 = a\<^sub>5 == False
  a\<^sub>4 = a\<^sub>3 == False
  a\<^sub>4 = a\<^sub>2 == False
  a\<^sub>4 = a\<^sub>1 == False
  a\<^sub>3 = a\<^sub>5 == False
  a\<^sub>3 = a\<^sub>4 == False
  a\<^sub>3 = a\<^sub>2 == False
  a\<^sub>3 = a\<^sub>1 == False
  a\<^sub>2 = a\<^sub>5 == False
  a\<^sub>2 = a\<^sub>4 == False
  a\<^sub>2 = a\<^sub>3 == False
  a\<^sub>2 = a\<^sub>1 == False
  a\<^sub>1 = a\<^sub>5 == False
  a\<^sub>1 = a\<^sub>4 == False
  a\<^sub>1 = a\<^sub>3 == False
  a\<^sub>1 = a\<^sub>2 == False
  a\<^sub>4 = a\<^sub>3 == False
  a\<^sub>4 = a\<^sub>2 == False
  a\<^sub>4 = a\<^sub>1 == False
  a\<^sub>3 = a\<^sub>4 == False
  a\<^sub>3 = a\<^sub>2 == False
  a\<^sub>3 = a\<^sub>1 == False
  a\<^sub>2 = a\<^sub>4 == False
  a\<^sub>2 = a\<^sub>3 == False
  a\<^sub>2 = a\<^sub>1 == False
  a\<^sub>1 = a\<^sub>4 == False
  a\<^sub>1 = a\<^sub>3 == False
  a\<^sub>1 = a\<^sub>2 == False
  a\<^sub>3 = a\<^sub>2 == False
  a\<^sub>3 = a\<^sub>1 == False
  a\<^sub>2 = a\<^sub>3 == False
  a\<^sub>2 = a\<^sub>1 == False
  a\<^sub>1 = a\<^sub>3 == False
  a\<^sub>1 = a\<^sub>2 == False
  a\<^sub>2 = a\<^sub>1 == False
  a\<^sub>1 = a\<^sub>2 == False
  (0::?'a1) = (1::?'a1) == False
  (0::?'a1) = of_nat ?n1 == 0 = ?n1
  (0::?'a1) = of_nat (Suc ?n1) == False
  (0::?'a1) = - (1::?'a1) == False
  (0::?'a1) = - ?a1 == (0::?'a1) = ?a1
  (0::?'a1) = - numeral ?n1 == False
  (0::?'a1) = numeral ?n1 == False
  (0::?'a1) = of_int ?z1 == ?z1 = 0
  (0::?'a1) = \<bar>?a1\<bar> == ?a1 = (0::?'a1)
  0 = Code_Numeral.Suc ?natural'1 == False
  0 = Suc ?x2.1 == False
  (0::?'a1) = (1::?'a1) / ?a1 == ?a1 = (0::?'a1)
  0 = max ?a1 ?b1 == ?a1 = 0 & ?b1 = 0
  (0::?'a1) = ?x1 + ?y1 == ?x1 = (0::?'a1) & ?y1 = (0::?'a1)
  (0::?'a1) = ?a1 + ?a1 == ?a1 = (0::?'a1)
  0 = gcd ?a1 ?b1 == ?a1 = 0 & ?b1 = 0
  STR '''' = String.Literal ?b0.1 ?b1.1 ?b2.1 ?b3.1 ?b4.1 ?b5.1 ?b6.1 ?s1 ==
  False
  (1::?'a1) = (0::?'a1) == False
  (1::?'a1) = of_nat ?n1 == ?n1 = 1
  (1::?'a1) = - (1::?'a1) == False
  (1::?'a1) = - ?a1 == ?a1 = - (1::?'a1)
  (1::?'a1) = - numeral ?n1 == False
  (1::?'a1) = numeral ?n1 == num.One = ?n1
  (1::?'a1) = ?a1 / ?b1 == ?b1 ~= (0::?'a1) & ?a1 = ?b1
  (1::?'a1) = ?b1 / ?a1 == ?a1 ~= (0::?'a1) & ?a1 = ?b1
  1 = ?m1 * ?n1 == ?m1 = 1 & ?n1 = 1
  seq.Empty = seq.Insert ?x21.1 ?x22.1 == False
  seq.Empty = seq.Join ?x31.1 ?x32.1 == False
  None = Some ?x2.1 == False
  None = map_option ?f1 ?x1 == ?x1 = None
  cofinite = bot == finite UNIV
  [] = remdups ?x1 == ?x1 = []
  [] = concat ?xss1 == ALL xs:set ?xss1. xs = []
  [] = rev ?xs1 == ?xs1 = []
  [] = replicate ?n1 ?x1 == ?n1 = 0
  [] = ?x21.1 # ?x22.1 == False
  [] = map ?f1 ?xs1 == ?xs1 = []
  [] = ?xs1 @ ?ys1 == ?xs1 = [] & ?ys1 = []
  [] = [?i1..?j1] == ?j1 < ?i1
  [] = take ?n1 ?xs1 == ?n1 = 0 | ?xs1 = []
  [] = drop ?n1 ?xs1 == length ?xs1 <= ?n1
  [] = zip ?xs1 ?ys1 == ?xs1 = [] | ?ys1 = []
  at_top = bot == False
  sequentially = bot == False
  at_bot = bot == False
  num.One = num.Bit1 ?x3.1 == False
  num.One = num.Bit0 ?x2.1 == False
  False = True == False
  False = ?P1 == ~ ?P1
  True = False == False
  True = ?y == ?y
  ?P1 = False == ~ ?P1
  ?y = True == ?y
  ?x1 = ?x1 == True
  ?a1 = - ?a1 == ?a1 = (0::?'a1)
  Map.empty = map_of ?xys1 == ?xys1 = []
  ?P1 = (~ ?P1) == False
  ?a1 = ?b1 / - numeral ?w1 ==
  if - numeral ?w1 ~= (0::?'a1) then ?a1 * - numeral ?w1 = ?b1
  else ?a1 = (0::?'a1)
  ?a1 = ?b1 / numeral ?w1 ==
  if numeral ?w1 ~= (0::?'a1) then ?a1 * numeral ?w1 = ?b1
  else ?a1 = (0::?'a1)
  ?c1 = ?c1 * ?b1 == ?c1 = (0::?'a1) | ?b1 = (1::?'a1)
  ?c1 = ?b1 * ?c1 == ?c1 = (0::?'a1) | ?b1 = (1::?'a1)
  ?a1 = ?b1 + ?a1 == ?b1 = (0::?'a1)
  ?a1 = ?a1 + ?b1 == ?b1 = (0::?'a1)
  ?xs1 = ?x1 # ?xs1 == False
  Map.empty = ?f1 ++ ?g1 == ?f1 = Map.empty & ?g1 = Map.empty
  ?y1 = ?xs1 @ ?y1 == ?xs1 = []
  ?y1 = ?y1 @ ?ys1 == ?ys1 = []
  division_segment ?a1 = (0::?'a1) == False
  char_of ?m1 = char_of ?n1 == ?m1 mod (256::?'a1) = ?n1 mod (256::?'a1)
  Narrowing_sum_of_products ?x1 = Narrowing_sum_of_products ?ya1 ==
  ?x1 = ?ya1
  euclidean_size ?b1 = 0 == ?b1 = (0::?'a1)
  lazy_sequence_of_list ?x1 = lazy_sequence_of_list ?ya1 == ?x1 = ?ya1
  mask ?n1 = (0::?'a1) == ?n1 = 0
  not ?x1 = not ?y1 == ?x1 = ?y1
  normalize ?a1 = (0::?'a1) == ?a1 = (0::?'a1)
  three_valued.Value ?x2.1 = three_valued.Unknown_value == False
  three_valued.Value ?x2.1 = three_valued.No_value == False
  three_valued.Value ?x2.1 = three_valued.Value ?y2.1 == ?x2.1 = ?y2.1
  Property ?x3.1 = Property ?y3.1 == ?x3.1 = ?y3.1
  Property ?x3.1 = Existential ?x21.1 ?x22.1 ?x23.1 == False
  Property ?x3.1 = Universal ?x11.1 ?x12.1 ?x13.1 == False
  finite ?A1 ==> sorted_list_of_set ?A1 = [] == ?A1 = {}
  sum_list ?ns1 = (0::?'a1) == ALL n:set ?ns1. n = (0::?'a1)
  of_char ?c1 = of_char ?d1 == ?c1 = ?d1
  fact ?n1 = (0::?'a1) == False
  unit_factor ?a1 = (0::?'a1) == ?a1 = (0::?'a1)
  unknown.Known ?x2.1 = unknown.Unknown == False
  unknown.Known ?x2.1 = unknown.Known ?y2.1 == ?x2.1 = ?y2.1
  {?x1<..} = {} == False
  {?x1<..} = {?y1<..} == ?x1 = ?y1
  ffun.Constant ?x1.1 = ffun.Constant ?y1.1 == ?x1.1 = ?y1.1
  ffun.Constant ?x1.1 = ffun.Update ?x21.1 ?x22.1 ?x23.1 == False
  cfun.Constant ?x1 = cfun.Constant ?ya1 == ?x1 = ?ya1
  of_bool ?P1 = (0::?'a1) == ~ ?P1
  of_bool ?y = (1::?'a1) == ?y
  {..<?x1} = {} == False
  {..<?x1} = {..<?y1} == ?x1 = ?y1
  Sup ?A1 = top == ALL x<top. EX i:?A1. x < i
  Sup ?A1 = bot == ALL x:?A1. x = bot
  Sup (?f1 ` ?A1) = top == ALL x<top. EX i:?A1. x < ?f1 i
  Sup (?B1 ` ?A1) = bot == ALL x:?A1. ?B1 x = bot
  Inf ?A1 = top == ALL x:?A1. x = top
  \<Inter> ?A1 = UNIV == ALL x:?A1. x = UNIV
  Inf ?A1 = bot == ALL x>bot. EX i:?A1. i < x
  Inf (?B1 ` ?A1) = top == ALL x:?A1. ?B1 x = top
  Inf (?f1 ` ?A1) = bot == ALL x>bot. EX i:?A1. ?f1 i < x
  {?l'1..} = UNIV == False
  {?l1..} = {} == False
  {?x1..} = {?y1..} == ?x1 = ?y1
  {?l'1..} = {..?h1} == False
  {?l'1..} = {?l1..?h1} == False
  {..?h'1} = UNIV == False
  {..?h1} = {} == False
  {..?h1} = {?l'1..} == False
  {..?x1} = {..?y1} == ?x1 = ?y1
  {..?h'1} = {?l1..?h1} == False
  finite_subsets_at_top ?A1 = bot == False
  inverse ?a1 = (0::?'a1) == ?a1 = (0::?'a1)
  inverse ?x1 = (1::?'a1) == ?x1 = (1::?'a1)
  inverse ?a1 = inverse ?b1 == ?a1 = ?b1
  of_nat ?m1 = (0::?'a1) == ?m1 = 0
  of_nat ?n1 = (1::?'a1) == ?n1 = 1
  of_nat ?m1 = of_nat ?n1 == ?m1 = ?n1
  int ?m1 = numeral ?v1 == ?m1 = numeral ?v1
  of_nat ?x1 = of_nat ?b1 ^ ?w1 == ?x1 = ?b1 ^ ?w1
  of_nat ?y1 = numeral ?x1 ^ ?n1 == ?y1 = numeral ?x1 ^ ?n1
  of_nat (Suc ?n1) = (0::?'a1) == False
  - (1::?'a1) = (0::?'a1) == False
  - (1::?'a1) = (1::?'a1) == False
  - (1::?'a1) = - numeral ?n1 == ?n1 = num.One
  - (1::?'a1) = numeral ?n1 == False
  - ?a1 = (0::?'a1) == ?a1 = (0::?'a1)
  - ?a1 = (1::?'a1) == ?a1 = - (1::?'a1)
  - ?a1 = ?a1 == ?a1 = (0::?'a1)
  - ?A1 = - ?B1 == ?A1 = ?B1
  - ?x1 = - ?y1 == ?x1 = ?y1
  - ?a1 = - ?b1 == ?a1 = ?b1
  - int ?n1 = int ?m1 == ?n1 = 0 & ?m1 = 0
  - numeral ?n1 = (0::?'a1) == False
  - numeral ?n1 = (1::?'a1) == False
  - numeral ?n1 = - (1::?'a1) == ?n1 = num.One
  - numeral ?m1 = - numeral ?n1 == ?m1 = ?n1
  - numeral ?m1 = numeral ?n1 == False
  numeral ?n1 = (0::?'a1) == False
  numeral ?n1 = (1::?'a1) == ?n1 = num.One
  numeral ?n1 = - (1::?'a1) == False
  numeral ?m1 = - numeral ?n1 == False
  numeral ?m1 = numeral ?n1 == ?m1 = ?n1
  numeral ?k1 = Suc ?n1 == pred_numeral ?k1 = ?n1
  set_option ?xo1 = {} == ?xo1 = None
  of_int ?z1 = (0::?'a1) == ?z1 = 0
  of_int ?z1 = (1::?'a1) == ?z1 = 1
  of_int ?z1 = numeral ?n1 == ?z1 = numeral ?n1
  of_int ?w1 = of_int ?z1 == ?w1 = ?z1
  of_int ?y1 = (- numeral ?x1) ^ ?n1 == ?y1 = (- numeral ?x1) ^ ?n1
  of_int ?y1 = numeral ?x1 ^ ?n1 == ?y1 = numeral ?x1 ^ ?n1
  of_int ?x1 = of_int ?b1 ^ ?w1 == ?x1 = ?b1 ^ ?w1
  fun_box.FunBox ?x1 = fun_box.FunBox ?ya1 == ?x1 = ?ya1
  \<bar>?a1\<bar> = (0::?'a1) == ?a1 = (0::?'a1)
  pred.Pred ?x1 = pred.Pred ?ya1 == ?x1 = ?ya1
  length ?xs1 = 0 == ?xs1 = []
  length (remdups ?xs1) = length ?xs1 == remdups ?xs1 = ?xs1
  ?r1^--1 = ?s1^--1 == ?r1 = ?s1
  Some ?x2.1 = None == False
  Some ?x2.1 = Some ?y2.1 == ?x2.1 = ?y2.1
  distinct (map fst ?xys1) ==>
  Some ?y1 = map_of ?xys1 ?x1 == (?x1, ?y1) : set ?xys1
  ?r1^-1 = ?s1^-1 == ?r1 = ?s1
  word.Word ?x1 = word.Word ?ya1 == ?x1 = ?ya1
  finite ?A1 ==> Lcm ?A1 = 0 == 0 : ?A1
  Lcm ?A1 = (1::?'a1) == ALL a:?A1. is_unit a
  Gcd ?A1 = (0::?'a1) == ?A1 <= {0::?'a1}
  Predicate.single ?x1 = bot == False
  remdups_adj ?xs1 = [] == ?xs1 = []
  principal ?A1 = principal ?B1 == ?A1 = ?B1
  Code_Numeral.Suc ?natural'2 = 0 == False
  Code_Numeral.Suc ?natural1 = Code_Numeral.Suc ?natural'1 ==
  ?natural1 = ?natural'1
  finite ?A1 ==> card ?A1 = 0 == ?A1 = {}
  set ?xs1 = {} == ?xs1 = []
  Inr ?x2.1 = Inr ?y2.1 == ?x2.1 = ?y2.1
  Inr ?x2.1 = Inl ?x1.1 == False
  Inr ?b'2 = Inl ?a2 == False
  Inl ?x1.1 = Inr ?x2.1 == False
  Inl ?x1.1 = Inl ?y1.1 == ?x1.1 = ?y1.1
  num.Bit1 ?x3.1 = num.One == False
  num.Bit1 ?x3.1 = num.Bit1 ?y3.1 == ?x3.1 = ?y3.1
  num.Bit1 ?x3.1 = num.Bit0 ?x2.1 == False
  num.Bit0 ?x2.1 = num.One == False
  num.Bit0 ?x2.1 = num.Bit1 ?x3.1 == False
  num.Bit0 ?x2.1 = num.Bit0 ?y2.1 == ?x2.1 = ?y2.1
  rotate1 ?xs1 = [] == ?xs1 = []
  remdups ?x1 = [] == ?x1 = []
  remdups ?xs1 = ?xs1 == distinct ?xs1
  Collect ?P1 = {} == ALL x. ~ ?P1 x
  concat ?xss1 = [] == ALL xs:set ?xss1. xs = []
  map_of ?xys1 = Map.empty == ?xys1 = []
  rev ?xs1 = [] == ?xs1 = []
  rev ?xs1 = rev ?ys1 == ?xs1 = ?ys1
  rev ?xs1 = [?x1] == ?xs1 = [?x1]
  rev ?xs1 = ?y1 # ?ys1 == ?xs1 = rev ?ys1 @ [?y1]
  Pow ?X1 = {?Y1} == ?X1 = {} & ?Y1 = {}
  Suc 0 = ?m1 * ?n1 == ?m1 = Suc 0 & ?n1 = Suc 0
  Suc ?x2.1 = 0 == False
  Suc ?nat'2 = 0 == False
  Suc ?n1 = numeral ?k1 == ?n1 = pred_numeral ?k1
  Suc ?x2.1 = Suc ?y2.1 == ?x2.1 = ?y2.1
  dom ?f1 = {} == ?f1 = Map.empty
  nat ?i1 = 0 == ?i1 <= 0
  nat ?y1 = numeral ?x1 ^ ?n1 == ?y1 = numeral ?x1 ^ ?n1
  (~ ?P1) = ?P1 == False
  (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
  narrowing_term.Narrowing_constructor ?x21.1 ?x22.1 =
  narrowing_term.Narrowing_constructor ?y21.1 ?y22.1 ==
  ?x21.1 = ?y21.1 & ?x22.1 = ?y22.1
  narrowing_term.Narrowing_constructor ?x21.1 ?x22.1 =
  narrowing_term.Narrowing_variable ?x11.1 ?x12.1 ==
  False
  narrowing_term.Narrowing_variable ?x11.1 ?x12.1 =
  narrowing_term.Narrowing_constructor ?x21.1 ?x22.1 ==
  False
  narrowing_term.Narrowing_variable ?x11.1 ?x12.1 =
  narrowing_term.Narrowing_variable ?y11.1 ?y12.1 ==
  ?x11.1 = ?y11.1 & ?x12.1 = ?y12.1
  take_bit ?n1 (1::?'a1) = (0::?'a1) == ?n1 = 0
  push_bit ?n1 ?a1 = (0::?'a1) == ?a1 = (0::?'a1)
  ??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons ?x1.1 ?x2.1 =
  ??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons ?y1.1 ?y2.1 ==
  ?x1.1 = ?y1.1 & ?x2.1 = ?y2.1
  {?a1<..<?b1} = {} == ?b1 <= ?a1
  tuple_isomorphism.Tuple_Isomorphism ?x1.1 ?x2.1 =
  tuple_isomorphism.Tuple_Isomorphism ?y1.1 ?y2.1 ==
  ?x1.1 = ?y1.1 & ?x2.1 = ?y2.1
  {?k1<..?l1} = {} == ~ ?k1 < ?l1
  {?a1..<?b1} = {} == ~ ?a1 < ?b1
  finite ?A1 ==> prod ?f1 ?A1 = (0::?'a1) == EX a:?A1. ?f1 a = (0::?'a1)
  finite ?A1 ==> prod ?f1 ?A1 = 1 == ALL a:?A1. ?f1 a = 1
  {?l'1..?h'1} = UNIV == False
  {?a1..?b1} = {} == ~ ?a1 <= ?b1
  {?l1..?h1} = {?l'1..} == False
  {?l1..?h1} = {..?h'1} == False
  {?l1..?h1} = {?l'1..?h'1} ==
  ?l1 = ?l'1 & ?h1 = ?h'1 | ~ ?l1 <= ?h1 & ~ ?l'1 <= ?h'1
  {?a1..?b1} = {?c1} == ?a1 = ?b1 & ?b1 = ?c1
  finite ?F1 ==> sum ?f1 ?F1 = (0::?'a1) == ALL a:?F1. ?f1 a = (0::?'a1)
  (1::?'a1) / ?a1 = (0::?'a1) == ?a1 = (0::?'a1)
  (1::?'a1) div unit_factor ?a1 = (0::?'a1) == ?a1 = (0::?'a1)
  ?a1 / ?b1 = (0::?'a1) == ?a1 = (0::?'a1) | ?b1 = (0::?'a1)
  ?a1 / ?b1 = (1::?'a1) == ?b1 ~= (0::?'a1) & ?a1 = ?b1
  ?b1 / ?a1 = (1::?'a1) == ?a1 ~= (0::?'a1) & ?a1 = ?b1
  ?a1 / ?c1 = ?b1 / ?c1 == ?c1 = (0::?'a1) | ?a1 = ?b1
  ?c1 / ?a1 = ?c1 / ?b1 == ?c1 = (0::?'a1) | ?a1 = ?b1
  ?b1 / - numeral ?w1 = ?a1 ==
  if - numeral ?w1 ~= (0::?'a1) then ?b1 = ?a1 * - numeral ?w1
  else ?a1 = (0::?'a1)
  ?b1 / numeral ?w1 = ?a1 ==
  if numeral ?w1 ~= (0::?'a1) then ?b1 = ?a1 * numeral ?w1
  else ?a1 = (0::?'a1)
  map_option ?f1 ?opt1 = None == ?opt1 = None
  map_option ?f1 ?a1 = None == ?a1 = None
  map_option ?f1 ?xo1 = Some ?y1 == EX z. ?xo1 = Some z & ?f1 z = ?y1
  pair_box.PairBox ?x1.1 ?x2.1 = pair_box.PairBox ?y1.1 ?y2.1 ==
  ?x1.1 = ?y1.1 & ?x2.1 = ?y2.1
  ?a1 * ?b1 = (0::?'a1) == ?a1 = (0::?'a1) | ?b1 = (0::?'a1)
  ?m1 * ?n1 = 0 == ?m1 = 0 | ?n1 = 0
  ?m1 * ?n1 = 1 == ?m1 = 1 & ?n1 = 1
  ?c1 * ?a1 = ?c1 == ?c1 = (0::?'a1) | ?a1 = (1::?'a1)
  ?a1 * ?c1 = ?c1 == ?c1 = (0::?'a1) | ?a1 = (1::?'a1)
  ?m1 * ?n1 = Suc 0 == ?m1 = Suc 0 & ?n1 = Suc 0
  ?c1 * ?a1 = ?c1 * ?b1 == ?c1 = (0::?'a1) | ?a1 = ?b1
  ?a1 * ?c1 = ?b1 * ?c1 == ?c1 = (0::?'a1) | ?a1 = ?b1
  ?k1 * ?m1 = ?k1 * ?n1 == ?m1 = ?n1 | ?k1 = 0
  ?m1 * ?k1 = ?n1 * ?k1 == ?m1 = ?n1 | ?k1 = 0
  ?A1 - ?B1 = {} == ?A1 <= ?B1
  ?m1 - ?n1 = 0 == ?m1 <= ?n1
  ?a1 - ?b1 = (0::?'a1) == ?a1 = ?b1
  ?A1 // ?r1 = {} == ?A1 = {}
  typerep.Typerep ?x1.1 ?x2.1 = typerep.Typerep ?y1.1 ?y2.1 ==
  ?x1.1 = ?y1.1 & ?x2.1 = ?y2.1
  ?a1 ^ ?n1 = (0::?'a1) == ?a1 = (0::?'a1) & 0 < ?n1
  ?x1 ^ ?m1 = Suc 0 == ?m1 = 0 | ?x1 = Suc 0
  (1::?'a1) < ?a1 ==> ?a1 ^ ?m1 = ?a1 ^ ?n1 == ?m1 = ?n1
  ?a1\<^sup>2 = (0::?'a1) == ?a1 = (0::?'a1)
  [| (0::?'a1) <= ?x1; (0::?'a1) <= ?y1 |]
  ==> ?x1\<^sup>2 = ?y1\<^sup>2 == ?x1 = ?y1
  of_nat ?b1 ^ ?w1 = of_nat ?x1 == ?b1 ^ ?w1 = ?x1
  (- numeral ?x1) ^ ?n1 = of_int ?y1 == (- numeral ?x1) ^ ?n1 = ?y1
  numeral ?x1 ^ ?n1 = of_nat ?y1 == numeral ?x1 ^ ?n1 = ?y1
  numeral ?x1 ^ ?n1 = of_int ?y1 == numeral ?x1 ^ ?n1 = ?y1
  numeral ?x1 ^ ?n1 = nat ?y1 == numeral ?x1 ^ ?n1 = ?y1
  of_int ?b1 ^ ?w1 = of_int ?x1 == ?b1 ^ ?w1 = ?x1
  max ?a1 ?b1 = 0 == ?a1 = 0 & ?b1 = 0
  ?A1 Un ?B1 = {} == ?A1 = {} & ?B1 = {}
  sup ?a1 ?b1 = bot == ?a1 = bot & ?b1 = bot
  ?A1 Int ?B1 = UNIV == ?A1 = UNIV & ?B1 = UNIV
  inf ?a1 ?b1 = top == ?a1 = top & ?b1 = top
  ?B1 Int insert ?a1 ?A1 = {} == ?a1 ~: ?B1 & ?B1 Int ?A1 = {}
  insert ?a1 ?A1 Int ?B1 = {} == ?a1 ~: ?B1 & ?A1 Int ?B1 = {}
  ?m1 + ?n1 = 0 == ?m1 = 0 & ?n1 = 0
  ?x1 + ?y1 = (0::?'a1) == ?x1 = (0::?'a1) & ?y1 = (0::?'a1)
  ?a1 + ?a1 = (0::?'a1) == ?a1 = (0::?'a1)
  ?b1 + ?a1 = ?a1 == ?b1 = (0::?'a1)
  ?a1 + ?b1 = ?a1 == ?b1 = (0::?'a1)
  ?b1 + ?a1 = ?c1 + ?a1 == ?b1 = ?c1
  ?a1 + ?b1 = ?a1 + ?c1 == ?b1 = ?c1
  seq.Insert ?x21.1 ?x22.1 = seq.Empty == False
  seq.Insert ?x21.1 ?x22.1 = seq.Insert ?y21.1 ?y22.1 ==
  ?x21.1 = ?y21.1 & ?x22.1 = ?y22.1
  seq.Insert ?x21.1 ?x22.1 = seq.Join ?x31.1 ?x32.1 == False
  apsnd ?f1 ?x1 = apsnd ?g1 ?x1 == ?f1 (snd ?x1) = ?g1 (snd ?x1)
  apfst ?f1 ?x1 = apfst ?g1 ?x1 == ?f1 (fst ?x1) = ?g1 (fst ?x1)
  ?A1 \<times> ?B1 = {} == ?A1 = {} | ?B1 = {}
  seq.Join ?x31.1 ?x32.1 = seq.Empty == False
  seq.Join ?x31.1 ?x32.1 = seq.Insert ?x21.1 ?x22.1 == False
  seq.Join ?x31.1 ?x32.1 = seq.Join ?y31.1 ?y32.1 ==
  ?x31.1 = ?y31.1 & ?x32.1 = ?y32.1
  (?x1.1, ?x2.1) = (?y1.1, ?y2.1) == ?x1.1 = ?y1.1 & ?x2.1 = ?y2.1
  lcm ?m1 ?n1 = 0 == ?m1 = 0 | ?n1 = 0
  lcm ?m1 ?n1 = 0 == ?m1 = 0 | ?n1 = 0
  lcm ?m1 ?n1 = 1 == (?m1 = 1 | ?m1 = - 1) & (?n1 = 1 | ?n1 = - 1)
  lcm ?a1 ?b1 = (1::?'a1) == is_unit ?a1 & is_unit ?b1
  lcm ?m1 ?n1 = ?n1 == ?m1 dvd ?n1
  lcm ?m1 ?n1 = ?m1 == ?n1 dvd ?m1
  lcm ?m1 ?n1 = \<bar>?n1\<bar> == ?m1 dvd ?n1
  lcm ?m1 ?n1 = \<bar>?m1\<bar> == ?n1 dvd ?m1
  lcm ?m1 ?n1 = Suc 0 == ?m1 = Suc 0 & ?n1 = Suc 0
  gcd ?a1 ?b1 = 0 == ?a1 = 0 & ?b1 = 0
  gcd ?a1 ?b1 = (0::?'a1) == ?a1 = (0::?'a1) & ?b1 = (0::?'a1)
  ?n1 choose ?k1 = 0 == ?n1 < ?k1
  takeWhile ?P1 ?xs1 = ?xs1 == ALL x:set ?xs1. ?P1 x
  replicate ?n1 ?x1 = [] == ?n1 = 0
  replicate ?m1 ?x1 = replicate ?n1 ?y1 ==
  ?m1 = ?n1 & (?m1 ~= 0 --> ?x1 = ?y1)
  [?x1] = rev ?xs1 == [?x1] = ?xs1
  ?x21.1 # ?x22.1 = [] == False
  ?x1 # ?xs1 = ?xs1 == False
  ?x21.1 # ?x22.1 = ?y21.1 # ?y22.1 == ?x21.1 = ?y21.1 & ?x22.1 = ?y22.1
  dropWhile ?P1 ?xs1 = [] == ALL x:set ?xs1. ?P1 x
  ?A1 <+> ?B1 = {} == ?A1 = {} & ?B1 = {}
  map ?f1 ?xs1 = [] == ?xs1 = []
  map ?f1 ?a1 = [] == ?a1 = []
  inj ?f1 ==> map ?f1 ?xs1 = map ?f1 ?ys1 == ?xs1 = ?ys1
  map ?f1 ?xs1 = map ?g1 ?xs1 == ALL x:set ?xs1. ?f1 x = ?g1 x
  ?x1 powi ?n1 = (0::?'a1) == ?x1 = (0::?'a1) & ?n1 ~= 0
  ?f1 ++ ?g1 = Map.empty == ?f1 = Map.empty & ?g1 = Map.empty
  splice ?xs1 ?ys1 = [] == ?xs1 = [] & ?ys1 = []
  rotate ?n1 ?xs1 = [] == ?xs1 = []
  ?xs1 @ ?ys1 = [] == ?xs1 = [] & ?ys1 = []
  ?xs1 @ ?ys1 = ?ys1 == ?xs1 = []
  ?xs1 @ ?ys1 = ?xs1 == ?ys1 = []
  ?ys1 @ ?xs1 = ?zs1 @ ?xs1 == ?ys1 = ?zs1
  ?xs1 @ ?ys1 = ?xs1 @ ?zs1 == ?ys1 = ?zs1
  length ?xs1 = length ?ys1 | length ?us1 = length ?vs1 ==>
  ?xs1 @ ?us1 = ?ys1 @ ?vs1 == ?xs1 = ?ys1 & ?us1 = ?vs1
  ?xs1 @ [?x1] = ?ys1 @ [?y1] == ?xs1 = ?ys1 & ?x1 = ?y1
  {?b1} = insert ?a1 ?A1 == ?a1 = ?b1 & ?A1 <= {?b1}
  insert ?a1 ?A1 = {} == False
  insert ?a1 ?A1 = {?b1} == ?a1 = ?b1 & ?A1 <= {?b1}
  distinct (map fst ?xys1) ==>
  map_of ?xys1 ?x1 = Some ?y1 == (?x1, ?y1) : set ?xys1
  [| distinct (map fst ?xys3); (?x3, ?y3) : set ?xys3 |]
  ==> map_of ?xys3 ?x3 = Some ?y3 == True
  length ?xs1 = length ?ys1 ==>
  map_of (zip ?xs1 ?ys1) ?x1 = None == ?x1 ~: set ?xs1
  ?f1 ` ?A1 = {} == ?A1 = {}
  [?i1..?j1] = [] == ?j1 < ?i1
  take ?n1 ?xs1 = [] == ?n1 = 0 | ?xs1 = []
  take ?n1 ?xs1 = ?xs1 == length ?xs1 <= ?n1
  drop ?n1 ?xs1 = [] == length ?xs1 <= ?n1
  zip ?xs1 ?ys1 = [] == ?xs1 = [] | ?ys1 = []
  [?i1..<?j1] = [] == ?j1 = 0 | ?j1 <= ?i1
  Existential ?x21.1 ?x22.1 ?x23.1 = Property ?x3.1 == False
  Existential ?x21.1 ?x22.1 ?x23.1 = Existential ?y21.1 ?y22.1 ?y23.1 ==
  ?x21.1 = ?y21.1 & ?x22.1 = ?y22.1 & ?x23.1 = ?y23.1
  Existential ?x21.1 ?x22.1 ?x23.1 = Universal ?x11.1 ?x12.1 ?x13.1 == False
  Universal ?x11.1 ?x12.1 ?x13.1 = Property ?x3.1 == False
  Universal ?x11.1 ?x12.1 ?x13.1 = Existential ?x21.1 ?x22.1 ?x23.1 == False
  Universal ?x11.1 ?x12.1 ?x13.1 = Universal ?y11.1 ?y12.1 ?y13.1 ==
  ?x11.1 = ?y11.1 & ?x12.1 = ?y12.1 & ?x13.1 = ?y13.1
  ffun.Update ?x21.1 ?x22.1 ?x23.1 = ffun.Constant ?x1.1 == False
  ffun.Update ?x21.1 ?x22.1 ?x23.1 = ffun.Update ?y21.1 ?y22.1 ?y23.1 ==
  ?x21.1 = ?y21.1 & ?x22.1 = ?y22.1 & ?x23.1 = ?y23.1
  insort_key ?f1 ?a1 ?xs1 = [] == False
  ?xs1[?k1 := ?x1] = [] == ?xs1 = []
  ?m2.3 ?k3 = Some ?k'3 ==>
  (?m1.3 \<circ>\<^sub>m ?m2.3) ?k3 = ?m1.3 ?k'3 == True
  (?m1 ++ ?n1) ?k1 = None == ?n1 ?k1 = None & ?m1 ?k1 = None
  ?n3 ?k3 = Some ?xx3 ==> (?m3 ++ ?n3) ?k3 = Some ?xx3 == True
  ?t1(?k1 |-> ?x1) = Map.empty == False
  Char ?x1.1 ?x2.1 ?x3.1 ?x4.1 ?x5.1 ?x6.1 ?x7.1 ?x8.1 =
  Char ?y1.1 ?y2.1 ?y3.1 ?y4.1 ?y5.1 ?y6.1 ?y7.1 ?y8.1 ==
  ?x1.1 = ?y1.1 &
  ?x2.1 = ?y2.1 &
  ?x3.1 = ?y3.1 &
  ?x4.1 = ?y4.1 &
  ?x5.1 = ?y5.1 & ?x6.1 = ?y6.1 & ?x7.1 = ?y7.1 & ?x8.1 = ?y8.1
  String.Literal ?b0.1 ?b1.1 ?b2.1 ?b3.1 ?b4.1 ?b5.1 ?b6.1 ?s1 = STR '''' ==
  False
  String.Literal ?b0.1 ?b1.1 ?b2.1 ?b3.1 ?b4.1 ?b5.1 ?b6.1 ?s1 =
  String.Literal ?c0.1 ?c1.1 ?c2.1 ?c3.1 ?c4.1 ?c5.1 ?c6.1 ?t1 ==
  ?b0.1 = ?c0.1 &
  ?b1.1 = ?c1.1 &
  ?b2.1 = ?c2.1 &
  ?b3.1 = ?c3.1 & ?b4.1 = ?c4.1 & ?b5.1 = ?c5.1 & ?b6.1 = ?c6.1 & ?s1 = ?t1
  case narrowing_term.Narrowing_constructor ?x21.1 ?x22.1 of
  narrowing_term.Narrowing_variable x xa => ?f1.1 x xa
  | narrowing_term.Narrowing_constructor x xa => ?f2.1 x xa ==
  ?f2.1 ?x21.1 ?x22.1
  case narrowing_term.Narrowing_variable ?x11.1 ?x12.1 of
  narrowing_term.Narrowing_variable x xa => ?f1.1 x xa
  | narrowing_term.Narrowing_constructor x xa => ?f2.1 x xa ==
  ?f1.1 ?x11.1 ?x12.1
  rec_narrowing_term ?f1.1 ?f2.1
   (narrowing_term.Narrowing_constructor ?x21.1 ?x22.1) ==
  ?f2.1 ?x21.1
   (map (%narrowing_term.
            (narrowing_term, rec_narrowing_term ?f1.1 ?f2.1 narrowing_term))
     ?x22.1)
  rec_narrowing_term ?f1.1 ?f2.1
   (narrowing_term.Narrowing_variable ?x11.1 ?x12.1) ==
  ?f1.1 ?x11.1 ?x12.1
  Quickcheck_Exhaustive.full_exhaustive_natural' ?f1 ?d1 ?i1 ==
  if ?d1 < ?i1 then None
  else Quickcheck_Exhaustive.orelse
        (?f1 (?i1, %_. term_of_class.term_of ?i1))
        (Quickcheck_Exhaustive.full_exhaustive_natural' ?f1 ?d1 (?i1 + 1))
  Quickcheck_Exhaustive.full_exhaustive_integer' ?f1 ?d1 ?i1 ==
  if ?d1 < ?i1 then None
  else case ?f1 (?i1, %_. term_of_class.term_of ?i1) of
       None =>
         Quickcheck_Exhaustive.full_exhaustive_integer' ?f1 ?d1 (?i1 + 1)
       | Some x => Some x
  horner_sum ?f1 ?a1 [] == 0::?'a1
  horner_sum ?f1 ?a1 (?x1 # ?xs1) == ?f1 ?x1 + ?a1 * horner_sum ?f1 ?a1 ?xs1
  case unknown.Unknown of unknown.Unknown => ?y
  | unknown.Known x => ?f2.1 x ==
  ?y
  case unknown.Known ?x2.1 of unknown.Unknown => ?f1.1
  | unknown.Known x => ?f2.1 x ==
  ?f2.1 ?x2.1
  Quickcheck_Exhaustive.full_exhaustive_int' ?f1 ?d1 ?i1 ==
  if ?d1 < ?i1 then None
  else case ?f1 (?i1, %_. term_of_class.term_of ?i1) of
       None => Quickcheck_Exhaustive.full_exhaustive_int' ?f1 ?d1 (?i1 + 1)
       | Some x => Some x
  full_exhaustive_fun' ?f1 ?i1 ?d1 ==
  Quickcheck_Exhaustive.orelse
   (full_exhaustive_class.full_exhaustive
     (%v. ?f1 (??.Quickcheck_Exhaustive.valtermify_absdummy v)) ?d1)
   (if 1 < ?i1
    then full_exhaustive_fun'
          (%g. full_exhaustive_class.full_exhaustive
                (%a. full_exhaustive_class.full_exhaustive
                      (%b. ?f1 (??.Quickcheck_Exhaustive.valtermify_fun_upd
                                 g a b))
                      ?d1)
                ?d1)
          (?i1 - 1) ?d1
    else None)
  rec_unknown ?y ?f2.1 unknown.Unknown == ?y
  rec_unknown ?f1.1 ?f2.1 (unknown.Known ?x2.1) == ?f2.1 ?x2.1
  Quickcheck_Exhaustive.exhaustive_natural' ?f1 ?d1 ?i1 ==
  if ?d1 < ?i1 then None
  else Quickcheck_Exhaustive.orelse (?f1 ?i1)
        (Quickcheck_Exhaustive.exhaustive_natural' ?f1 ?d1 (?i1 + 1))
  Quickcheck_Exhaustive.exhaustive_integer' ?f1 ?d1 ?i1 ==
  if ?d1 < ?i1 then None
  else Quickcheck_Exhaustive.orelse (?f1 ?i1)
        (Quickcheck_Exhaustive.exhaustive_integer' ?f1 ?d1 (?i1 + 1))
  Quickcheck_Exhaustive.exhaustive_int' ?f1 ?d1 ?i1 ==
  if ?d1 < ?i1 then None
  else Quickcheck_Exhaustive.orelse (?f1 ?i1)
        (Quickcheck_Exhaustive.exhaustive_int' ?f1 ?d1 (?i1 + 1))
  exhaustive_fun' ?f1 ?i1 ?d1 ==
  Quickcheck_Exhaustive.orelse
   (exhaustive_class.exhaustive (%b. ?f1 (%_. b)) ?d1)
   (if 1 < ?i1
    then exhaustive_fun'
          (%g. exhaustive_class.exhaustive
                (%a. exhaustive_class.exhaustive (%b. ?f1 (g(a := b))) ?d1)
                ?d1)
          (?i1 - 1) ?d1
    else None)
  random_aux_tuple_isomorphism ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, scomp (random_class.random ?j1)
           (%x. scomp (random_class.random ?j1)
                 (%y. Pair
                       (??.Code_Evaluation.valapp
                         (??.Code_Evaluation.valapp
                           (tuple_isomorphism.Tuple_Isomorphism,
                            %u. Code_Evaluation.Const
                                 STR ''Record.tuple_isomorphism.Tuple_Isomorphism''
                                 (typerep.Typerep STR ''fun''
                                   [typerep.Typerep STR ''fun''
                                     [TYPEREP(?'a1),
typerep.Typerep STR ''Product_Type.prod'' [TYPEREP(?'b1), TYPEREP(?'c1)]],
                                    typerep.Typerep STR ''fun''
                                     [typerep.Typerep STR ''fun''
 [typerep.Typerep STR ''Product_Type.prod'' [TYPEREP(?'b1), TYPEREP(?'c1)],
  TYPEREP(?'a1)],
typerep.Typerep STR ''Record.tuple_isomorphism''
 [TYPEREP(?'a1), TYPEREP(?'b1), TYPEREP(?'c1)]]]))
                           x)
                         y))))])
   ?s1
  case ffun.Constant ?x1.1 of ffun.Constant x => ?f1.1 x
  | ffun.Update x xa xb => ?f2.1 x xa xb ==
  ?f1.1 ?x1.1
  case ffun.Update ?x21.1 ?x22.1 ?x23.1 of ffun.Constant x => ?f1.1 x
  | ffun.Update x xa xb => ?f2.1 x xa xb ==
  ?f2.1 ?x21.1 ?x22.1 ?x23.1
  rec_ffun ?f1.1 ?f2.1 (ffun.Constant ?x1.1) == ?f1.1 ?x1.1
  rec_ffun ?f1.1 ?f2.1 (ffun.Update ?x21.1 ?x22.1 ?x23.1) ==
  ?f2.1 ?x21.1 ?x22.1 ?x23.1 (rec_ffun ?f1.1 ?f2.1 ?x23.1)
  case 0 of 0 => ?y | Code_Numeral.Suc x => ?f2.1 x == ?y
  case Code_Numeral.Suc ?natural1 of 0 => ?f1.1
  | Code_Numeral.Suc x => ?f2.1 x ==
  ?f2.1 ?natural1
  rec_natural ?y ?f2.1 0 == ?y
  rec_natural ?f1.1 ?f2.1 (Code_Numeral.Suc ?natural1) ==
  ?f2.1 ?natural1 (rec_natural ?f1.1 ?f2.1 ?natural1)
  semiring_1_class.of_nat_aux ?inc1 0 ?y == ?y
  semiring_1_class.of_nat_aux ?inc1 (Suc ?n1) ?i1 ==
  semiring_1_class.of_nat_aux ?inc1 ?n1 (?inc1 ?i1)
  case Right of Left => ?f1.1 | Right => ?y == ?y
  case Left of Left => ?y | Right => ?f2.1 == ?y
  old.rec_bool ?f1.1 ?y False == ?y
  old.rec_bool ?y ?f2.1 True == ?y
  insort_key ?f1 ?x1 [] == [?x1]
  insort_key ?f1 ?x1 (?y1 # ?ys1) ==
  if ?f1 ?x1 <= ?f1 ?y1 then ?x1 # ?y1 # ?ys1
  else ?y1 # insort_key ?f1 ?x1 ?ys1
  rec_sumbool ?f1.1 ?y Right == ?y
  rec_sumbool ?y ?f2.1 Left == ?y
  size_prod ?xa1 ?x1 (?x1.1, ?x2.1) == ?xa1 ?x1.1 + ?x1 ?x2.1 + Suc 0
  random_aux_unit ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, Pair
           ((),
            %u. Code_Evaluation.Const STR ''Product_Type.Unity''
                 (typerep.Typerep STR ''Product_Type.unit'' [])))])
   ?s1
  random_aux_prod ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, scomp (random_class.random ?j1)
           (%x. scomp (random_class.random ?j1)
                 (%y. Pair
                       (??.Code_Evaluation.valapp
                         (??.Code_Evaluation.valapp
                           (Pair,
                            %u. Code_Evaluation.Const
                                 STR ''Product_Type.Pair''
                                 (typerep.Typerep STR ''fun''
                                   [TYPEREP(?'a1),
                                    typerep.Typerep STR ''fun''
                                     [TYPEREP(?'b1),
typerep.Typerep STR ''Product_Type.prod'' [TYPEREP(?'a1), TYPEREP(?'b1)]]]))
                           x)
                         y))))])
   ?s1
  ?r1^** ?a1 ?a1 == True
  case False of True => ?f1.1 | False => ?y == ?y
  case True of True => ?y | False => ?f2.1 == ?y
  case a\<^sub>2 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?y == ?y
  case a\<^sub>1 of a\<^sub>1 => ?y | a\<^sub>2 => ?f2.1 == ?y
  size_sum ?xa1 ?x1 (Inr ?x2.1) == ?x1 ?x2.1 + Suc 0
  size_sum ?xa1 ?x1 (Inl ?x1.1) == ?xa1 ?x1.1 + Suc 0
  Lazy_Sequence.iterate_upto ?f1 ?n1 ?m1 ==
  Lazy_Sequence
   (%_. if ?m1 < ?n1 then None
        else Some (?f1 ?n1, Lazy_Sequence.iterate_upto ?f1 (?n1 + 1) ?m1))
  rec_finite_2 ?f1.1 ?y a\<^sub>2 == ?y
  rec_finite_2 ?y ?f2.1 a\<^sub>1 == ?y
  ?r1 ?y1 ?x1 ==> symclp ?r1 ?x1 ?y1 == True
  ?r1 ?x1 ?y1 ==> symclp ?r1 ?x1 ?y1 == True
  case None of None => ?y | Some x => ?f2.1 x == ?y
  case Lazy_Sequence.yield ?xq1 of None => ?g1 | Some x => ?h1 x ==
  case list_of_lazy_sequence ?xq1 of [] => ?g1
  | x # xa => (curry ?h1 x o lazy_sequence_of_list) xa
  case Some ?x2.1 of None => ?f1.1 | Some x => ?f2.1 x == ?f2.1 ?x2.1
  case map_option ?f1 ?x1 of None => ?g1 | Some x => ?h1 x ==
  case ?x1 of None => ?g1 | Some x => (?h1 o ?f1) x
  concat_bit 0 ?k1 ?y == ?y
  concat_bit ?n1 0 ?l1 == push_bit ?n1 ?l1
  concat_bit ?n1 ?k1 0 == take_bit ?n1 ?k1
  old.rec_sum ?f1.1 ?f2.1 (Inr ?b1) == ?f2.1 ?b1
  old.rec_sum ?f1.1 ?f2.1 (Inl ?a1) == ?f1.1 ?a1
  random_aux_option ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, Pair
           (None,
            %u. Code_Evaluation.Const STR ''Option.option.None''
                 (typerep.Typerep STR ''Option.option'' [TYPEREP(?'a1)]))),
      (1, scomp (random_class.random ?j1)
           (%x. Pair
                 (??.Code_Evaluation.valapp
                   (Some,
                    %u. Code_Evaluation.Const STR ''Option.option.Some''
                         (typerep.Typerep STR ''fun''
                           [TYPEREP(?'a1),
                            typerep.Typerep STR ''Option.option''
                             [TYPEREP(?'a1)]]))
                   x)))])
   ?s1
  rel_option ?R1 None None == True
  rel_option ?P1 None ?x1 == ?x1 = None
  rel_option ?R1 None (Some ?y2.1) == False
  rel_option ?P1 ?x1 None == ?x1 = None
  rel_option ?R1 (Some ?y2.1) None == False
  rel_option ?R1 (Some ?x2.1) (Some ?y2.1) == ?R1 ?x2.1 ?y2.1
  rec_option ?y ?f2.1 None == ?y
  rec_option ?f1.1 ?f2.1 (Some ?x2.1) == ?f2.1 ?x2.1
  (?A1 - ?B1) ?x1 == ?A1 ?x1 - ?B1 ?x1
  equivclp ?r1 ?x1 ?x1 == True
  random_aux_finite_5 ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, Pair
           (a\<^sub>1,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>1''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_5'' []))),
      (1, Pair
           (a\<^sub>2,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>2''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_5'' []))),
      (1, Pair
           (a\<^sub>3,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>3''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_5'' []))),
      (1, Pair
           (a\<^sub>4,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>4''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_5'' []))),
      (1, Pair
           (a\<^sub>5,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>5''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_5'' [])))])
   ?s1
  random_aux_finite_4 ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, Pair
           (a\<^sub>1,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal False False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>1''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_4'' []))),
      (1, Pair
           (a\<^sub>2,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal False False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>2''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_4'' []))),
      (1, Pair
           (a\<^sub>3,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal False False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>3''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_4'' []))),
      (1, Pair
           (a\<^sub>4,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal False False True False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>4''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_4'' [])))])
   ?s1
  random_aux_finite_3 ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, Pair
           (a\<^sub>1,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True True False False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>1''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_3'' []))),
      (1, Pair
           (a\<^sub>2,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True True False False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>2''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_3'' []))),
      (1, Pair
           (a\<^sub>3,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True True False False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>3''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_3'' [])))])
   ?s1
  random_aux_finite_2 ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, Pair
           (a\<^sub>1,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal False True False False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>1''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_2'' []))),
      (1, Pair
           (a\<^sub>2,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal False True False False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>2''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_2'' [])))])
   ?s1
  random_aux_finite_1 ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, Pair
           (a\<^sub>1,
            %u. Code_Evaluation.Const
                 (String.Literal True False True False False False True
                   (String.Literal False True True True False True True
                     (String.Literal True False True False True True True
                       (String.Literal True False True True False True True
                         (String.Literal False True True True False True
                           False
                           (String.Literal False True True False False True
                             True
                             (String.Literal True False False True False
                               True True
                               (String.Literal False True True True False
                                 True True
                                 (String.Literal True False False True False
                                   True True
                                   (String.Literal False False True False
                                     True True True
                                     (String.Literal True False True False
 False True True
 (String.Literal True True True True True False True
   (String.Literal True False False False True True False
     (String.Literal False True True True False True False
       (String.Literal True False False False False True True
         (String.Literal False False True True True False True
           STR ''<^sub>1''))))))))))))))))
                 (typerep.Typerep STR ''Enum.finite_1'' [])))])
   ?s1
  random_aux_sum ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(1, scomp (random_class.random ?j1)
           (%x. Pair
                 (??.Code_Evaluation.valapp
                   (Inl,
                    %u. Code_Evaluation.Const STR ''Sum_Type.Inl''
                         (typerep.Typerep STR ''fun''
                           [TYPEREP(?'a1),
                            typerep.Typerep STR ''Sum_Type.sum''
                             [TYPEREP(?'a1), TYPEREP(?'b1)]]))
                   x))),
      (1, scomp (random_class.random ?j1)
           (%x. Pair
                 (??.Code_Evaluation.valapp
                   (Inr,
                    %u. Code_Evaluation.Const STR ''Sum_Type.Inr''
                         (typerep.Typerep STR ''fun''
                           [TYPEREP(?'b1),
                            typerep.Typerep STR ''Sum_Type.sum''
                             [TYPEREP(?'a1), TYPEREP(?'b1)]]))
                   x)))])
   ?s1
  [| inj_on ?f1 ?A1; ?y : ?A1 |] ==> inv_into ?A1 ?f1 (?f1 ?y) == ?y
  Predicate.iterate_upto ?f1 ?n1 ?m1 ==
  Predicate.Seq
   (%u. if ?m1 < ?n1 then seq.Empty
        else seq.Insert (?f1 ?n1)
              (Predicate.iterate_upto ?f1 (?n1 + 1) ?m1))
  combine_options ?f1 None ?y == ?y
  combine_options ?f1 ?y None == ?y
  combine_options ?f1 (Some ?a1) (Some ?b1) == Some (?f1 ?a1 ?b1)
  sup ?f1 ?g1 ?x1 == sup (?f1 ?x1) (?g1 ?x1)
  inf ?f1 ?g1 ?x1 == inf (?f1 ?x1) (?g1 ?x1)
  case Inr ?x2.1 of Inl x => ?f1.1 x | Inr x => ?f2.1 x == ?f2.1 ?x2.1
  case Inl ?x1.1 of Inl x => ?f1.1 x | Inr x => ?f2.1 x == ?f1.1 ?x1.1
  map_prod ?f1 ?g1 (?a1, ?b1) == (?f1 ?a1, ?g1 ?b1)
  Limited_Sequence.eval ?f1 ?i1 ?pol1 == ?f1 ?i1 ?pol1
  Random_Sequence.iter ?random1 ?nrandom1 ?seed1 ==
  if ?nrandom1 = 0 then Lazy_Sequence.empty
  else Lazy_Sequence
        (%u. let ((x, uu_), seed') = ?random1 ?seed1
             in Some
                 (x, Random_Sequence.iter ?random1 (?nrandom1 - 1) seed'))
  random_aux_list ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(?i1,
       scomp (random_class.random ?j1)
        (%x. scomp (random_aux_list (?i1 - 1) ?j1)
              (%y. Pair
                    (??.Code_Evaluation.valapp
                      (??.Code_Evaluation.valapp
                        ((#),
                         %u. Code_Evaluation.Const STR ''List.list.Cons''
                              (typerep.Typerep STR ''fun''
                                [TYPEREP(?'a1),
                                 typerep.Typerep STR ''fun''
                                  [typerep.Typerep STR ''List.list''
                                    [TYPEREP(?'a1)],
                                   typerep.Typerep STR ''List.list''
                                    [TYPEREP(?'a1)]]]))
                        x)
                      y)))),
      (1, Pair
           ([],
            %u. Code_Evaluation.Const STR ''List.list.Nil''
                 (typerep.Typerep STR ''List.list'' [TYPEREP(?'a1)])))])
   ?s1
  map_tailrec_rev ?f1 [] ?y == ?y
  map_tailrec_rev ?f1 (?a1 # ?as1) ?bs1 ==
  map_tailrec_rev ?f1 ?as1 (?f1 ?a1 # ?bs1)
  pred_prod ?P1.1 ?P2.1 (?a1, ?b1) == ?P1.1 ?a1 & ?P2.1 ?b1
  rec_nat ?y ?f2.1 0 == ?y
  rec_nat ?a1 ?f1 (numeral ?v1) ==
  let pv = pred_numeral ?v1 in ?f1 pv (rec_nat ?a1 ?f1 pv)
  rec_nat ?f1.1 ?f2.1 (Suc ?nat1) == ?f2.1 ?nat1 (rec_nat ?f1.1 ?f2.1 ?nat1)
  rec_nat ?a1 ?f1 (numeral ?v1 + ?n1) ==
  let pv = pred_numeral ?v1 in ?f1 (pv + ?n1) (rec_nat ?a1 ?f1 (pv + ?n1))
  ord.lexordp_eq ?less1 [] ?ys1 == True
  ord.lexordp_eq ?less1 ?xs1 [] == ?xs1 = []
  ord.lexordp_eq ?less1 (?x1 # ?xs1) [] == False
  ord.lexordp_eq ?less1 (?x1 # ?xs1) (?y1 # ?ys1) ==
  ?less1 ?x1 ?y1 | ~ ?less1 ?y1 ?x1 & ord.lexordp_eq ?less1 ?xs1 ?ys1
  list_all2 ?R1 [] [] == True
  list_all2 ?P1 [] ?ys1 == ?ys1 = []
  list_all2 ?R1 [] (?y21.1 # ?y22.1) == False
  list_all2 ?P1 ?xs1 [] == ?xs1 = []
  list_all2 ?P1 (rev ?xs1) (rev ?ys1) == list_all2 ?P1 ?xs1 ?ys1
  list_all2 ?R1 (?y21.1 # ?y22.1) [] == False
  list_all2 ?P1 (?x1 # ?xs1) (?y1 # ?ys1) ==
  ?P1 ?x1 ?y1 & list_all2 ?P1 ?xs1 ?ys1
  list_all2 ?R1 (?x21.1 # ?x22.1) (?y21.1 # ?y22.1) ==
  ?R1 ?x21.1 ?y21.1 & list_all2 ?R1 ?x22.1 ?y22.1
  list_all2 ?P1 ?xs1 ?ys1 ==>
  list_all2 ?P1 (take ?n1 ?xs1) (take ?n1 ?ys1) == True
  list_all2 ?P1 ?xs1 ?ys1 ==>
  list_all2 ?P1 (drop ?n1 ?xs1) (drop ?n1 ?ys1) == True
  case [] of [] => ?y | x # xa => ?f2.1 x xa == ?y
  case ?x21.1 # ?x22.1 of [] => ?f1.1 | x # xa => ?f2.1 x xa ==
  ?f2.1 ?x21.1 ?x22.1
  pred_sum ?P1.1 ?P2.1 (Inr ?b1) == ?P2.1 ?b1
  pred_sum ?P1.1 ?P2.1 (Inl ?a1) == ?P1.1 ?a1
  subset.chain ?A1 {} == True
  ?r1^--1 ?a1 ?b1 == ?r1 ?b1 ?a1
  scomp ?f1 ?g1 ?x1 == case ?f1 ?x1 of (x, xa) => ?g1 x xa
  curry ?f1 ?a1 ?b1 == ?f1 (?a1, ?b1)
  random_aux_num ?i1 ?j1 ?s1 ==
  Quickcheck_Random.collapse
   (Random.select_weight
     [(?i1,
       scomp (random_aux_num (?i1 - 1) ?j1)
        (%x. Pair
              (??.Code_Evaluation.valapp
                (num.Bit0,
                 %u. Code_Evaluation.Const STR ''Num.num.Bit0''
                      (typerep.Typerep STR ''fun''
                        [typerep.Typerep STR ''Num.num'' [],
                         typerep.Typerep STR ''Num.num'' []]))
                x))),
      (?i1,
       scomp (random_aux_num (?i1 - 1) ?j1)
        (%x. Pair
              (??.Code_Evaluation.valapp
                (num.Bit1,
                 %u. Code_Evaluation.Const STR ''Num.num.Bit1''
                      (typerep.Typerep STR ''fun''
                        [typerep.Typerep STR ''Num.num'' [],
                         typerep.Typerep STR ''Num.num'' []]))
                x))),
      (1, Pair
           (num.One,
            %u. Code_Evaluation.Const STR ''Num.num.One''
                 (typerep.Typerep STR ''Num.num'' [])))])
   ?s1
  rec_list ?y ?f2.1 [] == ?y
  rec_list ?f1.1 ?f2.1 (?x21.1 # ?x22.1) ==
  ?f2.1 ?x21.1 ?x22.1 (rec_list ?f1.1 ?f2.1 ?x22.1)
  subset.maxchain ?A1 ?y ==> subset.suc ?A1 ?y == ?y
  ~ subset.chain ?A1 ?y ==> subset.suc ?A1 ?y == ?y
  map_sum ?f1.1 ?f2.1 (Inr ?a1) == Inr (?f2.1 ?a1)
  map_sum ?f1.1 ?f2.1 (Inl ?a1) == Inl (?f1.1 ?a1)
  case 0 of 0 => ?y | Suc x => ?f2.1 x == ?y
  case numeral ?v1 of 0 => ?a1 | Suc x => ?f1 x ==
  Let (pred_numeral ?v1) ?f1
  case Suc ?x2.1 of 0 => ?f1.1 | Suc x => ?f2.1 x == ?f2.1 ?x2.1
  case numeral ?v1 + ?n1 of 0 => ?a1 | Suc x => ?f1 x ==
  let pv = pred_numeral ?v1 in ?f1 (pv + ?n1)
  ?x1 : ?A1 ==> (?m1 |` ?A1) ?x1 == ?m1 ?x1
  ?x1 ~: ?A1 ==> (?m1 |` ?A1) ?x1 == None
  ord.lexordp ?less1 [] ?ys1 == ?ys1 ~= []
  ord.lexordp ?less1 ?xs1 [] == False
  ord.lexordp ?less1 (?x1 # ?xs1) (?y1 # ?ys1) ==
  ?less1 ?x1 ?y1 | ~ ?less1 ?y1 ?x1 & ord.lexordp ?less1 ?xs1 ?ys1
  [][?i1 := ?v1] == []
  length ?y <= ?i1 ==> ?y[?i1 := ?x1] == ?y
  ?y[?i1 := ?y ! ?i1] == ?y
  (?x1 # ?xs1)[?i1 := ?v1] ==
  case ?i1 of 0 => ?v1 # ?xs1 | Suc j => ?x1 # ?xs1[j := ?v1]
  (?xs1 @ ?x1 # ?ys1)[length ?xs1 := ?y1] == ?xs1 @ ?y1 # ?ys1
  ?xs1[?i1 := ?x1, ?i1 := ?y1] == ?xs1[?i1 := ?y1]
  filterlim ?f1 top ?F1 == True
  override_on ?y ?g1 {} == ?y
  Finite_Set.fold ?f1 ?y {} == ?y
  infinite ?A1 ==> Finite_Set.fold ?f1 ?y ?A1 == ?y
  Random.iterate ?k1 ?f1 ?x1 ==
  if ?k1 = 0 then Pair ?x1
  else scomp (?f1 ?x1) (Random.iterate (?k1 - 1) ?f1)
  in_rel ?R ?x ?y == (?x, ?y) : ?R
  ?y([] [|->] ?bs1) == ?y
  ?y(?as1 [|->] []) == ?y
  length ?xs1 = length ?ys1 ==>
  ?m1(?xs1 [|->] ?ys1 @ ?zs1) == ?m1(?xs1 [|->] ?ys1)
  length ?xs1 <= ?i1 ==>
  ?m1(?xs1 [|->] ?ys1[?i1 := ?y1]) == ?m1(?xs1 [|->] ?ys1)
  ?m1(?a1 # ?as1 [|->] ?b1 # ?bs1) == ?m1(?a1 |-> ?b1, ?as1 [|->] ?bs1)
  length ?xs1 = length ?ys1 ==>
  ?m1(?xs1 @ ?zs1 [|->] ?ys1) == ?m1(?xs1 [|->] ?ys1)
  length ?xs1 < length ?ys1 ==>
  ?m1(?xs1 @ [?x1] [|->] ?ys1) == ?m1(?xs1 [|->] ?ys1, ?x1 |->
  ?ys1 ! length ?xs1)
  ?a1 ~: set ?as1 ==>
  ?m1(?a1 |-> ?b1, ?as1 [|->] ?bs1) == ?m1(?as1 [|->] ?bs1, ?a1 |-> ?b1)
  ?m2.1 ?k1 = None ==> (?m1.1 \<circ>\<^sub>m ?m2.1) ?k1 == None
  ?m2.1 ?k1 = Some ?k'1 ==> (?m1.1 \<circ>\<^sub>m ?m2.1) ?k1 == ?m1.1 ?k'1
  bij_betw of_nat ?N1 ?A1 == of_nat ` ?N1 = ?A1
  bij prod.swap == True
  bij_betw Suc ?M1 ?N1 == Suc ` ?M1 = ?N1
  bij id == True
  bij_betw id ?A1 ?A1 == True
  bij_betw ((+) ?a1) ?A1 ?B1 == (+) ?a1 ` ?A1 = ?B1
  bij ?f1 ==> bij (?f1 ^^ ?n1) == True
  ?n1 ?k1 = Some ?xx1 ==> (?m1 ++ ?n1) ?k1 == Some ?xx1
  Map.empty(?x1 := None) == Map.empty
  ?k1 ~: dom ?y ==> ?y(?k1 := None) == ?y
  ?y(?x1 := ?y ?x1) == ?y
  (?m1 |` ?D1)(?x1 := None) ==
  if ?x1 : ?D1 then ?m1 |` (?D1 - {?x1}) else ?m1 |` ?D1
  ?x1 : ?D1 ==>
  (?m1 |` ?D1)(?x1 := ?y1) == (?m1 |` (?D1 - {?x1}))(?x1 := ?y1)
  ?f1(?x1 := ?y1, ?x1 := ?z1) == ?f1(?x1 := ?z1)
  (?f1 ^^ 0) ?y == ?y
  foldr ?f1 (?xs1 @ ?ys1) ?a1 == foldr ?f1 ?xs1 (foldr ?f1 ?ys1 ?a1)
  foldl ?f1 ?y [] == ?y
  foldl ?f1 ?a1 (?x1 # ?xs1) == foldl ?f1 (?f1 ?a1 ?x1) ?xs1
  foldl ?f1 ?a1 (?xs1 @ ?ys1) == foldl ?f1 (foldl ?f1 ?a1 ?xs1) ?ys1
  fcomp ?f1 ?g1 ?x1 == ?g1 (?f1 ?x1)
  (?f1 o ?g1) ?x1 == ?f1 (?g1 ?x1)
  if False then ?x1 else ?y == ?y
  if True then ?y else ?y1 == ?y
  if ?c1 then ?y else ?y == ?y
  if ?y = ?y1 then ?y1 else ?y == ?y
  case three_valued.Unknown_value of three_valued.Unknown_value => ?y
  | three_valued.Value x => ?f2.1 x | three_valued.No_value => ?f3.1 ==
  ?y
  case three_valued.No_value of three_valued.Unknown_value => ?f1.1
  | three_valued.Value x => ?f2.1 x | three_valued.No_value => ?y ==
  ?y
  case three_valued.Value ?x2.1 of three_valued.Unknown_value => ?f1.1
  | three_valued.Value x => ?f2.1 x | three_valued.No_value => ?f3.1 ==
  ?f2.1 ?x2.1
  rec_three_valued ?y ?f2.1 ?f3.1 three_valued.Unknown_value == ?y
  rec_three_valued ?f1.1 ?f2.1 ?y three_valued.No_value == ?y
  rec_three_valued ?f1.1 ?f2.1 ?f3.1 (three_valued.Value ?x2.1) ==
  ?f2.1 ?x2.1
  size_tuple_isomorphism ?xb1 ?xa1 ?x1
   (tuple_isomorphism.Tuple_Isomorphism ?x1.1 ?x2.1) ==
  Suc 0
  case Property ?x3.1 of Universal x xa xb => ?f1.1 x xa xb
  | Existential x xa xb => ?f2.1 x xa xb | Property x => ?f3.1 x ==
  ?f3.1 ?x3.1
  case Existential ?x21.1 ?x22.1 ?x23.1 of
  Universal x xa xb => ?f1.1 x xa xb | Existential x xa xb => ?f2.1 x xa xb
  | Property x => ?f3.1 x ==
  ?f2.1 ?x21.1 ?x22.1 ?x23.1
  case Universal ?x11.1 ?x12.1 ?x13.1 of Universal x xa xb => ?f1.1 x xa xb
  | Existential x xa xb => ?f2.1 x xa xb | Property x => ?f3.1 x ==
  ?f1.1 ?x11.1 ?x12.1 ?x13.1
  rec_property ?f1.1 ?f2.1 ?f3.1 (Property ?x3.1) == ?f3.1 ?x3.1
  rec_property ?f1.1 ?f2.1 ?f3.1 (Existential ?x21.1 ?x22.1 ?x23.1) ==
  ?f2.1 ?x21.1
   ((%property. (property, rec_property ?f1.1 ?f2.1 ?f3.1 property)) o
    ?x22.1)
   ?x23.1
  rec_property ?f1.1 ?f2.1 ?f3.1 (Universal ?x11.1 ?x12.1 ?x13.1) ==
  ?f1.1 ?x11.1
   ((%property. (property, rec_property ?f1.1 ?f2.1 ?f3.1 property)) o
    ?x12.1)
   ?x13.1
  case a\<^sub>3 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?y ==
  ?y
  case a\<^sub>2 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?y
  | a\<^sub>3 => ?f3.1 ==
  ?y
  case a\<^sub>1 of a\<^sub>1 => ?y | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?f3.1 ==
  ?y
  rec_finite_3 ?f1.1 ?f2.1 ?y a\<^sub>3 == ?y
  rec_finite_3 ?f1.1 ?y ?f3.1 a\<^sub>2 == ?y
  rec_finite_3 ?y ?f2.1 ?f3.1 a\<^sub>1 == ?y
  case seq.Empty of seq.Empty => ?y | seq.Insert x xa => ?f2.1 x xa
  | seq.Join x xa => ?f3.1 x xa ==
  ?y
  case seq.Insert ?x21.1 ?x22.1 of seq.Empty => ?f1.1
  | seq.Insert x xa => ?f2.1 x xa | seq.Join x xa => ?f3.1 x xa ==
  ?f2.1 ?x21.1 ?x22.1
  case seq.Join ?x31.1 ?x32.1 of seq.Empty => ?f1.1
  | seq.Insert x xa => ?f2.1 x xa | seq.Join x xa => ?f3.1 x xa ==
  ?f3.1 ?x31.1 ?x32.1
  rec_seq ?y ?f2.1 ?f3.1 seq.Empty == ?y
  rec_seq ?f1.1 ?f2.1 ?f3.1 (seq.Insert ?x21.1 ?x22.1) ==
  ?f2.1 ?x21.1 ?x22.1
  rec_seq ?f1.1 ?f2.1 ?f3.1 (seq.Join ?x31.1 ?x32.1) ==
  ?f3.1 ?x31.1 ?x32.1 (rec_seq ?f1.1 ?f2.1 ?f3.1 ?x32.1)
  inv_imagep ?r1 ?f1 ?x1 ?y1 == ?r1 (?f1 ?x1) (?f1 ?y1)
  rel_prod ?R1.1 ?R2.1 (?a1, ?b1) (?c1, ?d1) ==
  ?R1.1 ?a1 ?c1 & ?R2.1 ?b1 ?d1
  Random_Pred.iter' ?T1 ?nrandom1 ?sz1 ?seed1 ==
  if ?nrandom1 = 0 then bot
  else let ((x, uu_), seed') = random_class.random ?sz1 ?seed1
       in Predicate.Seq
           (%u. seq.Insert x
                 (Random_Pred.iter' ?T1 (?nrandom1 - 1) ?sz1 seed'))
  case num.One of num.One => ?y | num.Bit0 x => ?f2.1 x
  | num.Bit1 x => ?f3.1 x ==
  ?y
  case num.Bit1 ?x3.1 of num.One => ?f1.1 | num.Bit0 x => ?f2.1 x
  | num.Bit1 x => ?f3.1 x ==
  ?f3.1 ?x3.1
  case num.Bit0 ?x2.1 of num.One => ?f1.1 | num.Bit0 x => ?f2.1 x
  | num.Bit1 x => ?f3.1 x ==
  ?f2.1 ?x2.1
  rec_num ?y ?f2.1 ?f3.1 num.One == ?y
  rec_num ?f1.1 ?f2.1 ?f3.1 (num.Bit1 ?x3.1) ==
  ?f3.1 ?x3.1 (rec_num ?f1.1 ?f2.1 ?f3.1 ?x3.1)
  rec_num ?f1.1 ?f2.1 ?f3.1 (num.Bit0 ?x2.1) ==
  ?f2.1 ?x2.1 (rec_num ?f1.1 ?f2.1 ?f3.1 ?x2.1)
  ?a1 ~: ?A1 ==> override_on ?f1 ?g1 ?A1 ?a1 == ?f1 ?a1
  ?a1 : ?A1 ==> override_on ?f1 ?g1 ?A1 ?a1 == ?g1 ?a1
  rel_sum ?R1.1 ?R2.1 (Inr ?a2.1) (Inr ?b2.1) == ?R2.1 ?a2.1 ?b2.1
  rel_sum ?R1.1 ?R2.1 (Inr ?a2.1) (Inl ?b1.1) == False
  rel_sum ?R1.1 ?R2.1 (Inl ?a1.1) (Inr ?b2.1) == False
  rel_sum ?R1.1 ?R2.1 (Inl ?a1.1) (Inl ?b1.1) == ?R1.1 ?a1.1 ?b1.1
  ?x1 ~: set ?xs1 ==> (?f1(?xs1 [|->] ?ys1)) ?x1 == ?f1 ?x1
  map_fun ?f1 ?g1 ?h1 ?x1 == ?g1 (?h1 (?f1 ?x1))
  (?f1(?x1 := ?y1)) ?z1 == if ?z1 = ?x1 then ?y1 else ?f1 ?z1
  case a\<^sub>4 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?f3.1 | a\<^sub>4 => ?y ==
  ?y
  case a\<^sub>3 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?y | a\<^sub>4 => ?f4.1 ==
  ?y
  case a\<^sub>2 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?y
  | a\<^sub>3 => ?f3.1 | a\<^sub>4 => ?f4.1 ==
  ?y
  case a\<^sub>1 of a\<^sub>1 => ?y | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?f3.1 | a\<^sub>4 => ?f4.1 ==
  ?y
  rec_finite_4 ?f1.1 ?f2.1 ?f3.1 ?y a\<^sub>4 == ?y
  rec_finite_4 ?f1.1 ?f2.1 ?y ?f4.1 a\<^sub>3 == ?y
  rec_finite_4 ?f1.1 ?y ?f3.1 ?f4.1 a\<^sub>2 == ?y
  rec_finite_4 ?y ?f2.1 ?f3.1 ?f4.1 a\<^sub>1 == ?y
  case a\<^sub>5 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?f3.1 | a\<^sub>4 => ?f4.1 | a\<^sub>5 => ?y ==
  ?y
  case a\<^sub>4 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?f3.1 | a\<^sub>4 => ?y | a\<^sub>5 => ?f5.1 ==
  ?y
  case a\<^sub>3 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?y | a\<^sub>4 => ?f4.1 | a\<^sub>5 => ?f5.1 ==
  ?y
  case a\<^sub>2 of a\<^sub>1 => ?f1.1 | a\<^sub>2 => ?y
  | a\<^sub>3 => ?f3.1 | a\<^sub>4 => ?f4.1 | a\<^sub>5 => ?f5.1 ==
  ?y
  case a\<^sub>1 of a\<^sub>1 => ?y | a\<^sub>2 => ?f2.1
  | a\<^sub>3 => ?f3.1 | a\<^sub>4 => ?f4.1 | a\<^sub>5 => ?f5.1 ==
  ?y
  rec_finite_5 ?f1.1 ?f2.1 ?f3.1 ?f4.1 ?y a\<^sub>5 == ?y
  rec_finite_5 ?f1.1 ?f2.1 ?f3.1 ?y ?f5.1 a\<^sub>4 == ?y
  rec_finite_5 ?f1.1 ?f2.1 ?y ?f4.1 ?f5.1 a\<^sub>3 == ?y
  rec_finite_5 ?f1.1 ?y ?f3.1 ?f4.1 ?f5.1 a\<^sub>2 == ?y
  rec_finite_5 ?y ?f2.1 ?f3.1 ?f4.1 ?f5.1 a\<^sub>1 == ?y
  Char (digit0 ?y) (digit1 ?y) (digit2 ?y) (digit3 ?y) (digit4 ?y)
   (digit5 ?y) (digit6 ?y) (digit7 ?y) ==
  ?y
simplification procedures:
  ??.record:
    ?x
  ??.record_eq:
    ?r = ?s
  ??.record_upd:
    ?x
  Collect_mem:
    Collect ?t
  HOL.defined_All:
    ALL x. ?P x
  NO_MATCH:
    NO_MATCH ?pat ?val
  Set.defined_All:
    ALL x:?A. ?P x --> ?Q x
  antisym_le:
    ?x <= ?y
  antisym_less:
    ~ ?x < ?y
  boolean_algebra_cancel_inf:
    inf ?a ?b
  boolean_algebra_cancel_sup:
    sup ?a ?b
  cancel_div_mod_int:
    ?a + ?b
  cancel_div_mod_nat:
    ?m + ?n
  case_prod_beta:
    case ?z of (x, xa) => ?f x xa
  case_prod_eta:
    %(x, y). ?f x y
  datatype_no_proper_subterm:
    ?x = ?y
  defined_Bex:
    EX x:?A. ?P x & ?Q x
  defined_Collect:
    {x. ?P x & ?Q x}
  defined_Ex:
    EX x. ?P x
  defined_all:
    !!x. PROP ?P x
  divide_cancel_factor:
    ?l / (?m * ?n)
    ?l * ?m / ?n
  divide_cancel_numeral_factor:
    ?l / (?m * ?n)
    numeral ?v / numeral ?w
    ?l * ?m / ?n
  dvd_cancel_factor:
    ?l dvd ?m * ?n
    ?l * ?m dvd ?n
  eliminate_false_implies:
    False ==> PROP ?P
  fast_arith:
    ?m <= ?n
    ?m < ?n
    ?m = ?n
  fast_arith_nat:
    ?m <= ?n
    ?m < ?n
    ?m = ?n
  field_combine_numerals:
    ?i - ?j
    ?i + ?j
  fun_upd2:
    ?f(?v := ?w, ?x := ?y)
  group_cancel_add:
    ?a + ?b
  group_cancel_diff:
    ?a - ?b
  group_cancel_eq:
    ?a = ?b
  group_cancel_le:
    ?a <= ?b
  group_cancel_less:
    ?a < ?b
  int_combine_numerals:
    ?i - ?j
    ?i + ?j
  int_div_cancel_factor:
    ?l div (?m * ?n)
    ?l * ?m div ?n
  int_div_cancel_numeral_factors:
    ?l div (?m * ?n)
    ?l * ?m div ?n
  int_mod_cancel_factor:
    ?l mod (?m * ?n)
    ?l * ?m mod ?n
  inteq_cancel_numerals:
    ?l = - ?m
    ?l = ?m * ?n
    ?l = ?m - ?n
    ?l = ?m + ?n
    - ?l = ?m
    ?l * ?m = ?n
    ?l - ?m = ?n
    ?l + ?m = ?n
  intle_cancel_numerals:
    ?l <= - ?m
    ?l <= ?m * ?n
    ?l <= ?m - ?n
    ?l <= ?m + ?n
    - ?l <= ?m
    ?l * ?m <= ?n
    ?l - ?m <= ?n
    ?l + ?m <= ?n
  intless_cancel_numerals:
    ?l < - ?m
    ?l < ?m * ?n
    ?l < ?m - ?n
    ?l < ?m + ?n
    - ?l < ?m
    ?l * ?m < ?n
    ?l - ?m < ?n
    ?l + ?m < ?n
  let_simp:
    Let ?x ?f
  linordered_ring_le_cancel_factor:
    ?l <= ?m * ?n
    ?l * ?m <= ?n
  linordered_ring_less_cancel_factor:
    ?l < ?m * ?n
    ?l * ?m < ?n
  list_eq:
    ?xs = ?ys
  list_neq:
    ?xs = ?ys
  list_to_set_comprehension:
    set ?xs
  nat_combine_numerals:
    Suc (?i + ?j)
    ?i + ?j
  nat_div_cancel_factor:
    ?l div (?m * ?n)
    ?l * ?m div ?n
  nat_div_cancel_numeral_factor:
    ?l div (?m * ?n)
    ?l * ?m div ?n
  nat_dvd_cancel_factor:
    ?l dvd ?m * ?n
    ?l * ?m dvd ?n
  nat_dvd_cancel_numeral_factor:
    ?l dvd ?m * ?n
    ?l * ?m dvd ?n
  nat_eq_cancel_factor:
    ?l = ?m * ?n
    ?l * ?m = ?n
  nat_eq_cancel_numeral_factor:
    ?l = ?m * ?n
    ?l * ?m = ?n
  nat_le_cancel_factor:
    ?l <= ?m * ?n
    ?l * ?m <= ?n
  nat_le_cancel_numeral_factor:
    ?l <= ?m * ?n
    ?l * ?m <= ?n
  nat_less_cancel_factor:
    ?l < ?m * ?n
    ?l * ?m < ?n
  nat_less_cancel_numeral_factor:
    ?l < ?m * ?n
    ?l * ?m < ?n
  natdiff_cancel_numerals:
    ?m - Suc ?n
    ?l - ?m * ?n
    ?l - (?m + ?n)
    Suc ?m - ?n
    ?l * ?m - ?n
    ?l + ?m - ?n
  natdiff_cancel_sums:
    ?m - Suc ?n
    ?l - (?m + ?n)
    Suc ?m - ?n
    ?l + ?m - ?n
  nateq_cancel_numerals:
    ?m = Suc ?n
    ?l = ?m * ?n
    ?l = ?m + ?n
    Suc ?m = ?n
    ?l * ?m = ?n
    ?l + ?m = ?n
  nateq_cancel_sums:
    ?m = Suc ?n
    ?l = ?m + ?n
    Suc ?m = ?n
    ?l + ?m = ?n
  natle_cancel_numerals:
    ?m <= Suc ?n
    ?l <= ?m * ?n
    ?l <= ?m + ?n
    Suc ?m <= ?n
    ?l * ?m <= ?n
    ?l + ?m <= ?n
  natle_cancel_sums:
    ?m <= Suc ?n
    ?l <= ?m + ?n
    Suc ?m <= ?n
    ?l + ?m <= ?n
  natless_cancel_numerals:
    ?m < Suc ?n
    ?l < ?m * ?n
    ?l < ?m + ?n
    Suc ?m < ?n
    ?l * ?m < ?n
    ?l + ?m < ?n
  natless_cancel_sums:
    ?m < Suc ?n
    ?l < ?m + ?n
    Suc ?m < ?n
    ?l + ?m < ?n
  neq:
    ?x = ?y
  numeral_divmod:
    (0::?'a) mod (0::?'a)
    (0::?'a) mod (1::?'a)
    0 mod - 1
    0 mod - numeral ?b
    (0::?'a) mod numeral ?b
    (1::?'a) mod (0::?'a)
    (1::?'a) mod (1::?'a)
    1 mod - 1
    1 mod - numeral ?b
    (1::?'a) mod numeral ?b
    - 1 mod 0
    - 1 mod 1
    - 1 mod - 1
    - 1 mod - numeral ?b
    - 1 mod numeral ?b
    - numeral ?a mod 0
    - numeral ?a mod 1
    - numeral ?a mod - 1
    - numeral ?a mod - numeral ?b
    - numeral ?a mod numeral ?b
    numeral ?a mod (0::?'a)
    numeral ?a mod (1::?'a)
    numeral ?a mod - 1
    numeral ?a mod - numeral ?b
    numeral ?a mod numeral ?b
    (0::?'a) div (0::?'a)
    (0::?'a) div (1::?'a)
    0 div - 1
    0 div - numeral ?b
    (0::?'a) div numeral ?b
    (1::?'a) div (0::?'a)
    (1::?'a) div (1::?'a)
    1 div - 1
    1 div - numeral ?b
    (1::?'a) div numeral ?b
    - 1 div 0
    - 1 div 1
    - 1 div - 1
    - 1 div - numeral ?b
    - 1 div numeral ?b
    - numeral ?a div 0
    - numeral ?a div 1
    - numeral ?a div - 1
    - numeral ?a div - numeral ?b
    - numeral ?a div numeral ?b
    numeral ?a div (0::?'a)
    numeral ?a div (1::?'a)
    numeral ?a div - 1
    numeral ?a div - numeral ?b
    numeral ?a div numeral ?b
  reorient_numeral:
    - numeral ?w = ?y
    numeral ?w = ?x
  reorient_one:
    (1::?'a) = ?x
  reorient_zero:
    (0::?'a) = ?x
  ring_eq_cancel_factor:
    ?l = ?m * ?n
    ?l * ?m = ?n
  ring_eq_cancel_numeral_factor:
    ?l = ?m * ?n
    ?l * ?m = ?n
  ring_le_cancel_numeral_factor:
    ?l <= ?m * ?n
    ?l * ?m <= ?n
  ring_less_cancel_numeral_factor:
    ?l < ?m * ?n
    ?l * ?m < ?n
  semiring_assoc_fold:
    ?a * ?b
  unit_eq:
    ?x
congruences:
  If: ?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y
  Bex: [| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
       ==> EX x:?A. ?P x == EX x:?B. ?Q x
  Ball:
    [| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
    ==> ALL x:?A. ?P x == ALL x:?B. ?Q x
  (`): [| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
       ==> ?f ` ?M == ?g ` ?N
  (-->): [| ?P == ?P'; ?P' ==> ?Q == ?Q' |] ==> ?P --> ?Q == ?P' --> ?Q'
  NO_MATCH: NO_MATCH ?pat ?val == NO_MATCH ?pat ?val
  ASSUMPTION: ASSUMPTION ?A == ASSUMPTION ?A
  (=simp=>):
    [| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q == PROP ?Q' |]
    ==> (PROP ?P =simp=> PROP ?Q) == (PROP ?P' =simp=> PROP ?Q')
  case_nat:
    ?M == ?M' ==>
    case ?M of 0 => ?f1.0 | Suc x => ?f2.0 x ==
    case ?M' of 0 => ?f1.0 | Suc x => ?f2.0 x
  case_num:
    ?num == ?num' ==>
    case ?num of num.One => ?f1.0 | num.Bit0 x => ?f2.0 x
    | num.Bit1 x => ?f3.0 x ==
    case ?num' of num.One => ?f1.0 | num.Bit0 x => ?f2.0 x
    | num.Bit1 x => ?f3.0 x
  successively:
    [| !!x y. [| x : set ?xs; y : set ?xs |] ==> ?P x y == ?Q x y;
       ?xs == ?ys |]
    ==> successively ?P ?xs == successively ?Q ?ys
  case_list:
    ?list == ?list' ==>
    case ?list of [] => ?f1.0 | x # xa => ?f2.0 x xa ==
    case ?list' of [] => ?f1.0 | x # xa => ?f2.0 x xa
  case_char:
    ?char == ?char' ==>
    case ?char of
    Char x xa xb xc xd xe xf xg => ?f x xa xb xc xd xe xf xg ==
    case ?char' of Char x xa xb xc xd xe xf xg => ?f x xa xb xc xd xe xf xg
  case_sum:
    ?M == ?M' ==>
    case ?M of Inl x => ?f1.0 x | Inr x => ?f2.0 x ==
    case ?M' of Inl x => ?f1.0 x | Inr x => ?f2.0 x
  case_word:
    ?word == ?word' ==>
    case ?word of word.Word x => ?f x == case ?word' of word.Word x => ?f x
  case_seq:
    ?seq == ?seq' ==>
    case ?seq of seq.Empty => ?f1.0 | seq.Insert x xa => ?f2.0 x xa
    | seq.Join x xa => ?f3.0 x xa ==
    case ?seq' of seq.Empty => ?f1.0 | seq.Insert x xa => ?f2.0 x xa
    | seq.Join x xa => ?f3.0 x xa
  case_pred:
    ?pred == ?pred' ==>
    case ?pred of pred.Pred x => ?f x == case ?pred' of pred.Pred x => ?f x
  case_option:
    ?option == ?option' ==>
    case ?option of None => ?f1.0 | Some x => ?f2.0 x ==
    case ?option' of None => ?f1.0 | Some x => ?f2.0 x
  case_finite_1:
    ?finite_1.0 == ?finite_1' ==>
    case ?finite_1.0 of a\<^sub>1 => ?f ==
    case ?finite_1' of a\<^sub>1 => ?f
  case_finite_2:
    ?finite_2.0 == ?finite_2' ==>
    case ?finite_2.0 of a\<^sub>1 => ?f1.0 | a\<^sub>2 => ?f2.0 ==
    case ?finite_2' of a\<^sub>1 => ?f1.0 | a\<^sub>2 => ?f2.0
  case_finite_3:
    ?finite_3.0 == ?finite_3' ==>
    case ?finite_3.0 of a\<^sub>1 => ?f1.0 | a\<^sub>2 => ?f2.0
    | a\<^sub>3 => ?f3.0 ==
    case ?finite_3' of a\<^sub>1 => ?f1.0 | a\<^sub>2 => ?f2.0
    | a\<^sub>3 => ?f3.0
  case_finite_4:
    ?finite_4.0 == ?finite_4' ==>
    case ?finite_4.0 of a\<^sub>1 => ?f1.0 | a\<^sub>2 => ?f2.0
    | a\<^sub>3 => ?f3.0 | a\<^sub>4 => ?f4.0 ==
    case ?finite_4' of a\<^sub>1 => ?f1.0 | a\<^sub>2 => ?f2.0
    | a\<^sub>3 => ?f3.0 | a\<^sub>4 => ?f4.0
  case_finite_5:
    ?finite_5.0 == ?finite_5' ==>
    case ?finite_5.0 of a\<^sub>1 => ?f1.0 | a\<^sub>2 => ?f2.0
    | a\<^sub>3 => ?f3.0 | a\<^sub>4 => ?f4.0 | a\<^sub>5 => ?f5.0 ==
    case ?finite_5' of a\<^sub>1 => ?f1.0 | a\<^sub>2 => ?f2.0
    | a\<^sub>3 => ?f3.0 | a\<^sub>4 => ?f4.0 | a\<^sub>5 => ?f5.0
  case_bool:
    ?M == ?M' ==>
    case ?M of True => ?f1.0 | False => ?f2.0 ==
    case ?M' of True => ?f1.0 | False => ?f2.0
  case_unit: ?M == ?M' ==> case ?M of () => ?f1.0 == case ?M' of () => ?f1.0
  case_fun_box:
    ?fun_box == ?fun_box' ==>
    case ?fun_box of fun_box.FunBox x => ?f x ==
    case ?fun_box' of fun_box.FunBox x => ?f x
  case_typerep:
    ?typerep == ?typerep' ==>
    case ?typerep of typerep.Typerep x xa => ?f x xa ==
    case ?typerep' of typerep.Typerep x xa => ?f x xa
  case_term:
    ?term == ?term' ==>
    case ?term of ??.Code_Evaluation.term.dummy_term => ?f ==
    case ?term' of ??.Code_Evaluation.term.dummy_term => ?f
  case_pair_box:
    ?pair_box == ?pair_box' ==>
    case ?pair_box of pair_box.PairBox x xa => ?f x xa ==
    case ?pair_box' of pair_box.PairBox x xa => ?f x xa
  case_sumbool:
    ?sumbool == ?sumbool' ==>
    case ?sumbool of Left => ?f1.0 | Right => ?f2.0 ==
    case ?sumbool' of Left => ?f1.0 | Right => ?f2.0
  case_natural:
    ?M == ?M' ==>
    case ?M of 0 => ?f1.0 | Code_Numeral.Suc x => ?f2.0 x ==
    case ?M' of 0 => ?f1.0 | Code_Numeral.Suc x => ?f2.0 x
  case_cfun:
    ?cfun == ?cfun' ==>
    case ?cfun of cfun.Constant x => ?f x ==
    case ?cfun' of cfun.Constant x => ?f x
  case_ffun:
    ?ffun == ?ffun' ==>
    case ?ffun of ffun.Constant x => ?f1.0 x
    | ffun.Update x xa xb => ?f2.0 x xa xb ==
    case ?ffun' of ffun.Constant x => ?f1.0 x
    | ffun.Update x xa xb => ?f2.0 x xa xb
  sum: [| ?A == ?B; !!x. x : ?B =simp=> ?g x == ?h x |]
       ==> sum ?g ?A == sum ?h ?B
  prod:
    [| ?A == ?B; !!x. x : ?B =simp=> ?g x == ?h x |]
    ==> prod ?g ?A == prod ?h ?B
  case_unknown:
    ?unknown == ?unknown' ==>
    case ?unknown of unknown.Unknown => ?f1.0
    | unknown.Known x => ?f2.0 x ==
    case ?unknown' of unknown.Unknown => ?f1.0 | unknown.Known x => ?f2.0 x
  case_property:
    ?property == ?property' ==>
    case ?property of Universal x xa xb => ?f1.0 x xa xb
    | Existential x xa xb => ?f2.0 x xa xb | Property x => ?f3.0 x ==
    case ?property' of Universal x xa xb => ?f1.0 x xa xb
    | Existential x xa xb => ?f2.0 x xa xb | Property x => ?f3.0 x
  case_lazy_sequence:
    ?lazy_sequence == ?lazy_sequence' ==>
    case ?lazy_sequence of lazy_sequence_of_list x => ?f x ==
    case ?lazy_sequence' of lazy_sequence_of_list x => ?f x
  case_tuple_isomorphism:
    ?tuple_isomorphism == ?tuple_isomorphism' ==>
    case ?tuple_isomorphism of
    tuple_isomorphism.Tuple_Isomorphism x xa => ?f x xa ==
    case ?tuple_isomorphism' of
    tuple_isomorphism.Tuple_Isomorphism x xa => ?f x xa
  case_three_valued:
    ?three_valued == ?three_valued' ==>
    case ?three_valued of three_valued.Unknown_value => ?f1.0
    | three_valued.Value x => ?f2.0 x | three_valued.No_value => ?f3.0 ==
    case ?three_valued' of three_valued.Unknown_value => ?f1.0
    | three_valued.Value x => ?f2.0 x | three_valued.No_value => ?f3.0
  case_narrowing_cons:
    ?narrowing_cons == ?narrowing_cons' ==>
    case ?narrowing_cons of
    ??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons x xa => ?f x xa ==
    case ?narrowing_cons' of
    ??.Quickcheck_Narrowing.narrowing_cons.Narrowing_cons x xa => ?f x xa
  case_narrowing_term:
    ?narrowing_term == ?narrowing_term' ==>
    case ?narrowing_term of
    narrowing_term.Narrowing_variable x xa => ?f1.0 x xa
    | narrowing_term.Narrowing_constructor x xa => ?f2.0 x xa ==
    case ?narrowing_term' of
    narrowing_term.Narrowing_variable x xa => ?f1.0 x xa
    | narrowing_term.Narrowing_constructor x xa => ?f2.0 x xa
  case_narrowing_type:
    ?narrowing_type == ?narrowing_type' ==>
    case ?narrowing_type of Narrowing_sum_of_products x => ?f x ==
    case ?narrowing_type' of Narrowing_sum_of_products x => ?f x
loopers: "split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun"
  "split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun"
  "split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun"
unsafe solvers: "Rtranclp" "Tranclp" "Rtrancl" "Trancl" "lin_arith"
  "Transitivity" "ASSUMPTION" "HOL unsafe"
safe solvers: "HOL safe"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Syntax"
### 3.257s elapsed time, 10.711s cpu time, 2.164s GC time
Loading theory "Draft.Semantics" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.IMP2_Basic_Decls" via "Draft.IMP2_Basic_Simpset")
### theory "HOL-Library.Tree"
### 2.669s elapsed time, 8.383s cpu time, 1.998s GC time
Loading theory "Draft.Templates" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.057s elapsed time, 0.117s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.IMP2_Basic_DeclsMoreTemplates")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Proofs for inductive predicate(s) "big_step"
  Proving monotonicity ...
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.639s elapsed time, 1.339s cpu time, 0.124s GC time
### Cannot skip proof of schematic goal statement
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
Proofs for inductive predicate(s) "small_steps"
  Proving monotonicity ...
Proofs for inductive predicate(s) "count_it"
  Proving monotonicity ...
### theory "Draft.Semantics"
### 2.983s elapsed time, 4.370s cpu time, 0.349s GC time
Loading theory "Draft.IMP2_Basic_Simpset" (required by "Draft.IMP2_Basic_DeclsMoreTemplates" via "Draft.IMP2_Basic_Decls")
val vcg_bb_simplify = fn: thm list -> Proof.context -> thm -> thm
val vcg_bb_simp_tac = fn: thm list -> Proof.context -> int -> tactic
val mk_BB_PROTECT = fn: term -> term
val dest_BB_PROTECT = fn: term -> term
### theory "Draft.IMP2_Basic_Simpset"
### 0.248s elapsed time, 0.266s cpu time, 0.000s GC time
Loading theory "Draft.IMP2_Basic_Decls" (required by "Draft.IMP2_Basic_DeclsMoreTemplates")
### theory "Draft.IMP2_Basic_Decls"
### 0.239s elapsed time, 0.239s cpu time, 0.000s GC time
Loading theory "Draft.IMP2_Basic_DeclsMoreTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.IMP2_Basic_DeclsMoreTemplates"
### 0.679s elapsed time, 1.527s cpu time, 0.988s GC time
val it = (): unit
