Loading theory "HOL-Library.Code_Target_Int" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Finite_String")
Loading theory "HOL-Eisbach.Eisbach" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Word_EqI" via "HOL-Eisbach.Eisbach_Tools")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.InterpreterMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.InterpreterMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
### Code generator: dropping subsumed code equation
### 1 == Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l == ?l
### Code generator: dropping subsumed code equation
### ?k + 0 == ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m == Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m == Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 == 0
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l == - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 == ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) == Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) == Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l == 0
### Code generator: dropping subsumed code equation
### ?k * 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One == - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One == ?k
### Code generator: dropping subsumed code equation
### 0 div ?k == 0
### Code generator: dropping subsumed code equation
### ?k div 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n == - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n ==
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n ==
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n == snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One == 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One == 0
### Code generator: dropping subsumed code equation
### 0 mod ?k == 0
### Code generator: dropping subsumed code equation
### ?k mod 0 == ?k
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k == True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Neg ?l == ?l <= ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Pos ?l == ?k <= ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= 0 == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l == ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l == ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 == False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 < 0 == False
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
### theory "HOL-Library.Function_Algebras"
### 0.141s elapsed time, 0.537s cpu time, 0.034s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "HOL-Library.Word" via "HOL-Library.Type_Length" via "HOL-Library.Numeral_Type" via "HOL-Library.Cardinality")
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) == numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 == 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) == - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) == nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 == 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) == 0
### theory "HOL-Library.Code_Target_Int"
### 0.159s elapsed time, 0.619s cpu time, 0.034s GC time
Loading theory "Draft.Finite_String" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter")
structure Eisbach_Rule_Insts: sig end
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "{}"
instantiation
  fin_string :: finite
instantiation
  char :: linorder
  less_eq_char == less_eq :: char => char => bool
  less_char == less :: char => char => bool
instantiation
  fin_string :: linorder
  less_eq_fin_string == less_eq :: fin_string => fin_string => bool
  less_fin_string == less :: fin_string => fin_string => bool
### theory "HOL-Library.Nat_Bijection"
### 0.332s elapsed time, 1.290s cpu time, 0.101s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.InterpreterMoreTemplates" via "Draft.ExtrEqs")
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
### theory "HOL-Eisbach.Eisbach"
### 0.457s elapsed time, 1.779s cpu time, 0.156s GC time
Loading theory "HOL-Eisbach.Eisbach_Tools" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Word_EqI")
val try_map = fn: 'a Seq.seq -> 'a Seq.seq -> 'a Seq.seq
val uncurry_rule = fn: thm -> thm
val curry_rule = fn: thm -> thm
### theory "HOL-Eisbach.Eisbach_Tools"
### 0.032s elapsed time, 0.128s cpu time, 0.000s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.InterpreterMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "{}"
Found termination order: "{}"
### theory "HOL-Library.Phantom_Type"
### 0.561s elapsed time, 2.246s cpu time, 0.184s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "HOL-Library.Word" via "HOL-Library.Type_Length" via "HOL-Library.Numeral_Type")
### theory "HOL-Library.Set_Algebras"
### 0.217s elapsed time, 0.907s cpu time, 0.062s GC time
Loading theory "HOL-Library.Signed_Division" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Word_Lemmas" via "Word_Lib.Signed_Division_Word")
Found termination order: "size <*mlex*> {}"
### Additional type variable(s) in locale specification "CARD_1": 'a
consts
  shift :: "'a list => 'a stream => 'a stream"
class signed_division = type +
  fixes signed_divide :: "'a => 'a => 'a"
    and signed_modulo :: "'a => 'a => 'a"
instantiation
  int :: signed_division
  signed_divide_int == signed_divide :: int => int => int
  signed_modulo_int == signed_modulo :: int => int => int
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
instantiation
  fin_string :: enum
  enum_fin_string == enum_class.enum :: fin_string list
  enum_all_fin_string == enum_class.enum_all :: (fin_string => bool) => bool
  enum_ex_fin_string == enum_class.enum_ex :: (fin_string => bool) => bool
instantiation
  fin_string :: equal
  equal_fin_string == equal_class.equal :: fin_string => fin_string => bool
### theory "Draft.Finite_String"
### 0.694s elapsed time, 2.770s cpu time, 0.250s GC time
Loading theory "HOL-Library.Sublist" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bitwise_Signed" via "Word_Lib.Bitwise" via "Word_Lib.Reversed_Bit_Lists")
### theory "HOL-Library.Signed_Division"
### 0.154s elapsed time, 0.612s cpu time, 0.066s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.InterpreterMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
### Additional type variable(s) in locale specification "card2": 'a
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
consts
  cycle :: "'a list => 'a stream"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
consts
  flat :: "'a list stream => 'a stream"
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
consts
  prefixes :: "'a list => 'a list list"
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
### theory "HOL-Library.Stream"
### 1.147s elapsed time, 4.410s cpu time, 0.864s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.InterpreterMoreTemplates" via "Draft.ExtrEqs")
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
### theory "HOL-Library.Cardinality"
### 0.951s elapsed time, 3.590s cpu time, 0.838s GC time
Loading theory "HOL-Library.Numeral_Type" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "HOL-Library.Word" via "HOL-Library.Type_Length")
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
instantiation
  num1 :: CARD_1
instantiation
  num1 :: {comm_monoid_mult,numeral,comm_ring}
  uminus_num1 == uminus :: num1 => num1
  zero_num1 == zero_class.zero :: num1
  minus_num1 == minus :: num1 => num1 => num1
  plus_num1 == plus :: num1 => num1 => num1
  one_num1 == one_class.one :: num1
  times_num1 == times :: num1 => num1 => num1
instantiation
  num1 :: linorder
  less_eq_num1 == less_eq :: num1 => num1 => bool
  less_num1 == less :: num1 => num1 => bool
Found termination order: "size <*mlex*> {}"
locale mod_type
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_type n Rep Abs"
locale mod_ring
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_ring n Rep Abs"
instantiation
  bit0 :: (finite) {minus,one,plus,times,uminus,zero}
  bit1 :: (finite) {minus,one,plus,times,uminus,zero}
  zero_bit0 == zero_class.zero :: 'a bit0
  uminus_bit0 == uminus :: 'a bit0 => 'a bit0
  times_bit0 == times :: 'a bit0 => 'a bit0 => 'a bit0
  plus_bit0 == plus :: 'a bit0 => 'a bit0 => 'a bit0
  one_bit0 == one_class.one :: 'a bit0
  minus_bit0 == minus :: 'a bit0 => 'a bit0 => 'a bit0
  zero_bit1 == zero_class.zero :: 'a bit1
  uminus_bit1 == uminus :: 'a bit1 => 'a bit1
  times_bit1 == times :: 'a bit1 => 'a bit1 => 'a bit1
  plus_bit1 == plus :: 'a bit1 => 'a bit1 => 'a bit1
  one_bit1 == one_class.one :: 'a bit1
  minus_bit1 == minus :: 'a bit1 => 'a bit1 => 'a bit1
Found termination order: "size <*mlex*> {}"
consts
  suffixes :: "'a list => 'a list list"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Proofs for inductive predicate(s) "list_emb"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
instantiation
  bit0 :: (finite) linorder
  bit1 :: (finite) linorder
  less_eq_bit0 == less_eq :: 'a bit0 => 'a bit0 => bool
  less_bit0 == less :: 'a bit0 => 'a bit0 => bool
  less_eq_bit1 == less_eq :: 'a bit1 => 'a bit1 => bool
  less_bit1 == less :: 'a bit1 => 'a bit1 => bool
Found termination order: "size <*mlex*> {}"
instantiation
  num0 :: equal
  equal_num0 == equal_class.equal :: num0 => num0 => bool
Found termination order: "size <*mlex*> {}"
instantiation
  num1 :: equal
  equal_num1 == equal_class.equal :: num1 => num1 => bool
instantiation
  num1 :: enum
  enum_num1 == enum_class.enum :: num1 list
  enum_all_num1 == enum_class.enum_all :: (num1 => bool) => bool
  enum_ex_num1 == enum_class.enum_ex :: (num1 => bool) => bool
instantiation
  num0 :: card_UNIV
  num1 :: card_UNIV
  card_UNIV_num0 == card_UNIV_class.card_UNIV :: (num0, nat) phantom
  finite_UNIV_num0 == finite_UNIV :: (num0, bool) phantom
  card_UNIV_num1 == card_UNIV_class.card_UNIV :: (num1, nat) phantom
  finite_UNIV_num1 == finite_UNIV :: (num1, bool) phantom
Found termination order: "size <*mlex*> {}"
instantiation
  bit0 :: (finite) equal
  bit1 :: (finite) equal
  equal_bit0 == equal_class.equal :: 'a bit0 => 'a bit0 => bool
  equal_bit1 == equal_class.equal :: 'a bit1 => 'a bit1 => bool
instantiation
  bit0 :: (finite) enum
  enum_bit0 == enum_class.enum :: 'a bit0 list
  enum_all_bit0 == enum_class.enum_all :: ('a bit0 => bool) => bool
  enum_ex_bit0 == enum_class.enum_ex :: ('a bit0 => bool) => bool
Found termination order: "size <*mlex*> {}"
instantiation
  bit1 :: (finite) enum
  enum_bit1 == enum_class.enum :: 'a bit1 list
  enum_all_bit1 == enum_class.enum_all :: ('a bit1 => bool) => bool
  enum_ex_bit1 == enum_class.enum_ex :: ('a bit1 => bool) => bool
### theory "HOL-Library.BigO"
### 1.135s elapsed time, 4.334s cpu time, 1.263s GC time
Loading theory "Word_Lib.Enumeration" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Enumeration_Word")
instantiation
  bit0 :: (finite) finite_UNIV
  bit1 :: (finite) finite_UNIV
  finite_UNIV_bit0 == finite_UNIV :: ('a bit0, bool) phantom
  finite_UNIV_bit1 == finite_UNIV :: ('a bit1, bool) phantom
consts
  the_index :: "'a list => 'a => nat"
instantiation
  bit0 :: ({card_UNIV,finite}) card_UNIV
  bit1 :: ({card_UNIV,finite}) card_UNIV
  card_UNIV_bit0 == card_UNIV_class.card_UNIV :: ('a bit0, nat) phantom
  card_UNIV_bit1 == card_UNIV_class.card_UNIV :: ('a bit1, nat) phantom
Found termination order: "size <*mlex*> {}"
class enum = finite +
  fixes enum :: "'a list"
    and enum_all :: "('a => bool) => bool"
    and enum_ex :: "('a => bool) => bool"
  assumes "UNIV_enum": "UNIV = set enum_class.enum"
    and "enum_distinct": "distinct enum_class.enum"
  assumes "enum_all_UNIV": "!!P. enum_class.enum_all P = Ball UNIV P"
  assumes "enum_ex_UNIV": "!!P. enum_class.enum_ex P = Bex UNIV P"
### theory "HOL-Library.Numeral_Type"
### 1.069s elapsed time, 4.072s cpu time, 1.222s GC time
Loading theory "HOL-Library.Type_Length" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "HOL-Library.Word")
Found termination order: "size <*mlex*> {}"
class enum_alt = type +
  fixes enum_alt :: "nat => 'a option"
class len0 = type +
  fixes len_of :: "'a itself => nat"
consts
  sublists :: "'a list => 'a list list"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
class enumeration_alt = enum_alt +
  assumes
    "enum_alt_one_bound":
      "!!x. enum_alt x = None ==> enum_alt (Suc x) = None"
  assumes "enum_alt_surj": "range enum_alt Un {None} = UNIV"
  assumes
    "enum_alt_inj":
      "!!x y. enum_alt x = enum_alt y ==> x = y | enum_alt x = None"
class len = len0 +
  assumes "len_gt_0": "0 < LENGTH('a)"
instantiation
  0 :: len0
  1 :: len0
  len_of_num0 == len_of :: 0 itself => nat
  len_of_num1 == len_of :: 1 itself => nat
instantiation
  bit0 :: (len0) len0
  bit1 :: (len0) len0
  len_of_bit0 == len_of :: 'a bit0 itself => nat
  len_of_bit1 == len_of :: 'a bit1 itself => nat
instantiation
  Enum.finite_1 :: len
  len_of_finite_1 == len_of :: Enum.finite_1 itself => nat
instantiation
  Enum.finite_2 :: len
  len_of_finite_2 == len_of :: Enum.finite_2 itself => nat
Found termination order: "size <*mlex*> {}"
instantiation
  Enum.finite_3 :: len
  len_of_finite_3 == len_of :: Enum.finite_3 itself => nat
### theory "HOL-Library.Sublist"
### 2.070s elapsed time, 7.853s cpu time, 2.072s GC time
Loading theory "Word_Lib.More_Sublist" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
class enumeration_both = enum + enum_alt +
  assumes "enum_alt_rel": "enum_alt = alt_from_ord enum_class.enum"
### theory "Word_Lib.More_Sublist"
### 0.046s elapsed time, 0.190s cpu time, 0.000s GC time
Loading theory "Word_Lib.Even_More_List" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bitwise_Signed" via "Word_Lib.Bitwise" via "Word_Lib.Reversed_Bit_Lists")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Word_Lib.Even_More_List"
### 0.047s elapsed time, 0.191s cpu time, 0.000s GC time
Loading theory "Word_Lib.More_Misc" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
### theory "Word_Lib.More_Misc"
### 0.058s elapsed time, 0.216s cpu time, 0.109s GC time
instantiation
  bool :: enumeration_both
  enum_alt_bool == enum_alt :: nat => bool option
instantiation
  nat :: enumeration_alt
  enum_alt_nat == enum_alt :: nat => nat option
### theory "Word_Lib.Enumeration"
### 0.572s elapsed time, 2.170s cpu time, 0.238s GC time
Found termination order: "size <*mlex*> {}"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "HOL-Library.Type_Length"
### 0.603s elapsed time, 2.075s cpu time, 0.252s GC time
Loading theory "HOL-Library.Word" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Loading theory "Word_Lib.More_Arithmetic" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Aligned" via "Word_Lib.More_Word")
### theory "Word_Lib.More_Arithmetic"
### 0.054s elapsed time, 0.165s cpu time, 0.000s GC time
### theory "HOL-Library.Tree"
### 2.580s elapsed time, 9.404s cpu time, 2.245s GC time
Loading theory "Draft.Templates" (required by "Draft.InterpreterMoreTemplates" via "Draft.ExtrEqs")
instantiation
  word :: (len) comm_ring_1
  uminus_word == uminus :: 'a word => 'a word
  one_word == one_class.one :: 'a word
  times_word == times :: 'a word => 'a word => 'a word
  zero_word == zero_class.zero :: 'a word
  minus_word == minus :: 'a word => 'a word => 'a word
  plus_word == plus :: 'a word => 'a word => 'a word
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.085s elapsed time, 0.212s cpu time, 0.096s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.InterpreterMoreTemplates")
signature WORD_LIB =
  sig
    val dest_binT: typ -> int
    val dest_wordT: typ -> int
    val is_wordT: typ -> bool
    val mk_wordT: int -> typ
  end
structure Word_Lib: WORD_LIB
instantiation
  word :: (len) equal
  equal_word == equal_class.equal :: 'a word => 'a word => bool
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.844s elapsed time, 2.103s cpu time, 1.021s GC time
instantiation
  word :: (len) linorder
  less_eq_word == less_eq :: 'a word => 'a word => bool
  less_word == less :: 'a word => 'a word => bool
instantiation
  word :: (len) enum
  enum_word == enum_class.enum :: 'a word list
  enum_all_word == enum_class.enum_all :: ('a word => bool) => bool
  enum_ex_word == enum_class.enum_ex :: ('a word => bool) => bool
instantiation
  word :: (len) semiring_modulo
  modulo_word == modulo :: 'a word => 'a word => 'a word
  divide_word == divide :: 'a word => 'a word => 'a word
instantiation
  word :: (len) semiring_bits
  bit_word == bit :: 'a word => nat => bool
instantiation
  word :: (len) ring_bit_operations
  not_word == not :: 'a word => 'a word
  and_word == and :: 'a word => 'a word => 'a word
  or_word == or :: 'a word => 'a word => 'a word
  xor_word == xor :: 'a word => 'a word => 'a word
  mask_word == mask :: nat => 'a word
  set_bit_word == set_bit :: nat => 'a word => 'a word
  unset_bit_word == unset_bit :: nat => 'a word => 'a word
  flip_bit_word == flip_bit :: nat => 'a word => 'a word
  push_bit_word == push_bit :: nat => 'a word => 'a word
  drop_bit_word == drop_bit :: nat => 'a word => 'a word
  take_bit_word == take_bit :: nat => 'a word => 'a word
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class unique_euclidean_semiring_numeral =
  unique_euclidean_semiring_with_nat + linordered_semidom +
  fixes divmod :: "num => num => 'a * 'a"
    and divmod_step :: "num => 'a * 'a => 'a * 'a"
  assumes
    "div_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a div b = (0::'a)"
    and "mod_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a mod b = a"
    and
    "div_positive": "!!b a. [| (0::'a) < b; b <= a |] ==> (0::'a) < a div b"
    and "mod_less_eq_dividend": "!!a b. (0::'a) <= a ==> a mod b <= a"
    and "pos_mod_bound": "!!b a. (0::'a) < b ==> a mod b < b"
    and "pos_mod_sign": "!!b a. (0::'a) < b ==> (0::'a) <= a mod b"
    and
    "mod_mult2_eq":
      "!!c a b.
          (0::'a) <= c ==> a mod (b * c) = b * (a div b mod c) + a mod b"
    and
    "div_mult2_eq":
      "!!c a b. (0::'a) <= c ==> a div (b * c) = a div b div c"
  assumes "discrete": "!!a b. (a < b) = (a + (1::'a) <= b)"
  assumes
    "divmod_def":
      "!!m n.
          divmod m n = (numeral m div numeral n, numeral m mod numeral n)"
    and
    "divmod_step_def":
      "!!l qr.
          divmod_step l qr =
          (let (q, r) = qr
           in if numeral l <= r then ((2::'a) * q + (1::'a), r - numeral l)
              else ((2::'a) * q, r))"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
instantiation
  word :: (len) size
  size_word == size :: 'a word => nat
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Min (\<le>s) (set (?x # ?xs)) == fold signed.min ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Max (\<le>s) (set (?x # ?xs)) == fold signed.max ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [?x] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted (?x # ?y # ?zs) == ?x \<le>s ?y & signed.sorted (?y # ?zs)
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted_list_of_set (set ?xs) == signed.sort (remdups ?xs)
val unat_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?v1 ... ?w1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.unat_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val unat_arith_tacs = fn: Proof.context -> tactic list
val unat_arith_tac = fn: Proof.context -> int -> tactic
val uint_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?a1 ... ?b1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.uint_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val uint_arith_tacs = fn: Proof.context -> tactic list
val uint_arith_tac = fn: Proof.context -> int -> tactic
locale word_rotate
signature SMT_WORD =
  sig
    val add_word_shift': term * string -> Context.generic -> Context.generic
  end
structure SMT_Word: SMT_WORD
### theory "HOL-Library.Word"
### 4.415s elapsed time, 6.261s cpu time, 1.634s GC time
Loading theory "Word_Lib.Bit_Comprehension" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Loading theory "Word_Lib.Hex_Words" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Loading theory "Word_Lib.Legacy_Aliases" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bitwise_Signed" via "Word_Lib.Bitwise" via "Word_Lib.Reversed_Bit_Lists")
Loading theory "Word_Lib.More_Divides" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Aligned" via "Word_Lib.More_Word")
locale abstract_boolean_algebra
  fixes
    conj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<sqinter>\<close> 70)
    and
    disj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<squnion>\<close> 65)
    and compl :: "'a => 'a"  (\<open>\<^bold>- _\<close> [81] 80)
    and zero :: "'a"  (\<open>\<^bold>0\<close>)
    and one :: "'a"  (\<open>\<^bold>1\<close>)
  assumes
    "abstract_boolean_algebra (\<^bold>\<sqinter>) (\<^bold>\<squnion>)
      compl \<^bold>0 \<^bold>1"
### theory "Word_Lib.Hex_Words"
### 0.039s elapsed time, 0.192s cpu time, 0.000s GC time
Loading theory "Word_Lib.Signed_Words" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bitwise_Signed")
instantiation
  signed :: (len0) len0
  len_of_signed == len_of :: 'a signed itself => nat
locale abstract_boolean_algebra_sym_diff
  fixes
    conj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<sqinter>\<close> 70)
    and
    disj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<squnion>\<close> 65)
    and compl :: "'a => 'a"  (\<open>\<^bold>- _\<close> [81] 80)
    and zero :: "'a"  (\<open>\<^bold>0\<close>)
    and one :: "'a"  (\<open>\<^bold>1\<close>)
    and
    xor :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<ominus>\<close> 65)
  assumes
    "abstract_boolean_algebra_sym_diff (\<^bold>\<sqinter>)
      (\<^bold>\<squnion>) compl \<^bold>0 \<^bold>1 (\<^bold>\<ominus>)"
### theory "Word_Lib.Signed_Words"
### 0.086s elapsed time, 0.354s cpu time, 0.000s GC time
Loading theory "Word_Lib.Norm_Words" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
### theory "Word_Lib.Legacy_Aliases"
### 0.145s elapsed time, 0.635s cpu time, 0.000s GC time
Loading theory "Word_Lib.Word_Names" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Word_32")
val is_refl = fn: term -> bool
val signed_dest_wordT = fn: typ -> int
val typ_size_of = fn: cterm -> int
val num_len = fn: term -> int
val unsigned_norm = fn: bool -> 'a -> Proof.context -> cterm -> thm option
### theory "Word_Lib.Norm_Words"
### 0.077s elapsed time, 0.299s cpu time, 0.082s GC time
Loading theory "Word_Lib.Syntax_Bundles" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
### theory "Word_Lib.Word_Names"
### 0.058s elapsed time, 0.220s cpu time, 0.082s GC time
Loading theory "Word_Lib.Type_Syntax" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
### theory "Word_Lib.More_Divides"
### 0.202s elapsed time, 0.855s cpu time, 0.082s GC time
Loading theory "Word_Lib.Word_Syntax" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Word_32")
bundle bit_projection_infix_syntax
### theory "Word_Lib.Syntax_Bundles"
### 0.023s elapsed time, 0.092s cpu time, 0.000s GC time
Loading theory "Word_Lib.Signed_Division_Word" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Word_Lemmas")
structure Word_Syntax:
  sig
    val show_word_types: bool Config.T
    val tr': string -> Proof.context -> typ -> term list -> term
  end
### theory "Word_Lib.Type_Syntax"
### 0.050s elapsed time, 0.201s cpu time, 0.000s GC time
Loading theory "Word_Lib.More_Word" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Aligned")
### theory "Word_Lib.Word_Syntax"
### 0.063s elapsed time, 0.255s cpu time, 0.000s GC time
instantiation
  word :: (len) signed_division
  signed_divide_word == signed_divide :: 'a word => 'a word => 'a word
  signed_modulo_word == signed_modulo :: 'a word => 'a word => 'a word
### theory "Word_Lib.Signed_Division_Word"
### 0.354s elapsed time, 1.138s cpu time, 0.075s GC time
class bit_comprehension = ring_bit_operations +
  fixes set_bits :: "(nat => bool) => 'a"
  assumes "set_bits_bit_eq": "!!a. set_bits (bit a) = a"
instantiation
  int :: bit_comprehension
  set_bits_int == set_bits :: (nat => bool) => int
instantiation
  word :: (len) bit_comprehension
  set_bits_word == set_bits :: (nat => bool) => 'a word
Proofs for inductive predicate(s) "wf_set_bits_int"
  Proving monotonicity ...
### theory "Word_Lib.Bit_Comprehension"
### 0.859s elapsed time, 2.666s cpu time, 0.219s GC time
### theory "Word_Lib.More_Word"
### 0.958s elapsed time, 2.025s cpu time, 0.211s GC time
Loading theory "Word_Lib.Bit_Shifts_Infix_Syntax" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Aligned")
Loading theory "Word_Lib.Enumeration_Word" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Loading theory "Word_Lib.Least_significant_bit" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bits_Int")
Loading theory "Word_Lib.Many_More" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
instantiation
  word :: (len) enumeration_both
  enum_alt_word == enum_alt :: nat => 'a word option
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
### theory "Word_Lib.Many_More"
### 0.392s elapsed time, 1.551s cpu time, 0.141s GC time
Loading theory "Word_Lib.Strict_part_mono" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
### theory "Word_Lib.Enumeration_Word"
### 0.409s elapsed time, 1.617s cpu time, 0.141s GC time
Loading theory "Word_Lib.Word_16" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
class lsb = semiring_bits +
  fixes lsb :: "'a => bool"
  assumes "lsb_odd": "lsb = odd"
instantiation
  int :: lsb
  lsb_int == lsb :: int => bool
### theory "Word_Lib.Strict_part_mono"
### 0.042s elapsed time, 0.167s cpu time, 0.000s GC time
instantiation
  word :: (len) lsb
  lsb_word == lsb :: 'a word => bool
### theory "Word_Lib.Least_significant_bit"
### 0.462s elapsed time, 1.814s cpu time, 0.141s GC time
### theory "Word_Lib.Word_16"
### 0.175s elapsed time, 0.483s cpu time, 0.105s GC time
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
### theory "Word_Lib.Bit_Shifts_Infix_Syntax"
### 0.887s elapsed time, 2.412s cpu time, 0.247s GC time
Loading theory "Word_Lib.Aligned" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Loading theory "Word_Lib.Singleton_Bit_Shifts" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bitwise_Signed" via "Word_Lib.Bitwise" via "Word_Lib.Reversed_Bit_Lists")
Loading theory "Word_Lib.Most_significant_bit" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bits_Int")
class msb = type +
  fixes msb :: "'a => bool"
instantiation
  int :: msb
  msb_int == msb :: int => bool
### theory "Word_Lib.Singleton_Bit_Shifts"
### 0.077s elapsed time, 0.229s cpu time, 0.000s GC time
instantiation
  word :: (len) msb
  msb_word == msb :: 'a word => bool
### theory "Word_Lib.Most_significant_bit"
### 0.138s elapsed time, 0.386s cpu time, 0.076s GC time
Loading theory "Word_Lib.Generic_set_bit" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bits_Int")
### theory "Word_Lib.Aligned"
### 0.262s elapsed time, 0.626s cpu time, 0.076s GC time
Loading theory "Word_Lib.Next_and_Prev" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Loading theory "Word_Lib.Word_EqI" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
### theory "Word_Lib.Next_and_Prev"
### 0.053s elapsed time, 0.162s cpu time, 0.000s GC time
class set_bit = semiring_bits +
  fixes set_bit :: "'a => nat => bool => 'a"
  assumes
    "bit_set_bit_iff_2n":
      "!!a m b n.
          bit (set_bit_class.set_bit a m b) n =
          ((if m = n then b else bit a n) & (2::'a) ^ n ~= (0::'a))"
instantiation
  int :: set_bit
  set_bit_int == set_bit_class.set_bit :: int => nat => bool => int
instantiation
  word :: (len) set_bit
  set_bit_word == set_bit_class.set_bit :: 'a word => nat => bool => 'a word
### theory "Word_Lib.Generic_set_bit"
### 0.463s elapsed time, 1.006s cpu time, 0.058s GC time
Loading theory "Word_Lib.Bits_Int" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### theory "Word_Lib.Word_EqI"
### 1.421s elapsed time, 2.957s cpu time, 0.135s GC time
Loading theory "Word_Lib.Word_Lemmas" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### theory "Word_Lib.Bits_Int"
### 1.814s elapsed time, 3.719s cpu time, 0.203s GC time
Loading theory "Word_Lib.Rsplit" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
Loading theory "Word_Lib.Typedef_Morphisms" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bitwise_Signed" via "Word_Lib.Bitwise" via "Word_Lib.Reversed_Bit_Lists")
locale type_definition
  fixes Rep :: "'b => 'a"
    and Abs :: "'a => 'b"
    and A :: "'a set"
  assumes "type_definition Rep Abs A"
### theory "Word_Lib.Rsplit"
### 0.063s elapsed time, 0.194s cpu time, 0.000s GC time
locale td_ext
  fixes Rep :: "'a => 'b"
    and Abs :: "'b => 'a"
    and A :: "'b set"
    and norm :: "'b => 'b"
  assumes "td_ext Rep Abs A norm"
### theory "Word_Lib.Typedef_Morphisms"
### 0.206s elapsed time, 0.476s cpu time, 0.000s GC time
Loading theory "Word_Lib.Reversed_Bit_Lists" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bitwise_Signed" via "Word_Lib.Bitwise")
### theory "Word_Lib.Word_Lemmas"
### 1.336s elapsed time, 2.854s cpu time, 0.255s GC time
Loading theory "Word_Lib.Word_8" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
consts
  takefill :: "'a => nat => 'a list => 'a list"
### theory "Word_Lib.Word_8"
### 0.508s elapsed time, 1.046s cpu time, 0.069s GC time
consts
  bl_to_bin_aux :: "bool list => int => int"
consts
  bin_to_bl_aux :: "nat => int => bool list => bool list"
consts
  rbl_succ :: "bool list => bool list"
consts
  rbl_pred :: "bool list => bool list"
consts
  rbl_add :: "bool list => bool list => bool list"
consts
  rbl_mult :: "bool list => bool list => bool list"
locale Reversed_Bit_Lists.word_rotate
### theory "Word_Lib.Reversed_Bit_Lists"
### 1.485s elapsed time, 2.495s cpu time, 0.199s GC time
Loading theory "Word_Lib.Bitwise" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Bitwise_Signed")
Loading theory "Word_Lib.More_Word_Operations" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo" via "Word_Lib.Word_32")
### Ignoring duplicate rewrite rule:
### map ?f1 [] == []
### Ignoring duplicate rewrite rule:
### map ?f1 (?x21.1 # ?x22.1) == ?f1 ?x21.1 # map ?f1 ?x22.1
### Ignoring duplicate rewrite rule:
### map ?f1 [] == []
### Ignoring duplicate rewrite rule:
### map ?f1 (?x21.1 # ?x22.1) == ?f1 ?x21.1 # map ?f1 ?x22.1
### Ignoring duplicate rewrite rule:
### zip [] ?ys1 == []
### Ignoring duplicate rewrite rule:
### zip (?x1 # ?xs1) (?y1 # ?ys1) == (?x1, ?y1) # zip ?xs1 ?ys1
structure Word_Bitwise_Tac:
  sig
    val expand_upt_simproc: simproc
    val expand_word_eq_sss: simpset * simpset list
    val mk_nat_clist: cterm list -> cterm
    val nat_get_Suc_simproc: int -> term list -> simproc
    val nat_get_Suc_simproc_fn: int -> Proof.context -> cterm -> thm option
    val no_split_ss: simpset
    val tac: Proof.context -> int -> tactic
    val upt_conv: Proof.context -> cterm -> thm option
    val word_len_simproc: simproc
    val word_len_simproc_fn: Proof.context -> cterm -> thm option
    val word_ss: simpset
  end
### theory "Word_Lib.Bitwise"
### 0.219s elapsed time, 0.496s cpu time, 0.115s GC time
Loading theory "Word_Lib.Bitwise_Signed" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
val bw_tac_signed = fn: Proof.context -> int -> tactic
### theory "Word_Lib.Bitwise_Signed"
### 0.164s elapsed time, 0.330s cpu time, 0.000s GC time
### theory "Word_Lib.More_Word_Operations"
### 0.548s elapsed time, 0.896s cpu time, 0.000s GC time
Loading theory "Word_Lib.Word_32" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32" via "Word_Lib.Word_Lib_Sumo")
### theory "Word_Lib.Word_32"
### 0.634s elapsed time, 0.706s cpu time, 0.098s GC time
Loading theory "Word_Lib.Word_Lib_Sumo" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter" via "Draft.Interval_Word32")
bundle no_take_bit
### Rewrite rule not in simpset:
### unsigned (word_of_nat ?n1) == of_nat (take_bit LENGTH(?'b1) ?n1)
### Rewrite rule not in simpset:
### unsigned (word_of_int ?k1) == of_nat (nat (take_bit LENGTH(?'b1) ?k1))
### Rewrite rule not in simpset:
### signed (word_of_int ?n1) ==
### of_int (signed_take_bit (LENGTH(?'b1) - Suc 0) ?n1)
### Rewrite rule not in simpset:
### signed (word_of_nat ?n1) ==
### of_int (signed_take_bit (LENGTH(?'b1) - Suc 0) (int ?n1))
### theory "Word_Lib.Word_Lib_Sumo"
### 1.316s elapsed time, 1.370s cpu time, 0.073s GC time
Loading theory "Draft.Interval_Word32" (required by "Draft.InterpreterMoreTemplates" via "Draft.Interpreter")
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Numeral_Type.bit0" found.
Proofs for inductive predicate(s) "repe"
  Proving monotonicity ...
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Draft.Interval_Word32"
### 4.238s elapsed time, 6.090s cpu time, 2.556s GC time
Loading theory "Draft.Interpreter" (required by "Draft.InterpreterMoreTemplates")
Proofs for inductive predicate(s) "rtsem"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rfsem"
  Proving monotonicity ...
### Ambiguous input (line 133 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.rtsem" ("_position" \<theta>)
###         ("_position" \<nu>) ("_position" r)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" \<omega>)
###           ("_Update" ("_position" \<nu>)
###             ("_updbind" ("_position" x) ("_position" r)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>rpsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.rtsem" ("_position" \<theta>)
###         ("_position" \<nu>) ("_position" r)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" \<omega>)
###           ("_applC" ("_position" \<nu>)
###             ("\<^const>Interpreter.prog.Assign" ("_position" x)
###               ("_position" r)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>rpsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "rpsem"
  Proving monotonicity ...
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Proofs for inductive predicate(s) "wfsem"
  Proving monotonicity ...
### Ambiguous input (line 201 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<phi>) ("_position" \<nu>)
###       ("_position" True)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" \<nu>) ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem"
###         ("_applC" ("\<^const>Interpreter.prog.Test") ("_position" \<phi>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<phi>) ("_position" \<nu>)
###       ("_position" True)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" \<nu>) ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem"
###         ("_applC" ("\<^const>Interpreter.prog.Test") ("_position" \<phi>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<phi>) ("_position" \<nu>)
###       ("_position" True)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" \<nu>) ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem"
###         ("_applC" ("\<^const>Interpreter.prog.Test") ("_position" \<phi>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<phi>) ("_position" \<nu>)
###       ("_position" True)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" \<nu>) ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem"
###         ("_applC" ("\<^const>Interpreter.prog.Test") ("_position" \<phi>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 202 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 8 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<mu>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem" ("_position" \<beta>)
###         ("_position" \<mu>) ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem"
###         ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###           ("_position" \<beta>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<mu>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem" ("_position" \<beta>)
###         ("_position" \<mu>) ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem"
###         ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###           ("_position" \<beta>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<mu>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem" ("_position" \<beta>) ("_position" \<mu>)
###         ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem"
###         ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###           ("_position" \<beta>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<mu>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem" ("_position" \<beta>) ("_position" \<mu>)
###         ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem"
###         ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###           ("_position" \<beta>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<mu>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem" ("_position" \<beta>)
###         ("_position" \<mu>) ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem"
###         ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###           ("_position" \<beta>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<mu>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.wfsem" ("_position" \<beta>)
###         ("_position" \<mu>) ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem"
###         ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###           ("_position" \<beta>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<mu>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem" ("_position" \<beta>) ("_position" \<mu>)
###         ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem"
###         ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###           ("_position" \<beta>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<mu>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem" ("_position" \<beta>) ("_position" \<mu>)
###         ("_position" \<omega>)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>wpsem"
###         ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###           ("_position" \<beta>))
###         ("_position" \<nu>) ("_position" \<omega>)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 203 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 8 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_Update"
###         ("_Update" ("_position" \<nu>)
###           ("_updbind" ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("_updbind" ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_Update"
###         ("_applC" ("_position" \<nu>)
###           ("\<^const>Interpreter.prog.Assign"
###             ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("_updbind" ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_applC"
###         ("_Update" ("_position" \<nu>)
###           ("_updbind" ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("\<^const>Interpreter.prog.Assign"
###           ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_applC"
###         ("_applC" ("_position" \<nu>)
###           ("\<^const>Interpreter.prog.Assign"
###             ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("\<^const>Interpreter.prog.Assign"
###           ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_Update"
###         ("_Update" ("_position" \<nu>)
###           ("_updbind" ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("_updbind" ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_Update"
###         ("_applC" ("_position" \<nu>)
###           ("\<^const>Interpreter.prog.Assign"
###             ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("_updbind" ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_applC"
###         ("_Update" ("_position" \<nu>)
###           ("_updbind" ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("\<^const>Interpreter.prog.Assign"
###           ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_applC"
###         ("_applC" ("_position" \<nu>)
###           ("\<^const>Interpreter.prog.Assign"
###             ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("\<^const>Interpreter.prog.Assign"
###           ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem"
###       ("_applC" ("_position" Assign)
###         ("_cargs" ("_position" x) ("_position" \<theta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 204 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem"
###       ("_applC" ("_position" Choice)
###         ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem"
###       ("_applC" ("_position" Choice)
###         ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem"
###       ("_applC" ("_position" Choice)
###         ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem"
###       ("_applC" ("_position" Choice)
###         ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 205 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<beta>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem"
###       ("_applC" ("_position" Choice)
###         ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<beta>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem"
###       ("_applC" ("_position" Choice)
###         ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<beta>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem"
###       ("_applC" ("_position" Choice)
###         ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem" ("_position" \<beta>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>wpsem"
###       ("_applC" ("_position" Choice)
###         ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###       ("_position" \<nu>) ("_position" \<omega>))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "wpsem"
  Proving monotonicity ...
### Ambiguous input (line 208 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Interpreter.wfsem"
###     ("_applC" ("_position" Test) ("_position" \<phi>)) ("_position" \<nu>)
###     ("_position" b)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Interpreter.wpsem"
###     ("_applC" ("_position" Test) ("_position" \<phi>)) ("_position" \<nu>)
###     ("_position" b)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 209 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Interpreter.wfsem"
###     ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###       ("_position" \<beta>))
###     ("_position" \<nu>) ("_position" b)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Interpreter.wpsem"
###     ("\<^const>Interpreter.prog.Sequence" ("_position" \<alpha>)
###       ("_position" \<beta>))
###     ("_position" \<nu>) ("_position" b)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 210 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Interpreter.wfsem"
###     ("_applC" ("_position" Assign)
###       ("_cargs" ("_position" x) ("_position" \<theta>)))
###     ("_position" \<nu>) ("_position" b)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Interpreter.wpsem"
###     ("_applC" ("_position" Assign)
###       ("_cargs" ("_position" x) ("_position" \<theta>)))
###     ("_position" \<nu>) ("_position" b)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 211 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Interpreter.wfsem"
###     ("_applC" ("_position" Choice)
###       ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###     ("_position" \<nu>) ("_position" b)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Interpreter.wpsem"
###     ("_applC" ("_position" Choice)
###       ("_cargs" ("_position" \<alpha>) ("_position" \<beta>)))
###     ("_position" \<nu>) ("_position" b)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "represents_state"
  Proving monotonicity ...
### Ambiguous input (line 558 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 8 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_applC"
###         ("_applC" ("_position" \<nu>)
###           ("\<^const>Interpreter.prog.Assign"
###             ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("\<^const>Interpreter.prog.Assign"
###           ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.rtsem"
###           ("_constrain" ("_position" \<theta>) ("_type_name" trm))
###           ("_position" \<nu>') ("_position" r)))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###           ("_Update" ("_position" \<nu>')
###             ("_updbind" ("_position" x) ("_position" r))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_applC"
###         ("_Update" ("_position" \<nu>)
###           ("_updbind" ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("\<^const>Interpreter.prog.Assign"
###           ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.rtsem"
###           ("_constrain" ("_position" \<theta>) ("_type_name" trm))
###           ("_position" \<nu>') ("_position" r)))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###           ("_Update" ("_position" \<nu>')
###             ("_updbind" ("_position" x) ("_position" r))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_Update"
###         ("_applC" ("_position" \<nu>)
###           ("\<^const>Interpreter.prog.Assign"
###             ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("_updbind" ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.rtsem"
###           ("_constrain" ("_position" \<theta>) ("_type_name" trm))
###           ("_position" \<nu>') ("_position" r)))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###           ("_Update" ("_position" \<nu>')
###             ("_updbind" ("_position" x) ("_position" r))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_Update"
###         ("_Update" ("_position" \<nu>)
###           ("_updbind" ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("_updbind" ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.rtsem"
###           ("_constrain" ("_position" \<theta>) ("_type_name" trm))
###           ("_position" \<nu>') ("_position" r)))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###           ("_Update" ("_position" \<nu>')
###             ("_updbind" ("_position" x) ("_position" r))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_applC"
###         ("_applC" ("_position" \<nu>)
###           ("\<^const>Interpreter.prog.Assign"
###             ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("\<^const>Interpreter.prog.Assign"
###           ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.rtsem"
###           ("_constrain" ("_position" \<theta>) ("_type_name" trm))
###           ("_position" \<nu>') ("_position" r)))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###           ("_applC" ("_position" \<nu>')
###             ("\<^const>Interpreter.prog.Assign" ("_position" x)
###               ("_position" r))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_applC"
###         ("_Update" ("_position" \<nu>)
###           ("_updbind" ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("\<^const>Interpreter.prog.Assign"
###           ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.rtsem"
###           ("_constrain" ("_position" \<theta>) ("_type_name" trm))
###           ("_position" \<nu>') ("_position" r)))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###           ("_applC" ("_position" \<nu>')
###             ("\<^const>Interpreter.prog.Assign" ("_position" x)
###               ("_position" r))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_Update"
###         ("_applC" ("_position" \<nu>)
###           ("\<^const>Interpreter.prog.Assign"
###             ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("_updbind" ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.rtsem"
###           ("_constrain" ("_position" \<theta>) ("_type_name" trm))
###           ("_position" \<nu>') ("_position" r)))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###           ("_applC" ("_position" \<nu>')
###             ("\<^const>Interpreter.prog.Assign" ("_position" x)
###               ("_position" r))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_position" \<omega>)
###       ("_Update"
###         ("_Update" ("_position" \<nu>)
###           ("_updbind" ("_applC" ("_position" Inr) ("_position" x))
###             ("_applC" ("_position" snd)
###               ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###                 ("_position" \<nu>)))))
###         ("_updbind" ("_applC" ("_position" Inl) ("_position" x))
###           ("_applC" ("_position" fst)
###             ("\<^const>Interpreter.wtsemU" ("_position" \<theta>)
###               ("_position" \<nu>)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.rtsem"
###           ("_constrain" ("_position" \<theta>) ("_type_name" trm))
###           ("_position" \<nu>') ("_position" r)))
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###           ("_applC" ("_position" \<nu>')
###             ("\<^const>Interpreter.prog.Assign" ("_position" x)
###               ("_position" r))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 572 of "$AFP/Interval_Arithmetic_Word32/Interpreter.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wfsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Ex_binder" ("_position" \<omega>')
###         ("\<^const>HOL.conj"
###           ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###             ("_position" \<omega>'))
###           ("\<^const>Interpreter.rpsem" ("_position" \<alpha>)
###             ("_position" \<nu>') ("_position" \<omega>')))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Interpreter.wpsem" ("_position" \<alpha>) ("_position" \<nu>)
###       ("_position" \<omega>)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Interpreter.represents_state" ("_position" \<nu>)
###         ("_position" \<nu>')))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Ex_binder" ("_position" \<omega>')
###         ("\<^const>HOL.conj"
###           ("\<^const>Interpreter.represents_state" ("_position" \<omega>)
###             ("_position" \<omega>'))
###           ("\<^const>Interpreter.rpsem" ("_position" \<alpha>)
###             ("_position" \<nu>') ("_position" \<omega>')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Interpreter"
### 4.388s elapsed time, 6.151s cpu time, 0.399s GC time
Loading theory "Draft.InterpreterMoreTemplates"
val templateLemmas =
   [("Interpreter.eval_tot", "EX r. [?\<theta>]?\<nu>' \<down> r",
     template_predicate (template_app (template_hole 1, t_empty))),
    ("Interpreter.word_rep", "EX r. Rep_bword ?bw \<equiv>\<^sub>E r",
     template_predicate (template_app (template_hole 2, t_empty))),
    ("Interpreter.leq_simp",
     "Leq ?\<theta> ?\<theta>' = Geq ?\<theta>' ?\<theta>",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 1), template_var 0),
       template_app
        (template_app (template_hole 0, template_var 0), template_var 1))),
    ("Interpreter.greater_simp",
     "Greater ?\<theta> ?\<theta>' = ! (Geq ?\<theta>' ?\<theta>)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1), template_var 0),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 0),
           template_var 1)))),
    ("Interpreter.less_simp",
     "Less ?\<theta> ?\<theta>' = ! (Geq ?\<theta> ?\<theta>')",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1), template_var 0),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Interpreter.real_minus_le_minus", "(- ?b <= - ?a) = (?a <= ?b)",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 1, template_var 0), template_var 1))),
    ("Interpreter.rtsem_Const_simps",
     "([Const ?w]?\<nu> \<down> ?r) = (Rep_bword ?w \<equiv>\<^sub>E ?r)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 2)),
         template_var 0))),
    ("Interpreter.rtsem_Var_simps",
     "([Var ?x]?\<nu> \<down> ?r) = (?r = ?\<nu> ?x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 2,
                  template_app (template_hole 1, template_var 2)),
                template_var 1),
              template_var 0)
            )],
       template_equation
        (template_var 0, template_app (template_var 1, template_var 2)))),
    ("Interpreter.or_simp", "(?P || ?Q) = ! (! ?P && ! ?Q)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1), template_var 0),
       template_app
        (template_hole 1,
         template_app
          (template_app
            (template_hole 0,
             template_app (template_hole 1, template_var 1)),
           template_app (template_hole 1, template_var 0))))),
    ("Interpreter.equals_simp",
     "Equals ?\<theta> ?\<theta>' =
      (Geq ?\<theta> ?\<theta>' && Geq ?\<theta>' ?\<theta>)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1), template_var 0),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0)),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_var 1)))),
    ("Interpreter.wVarU",
     "([Var ?x]<>?\<nu>) = (?\<nu> (Inl ?x), ?\<nu> (Inr ?x))",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_var 0,
             template_app (template_hole 1, template_var 1))),
         template_app
          (template_var 0,
           template_app (template_hole 0, template_var 1))))),
    ("Interpreter.rpsem_Test_simps",
     "([? ?\<phi>]?\<nu> \<downharpoonleft> ?b) =
      (([?\<phi>]?\<nu> \<downharpoonright> True) & ?\<nu> = ?b)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 5,
                  template_app (template_hole 4, template_var 2)),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_app (template_hole 2, template_var 2),
                   template_var 1),
                 template_hole 1)),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("Interpreter.wpsem_Test_simps",
     "([[? ?\<phi>]]?\<nu> \<down> ?b) =
      (([[?\<phi>]]?\<nu> \<down> True) & ?\<nu> = ?b)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 5,
                  template_app (template_hole 4, template_var 2)),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_app (template_hole 2, template_var 2),
                   template_var 1),
                 template_hole 1)),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("Interpreter.fml_sound",
     "[| [[?\<phi>]]?\<nu> \<down> ?b; ?\<nu> REP ?\<nu>' |]
      ==> [?\<phi>]?\<nu>' \<downharpoonright> ?b",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 1, template_var 2),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 0),
             template_var 1)
           ))),
    ("Interpreter.rpsem_Choice_simps",
     "([?\<alpha> \<union>\<union> ?\<beta>]?\<nu> \<downharpoonleft> ?b) =
      (([?\<alpha>]?\<nu> \<downharpoonleft> ?b) |
       ([?\<beta>]?\<nu> \<downharpoonleft> ?b))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 1),
             template_var 0)),
         template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_var 0)))),
    ("Interpreter.wpsem_Choice_simps",
     "([[?\<alpha> \<union>\<union> ?\<beta>]]?\<nu> \<down> ?b) =
      (([[?\<alpha>]]?\<nu> \<down> ?b) | ([[?\<beta>]]?\<nu> \<down> ?b))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 1),
             template_var 0)),
         template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_var 0)))),
    ("Interpreter.trm_sound",
     "[| [?\<theta>]?\<nu>' \<down> ?r; ?\<nu> REP ?\<nu>' |]
      ==> [?\<theta>]<>?\<nu> \<equiv>\<^sub>P ?r",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 0),
              template_var 2)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 3),
                 template_var 0)),
             template_var 1)
           ))),
    ("Interpreter.rtsem_Abs_simps",
     "([Abs ?\<theta>]?\<nu> \<down> ?r) =
      (EX r1. ?r = \<bar>r1\<bar> & ([?\<theta>]?\<nu> \<down> r1))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app (template_hole 4, template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 3, t_empty))),
    ("Interpreter.rtsem_Neg_simps",
     "([Neg ?\<theta>]?\<nu> \<down> ?r) =
      (EX r. ?r = - r & ([?\<theta>]?\<nu> \<down> r))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app (template_hole 4, template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 3, t_empty))),
    ("Interpreter.wNegU",
     "([Neg ?\<theta>]<>?\<nu>) =
      (let (l, u) = [?\<theta>]<>?\<nu> in (wneg u, wneg l))",
     template_equation
      (template_app
        (template_app
          (template_hole 5, template_app (template_hole 4, template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 5, template_var 1),
             template_var 0)),
         template_app (template_hole 2, t_empty)))),
    ("Interpreter.real_max_mono",
     "[| ?c <= ?a; ?d <= ?b |] ==> max ?c ?d <= max ?a ?b",
     template_implication
      ([template_inequation (less_equals, template_var 3, template_var 2),
        template_inequation (less_equals, template_var 1, template_var 0)],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 0, template_var 3), template_var 1),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("Interpreter.rpsem_Seq_simps",
     "([?\<alpha> ;; ?\<beta>]?\<nu> \<downharpoonleft> ?b) =
      (EX \<mu>.
          ([?\<alpha>]?\<nu> \<downharpoonleft> \<mu>) &
          ([?\<beta>]\<mu> \<downharpoonleft> ?b))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 1, t_empty))),
    ("Interpreter.wpsem_Seq_simps",
     "([[?\<alpha> ;; ?\<beta>]]?\<nu> \<down> ?b) =
      (EX \<mu>.
          ([[?\<alpha>]]?\<nu> \<down> \<mu>) &
          ([[?\<beta>]]\<mu> \<down> ?b))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 1, t_empty))),
    ("Interpreter.repstate_simps",
     "(?\<nu> REP ?\<nu>') =
      (ALL x.
          (?\<nu> (Inl x) \<equiv>\<^sub>L ?\<nu>' x) &
          (?\<nu> (Inr x) \<equiv>\<^sub>U ?\<nu>' x))",
     template_equation
      (template_app
        (template_app (template_hole 6, template_var 1), template_var 0),
       template_app (template_hole 5, t_empty))),
    ("Interpreter.rpsem_Assign_simps",
     "([?x := ?\<theta>]?\<nu> \<downharpoonleft> ?b) =
      (EX r. ([?\<theta>]?\<nu> \<down> r) & ?b = ?\<nu>(?x := r))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 4, t_empty))),
    ("Interpreter.wAbsU",
     "([Abs ?\<theta>\<^sub>1]<>?\<nu>) =
      (let (l1, u1) = [?\<theta>\<^sub>1]<>?\<nu>
       in (wmax l1 (wneg u1), wmax u1 (wneg l1)))",
     template_equation
      (template_app
        (template_app
          (template_hole 6, template_app (template_hole 5, template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 6, template_var 1),
             template_var 0)),
         template_app (template_hole 3, t_empty)))),
    ("Interpreter.interval_program_sound",
     "[| [[?\<alpha>]]?\<nu> \<down> ?\<omega>; ?\<nu> REP ?\<nu>' |]
      ==> EX \<omega>'.
             (?\<omega> REP \<omega>') &
             ([?\<alpha>]?\<nu>' \<downharpoonleft> \<omega>')",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 2),
              template_var 0)
            )],
       template_predicate (template_app (template_hole 2, t_empty)))),
    ("Interpreter.wpsem_Assign_simps",
     "([[?x := ?\<theta>]]?\<nu> \<down> ?b) =
      (?b = ?\<nu>
       (Inr ?x := snd ([?\<theta>]<>?\<nu>),
        Inl ?x := fst ([?\<theta>]<>?\<nu>)))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 8,
                  template_app
                   (template_app (template_hole 7, template_var 3),
                    template_var 2)),
                template_var 1),
              template_var 0)
            )],
       template_equation
        (template_var 0,
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_app (template_hole 5, template_var 1),
                   template_app (template_hole 4, template_var 3)),
                 template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 2, template_var 2),
                     template_var 1)))),
             template_app (template_hole 1, template_var 3)),
           template_app
            (template_hole 0,
             template_app
              (template_app (template_hole 2, template_var 2),
               template_var 1)))))),
    ("Interpreter.rtsem_Max_simps",
     "([trm.Max ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]?\<nu> \<down> ?r) =
      (EX r1 r2.
          ?r = max r1 r2 &
          ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
          ([?\<theta>\<^sub>2]?\<nu> \<down> r2))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 3, t_empty))),
    ("Interpreter.rtsem_Min_simps",
     "([trm.Min ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]?\<nu> \<down> ?r) =
      (EX r1 r2.
          ?r = min r1 r2 &
          ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
          ([?\<theta>\<^sub>2]?\<nu> \<down> r2))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 3, t_empty))),
    ("Interpreter.rtsem_PlusU_simps",
     "([Plus ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]?\<nu> \<down> ?r) =
      (EX r1 r2.
          ?r = r1 + r2 &
          ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
          ([?\<theta>\<^sub>2]?\<nu> \<down> r2))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 3, t_empty))),
    ("Interpreter.rtsem_TimesU_simps",
     "([Times ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]?\<nu> \<down> ?r) =
      (EX r1 r2.
          ?r = r1 * r2 &
          ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
          ([?\<theta>\<^sub>2]?\<nu> \<down> r2))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app (template_hole 3, t_empty))),
    ("Interpreter.wMaxU",
     "([trm.Max ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]<>?\<nu>) =
      (let (l1, u1) = [?\<theta>\<^sub>1]<>?\<nu>;
           (l2, u2) = [?\<theta>\<^sub>2]<>?\<nu>
       in (wmax l1 l2, wmax u1 u2))",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app (template_hole 4, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 5, template_var 2),
             template_var 0)),
         template_app (template_hole 2, t_empty)))),
    ("Interpreter.wMinU",
     "([trm.Min ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]<>?\<nu>) =
      (let (l1, u1) = [?\<theta>\<^sub>1]<>?\<nu>;
           (l2, u2) = [?\<theta>\<^sub>2]<>?\<nu>
       in (wmin l1 l2, wmin u1 u2))",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app (template_hole 4, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 5, template_var 2),
             template_var 0)),
         template_app (template_hole 2, t_empty)))),
    ("Interpreter.wPlusU",
     "([Plus ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]<>?\<nu>) =
      (let (l1, u1) = [?\<theta>\<^sub>1]<>?\<nu>;
           (l2, u2) = [?\<theta>\<^sub>2]<>?\<nu>
       in (pl l1 l2, pu u1 u2))",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 6, template_var 2),
             template_var 0)),
         template_app (template_hole 3, t_empty)))),
    ("Interpreter.wTimesU",
     "([Times ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]<>?\<nu>) =
      (let (l1, u1) = [?\<theta>\<^sub>1]<>?\<nu>;
           (l2, u2) = [?\<theta>\<^sub>2]<>?\<nu>
       in (Interval_Word32.tl l1 u1 l2 u2, tu l1 u1 l2 u2))",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 6, template_var 2),
             template_var 0)),
         template_app (template_hole 3, t_empty)))),
    ("Interpreter.rep_upd",
     "[| ?\<omega> = ?\<nu>
         (Inr ?x := snd ([?\<theta>]<>?\<nu>),
          Inl ?x := fst ([?\<theta>]<>?\<nu>));
         ?\<nu> REP ?\<nu>'; [?\<theta>]?\<nu>' \<down> ?r |]
      ==> ?\<omega> REP ?\<nu>'(?x := ?r)",
     template_implication
      ([template_equation
         (template_var 5,
          template_app
           (template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app
                   (template_app (template_hole 8, template_var 4),
                    template_app (template_hole 7, template_var 3)),
                  template_app
                   (template_hole 6,
                    template_app
                     (template_app (template_hole 5, template_var 2),
                      template_var 4)))),
              template_app (template_hole 4, template_var 3)),
            template_app
             (template_hole 3,
              template_app
               (template_app (template_hole 5, template_var 2),
                template_var 4)))),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 4),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 2, template_var 5),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 3),
               template_var 0))
           ))),
    ("Interpreter.rfsem_Or_simps",
     "([?\<phi> || ?\<psi>]?\<nu> \<downharpoonright> ?b) =
      (?b & ([?\<phi>]?\<nu> \<downharpoonright> True) |
       ?b & ([?\<psi>]?\<nu> \<downharpoonright> True) |
       ?b & ([! ?\<phi> && ! ?\<psi>]?\<nu> \<downharpoonright> False) |
       ~ ?b & ([! ?\<phi> && ! ?\<psi>]?\<nu> \<downharpoonright> True))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 8,
             template_app
              (template_app (template_hole 7, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_var 0),
             template_app
              (template_app
                (template_app (template_hole 8, template_var 3),
                 template_var 1),
               template_hole 4))),
         template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 5, template_var 0),
               template_app
                (template_app
                  (template_app (template_hole 8, template_var 2),
                   template_var 1),
                 template_hole 4))),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_var 0),
                 template_app
                  (template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_app
                          (template_hole 3,
                           template_app (template_hole 2, template_var 3)),
                         template_app (template_hole 2, template_var 2))),
                     template_var 1),
                   template_hole 1))),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 0, template_var 0)),
               template_app
                (template_app
                  (template_app
                    (template_hole 8,
                     template_app
                      (template_app
                        (template_hole 3,
                         template_app (template_hole 2, template_var 3)),
                       template_app (template_hole 2, template_var 2))),
                   template_var 1),
                 template_hole 4))))))),
    ("Interpreter.wfsem_Or_simps",
     "([[?\<phi> || ?\<psi>]]?\<nu> \<down> ?b) =
      (?b & ([[?\<phi>]]?\<nu> \<down> True) |
       ?b & ([[?\<psi>]]?\<nu> \<down> True) |
       ?b & ([[! ?\<phi> && ! ?\<psi>]]?\<nu> \<down> False) |
       ~ ?b & ([[! ?\<phi> && ! ?\<psi>]]?\<nu> \<down> True))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 8,
             template_app
              (template_app (template_hole 7, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_var 0),
             template_app
              (template_app
                (template_app (template_hole 8, template_var 3),
                 template_var 1),
               template_hole 4))),
         template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 5, template_var 0),
               template_app
                (template_app
                  (template_app (template_hole 8, template_var 2),
                   template_var 1),
                 template_hole 4))),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_var 0),
                 template_app
                  (template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_app
                          (template_hole 3,
                           template_app (template_hole 2, template_var 3)),
                         template_app (template_hole 2, template_var 2))),
                     template_var 1),
                   template_hole 1))),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 0, template_var 0)),
               template_app
                (template_app
                  (template_app
                    (template_hole 8,
                     template_app
                      (template_app
                        (template_hole 3,
                         template_app (template_hole 2, template_var 3)),
                       template_app (template_hole 2, template_var 2))),
                   template_var 1),
                 template_hole 4))))))),
    ("Interpreter.rfsem_Geq_simps",
     "([Geq ?\<theta>\<^sub>1
         ?\<theta>\<^sub>2]?\<nu> \<downharpoonright> ?b) =
      (?b &
       (EX r1.
           ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
           (EX r2. ([?\<theta>\<^sub>2]?\<nu> \<down> r2) & r2 <= r1)) |
       ~ ?b &
       (EX r1.
           ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
           (EX r2. ([?\<theta>\<^sub>2]?\<nu> \<down> r2) & r1 < r2)))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 8,
             template_app
              (template_app (template_hole 7, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_var 0),
             template_app (template_hole 4, t_empty))),
         template_app
          (template_app
            (template_hole 5,
             template_app (template_hole 1, template_var 0)),
           template_app (template_hole 4, t_empty))))),
    ("Interpreter.rfsem_Greater_simps",
     "([Greater ?\<theta>\<^sub>1
         ?\<theta>\<^sub>2]?\<nu> \<downharpoonright> ?b) =
      (?b &
       (EX r1.
           ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
           (EX r2. ([?\<theta>\<^sub>2]?\<nu> \<down> r2) & r2 < r1)) |
       ~ ?b &
       (EX r1.
           ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
           (EX r2. ([?\<theta>\<^sub>2]?\<nu> \<down> r2) & r1 <= r2)) |
       ?b &
       ([Geq ?\<theta>\<^sub>2
          ?\<theta>\<^sub>1]?\<nu> \<downharpoonright> False) |
       ~ ?b &
       ([Geq ?\<theta>\<^sub>2
          ?\<theta>\<^sub>1]?\<nu> \<downharpoonright> True))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 11,
             template_app
              (template_app (template_hole 10, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 9,
           template_app
            (template_app (template_hole 8, template_var 0),
             template_app (template_hole 7, t_empty))),
         template_app
          (template_app
            (template_hole 9,
             template_app
              (template_app
                (template_hole 8,
                 template_app (template_hole 4, template_var 0)),
               template_app (template_hole 7, t_empty))),
           template_app
            (template_app
              (template_hole 9,
               template_app
                (template_app (template_hole 8, template_var 0),
                 template_app
                  (template_app
                    (template_app
                      (template_hole 11,
                       template_app
                        (template_app (template_hole 2, template_var 2),
                         template_var 3)),
                     template_var 1),
                   template_hole 1))),
             template_app
              (template_app
                (template_hole 8,
                 template_app (template_hole 4, template_var 0)),
               template_app
                (template_app
                  (template_app
                    (template_hole 11,
                     template_app
                      (template_app (template_hole 2, template_var 2),
                       template_var 3)),
                   template_var 1),
                 template_hole 0))))))),
    ("Interpreter.rfsem_Equals_simps",
     "([Equals ?\<theta>\<^sub>1
         ?\<theta>\<^sub>2]?\<nu> \<downharpoonright> ?b) =
      (?b &
       (EX r1.
           ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
           ([?\<theta>\<^sub>2]?\<nu> \<down> r1)) |
       ~ ?b &
       (EX r1.
           ([?\<theta>\<^sub>1]?\<nu> \<down> r1) &
           (EX r2. ([?\<theta>\<^sub>2]?\<nu> \<down> r2) & r1 ~= r2)) |
       ?b &
       ([Geq ?\<theta>\<^sub>1
          ?\<theta>\<^sub>2]?\<nu> \<downharpoonright> True) &
       ([Geq ?\<theta>\<^sub>2
          ?\<theta>\<^sub>1]?\<nu> \<downharpoonright> True) |
       ~ ?b &
       ([Geq ?\<theta>\<^sub>1
          ?\<theta>\<^sub>2]?\<nu> \<downharpoonright> False) |
       ~ ?b &
       ([Geq ?\<theta>\<^sub>2
          ?\<theta>\<^sub>1]?\<nu> \<downharpoonright> False) |
       ~ ?b &
       ([Geq ?\<theta>\<^sub>1
          ?\<theta>\<^sub>2]?\<nu> \<downharpoonright> False) &
       ([Geq ?\<theta>\<^sub>2
          ?\<theta>\<^sub>1]?\<nu> \<downharpoonright> False))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 10,
             template_app
              (template_app (template_hole 9, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 8,
           template_app
            (template_app (template_hole 7, template_var 0),
             template_app (template_hole 6, t_empty))),
         template_app
          (template_app
            (template_hole 8,
             template_app
              (template_app
                (template_hole 7,
                 template_app (template_hole 4, template_var 0)),
               template_app (template_hole 6, t_empty))),
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app (template_hole 7, template_var 0),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app
                        (template_app
                          (template_hole 10,
                           template_app
                            (template_app (template_hole 2, template_var 3),
                             template_var 2)),
                         template_var 1),
                       template_hole 1)),
                   template_app
                    (template_app
                      (template_app
                        (template_hole 10,
                         template_app
                          (template_app (template_hole 2, template_var 2),
                           template_var 3)),
                       template_var 1),
                     template_hole 1)))),
             template_app
              (template_app
                (template_hole 8,
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app (template_hole 4, template_var 0)),
                   template_app
                    (template_app
                      (template_app
                        (template_hole 10,
                         template_app
                          (template_app (template_hole 2, template_var 3),
                           template_var 2)),
                       template_var 1),
                     template_hole 0))),
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app (template_hole 4, template_var 0)),
                     template_app
                      (template_app
                        (template_app
                          (template_hole 10,
                           template_app
                            (template_app (template_hole 2, template_var 2),
                             template_var 3)),
                         template_var 1),
                       template_hole 0))),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app (template_hole 4, template_var 0)),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_app
                            (template_hole 10,
                             template_app
                              (template_app
                                (template_hole 2, template_var 3),
                               template_var 2)),
                           template_var 1),
                         template_hole 0)),
                     template_app
                      (template_app
                        (template_app
                          (template_hole 10,
                           template_app
                            (template_app (template_hole 2, template_var 2),
                             template_var 3)),
                         template_var 1),
                       template_hole 0)))))))))),
    ("Interpreter.rfsem_And_simps",
     "([?\<phi> && ?\<psi>]?\<nu> \<downharpoonright> ?b) =
      ((EX \<theta>\<^sub>1 r1 \<theta>\<^sub>2.
           ?\<phi> = Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &
           ?\<psi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ?b &
           ([\<theta>\<^sub>1]?\<nu> \<down> r1) &
           ([\<theta>\<^sub>2]?\<nu> \<down> r1)) |
       (EX \<theta>\<^sub>1 r1 \<theta>\<^sub>2.
           ?\<phi> = Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &
           ?\<psi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ~ ?b &
           ([\<theta>\<^sub>1]?\<nu> \<down> r1) &
           (EX r2. ([\<theta>\<^sub>2]?\<nu> \<down> r2) & r1 ~= r2)) |
       ?b &
       ([?\<phi>]?\<nu> \<downharpoonright> True) &
       ([?\<psi>]?\<nu> \<downharpoonright> True) |
       ~ ?b & ([?\<phi>]?\<nu> \<downharpoonright> False) |
       ~ ?b & ([?\<psi>]?\<nu> \<downharpoonright> False) |
       ~ ?b &
       ([?\<phi>]?\<nu> \<downharpoonright> False) &
       ([?\<psi>]?\<nu> \<downharpoonright> False))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 12,
             template_app
              (template_app (template_hole 11, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 10, template_app (template_hole 9, t_empty)),
         template_app
          (template_app
            (template_hole 10, template_app (template_hole 9, t_empty)),
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app (template_hole 7, template_var 0),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app
                        (template_app (template_hole 12, template_var 3),
                         template_var 1),
                       template_hole 1)),
                   template_app
                    (template_app
                      (template_app (template_hole 12, template_var 2),
                       template_var 1),
                     template_hole 1)))),
             template_app
              (template_app
                (template_hole 10,
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app (template_hole 3, template_var 0)),
                   template_app
                    (template_app
                      (template_app (template_hole 12, template_var 3),
                       template_var 1),
                     template_hole 0))),
               template_app
                (template_app
                  (template_hole 10,
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app (template_hole 3, template_var 0)),
                     template_app
                      (template_app
                        (template_app (template_hole 12, template_var 2),
                         template_var 1),
                       template_hole 0))),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app (template_hole 3, template_var 0)),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_app (template_hole 12, template_var 3),
                           template_var 1),
                         template_hole 0)),
                     template_app
                      (template_app
                        (template_app (template_hole 12, template_var 2),
                         template_var 1),
                       template_hole 0)))))))))),
    ("Interpreter.rfsem_Not_simps",
     "([! ?\<phi>]?\<nu> \<downharpoonright> ?b) =
      ((EX \<theta>\<^sub>1 r1 \<theta>\<^sub>2.
           ?\<phi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ?b &
           ([\<theta>\<^sub>1]?\<nu> \<down> r1) &
           (EX r2. ([\<theta>\<^sub>2]?\<nu> \<down> r2) & r2 < r1)) |
       (EX \<theta>\<^sub>1 r1 \<theta>\<^sub>2.
           ?\<phi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ~ ?b &
           ([\<theta>\<^sub>1]?\<nu> \<down> r1) &
           (EX r2. ([\<theta>\<^sub>2]?\<nu> \<down> r2) & r1 <= r2)) |
       (EX \<phi>.
           (EX \<psi>. ?\<phi> = (! \<phi> && ! \<psi>)) &
           ?b & ([\<phi>]?\<nu> \<downharpoonright> True)) |
       (EX \<psi>.
           (EX \<phi>. ?\<phi> = (! \<phi> && ! \<psi>)) &
           ?b & ([\<psi>]?\<nu> \<downharpoonright> True)) |
       ?b & ([?\<phi>]?\<nu> \<downharpoonright> False) |
       ~ ?b & ([?\<phi>]?\<nu> \<downharpoonright> True))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 15,
             template_app (template_hole 14, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 13, template_app (template_hole 12, t_empty)),
         template_app
          (template_app
            (template_hole 13, template_app (template_hole 12, t_empty)),
           template_app
            (template_app
              (template_hole 13, template_app (template_hole 3, t_empty)),
             template_app
              (template_app
                (template_hole 13, template_app (template_hole 3, t_empty)),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_app (template_hole 10, template_var 0),
                     template_app
                      (template_app
                        (template_app (template_hole 15, template_var 2),
                         template_var 1),
                       template_hole 0))),
                 template_app
                  (template_app
                    (template_hole 10,
                     template_app (template_hole 5, template_var 0)),
                   template_app
                    (template_app
                      (template_app (template_hole 15, template_var 2),
                       template_var 1),
                     template_hole 1))))))))),
    ("Interpreter.wfsem_Equals_simps",
     "([[Equals ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]]?\<nu> \<down> ?b) =
      (?b &
       fst ([?\<theta>\<^sub>2]<>?\<nu>) =
       snd ([?\<theta>\<^sub>2]<>?\<nu>) &
       snd ([?\<theta>\<^sub>2]<>?\<nu>) =
       snd ([?\<theta>\<^sub>1]<>?\<nu>) &
       snd ([?\<theta>\<^sub>1]<>?\<nu>) =
       fst ([?\<theta>\<^sub>1]<>?\<nu>) &
       fst ([?\<theta>\<^sub>2]<>?\<nu>) ~= 0x80000001 &
       fst ([?\<theta>\<^sub>2]<>?\<nu>) ~= 0x7FFFFFFF |
       ~ ?b &
       sint (snd ([?\<theta>\<^sub>2]<>?\<nu>))
       < sint (fst ([?\<theta>\<^sub>1]<>?\<nu>)) |
       ~ ?b &
       sint (snd ([?\<theta>\<^sub>1]<>?\<nu>))
       < sint (fst ([?\<theta>\<^sub>2]<>?\<nu>)) |
       ?b &
       ([[Geq ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]]?\<nu> \<down> True) &
       ([[Geq ?\<theta>\<^sub>2 ?\<theta>\<^sub>1]]?\<nu> \<down> True) |
       ~ ?b &
       ([[Geq ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]]?\<nu> \<down> False) |
       ~ ?b &
       ([[Geq ?\<theta>\<^sub>2 ?\<theta>\<^sub>1]]?\<nu> \<down> False) |
       ~ ?b &
       ([[Geq ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]]?\<nu> \<down> False) &
       ([[Geq ?\<theta>\<^sub>2 ?\<theta>\<^sub>1]]?\<nu> \<down> False))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 17,
                  template_app
                   (template_app (template_hole 16, template_var 3),
                    template_var 2)),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 15,
               template_app
                (template_app (template_hole 14, template_var 0),
                 template_app
                  (template_app
                    (template_hole 14,
                     template_app
                      (template_app
                        (template_hole 13,
                         template_app
                          (template_hole 12,
                           template_app
                            (template_app
                              (template_hole 11, template_var 2),
                             template_var 1))),
                       template_app
                        (template_hole 10,
                         template_app
                          (template_app (template_hole 11, template_var 2),
                           template_var 1)))),
                   template_app
                    (template_app
                      (template_hole 14,
                       template_app
                        (template_app
                          (template_hole 13,
                           template_app
                            (template_hole 10,
                             template_app
                              (template_app
                                (template_hole 11, template_var 2),
                               template_var 1))),
                         template_app
                          (template_hole 10,
                           template_app
                            (template_app
                              (template_hole 11, template_var 3),
                             template_var 1)))),
                     template_app
                      (template_app
                        (template_hole 14,
                         template_app
                          (template_app
                            (template_hole 13,
                             template_app
                              (template_hole 10,
                               template_app
                                (template_app
                                  (template_hole 11, template_var 3),
                                 template_var 1))),
                           template_app
                            (template_hole 12,
                             template_app
                              (template_app
                                (template_hole 11, template_var 3),
                               template_var 1)))),
                       template_app
                        (template_app
                          (template_hole 14,
                           template_app
                            (template_hole 9,
                             template_app
                              (template_app
                                (template_hole 13,
                                 template_app
                                  (template_hole 12,
                                   template_app
                                    (template_app
(template_hole 11, template_var 2),
                                     template_var 1))),
                               template_app
                                (template_hole 8,
                                 template_app
                                  (template_hole 7,
                                   template_app
                                    (template_hole 6,
                                     template_app
(template_hole 6,
 template_app
  (template_hole 6,
   template_app
    (template_hole 6,
     template_app
      (template_hole 6,
       template_app
        (template_hole 6,
         template_app
          (template_hole 6,
           template_app
            (template_hole 6,
             template_app
              (template_hole 6,
               template_app
                (template_hole 6,
                 template_app
                  (template_hole 6,
                   template_app
                    (template_hole 6,
                     template_app
                      (template_hole 6,
                       template_app
                        (template_hole 6,
                         template_app
                          (template_hole 6,
                           template_app
                            (template_hole 6,
                             template_app
                              (template_hole 6,
                               template_app
                                (template_hole 6,
                                 template_app
                                  (template_hole 6,
                                   template_app
                                    (template_hole 6,
                                     template_app
(template_hole 6,
 template_app
  (template_hole 6,
   template_app
    (template_hole 6,
     template_app
      (template_hole 6,
       template_app
        (template_hole 6,
         template_app
          (template_hole 6,
           template_app
            (template_hole 6,
             template_app
              (template_hole 6,
               template_app
                (template_hole 6,
                 template_app
                  (template_hole 6,
                   template_hole 5))))))))))))))))))))))))))))))))))),
                         template_app
                          (template_hole 9,
                           template_app
                            (template_app
                              (template_hole 13,
                               template_app
                                (template_hole 12,
                                 template_app
                                  (template_app
                                    (template_hole 11, template_var 2),
                                   template_var 1))),
                             template_app
                              (template_hole 8,
                               template_app
                                (template_hole 7,
                                 template_app
                                  (template_hole 7,
                                   template_app
                                    (template_hole 7,
                                     template_app
(template_hole 7,
 template_app
  (template_hole 7,
   template_app
    (template_hole 7,
     template_app
      (template_hole 7,
       template_app
        (template_hole 7,
         template_app
          (template_hole 7,
           template_app
            (template_hole 7,
             template_app
              (template_hole 7,
               template_app
                (template_hole 7,
                 template_app
                  (template_hole 7,
                   template_app
                    (template_hole 7,
                     template_app
                      (template_hole 7,
                       template_app
                        (template_hole 7,
                         template_app
                          (template_hole 7,
                           template_app
                            (template_hole 7,
                             template_app
                              (template_hole 7,
                               template_app
                                (template_hole 7,
                                 template_app
                                  (template_hole 7,
                                   template_app
                                    (template_hole 7,
                                     template_app
(template_hole 7,
 template_app
  (template_hole 7,
   template_app
    (template_hole 7,
     template_app
      (template_hole 7,
       template_app
        (template_hole 7,
         template_app
          (template_hole 7,
           template_app
            (template_hole 7,
             template_app
              (template_hole 7,
               template_hole 5))))))))))))))))))))))))))))))))))))))),
             template_app
              (template_app
                (template_hole 15,
                 template_app
                  (template_app
                    (template_hole 14,
                     template_app (template_hole 9, template_var 0)),
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_hole 3,
                         template_app
                          (template_hole 10,
                           template_app
                            (template_app
                              (template_hole 11, template_var 2),
                             template_var 1)))),
                     template_app
                      (template_hole 3,
                       template_app
                        (template_hole 12,
                         template_app
                          (template_app (template_hole 11, template_var 3),
                           template_var 1)))))),
               template_app
                (template_app
                  (template_hole 15,
                   template_app
                    (template_app
                      (template_hole 14,
                       template_app (template_hole 9, template_var 0)),
                     template_app
                      (template_app
                        (template_hole 4,
                         template_app
                          (template_hole 3,
                           template_app
                            (template_hole 10,
                             template_app
                              (template_app
                                (template_hole 11, template_var 3),
                               template_var 1)))),
                       template_app
                        (template_hole 3,
                         template_app
                          (template_hole 12,
                           template_app
                            (template_app
                              (template_hole 11, template_var 2),
                             template_var 1)))))),
                 template_app
                  (template_app
                    (template_hole 15,
                     template_app
                      (template_app (template_hole 14, template_var 0),
                       template_app
                        (template_app
                          (template_hole 14,
                           template_app
                            (template_app
                              (template_app
                                (template_hole 17,
                                 template_app
                                  (template_app
                                    (template_hole 2, template_var 3),
                                   template_var 2)),
                               template_var 1),
                             template_hole 1)),
                         template_app
                          (template_app
                            (template_app
                              (template_hole 17,
                               template_app
                                (template_app
                                  (template_hole 2, template_var 2),
                                 template_var 3)),
                             template_var 1),
                           template_hole 1)))),
                   template_app
                    (template_app
                      (template_hole 15,
                       template_app
                        (template_app
                          (template_hole 14,
                           template_app (template_hole 9, template_var 0)),
                         template_app
                          (template_app
                            (template_app
                              (template_hole 17,
                               template_app
                                (template_app
                                  (template_hole 2, template_var 3),
                                 template_var 2)),
                             template_var 1),
                           template_hole 0))),
                     template_app
                      (template_app
                        (template_hole 15,
                         template_app
                          (template_app
                            (template_hole 14,
                             template_app
                              (template_hole 9, template_var 0)),
                           template_app
                            (template_app
                              (template_app
                                (template_hole 17,
                                 template_app
                                  (template_app
                                    (template_hole 2, template_var 2),
                                   template_var 3)),
                               template_var 1),
                             template_hole 0))),
                       template_app
                        (template_app
                          (template_hole 14,
                           template_app (template_hole 9, template_var 0)),
                         template_app
                          (template_app
                            (template_hole 14,
                             template_app
                              (template_app
                                (template_app
                                  (template_hole 17,
                                   template_app
                                    (template_app
(template_hole 2, template_var 3),
                                     template_var 2)),
                                 template_var 1),
                               template_hole 0)),
                           template_app
                            (template_app
                              (template_app
                                (template_hole 17,
                                 template_app
                                  (template_app
                                    (template_hole 2, template_var 2),
                                   template_var 3)),
                               template_var 1),
                             template_hole 0)))))))))
           ))),
    ("Interpreter.wfsem_And_simps",
     "([[?\<phi> && ?\<psi>]]?\<nu> \<down> ?b) =
      ((EX \<theta>\<^sub>2 \<theta>\<^sub>1.
           ?\<phi> = Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &
           ?\<psi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ?b &
           fst ([\<theta>\<^sub>2]<>?\<nu>) =
           snd ([\<theta>\<^sub>2]<>?\<nu>) &
           snd ([\<theta>\<^sub>2]<>?\<nu>) =
           snd ([\<theta>\<^sub>1]<>?\<nu>) &
           snd ([\<theta>\<^sub>1]<>?\<nu>) =
           fst ([\<theta>\<^sub>1]<>?\<nu>) &
           fst ([\<theta>\<^sub>2]<>?\<nu>) ~= 0x80000001 &
           fst ([\<theta>\<^sub>2]<>?\<nu>) ~= 0x7FFFFFFF) |
       (EX \<theta>\<^sub>1 \<theta>\<^sub>2.
           ?\<phi> = Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &
           ?\<psi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ~ ?b &
           sint (snd ([\<theta>\<^sub>2]<>?\<nu>))
           < sint (fst ([\<theta>\<^sub>1]<>?\<nu>))) |
       (EX \<theta>\<^sub>2 \<theta>\<^sub>1.
           ?\<phi> = Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &
           ?\<psi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ~ ?b &
           sint (snd ([\<theta>\<^sub>1]<>?\<nu>))
           < sint (fst ([\<theta>\<^sub>2]<>?\<nu>))) |
       ?b &
       ([[?\<phi>]]?\<nu> \<down> True) & ([[?\<psi>]]?\<nu> \<down> True) |
       ~ ?b & ([[?\<phi>]]?\<nu> \<down> False) |
       ~ ?b & ([[?\<psi>]]?\<nu> \<down> False) |
       ~ ?b &
       ([[?\<phi>]]?\<nu> \<down> False) &
       ([[?\<psi>]]?\<nu> \<down> False))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 19,
             template_app
              (template_app (template_hole 18, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 17, template_app (template_hole 16, t_empty)),
         template_app
          (template_app
            (template_hole 17, template_app (template_hole 16, t_empty)),
           template_app
            (template_app
              (template_hole 17, template_app (template_hole 16, t_empty)),
             template_app
              (template_app
                (template_hole 17,
                 template_app
                  (template_app (template_hole 15, template_var 0),
                   template_app
                    (template_app
                      (template_hole 15,
                       template_app
                        (template_app
                          (template_app (template_hole 19, template_var 3),
                           template_var 1),
                         template_hole 1)),
                     template_app
                      (template_app
                        (template_app (template_hole 19, template_var 2),
                         template_var 1),
                       template_hole 1)))),
               template_app
                (template_app
                  (template_hole 17,
                   template_app
                    (template_app
                      (template_hole 15,
                       template_app (template_hole 8, template_var 0)),
                     template_app
                      (template_app
                        (template_app (template_hole 19, template_var 3),
                         template_var 1),
                       template_hole 0))),
                 template_app
                  (template_app
                    (template_hole 17,
                     template_app
                      (template_app
                        (template_hole 15,
                         template_app (template_hole 8, template_var 0)),
                       template_app
                        (template_app
                          (template_app (template_hole 19, template_var 2),
                           template_var 1),
                         template_hole 0))),
                   template_app
                    (template_app
                      (template_hole 15,
                       template_app (template_hole 8, template_var 0)),
                     template_app
                      (template_app
                        (template_hole 15,
                         template_app
                          (template_app
                            (template_app
                              (template_hole 19, template_var 3),
                             template_var 1),
                           template_hole 0)),
                       template_app
                        (template_app
                          (template_app (template_hole 19, template_var 2),
                           template_var 1),
                         template_hole 0))))))))))),
    ("Interpreter.wfsem_Not_simps",
     "([[! ?\<phi>]]?\<nu> \<down> ?b) =
      ((EX \<theta>\<^sub>1 \<theta>\<^sub>2.
           ?\<phi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ?b &
           sint (snd ([\<theta>\<^sub>2]<>?\<nu>))
           < sint (fst ([\<theta>\<^sub>1]<>?\<nu>))) |
       (EX \<theta>\<^sub>2 \<theta>\<^sub>1.
           ?\<phi> = Geq \<theta>\<^sub>2 \<theta>\<^sub>1 &
           ~ ?b &
           (snd ([\<theta>\<^sub>1]<>?\<nu>) = 0x80000001 -->
            fst ([\<theta>\<^sub>2]<>?\<nu>) ~= 0x80000001) &
           (snd ([\<theta>\<^sub>1]<>?\<nu>) = 0x7FFFFFFF -->
            fst ([\<theta>\<^sub>2]<>?\<nu>) ~= 0x7FFFFFFF) &
           sint (snd ([\<theta>\<^sub>1]<>?\<nu>))
           <= sint (fst ([\<theta>\<^sub>2]<>?\<nu>))) |
       (EX \<phi>.
           (EX \<psi>. ?\<phi> = (! \<phi> && ! \<psi>)) &
           ?b & ([[\<phi>]]?\<nu> \<down> True)) |
       (EX \<psi>.
           (EX \<phi>. ?\<phi> = (! \<phi> && ! \<psi>)) &
           ?b & ([[\<psi>]]?\<nu> \<down> True)) |
       ?b & ([[?\<phi>]]?\<nu> \<down> False) |
       ~ ?b & ([[?\<phi>]]?\<nu> \<down> True))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 23,
             template_app (template_hole 22, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 21, template_app (template_hole 20, t_empty)),
         template_app
          (template_app
            (template_hole 21, template_app (template_hole 20, t_empty)),
           template_app
            (template_app
              (template_hole 21, template_app (template_hole 3, t_empty)),
             template_app
              (template_app
                (template_hole 21, template_app (template_hole 3, t_empty)),
               template_app
                (template_app
                  (template_hole 21,
                   template_app
                    (template_app (template_hole 19, template_var 0),
                     template_app
                      (template_app
                        (template_app (template_hole 23, template_var 2),
                         template_var 1),
                       template_hole 0))),
                 template_app
                  (template_app
                    (template_hole 19,
                     template_app (template_hole 11, template_var 0)),
                   template_app
                    (template_app
                      (template_app (template_hole 23, template_var 2),
                       template_var 1),
                     template_hole 1))))))))),
    ("Interpreter.wfsem_Gr_simps",
     "([[?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2]]?\<nu> \<down> ?b) =
      ((EX \<theta>\<^sub>1 \<theta>\<^sub>2.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
           ! (Geq \<theta>\<^sub>2 \<theta>\<^sub>1) &
           ?b &
           sint (snd ([\<theta>\<^sub>2]<>?\<nu>))
           < sint (fst ([\<theta>\<^sub>1]<>?\<nu>))) |
       (EX \<theta>\<^sub>2 \<theta>\<^sub>1.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
           ! (Geq \<theta>\<^sub>2 \<theta>\<^sub>1) &
           ~ ?b &
           (snd ([\<theta>\<^sub>1]<>?\<nu>) = 0x80000001 -->
            fst ([\<theta>\<^sub>2]<>?\<nu>) ~= 0x80000001) &
           (snd ([\<theta>\<^sub>1]<>?\<nu>) = 0x7FFFFFFF -->
            fst ([\<theta>\<^sub>2]<>?\<nu>) ~= 0x7FFFFFFF) &
           sint (snd ([\<theta>\<^sub>1]<>?\<nu>))
           <= sint (fst ([\<theta>\<^sub>2]<>?\<nu>))) |
       (EX \<theta>\<^sub>1 \<theta>\<^sub>2.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
           Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &
           ?b &
           (snd ([\<theta>\<^sub>2]<>?\<nu>) = 0x80000001 -->
            fst ([\<theta>\<^sub>1]<>?\<nu>) ~= 0x80000001) &
           (snd ([\<theta>\<^sub>2]<>?\<nu>) = 0x7FFFFFFF -->
            fst ([\<theta>\<^sub>1]<>?\<nu>) ~= 0x7FFFFFFF) &
           sint (snd ([\<theta>\<^sub>2]<>?\<nu>))
           <= sint (fst ([\<theta>\<^sub>1]<>?\<nu>))) |
       (EX \<theta>\<^sub>2 \<theta>\<^sub>1.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
           Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &
           ~ ?b &
           sint (snd ([\<theta>\<^sub>1]<>?\<nu>))
           < sint (fst ([\<theta>\<^sub>2]<>?\<nu>))) |
       (EX \<theta>\<^sub>2 \<theta>\<^sub>1.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
           (Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &&
            Geq \<theta>\<^sub>2 \<theta>\<^sub>1) &
           ?b &
           fst ([\<theta>\<^sub>2]<>?\<nu>) =
           snd ([\<theta>\<^sub>2]<>?\<nu>) &
           snd ([\<theta>\<^sub>2]<>?\<nu>) =
           snd ([\<theta>\<^sub>1]<>?\<nu>) &
           snd ([\<theta>\<^sub>1]<>?\<nu>) =
           fst ([\<theta>\<^sub>1]<>?\<nu>) &
           fst ([\<theta>\<^sub>2]<>?\<nu>) ~= 0x80000001 &
           fst ([\<theta>\<^sub>2]<>?\<nu>) ~= 0x7FFFFFFF) |
       (EX \<theta>\<^sub>1 \<theta>\<^sub>2.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
           (Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &&
            Geq \<theta>\<^sub>2 \<theta>\<^sub>1) &
           ~ ?b &
           sint (snd ([\<theta>\<^sub>2]<>?\<nu>))
           < sint (fst ([\<theta>\<^sub>1]<>?\<nu>))) |
       (EX \<theta>\<^sub>2 \<theta>\<^sub>1.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
           (Geq \<theta>\<^sub>1 \<theta>\<^sub>2 &&
            Geq \<theta>\<^sub>2 \<theta>\<^sub>1) &
           ~ ?b &
           sint (snd ([\<theta>\<^sub>1]<>?\<nu>))
           < sint (fst ([\<theta>\<^sub>2]<>?\<nu>))) |
       (EX \<phi> \<psi>.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 = (\<phi> && \<psi>) &
           ?b &
           ([[\<phi>]]?\<nu> \<down> True) &
           ([[\<psi>]]?\<nu> \<down> True)) |
       (EX \<phi>.
           (EX \<psi>.
               ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
               (\<phi> && \<psi>)) &
           ~ ?b & ([[\<phi>]]?\<nu> \<down> False)) |
       (EX \<psi>.
           (EX \<phi>.
               ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
               (\<phi> && \<psi>)) &
           ~ ?b & ([[\<psi>]]?\<nu> \<down> False)) |
       (EX \<phi>.
           (EX \<psi>.
               ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
               ! (! \<phi> && ! \<psi>)) &
           ?b & ([[\<phi>]]?\<nu> \<down> True)) |
       (EX \<psi>.
           (EX \<phi>.
               ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 =
               ! (! \<phi> && ! \<psi>)) &
           ?b & ([[\<psi>]]?\<nu> \<down> True)) |
       (EX \<phi> \<psi>.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 = (\<phi> && \<psi>) &
           ~ ?b &
           ([[\<phi>]]?\<nu> \<down> False) &
           ([[\<psi>]]?\<nu> \<down> False)) |
       (EX \<phi>.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 = ! \<phi> &
           ?b & ([[\<phi>]]?\<nu> \<down> False)) |
       (EX \<phi>.
           ?Le ?\<theta>\<^sub>1 ?\<theta>\<^sub>2 = ! \<phi> &
           ~ ?b & ([[\<phi>]]?\<nu> \<down> True)))",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 23,
             template_app
              (template_app (template_var 4, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 22, template_app (template_hole 21, t_empty)),
         template_app
          (template_app
            (template_hole 22, template_app (template_hole 21, t_empty)),
           template_app
            (template_app
              (template_hole 22, template_app (template_hole 21, t_empty)),
             template_app
              (template_app
                (template_hole 22,
                 template_app (template_hole 21, t_empty)),
               template_app
                (template_app
                  (template_hole 22,
                   template_app (template_hole 21, t_empty)),
                 template_app
                  (template_app
                    (template_hole 22,
                     template_app (template_hole 21, t_empty)),
                   template_app
                    (template_app
                      (template_hole 22,
                       template_app (template_hole 21, t_empty)),
                     template_app
                      (template_app
                        (template_hole 22,
                         template_app (template_hole 2, t_empty)),
                       template_app
                        (template_app
                          (template_hole 22,
                           template_app (template_hole 2, t_empty)),
                         template_app
                          (template_app
                            (template_hole 22,
                             template_app (template_hole 2, t_empty)),
                           template_app
                            (template_app
                              (template_hole 22,
                               template_app (template_hole 2, t_empty)),
                             template_app
                              (template_app
                                (template_hole 22,
                                 template_app (template_hole 2, t_empty)),
                               template_app
                                (template_app
                                  (template_hole 22,
                                   template_app (template_hole 2, t_empty)),
                                 template_app
                                  (template_app
                                    (template_hole 22,
                                     template_app
(template_hole 2, t_empty)),
                                   template_app
                                    (template_hole 2,
                                     t_empty)))))))))))))))))]:
   (string * thm * template) list
### theory "Draft.InterpreterMoreTemplates"
### 0.615s elapsed time, 0.878s cpu time, 0.051s GC time
val it = (): unit
