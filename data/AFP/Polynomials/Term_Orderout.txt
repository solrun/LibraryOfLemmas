Loading theory "Draft.OAlist" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping")
Loading theory "Draft.MPoly_Type" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products" via "Draft.More_MPoly_Type")
Loading theory "Draft.More_Modules" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.MPoly_Type_Class_Ordered" via "Draft.MPoly_Type_Class")
Loading theory "Draft.Templates" (required by "Draft.Term_OrderTemplates" via "Draft.ExtrEqs")
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.069s elapsed time, 0.301s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Term_OrderTemplates")
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
instantiation
  mpoly :: (zero) zero
  zero_mpoly == zero_class.zero :: 'a mpoly
### Missing patterns in function definition:
### !!a. min_list_param a [] = undefined
instantiation
  mpoly :: (monoid_add) monoid_add
  plus_mpoly == plus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_mpoly == minus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (ab_group_add) ab_group_add
  uminus_mpoly == uminus :: 'a mpoly => 'a mpoly
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  mpoly :: (zero_neq_one) zero_neq_one
  one_mpoly == one_class.one :: 'a mpoly
instantiation
  mpoly :: (semiring_0) semiring_0
  times_mpoly == times :: 'a mpoly => 'a mpoly => 'a mpoly
### theory "Draft.More_Modules"
### 0.222s elapsed time, 0.871s cpu time, 0.059s GC time
Loading theory "Draft.Utils" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products")
instantiation
  key_order :: (type) equal
  equal_key_order == equal_class.equal ::
    'a key_order => 'a key_order => bool
instantiation
  key_order :: (type) uminus
  uminus_key_order == uminus :: 'a key_order => 'a key_order
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### linorder.Min (le_of_key_order ?ko) (set (?x # ?xs)) ==
### fold (key_order_lin.min ?ko) ?xs ?x
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### linorder.Max (le_of_key_order ?ko) (set (?x # ?xs)) ==
### fold (key_order_lin.max ?ko) ?xs ?x
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko [] == True
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko [?x] == True
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko (?x # ?y # ?zs) ==
### le_of_key_order ?ko ?x ?y & key_order_lin.sorted ?ko (?y # ?zs)
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted_list_of_set ?ko (set ?xs) ==
### key_order_lin.sort ?ko (remdups ?xs)
### Ambiguous input (line 494 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>div" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### Ambiguous input (line 498 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>mod" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 502 of "$AFP/Polynomials/MPoly_Type.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 505 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 509 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.MPoly_Type"
### 0.542s elapsed time, 2.076s cpu time, 0.283s GC time
Loading theory "Draft.More_MPoly_Type" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products")
### theory "Draft.Utils"
### 0.333s elapsed time, 1.259s cpu time, 0.225s GC time
MPoly (mapping_of ?x) = ?x
?y : UNIV ==> mapping_of (MPoly ?y) = ?y
(mapping_of ?x = mapping_of ?y) = (?x = ?y)
[| ?x : UNIV; ?y : UNIV |] ==> (MPoly ?x = MPoly ?y) = (?x = ?y)
[| ?y : UNIV; !!x. ?P (mapping_of x) |] ==> ?P ?y
(!!y. y : UNIV ==> ?P (MPoly y)) ==> ?P ?x
[| ?y : UNIV; !!x. ?y = mapping_of x ==> ?P |] ==> ?P
(!!y. [| ?x = MPoly y; y : UNIV |] ==> ?P) ==> ?P
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.720s elapsed time, 2.704s cpu time, 0.434s GC time
locale comparator
  fixes comp :: "'a => 'a => order"
  assumes "comparator comp"
### theory "Draft.More_MPoly_Type"
### 0.287s elapsed time, 1.037s cpu time, 0.151s GC time
Loading theory "Draft.Power_Products" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type")
"(Gcd (coeffs
        (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
          6 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
          8)),
  sdiv
   (Gcd (coeffs
          (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
            6 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
            8)))
   (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
    M [(1::'b) + (1::'b), 0::'b, (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
     6 +
    M [(1::'b) + (1::'b), 0::'b,
       (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
     8))"
  :: "'a * 'a mpoly"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. size_list size (snd (snd (snd (snd p))))) <*mlex*>
   (%p. size_list size (fst (snd (snd (snd p))))) <*mlex*> {}"
class plus = type +
  fixes plus :: "'a => 'a => 'a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
Found termination order:
  "(%p. size_list size (snd (snd p))) <*mlex*>
   (%p. size_list size (fst (snd p))) <*mlex*> {}"
class ninv_comm_monoid_add = comm_monoid_add +
  assumes "plus_eq_zero": "!!s t. s + t = (0::'a) ==> s = (0::'a)"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
Found termination order:
  "(%p. size_list size (snd (snd p))) <*mlex*>
   (%p. size_list size (fst (snd p))) <*mlex*> {}"
class lcs_powerprod = comm_powerprod +
  fixes lcs :: "'a => 'a => 'a"
  assumes "adds_lcs": "!!s t. s adds lcs s t"
  assumes "lcs_adds": "!!s u t. [| s adds u; t adds u |] ==> lcs s t adds u"
  assumes "lcs_comm": "!!s t. lcs s t = lcs t s"
class graded_dickson_powerprod = ulcs_powerprod +
  assumes "ex_dgrad": "EX d. dickson_grading d"
class dickson_powerprod = ulcs_powerprod +
  assumes "dickson": "almost_full_on (adds) UNIV"
locale comparator2
  fixes comp1 :: "'a => 'a => order"
    and comp2 :: "'a => 'a => order"
  assumes "comparator2 comp1 comp2"
locale oalist_raw
  fixes rep_key_order :: "'o => 'a key_order"
class semi_canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_imp_add": "!!a b. a <= b ==> EX c. b = a + c"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  ninv_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
[| le ?x ?a ?b; le ?x ?b ?c |] ==> le ?x ?a ?c
[| le ?x ?a ?b; le ?x ?b ?c |] ==> le ?x ?a ?c
[| ?a <= ?b; ?b <= ?c |] ==> ?a <= ?c
[| le ?xa ?x ?y; le ?xa ?y ?z |] ==> le ?xa ?x ?z
locale oalist_raw
  fixes rep_key_order :: "'o => 'a key_order"
class add_linorder_min = add_linorder +
  assumes "zero_min": "!!x. (0::'a) <= x"
locale oalist_abstract
  fixes rep_key_order :: "'o => 'a key_order"
    and list_of_oalist :: "'x => ('a * 'b) list * 'o"
    and oalist_of_list :: "('a * 'b) list * 'o => 'x"
  assumes "oalist_abstract rep_key_order list_of_oalist oalist_of_list"
instantiation
  nat :: add_linorder
instantiation
  nat :: add_linorder_min
instantiation
  nat :: add_wellorder
instantiation
  int :: add_linorder_group
instantiation
  rat :: add_linorder_group
instantiation
  real :: add_linorder_group
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "od_powerprod (\<preceq>) (\<prec>)"
locale oalist_abstract3
  fixes rep_key_order :: "'o => 'a key_order"
    and list_of_oalistx :: "'x => ('a * 'b) list * 'o"
    and oalist_of_listx :: "('a * 'b) list * 'o => 'x"
    and list_of_oalisty :: "'y => ('a * 'c) list * 'o"
    and oalist_of_listy :: "('a * 'c) list * 'o => 'y"
    and list_of_oalistz :: "'z => ('a * 'd) list * 'o"
    and oalist_of_listz :: "('a * 'd) list * 'o => 'z"
  assumes
    "oalist_abstract3 rep_key_order list_of_oalistx oalist_of_listx
      list_of_oalisty oalist_of_listy list_of_oalistz oalist_of_listz"
instantiation
  fun :: (type, add_linorder) lcs_powerprod
  lcs_fun == lcs :: ('a => 'b) => ('a => 'b) => 'a => 'b
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp (key_compare ?ko)) (set (?x # ?xs)) ==
### fold (ko.min ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp (key_compare ?ko)) (set (?x # ?xs)) ==
### fold (ko.max ?ko) ?xs ?x
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko (?x # ?y # ?zs) ==
### le_of_comp (key_compare ?ko) ?x ?y & ko.sorted ?ko (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted_list_of_set ?ko (set ?xs) == ko.sort ?ko (remdups ?xs)
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
instantiation
  poly_mapping :: (type, add_linorder) lcs_powerprod
  lcs_poly_mapping == lcs ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Draft.Power_Products"
### 9.938s elapsed time, 21.845s cpu time, 5.017s GC time
Loading theory "Draft.MPoly_Type_Class" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.MPoly_Type_Class_Ordered")
Loading theory "Draft.PP_Type" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping")
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
instantiation
  pp :: (type, zero) zero
  zero_pp == zero_class.zero :: ('a, 'b) pp
instantiation
  pp :: (type, monoid_add) monoid_add
  plus_pp == plus :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (type, cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_pp == minus :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (type, add_linorder) lcs_powerprod
  lcs_pp == lcs :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (linorder, {ordered_comm_monoid_add,linorder}) linorder
  less_eq_pp == less_eq :: ('a, 'b) pp => ('a, 'b) pp => bool
  less_pp == less :: ('a, 'b) pp => ('a, 'b) pp => bool
### Cannot skip proof of schematic goal statement
### theory "Draft.PP_Type"
### 0.483s elapsed time, 1.405s cpu time, 0.137s GC time
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Ambiguous input (line 1415 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Ambiguous input (line 1454 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1463 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("\<^const>Series.suminf_binder" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("_Sum_any" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### theory "Draft.MPoly_Type_Class"
### 1.915s elapsed time, 4.278s cpu time, 0.468s GC time
Loading theory "Draft.MPoly_Type_Class_Ordered" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping")
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp comparator_of) (set (?x # ?xs)) ==
### fold tc.min ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp comparator_of) (set (?x # ?xs)) ==
### fold tc.max ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted (?x # ?y # ?zs) ==
### le_of_comp comparator_of ?x ?y & tc.sorted (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted_list_of_set (set ?xs) == tc.sort (remdups ?xs)
class the_min = linorder +
  fixes the_min :: "'a"
  assumes "the_min_min": "!!x. the_min <= x"
instantiation
  nat :: the_min
  the_min_nat == the_min :: nat
instantiation
  unit :: the_min
  the_min_unit == the_min :: unit
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
instantiation
  oalist_tc :: (linorder, zero) equal
  equal_oalist_tc == equal_class.equal ::
    ('a, 'b) oalist_tc => ('a, 'b) oalist_tc => bool
### theory "Draft.OAlist"
### 14.792s elapsed time, 33.460s cpu time, 6.632s GC time
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale gd_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "gd_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "od_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
### theory "Draft.MPoly_Type_Class_Ordered"
### 7.113s elapsed time, 12.091s cpu time, 4.084s GC time
Loading theory "Draft.OAlist_Poly_Mapping" (required by "Draft.Term_OrderTemplates" via "Draft.Term_Order")
class nat_term = type +
  fixes rep_nat_term :: "'a => (nat, nat) pp * nat"
    and splus :: "'a => 'a => 'a"
  assumes
    "rep_nat_term_inj": "!!x y. rep_nat_term x = rep_nat_term y ==> x = y"
    and
    "full_component":
      "!!x i t. snd (rep_nat_term x) = i ==> EX y. rep_nat_term y = (t, i)"
    and
    "splus_term":
      "!!x y.
          rep_nat_term (splus x y) =
          pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)"
class nat_pp_term = plus + zero + nat_term +
  assumes "rep_nat_term_zero": "rep_nat_term (0::'a) = (0, 0)"
    and "splus_pp_term": "splus = (+)"
instantiation
  nat_term_order :: (type) equal
  equal_nat_term_order == equal_class.equal ::
    'a nat_term_order => 'a nat_term_order => bool
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp (nat_term_compare_inv ?ko)) (set (?x # ?xs)) ==
### fold (ko_ntm.min ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp (nat_term_compare_inv ?ko)) (set (?x # ?xs)) ==
### fold (ko_ntm.max ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko (?x # ?y # ?zs) ==
### le_of_comp (nat_term_compare_inv ?ko) ?x ?y & ko_ntm.sorted ?ko (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted_list_of_set ?ko (set ?xs) == ko_ntm.sort ?ko (remdups ?xs)
### Cannot skip proof of schematic goal statement
### theory "Draft.OAlist_Poly_Mapping"
### 4.075s elapsed time, 4.419s cpu time, 0.641s GC time
Loading theory "Draft.Term_Order" (required by "Draft.Term_OrderTemplates")
class nat = minus + plus + zero + equal + order +
  fixes rep_nat :: "'a => nat"
    and abs_nat :: "nat => 'a"
  assumes "rep_inverse": "!!x. abs_nat (rep_nat x) = x"
    and "abs_inverse": "!!n. rep_nat (abs_nat n) = n"
    and "abs_zero": "abs_nat 0 = (0::'a)"
    and "abs_plus": "!!m n. abs_nat m + abs_nat n = abs_nat (m + n)"
    and "abs_minus": "!!m n. abs_nat m - abs_nat n = abs_nat (m - n)"
    and "abs_ord": "!!m n. m <= n ==> abs_nat m <= abs_nat n"
instantiation
  nat :: nat
  rep_nat_nat == rep_nat :: nat => nat
  abs_nat_nat == abs_nat :: nat => nat
instantiation
  natural :: nat
  rep_nat_natural == rep_nat :: natural => nat
  abs_nat_natural == abs_nat :: nat => natural
class nat_pp_compare = plus + zero + linorder +
  fixes rep_nat_pp :: "'a => (nat, nat) pp"
    and abs_nat_pp :: "(nat, nat) pp => 'a"
    and lex_comp' :: "'a => 'a => order"
    and deg' :: "'a => nat"
  assumes "rep_nat_pp_inverse": "!!x. abs_nat_pp (rep_nat_pp x) = x"
    and "abs_nat_pp_inverse": "!!t. rep_nat_pp (abs_nat_pp t) = t"
    and
    "lex_comp'":
      "!!x y.
          lex_comp' x y = comp_of_ord lex_pp (rep_nat_pp x) (rep_nat_pp y)"
    and "deg'": "!!x. deg' x = deg_pp (rep_nat_pp x)"
    and "le_pp": "!!x y. rep_nat_pp x <= rep_nat_pp y ==> x <= y"
    and "zero_pp": "rep_nat_pp (0::'a) = 0"
    and "plus_pp": "!!x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y"
class nat_term_compare = nat_term + linorder +
  fixes is_scalar :: "'a itself => bool"
    and lex_comp :: "'a => 'a => order"
    and deg_comp :: "('a => 'a => order) => 'a => 'a => order"
    and pot_comp :: "('a => 'a => order) => 'a => 'a => order"
  assumes "zero_component": "EX x. snd (rep_nat_term x) = 0"
    and "is_scalar": "is_scalar = (%_. ALL x. snd (rep_nat_term x) = 0)"
    and "lex_comp": "lex_comp = lex_comp_aux"
    and
    "deg_comp":
      "!!cmp.
          deg_comp cmp =
          (%x y. case comparator_of (deg_pp (fst (rep_nat_term x)))
                       (deg_pp (fst (rep_nat_term y))) of
                 Eq => cmp x y | Lt => Lt | Gt => Gt)"
    and
    "pot_comp":
      "!!cmp.
          pot_comp cmp =
          (%x y. case comparator_of (snd (rep_nat_term x))
                       (snd (rep_nat_term y)) of
                 Eq => cmp x y | Lt => Lt | Gt => Gt)"
    and "le_term": "!!x y. rep_nat_term x <= rep_nat_term y ==> x <= y"
instantiation
  pp :: (nat, nat) nat_pp_compare
  rep_nat_pp_pp == rep_nat_pp :: ('a, 'b) pp => (nat, nat) pp
  abs_nat_pp_pp == abs_nat_pp :: (nat, nat) pp => ('a, 'b) pp
  lex_comp'_pp == lex_comp' :: ('a, 'b) pp => ('a, 'b) pp => order
  deg'_pp == deg' :: ('a, 'b) pp => nat
instantiation
  pp :: (nat, nat) nat_term
  rep_nat_term_pp == rep_nat_term :: ('a, 'b) pp => (nat, nat) pp * nat
  splus_pp == splus :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (nat, nat) nat_term_compare
  is_scalar_pp == is_scalar :: ('a, 'b) pp itself => bool
  lex_comp_pp == lex_comp :: ('a, 'b) pp => ('a, 'b) pp => order
  deg_comp_pp == deg_comp ::
    (('a, 'b) pp => ('a, 'b) pp => order)
    => ('a, 'b) pp => ('a, 'b) pp => order
  pot_comp_pp == pot_comp ::
    (('a, 'b) pp => ('a, 'b) pp => order)
    => ('a, 'b) pp => ('a, 'b) pp => order
instantiation
  prod :: ({comm_powerprod,nat_pp_compare}, nat) nat_term
  rep_nat_term_prod == rep_nat_term :: 'a * 'b => (nat, nat) pp * nat
  splus_prod == splus :: 'a * 'b => 'a * 'b => 'a * 'b
instantiation
  prod :: ({comm_powerprod,nat_pp_compare}, nat) nat_term_compare
  is_scalar_prod == is_scalar :: ('a * 'b) itself => bool
  lex_comp_prod == lex_comp :: 'a * 'b => 'a * 'b => order
  deg_comp_prod == deg_comp ::
    ('a * 'b => 'a * 'b => order) => 'a * 'b => 'a * 'b => order
  pot_comp_prod == pot_comp ::
    ('a * 'b => 'a * 'b => order) => 'a * 'b => 'a * 'b => order
### theory "Draft.Term_Order"
### 3.572s elapsed time, 3.986s cpu time, 0.437s GC time
Loading theory "Draft.Term_OrderTemplates"
"True"
  :: "bool"
"True"
  :: "bool"
"False"
  :: "bool"
val templateLemmas =
   [("Term_Order.rep_nat_pp_pp_inverse", "abs_nat_pp (rep_nat_pp ?x) = ?x",
     template_equation
      (template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)),
       template_var 0)),
    ("Term_Order.abs_nat_pp_pp_inverse", "rep_nat_pp (abs_nat_pp ?t) = ?t",
     template_equation
      (template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)),
       template_var 0)),
    ("Term_Order.deg'_pp", "deg' ?t = deg_pp (rep_nat_pp ?t)",
     template_equation
      (template_app (template_hole 2, template_var 0),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Term_Order.nat_term_compare_DEG",
     "nat_term_compare (DEG ?to) = deg_comp (nat_term_compare ?to)",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 0, template_app (template_hole 2, template_var 0)))),
    ("Term_Order.nat_term_compare_POT",
     "nat_term_compare (POT ?to) = pot_comp (nat_term_compare ?to)",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 0, template_app (template_hole 2, template_var 0)))),
    ("Term_Order.deg_rep_nat_pp",
     "deg_pp (rep_nat_pp ?t) = rep_nat (deg_pp ?t)",
     template_equation
      (template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Term_Order.DRLEX_eq",
     "nat_term_order_eq DRLEX Term_Order.LEX ?dg ?ps = False",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 3, template_hole 2),
             template_hole 1),
           template_var 1),
         template_var 0),
       template_hole 0)),
    ("Term_Order.LEX_eq",
     "nat_term_order_eq Term_Order.LEX DRLEX ?dg ?ps = False",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 3, template_hole 2),
             template_hole 1),
           template_var 1),
         template_var 0),
       template_hole 0)),
    ("Term_Order.LEX_eq",
     "nat_term_order_eq Term_Order.LEX Term_Order.LEX ?dg ?ps = True",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 1),
           template_var 1),
         template_var 0),
       template_hole 0)),
    ("Term_Order.DRLEX_eq", "nat_term_order_eq DRLEX DRLEX ?dg ?ps = True",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 1),
           template_var 1),
         template_var 0),
       template_hole 0)),
    ("Term_Order.comparator_deg_comp",
     "comparator ?cmp ==> comparator (deg_comp ?cmp)",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0))
           ))),
    ("Term_Order.comparator_pot_comp",
     "comparator ?cmp ==> comparator (pot_comp ?cmp)",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0))
           ))),
    ("Term_Order.snd_of_exps_zero",
     "snd (rep_nat_term (Term_Order.of_exps ?a ?b 0)) = 0",
     template_equation
      (template_app
        (template_hole 3,
         template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 1),
               template_var 0),
             template_hole 0))),
       template_hole 0)),
    ("Term_Order.keys_rep_nat_pp_pp",
     "keys_pp (rep_nat_pp ?t) = rep_nat ` keys_pp ?t",
     template_equation
      (template_app
        (template_hole 4, template_app (template_hole 3, template_var 0)),
       template_app
        (template_app (template_hole 2, template_hole 1),
         template_app (template_hole 0, template_var 0)))),
    ("Term_Order.nat_term_order_equal",
     "equal_class.equal ?to1.0 ?to2.0 =
      nat_term_order_eq ?to1.0 ?to2.0 False False",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1), template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 1),
             template_var 0),
           template_hole 0),
         template_hole 0))),
    ("Term_Order.rep_nat_pp_pp_eq_iff",
     "(rep_nat_pp ?x = rep_nat_pp ?y) = (?x = ?y)",
     template_bimplication
      (template_equation
        (template_app (template_hole 1, template_var 1),
         template_app (template_hole 1, template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("Term_Order.lex_rep_nat_pp",
     "lex_pp (rep_nat_pp ?x) (rep_nat_pp ?y) = lex_pp ?x ?y",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("Term_Order.lookup_abs_nat_pp_pp",
     "lookup_pp (abs_nat_pp ?t) = (%n. abs_nat (lookup_pp ?t (rep_nat n)))",
     template_equation
      (template_app
        (template_hole 4, template_app (template_hole 3, template_var 0)),
       t_empty)),
    ("Term_Order.lookup_rep_nat_pp_pp",
     "lookup_pp (rep_nat_pp ?t) = (%n. rep_nat (lookup_pp ?t (abs_nat n)))",
     template_equation
      (template_app
        (template_hole 4, template_app (template_hole 3, template_var 0)),
       t_empty)),
    ("Term_Order.compute_lex_pp", "lex_pp ?p ?q = (lex_comp' ?p ?q ~= Gt)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 1),
              template_var 0)
            )],
       template_negation
        (
           template_equation
            (template_app
              (template_app (template_hole 1, template_var 1),
               template_var 0),
             template_hole 0)
           ))),
    ("Term_Order.plus_pp_pp",
     "rep_nat_pp (?x + ?y) = rep_nat_pp ?x + rep_nat_pp ?y",
     template_equation
      (template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 2, template_var 0)))),
    ("Term_Order.lex_comp'_pp",
     "lex_comp' ?x ?y = comp_of_ord lex_pp (rep_nat_pp ?x) (rep_nat_pp ?y)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1), template_var 0),
       template_app
        (template_app
          (template_app (template_hole 2, template_hole 1),
           template_app (template_hole 0, template_var 1)),
         template_app (template_hole 0, template_var 0)))),
    ("Term_Order.rep_nat_pp_pp_inj",
     "rep_nat_pp ?x = rep_nat_pp ?y ==> ?x = ?y",
     template_implication
      ([template_equation
         (template_app (template_hole 1, template_var 1),
          template_app (template_hole 1, template_var 0))],
       template_equation (template_var 1, template_var 0))),
    ("Term_Order.le_pp_pp", "rep_nat_pp ?x <= rep_nat_pp ?y ==> ?x <= ?y",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 1, template_var 1),
          template_app (template_hole 1, template_var 0))],
       template_inequation (less_equals, template_var 1, template_var 0))),
    ("Term_Order.deg_pp_of_exps",
     "deg_pp (fst (rep_nat_term (Term_Order.of_exps ?a ?b ?i))) = ?a + ?b",
     template_equation
      (template_app
        (template_hole 4,
         template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 1),
               template_var 0)))),
       template_app
        (template_app (template_hole 0, template_var 2), template_var 1))),
    ("Term_Order.compute_dlex_pp",
     "dlex_pp ?p ?q = (deg_comp lex_comp' ?p ?q ~= Gt)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0)
            )],
       template_negation
        (
           template_equation
            (template_app
              (template_app
                (template_app (template_hole 2, template_hole 1),
                 template_var 1),
               template_var 0),
             template_hole 0)
           ))),
    ("Term_Order.nat_term_order_eq_sym",
     "nat_term_order_eq ?to1.0 ?to2.0 ?dg ?ps =
      nat_term_order_eq ?to2.0 ?to1.0 ?dg ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 2),
             template_var 3),
           template_var 1),
         template_var 0))),
    ("Term_Order.DRLEX_eq",
     "nat_term_order_eq DRLEX (DEG ?to) ?dg ?ps =
      nat_term_order_eq DRLEX ?to True ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 3, template_hole 2),
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 3, template_hole 2),
             template_var 2),
           template_hole 0),
         template_var 0))),
    ("Term_Order.nat_term_order_eq_DEG_dg'",
     "nat_term_order_eq ?to1.0 (DEG ?to2.0) True ?ps =
      nat_term_order_eq ?to1.0 ?to2.0 True ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_app (template_hole 1, template_var 1)),
           template_hole 0),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_hole 0),
         template_var 0))),
    ("Term_Order.nat_term_order_eq_DEG_dg",
     "nat_term_order_eq (DEG ?to1.0) ?to2.0 True ?ps =
      nat_term_order_eq ?to1.0 ?to2.0 True ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)),
             template_var 1),
           template_hole 0),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_hole 0),
         template_var 0))),
    ("Term_Order.DEG_eq",
     "nat_term_order_eq (DEG ?to) DRLEX ?dg ?ps =
      nat_term_order_eq DRLEX (DEG ?to) ?dg ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)),
             template_hole 0),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_hole 0),
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0))),
    ("Term_Order.DEG_eq",
     "nat_term_order_eq (DEG ?to) Term_Order.LEX ?dg ?ps =
      nat_term_order_eq Term_Order.LEX (DEG ?to) ?dg ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)),
             template_hole 0),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_hole 0),
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0))),
    ("Term_Order.POT_eq",
     "nat_term_order_eq (POT ?to1.0) DRLEX ?dg ?ps =
      nat_term_order_eq DRLEX (POT ?to1.0) ?dg ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)),
             template_hole 0),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_hole 0),
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0))),
    ("Term_Order.POT_eq",
     "nat_term_order_eq (POT ?to) Term_Order.LEX ?dg ?ps =
      nat_term_order_eq Term_Order.LEX (POT ?to) ?dg ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)),
             template_hole 0),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_hole 0),
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0))),
    ("Term_Order.DEG_eq",
     "nat_term_order_eq (DEG ?to1.0) (DEG ?to2.0) ?dg ?ps =
      nat_term_order_eq ?to1.0 ?to2.0 True ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 3)),
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_var 3),
             template_var 2),
           template_hole 0),
         template_var 0))),
    ("Term_Order.POT_eq",
     "nat_term_order_eq (POT ?to1.0) (POT ?to2.0) ?dg ?ps =
      nat_term_order_eq ?to1.0 ?to2.0 ?dg True",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 3)),
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_var 3),
             template_var 2),
           template_var 1),
         template_hole 0))),
    ("Term_Order.keys_pp_of_exps",
     "keys_pp (fst (rep_nat_term (Term_Order.of_exps ?a ?b ?i))) <= {0, 1}",
     template_inequation
      (less_equals,
       template_app
        (template_hole 7,
         template_app
          (template_hole 6,
           template_app
            (template_hole 5,
             template_app
              (template_app
                (template_app (template_hole 4, template_var 2),
                 template_var 1),
               template_var 0)))),
       template_app
        (template_app (template_hole 3, template_hole 2),
         template_app
          (template_app (template_hole 3, template_hole 1),
           template_hole 0)))),
    ("Term_Order.LEX_eq",
     "nat_term_order_eq Term_Order.LEX (DEG ?to) ?dg ?ps =
      (?dg & nat_term_order_eq Term_Order.LEX ?to ?dg ?ps)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 3, template_hole 2),
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app (template_hole 0, template_var 1),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 3, template_hole 2),
               template_var 2),
             template_var 1),
           template_var 0)))),
    ("Term_Order.compute_drlex_pp",
     "drlex_pp ?p ?q = (deg_comp (%x y. lex_comp' y x) ?p ?q ~= Gt)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0)
            )],
       template_negation
        (
           template_equation
            (template_app
              (template_app
                (template_app (template_hole 2, t_empty), template_var 1),
               template_var 0),
             template_hole 0)
           ))),
    ("Term_Order.POT_eq",
     "nat_term_order_eq (POT ?to1.0) (DEG ?to2.0) ?dg ?ps =
      nat_term_order_eq (DEG ?to2.0) (POT ?to1.0) ?dg ?ps",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 3)),
             template_app (template_hole 0, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 0, template_var 2)),
             template_app (template_hole 1, template_var 3)),
           template_var 1),
         template_var 0))),
    ("Term_Order.snd_of_exps",
     "snd (rep_nat_term ?x) = ?i ==>
      snd (rep_nat_term (Term_Order.of_exps ?a ?b ?i)) = ?i",
     template_implication
      ([template_equation
         (template_app
           (template_hole 2,
            template_app (template_hole 1, template_var 3)),
          template_var 2)],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app
              (template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 0),
               template_var 2))),
         template_var 2))),
    ("Term_Order.pot_comp_pos",
     "snd (rep_nat_term ?u) < snd (rep_nat_term ?v) ==>
      pot_comp ?cmp ?u ?v = Lt",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_hole 4,
            template_app (template_hole 3, template_var 2)),
          template_app
           (template_hole 4,
            template_app (template_hole 3, template_var 1)))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 0),
             template_var 2),
           template_var 1),
         template_hole 0))),
    ("Term_Order.LEX_eq",
     "nat_term_order_eq Term_Order.LEX (POT ?to) ?dg ?ps =
      ((?ps | is_scalar TYPE(?'a)) &
       nat_term_order_eq Term_Order.LEX ?to ?dg ?ps)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 6, template_hole 5),
             template_app (template_hole 4, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 0),
             template_app (template_hole 1, template_hole 0))),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 6, template_hole 5),
               template_var 2),
             template_var 1),
           template_var 0)))),
    ("Term_Order.nat_term_order_eq_POT_ps'",
     "?ps | is_scalar TYPE(?'a) ==>
      nat_term_order_eq ?to1.0 (POT ?to2.0) ?dg ?ps =
      nat_term_order_eq ?to1.0 ?to2.0 ?dg ?ps",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 3),
              template_app (template_hole 4, template_hole 3))
            )],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_app (template_hole 1, template_var 2),
               template_app (template_hole 0, template_var 1)),
             template_var 0),
           template_var 3),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 1, template_var 2),
               template_var 1),
             template_var 0),
           template_var 3)))),
    ("Term_Order.nat_term_order_eq_POT_ps",
     "?ps | is_scalar TYPE(?'a) ==>
      nat_term_order_eq (POT ?to1.0) ?to2.0 ?dg ?ps =
      nat_term_order_eq ?to1.0 ?to2.0 ?dg ?ps",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 3),
              template_app (template_hole 4, template_hole 3))
            )],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_app
                (template_hole 1,
                 template_app (template_hole 0, template_var 2)),
               template_var 1),
             template_var 0),
           template_var 3),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 1, template_var 2),
               template_var 1),
             template_var 0),
           template_var 3)))),
    ("Term_Order.DRLEX_eq",
     "nat_term_order_eq DRLEX (POT ?to) ?dg ?ps =
      ((?dg | ?ps | is_scalar TYPE(?'a)) &
       nat_term_order_eq DRLEX ?to ?dg True)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 7, template_hole 6),
             template_app (template_hole 5, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 1),
             template_app
              (template_app (template_hole 3, template_var 0),
               template_app (template_hole 2, template_hole 1)))),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 7, template_hole 6),
               template_var 2),
             template_var 1),
           template_hole 0)))),
    ("Term_Order.lookup_pp_of_exps",
     "lookup_pp (fst (rep_nat_term (Term_Order.of_exps ?a ?b ?i))) =
      (%x. if x = 0 then ?a else if x = 1 then ?b else 0)",
     template_equation
      (template_app
        (template_hole 7,
         template_app
          (template_hole 6,
           template_app
            (template_hole 5,
             template_app
              (template_app
                (template_app (template_hole 4, template_var 2),
                 template_var 1),
               template_var 0)))),
       t_empty)),
    ("Term_Order.eq_of_exps",
     "(fst (rep_nat_term (Term_Order.of_exps ?a1.0 ?b1.0 ?i)) =
       fst (rep_nat_term (Term_Order.of_exps ?a2.0 ?b2.0 ?j))) =
      (?a1.0 = ?a2.0 & ?b1.0 = ?b2.0)",
     template_bimplication
      (template_equation
        (template_app
          (template_hole 6,
           template_app
            (template_hole 5,
             template_app
              (template_app
                (template_app (template_hole 4, template_var 5),
                 template_var 4),
               template_var 3))),
         template_app
          (template_hole 6,
           template_app
            (template_hole 3,
             template_app
              (template_app
                (template_app (template_hole 2, template_var 2),
                 template_var 1),
               template_var 0)))),
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 5),
                 template_var 2)),
             template_app
              (template_app (template_hole 0, template_var 4),
               template_var 1))
           ))),
    ("Term_Order.deg_comp_pos",
     "[| ?cmp ?u ?v = Lt; fst (rep_nat_term ?u) = fst (rep_nat_term ?v) |]
      ==> deg_comp ?cmp ?u ?v = Lt",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_var 2, template_var 1), template_var 0),
          template_hole 4),
        template_equation
         (template_app
           (template_hole 2,
            template_app (template_hole 1, template_var 1)),
          template_app
           (template_hole 2,
            template_app (template_hole 1, template_var 0)))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1),
           template_var 0),
         template_hole 4))),
    ("Term_Order.pot_comp_zero_min",
     "[| ?cmp ?u ?v ~= Gt; snd (rep_nat_term ?u) = snd (rep_nat_term ?v) |]
      ==> pot_comp ?cmp ?u ?v ~= Gt",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app
               (template_app (template_var 2, template_var 1),
                template_var 0),
              template_hole 4)
            ),
        template_equation
         (template_app
           (template_hole 2,
            template_app (template_hole 1, template_var 1)),
          template_app
           (template_hole 2,
            template_app (template_hole 1, template_var 0)))],
       template_negation
        (
           template_equation
            (template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0),
             template_hole 4)
           ))),
    ("Term_Order.lex_pp_of_exps",
     "lex_pp (fst (rep_nat_term (Term_Order.of_exps ?a1.0 ?b1.0 ?i)))
       (fst (rep_nat_term (Term_Order.of_exps ?a2.0 ?b2.0 ?j))) =
      (?a1.0 < ?a2.0 | ?a1.0 = ?a2.0 & ?b1.0 <= ?b2.0)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_app
                       (template_app (template_hole 5, template_var 5),
                        template_var 4),
                      template_var 3)))),
              template_app
               (template_hole 7,
                template_app
                 (template_hole 6,
                  template_app
                   (template_app
                     (template_app (template_hole 5, template_var 2),
                      template_var 1),
                    template_var 0))))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 3, template_var 5),
                 template_var 2)),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 5),
                   template_var 2)),
               template_app
                (template_app (template_hole 0, template_var 4),
                 template_var 1)))
           ))),
    ("Term_Order.snd_rep_nat_term_eqI",
     "[| ?ps | is_scalar TYPE(?'a);
         ?ps ==> snd (rep_nat_term ?u) = snd (rep_nat_term ?v) |]
      ==> snd (rep_nat_term ?u) = snd (rep_nat_term ?v)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 2),
              template_app (template_hole 4, template_hole 3))
            ),
        template_implication
         ([template_predicate (template_var 2)],
          template_equation
           (template_app
             (template_hole 1,
              template_app (template_hole 0, template_var 1)),
            template_app
             (template_hole 1,
              template_app (template_hole 0, template_var 0))))],
       template_equation
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app
          (template_hole 1,
           template_app (template_hole 0, template_var 0))))),
    ("Term_Order.DEG_eq",
     "nat_term_order_eq (DEG ?to1.0) (POT ?to2.0) ?dg ?ps =
      (if ?dg then nat_term_order_eq ?to1.0 (POT ?to2.0) ?dg ?ps
       else (?ps | is_scalar TYPE(?'a)) &
            nat_term_order_eq (DEG ?to1.0) ?to2.0 ?dg ?ps)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_hole 7,
               template_app (template_hole 6, template_var 3)),
             template_app (template_hole 5, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 4, template_var 1),
           template_app
            (template_app
              (template_app
                (template_app (template_hole 7, template_var 3),
                 template_app (template_hole 5, template_var 2)),
               template_var 1),
             template_var 0)),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_var 0),
               template_app (template_hole 1, template_hole 0))),
           template_app
            (template_app
              (template_app
                (template_app
                  (template_hole 7,
                   template_app (template_hole 6, template_var 3)),
                 template_var 2),
               template_var 1),
             template_var 0))))),
    ("Term_Order.pot_comp_cong",
     "(snd (rep_nat_term ?u) = snd (rep_nat_term ?v) ==>
       ?to1.0 ?u ?v = ?to2.0 ?u ?v) ==>
      pot_comp ?to1.0 ?u ?v = pot_comp ?to2.0 ?u ?v",
     template_implication
      ([template_implication
         ([template_equation
            (template_app
              (template_hole 3,
               template_app (template_hole 2, template_var 3)),
             template_app
              (template_hole 3,
               template_app (template_hole 2, template_var 2)))],
          template_equation
           (template_app
             (template_app (template_var 1, template_var 3),
              template_var 2),
            template_app
             (template_app (template_var 0, template_var 3),
              template_var 2)))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 1),
             template_var 3),
           template_var 2),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 0),
             template_var 3),
           template_var 2)))),
    ("Term_Order.deg_comp_zero_min",
     "[| comparator ?cmp; snd (rep_nat_term ?u) = snd (rep_nat_term ?v);
         fst (rep_nat_term ?u) = 0 |]
      ==> deg_comp ?cmp ?u ?v ~= Gt",
     template_implication
      ([template_predicate
         (template_app (template_hole 10, template_var 2)),
        template_equation
         (template_app
           (template_hole 8,
            template_app (template_hole 7, template_var 1)),
          template_app
           (template_hole 8,
            template_app (template_hole 7, template_var 0))),
        template_equation
         (template_app
           (template_hole 5,
            template_app (template_hole 7, template_var 1)),
          template_hole 4)],
       template_negation
        (
           template_equation
            (template_app
              (template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 1),
               template_var 0),
             template_hole 0)
           ))),
    ("Term_Order.deg_comp_cong",
     "(deg_pp (fst (rep_nat_term ?u)) = deg_pp (fst (rep_nat_term ?v)) ==>
       ?to1.0 ?u ?v = ?to2.0 ?u ?v) ==>
      deg_comp ?to1.0 ?u ?v = deg_comp ?to2.0 ?u ?v",
     template_implication
      ([template_implication
         ([template_equation
            (template_app
              (template_hole 4,
               template_app
                (template_hole 3,
                 template_app (template_hole 2, template_var 3))),
             template_app
              (template_hole 4,
               template_app
                (template_hole 3,
                 template_app (template_hole 2, template_var 2))))],
          template_equation
           (template_app
             (template_app (template_var 1, template_var 3),
              template_var 2),
            template_app
             (template_app (template_var 0, template_var 3),
              template_var 2)))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 1),
             template_var 3),
           template_var 2),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 0),
             template_var 3),
           template_var 2)))),
    ("Term_Order.rep_nat_term_of_exps",
     "rep_nat_term (Term_Order.of_exps ?a ?b ?i) =
      (pp_of_fun (%x. if x = 0 then ?a else if x = 1 then ?b else 0),
       if EX y. snd (rep_nat_term y) = ?i then ?i else 0)",
     template_equation
      (template_app
        (template_hole 9,
         template_app
          (template_app
            (template_app (template_hole 8, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_hole 7, template_app (template_hole 6, t_empty)),
         template_app
          (template_app
            (template_app
              (template_hole 5, template_app (template_hole 1, t_empty)),
             template_var 0),
           template_hole 3)))),
    ("Term_Order.deg_comp_monotone",
     "[| ?cmp ?u ?v = Lt ==> ?cmp (splus ?t ?u) (splus ?t ?v) = Lt;
         deg_comp ?cmp ?u ?v = Lt |]
      ==> deg_comp ?cmp (splus ?t ?u) (splus ?t ?v) = Lt",
     template_implication
      ([template_implication
         ([template_equation
            (template_app
              (template_app (template_var 3, template_var 2),
               template_var 1),
             template_hole 2)],
          template_equation
           (template_app
             (template_app
               (template_var 3,
                template_app
                 (template_app (template_hole 1, template_var 0),
                  template_var 2)),
              template_app
               (template_app (template_hole 1, template_var 0),
                template_var 1)),
            template_hole 2)),
        template_equation
         (template_app
           (template_app
             (template_app (template_hole 0, template_var 3),
              template_var 2),
            template_var 1),
          template_hole 2)],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_app
              (template_app (template_hole 1, template_var 0),
               template_var 2)),
           template_app
            (template_app (template_hole 1, template_var 0),
             template_var 1)),
         template_hole 2))),
    ("Term_Order.pot_comp_monotone",
     "[| ?cmp ?u ?v = Lt ==> ?cmp (splus ?t ?u) (splus ?t ?v) = Lt;
         pot_comp ?cmp ?u ?v = Lt |]
      ==> pot_comp ?cmp (splus ?t ?u) (splus ?t ?v) = Lt",
     template_implication
      ([template_implication
         ([template_equation
            (template_app
              (template_app (template_var 3, template_var 2),
               template_var 1),
             template_hole 2)],
          template_equation
           (template_app
             (template_app
               (template_var 3,
                template_app
                 (template_app (template_hole 1, template_var 0),
                  template_var 2)),
              template_app
               (template_app (template_hole 1, template_var 0),
                template_var 1)),
            template_hole 2)),
        template_equation
         (template_app
           (template_app
             (template_app (template_hole 0, template_var 3),
              template_var 2),
            template_var 1),
          template_hole 2)],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_app
              (template_app (template_hole 1, template_var 0),
               template_var 2)),
           template_app
            (template_app (template_hole 1, template_var 0),
             template_var 1)),
         template_hole 2))),
    ("Term_Order.nat_term_order_eqD",
     "[| nat_term_order_eq ?to1.0 ?to2.0 ?dg ?ps;
         ?dg ==>
         deg_pp (fst (rep_nat_term ?u)) = deg_pp (fst (rep_nat_term ?v));
         ?ps ==> snd (rep_nat_term ?u) = snd (rep_nat_term ?v) |]
      ==> nat_term_compare ?to1.0 ?u ?v = nat_term_compare ?to2.0 ?u ?v",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 7, template_var 5),
                  template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_implication
         ([template_predicate (template_var 3)],
          template_equation
           (template_app
             (template_hole 5,
              template_app
               (template_hole 4,
                template_app (template_hole 3, template_var 1))),
            template_app
             (template_hole 5,
              template_app
               (template_hole 4,
                template_app (template_hole 3, template_var 0))))),
        template_implication
         ([template_predicate (template_var 2)],
          template_equation
           (template_app
             (template_hole 2,
              template_app (template_hole 3, template_var 1)),
            template_app
             (template_hole 2,
              template_app (template_hole 3, template_var 0))))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 5),
             template_var 1),
           template_var 0),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 4),
             template_var 1),
           template_var 0)))),
    ("Term_Order.nat_term_order_eqI",
     "(!!u v.
          [| ?dg ==>
             deg_pp (fst (rep_nat_term u)) = deg_pp (fst (rep_nat_term v));
             ?ps ==> snd (rep_nat_term u) = snd (rep_nat_term v) |]
          ==> nat_term_compare ?to1.0 u v = nat_term_compare ?to2.0 u v) ==>
      nat_term_order_eq ?to1.0 ?to2.0 ?dg ?ps",
     template_implication
      ([template_predicate (template_app (template_hole 9, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 0),
               template_var 3),
             template_var 2)
           )))]:
   (string * thm * template) list
### theory "Draft.Term_OrderTemplates"
### 1.503s elapsed time, 5.367s cpu time, 2.588s GC time
val it = (): unit
