Loading theory "Draft.OAlist" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping")
Loading theory "Draft.MPoly_Type" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products" via "Draft.More_MPoly_Type")
Loading theory "Draft.More_Modules" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping" via "Draft.MPoly_Type_Class_Ordered" via "Draft.MPoly_Type_Class")
Loading theory "Draft.Templates" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.ExtrEqs")
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.103s elapsed time, 0.410s cpu time, 0.061s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.OAlist_Poly_MappingTemplates")
### Missing patterns in function definition:
### !!a. min_list_param a [] = undefined
instantiation
  mpoly :: (zero) zero
  zero_mpoly == zero_class.zero :: 'a mpoly
instantiation
  mpoly :: (monoid_add) monoid_add
  plus_mpoly == plus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_mpoly == minus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (ab_group_add) ab_group_add
  uminus_mpoly == uminus :: 'a mpoly => 'a mpoly
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  mpoly :: (zero_neq_one) zero_neq_one
  one_mpoly == one_class.one :: 'a mpoly
instantiation
  mpoly :: (semiring_0) semiring_0
  times_mpoly == times :: 'a mpoly => 'a mpoly => 'a mpoly
### theory "Draft.More_Modules"
### 0.203s elapsed time, 0.807s cpu time, 0.061s GC time
Loading theory "Draft.Utils" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products")
instantiation
  key_order :: (type) equal
  equal_key_order == equal_class.equal ::
    'a key_order => 'a key_order => bool
instantiation
  key_order :: (type) uminus
  uminus_key_order == uminus :: 'a key_order => 'a key_order
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### linorder.Min (le_of_key_order ?ko) (set (?x # ?xs)) ==
### fold (key_order_lin.min ?ko) ?xs ?x
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### linorder.Max (le_of_key_order ?ko) (set (?x # ?xs)) ==
### fold (key_order_lin.max ?ko) ?xs ?x
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko [] == True
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko [?x] == True
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko (?x # ?y # ?zs) ==
### le_of_key_order ?ko ?x ?y & key_order_lin.sorted ?ko (?y # ?zs)
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted_list_of_set ?ko (set ?xs) ==
### key_order_lin.sort ?ko (remdups ?xs)
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### Ambiguous input (line 494 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>div" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 498 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>mod" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 502 of "$AFP/Polynomials/MPoly_Type.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 505 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 509 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.MPoly_Type"
### 0.523s elapsed time, 2.016s cpu time, 0.257s GC time
Loading theory "Draft.More_MPoly_Type" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products")
### theory "Draft.Utils"
### 0.330s elapsed time, 1.256s cpu time, 0.196s GC time
MPoly (mapping_of ?x) = ?x
?y : UNIV ==> mapping_of (MPoly ?y) = ?y
(mapping_of ?x = mapping_of ?y) = (?x = ?y)
[| ?x : UNIV; ?y : UNIV |] ==> (MPoly ?x = MPoly ?y) = (?x = ?y)
[| ?y : UNIV; !!x. ?P (mapping_of x) |] ==> ?P ?y
(!!y. y : UNIV ==> ?P (MPoly y)) ==> ?P ?x
[| ?y : UNIV; !!x. ?y = mapping_of x ==> ?P |] ==> ?P
(!!y. [| ?x = MPoly y; y : UNIV |] ==> ?P) ==> ?P
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.702s elapsed time, 2.661s cpu time, 0.345s GC time
locale comparator
  fixes comp :: "'a => 'a => order"
  assumes "comparator comp"
### theory "Draft.More_MPoly_Type"
### 0.320s elapsed time, 1.153s cpu time, 0.150s GC time
Loading theory "Draft.Power_Products" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type")
"(Gcd (coeffs
        (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
          6 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
          8)),
  sdiv
   (Gcd (coeffs
          (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
            6 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
            8)))
   (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
    M [(1::'b) + (1::'b), 0::'b, (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
     6 +
    M [(1::'b) + (1::'b), 0::'b,
       (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
     8))"
  :: "'a * 'a mpoly"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. size_list size (snd (snd (snd (snd p))))) <*mlex*>
   (%p. size_list size (fst (snd (snd (snd p))))) <*mlex*> {}"
class plus = type +
  fixes plus :: "'a => 'a => 'a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class ninv_comm_monoid_add = comm_monoid_add +
  assumes "plus_eq_zero": "!!s t. s + t = (0::'a) ==> s = (0::'a)"
Found termination order:
  "(%p. size_list size (snd (snd p))) <*mlex*>
   (%p. size_list size (fst (snd p))) <*mlex*> {}"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
Found termination order:
  "(%p. size_list size (snd (snd p))) <*mlex*>
   (%p. size_list size (fst (snd p))) <*mlex*> {}"
class lcs_powerprod = comm_powerprod +
  fixes lcs :: "'a => 'a => 'a"
  assumes "adds_lcs": "!!s t. s adds lcs s t"
  assumes "lcs_adds": "!!s u t. [| s adds u; t adds u |] ==> lcs s t adds u"
  assumes "lcs_comm": "!!s t. lcs s t = lcs t s"
class graded_dickson_powerprod = ulcs_powerprod +
  assumes "ex_dgrad": "EX d. dickson_grading d"
class dickson_powerprod = ulcs_powerprod +
  assumes "dickson": "almost_full_on (adds) UNIV"
locale comparator2
  fixes comp1 :: "'a => 'a => order"
    and comp2 :: "'a => 'a => order"
  assumes "comparator2 comp1 comp2"
locale oalist_raw
  fixes rep_key_order :: "'o => 'a key_order"
class semi_canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_imp_add": "!!a b. a <= b ==> EX c. b = a + c"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  ninv_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
[| le ?x ?a ?b; le ?x ?b ?c |] ==> le ?x ?a ?c
[| le ?x ?a ?b; le ?x ?b ?c |] ==> le ?x ?a ?c
[| ?a <= ?b; ?b <= ?c |] ==> ?a <= ?c
[| le ?xa ?x ?y; le ?xa ?y ?z |] ==> le ?xa ?x ?z
locale oalist_raw
  fixes rep_key_order :: "'o => 'a key_order"
class add_linorder_min = add_linorder +
  assumes "zero_min": "!!x. (0::'a) <= x"
locale oalist_abstract
  fixes rep_key_order :: "'o => 'a key_order"
    and list_of_oalist :: "'x => ('a * 'b) list * 'o"
    and oalist_of_list :: "('a * 'b) list * 'o => 'x"
  assumes "oalist_abstract rep_key_order list_of_oalist oalist_of_list"
instantiation
  nat :: add_linorder
instantiation
  nat :: add_linorder_min
instantiation
  nat :: add_wellorder
instantiation
  int :: add_linorder_group
instantiation
  rat :: add_linorder_group
instantiation
  real :: add_linorder_group
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "od_powerprod (\<preceq>) (\<prec>)"
locale oalist_abstract3
  fixes rep_key_order :: "'o => 'a key_order"
    and list_of_oalistx :: "'x => ('a * 'b) list * 'o"
    and oalist_of_listx :: "('a * 'b) list * 'o => 'x"
    and list_of_oalisty :: "'y => ('a * 'c) list * 'o"
    and oalist_of_listy :: "('a * 'c) list * 'o => 'y"
    and list_of_oalistz :: "'z => ('a * 'd) list * 'o"
    and oalist_of_listz :: "('a * 'd) list * 'o => 'z"
  assumes
    "oalist_abstract3 rep_key_order list_of_oalistx oalist_of_listx
      list_of_oalisty oalist_of_listy list_of_oalistz oalist_of_listz"
instantiation
  fun :: (type, add_linorder) lcs_powerprod
  lcs_fun == lcs :: ('a => 'b) => ('a => 'b) => 'a => 'b
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp (key_compare ?ko)) (set (?x # ?xs)) ==
### fold (ko.min ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp (key_compare ?ko)) (set (?x # ?xs)) ==
### fold (ko.max ?ko) ?xs ?x
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko (?x # ?y # ?zs) ==
### le_of_comp (key_compare ?ko) ?x ?y & ko.sorted ?ko (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted_list_of_set ?ko (set ?xs) == ko.sort ?ko (remdups ?xs)
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
instantiation
  poly_mapping :: (type, add_linorder) lcs_powerprod
  lcs_poly_mapping == lcs ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Draft.Power_Products"
### 9.950s elapsed time, 21.656s cpu time, 4.651s GC time
Loading theory "Draft.MPoly_Type_Class" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping" via "Draft.MPoly_Type_Class_Ordered")
Loading theory "Draft.PP_Type" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping")
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
instantiation
  pp :: (type, zero) zero
  zero_pp == zero_class.zero :: ('a, 'b) pp
instantiation
  pp :: (type, monoid_add) monoid_add
  plus_pp == plus :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (type, cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_pp == minus :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (type, add_linorder) lcs_powerprod
  lcs_pp == lcs :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (linorder, {ordered_comm_monoid_add,linorder}) linorder
  less_eq_pp == less_eq :: ('a, 'b) pp => ('a, 'b) pp => bool
  less_pp == less :: ('a, 'b) pp => ('a, 'b) pp => bool
### Cannot skip proof of schematic goal statement
### theory "Draft.PP_Type"
### 0.442s elapsed time, 1.305s cpu time, 0.112s GC time
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Ambiguous input (line 1415 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Ambiguous input (line 1454 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1463 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("\<^const>Series.suminf_binder" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("_Sum_any" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### theory "Draft.MPoly_Type_Class"
### 1.903s elapsed time, 4.269s cpu time, 0.442s GC time
Loading theory "Draft.MPoly_Type_Class_Ordered" (required by "Draft.OAlist_Poly_MappingTemplates" via "Draft.OAlist_Poly_Mapping")
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp comparator_of) (set (?x # ?xs)) ==
### fold tc.min ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp comparator_of) (set (?x # ?xs)) ==
### fold tc.max ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted (?x # ?y # ?zs) ==
### le_of_comp comparator_of ?x ?y & tc.sorted (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted_list_of_set (set ?xs) == tc.sort (remdups ?xs)
class the_min = linorder +
  fixes the_min :: "'a"
  assumes "the_min_min": "!!x. the_min <= x"
instantiation
  nat :: the_min
  the_min_nat == the_min :: nat
instantiation
  unit :: the_min
  the_min_unit == the_min :: unit
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
instantiation
  oalist_tc :: (linorder, zero) equal
  equal_oalist_tc == equal_class.equal ::
    ('a, 'b) oalist_tc => ('a, 'b) oalist_tc => bool
### theory "Draft.OAlist"
### 14.726s elapsed time, 33.244s cpu time, 6.045s GC time
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale gd_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "gd_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "od_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
### theory "Draft.MPoly_Type_Class_Ordered"
### 6.051s elapsed time, 9.192s cpu time, 1.206s GC time
Loading theory "Draft.OAlist_Poly_Mapping" (required by "Draft.OAlist_Poly_MappingTemplates")
class nat_term = type +
  fixes rep_nat_term :: "'a => (nat, nat) pp * nat"
    and splus :: "'a => 'a => 'a"
  assumes
    "rep_nat_term_inj": "!!x y. rep_nat_term x = rep_nat_term y ==> x = y"
    and
    "full_component":
      "!!x i t. snd (rep_nat_term x) = i ==> EX y. rep_nat_term y = (t, i)"
    and
    "splus_term":
      "!!x y.
          rep_nat_term (splus x y) =
          pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)"
class nat_pp_term = plus + zero + nat_term +
  assumes "rep_nat_term_zero": "rep_nat_term (0::'a) = (0, 0)"
    and "splus_pp_term": "splus = (+)"
instantiation
  nat_term_order :: (type) equal
  equal_nat_term_order == equal_class.equal ::
    'a nat_term_order => 'a nat_term_order => bool
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp (nat_term_compare_inv ?ko)) (set (?x # ?xs)) ==
### fold (ko_ntm.min ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp (nat_term_compare_inv ?ko)) (set (?x # ?xs)) ==
### fold (ko_ntm.max ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko (?x # ?y # ?zs) ==
### le_of_comp (nat_term_compare_inv ?ko) ?x ?y & ko_ntm.sorted ?ko (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted_list_of_set ?ko (set ?xs) == ko_ntm.sort ?ko (remdups ?xs)
### Cannot skip proof of schematic goal statement
### theory "Draft.OAlist_Poly_Mapping"
### 3.956s elapsed time, 4.294s cpu time, 0.528s GC time
Loading theory "Draft.OAlist_Poly_MappingTemplates"
val templateLemmas =
   [("OAlist_Poly_Mapping.comparator_nat_term_compare_inv",
     "comparator (nat_term_compare_inv ?to)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("OAlist_Poly_Mapping.comparator_nat_term_compare",
     "comparator (nat_term_compare ?to)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("OAlist_Poly_Mapping.nat_term_comp_nat_term_compare",
     "nat_term_comp (nat_term_compare ?to)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("OAlist_Poly_Mapping.oalist_inv_list_of_oalist_ntm",
     "ko_ntm.oalist_inv (list_of_oalist_ntm ?xs)",
     template_predicate
      (
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_app (template_hole 0, template_var 0))
         )),
    ("OAlist_Poly_Mapping.le_of_nat_term_order_zero_min",
     "le_of_nat_term_order ?to (0::?'a) ?t",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 1, template_var 1),
             template_hole 0),
           template_var 0)
         )),
    ("OAlist_Poly_Mapping.OAlist_list_of_oalist_ntm",
     "OAlist_ntm (list_of_oalist_ntm ?xs) = ?xs",
     template_equation
      (template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)),
       template_var 0)),
    ("OAlist_Poly_Mapping.linorder_le_of_nat_term_order",
     "class.linorder (le_of_nat_term_order ?to) (lt_of_nat_term_order ?to)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 0)),
           template_app (template_hole 0, template_var 0))
         )),
    ("OAlist_Poly_Mapping.nat_term_compare_inv_conv",
     "nat_term_compare_inv ?to =
      key_compare (key_order_of_nat_term_order_inv ?to)",
     template_equation
      (template_app (template_hole 2, template_var 0),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("OAlist_Poly_Mapping.nat_term_compare_conv",
     "nat_term_compare ?to = key_compare (key_order_of_nat_term_order ?to)",
     template_equation
      (template_app (template_hole 2, template_var 0),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("OAlist_Poly_Mapping.list_of_oalist_OAlist_ntm",
     "list_of_oalist_ntm (OAlist_ntm ?xs) = sort_oalist_ko_ntm ?xs",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("OAlist_Poly_Mapping.oalist_ntm_eq_iff",
     "(?xs = ?ys) = (list_of_oalist_ntm ?xs = list_of_oalist_ntm ?ys)",
     template_bimplication
      (template_equation (template_var 1, template_var 0),
       template_equation
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("OAlist_Poly_Mapping.nat_term_compare_inv_alt",
     "nat_term_compare_inv ?to ?x ?y = nat_term_compare ?to ?y ?x",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 0, template_var 2), template_var 0),
         template_var 1))),
    ("OAlist_Poly_Mapping.ko_ntm_le",
     "ko_ntm.le ?to = (%x y. le_of_nat_term_order ?to y x)",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       t_empty)),
    ("OAlist_Poly_Mapping.oalist_ntm_eqI",
     "list_of_oalist_ntm ?xs = list_of_oalist_ntm ?ys ==> ?xs = ?ys",
     template_implication
      ([template_equation
         (template_app (template_hole 1, template_var 1),
          template_app (template_hole 1, template_var 0))],
       template_equation (template_var 1, template_var 0))),
    ("OAlist_Poly_Mapping.le_of_nat_term_order_alt",
     "le_of_nat_term_order ?to =
      (%u v. ko.le (key_order_of_nat_term_order_inv ?to) v u)",
     template_equation
      (template_app (template_hole 3, template_var 0), t_empty)),
    ("OAlist_Poly_Mapping.lt_of_nat_term_order_alt",
     "lt_of_nat_term_order ?to =
      (%u v. ko.lt (key_order_of_nat_term_order_inv ?to) v u)",
     template_equation
      (template_app (template_hole 3, template_var 0), t_empty)),
    ("OAlist_Poly_Mapping.lt_of_nat_term_order",
     "lt_of_nat_term_order ?to ?x ?y = (nat_term_compare ?to ?x ?y = Lt)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 0),
         template_hole 0))),
    ("OAlist_Poly_Mapping.le_of_nat_term_order",
     "le_of_nat_term_order ?to ?x ?y = (nat_term_compare ?to ?x ?y ~= Gt)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_negation
        (
           template_equation
            (template_app
              (template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 1),
               template_var 0),
             template_hole 0)
           ))),
    ("OAlist_Poly_Mapping.nat_term_compare_splus",
     "nat_term_compare ?to (splus ?t ?u) (splus ?t ?v) =
      nat_term_compare ?to ?u ?v",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_var 3),
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2), template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 1, template_var 3), template_var 1),
         template_var 0))),
    ("OAlist_Poly_Mapping.nat_term_compare_Abs_nat_term_order_id",
     "[| comparator ?cmp; nat_term_comp ?cmp |]
      ==> nat_term_compare (Abs_nat_term_order ?cmp) = ?cmp",
     template_implication
      ([template_predicate (template_app (template_hole 4, template_var 0)),
        template_predicate
         (template_app (template_hole 3, template_var 0))],
       template_equation
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 0)),
         template_var 0))),
    ("OAlist_Poly_Mapping.le_of_nat_term_order_plus_monotone",
     "le_of_nat_term_order ?to ?s ?t ==>
      le_of_nat_term_order ?to (?u + ?s) (?u + ?t)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 3),
                template_var 2),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_app
                (template_app (template_hole 0, template_var 0),
                 template_var 2)),
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 1))
           ))),
    ("OAlist_Poly_Mapping.OAlist_lookup_ntm_single",
     "OAlist_lookup_ntm (oalist_of_list_ntm ([(?k, ?v)], ?ko)) ?k' =
      (if ?k = ?k' then ?v else (0::?'b))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_hole 7,
                  template_app
                   (template_app
                     (template_hole 6,
                      template_app
                       (template_app
                         (template_hole 5,
                          template_app
                           (template_app (template_hole 4, template_var 3),
                            template_var 2)),
                        template_hole 3)),
                    template_var 1))),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 3),
                   template_var 0)),
               template_var 2),
             template_hole 0)
           ))),
    ("OAlist_Poly_Mapping.nat_term_compD3",
     "[| nat_term_comp ?cmp; ?cmp ?u ?v = Lt |]
      ==> ?cmp (splus ?t ?u) (splus ?t ?v) = Lt",
     template_implication
      ([template_predicate (template_app (template_hole 3, template_var 3)),
        template_equation
         (template_app
           (template_app (template_var 3, template_var 2), template_var 1),
          template_hole 1)],
       template_equation
        (template_app
          (template_app
            (template_var 3,
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 2)),
           template_app
            (template_app (template_hole 0, template_var 0),
             template_var 1)),
         template_hole 1))),
    ("OAlist_Poly_Mapping.compute_min_key_val_ko_ntm",
     "min_key_val_ko_ntm ?ko (?xs, ?ox) =
      (if ?ko = ?ox then hd
       else min_list_param (%x y. le_of_nat_term_order ?ko (fst y) (fst x)))
       ?xs",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 7, template_var 2),
              template_app
               (template_app (template_hole 6, template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 4, template_var 2),
                     template_var 0)),
                 template_hole 3),
               template_app (template_hole 2, t_empty)),
             template_var 1)
           ))),
    ("OAlist_Poly_Mapping.nat_term_compD1",
     "[| nat_term_comp ?cmp; snd (rep_nat_term ?u) = snd (rep_nat_term ?v);
         fst (rep_nat_term ?u) = 0 |]
      ==> ?cmp ?u ?v ~= Gt",
     template_implication
      ([template_predicate (template_app (template_hole 9, template_var 2)),
        template_equation
         (template_app
           (template_hole 7,
            template_app (template_hole 6, template_var 1)),
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_var 0))),
        template_equation
         (template_app
           (template_hole 4,
            template_app (template_hole 6, template_var 1)),
          template_hole 3)],
       template_negation
        (
           template_equation
            (template_app
              (template_app (template_var 2, template_var 1),
               template_var 0),
             template_hole 0)
           ))),
    ("OAlist_Poly_Mapping.nat_term_compD2",
     "[| nat_term_comp ?cmp; fst (rep_nat_term ?u) = fst (rep_nat_term ?v);
         snd (rep_nat_term ?u) < snd (rep_nat_term ?v) |]
      ==> ?cmp ?u ?v = Lt",
     template_implication
      ([template_predicate (template_app (template_hole 7, template_var 2)),
        template_equation
         (template_app
           (template_hole 5,
            template_app (template_hole 4, template_var 1)),
          template_app
           (template_hole 5,
            template_app (template_hole 4, template_var 0))),
        template_inequation
         (less_than,
          template_app
           (template_hole 2,
            template_app (template_hole 4, template_var 1)),
          template_app
           (template_hole 2,
            template_app (template_hole 4, template_var 0)))],
       template_equation
        (template_app
          (template_app (template_var 2, template_var 1), template_var 0),
         template_hole 0))),
    ("OAlist_Poly_Mapping.nat_term_compD1'",
     "[| comparator ?cmp; nat_term_comp ?cmp;
         snd (rep_nat_term ?u) <= snd (rep_nat_term ?v);
         fst (rep_nat_term ?u) = 0 |]
      ==> ?cmp ?u ?v ~= Gt",
     template_implication
      ([template_predicate
         (template_app (template_hole 10, template_var 2)),
        template_predicate (template_app (template_hole 9, template_var 2)),
        template_inequation
         (less_equals,
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_var 1)),
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_var 0))),
        template_equation
         (template_app
           (template_hole 4,
            template_app (template_hole 6, template_var 1)),
          template_hole 3)],
       template_negation
        (
           template_equation
            (template_app
              (template_app (template_var 2, template_var 1),
               template_var 0),
             template_hole 0)
           ))),
    ("OAlist_Poly_Mapping.comparator_lexicographic",
     "[| comparator ?c1.0; comparator ?c2.0;
         !!x y. [| ?f x = ?f y; ?g x = ?g y |] ==> x = y |]
      ==> comparator
           (%x y. case ?c1.0 (?f x) (?f y) of Eq => ?c2.0 (?g x) (?g y)
                  | Lt => Lt | Gt => Gt)",
     template_implication
      ([template_predicate (template_app (template_hole 9, template_var 3)),
        template_predicate (template_app (template_hole 8, template_var 2)),
        template_predicate (template_app (template_hole 7, t_empty))],
       template_predicate (template_app (template_hole 3, t_empty)))),
    ("OAlist_Poly_Mapping.nat_term_compD4'",
     "[| comparator ?cmp; nat_term_comp ?cmp;
         fst (rep_nat_term ?u) = fst (rep_nat_term ?a);
         fst (rep_nat_term ?v) = fst (rep_nat_term ?b);
         snd (rep_nat_term ?u) = snd (rep_nat_term ?v);
         snd (rep_nat_term ?a) = snd (rep_nat_term ?b) |]
      ==> ?cmp ?u ?v = ?cmp ?a ?b",
     template_implication
      ([template_predicate (template_app (template_hole 7, template_var 4)),
        template_predicate (template_app (template_hole 6, template_var 4)),
        template_equation
         (template_app
           (template_hole 4,
            template_app (template_hole 3, template_var 3)),
          template_app
           (template_hole 4,
            template_app (template_hole 3, template_var 2))),
        template_equation
         (template_app
           (template_hole 4,
            template_app (template_hole 3, template_var 1)),
          template_app
           (template_hole 4,
            template_app (template_hole 3, template_var 0))),
        template_equation
         (template_app
           (template_hole 1,
            template_app (template_hole 3, template_var 3)),
          template_app
           (template_hole 1,
            template_app (template_hole 3, template_var 1))),
        template_equation
         (template_app
           (template_hole 1,
            template_app (template_hole 3, template_var 2)),
          template_app
           (template_hole 1,
            template_app (template_hole 3, template_var 0)))],
       template_equation
        (template_app
          (template_app (template_var 4, template_var 3), template_var 1),
         template_app
          (template_app (template_var 4, template_var 2),
           template_var 0)))),
    ("OAlist_Poly_Mapping.nat_term_compD4",
     "[| nat_term_comp ?cmp; fst (rep_nat_term ?u) = fst (rep_nat_term ?a);
         fst (rep_nat_term ?v) = fst (rep_nat_term ?b);
         snd (rep_nat_term ?u) = snd (rep_nat_term ?v);
         snd (rep_nat_term ?a) = snd (rep_nat_term ?b); ?cmp ?a ?b = Lt |]
      ==> ?cmp ?u ?v = Lt",
     template_implication
      ([template_predicate (template_app (template_hole 7, template_var 4)),
        template_equation
         (template_app
           (template_hole 5,
            template_app (template_hole 4, template_var 3)),
          template_app
           (template_hole 5,
            template_app (template_hole 4, template_var 2))),
        template_equation
         (template_app
           (template_hole 5,
            template_app (template_hole 4, template_var 1)),
          template_app
           (template_hole 5,
            template_app (template_hole 4, template_var 0))),
        template_equation
         (template_app
           (template_hole 2,
            template_app (template_hole 4, template_var 3)),
          template_app
           (template_hole 2,
            template_app (template_hole 4, template_var 1))),
        template_equation
         (template_app
           (template_hole 2,
            template_app (template_hole 4, template_var 2)),
          template_app
           (template_hole 2,
            template_app (template_hole 4, template_var 0))),
        template_equation
         (template_app
           (template_app (template_var 4, template_var 2), template_var 0),
          template_hole 0)],
       template_equation
        (template_app
          (template_app (template_var 4, template_var 3), template_var 1),
         template_hole 0))),
    ("OAlist_Poly_Mapping.nat_term_compD4''",
     "[| comparator ?cmp; nat_term_comp ?cmp;
         fst (rep_nat_term ?u) = fst (rep_nat_term ?a);
         fst (rep_nat_term ?v) = fst (rep_nat_term ?b);
         snd (rep_nat_term ?u) <= snd (rep_nat_term ?v);
         snd (rep_nat_term ?a) = snd (rep_nat_term ?b); ?cmp ?a ?b ~= Gt |]
      ==> ?cmp ?u ?v ~= Gt",
     template_implication
      ([template_predicate
         (template_app (template_hole 10, template_var 4)),
        template_predicate (template_app (template_hole 9, template_var 4)),
        template_equation
         (template_app
           (template_hole 7,
            template_app (template_hole 6, template_var 3)),
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_var 2))),
        template_equation
         (template_app
           (template_hole 7,
            template_app (template_hole 6, template_var 1)),
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_var 0))),
        template_inequation
         (less_equals,
          template_app
           (template_hole 4,
            template_app (template_hole 6, template_var 3)),
          template_app
           (template_hole 4,
            template_app (template_hole 6, template_var 1))),
        template_equation
         (template_app
           (template_hole 4,
            template_app (template_hole 6, template_var 2)),
          template_app
           (template_hole 4,
            template_app (template_hole 6, template_var 0))),
        template_negation
         (
            template_equation
             (template_app
               (template_app (template_var 4, template_var 2),
                template_var 0),
              template_hole 0)
            )],
       template_negation
        (
           template_equation
            (template_app
              (template_app (template_var 4, template_var 3),
               template_var 1),
             template_hole 0)
           ))),
    ("OAlist_Poly_Mapping.nat_term_compI",
     "[| !!u v.
            [| snd (rep_nat_term u) = snd (rep_nat_term v);
               fst (rep_nat_term u) = 0 |]
            ==> ?cmp u v ~= Gt;
         !!u v.
            [| fst (rep_nat_term u) = fst (rep_nat_term v);
               snd (rep_nat_term u) < snd (rep_nat_term v) |]
            ==> ?cmp u v = Lt;
         !!t u v. ?cmp u v = Lt ==> ?cmp (splus t u) (splus t v) = Lt;
         !!u v a b.
            [| fst (rep_nat_term u) = fst (rep_nat_term a);
               fst (rep_nat_term v) = fst (rep_nat_term b);
               snd (rep_nat_term u) = snd (rep_nat_term v);
               snd (rep_nat_term a) = snd (rep_nat_term b); ?cmp a b = Lt |]
            ==> ?cmp u v = Lt |]
      ==> nat_term_comp ?cmp",
     template_implication
      ([template_predicate (template_app (template_hole 14, t_empty)),
        template_predicate (template_app (template_hole 14, t_empty)),
        template_predicate (template_app (template_hole 14, t_empty)),
        template_predicate (template_app (template_hole 14, t_empty))],
       template_predicate
        (template_app (template_hole 0, template_var 0))))]:
   (string * thm * template) list
### theory "Draft.OAlist_Poly_MappingTemplates"
### 0.670s elapsed time, 1.320s cpu time, 0.164s GC time
val it = (): unit
