Loading theory "Draft.MPoly_Type" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products" via "Draft.More_MPoly_Type")
Loading theory "Draft.More_Modules" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.MPoly_Type_Class_Ordered" via "Draft.MPoly_Type_Class")
Loading theory "Draft.OAlist" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping")
Loading theory "Draft.Templates" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.ExtrEqs")
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.120s elapsed time, 0.470s cpu time, 0.065s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.MPoly_Type_Class_OAlistTemplates")
### Missing patterns in function definition:
### !!a. min_list_param a [] = undefined
instantiation
  mpoly :: (zero) zero
  zero_mpoly == zero_class.zero :: 'a mpoly
instantiation
  mpoly :: (monoid_add) monoid_add
  plus_mpoly == plus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_mpoly == minus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (ab_group_add) ab_group_add
  uminus_mpoly == uminus :: 'a mpoly => 'a mpoly
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  mpoly :: (zero_neq_one) zero_neq_one
  one_mpoly == one_class.one :: 'a mpoly
### theory "Draft.More_Modules"
### 0.209s elapsed time, 0.818s cpu time, 0.065s GC time
Loading theory "Draft.Utils" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products")
instantiation
  mpoly :: (semiring_0) semiring_0
  times_mpoly == times :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  key_order :: (type) equal
  equal_key_order == equal_class.equal ::
    'a key_order => 'a key_order => bool
instantiation
  key_order :: (type) uminus
  uminus_key_order == uminus :: 'a key_order => 'a key_order
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### linorder.Min (le_of_key_order ?ko) (set (?x # ?xs)) ==
### fold (key_order_lin.min ?ko) ?xs ?x
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### linorder.Max (le_of_key_order ?ko) (set (?x # ?xs)) ==
### fold (key_order_lin.max ?ko) ?xs ?x
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko [] == True
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko [?x] == True
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted ?ko (?x # ?y # ?zs) ==
### le_of_key_order ?ko ?x ?y & key_order_lin.sorted ?ko (?y # ?zs)
### Partially applied constant "OAlist.le_of_key_order" on left hand side of equation, in theorem:
### key_order_lin.sorted_list_of_set ?ko (set ?xs) ==
### key_order_lin.sort ?ko (remdups ?xs)
### Ambiguous input (line 494 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>div" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 498 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>mod" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Utils"
### 0.322s elapsed time, 1.214s cpu time, 0.183s GC time
MPoly (mapping_of ?x) = ?x
?y : UNIV ==> mapping_of (MPoly ?y) = ?y
(mapping_of ?x = mapping_of ?y) = (?x = ?y)
[| ?x : UNIV; ?y : UNIV |] ==> (MPoly ?x = MPoly ?y) = (?x = ?y)
[| ?y : UNIV; !!x. ?P (mapping_of x) |] ==> ?P ?y
(!!y. y : UNIV ==> ?P (MPoly y)) ==> ?P ?x
[| ?y : UNIV; !!x. ?y = mapping_of x ==> ?P |] ==> ?P
(!!y. [| ?x = MPoly y; y : UNIV |] ==> ?P) ==> ?P
### Ambiguous input (line 502 of "$AFP/Polynomials/MPoly_Type.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 505 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 509 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.MPoly_Type"
### 0.578s elapsed time, 2.195s cpu time, 0.248s GC time
Loading theory "Draft.More_MPoly_Type" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type" via "Draft.Power_Products")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.662s elapsed time, 2.505s cpu time, 0.281s GC time
locale comparator
  fixes comp :: "'a => 'a => order"
  assumes "comparator comp"
### theory "Draft.More_MPoly_Type"
### 0.300s elapsed time, 1.057s cpu time, 0.170s GC time
Loading theory "Draft.Power_Products" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.PP_Type")
"(Gcd (coeffs
        (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
          6 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
          8)),
  sdiv
   (Gcd (coeffs
          (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
            6 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
            8)))
   (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
    M [(1::'b) + (1::'b), 0::'b, (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
     6 +
    M [(1::'b) + (1::'b), 0::'b,
       (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
     8))"
  :: "'a * 'a mpoly"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. size_list size (snd (snd (snd (snd p))))) <*mlex*>
   (%p. size_list size (fst (snd (snd (snd p))))) <*mlex*> {}"
class plus = type +
  fixes plus :: "'a => 'a => 'a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class ninv_comm_monoid_add = comm_monoid_add +
  assumes "plus_eq_zero": "!!s t. s + t = (0::'a) ==> s = (0::'a)"
Found termination order:
  "(%p. size_list size (snd (snd p))) <*mlex*>
   (%p. size_list size (fst (snd p))) <*mlex*> {}"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
Found termination order:
  "(%p. size_list size (snd (snd p))) <*mlex*>
   (%p. size_list size (fst (snd p))) <*mlex*> {}"
class lcs_powerprod = comm_powerprod +
  fixes lcs :: "'a => 'a => 'a"
  assumes "adds_lcs": "!!s t. s adds lcs s t"
  assumes "lcs_adds": "!!s u t. [| s adds u; t adds u |] ==> lcs s t adds u"
  assumes "lcs_comm": "!!s t. lcs s t = lcs t s"
class graded_dickson_powerprod = ulcs_powerprod +
  assumes "ex_dgrad": "EX d. dickson_grading d"
class dickson_powerprod = ulcs_powerprod +
  assumes "dickson": "almost_full_on (adds) UNIV"
locale comparator2
  fixes comp1 :: "'a => 'a => order"
    and comp2 :: "'a => 'a => order"
  assumes "comparator2 comp1 comp2"
locale oalist_raw
  fixes rep_key_order :: "'o => 'a key_order"
class semi_canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_imp_add": "!!a b. a <= b ==> EX c. b = a + c"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  ninv_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
[| le ?x ?a ?b; le ?x ?b ?c |] ==> le ?x ?a ?c
[| le ?x ?a ?b; le ?x ?b ?c |] ==> le ?x ?a ?c
[| ?a <= ?b; ?b <= ?c |] ==> ?a <= ?c
[| le ?xa ?x ?y; le ?xa ?y ?z |] ==> le ?xa ?x ?z
locale oalist_raw
  fixes rep_key_order :: "'o => 'a key_order"
class add_linorder_min = add_linorder +
  assumes "zero_min": "!!x. (0::'a) <= x"
locale oalist_abstract
  fixes rep_key_order :: "'o => 'a key_order"
    and list_of_oalist :: "'x => ('a * 'b) list * 'o"
    and oalist_of_list :: "('a * 'b) list * 'o => 'x"
  assumes "oalist_abstract rep_key_order list_of_oalist oalist_of_list"
instantiation
  nat :: add_linorder
instantiation
  nat :: add_linorder_min
instantiation
  nat :: add_wellorder
instantiation
  int :: add_linorder_group
instantiation
  rat :: add_linorder_group
instantiation
  real :: add_linorder_group
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "od_powerprod (\<preceq>) (\<prec>)"
instantiation
  fun :: (type, add_linorder) lcs_powerprod
  lcs_fun == lcs :: ('a => 'b) => ('a => 'b) => 'a => 'b
locale oalist_abstract3
  fixes rep_key_order :: "'o => 'a key_order"
    and list_of_oalistx :: "'x => ('a * 'b) list * 'o"
    and oalist_of_listx :: "('a * 'b) list * 'o => 'x"
    and list_of_oalisty :: "'y => ('a * 'c) list * 'o"
    and oalist_of_listy :: "('a * 'c) list * 'o => 'y"
    and list_of_oalistz :: "'z => ('a * 'd) list * 'o"
    and oalist_of_listz :: "('a * 'd) list * 'o => 'z"
  assumes
    "oalist_abstract3 rep_key_order list_of_oalistx oalist_of_listx
      list_of_oalisty oalist_of_listy list_of_oalistz oalist_of_listz"
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp (key_compare ?ko)) (set (?x # ?xs)) ==
### fold (ko.min ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp (key_compare ?ko)) (set (?x # ?xs)) ==
### fold (ko.max ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted ?ko (?x # ?y # ?zs) ==
### le_of_comp (key_compare ?ko) ?x ?y & ko.sorted ?ko (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko.sorted_list_of_set ?ko (set ?xs) == ko.sort ?ko (remdups ?xs)
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
instantiation
  poly_mapping :: (type, add_linorder) lcs_powerprod
  lcs_poly_mapping == lcs ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Draft.Power_Products"
### 9.605s elapsed time, 20.740s cpu time, 3.824s GC time
Loading theory "Draft.MPoly_Type_Class" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping" via "Draft.MPoly_Type_Class_Ordered")
Loading theory "Draft.PP_Type" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping")
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
instantiation
  pp :: (type, zero) zero
  zero_pp == zero_class.zero :: ('a, 'b) pp
instantiation
  pp :: (type, monoid_add) monoid_add
  plus_pp == plus :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (type, cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_pp == minus :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (type, add_linorder) lcs_powerprod
  lcs_pp == lcs :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (linorder, {ordered_comm_monoid_add,linorder}) linorder
  less_eq_pp == less_eq :: ('a, 'b) pp => ('a, 'b) pp => bool
  less_pp == less :: ('a, 'b) pp => ('a, 'b) pp => bool
### theory "Draft.PP_Type"
### 0.866s elapsed time, 2.810s cpu time, 1.515s GC time
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Cannot skip proof of schematic goal statement
### Ambiguous input (line 1415 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Ambiguous input (line 1454 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1463 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("\<^const>Series.suminf_binder" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("_Sum_any" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### theory "Draft.MPoly_Type_Class"
### 2.294s elapsed time, 5.703s cpu time, 1.850s GC time
Loading theory "Draft.MPoly_Type_Class_Ordered" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order" via "Draft.OAlist_Poly_Mapping")
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp comparator_of) (set (?x # ?xs)) ==
### fold tc.min ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp comparator_of) (set (?x # ?xs)) ==
### fold tc.max ?xs ?x
class the_min = linorder +
  fixes the_min :: "'a"
  assumes "the_min_min": "!!x. the_min <= x"
instantiation
  nat :: the_min
  the_min_nat == the_min :: nat
instantiation
  unit :: the_min
  the_min_unit == the_min :: unit
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted (?x # ?y # ?zs) ==
### le_of_comp comparator_of ?x ?y & tc.sorted (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### tc.sorted_list_of_set (set ?xs) == tc.sort (remdups ?xs)
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
instantiation
  oalist_tc :: (linorder, zero) equal
  equal_oalist_tc == equal_class.equal ::
    ('a, 'b) oalist_tc => ('a, 'b) oalist_tc => bool
### theory "Draft.OAlist"
### 16.138s elapsed time, 37.935s cpu time, 10.266s GC time
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale gd_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "gd_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "od_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
### theory "Draft.MPoly_Type_Class_Ordered"
### 7.149s elapsed time, 13.135s cpu time, 4.844s GC time
Loading theory "Draft.OAlist_Poly_Mapping" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist" via "Draft.Term_Order")
class nat_term = type +
  fixes rep_nat_term :: "'a => (nat, nat) pp * nat"
    and splus :: "'a => 'a => 'a"
  assumes
    "rep_nat_term_inj": "!!x y. rep_nat_term x = rep_nat_term y ==> x = y"
    and
    "full_component":
      "!!x i t. snd (rep_nat_term x) = i ==> EX y. rep_nat_term y = (t, i)"
    and
    "splus_term":
      "!!x y.
          rep_nat_term (splus x y) =
          pprod.splus (fst (rep_nat_term x)) (rep_nat_term y)"
class nat_pp_term = plus + zero + nat_term +
  assumes "rep_nat_term_zero": "rep_nat_term (0::'a) = (0, 0)"
    and "splus_pp_term": "splus = (+)"
instantiation
  nat_term_order :: (type) equal
  equal_nat_term_order == equal_class.equal ::
    'a nat_term_order => 'a nat_term_order => bool
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Min (le_of_comp (nat_term_compare_inv ?ko)) (set (?x # ?xs)) ==
### fold (ko_ntm.min ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### linorder.Max (le_of_comp (nat_term_compare_inv ?ko)) (set (?x # ?xs)) ==
### fold (ko_ntm.max ?ko) ?xs ?x
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko [] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko [?x] == True
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted ?ko (?x # ?y # ?zs) ==
### le_of_comp (nat_term_compare_inv ?ko) ?x ?y & ko_ntm.sorted ?ko (?y # ?zs)
### Partially applied constant "Comparator.le_of_comp" on left hand side of equation, in theorem:
### ko_ntm.sorted_list_of_set ?ko (set ?xs) == ko_ntm.sort ?ko (remdups ?xs)
### Cannot skip proof of schematic goal statement
### theory "Draft.OAlist_Poly_Mapping"
### 3.781s elapsed time, 4.154s cpu time, 0.583s GC time
Loading theory "Draft.Term_Order" (required by "Draft.MPoly_Type_Class_OAlistTemplates" via "Draft.MPoly_Type_Class_OAlist")
class nat = minus + plus + zero + equal + order +
  fixes rep_nat :: "'a => nat"
    and abs_nat :: "nat => 'a"
  assumes "rep_inverse": "!!x. abs_nat (rep_nat x) = x"
    and "abs_inverse": "!!n. rep_nat (abs_nat n) = n"
    and "abs_zero": "abs_nat 0 = (0::'a)"
    and "abs_plus": "!!m n. abs_nat m + abs_nat n = abs_nat (m + n)"
    and "abs_minus": "!!m n. abs_nat m - abs_nat n = abs_nat (m - n)"
    and "abs_ord": "!!m n. m <= n ==> abs_nat m <= abs_nat n"
instantiation
  nat :: nat
  rep_nat_nat == rep_nat :: nat => nat
  abs_nat_nat == abs_nat :: nat => nat
instantiation
  natural :: nat
  rep_nat_natural == rep_nat :: natural => nat
  abs_nat_natural == abs_nat :: nat => natural
class nat_pp_compare = plus + zero + linorder +
  fixes rep_nat_pp :: "'a => (nat, nat) pp"
    and abs_nat_pp :: "(nat, nat) pp => 'a"
    and lex_comp' :: "'a => 'a => order"
    and deg' :: "'a => nat"
  assumes "rep_nat_pp_inverse": "!!x. abs_nat_pp (rep_nat_pp x) = x"
    and "abs_nat_pp_inverse": "!!t. rep_nat_pp (abs_nat_pp t) = t"
    and
    "lex_comp'":
      "!!x y.
          lex_comp' x y = comp_of_ord lex_pp (rep_nat_pp x) (rep_nat_pp y)"
    and "deg'": "!!x. deg' x = deg_pp (rep_nat_pp x)"
    and "le_pp": "!!x y. rep_nat_pp x <= rep_nat_pp y ==> x <= y"
    and "zero_pp": "rep_nat_pp (0::'a) = 0"
    and "plus_pp": "!!x y. rep_nat_pp (x + y) = rep_nat_pp x + rep_nat_pp y"
class nat_term_compare = nat_term + linorder +
  fixes is_scalar :: "'a itself => bool"
    and lex_comp :: "'a => 'a => order"
    and deg_comp :: "('a => 'a => order) => 'a => 'a => order"
    and pot_comp :: "('a => 'a => order) => 'a => 'a => order"
  assumes "zero_component": "EX x. snd (rep_nat_term x) = 0"
    and "is_scalar": "is_scalar = (%_. ALL x. snd (rep_nat_term x) = 0)"
    and "lex_comp": "lex_comp = lex_comp_aux"
    and
    "deg_comp":
      "!!cmp.
          deg_comp cmp =
          (%x y. case comparator_of (deg_pp (fst (rep_nat_term x)))
                       (deg_pp (fst (rep_nat_term y))) of
                 Eq => cmp x y | Lt => Lt | Gt => Gt)"
    and
    "pot_comp":
      "!!cmp.
          pot_comp cmp =
          (%x y. case comparator_of (snd (rep_nat_term x))
                       (snd (rep_nat_term y)) of
                 Eq => cmp x y | Lt => Lt | Gt => Gt)"
    and "le_term": "!!x y. rep_nat_term x <= rep_nat_term y ==> x <= y"
instantiation
  pp :: (nat, nat) nat_pp_compare
  rep_nat_pp_pp == rep_nat_pp :: ('a, 'b) pp => (nat, nat) pp
  abs_nat_pp_pp == abs_nat_pp :: (nat, nat) pp => ('a, 'b) pp
  lex_comp'_pp == lex_comp' :: ('a, 'b) pp => ('a, 'b) pp => order
  deg'_pp == deg' :: ('a, 'b) pp => nat
instantiation
  pp :: (nat, nat) nat_term
  rep_nat_term_pp == rep_nat_term :: ('a, 'b) pp => (nat, nat) pp * nat
  splus_pp == splus :: ('a, 'b) pp => ('a, 'b) pp => ('a, 'b) pp
instantiation
  pp :: (nat, nat) nat_term_compare
  is_scalar_pp == is_scalar :: ('a, 'b) pp itself => bool
  lex_comp_pp == lex_comp :: ('a, 'b) pp => ('a, 'b) pp => order
  deg_comp_pp == deg_comp ::
    (('a, 'b) pp => ('a, 'b) pp => order)
    => ('a, 'b) pp => ('a, 'b) pp => order
  pot_comp_pp == pot_comp ::
    (('a, 'b) pp => ('a, 'b) pp => order)
    => ('a, 'b) pp => ('a, 'b) pp => order
instantiation
  prod :: ({comm_powerprod,nat_pp_compare}, nat) nat_term
  rep_nat_term_prod == rep_nat_term :: 'a * 'b => (nat, nat) pp * nat
  splus_prod == splus :: 'a * 'b => 'a * 'b => 'a * 'b
instantiation
  prod :: ({comm_powerprod,nat_pp_compare}, nat) nat_term_compare
  is_scalar_prod == is_scalar :: ('a * 'b) itself => bool
  lex_comp_prod == lex_comp :: 'a * 'b => 'a * 'b => order
  deg_comp_prod == deg_comp ::
    ('a * 'b => 'a * 'b => order) => 'a * 'b => 'a * 'b => order
  pot_comp_prod == pot_comp ::
    ('a * 'b => 'a * 'b => order) => 'a * 'b => 'a * 'b => order
### theory "Draft.Term_Order"
### 3.325s elapsed time, 3.697s cpu time, 0.319s GC time
Loading theory "Draft.MPoly_Type_Class_OAlist" (required by "Draft.MPoly_Type_Class_OAlistTemplates")
instantiation
  pp :: (type, {zero,equal}) equal
  equal_pp == equal_class.equal :: ('a, 'b) pp => ('a, 'b) pp => bool
instantiation
  poly_mapping :: (type, {zero,equal}) equal
  equal_poly_mapping == equal_class.equal ::
    ('a \<Rightarrow>\<^sub>0 'b) => ('a \<Rightarrow>\<^sub>0 'b) => bool
locale experiment11201184
"True"
  :: "bool"
"False"
  :: "bool"
"True"
  :: "bool"
"PP_oalist (OAlist_tc [(0, 2), (2, 7)])"
  :: "(nat, nat) pp"
locale gd_nat_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and cmp_term :: "'t nat_term_order"
  assumes "gd_nat_term pair_of_term term_of_pair cmp_term"
locale gd_nat_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and cmp_term :: "'t nat_term_order"
  assumes "gd_nat_term pair_of_term term_of_pair cmp_term"
### Cannot skip proof of schematic goal statement
### Abstraction on left hand side of equation, in theorem:
### linorder.Min
###  (%s t. le_of_nat_term_order ?cmp_term (fst (s, the_min))
###          (fst (t, the_min)))
###  (set (?x # ?xs)) ==
### fold (punit0.ordered_powerprod_lin.min ?cmp_term) ?xs ?x
### Abstraction on left hand side of equation, in theorem:
### linorder.Max
###  (%s t. le_of_nat_term_order ?cmp_term (fst (s, the_min))
###          (fst (t, the_min)))
###  (set (?x # ?xs)) ==
### fold (punit0.ordered_powerprod_lin.max ?cmp_term) ?xs ?x
### Abstraction on left hand side of equation, in theorem:
### punit0.ordered_powerprod_lin.sorted ?cmp_term [] == True
### Abstraction on left hand side of equation, in theorem:
### punit0.ordered_powerprod_lin.sorted ?cmp_term [?x] == True
### Abstraction on left hand side of equation, in theorem:
### punit0.ordered_powerprod_lin.sorted ?cmp_term (?x # ?y # ?zs) ==
### le_of_nat_term_order ?cmp_term (fst (?x, the_min)) (fst (?y, the_min)) &
### punit0.ordered_powerprod_lin.sorted ?cmp_term (?y # ?zs)
### Abstraction on left hand side of equation, in theorem:
### punit0.ordered_powerprod_lin.sorted_list_of_set ?cmp_term (set ?xs) ==
### punit0.ordered_powerprod_lin.sort ?cmp_term (remdups ?xs)
### Abstraction on left hand side of equation, in theorem:
### punit0.punit.ord_strict_p ?cmp_term ?p ?q ==
### ?q ~= 0 &
### (?p = 0 |
###  (let v1 = punit0.punit.lt ?cmp_term ?p; v2 = punit0.punit.lt ?cmp_term ?q
###   in lt_of_nat_term_order ?cmp_term (fst (v1, the_min))
###       (fst (v2, the_min)) |
###      v1 = v2 &
###      lookup ?p v1 = lookup ?q v2 &
###      punit0.punit.ord_strict_p ?cmp_term
###       (punit0.punit.lower ?cmp_term ?p v1)
###       (punit0.punit.lower ?cmp_term ?q v2)))
### Partially applied constant "OAlist_Poly_Mapping.le_of_nat_term_order" on left hand side of equation, in theorem:
### linorder.Min (le_of_nat_term_order ?cmp_term) (set (?x # ?xs)) ==
### fold (punit0.ord_term_lin.min ?cmp_term) ?xs ?x
### Partially applied constant "OAlist_Poly_Mapping.le_of_nat_term_order" on left hand side of equation, in theorem:
### linorder.Max (le_of_nat_term_order ?cmp_term) (set (?x # ?xs)) ==
### fold (punit0.ord_term_lin.max ?cmp_term) ?xs ?x
### Partially applied constant "OAlist_Poly_Mapping.le_of_nat_term_order" on left hand side of equation, in theorem:
### punit0.ord_term_lin.sorted ?cmp_term [] == True
### Partially applied constant "OAlist_Poly_Mapping.le_of_nat_term_order" on left hand side of equation, in theorem:
### punit0.ord_term_lin.sorted ?cmp_term [?x] == True
### Partially applied constant "OAlist_Poly_Mapping.le_of_nat_term_order" on left hand side of equation, in theorem:
### punit0.ord_term_lin.sorted ?cmp_term (?x # ?y # ?zs) ==
### le_of_nat_term_order ?cmp_term ?x ?y &
### punit0.ord_term_lin.sorted ?cmp_term (?y # ?zs)
### Partially applied constant "OAlist_Poly_Mapping.le_of_nat_term_order" on left hand side of equation, in theorem:
### punit0.ord_term_lin.sorted_list_of_set ?cmp_term (set ?xs) ==
### punit0.ord_term_lin.sort ?cmp_term (remdups ?xs)
### Code generator: dropping subsumed code equation
### ord_strict_p_punit ?cmp_term ?p ?q ==
### ?q ~= 0 &
### (?p = 0 |
###  (let v1 = lt_punit ?cmp_term ?p; v2 = lt_punit ?cmp_term ?q
###   in lt_of_nat_term_order ?cmp_term v1 v2 |
###      v1 = v2 &
###      lookup ?p v1 = lookup ?q v2 &
###      ord_strict_p_punit ?cmp_term (punit0.lower ?cmp_term ?p v1)
###       (punit0.lower ?cmp_term ?q v2)))
locale trivariate\<^sub>0_rat
locale experiment11318086
instantiation
  mpoly :: ({zero,equal}) equal
  equal_mpoly == equal_class.equal :: 'a mpoly => 'a mpoly => bool
### theory "Draft.MPoly_Type_Class_OAlist"
### 6.086s elapsed time, 9.199s cpu time, 1.246s GC time
Loading theory "Draft.MPoly_Type_Class_OAlistTemplates"
"True"
  :: "bool"
val templateLemmas =
   [("MPoly_Type_Class_OAlist.gd_nat_term_to_pair_unit",
     "gd_nat_term to_pair_unit fst ?cmp_term",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 0),
           template_var 0)
         )),
    ("MPoly_Type_Class_OAlist.MP_oalist_empty",
     "MP_oalist (OAlist_empty_ntm ?ko) = 0",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_OAlist.gd_powerprod_ord_pp_punit",
     "gd_powerprod (ord_pp_punit ?cmp_term)
       (ord_pp_strict_punit ?cmp_term)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 0)),
           template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_OAlist.lookup_PP_oalist",
     "lookup_pp (PP_oalist ?xs) = OAlist_tc_lookup ?xs",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_OAlist.C\<^sub>0_numeral",
     "C\<^sub>0 (numeral ?x) = numeral ?x",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_OAlist.gd_nat_term_id",
     "gd_nat_term (%x. x) (%x. x) ?cmp_term",
     template_predicate
      (
         template_app
          (template_app (template_app (template_hole 0, t_empty), t_empty),
           template_var 0)
         )),
    ("MPoly_Type_Class_OAlist.keys_PP_oalist",
     "keys_pp (PP_oalist ?xs) = set (OAlist_tc_sorted_domain ?xs)",
     template_equation
      (template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("MPoly_Type_Class_OAlist.C\<^sub>0_minus",
     "C\<^sub>0 (- ?x) = - C\<^sub>0 ?x",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 0, template_app (template_hole 2, template_var 0)))),
    ("MPoly_Type_Class_OAlist.is_zero_MP_oalist",
     "is_zero (MP_oalist ?xs) = List.null (fst (list_of_oalist_ntm ?xs))",
     template_equation
      (template_app
        (template_hole 4, template_app (template_hole 3, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_hole 1,
           template_app (template_hole 0, template_var 0))))),
    ("MPoly_Type_Class_OAlist.deg_pp_PP_oalist",
     "deg_pp (PP_oalist ?xs) = sum_list (map snd (list_of_oalist_tc ?xs))",
     template_equation
      (template_app
        (template_hole 5, template_app (template_hole 4, template_var 0)),
       template_app
        (template_hole 3,
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_app (template_hole 0, template_var 0))))),
    ("MPoly_Type_Class_OAlist.equal_PP_oalist",
     "equal_class.equal (PP_oalist ?xs) (PP_oalist ?ys) = (?xs = ?ys)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app (template_hole 1, template_var 1)),
              template_app (template_hole 1, template_var 0))
            )],
       template_equation (template_var 1, template_var 0))),
    ("MPoly_Type_Class_OAlist.equal_MP_oalist",
     "equal_class.equal (MP_oalist ?xs) (MP_oalist ?ys) =
      OAlist_eq_ntm ?xs ?ys",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("MPoly_Type_Class_OAlist.change_ord_MP_oalist",
     "change_ord ?to (MP_oalist ?xs) =
      MP_oalist (OAlist_reorder_ntm ?to ?xs)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_OAlist.uminus_MP_oalist",
     "- MP_oalist ?xs = MP_oalist (OAlist_map_val_ntm (%_. uminus) ?xs)",
     template_equation
      (template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, t_empty), template_var 0)))),
    ("MPoly_Type_Class_OAlist.range_MP_oalist",
     "Poly_Mapping.range (MP_oalist ?xs) =
      set (map snd (fst (list_of_oalist_ntm ?xs)))",
     template_equation
      (template_app
        (template_hole 6, template_app (template_hole 5, template_var 0)),
       template_app
        (template_hole 4,
         template_app
          (template_app (template_hole 3, template_hole 2),
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))))),
    ("MPoly_Type_Class_OAlist.keys_MP_oalist",
     "keys (MP_oalist ?xs) = set (map fst (fst (list_of_oalist_ntm ?xs)))",
     template_equation
      (template_app
        (template_hole 6, template_app (template_hole 5, template_var 0)),
       template_app
        (template_hole 4,
         template_app
          (template_app (template_hole 3, template_hole 2),
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))))),
    ("MPoly_Type_Class_OAlist.map_MP_oalist",
     "Poly_Mapping.map ?f (MP_oalist ?xs) =
      MP_oalist (OAlist_map_val_ntm (%_. ?f) ?xs)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, t_empty), template_var 0)))),
    ("MPoly_Type_Class_OAlist.V\<^sub>0_power",
     "V\<^sub>0 ?v ^ ?n = monomial (1::?'b) (single_pp ?v ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 1),
             template_var 0)),
         template_hole 0))),
    ("MPoly_Type_Class_OAlist.adds_pp_PP_oalist",
     "adds_pp_add_linorder (PP_oalist ?xs) (PP_oalist ?ys) =
      OAlist_tc_prod_ord (%_. (<=)) ?xs ?ys",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 1, t_empty), template_var 1),
         template_var 0))),
    ("MPoly_Type_Class_OAlist.single_PP_oalist",
     "single_pp ?x ?e = PP_oalist (oalist_tc_of_list [(?x, ?e)])",
     template_equation
      (template_app
        (template_app (template_hole 5, template_var 1), template_var 0),
       template_app
        (template_hole 4,
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0)),
             template_hole 0))))),
    ("MPoly_Type_Class_OAlist.single_MP_oalist",
     "monomial ?v ?k = distr\<^sub>0 nat_term_order_of_le [(?k, ?v)]",
     template_equation
      (template_app
        (template_app (template_hole 5, template_var 1), template_var 0),
       template_app
        (template_app (template_hole 4, template_hole 3),
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 1),
               template_var 0)),
           template_hole 0)))),
    ("MPoly_Type_Class_OAlist.plus_PP_oalist",
     "PP_oalist ?xs + PP_oalist ?ys =
      PP_oalist (OAlist_tc_map2_val_neutr (%_. (+)) ?xs ?ys)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, t_empty), template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_OAlist.minus_PP_oalist",
     "PP_oalist ?xs - PP_oalist ?ys =
      PP_oalist (OAlist_tc_map2_val_rneutr (%_. (-)) ?xs ?ys)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, t_empty), template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_OAlist.lcs_PP_oalist",
     "lcs (PP_oalist ?xs) (PP_oalist ?ys) =
      PP_oalist (OAlist_tc_map2_val_neutr (%_. max) ?xs ?ys)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, t_empty), template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_OAlist.plus_MP_oalist",
     "MP_oalist ?xs + MP_oalist ?ys =
      MP_oalist (OAlist_map2_val_neutr_ntm (%_. (+)) ?xs ?ys)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, t_empty), template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_OAlist.minus_MP_oalist",
     "MP_oalist ?xs - MP_oalist ?ys =
      MP_oalist (OAlist_map2_val_rneutr_ntm (%_. (-)) ?xs ?ys)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, t_empty), template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_OAlist.except_MP_oalist",
     "except (MP_oalist ?xs) ?S =
      MP_oalist (OAlist_filter_ntm (%kv. fst kv ~: ?S) ?xs)",
     template_equation
      (template_app
        (template_app
          (template_hole 5, template_app (template_hole 4, template_var 1)),
         template_var 0),
       template_app
        (template_hole 4,
         template_app
          (template_app (template_hole 3, t_empty), template_var 1)))),
    ("MPoly_Type_Class_OAlist.plus_monomial_less_MP_oalist",
     "plus_monomial_less (MP_oalist ?xs) ?c ?u =
      MP_oalist (OAlist_update_by_fun_gr_ntm ?u (%c0. c0 + ?c) ?xs)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, template_var 0), t_empty),
           template_var 2)))),
    ("MPoly_Type_Class_OAlist.lex_comp_PP_oalist",
     "lex_comp' (PP_oalist ?xs) (PP_oalist ?ys) =
      the (OAlist_tc_lex_ord (%_ x y. Some (comparator_of x y)) ?xs ?ys)",
     template_equation
      (template_app
        (template_app
          (template_hole 5, template_app (template_hole 4, template_var 1)),
         template_app (template_hole 4, template_var 0)),
       template_app
        (template_hole 3,
         template_app
          (template_app
            (template_app (template_hole 2, t_empty), template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_OAlist.shift_map_keys_punit_MP_oalist",
     "list_of_oalist_ntm (shift_map_keys_punit ?t ?f ?xs) =
      map_raw (%(k, v). (?t + k, ?f v)) (list_of_oalist_ntm ?xs)",
     template_equation
      (template_app
        (template_hole 5,
         template_app
          (template_app
            (template_app (template_hole 4, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, t_empty)),
         template_app (template_hole 5, template_var 0)))),
    ("MPoly_Type_Class_OAlist.if_poly_mapping_eq_iff",
     "(if ?x = ?y then ?a else ?b) =
      (if ALL i:keys ?x Un keys ?y. lookup ?x i = lookup ?y i then ?a
       else ?b)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_var 3)),
                   template_app (template_hole 2, template_var 2))),
               t_empty)),
           template_var 1),
         template_var 0))),
    ("MPoly_Type_Class_OAlist.gd_term_id",
     "gd_term (%x. x) (%x. x)
       (%s t. le_of_nat_term_order ?cmp_term (s, the_min) (t, the_min))
       (%s t. lt_of_nat_term_order ?cmp_term (s, the_min) (t, the_min))
       (le_of_nat_term_order ?cmp_term) (lt_of_nat_term_order ?cmp_term)",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 4, t_empty), t_empty),
                 t_empty),
               t_empty),
             template_app (template_hole 3, template_var 0)),
           template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_OAlist.keys_add_eq",
     "keys (?a + ?b) =
      keys ?a Un keys ?b -
      {x: keys ?a Int keys ?b. lookup ?a x + lookup ?b x = (0::?'b)}",
     template_equation
      (template_app
        (template_hole 11,
         template_app
          (template_app (template_hole 10, template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_hole 9,
           template_app
            (template_app
              (template_hole 8,
               template_app (template_hole 11, template_var 1)),
             template_app (template_hole 11, template_var 0))),
         template_app (template_hole 7, t_empty)))),
    ("MPoly_Type_Class_OAlist.gd_term_to_pair_unit",
     "gd_term to_pair_unit fst
       (%s t. le_of_nat_term_order ?cmp_term (fst (s, the_min))
               (fst (t, the_min)))
       (%s t. lt_of_nat_term_order ?cmp_term (fst (s, the_min))
               (fst (t, the_min)))
       (le_of_nat_term_order ?cmp_term) (lt_of_nat_term_order ?cmp_term)",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 16, template_hole 15),
                   template_hole 14),
                 t_empty),
               t_empty),
             template_app (template_hole 13, template_var 0)),
           template_app (template_hole 6, template_var 0))
         )),
    ("MPoly_Type_Class_OAlist.foldl_assoc",
     "(!!x y z. ?f (?f x y) z = ?f x (?f y z)) ==>
      foldl ?f (?f ?a ?b) ?xs = ?f ?a (foldl ?f ?b ?xs)",
     template_implication
      ([template_predicate (template_app (template_hole 3, t_empty))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_app
              (template_app (template_var 3, template_var 2),
               template_var 1)),
           template_var 0),
         template_app
          (template_app (template_var 3, template_var 2),
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 1),
             template_var 0))))),
    ("MPoly_Type_Class_OAlist.term_powerprod_gd_term",
     "[| term_powerprod ?pair_of_term ?term_of_pair;
         !!v. fst (rep_nat_term v) = rep_nat_pp (fst (?pair_of_term v));
         !!t. snd (rep_nat_term (?term_of_pair (t, the_min))) = 0;
         !!v w.
            snd (?pair_of_term v) <= snd (?pair_of_term w) ==>
            snd (rep_nat_term v) <= snd (rep_nat_term w);
         !!s t k.
            ?term_of_pair (s + t, k) =
            splus (?term_of_pair (s, k)) (?term_of_pair (t, k));
         !!t v.
            term_powerprod.splus ?pair_of_term ?term_of_pair t v =
            splus (?term_of_pair (t, the_min)) v |]
      ==> gd_term ?pair_of_term ?term_of_pair
           (%s t. le_of_nat_term_order ?cmp_term
                   (?term_of_pair (s, the_min))
                   (?term_of_pair (t, the_min)))
           (%s t. lt_of_nat_term_order ?cmp_term
                   (?term_of_pair (s, the_min))
                   (?term_of_pair (t, the_min)))
           (le_of_nat_term_order ?cmp_term)
           (lt_of_nat_term_order ?cmp_term)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 23, template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 22, t_empty)),
        template_predicate (template_app (template_hole 16, t_empty)),
        template_predicate (template_app (template_hole 22, t_empty)),
        template_predicate (template_app (template_hole 16, t_empty)),
        template_predicate (template_app (template_hole 16, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 2, template_var 2),
                     template_var 1),
                   t_empty),
                 t_empty),
               template_app (template_hole 1, template_var 0)),
             template_app (template_hole 0, template_var 0))
           )))]:
   (string * thm * template) list
### theory "Draft.MPoly_Type_Class_OAlistTemplates"
### 1.825s elapsed time, 6.483s cpu time, 0.900s GC time
"MP_oalist
  (OAlist_ntm ([(PP_oalist (OAlist_tc [(0, 2)]), 1)], Term_Order.LEX))"
  :: "(nat, nat) pp \<Rightarrow>\<^sub>0 rat"
"MP_oalist
  (OAlist_ntm
    ([(PP_oalist (OAlist_tc [(0, 2), (2, 1)]), 1),
      (PP_oalist (OAlist_tc [(1, 3), (2, 2)]), 2)],
     Term_Order.LEX))"
  :: "(nat, nat) pp \<Rightarrow>\<^sub>0 rat"
"PP_oalist (OAlist_tc [])"
  :: "(nat, nat) pp"
"False"
  :: "bool"
"PP_oalist (OAlist_tc [(0, 3)])"
  :: "(nat, nat) pp"
val it = (): unit
