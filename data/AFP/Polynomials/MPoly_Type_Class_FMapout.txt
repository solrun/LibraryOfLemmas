Loading theory "Draft.MPoly_Type" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.MPoly_Type_Class_FMap" via "Draft.MPoly_Type_Class_Ordered" via "Draft.MPoly_Type_Class" via "Draft.Power_Products" via "Draft.More_MPoly_Type")
Loading theory "Draft.Templates" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.ExtrEqs")
Loading theory "Draft.More_Modules" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.MPoly_Type_Class_FMap" via "Draft.MPoly_Type_Class_Ordered" via "Draft.MPoly_Type_Class")
Loading theory "Draft.Utils" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.MPoly_Type_Class_FMap" via "Draft.MPoly_Type_Class_Ordered" via "Draft.MPoly_Type_Class")
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.103s elapsed time, 0.406s cpu time, 0.050s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.MPoly_Type_Class_FMapTemplates")
instantiation
  mpoly :: (zero) zero
  zero_mpoly == zero_class.zero :: 'a mpoly
instantiation
  mpoly :: (monoid_add) monoid_add
  plus_mpoly == plus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_mpoly == minus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (ab_group_add) ab_group_add
  uminus_mpoly == uminus :: 'a mpoly => 'a mpoly
### theory "Draft.More_Modules"
### 0.188s elapsed time, 0.748s cpu time, 0.050s GC time
MPoly (mapping_of ?x) = ?x
?y : UNIV ==> mapping_of (MPoly ?y) = ?y
(mapping_of ?x = mapping_of ?y) = (?x = ?y)
[| ?x : UNIV; ?y : UNIV |] ==> (MPoly ?x = MPoly ?y) = (?x = ?y)
[| ?y : UNIV; !!x. ?P (mapping_of x) |] ==> ?P ?y
(!!y. y : UNIV ==> ?P (MPoly y)) ==> ?P ?x
[| ?y : UNIV; !!x. ?y = mapping_of x ==> ?P |] ==> ?P
(!!y. [| ?x = MPoly y; y : UNIV |] ==> ?P) ==> ?P
instantiation
  mpoly :: (zero_neq_one) zero_neq_one
  one_mpoly == one_class.one :: 'a mpoly
instantiation
  mpoly :: (semiring_0) semiring_0
  times_mpoly == times :: 'a mpoly => 'a mpoly => 'a mpoly
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### theory "Draft.Utils"
### 0.325s elapsed time, 1.158s cpu time, 0.137s GC time
### Ambiguous input (line 494 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>div" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 498 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>mod" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 502 of "$AFP/Polynomials/MPoly_Type.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 505 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 509 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.MPoly_Type"
### 0.482s elapsed time, 1.476s cpu time, 0.137s GC time
Loading theory "Draft.More_MPoly_Type" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.MPoly_Type_Class_FMap" via "Draft.MPoly_Type_Class_Ordered" via "Draft.MPoly_Type_Class" via "Draft.Power_Products")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.570s elapsed time, 1.641s cpu time, 0.158s GC time
### theory "Draft.More_MPoly_Type"
### 0.257s elapsed time, 0.697s cpu time, 0.119s GC time
Loading theory "Draft.Poly_Mapping_Finite_Map" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.MPoly_Type_Class_FMap")
Loading theory "Draft.Power_Products" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.MPoly_Type_Class_FMap" via "Draft.MPoly_Type_Class_Ordered" via "Draft.MPoly_Type_Class")
"(Gcd (coeffs
        (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
          6 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
          8)),
  sdiv
   (Gcd (coeffs
          (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
            6 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
            8)))
   (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
    M [(1::'b) + (1::'b), 0::'b, (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
     6 +
    M [(1::'b) + (1::'b), 0::'b,
       (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
     8))"
  :: "'a * 'a mpoly"
instantiation
  poly_mapping :: (type, {zero,equal}) equal
  equal_poly_mapping == equal_class.equal ::
    ('a \<Rightarrow>\<^sub>0 'b) => ('a \<Rightarrow>\<^sub>0 'b) => bool
### theory "Draft.Poly_Mapping_Finite_Map"
### 0.368s elapsed time, 0.779s cpu time, 0.066s GC time
class plus = type +
  fixes plus :: "'a => 'a => 'a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class ninv_comm_monoid_add = comm_monoid_add +
  assumes "plus_eq_zero": "!!s t. s + t = (0::'a) ==> s = (0::'a)"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
class lcs_powerprod = comm_powerprod +
  fixes lcs :: "'a => 'a => 'a"
  assumes "adds_lcs": "!!s t. s adds lcs s t"
  assumes "lcs_adds": "!!s u t. [| s adds u; t adds u |] ==> lcs s t adds u"
  assumes "lcs_comm": "!!s t. lcs s t = lcs t s"
class graded_dickson_powerprod = ulcs_powerprod +
  assumes "ex_dgrad": "EX d. dickson_grading d"
class dickson_powerprod = ulcs_powerprod +
  assumes "dickson": "almost_full_on (adds) UNIV"
class semi_canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_imp_add": "!!a b. a <= b ==> EX c. b = a + c"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  ninv_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
class add_linorder_min = add_linorder +
  assumes "zero_min": "!!x. (0::'a) <= x"
instantiation
  nat :: add_linorder
instantiation
  nat :: add_linorder_min
instantiation
  nat :: add_wellorder
instantiation
  int :: add_linorder_group
instantiation
  rat :: add_linorder_group
instantiation
  real :: add_linorder_group
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "od_powerprod (\<preceq>) (\<prec>)"
instantiation
  fun :: (type, add_linorder) lcs_powerprod
  lcs_fun == lcs :: ('a => 'b) => ('a => 'b) => 'a => 'b
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
instantiation
  poly_mapping :: (type, add_linorder) lcs_powerprod
  lcs_poly_mapping == lcs ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Draft.Power_Products"
### 7.992s elapsed time, 9.318s cpu time, 1.500s GC time
Loading theory "Draft.MPoly_Type_Class" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.MPoly_Type_Class_FMap" via "Draft.MPoly_Type_Class_Ordered")
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Ambiguous input (line 1415 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Ambiguous input (line 1454 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1463 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("\<^const>Series.suminf_binder" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("_Sum_any" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### theory "Draft.MPoly_Type_Class"
### 1.562s elapsed time, 1.764s cpu time, 0.249s GC time
Loading theory "Draft.MPoly_Type_Class_Ordered" (required by "Draft.MPoly_Type_Class_FMapTemplates" via "Draft.MPoly_Type_Class_FMap")
class the_min = linorder +
  fixes the_min :: "'a"
  assumes "the_min_min": "!!x. the_min <= x"
instantiation
  nat :: the_min
  the_min_nat == the_min :: nat
instantiation
  unit :: the_min
  the_min_unit == the_min :: unit
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale gd_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "gd_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "od_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
### theory "Draft.MPoly_Type_Class_Ordered"
### 6.366s elapsed time, 8.314s cpu time, 2.736s GC time
Loading theory "Draft.MPoly_Type_Class_FMap" (required by "Draft.MPoly_Type_Class_FMapTemplates")
locale experiment10755304
### Code generator: dropping subsumed code equation
### monomial ?v ?k == sparse\<^sub>0 [(?k, ?v)]
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Abstraction on left hand side of equation, in theorem:
### pprod.shift_map_keys ?t ?f (fmap_of_list ?xs) ==
### fmap_of_list (map (%(k, v). (pprod.splus ?t k, ?f v)) ?xs)
### Partially applied constant "MPoly_Type_Class.to_pair_unit" on left hand side of equation, in theorem:
### punit.shift_map_keys ?t ?f (fmap_of_list ?xs) ==
### fmap_of_list (map (%(k, v). (punit.splus ?t k, ?f v)) ?xs)
### Abstraction on left hand side of equation, in theorem:
### pprod.monom_mult ?c ?t (Pm_fmap ?xs) ==
### Pm_fmap
###  (if ?c = (0::?'b) then fmempty else pprod.shift_map_keys ?t ((*) ?c) ?xs)
### Partially applied constant "MPoly_Type_Class.to_pair_unit" on left hand side of equation, in theorem:
### punit.monom_mult ?c ?t (Pm_fmap ?xs) ==
### Pm_fmap
###  (if ?c = (0::?'b) then fmempty else punit.shift_map_keys ?t ((*) ?c) ?xs)
### Abstraction on left hand side of equation, in theorem:
### pprod.mult_scalar (Pm_fmap (fmap_of_list ?xs)) ?q ==
### case ?xs of [] => Pm_fmap fmempty
### | (t, c) # ys =>
###     pprod.monom_mult c t ?q +
###     pprod.mult_scalar (except (Pm_fmap (fmap_of_list ys)) {t}) ?q
### Partially applied constant "MPoly_Type_Class.to_pair_unit" on left hand side of equation, in theorem:
### punit.mult_scalar (Pm_fmap (fmap_of_list ?xs)) ?q ==
### case ?xs of [] => Pm_fmap fmempty
### | (t, c) # ys =>
###     punit.monom_mult c t ?q +
###     punit.mult_scalar (except (Pm_fmap (fmap_of_list ys)) {t}) ?q
val mpoly_simproc =
   Simproc
    {lhss =
     [Const ("Poly_Mapping_Finite_Map.Pm_fmap",
             "(?'a \<Rightarrow>\<^sub>0 nat, ?'b) fmap
              => (?'a \<Rightarrow>\<^sub>0 nat) \<Rightarrow>\<^sub>0 
                 ?'b") $
        Var (("mpp", 0), "(?'a \<Rightarrow>\<^sub>0 nat, ?'b) fmap")],
     name = "multivariate polynomials", proc = fn, stamp = Stamp 10759896}:
   simproc
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
### Cannot skip proof of schematic goal statement
locale trivariate\<^sub>0_rat
locale trivariate
locale experiment10776492
### Cannot skip proof of schematic goal statement
locale experiment10777564
instantiation
  mpoly :: ({zero,equal}) equal
  equal_mpoly == equal_class.equal :: 'a mpoly => 'a mpoly => bool
locale experiment10778012
### theory "Draft.MPoly_Type_Class_FMap"
### 1.372s elapsed time, 1.497s cpu time, 0.193s GC time
Loading theory "Draft.MPoly_Type_Class_FMapTemplates"
val templateLemmas =
   [("MPoly_Type_Class_FMap.mpoly_simps", "(0::?'a) < numeral ?n",
     template_inequation
      (less_than, template_hole 1,
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(1::?'a) <= numeral ?n",
     template_inequation
      (less_equals, template_hole 1,
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(0::?'a) <= numeral ?n",
     template_inequation
      (less_equals, template_hole 1,
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "EX x. x = ?t",
     template_predicate (template_app (template_hole 1, t_empty))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "EX x. ?t = x",
     template_predicate (template_app (template_hole 1, t_empty))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(0::?'a) ~= numeral ?n",
     template_negation
      (
         template_equation
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "numeral ?n ~= (0::?'a)",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 0), template_hole 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "num.One ~= num.Bit0 ?x2.0",
     template_negation
      (
         template_equation
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "num.One ~= num.Bit1 ?x3.0",
     template_negation
      (
         template_equation
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "num.Bit0 ?x2.0 ~= num.One",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 0), template_hole 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "num.Bit1 ?x3.0 ~= num.One",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 0), template_hole 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "?P ~= (~ ?P)",
     template_negation
      (
         template_equation
          (template_var 0, template_app (template_hole 1, template_var 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(~ ?P) ~= ?P",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 0), template_var 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ numeral ?n < (1::?'a)",
     template_negation
      (
         template_inequation
          (less_than, template_app (template_hole 1, template_var 0),
           template_hole 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ numeral ?n < (0::?'a)",
     template_negation
      (
         template_inequation
          (less_than, template_app (template_hole 1, template_var 0),
           template_hole 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ numeral ?n <= (0::?'a)",
     template_negation
      (
         template_inequation
          (less_equals, template_app (template_hole 1, template_var 0),
           template_hole 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "lookup 0 ?k = (0::?'a)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?a when False) = (0::?'a)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?a when True) = ?a",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "?a ^ 0 = (1::?'a)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(0::?'a) * ?a = (0::?'a)",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "?a * (0::?'a) = (0::?'a)",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(0::?'a) + ?a = ?a",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "?a + (0::?'a) = ?a",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(1::?'a) * ?a = ?a",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "?a * (1::?'a) = ?a",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "?a ^ 1 = ?a",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "sum ?g {} = (0::?'a)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "{} - ?A = {}",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "{} Int ?B = {}",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "{} Un ?B = ?B",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(ALL x. ?P) = ?P",
     template_equation
      (template_app (template_hole 0, t_empty), template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(EX x. ?P) = ?P",
     template_equation
      (template_app (template_hole 0, t_empty), template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(~ ~ ?P) = ?P",
     template_equation
      (template_app
        (template_hole 0, template_app (template_hole 0, template_var 0)),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(False & ?P) = False",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(True & ?P) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P & False) = False",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P & True) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P & ?P) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 0, template_var 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(False | ?P) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(True | ?P) = True",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P | False) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P | True) = True",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P | ?P) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 0, template_var 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?x = ?x) = True",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(True = ?P) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P = True) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(False --> ?P) = True",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(True --> ?P) = ?P",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P --> True) = True",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P --> ?P) = True",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?m < num.One) = False",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(num.One <= ?n) = True",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?c : {}) = False",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "map ?f [] = []",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- (1::?'a) < numeral ?m",
     template_inequation
      (less_than, template_app (template_hole 2, template_hole 1),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?m < (1::?'a)",
     template_inequation
      (less_than,
       template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?n < (0::?'a)",
     template_inequation
      (less_than,
       template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- (1::?'a) <= numeral ?m",
     template_inequation
      (less_equals, template_app (template_hole 2, template_hole 1),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?m <= (1::?'a)",
     template_inequation
      (less_equals,
       template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?n <= (0::?'a)",
     template_inequation
      (less_equals,
       template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(1::?'a) ~= - numeral ?n",
     template_negation
      (
         template_equation
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(0::?'a) ~= - numeral ?n",
     template_negation
      (
         template_equation
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- (1::?'a) ~= numeral ?n",
     template_negation
      (
         template_equation
          (template_app (template_hole 2, template_hole 1),
           template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "numeral ?n ~= - (1::?'a)",
     template_negation
      (
         template_equation
          (template_app (template_hole 2, template_var 0),
           template_app (template_hole 1, template_hole 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?n ~= (1::?'a)",
     template_negation
      (
         template_equation
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 0)),
           template_hole 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?n ~= (0::?'a)",
     template_negation
      (
         template_equation
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 0)),
           template_hole 0)
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "num.Bit0 ?x2.0 ~= num.Bit1 ?x3.0",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 1),
           template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "num.Bit1 ?x3.0 ~= num.Bit0 ?x2.0",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 1),
           template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ (1::?'a) < - numeral ?m",
     template_negation
      (
         template_inequation
          (less_than, template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ (0::?'a) < - numeral ?n",
     template_negation
      (
         template_inequation
          (less_than, template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ numeral ?m < - (1::?'a)",
     template_negation
      (
         template_inequation
          (less_than, template_app (template_hole 2, template_var 0),
           template_app (template_hole 1, template_hole 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ (1::?'a) <= - numeral ?m",
     template_negation
      (
         template_inequation
          (less_equals, template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ (0::?'a) <= - numeral ?n",
     template_negation
      (
         template_inequation
          (less_equals, template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ numeral ?m <= - (1::?'a)",
     template_negation
      (
         template_inequation
          (less_equals, template_app (template_hole 2, template_var 0),
           template_app (template_hole 1, template_hole 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(if False then ?x else ?y) = ?y",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_hole 0), template_var 1),
         template_var 0),
       template_var 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(if True then ?x else ?y) = ?x",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_hole 0), template_var 1),
         template_var 0),
       template_var 1)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "fst (?x1.0, ?x2.0) = ?x1.0",
     template_equation
      (template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_var 1)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(False = ?P) = (~ ?P)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), template_var 0),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P = False) = (~ ?P)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P --> False) = (~ ?P)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P & ~ ?P) = False",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0),
         template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(~ ?P & ?P) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P | ~ ?P) = True",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0),
         template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(~ ?P | ?P) = True",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_var 0),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(num.One = num.Bit0 ?n) = False",
     template_equation
      (template_app
        (template_app (template_hole 3, template_hole 2),
         template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(num.One = num.Bit1 ?n) = False",
     template_equation
      (template_app
        (template_app (template_hole 3, template_hole 2),
         template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(num.Bit0 ?m = num.One) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 0)),
         template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(num.Bit1 ?m = num.One) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 0)),
         template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(num.One < num.Bit0 ?n) = True",
     template_equation
      (template_app
        (template_app (template_hole 3, template_hole 2),
         template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(num.One < num.Bit1 ?n) = True",
     template_equation
      (template_app
        (template_app (template_hole 3, template_hole 2),
         template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit0 ?m <= num.One) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 0)),
         template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit1 ?m <= num.One) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 0)),
         template_hole 1),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.Ball_True", "(ALL x:?X. True) = True",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), t_empty),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.MPoly_numeral",
     "MPoly (numeral ?x) = numeral ?x",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "Const\<^sub>0 (numeral ?x) = numeral ?x",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?m < numeral ?n",
     template_inequation
      (less_than,
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 1)),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?m <= - (1::?'a)",
     template_inequation
      (less_equals,
       template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 2, template_hole 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?m <= numeral ?n",
     template_inequation
      (less_equals,
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 1)),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "numeral ?m ~= - numeral ?n",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 1),
           template_app
            (template_hole 0,
             template_app (template_hole 1, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "- numeral ?m ~= numeral ?n",
     template_negation
      (
         template_equation
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 1)),
           template_app (template_hole 0, template_var 0))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ - (1::?'a) < - numeral ?m",
     template_negation
      (
         template_inequation
          (less_than, template_app (template_hole 2, template_hole 1),
           template_app
            (template_hole 2,
             template_app (template_hole 0, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ numeral ?m < - numeral ?n",
     template_negation
      (
         template_inequation
          (less_than, template_app (template_hole 1, template_var 1),
           template_app
            (template_hole 0,
             template_app (template_hole 1, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps", "~ numeral ?m <= - numeral ?n",
     template_negation
      (
         template_inequation
          (less_equals, template_app (template_hole 1, template_var 1),
           template_app
            (template_hole 0,
             template_app (template_hole 1, template_var 0)))
         )),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(case num.One of num.One => ?f1.0 | num.Bit0 x => ?f2.0 x
       | num.Bit1 x => ?f3.0 x) =
      ?f1.0",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 0),
         template_hole 0),
       template_var 2)),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "rec_num ?f1.0 ?f2.0 ?f3.0 num.One = ?f1.0",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 0),
         template_hole 0),
       template_var 2)),
    ("MPoly_Type_Class_FMap.lookup0_fmap_of_list_simps",
     "lookup0 (fmap_of_list []) ?i = (0::?'c)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_hole 2),
           template_app (template_hole 1, template_hole 0)),
         template_var 0),
       template_hole 2)),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "finite (insert ?a ?A) = finite ?A",
     template_equation
      (template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app (template_hole 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P --> ~ ?P) = (~ ?P)",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0),
         template_app (template_hole 0, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit0 ?m = num.Bit1 ?n) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit1 ?m = num.Bit0 ?n) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(ALL x:{}. ?P x) = True",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), t_empty),
       template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "Const\<^sub>0 (- ?x) = - Const\<^sub>0 ?x",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 0, template_app (template_hole 2, template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "fmdom' (fmap_of_list ?xs) = set (map fst ?xs)",
     template_equation
      (template_app
        (template_hole 4, template_app (template_hole 3, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_hole 0),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "((1::?'a) = numeral ?n) = (num.One = ?n)",
     template_bimplication
      (template_equation
        (template_hole 3, template_app (template_hole 2, template_var 0)),
       template_equation (template_hole 0, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(numeral ?n = (1::?'a)) = (?n = num.One)",
     template_bimplication
      (template_equation
        (template_app (template_hole 3, template_var 0), template_hole 2),
       template_equation (template_var 0, template_hole 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "((1::?'a) < numeral ?n) = (num.One < ?n)",
     template_equation
      (template_app
        (template_app (template_hole 4, template_hole 3),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_app (template_hole 1, template_hole 0), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(numeral ?n <= (1::?'a)) = (?n <= num.One)",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, template_var 0)),
         template_hole 2),
       template_app
        (template_app (template_hole 1, template_var 0), template_hole 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(ALL x. x ~= ?t) = False",
     template_equation
      (template_app (template_hole 3, t_empty), template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(ALL x. ?t ~= x) = False",
     template_equation
      (template_app (template_hole 3, t_empty), template_hole 0)),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(case num.Bit0 ?x2.0 of num.One => ?f1.0 | num.Bit0 x => ?f2.0 x
       | num.Bit1 x => ?f3.0 x) =
      ?f2.0 ?x2.0",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 3),
             template_var 2),
           template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_app (template_var 2, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(case num.Bit1 ?x3.0 of num.One => ?f1.0 | num.Bit0 x => ?f2.0 x
       | num.Bit1 x => ?f3.0 x) =
      ?f3.0 ?x3.0",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 3),
             template_var 2),
           template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_app (template_var 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "lookup 1 ?k = ((1::?'a) when ?k = (0::?'b))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_hole 4),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 3, template_hole 2),
             template_app
              (template_app (template_hole 1, template_var 0),
               template_hole 0))
           ))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "set (?x21.0 # ?x22.0) = insert ?x21.0 (set ?x22.0)",
     template_equation
      (template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 2, template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P ~= ?Q) = (?P = (~ ?Q))",
     template_bimplication
      (template_negation
        (template_equation (template_var 1, template_var 0)),
       template_equation
        (template_var 1, template_app (template_hole 0, template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P & ?P & ?Q) = (?P & ?Q)",
     template_equation
      (template_app
        (template_app (template_hole 0, template_var 1),
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(?P | ?P | ?Q) = (?P | ?Q)",
     template_equation
      (template_app
        (template_app (template_hole 0, template_var 1),
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(numeral ?m = numeral ?n) = (?m = ?n)",
     template_bimplication
      (template_equation
        (template_app (template_hole 1, template_var 1),
         template_app (template_hole 1, template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit0 ?m = num.Bit0 ?n) = (?m = ?n)",
     template_bimplication
      (template_equation
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit0 ?x2.0 = num.Bit0 ?y2.0) = (?x2.0 = ?y2.0)",
     template_bimplication
      (template_equation
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit1 ?m = num.Bit1 ?n) = (?m = ?n)",
     template_bimplication
      (template_equation
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit1 ?x3.0 = num.Bit1 ?y3.0) = (?x3.0 = ?y3.0)",
     template_bimplication
      (template_equation
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "((~ ?P) = (~ ?Q)) = (?P = ?Q)",
     template_bimplication
      (template_equation
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(numeral ?m < numeral ?n) = (?m < ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit0 ?m < num.Bit0 ?n) = (?m < ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 1, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit0 ?m < num.Bit1 ?n) = (?m <= ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit1 ?m < num.Bit0 ?n) = (?m < ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 2, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit1 ?m < num.Bit1 ?n) = (?m < ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 1, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(numeral ?m <= numeral ?n) = (?m <= ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit0 ?m <= num.Bit0 ?n) = (?m <= ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 1, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit0 ?m <= num.Bit1 ?n) = (?m <= ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 2, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit1 ?m <= num.Bit0 ?n) = (?m < ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(num.Bit1 ?m <= num.Bit1 ?n) = (?m <= ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 1, template_var 1), template_var 0))),
    ("MPoly_Type_Class_FMap.MPoly_power", "MPoly (?x ^ ?n) = MPoly ?x ^ ?n",
     template_equation
      (template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0, template_app (template_hole 2, template_var 1)),
         template_var 0))),
    ("MPoly_Type_Class_FMap.monomial_mp",
     "monomial ?c ?pp = Const\<^sub>0 ?c * monomial1 ?pp",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1), template_var 0),
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_app (template_hole 0, template_var 1)))),
    ("MPoly_Type_Class_FMap.monomial1_monomial",
     "monomial1 (monomial ?n ?v) = Var\<^sub>0 ?v ^ ?n",
     template_equation
      (template_app
        (template_hole 3,
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x:UNIV. ?P x) = (ALL x. ?P x)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), t_empty),
       template_app (template_hole 0, t_empty))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(- (1::?'a) = - numeral ?n) = (?n = num.One)",
     template_bimplication
      (template_equation
        (template_app (template_hole 4, template_hole 3),
         template_app
          (template_hole 4,
           template_app (template_hole 2, template_var 0))),
       template_equation (template_var 0, template_hole 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(- numeral ?n = - (1::?'a)) = (?n = num.One)",
     template_bimplication
      (template_equation
        (template_app
          (template_hole 4, template_app (template_hole 3, template_var 0)),
         template_app (template_hole 4, template_hole 2)),
       template_equation (template_var 0, template_hole 0))),
    ("MPoly_Type_Class_FMap.monomial1_add",
     "monomial1 (?a + ?b) = monomial1 ?a * monomial1 ?b",
     template_equation
      (template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 2, template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "lookup (monomial ?v ?k) ?k' = (?v when ?k = ?k')",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 3,
                template_app
                 (template_app (template_hole 2, template_var 2),
                  template_var 1)),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 1, template_var 1),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0))
           ))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "?a + (?b + ?c) = ?a + ?b + ?c",
     template_equation
      (template_app
        (template_app (template_hole 0, template_var 2),
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "?a * (?b * ?c) = ?a * ?b * ?c",
     template_equation
      (template_app
        (template_app (template_hole 0, template_var 2),
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0))),
    ("MPoly_Type_Class_FMap.compute_deg_pp",
     "deg_pm (Pm_fmap ?xs) = sum (the o fmlookup ?xs) (fmdom' ?xs)",
     template_equation
      (template_app
        (template_hole 6, template_app (template_hole 5, template_var 0)),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_hole 2),
             template_app (template_hole 1, template_var 0))),
         template_app (template_hole 0, template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "insert ?a ?B Un ?C = insert ?a (?B Un ?C)",
     template_equation
      (template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 0, template_var 2),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(- numeral ?m < - (1::?'a)) = (?m ~= num.One)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 6,
                template_app
                 (template_hole 5,
                  template_app (template_hole 4, template_var 0))),
              template_app (template_hole 5, template_hole 3))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(- numeral ?m = - numeral ?n) = (?m = ?n)",
     template_bimplication
      (template_equation
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_app
          (template_hole 2,
           template_app (template_hole 1, template_var 0))),
       template_equation (template_var 1, template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(- numeral ?m < - numeral ?n) = (?n < ?m)",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 1))),
         template_app
          (template_hole 2,
           template_app (template_hole 1, template_var 0))),
       template_app
        (template_app (template_hole 0, template_var 0), template_var 1))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(- numeral ?m <= - numeral ?n) = (?n <= ?m)",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 1))),
         template_app
          (template_hole 2,
           template_app (template_hole 1, template_var 0))),
       template_app
        (template_app (template_hole 0, template_var 0), template_var 1))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x. x = ?t --> ?P x) = ?P ?t",
     template_equation
      (template_app (template_hole 2, t_empty),
       template_app (template_var 0, template_var 1))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x. ?t = x --> ?P x) = ?P ?t",
     template_equation
      (template_app (template_hole 2, t_empty),
       template_app (template_var 0, template_var 1))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(EX x. x = ?t & ?P x) = ?P ?t",
     template_equation
      (template_app (template_hole 2, t_empty),
       template_app (template_var 0, template_var 1))),
    ("MPoly_Type_Class_FMap.mpoly_simps", "(EX x. ?t = x & ?P x) = ?P ?t",
     template_equation
      (template_app (template_hole 2, t_empty),
       template_app (template_var 0, template_var 1))),
    ("MPoly_Type_Class_FMap.compute_splus_pprod",
     "splus_pprod ?t (?s, ?i) = (?t + ?s, ?i)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 2),
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(~ - (1::?'a) <= - numeral ?m) = (?m ~= num.One)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 6,
              template_app
               (template_app
                 (template_hole 5,
                  template_app (template_hole 4, template_hole 3)),
                template_app
                 (template_hole 4,
                  template_app (template_hole 2, template_var 0))))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "map ?f (?x21.0 # ?x22.0) = ?f ?x21.0 # map ?f ?x22.0",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 2),
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0, template_app (template_var 2, template_var 1)),
         template_app
          (template_app (template_hole 2, template_var 2),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "lookup (?f + ?g) ?k = lookup ?f ?k + lookup ?g ?k",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "keys (monomial ?v ?k) = (if ?v = (0::?'b) then {} else {?k})",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 6,
              template_app
               (template_app (template_hole 5, template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 3, template_var 0),
                   template_hole 2)),
               template_hole 1),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_hole 1))
           ))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(?a : insert ?b ?A) = (?a = ?b | ?a : ?A)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 2),
              template_app
               (template_app (template_hole 2, template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)),
             template_app
              (template_app (template_hole 3, template_var 2),
               template_var 0))
           ))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(~ (ALL x:?A. ?P x)) = (EX x:?A. ~ ?P x)",
     template_equation
      (template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 1), t_empty)),
       template_app
        (template_app (template_hole 0, template_var 1), t_empty))),
    ("MPoly_Type_Class_FMap.compute_except_poly_mapping",
     "except (Pm_fmap ?xs) ?S = Pm_fmap (fmfilter (%k. k ~: ?S) ?xs)",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, template_var 1)),
         template_var 0),
       template_app
        (template_hole 3,
         template_app
          (template_app (template_hole 2, t_empty), template_var 1)))),
    ("MPoly_Type_Class_FMap.Pm_fmap_sum",
     "Pm_fmap ?f = (SUM x:fmdom' ?f. monomial (lookup0 ?f x) x)",
     template_equation
      (template_app (template_hole 5, template_var 0),
       template_app
        (template_app (template_hole 4, t_empty),
         template_app (template_hole 0, template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "rec_num ?f1.0 ?f2.0 ?f3.0 (num.Bit0 ?x2.0) =
      ?f2.0 ?x2.0 (rec_num ?f1.0 ?f2.0 ?f3.0 ?x2.0)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 3),
             template_var 2),
           template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_var 2, template_var 0),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "rec_num ?f1.0 ?f2.0 ?f3.0 (num.Bit1 ?x3.0) =
      ?f3.0 ?x3.0 (rec_num ?f1.0 ?f2.0 ?f3.0 ?x3.0)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 3),
             template_var 2),
           template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_var 1, template_var 0),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x:Collect ?Q. ?P x) = (ALL x. ?Q x --> ?P x)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         t_empty),
       template_app (template_hole 1, t_empty))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x:?f ` ?A. ?P x) = (ALL x:?A. ?P (?f x))",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         t_empty),
       template_app
        (template_app (template_hole 0, template_var 1), t_empty))),
    ("MPoly_Type_Class_FMap.compute_adds_term_pprod",
     "adds_term_pprod ?u ?v =
      (snd ?u = snd ?v & adds_pp_add_linorder (fst ?u) (fst ?v))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 2, template_var 1)),
                 template_app (template_hole 2, template_var 0))),
             template_app
              (template_app
                (template_hole 1,
                 template_app (template_hole 0, template_var 1)),
               template_app (template_hole 0, template_var 0)))
           ))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x:?A. ?P x | ?Q) = ((ALL x:?A. ?P x) | ?Q)",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 2), t_empty),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 1, template_var 2), t_empty)),
         template_var 0))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x:?A. ?P | ?Q x) = (?P | (ALL x:?A. ?Q x))",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 2), t_empty),
       template_app
        (template_app (template_hole 0, template_var 1),
         template_app
          (template_app (template_hole 1, template_var 2), t_empty)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x:?A. ?P --> ?Q x) = (?P --> (ALL x:?A. ?Q x))",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 2), t_empty),
       template_app
        (template_app (template_hole 0, template_var 1),
         template_app
          (template_app (template_hole 1, template_var 2), t_empty)))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x:?A. ?P x --> ?Q) = ((EX x:?A. ?P x) --> ?Q)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 2), t_empty),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2), t_empty)),
         template_var 0))),
    ("MPoly_Type_Class_FMap.compute_monomial",
     "monomial ?c ?t =
      (if ?c = (0::?'b) then 0 else sparse\<^sub>0 [(?t, ?c)])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_app (template_hole 6, template_var 0),
                   template_hole 5)),
               template_hole 4),
             template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_var 1),
                     template_var 0)),
                 template_hole 0)))
           ))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "(ALL x:insert ?a ?B. ?P x) = (?P ?a & (ALL x:?B. ?P x))",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         t_empty),
       template_app
        (template_app
          (template_hole 0, template_app (template_var 0, template_var 2)),
         template_app
          (template_app (template_hole 2, template_var 1), t_empty)))),
    ("MPoly_Type_Class_FMap.compute_monom_mult_punit",
     "monom_mult_punit ?c ?t (Pm_fmap ?xs) =
      Pm_fmap
       (if ?c = (0::?'b) then fmempty
        else shift_map_keys_punit ?t ((*) ?c) ?xs)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 2),
                template_var 1),
              template_app (template_hole 6, template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_hole 6,
             template_app
              (template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 4, template_var 2),
                     template_hole 3)),
                 template_hole 2),
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 1),
                   template_app (template_hole 0, template_var 2)),
                 template_var 0)))
           ))),
    ("MPoly_Type_Class_FMap.compute_monom_mult_pprod",
     "monom_mult_pprod ?c ?t (Pm_fmap ?xs) =
      Pm_fmap
       (if ?c = (0::?'c) then fmempty
        else shift_map_keys_pprod ?t ((*) ?c) ?xs)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 2),
                template_var 1),
              template_app (template_hole 6, template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_hole 6,
             template_app
              (template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 4, template_var 2),
                     template_hole 3)),
                 template_hole 2),
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 1),
                   template_app (template_hole 0, template_var 2)),
                 template_var 0)))
           ))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "insert ?x ?A - ?B =
      (if ?x : ?B then ?A - ?B else insert ?x (?A - ?B))",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0)),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "insert ?a ?B Int ?C =
      (if ?a : ?C then insert ?a (?B Int ?C) else ?B Int ?C)",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0)),
           template_app
            (template_app (template_hole 2, template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.compute_shift_map_keys_punit",
     "shift_map_keys_punit ?t ?f (fmap_of_list ?xs) =
      fmap_of_list (map (%(k, v). (?t + k, ?f v)) ?xs)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 6, template_var 2), template_var 1),
         template_app (template_hole 5, template_var 0)),
       template_app
        (template_hole 4,
         template_app
          (template_app
            (template_hole 3, template_app (template_hole 2, t_empty)),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.compute_shift_map_keys_pprod",
     "shift_map_keys_pprod ?t ?f (fmap_of_list ?xs) =
      fmap_of_list (map (%(k, v). (splus_pprod ?t k, ?f v)) ?xs)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 6, template_var 2), template_var 1),
         template_app (template_hole 5, template_var 0)),
       template_app
        (template_hole 4,
         template_app
          (template_app
            (template_hole 3, template_app (template_hole 2, t_empty)),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.lookup0_fmap_of_list_simps",
     "lookup0 (fmap_of_list ((?x, ?y) # ?xs)) ?i =
      (if ?x = ?i then ?y else lookup0 (fmap_of_list ?xs) ?i)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_hole 5),
                template_app
                 (template_hole 4,
                  template_app
                   (template_app
                     (template_hole 3,
                      template_app
                       (template_app (template_hole 2, template_var 3),
                        template_var 2)),
                    template_var 1))),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 0)),
               template_var 2),
             template_app
              (template_app
                (template_app (template_hole 6, template_hole 5),
                 template_app (template_hole 4, template_var 1)),
               template_var 0))
           ))),
    ("MPoly_Type_Class_FMap.mpoly_simps",
     "finite ?A ==> sum ?g (insert ?x ?A) = ?g ?x + sum ?g (?A - {?x})",
     template_implication
      ([template_predicate
         (template_app (template_hole 6, template_var 2))],
       template_equation
        (template_app
          (template_app (template_hole 4, template_var 1),
           template_app
            (template_app (template_hole 3, template_var 0),
             template_var 2)),
         template_app
          (template_app
            (template_hole 2,
             template_app (template_var 1, template_var 0)),
           template_app
            (template_app (template_hole 4, template_var 1),
             template_app
              (template_app (template_hole 1, template_var 2),
               template_app
                (template_app (template_hole 3, template_var 0),
                 template_hole 0))))))),
    ("MPoly_Type_Class_FMap.compute_adds_pp",
     "adds_pp_add_linorder (Pm_fmap ?xs) (Pm_fmap ?ys) =
      fmpred (%k v. lookup0 ?xs k <= lookup0 ?ys k) (?xs ++\<^sub>f ?ys)",
     template_equation
      (template_app
        (template_app
          (template_hole 6, template_app (template_hole 5, template_var 1)),
         template_app (template_hole 5, template_var 0)),
       template_app
        (template_app (template_hole 4, t_empty),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("MPoly_Type_Class_FMap.compute_lcs_pp",
     "lcs (Pm_fmap ?xs) (Pm_fmap ?ys) =
      Pm_fmap
       (fmmap_keys (%k v. max (lookup0 ?xs k) (lookup0 ?ys k))
         (?xs ++\<^sub>f ?ys))",
     template_equation
      (template_app
        (template_app
          (template_hole 6, template_app (template_hole 5, template_var 1)),
         template_app (template_hole 5, template_var 0)),
       template_app
        (template_hole 5,
         template_app
          (template_app (template_hole 4, t_empty),
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0))))),
    ("MPoly_Type_Class_FMap.if_poly_mapping_eq_iff",
     "(if ?x = ?y then ?a else ?b) =
      (if ALL i:keys ?x Un keys ?y. lookup ?x i = lookup ?y i then ?a
       else ?b)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_var 3)),
                   template_app (template_hole 2, template_var 2))),
               t_empty)),
           template_var 1),
         template_var 0))),
    ("MPoly_Type_Class_FMap.lex_pm_iff",
     "lex_pm ?s ?t =
      (ALL x.
          lookup ?s x <= lookup ?t x |
          (EX y<x. lookup ?s y ~= lookup ?t y))",
     template_equation
      (template_app
        (template_app (template_hole 9, template_var 1), template_var 0),
       template_app (template_hole 8, t_empty))),
    ("MPoly_Type_Class_FMap.keys_add_eq",
     "keys (?a + ?b) =
      keys ?a Un keys ?b -
      {x: keys ?a Int keys ?b. lookup ?a x + lookup ?b x = (0::?'b)}",
     template_equation
      (template_app
        (template_hole 11,
         template_app
          (template_app (template_hole 10, template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_hole 9,
           template_app
            (template_app
              (template_hole 8,
               template_app (template_hole 11, template_var 1)),
             template_app (template_hole 11, template_var 0))),
         template_app (template_hole 7, t_empty)))),
    ("MPoly_Type_Class_FMap.compute_dord_pp",
     "dord_pm ?ord (Pm_fmap ?xs) (Pm_fmap ?ys) =
      (let dx = deg_pm (Pm_fmap ?xs); dy = deg_pm (Pm_fmap ?ys)
       in dx < dy | dx = dy & ?ord (Pm_fmap ?xs) (Pm_fmap ?ys))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 7, template_var 2),
           template_app (template_hole 6, template_var 1)),
         template_app (template_hole 6, template_var 0)),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_hole 4,
             template_app (template_hole 6, template_var 1))),
         t_empty))),
    ("MPoly_Type_Class_FMap.compute_mult_scalar_punit",
     "Pm_fmap (fmap_of_list ?xs) * ?q =
      (case ?xs of [] => Pm_fmap fmempty
       | (t, c) # ys =>
           monom_mult_punit c t ?q +
           except (Pm_fmap (fmap_of_list ys)) {t} * ?q)",
     template_equation
      (template_app
        (template_app
          (template_hole 10,
           template_app
            (template_hole 9,
             template_app (template_hole 8, template_var 1))),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 7,
             template_app (template_hole 9, template_hole 6)),
           t_empty),
         template_var 1))),
    ("MPoly_Type_Class_FMap.compute_mult_scalar_pprod",
     "mult_scalar_pprod (Pm_fmap (fmap_of_list ?xs)) ?q =
      (case ?xs of [] => Pm_fmap fmempty
       | (t, c) # ys =>
           monom_mult_pprod c t ?q +
           mult_scalar_pprod (except (Pm_fmap (fmap_of_list ys)) {t}) ?q)",
     template_equation
      (template_app
        (template_app
          (template_hole 11,
           template_app
            (template_hole 10,
             template_app (template_hole 9, template_var 1))),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 8,
             template_app (template_hole 7, template_hole 6)),
           t_empty),
         template_var 1))),
    ("MPoly_Type_Class_FMap.foldl_assoc",
     "(!!x y z. ?f (?f x y) z = ?f x (?f y z)) ==>
      foldl ?f (?f ?a ?b) ?xs = ?f ?a (foldl ?f ?b ?xs)",
     template_implication
      ([template_predicate (template_app (template_hole 3, t_empty))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_app
              (template_app (template_var 3, template_var 2),
               template_var 1)),
           template_var 0),
         template_app
          (template_app (template_var 3, template_var 2),
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 1),
             template_var 0))))),
    ("MPoly_Type_Class_FMap.compute_lex_pp",
     "lex_pm (Pm_fmap ?xs) (Pm_fmap ?ys) =
      (let zs = ?xs ++\<^sub>f ?ys
       in fmpred
           (%x v. lookup0 ?xs x <= lookup0 ?ys x |
                  ~ fmpred (%y w. x <= y | lookup0 ?xs y = lookup0 ?ys y)
                     zs)
           zs)",
     template_equation
      (template_app
        (template_app
          (template_hole 11,
           template_app (template_hole 10, template_var 1)),
         template_app (template_hole 10, template_var 0)),
       template_app
        (template_app
          (template_hole 9,
           template_app
            (template_app (template_hole 8, template_var 1),
             template_var 0)),
         t_empty)))]:
   (string * thm * template) list
### theory "Draft.MPoly_Type_Class_FMapTemplates"
### 0.545s elapsed time, 0.780s cpu time, 0.091s GC time
val it = (): unit
