   [("JVMCFG.wf_jvmprog_is_wf", "wf_jvm_prog (PROG ?P)",
     template_predicate
      (
         template_app
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))
         )),
    ("JVMCFG.ex_new_class_name", "EX C. ~ is_class ?P C",
     template_predicate (template_app (template_hole 2, t_empty))),
    ("JVMCFG.wf_jvmprog_is_wf_typ",
     "wf_jvm_prog\<^bsub>TYPING ?P\<^esub> (PROG ?P)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 0))),
           template_app
            (template_hole 0,
             template_app (template_hole 1, template_var 0)))
         )),
    ("JVMCFG.ClassMain_is_no_class",
     "is_class (PROG ?P) (ClassMain ?P) ==> False",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app
                 (template_hole 3,
                  template_app (template_hole 2, template_var 0))),
              template_app (template_hole 1, template_var 0))
            )],
       template_predicate (template_hole 0))),
    ("JVMCFG.sourcenode_reachable",
     " ?P \<turnstile> ?n -?ek\<rightarrow> ?n' ==>
       ?P \<turnstile> \<Rightarrow>?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 3), template_var 2)
           ))),
    ("JVMCFG.targetnode_reachable",
     " ?P \<turnstile> ?n -?ek\<rightarrow> ?n' ==>
       ?P \<turnstile> \<Rightarrow>?n'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 3), template_var 0)
           ))),
    ("JVMCFG.ClassMain_unique_in_P",
     "is_class (PROG ?P) ?C ==> ClassMain ?P ~= ?C",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 5,
                template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 1))),
              template_var 0)
            )],
       template_negation
        (
           template_equation
            (template_app (template_hole 0, template_var 1), template_var 0)
           ))),
    ("JVMCFG.no_Call_in_ClassMain",
     "PROG
       ?P \<turnstile> ?C sees ?M: ?Ts\<rightarrow>?T = ?mb in ClassMain
                          ?P ==>
      False",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_hole 4,
                          template_app
                           (template_hole 3,
                            template_app
                             (template_hole 2, template_var 5))),
                        template_var 4),
                      template_var 3),
                    template_var 2),
                  template_var 1),
                template_var 0),
              template_app (template_hole 1, template_var 5))
            )],
       template_predicate (template_hole 0))),
    ("JVMCFG.MethodMain_not_seen",
     "PROG
       ?P \<turnstile> ?C sees MethodMain
                                ?P: ?Ts\<rightarrow>?T = ?mb in ?D ==>
      False",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_hole 4,
                          template_app
                           (template_hole 3,
                            template_app
                             (template_hole 2, template_var 5))),
                        template_var 4),
                      template_app (template_hole 1, template_var 5)),
                    template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate (template_hole 0))),
    ("JVMCFG.no_Call_from_ClassMain",
     "PROG
       ?P \<turnstile> ClassMain
                        ?P sees ?M: ?Ts\<rightarrow>?T = ?mb in ?C ==>
      False",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_hole 4,
                          template_app
                           (template_hole 3,
                            template_app
                             (template_hole 2, template_var 5))),
                        template_app (template_hole 1, template_var 5)),
                      template_var 4),
                    template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate (template_hole 0))),
    ("JVMCFG.MethodMain_unique_in_P",
     "PROG ?P \<turnstile> ?D sees ?M: ?Ts\<rightarrow>?T = ?mb in ?C ==>
      MethodMain ?P ~= ?M",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app
                         (template_hole 5,
                          template_app
                           (template_hole 4,
                            template_app
                             (template_hole 3, template_var 6))),
                        template_var 5),
                      template_var 4),
                    template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_negation
        (
           template_equation
            (template_app (template_hole 0, template_var 6), template_var 4)
           ))),
    ("JVMCFG.JVMCFG_edge_det",
     "[|  ?P \<turnstile> ?n -?et\<rightarrow> ?n';
          ?P \<turnstile> ?n -?et'\<rightarrow> ?n' |]
      ==> ?et = ?et'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 1, template_var 4),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 1, template_var 4),
                  template_var 3),
                template_var 0),
              template_var 1)
            )],
       template_equation (template_var 2, template_var 0))),
    ("JVMCFG.ClassMain_imp_MethodMain",
     " (?P, ?C0.0,
        ?Main) \<turnstile> \<Rightarrow>(ClassMain ?P, ?M, ?pc, ?nt) ==>
      ?M = MethodMain ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app (template_hole 7, template_var 5),
                  template_app
                   (template_app (template_hole 6, template_var 4),
                    template_var 3))),
              template_app
               (template_app
                 (template_hole 5,
                  template_app (template_hole 4, template_var 5)),
                template_app
                 (template_app (template_hole 3, template_var 2),
                  template_app
                   (template_app (template_hole 2, template_var 1),
                    template_var 0))))
            )],
       template_equation
        (template_var 2, template_app (template_hole 0, template_var 5)))),
    ("JVMCFG.map_of_fstD",
     "[| map_of ?xs ?a = \<lfloor>?b\<rfloor>; ALL x:set ?xs. fst x ~= ?a |]
      ==> False",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 7, template_var 2), template_var 1),
          template_app (template_hole 6, template_var 0)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 5,
                template_app (template_hole 4, template_var 2)),
              t_empty)
            )],
       template_predicate (template_hole 0))),
    ("JVMCFG.map_of_fstE",
     "[| map_of ?xs ?a = \<lfloor>?b\<rfloor>;
         EX x:set ?xs. fst x = ?a ==> ?thesis |]
      ==> ?thesis",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 5, template_var 3), template_var 2),
          template_app (template_hole 4, template_var 1)),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 2, template_var 3)),
                 t_empty)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("JVMCFG.ClassMain_imp_MethodMain",
     " (?P, ?C0.0,
        ?Main) \<turnstile> (?C', ?M', ?pc',
                             ?nt') -?ek\<rightarrow> (ClassMain ?P, ?M, ?pc,
                ?nt) ==>
      ?M = MethodMain ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_hole 8,
                    template_app
                     (template_app (template_hole 7, template_var 10),
                      template_app
                       (template_app (template_hole 6, template_var 9),
                        template_var 8))),
                  template_app
                   (template_app (template_hole 5, template_var 7),
                    template_app
                     (template_app (template_hole 4, template_var 6),
                      template_app
                       (template_app (template_hole 3, template_var 5),
                        template_var 4)))),
                template_var 3),
              template_app
               (template_app
                 (template_hole 5,
                  template_app (template_hole 2, template_var 10)),
                template_app
                 (template_app (template_hole 4, template_var 2),
                  template_app
                   (template_app (template_hole 3, template_var 1),
                    template_var 0))))
            )],
       template_equation
        (template_var 2, template_app (template_hole 0, template_var 10)))),
    ("JVMCFG.ex_unique_method_name",
     "EX Name.
         ALL C D fs ms.
            class (PROG ?P) C = \<lfloor>(D, fs, ms)\<rfloor> -->
            (ALL m:set ms. Name ~= fst m)",
     template_predicate (template_app (template_hole 16, t_empty))),
    ("JVMCFG.ClassMain_no_Call_target",
     " (?P, ?C0.0,
        ?Main) \<turnstile> (?C, ?M, ?pc,
                             ?nt) -?Q:(?C', ?M',
 ?pc')\<hookrightarrow>\<^bsub>(?D,
                                ?M'')\<^esub>?paramDefs\<rightarrow> (ClassMain
                                 ?P,
                                ?M''', ?pc'', ?nt') ==>
      False",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_hole 10,
                    template_app
                     (template_app (template_hole 9, template_var 16),
                      template_app
                       (template_app (template_hole 8, template_var 15),
                        template_var 14))),
                  template_app
                   (template_app (template_hole 7, template_var 13),
                    template_app
                     (template_app (template_hole 6, template_var 12),
                      template_app
                       (template_app (template_hole 5, template_var 11),
                        template_var 10)))),
                template_app
                 (template_app
                   (template_app
                     (template_app (template_hole 4, template_var 9),
                      template_app
                       (template_app (template_hole 3, template_var 8),
                        template_app
                         (template_app (template_hole 2, template_var 7),
                          template_var 6))),
                    template_app
                     (template_app (template_hole 8, template_var 5),
                      template_var 4)),
                  template_var 3)),
              template_app
               (template_app
                 (template_hole 7,
                  template_app (template_hole 1, template_var 16)),
                template_app
                 (template_app (template_hole 6, template_var 2),
                  template_app
                   (template_app (template_hole 5, template_var 1),
                    template_var 0))))
            )],
       template_predicate (template_hole 0))),
    ("JVMCFG.reachable_node_impl_Main_ex",
     "[|  (?P, ?C0.0, ?Main) \<turnstile> \<Rightarrow>(?C, ?M, ?pc, ?nt);
         ?C ~= ClassMain ?P |]
      ==> EX T mb D.
             PROG
              ?P \<turnstile> ?C0.0 sees ?Main: []\<rightarrow>T = mb in D",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 15,
                template_app
                 (template_app (template_hole 14, template_var 6),
                  template_app
                   (template_app (template_hole 13, template_var 5),
                    template_var 4))),
              template_app
               (template_app (template_hole 12, template_var 3),
                template_app
                 (template_app (template_hole 11, template_var 2),
                  template_app
                   (template_app (template_hole 10, template_var 1),
                    template_var 0))))
            ),
        template_negation
         (
            template_equation
             (template_var 3,
              template_app (template_hole 7, template_var 6))
            )],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("JVMCFG.method_of_reachable_node_exists",
     "[|  (?P, ?C0.0, ?Main) \<turnstile> \<Rightarrow>(?C, ?M, ?pc, ?nt);
         ?C ~= ClassMain ?P |]
      ==> EX Ts T mb.
             PROG ?P \<turnstile> ?C sees ?M: Ts\<rightarrow>T = mb in ?C",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 14,
                template_app
                 (template_app (template_hole 13, template_var 6),
                  template_app
                   (template_app (template_hole 12, template_var 5),
                    template_var 4))),
              template_app
               (template_app (template_hole 11, template_var 3),
                template_app
                 (template_app (template_hole 10, template_var 2),
                  template_app
                   (template_app (template_hole 9, template_var 1),
                    template_var 0))))
            ),
        template_negation
         (
            template_equation
             (template_var 3,
              template_app (template_hole 6, template_var 6))
            )],
       template_predicate (template_app (template_hole 5, t_empty)))),
    ("JVMCFG.instr_of_reachable_node_typable",
     "[|  (?P, ?C0.0, ?Main) \<turnstile> \<Rightarrow>(?C, ?M, ?pc, ?nt);
         ?C ~= ClassMain ?P |]
      ==> case ?pc of None => True
          | \<lfloor>pc''\<rfloor> =>
              TYPING ?P ?C ?M ! pc'' ~= None &
              pc'' < length (instrs_of (PROG ?P) ?C ?M)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 26,
                template_app
                 (template_app (template_hole 25, template_var 6),
                  template_app
                   (template_app (template_hole 24, template_var 5),
                    template_var 4))),
              template_app
               (template_app (template_hole 23, template_var 3),
                template_app
                 (template_app (template_hole 22, template_var 2),
                  template_app
                   (template_app (template_hole 21, template_var 1),
                    template_var 0))))
            ),
        template_negation
         (
            template_equation
             (template_var 3,
              template_app (template_hole 18, template_var 6))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 17, template_hole 16), t_empty),
             template_var 1)
           ))),
    ("JVMCFG.reachable_node_impl_wt_instr",
     "[|  (?P, ?C0.0,
           ?Main) \<turnstile> \<Rightarrow>(?C, ?M, \<lfloor>?pc\<rfloor>,
       ?nt);
         ?C ~= ClassMain ?P |]
      ==> EX T mxs mpc xt.
             PROG
              ?P,T,mxs,mpc,xt \<turnstile> instrs_of (PROG ?P) ?C ?M !
     ?pc,?pc :: TYPING ?P ?C ?M",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 24,
                template_app
                 (template_app (template_hole 23, template_var 6),
                  template_app
                   (template_app (template_hole 22, template_var 5),
                    template_var 4))),
              template_app
               (template_app (template_hole 21, template_var 3),
                template_app
                 (template_app (template_hole 20, template_var 2),
                  template_app
                   (template_app
                     (template_hole 19,
                      template_app (template_hole 18, template_var 1)),
                    template_var 0))))
            ),
        template_negation
         (
            template_equation
             (template_var 3,
              template_app (template_hole 15, template_var 6))
            )],
       template_predicate (template_app (template_hole 14, t_empty)))),
    ("JVMCFG.method_of_src_and_trg_exists",
     "[|  (?P, ?C0.0,
           ?Main) \<turnstile> (?C', ?M', ?pc',
                                ?nt') -?ek\<rightarrow> (?C, ?M, ?pc, ?nt);
         ?C ~= ClassMain ?P; ?C' ~= ClassMain ?P |]
      ==> (EX Ts T mb.
              PROG
               ?P \<turnstile> ?C sees ?M: Ts\<rightarrow>T = mb in ?C) &
          (EX Ts T mb.
              PROG
               ?P \<turnstile> ?C' sees ?M': Ts\<rightarrow>T = mb in ?C')",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_hole 15,
                    template_app
                     (template_app (template_hole 14, template_var 11),
                      template_app
                       (template_app (template_hole 13, template_var 10),
                        template_var 9))),
                  template_app
                   (template_app (template_hole 12, template_var 8),
                    template_app
                     (template_app (template_hole 11, template_var 7),
                      template_app
                       (template_app (template_hole 10, template_var 6),
                        template_var 5)))),
                template_var 4),
              template_app
               (template_app (template_hole 12, template_var 3),
                template_app
                 (template_app (template_hole 11, template_var 2),
                  template_app
                   (template_app (template_hole 10, template_var 1),
                    template_var 0))))
            ),
        template_negation
         (
            template_equation
             (template_var 3,
              template_app (template_hole 7, template_var 11))
            ),
        template_negation
         (
            template_equation
             (template_var 8,
              template_app (template_hole 7, template_var 11))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 6, template_app (template_hole 5, t_empty)),
             template_app (template_hole 5, t_empty))
           ))),
    ("JVMCFG.JVMCFG_reachable_inducts",
     "[|  (?x5a, ?x5b,
           ?x5c) \<turnstile> \<Rightarrow>(?x6a, ?x6b, ?x6c, ?x6d);
         !!P C0 Main.
            ?P2.0 P C0 Main (ClassMain P) (MethodMain P) None Enter;
         !!a aa b ab ac ad ba e ae af ag bb.
            [|  (a, aa, b) \<turnstile> \<Rightarrow>(ab, ac, ad, ba);
               ?P2.0 a aa b ab ac ad ba;
                (a, aa,
                 b) \<turnstile> (ab, ac, ad,
                                  ba) -e\<rightarrow> (ae, af, ag, bb);
               ?P1.0 a aa b ab ac ad ba e ae af ag bb |]
            ==> ?P2.0 a aa b ae af ag bb;
         !!P C0 Main.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(ClassMain P, MethodMain P,
            \<lfloor>0\<rfloor>, Enter);
               ?P2.0 P C0 Main (ClassMain P) (MethodMain P)
                \<lfloor>0\<rfloor> Enter |]
            ==> ?P1.0 P C0 Main (ClassMain P) (MethodMain P)
                 \<lfloor>0\<rfloor> Enter \<Up>id (ClassMain P)
                 (MethodMain P) \<lfloor>0\<rfloor> Normal;
         !!P C0 Main.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(ClassMain P, MethodMain P,
            \<lfloor>0\<rfloor>, Normal);
               ?P2.0 P C0 Main (ClassMain P) (MethodMain P)
                \<lfloor>0\<rfloor> Normal |]
            ==> ?P1.0 P C0 Main (ClassMain P) (MethodMain P)
                 \<lfloor>0\<rfloor> Normal (%s. False)\<^sub>\<surd>
                 (ClassMain P) (MethodMain P) \<lfloor>0\<rfloor>
                 nodeType.Return;
         !!P C0 Main T mxs mxl\<^sub>0 is xt D initParams ek.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(ClassMain P, MethodMain P,
            \<lfloor>0\<rfloor>, Normal);
               ?P2.0 P C0 Main (ClassMain P) (MethodMain P)
                \<lfloor>0\<rfloor> Normal;
               PROG
                P \<turnstile> C0 sees Main: []\<rightarrow>T = (mxs,
                           mxl\<^sub>0, is, xt) in D;
               initParams = [%s. s Heap, %s. \<lfloor>Value Null\<rfloor>];
               ek =
               %(s, ret).
                  True:(ClassMain P, MethodMain P,
                        0)\<hookrightarrow>\<^bsub>(D,
              Main)\<^esub>initParams |]
            ==> ?P1.0 P C0 Main (ClassMain P) (MethodMain P)
                 \<lfloor>0\<rfloor> Normal ek D Main None Enter;
         !!P C0 Main.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(ClassMain P, MethodMain P,
            \<lfloor>0\<rfloor>, nodeType.Return);
               ?P2.0 P C0 Main (ClassMain P) (MethodMain P)
                \<lfloor>0\<rfloor> nodeType.Return |]
            ==> ?P1.0 P C0 Main (ClassMain P) (MethodMain P)
                 \<lfloor>0\<rfloor> nodeType.Return \<Up>id (ClassMain P)
                 (MethodMain P) None nodeType.Return;
         !!P C0 Main C M.
            [|  (P, C0, Main) \<turnstile> \<Rightarrow>(C, M, None, Enter);
               ?P2.0 P C0 Main C M None Enter |]
            ==> ?P1.0 P C0 Main C M None Enter (%s. False)\<^sub>\<surd> C M
                 None nodeType.Return;
         !!P C0 Main C M.
            [|  (P, C0, Main) \<turnstile> \<Rightarrow>(C, M, None, Enter);
               ?P2.0 P C0 Main C M None Enter |]
            ==> ?P1.0 P C0 Main C M None Enter (%s. True)\<^sub>\<surd> C M
                 \<lfloor>0\<rfloor> Enter;
         !!C P C0 Main M pc n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Load n;
               ek =
               \<Up>%s. s(Stack (stkLength (P, C, M) pc) := s (Local n)) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Store n;
               ek =
               \<Up>%s. s(Local n :=
                            s (Stack (stkLength (P, C, M) pc - 1))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc v ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Push v;
               ek =
               \<Up>%s. s(Stack (stkLength (P, C, M) pc) |-> Value v) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Pop; ek = \<Up>id |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = IAdd;
               ek =
               \<Up>%s. let i1 = the_Intg
                                  (stkAt s (stkLength (P, C, M) pc - 1));
                            i2 = the_Intg
                                  (stkAt s (stkLength (P, C, M) pc - 2))
                        in s(Stack (stkLength (P, C, M) pc - 2) |->
                           Value (Intg (i1 + i2))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc i.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Goto i |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter
                 (%s. True)\<^sub>\<surd> C M
                 \<lfloor>nat (int pc + i)\<rfloor> Enter;
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = CmpEq;
               ek =
               \<Up>%s. let e1 = stkAt s (stkLength (P, C, M) pc - 1);
                            e2 = stkAt s (stkLength (P, C, M) pc - 2)
                        in s(Stack (stkLength (P, C, M) pc - 2) |->
                           Value (Bool (e1 = e2))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc i ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = IfFalse i; i ~= 1;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 1) =
                    Bool False)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>nat (int pc + i)\<rfloor> Enter;
         !!C P C0 Main M pc i ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = IfFalse i;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 1) ~= Bool False |
                    i = 1)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = New Cl;
               ek = (%s. new_Addr (heap_of s) ~= None)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> Normal;
         !!C P C0 Main M pc Cl pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = New Cl;
               pc' =
               (case match_ex_table (PROG P) OutOfMemory pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek = (%s. new_Addr (heap_of s) = None)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = New Cl;
               ek =
               \<Up>%s. let a = the (new_Addr (heap_of s))
                        in s(Heap |->
                           Hp (heap_of s(a |-> blank (PROG P) Cl)),
                           Stack (stkLength (P, C, M) pc) |->
                           Value (Addr a)) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = New Cl;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt OutOfMemory))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = New Cl;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt OutOfMemory))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 1) ~=
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> Normal;
         !!C P C0 Main M pc F Cl pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               pc' =
               (case match_ex_table (PROG P) NullPointer pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 1) =
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               ek =
               \<Up>%s. let (D, fs) =
                              the (heap_of s
                                    (the_Addr
(stkAt s (stkLength (P, C, M) pc - 1))))
                        in s(Stack (stkLength (P, C, M) pc - 1) |->
                           Value (the (fs (F, Cl)))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 2) ~=
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> Normal;
         !!C P C0 Main M pc F Cl pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               pc' =
               (case match_ex_table (PROG P) NullPointer pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 2) =
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               ek =
               \<Up>%s. let v = stkAt s (stkLength (P, C, M) pc - 1);
                            r = stkAt s (stkLength (P, C, M) pc - 2);
                            a = the_Addr r; (D, fs) = the (heap_of s a);
                            h' = heap_of s(a |-> (D, fs((F, Cl) |-> v)))
                        in s(Heap |-> Hp h') |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Checkcast Cl;
               ek =
               (%s. cast_ok (PROG P) Cl (heap_of s)
                     (stkAt s
                       (stkLength (P, C, M) pc - 1)))\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc Cl pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Checkcast Cl;
               pc' =
               (case match_ex_table (PROG P) ClassCast pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek =
               (%s. ~ cast_ok (PROG P) Cl (heap_of s)
                       (stkAt s
                         (stkLength (P, C, M) pc - 1)))\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Checkcast Cl;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt ClassCast))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = Checkcast Cl;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt ClassCast))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc pc' Exc d ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Throw;
               pc' = None |
               match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =
               \<lfloor>(the pc', d)\<rfloor>;
               ek =
               (%s. let v = stkAt s (stkLength (P, C, M) pc - 1);
                        Cl = if v = Null then NullPointer
                             else cname_of (heap_of s) (the_Addr v)
                    in case pc' of
                       None =>
                         match_ex_table (PROG P) Cl pc
                          (ex_table_of (PROG P) C M) =
                         None
                       | \<lfloor>pc''\<rfloor> =>
                           EX d. match_ex_table (PROG P) Cl pc
                                  (ex_table_of (PROG P) C M) =
                                 \<lfloor>(pc'',
     d)\<rfloor>)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Throw;
               ek =
               \<Up>%s. s(Exception |->
                       Value (stkAt s (stkLength (P, C, M) pc - 1))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               pc' ~= length (instrs_of (PROG P) C M);
               instrs_of (PROG P) C M ! pc = Throw;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (stkAt s (stkLength (P, C, M) pc - 1))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - Suc n) ~=
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> Normal;
         !!C P C0 Main M pc M' n pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               pc' =
               (case match_ex_table (PROG P) NullPointer pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - Suc n) =
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\<^sub>0 is xt D Q
            paramDefs ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               TYPING P C M ! pc = \<lfloor>(ST, LT)\<rfloor>;
               ST ! n = Class D';
               PROG
                P \<turnstile> D' sees M': Ts\<rightarrow>T = (mxs,
                         mxl\<^sub>0, is, xt) in D;
               Q =
               (%(s, ret).
                   let r = stkAt s (stkLength (P, C, M) pc - Suc n);
                       C' = cname_of (heap_of s) (the_Addr r)
                   in D = fst (method (PROG P) C' M'));
               paramDefs =
               (%s. s Heap) #
               (%s. s (Stack (stkLength (P, C, M) pc - Suc n))) #
               rev (map (%i s. s (Stack (stkLength (P, C, M) pc - Suc i)))
                     [0..<n]);
               ek =
               Q:(C, M,
                  pc)\<hookrightarrow>\<^bsub>(D, M')\<^esub>paramDefs |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek D M' None
                 Enter;
         !!C P C0 Main M pc M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek = (%s. False)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek C M
                 \<lfloor>pc\<rfloor> nodeType.Return;
         !!C P C0 Main M pc M' n ST LT ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, nodeType.Return);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               TYPING P C M ! pc = \<lfloor>(ST, LT)\<rfloor>; ST ! n ~= NT;
               ek = (%s. s Exception = None)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return ek
                 C M \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc M' n Exc pc' diff ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, nodeType.Return);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =
               \<lfloor>(pc', diff)\<rfloor>;
               pc' ~= length (instrs_of (PROG P) C M);
               ek =
               (%s. EX v d.
                       s Exception = \<lfloor>v\<rfloor> &
                       match_ex_table (PROG P)
                        (cname_of (heap_of s) (the_Addr (the_Value v))) pc
                        (ex_table_of (PROG P) C M) =
                       \<lfloor>(pc', d)\<rfloor>)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return ek
                 C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> nodeType.Return);
         !!C P C0 Main M pc pc' M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>,
            Exceptional \<lfloor>pc'\<rfloor> nodeType.Return);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> nodeType.Return);
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               \<Up>%s. s(Exception := None,
                          Stack (stkLength (P, C, M) pc' - 1) :=
                            s Exception) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> nodeType.Return) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, nodeType.Return);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               (%s. EX v. s Exception = \<lfloor>v\<rfloor> &
                          match_ex_table (PROG P)
                           (cname_of (heap_of s) (the_Addr (the_Value v)))
                           pc (ex_table_of (PROG P) C M) =
                          None)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return ek
                 C M None nodeType.Return;
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = instr.Return;
               ek =
               \<Up>%s. s(Stack 0 :=
                            s (Stack (stkLength (P, C, M) pc - 1))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M None
                 nodeType.Return;
         !!P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M, None,
            nodeType.Return);
               ?P2.0 P C0 Main C M None nodeType.Return;
                (P, C0,
                 Main) \<turnstile> (C', M', \<lfloor>pc'\<rfloor>,
                                     Normal) -Q':(C', M',
            pc')\<hookrightarrow>\<^bsub>(C,
    M)\<^esub>ps\<rightarrow> (C, M, None, Enter);
               ?P1.0 P C0 Main C' M' \<lfloor>pc'\<rfloor> Normal
                (Q':(C', M', pc')\<hookrightarrow>\<^bsub>(C, M)\<^esub>ps)
                C M None Enter;
               Q = (%(s, ret). ret = (C', M', pc'));
               stateUpdate =
               (%s s'. s'
                   (Heap := s Heap, Exception := s Exception,
                    Stack (stkLength (P, C', M') (Suc pc') - 1) :=
                      s (Stack 0)));
               ek = Q\<hookleftarrow>\<^bsub>(C, M)\<^esub>stateUpdate |]
            ==> ?P1.0 P C0 Main C M None nodeType.Return ek C' M'
                 \<lfloor>pc'\<rfloor> nodeType.Return |]
      ==> ?P2.0 ?x5a ?x5b ?x5c ?x6a ?x6b ?x6c ?x6d",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 167,
                template_app
                 (template_app (template_hole 166, template_var 8),
                  template_app
                   (template_app (template_hole 165, template_var 7),
                    template_var 6))),
              template_app
               (template_app (template_hole 164, template_var 5),
                template_app
                 (template_app (template_hole 163, template_var 4),
                  template_app
                   (template_app (template_hole 162, template_var 3),
                    template_var 2))))
            ),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_var 1, template_var 8),
                       template_var 7),
                     template_var 6),
                   template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2)
           ))),
    ("JVMCFG.JVMCFG_reachable_inducts",
     "[|  (?x1a, ?x1b,
           ?x1c) \<turnstile> (?x2a, ?x2b, ?x2c,
                               ?x2d) -?x3a\<rightarrow> (?x4a, ?x4b, ?x4c,
                   ?x4d);
         !!P C0 Main.
            ?P2.0 P C0 Main (ClassMain P) (MethodMain P) None Enter;
         !!a aa b ab ac ad ba e ae af ag bb.
            [|  (a, aa, b) \<turnstile> \<Rightarrow>(ab, ac, ad, ba);
               ?P2.0 a aa b ab ac ad ba;
                (a, aa,
                 b) \<turnstile> (ab, ac, ad,
                                  ba) -e\<rightarrow> (ae, af, ag, bb);
               ?P1.0 a aa b ab ac ad ba e ae af ag bb |]
            ==> ?P2.0 a aa b ae af ag bb;
         !!P C0 Main.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(ClassMain P, MethodMain P,
            \<lfloor>0\<rfloor>, Enter);
               ?P2.0 P C0 Main (ClassMain P) (MethodMain P)
                \<lfloor>0\<rfloor> Enter |]
            ==> ?P1.0 P C0 Main (ClassMain P) (MethodMain P)
                 \<lfloor>0\<rfloor> Enter \<Up>id (ClassMain P)
                 (MethodMain P) \<lfloor>0\<rfloor> Normal;
         !!P C0 Main.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(ClassMain P, MethodMain P,
            \<lfloor>0\<rfloor>, Normal);
               ?P2.0 P C0 Main (ClassMain P) (MethodMain P)
                \<lfloor>0\<rfloor> Normal |]
            ==> ?P1.0 P C0 Main (ClassMain P) (MethodMain P)
                 \<lfloor>0\<rfloor> Normal (%s. False)\<^sub>\<surd>
                 (ClassMain P) (MethodMain P) \<lfloor>0\<rfloor>
                 nodeType.Return;
         !!P C0 Main T mxs mxl\<^sub>0 is xt D initParams ek.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(ClassMain P, MethodMain P,
            \<lfloor>0\<rfloor>, Normal);
               ?P2.0 P C0 Main (ClassMain P) (MethodMain P)
                \<lfloor>0\<rfloor> Normal;
               PROG
                P \<turnstile> C0 sees Main: []\<rightarrow>T = (mxs,
                           mxl\<^sub>0, is, xt) in D;
               initParams = [%s. s Heap, %s. \<lfloor>Value Null\<rfloor>];
               ek =
               %(s, ret).
                  True:(ClassMain P, MethodMain P,
                        0)\<hookrightarrow>\<^bsub>(D,
              Main)\<^esub>initParams |]
            ==> ?P1.0 P C0 Main (ClassMain P) (MethodMain P)
                 \<lfloor>0\<rfloor> Normal ek D Main None Enter;
         !!P C0 Main.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(ClassMain P, MethodMain P,
            \<lfloor>0\<rfloor>, nodeType.Return);
               ?P2.0 P C0 Main (ClassMain P) (MethodMain P)
                \<lfloor>0\<rfloor> nodeType.Return |]
            ==> ?P1.0 P C0 Main (ClassMain P) (MethodMain P)
                 \<lfloor>0\<rfloor> nodeType.Return \<Up>id (ClassMain P)
                 (MethodMain P) None nodeType.Return;
         !!P C0 Main C M.
            [|  (P, C0, Main) \<turnstile> \<Rightarrow>(C, M, None, Enter);
               ?P2.0 P C0 Main C M None Enter |]
            ==> ?P1.0 P C0 Main C M None Enter (%s. False)\<^sub>\<surd> C M
                 None nodeType.Return;
         !!P C0 Main C M.
            [|  (P, C0, Main) \<turnstile> \<Rightarrow>(C, M, None, Enter);
               ?P2.0 P C0 Main C M None Enter |]
            ==> ?P1.0 P C0 Main C M None Enter (%s. True)\<^sub>\<surd> C M
                 \<lfloor>0\<rfloor> Enter;
         !!C P C0 Main M pc n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Load n;
               ek =
               \<Up>%s. s(Stack (stkLength (P, C, M) pc) := s (Local n)) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Store n;
               ek =
               \<Up>%s. s(Local n :=
                            s (Stack (stkLength (P, C, M) pc - 1))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc v ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Push v;
               ek =
               \<Up>%s. s(Stack (stkLength (P, C, M) pc) |-> Value v) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Pop; ek = \<Up>id |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = IAdd;
               ek =
               \<Up>%s. let i1 = the_Intg
                                  (stkAt s (stkLength (P, C, M) pc - 1));
                            i2 = the_Intg
                                  (stkAt s (stkLength (P, C, M) pc - 2))
                        in s(Stack (stkLength (P, C, M) pc - 2) |->
                           Value (Intg (i1 + i2))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc i.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Goto i |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter
                 (%s. True)\<^sub>\<surd> C M
                 \<lfloor>nat (int pc + i)\<rfloor> Enter;
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = CmpEq;
               ek =
               \<Up>%s. let e1 = stkAt s (stkLength (P, C, M) pc - 1);
                            e2 = stkAt s (stkLength (P, C, M) pc - 2)
                        in s(Stack (stkLength (P, C, M) pc - 2) |->
                           Value (Bool (e1 = e2))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc i ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = IfFalse i; i ~= 1;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 1) =
                    Bool False)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>nat (int pc + i)\<rfloor> Enter;
         !!C P C0 Main M pc i ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = IfFalse i;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 1) ~= Bool False |
                    i = 1)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = New Cl;
               ek = (%s. new_Addr (heap_of s) ~= None)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> Normal;
         !!C P C0 Main M pc Cl pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = New Cl;
               pc' =
               (case match_ex_table (PROG P) OutOfMemory pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek = (%s. new_Addr (heap_of s) = None)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = New Cl;
               ek =
               \<Up>%s. let a = the (new_Addr (heap_of s))
                        in s(Heap |->
                           Hp (heap_of s(a |-> blank (PROG P) Cl)),
                           Stack (stkLength (P, C, M) pc) |->
                           Value (Addr a)) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = New Cl;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt OutOfMemory))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = New Cl;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt OutOfMemory))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 1) ~=
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> Normal;
         !!C P C0 Main M pc F Cl pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               pc' =
               (case match_ex_table (PROG P) NullPointer pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 1) =
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               ek =
               \<Up>%s. let (D, fs) =
                              the (heap_of s
                                    (the_Addr
(stkAt s (stkLength (P, C, M) pc - 1))))
                        in s(Stack (stkLength (P, C, M) pc - 1) |->
                           Value (the (fs (F, Cl)))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = Getfield F Cl;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 2) ~=
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> Normal;
         !!C P C0 Main M pc F Cl pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               pc' =
               (case match_ex_table (PROG P) NullPointer pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - 2) =
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               ek =
               \<Up>%s. let v = stkAt s (stkLength (P, C, M) pc - 1);
                            r = stkAt s (stkLength (P, C, M) pc - 2);
                            a = the_Addr r; (D, fs) = the (heap_of s a);
                            h' = heap_of s(a |-> (D, fs((F, Cl) |-> v)))
                        in s(Heap |-> Hp h') |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' F Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = Putfield F Cl;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Checkcast Cl;
               ek =
               (%s. cast_ok (PROG P) Cl (heap_of s)
                     (stkAt s
                       (stkLength (P, C, M) pc - 1)))\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc Cl pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Checkcast Cl;
               pc' =
               (case match_ex_table (PROG P) ClassCast pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek =
               (%s. ~ cast_ok (PROG P) Cl (heap_of s)
                       (stkAt s
                         (stkLength (P, C, M) pc - 1)))\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Checkcast Cl;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt ClassCast))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' Cl ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = Checkcast Cl;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt ClassCast))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc pc' Exc d ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Throw;
               pc' = None |
               match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =
               \<lfloor>(the pc', d)\<rfloor>;
               ek =
               (%s. let v = stkAt s (stkLength (P, C, M) pc - 1);
                        Cl = if v = Null then NullPointer
                             else cname_of (heap_of s) (the_Addr v)
                    in case pc' of
                       None =>
                         match_ex_table (PROG P) Cl pc
                          (ex_table_of (PROG P) C M) =
                         None
                       | \<lfloor>pc''\<rfloor> =>
                           EX d. match_ex_table (PROG P) Cl pc
                                  (ex_table_of (PROG P) C M) =
                                 \<lfloor>(pc'',
     d)\<rfloor>)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Throw;
               ek =
               \<Up>%s. s(Exception |->
                       Value (stkAt s (stkLength (P, C, M) pc - 1))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               pc' ~= length (instrs_of (PROG P) C M);
               instrs_of (PROG P) C M ! pc = Throw;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (stkAt s (stkLength (P, C, M) pc - 1))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - Suc n) ~=
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> Normal;
         !!C P C0 Main M pc M' n pc' ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               pc' =
               (case match_ex_table (PROG P) NullPointer pc
                      (ex_table_of (PROG P) C M) of
                None => None
                | \<lfloor>(pc'', d)\<rfloor> => \<lfloor>pc''\<rfloor>);
               ek =
               (%s. stkAt s (stkLength (P, C, M) pc - Suc n) =
                    Null)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M
                 \<lfloor>pc\<rfloor> (Exceptional pc' Enter);
         !!C P C0 Main M pc M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional None Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional None Enter);
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               \<Up>%s. s(Exception |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional None Enter) ek C M None nodeType.Return;
         !!C P C0 Main M pc pc' M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Exceptional \<lfloor>pc'\<rfloor> Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> Enter);
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               \<Up>%s. s(Exception := None)
                       (Stack (stkLength (P, C, M) pc' - 1) |->
                       Value (Addr (addr_of_sys_xcpt NullPointer))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> Enter) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc M' n ST LT D' Ts T mxs mxl\<^sub>0 is xt D Q
            paramDefs ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               TYPING P C M ! pc = \<lfloor>(ST, LT)\<rfloor>;
               ST ! n = Class D';
               PROG
                P \<turnstile> D' sees M': Ts\<rightarrow>T = (mxs,
                         mxl\<^sub>0, is, xt) in D;
               Q =
               (%(s, ret).
                   let r = stkAt s (stkLength (P, C, M) pc - Suc n);
                       C' = cname_of (heap_of s) (the_Addr r)
                   in D = fst (method (PROG P) C' M'));
               paramDefs =
               (%s. s Heap) #
               (%s. s (Stack (stkLength (P, C, M) pc - Suc n))) #
               rev (map (%i s. s (Stack (stkLength (P, C, M) pc - Suc i)))
                     [0..<n]);
               ek =
               Q:(C, M,
                  pc)\<hookrightarrow>\<^bsub>(D, M')\<^esub>paramDefs |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek D M' None
                 Enter;
         !!C P C0 Main M pc M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Normal);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek = (%s. False)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Normal ek C M
                 \<lfloor>pc\<rfloor> nodeType.Return;
         !!C P C0 Main M pc M' n ST LT ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, nodeType.Return);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               TYPING P C M ! pc = \<lfloor>(ST, LT)\<rfloor>; ST ! n ~= NT;
               ek = (%s. s Exception = None)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return ek
                 C M \<lfloor>Suc pc\<rfloor> Enter;
         !!C P C0 Main M pc M' n Exc pc' diff ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, nodeType.Return);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               match_ex_table (PROG P) Exc pc (ex_table_of (PROG P) C M) =
               \<lfloor>(pc', diff)\<rfloor>;
               pc' ~= length (instrs_of (PROG P) C M);
               ek =
               (%s. EX v d.
                       s Exception = \<lfloor>v\<rfloor> &
                       match_ex_table (PROG P)
                        (cname_of (heap_of s) (the_Addr (the_Value v))) pc
                        (ex_table_of (PROG P) C M) =
                       \<lfloor>(pc', d)\<rfloor>)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return ek
                 C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> nodeType.Return);
         !!C P C0 Main M pc pc' M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>,
            Exceptional \<lfloor>pc'\<rfloor> nodeType.Return);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor>
                (Exceptional \<lfloor>pc'\<rfloor> nodeType.Return);
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               \<Up>%s. s(Exception := None,
                          Stack (stkLength (P, C, M) pc' - 1) :=
                            s Exception) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor>
                 (Exceptional \<lfloor>pc'\<rfloor> nodeType.Return) ek C M
                 \<lfloor>pc'\<rfloor> Enter;
         !!C P C0 Main M pc M' n ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, nodeType.Return);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return;
               instrs_of (PROG P) C M ! pc = Invoke M' n;
               ek =
               (%s. EX v. s Exception = \<lfloor>v\<rfloor> &
                          match_ex_table (PROG P)
                           (cname_of (heap_of s) (the_Addr (the_Value v)))
                           pc (ex_table_of (PROG P) C M) =
                          None)\<^sub>\<surd> |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> nodeType.Return ek
                 C M None nodeType.Return;
         !!C P C0 Main M pc ek.
            [| C ~= ClassMain P;
                (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M,
            \<lfloor>pc\<rfloor>, Enter);
               ?P2.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter;
               instrs_of (PROG P) C M ! pc = instr.Return;
               ek =
               \<Up>%s. s(Stack 0 :=
                            s (Stack (stkLength (P, C, M) pc - 1))) |]
            ==> ?P1.0 P C0 Main C M \<lfloor>pc\<rfloor> Enter ek C M None
                 nodeType.Return;
         !!P C0 Main C M C' M' pc' Q' ps Q stateUpdate ek.
            [|  (P, C0,
                 Main) \<turnstile> \<Rightarrow>(C, M, None,
            nodeType.Return);
               ?P2.0 P C0 Main C M None nodeType.Return;
                (P, C0,
                 Main) \<turnstile> (C', M', \<lfloor>pc'\<rfloor>,
                                     Normal) -Q':(C', M',
            pc')\<hookrightarrow>\<^bsub>(C,
    M)\<^esub>ps\<rightarrow> (C, M, None, Enter);
               ?P1.0 P C0 Main C' M' \<lfloor>pc'\<rfloor> Normal
                (Q':(C', M', pc')\<hookrightarrow>\<^bsub>(C, M)\<^esub>ps)
                C M None Enter;
               Q = (%(s, ret). ret = (C', M', pc'));
               stateUpdate =
               (%s s'. s'
                   (Heap := s Heap, Exception := s Exception,
                    Stack (stkLength (P, C', M') (Suc pc') - 1) :=
                      s (Stack 0)));
               ek = Q\<hookleftarrow>\<^bsub>(C, M)\<^esub>stateUpdate |]
            ==> ?P1.0 P C0 Main C M None nodeType.Return ek C' M'
                 \<lfloor>pc'\<rfloor> nodeType.Return |]
      ==> ?P1.0 ?x1a ?x1b ?x1c ?x2a ?x2b ?x2c ?x2d ?x3a ?x4a ?x4b ?x4c
           ?x4d",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_hole 167,
                    template_app
                     (template_app (template_hole 166, template_var 13),
                      template_app
                       (template_app (template_hole 165, template_var 12),
                        template_var 11))),
                  template_app
                   (template_app (template_hole 164, template_var 10),
                    template_app
                     (template_app (template_hole 163, template_var 9),
                      template_app
                       (template_app (template_hole 162, template_var 8),
                        template_var 7)))),
                template_var 6),
              template_app
               (template_app (template_hole 164, template_var 5),
                template_app
                 (template_app (template_hole 163, template_var 4),
                  template_app
                   (template_app (template_hole 162, template_var 3),
                    template_var 2))))
            ),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 160, t_empty)),
        template_predicate (template_app (template_hole 161, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_var 0, template_var 13),
                                 template_var 12),
                               template_var 11),
                             template_var 10),
                           template_var 9),
                         template_var 8),
                       template_var 7),
                     template_var 6),
                   template_var 5),
                 template_var 4),
               template_var 3),
             template_var 2)
           )))]
