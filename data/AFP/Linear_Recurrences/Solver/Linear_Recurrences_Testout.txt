Loading theory "Containers.Equal" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set")
Loading theory "Containers.Extend_Partial_Order" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder")
Loading theory "Containers.List_Fusion" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
Loading theory "Pure-ex.Guess" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library" via "Sturm_Sequences.Misc_Polynomial")
locale equal_base
  fixes equal :: "'a => 'a => bool"
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
### theory "Containers.Equal"
### 0.039s elapsed time, 0.138s cpu time, 0.019s GC time
Loading theory "Containers.Closure_Set" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
Proofs for inductive predicate(s) "terminates_onp"
  Proving monotonicity ...
### ML warning (line 99 of "~~/src/Pure/ex/Guess.thy"):
### Pattern is not exhaustive.
### ML warning (line 150 of "~~/src/Pure/ex/Guess.thy"):
### Matches are not exhaustive.
### ML warning (line 157 of "~~/src/Pure/ex/Guess.thy"):
### Pattern is not exhaustive.
signature GUESS =
  sig
    val guess:
       (binding * typ option * mixfix) list ->
         bool -> Proof.state -> Proof.state
    val guess_cmd:
       (binding * string option * mixfix) list ->
         bool -> Proof.state -> Proof.state
  end
structure Guess: GUESS
locale equal_base
  fixes equal :: "'a => 'a => bool"
### theory "Pure-ex.Guess"
### 0.059s elapsed time, 0.217s cpu time, 0.019s GC time
Loading theory "Deriving.Comparator" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
### theory "Containers.Closure_Set"
### 0.034s elapsed time, 0.143s cpu time, 0.000s GC time
Loading theory "Deriving.Derive_Manager" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
signature DERIVE_MANAGER =
  sig
    val derive: string -> string -> string -> theory -> theory
    val derive_cmd: string -> string -> string -> theory -> theory
    val print_info: theory -> unit
    val register_derive:
       string ->
         string ->
           (string -> string -> theory -> theory) -> theory -> theory
  end
structure Derive_Manager: DERIVE_MANAGER
### theory "Deriving.Derive_Manager"
### 0.040s elapsed time, 0.185s cpu time, 0.000s GC time
Loading theory "Deriving.Generator_Aux" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
### theory "Containers.Extend_Partial_Order"
### 0.123s elapsed time, 0.509s cpu time, 0.019s GC time
Loading theory "HOL-Library.AList" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Factorization.Precomputation" via "HOL-Library.RBT_Mapping" via "HOL-Library.Mapping")
signature BNF_ACCESS =
  sig
    val bnf_types: Proof.context -> string list -> typ list
    val case_consts: Proof.context -> string list -> term list
    val case_simps: Proof.context -> string list -> thm list list
    val case_thms: Proof.context -> string list -> thm list
    val constr_argument_types:
       Proof.context -> string list -> typ list list list
    val constr_terms: Proof.context -> string -> term list
    val distinct_thms: Proof.context -> string list -> thm list list
    val induct_thms: Proof.context -> string list -> thm list
    val inject_thms: Proof.context -> string list -> thm list list
    val map_comps: Proof.context -> string list -> thm list
    val map_simps: Proof.context -> string list -> thm list list
    val map_terms: Proof.context -> string list -> term list
    val set_simps: Proof.context -> string list -> thm list list
    val set_terms: Proof.context -> string list -> term list list
  end
structure Bnf_Access: BNF_ACCESS
consts
  update :: "'key => 'val => ('key * 'val) list => ('key * 'val) list"
locale list
  fixes g :: "('a, 's) generator"
signature GENERATOR_AUX =
  sig
    val OF_option: thm -> thm option list -> thm
    val add_used_tycos:
       Proof.context -> string -> string list -> string list
    val alist_to_string: (string * 'a) list -> string
    val conjI_tac:
       thm list ->
         Proof.context ->
           'a list -> (Proof.context -> int -> tactic) -> tactic
    val create_map:
       (typ -> term) ->
         (string * typ -> 'a -> term) ->
           'a ->
             (typ -> bool) ->
               (local_theory -> string -> bool list) ->
                 (local_theory -> string -> term) ->
                   (local_theory -> string -> 'a -> term) ->
                     string list ->
                       (local_theory -> string -> 'a) ->
                         typ -> local_theory -> term
    val create_partial:
       'a ->
         (typ -> bool) ->
           (local_theory -> string -> bool list) ->
             (local_theory -> string -> term) ->
               (local_theory -> string -> 'a -> term) ->
                 string list ->
                   (local_theory -> string -> 'a) ->
                     typ -> local_theory -> term
    val define_overloaded:
       string * term -> local_theory -> thm * local_theory
    val define_overloaded_generic:
       Attrib.binding * term -> local_theory -> thm * local_theory
    val drop_last: 'a list -> 'a list
    val freeify_tvars: typ -> typ
    val ind_case_to_idxs: 'a list list -> int -> int * int
    val infer_type: Proof.context -> term -> term
    val ints_to_subscript: int list -> string
    val is_class_instance: theory -> string -> sort -> bool
    val lambdas: term list -> term -> term
    val mk_case_tac:
       Proof.context ->
         term option list list ->
           thm ->
             (int ->
                Proof.context * thm list * (string * cterm) list -> tactic)
               -> tactic
    val mk_def: typ -> string -> term -> term
    val mk_id: typ -> term
    val mk_infer_const: string -> Proof.context -> term -> term
    val mutual_recursive_types:
       string -> Proof.context -> string list * typ list
    val prove_multi_future:
       Proof.context ->
         string list ->
           term list ->
             term list ->
               ({context: Proof.context, prems: thm list} -> tactic) ->
                 thm list
    val recursor:
       (string -> 'a) * ('a -> bool list) * string list ->
         bool ->
           (typ -> 'b) ->
             (typ -> 'b) ->
               (typ -> 'b) ->
                 ((typ * 'b option) list * 'a -> 'b) -> typ -> 'b
    val rename_types: (typ * typ) list -> term -> term
    val split_IHs:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list -> thm list -> thm list list
    val std_recursor_tac:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list ->
           ('a -> thm) ->
             thm list -> typ -> thm list -> Proof.context -> tactic
    val sub: string -> string
    val subT: string -> typ -> string
    val typ_and_vs_of_typname:
       theory -> string -> sort -> typ * (string * sort) list
    val typ_and_vs_of_used_typname:
       string ->
         bool list -> string list -> typ * (string * string list) list
    val type_parameters:
       typ -> Proof.context -> (string * sort) list * typ list
  end
structure Generator_Aux: GENERATOR_AUX
### theory "Deriving.Generator_Aux"
### 0.146s elapsed time, 0.560s cpu time, 0.076s GC time
Loading theory "Deriving.Equality_Generator" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set" via "Containers.Collection_Eq" via "Deriving.Equality_Instances")
consts
  list_has_next :: "'a list => bool"
### No equation for constructor "[]"
consts
  list_next :: "'a list => 'a * 'a list"
consts
  update_with_aux ::
    "'val
     => 'key => ('val => 'val) => ('key * 'val) list => ('key * 'val) list"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
locale comparator
  fixes comp :: "'a => 'a => order"
  assumes "comparator comp"
signature EQUALITY_GENERATOR =
  sig
    val ensure_info: equality_type -> string -> local_theory -> local_theory
    datatype equality_type = BNF | EQ
    val generate_equality:
       equality_type -> string -> local_theory -> local_theory
    val generate_equalitys_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {equality: term,
        equality_def: thm option,
        equality_thm: thm,
        map: term,
        map_comp: thm option,
        partial_equality_thm: thm,
        pequality: term, used_positions: bool list}
    val register_equality_of: string -> local_theory -> local_theory
    val register_foreign_equality:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_equality:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm -> thm -> bool list -> local_theory -> local_theory
  end
structure Equality_Generator: EQUALITY_GENERATOR
### theory "Deriving.Equality_Generator"
### 0.283s elapsed time, 1.070s cpu time, 0.120s GC time
Loading theory "Deriving.Equality_Instances" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set" via "Containers.Collection_Eq")
Found termination order: "case_sum (%x. Suc 0) (%x. 0) <*mlex*> {}"
generating equality for type "Sum_Type.sum"
generating equality for type "List.list"
generating equality for type "Product_Type.prod"
generating equality for type "Option.option"
### theory "Deriving.Equality_Instances"
### 0.086s elapsed time, 0.353s cpu time, 0.000s GC time
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Auxiliary" via "HOL-Library.Monad_Syntax")
Proofs for inductive predicate(s) "filter_has_next"
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.219s elapsed time, 0.724s cpu time, 0.411s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Auxiliary")
  Proving monotonicity ...
### theory "Deriving.Comparator"
### 0.811s elapsed time, 3.059s cpu time, 0.607s GC time
Loading theory "Deriving.Compare" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator")
### theory "HOL-Library.Monad_Syntax"
### 0.041s elapsed time, 0.158s cpu time, 0.000s GC time
Loading theory "Deriving.Comparator_Generator" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator")
class compare = type +
  fixes compare :: "'a => 'a => order"
  assumes "comparator_compare": "comparator compare"
### theory "Containers.List_Fusion"
### 1.024s elapsed time, 3.862s cpu time, 0.669s GC time
Loading theory "Containers.Containers_Auxiliary" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum")
class compare_order = compare + ord +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod" (infix \<open>\<sqsubset>\<close> 50)
Found termination order: "size_list size <*mlex*> {}"
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
### theory "Containers.Containers_Auxiliary"
### 0.207s elapsed time, 0.796s cpu time, 0.073s GC time
Loading theory "Efficient-Mergesort.Efficient_Sort" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Reconstruction" via "Berlekamp_Zassenhaus.Degree_Bound")
Found termination order:
  "(%p. size_list size (snd (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Library.AList"
### 1.169s elapsed time, 4.404s cpu time, 0.723s GC time
Loading theory "HOL-Number_Theory.Cong" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues")
class compare_order = compare + linorder +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
signature COMPARE_CODE =
  sig
    val change_compare_code:
       term -> string list -> local_theory -> local_theory
  end
structure Compare_Code: COMPARE_CODE
### theory "Deriving.Compare"
### 0.595s elapsed time, 2.313s cpu time, 0.200s GC time
Loading theory "HOL-Library.Char_ord" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
instantiation
  char :: linorder
  less_eq_char == less_eq :: char => char => bool
  less_char == less :: char => char => bool
signature COMPARATOR_GENERATOR =
  sig
    datatype comparator_type = BNF | Linorder
    val ensure_info:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparator:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparators_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {comp: term,
        comp_def: thm option,
        comp_thm: thm,
        map: term,
        map_comp: thm option,
        partial_comp_thms: thm list, pcomp: term, used_positions: bool list}
    val register_comparator_of: string -> local_theory -> local_theory
    val register_foreign_comparator:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_comparator:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm ->
                     thm ->
                       thm ->
                         thm -> bool list -> local_theory -> local_theory
  end
structure Comparator_Generator: COMPARATOR_GENERATOR
### theory "Deriving.Comparator_Generator"
### 0.632s elapsed time, 2.437s cpu time, 0.275s GC time
Loading theory "Deriving.Compare_Generator" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat")
class unique_euclidean_semiring = euclidean_semiring_cancel +
  fixes division_segment :: "'a => 'a"
  assumes
    "euclidean_size_mult":
      "!!a b. euclidean_size (a * b) = euclidean_size a * euclidean_size b"
  assumes "is_unit_division_segment": "!!a. is_unit (division_segment a)"
    and
    "division_segment_mult":
      "!!a b.
          [| a ~= (0::'a); b ~= (0::'a) |]
          ==> division_segment (a * b) =
              division_segment a * division_segment b"
    and
    "division_segment_mod":
      "!!b a.
          [| b ~= (0::'a); ~ b dvd a |]
          ==> division_segment (a mod b) = division_segment b"
  assumes
    "div_bounded":
      "!!b r q.
          [| b ~= (0::'a); division_segment r = division_segment b;
             euclidean_size r < euclidean_size b |]
          ==> (q * b + r) div b = q"
instantiation
  char :: distrib_lattice
  inf_char == inf :: char => char => char
  sup_char == sup :: char => char => char
### theory "HOL-Library.Char_ord"
### 0.087s elapsed time, 0.315s cpu time, 0.075s GC time
Loading theory "Containers.Lexicographic_Order" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order:
  "case_sum length
    (case_sum (%p. length (snd (snd p)))
      (%p. length (snd (snd p)))) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. 0) (%x. Suc 0)) <*mlex*> {}"
signature COMPARE_GENERATOR =
  sig
    val compare_instance:
       Comparator_Generator.comparator_type -> string -> theory -> theory
    val compare_order_instance_via_comparator_of: string -> theory -> theory
    val compare_order_instance_via_compare: string -> theory -> theory
  end
structure Compare_Generator: COMPARE_GENERATOR
### theory "Deriving.Compare_Generator"
### 0.287s elapsed time, 1.130s cpu time, 0.058s GC time
Loading theory "Deriving.Compare_Instances" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order")
### theory "Containers.Lexicographic_Order"
### 0.256s elapsed time, 1.003s cpu time, 0.058s GC time
Loading theory "HOL-Library.Conditional_Parametricity" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code" via "Polynomials.MPoly_Type_Class_FMap" via "Polynomials.Poly_Mapping_Finite_Map" via "HOL-Library.Finite_Map")
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
deriving "compare_order" instance for type "Int.int"
deriving "compare" instance for type "Int.int"
deriving "compare_order" instance for type "Code_Numeral.integer"
deriving "compare" instance for type "Code_Numeral.integer"
deriving "compare_order" instance for type "Nat.nat"
deriving "compare" instance for type "Nat.nat"
deriving "compare_order" instance for type "String.char"
deriving "compare" instance for type "String.char"
deriving "compare" instance for type "Sum_Type.sum"
generating comparator for type "Sum_Type.sum"
deriving "compare" instance for type "List.list"
generating comparator for type "List.list"
Found termination order: "size_list length <*mlex*> {}"
deriving "compare" instance for type "Product_Type.prod"
generating comparator for type "Product_Type.prod"
deriving "compare" instance for type "Option.option"
generating comparator for type "Option.option"
signature CONDITIONAL_PARAMETRICITY =
  sig
    exception WARNING of string
    val default_settings: settings
    val get_parametricity_theorems: Proof.context -> thm list
    val mk_cond_goal: Proof.context -> thm -> term * thm
    val mk_goal: Proof.context -> term -> term
    val mk_param_goal_from_eq_def: Proof.context -> thm -> term
    val parametric_constant:
       settings ->
         Attrib.binding * thm -> Proof.context -> thm * Proof.context
    val prove_find_goal_cond:
       settings -> Proof.context -> thm list -> thm option -> term -> thm
    val prove_goal: settings -> Proof.context -> thm option -> term -> thm
    val quiet_settings: settings
    type settings =
       {suppress_print_theorem: bool,
        suppress_warnings: bool,
        use_equality_heuristic: bool, warnings_as_errors: bool}
    val step_tac: settings -> Proof.context -> thm list -> int -> tactic
  end
structure Conditional_Parametricity: CONDITIONAL_PARAMETRICITY
### theory "HOL-Library.Conditional_Parametricity"
### 0.317s elapsed time, 1.222s cpu time, 0.110s GC time
Loading theory "HOL-Library.Fun_Lexorder" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate" via "Polynomials.More_MPoly_Type" via "Polynomials.MPoly_Type" via "HOL-Library.Poly_Mapping")
### theory "HOL-Number_Theory.Cong"
### 0.845s elapsed time, 3.279s cpu time, 0.327s GC time
Loading theory "HOL-Algebra.Congruence" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice" via "HOL-Algebra.Order")
Found termination order: "{}"
### theory "HOL-Library.Fun_Lexorder"
### 0.050s elapsed time, 0.205s cpu time, 0.000s GC time
Loading theory "HOL-Combinatorics.List_Permutation" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization" via "HOL-Algebra.Divisibility")
Found termination order: "{}"
deriving "compare" instance for type "HOL.bool"
deriving "compare" instance for type "Product_Type.unit"
Found termination order: "length <*mlex*> {}"
deriving "compare_order" instance for type "HOL.bool"
deriving "compare_order" instance for type "Product_Type.unit"
### theory "Deriving.Compare_Instances"
### 0.423s elapsed time, 1.648s cpu time, 0.110s GC time
Loading theory "Jordan_Normal_Form.Missing_Misc" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring")
### theory "HOL-Combinatorics.List_Permutation"
### 0.078s elapsed time, 0.319s cpu time, 0.000s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Found termination order: "{}"
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "Jordan_Normal_Form.Missing_Misc"
### 0.116s elapsed time, 0.443s cpu time, 0.100s GC time
Loading theory "HOL-Library.Groups_Big_Fun" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate" via "Polynomials.More_MPoly_Type" via "Polynomials.MPoly_Type" via "HOL-Library.Poly_Mapping")
### theory "Efficient-Mergesort.Efficient_Sort"
### 1.145s elapsed time, 4.449s cpu time, 0.427s GC time
Loading theory "HOL-Library.IArray" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
locale comm_monoid_fun
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_fun (\<^bold>*) \<^bold>1"
### theory "HOL-Library.Function_Algebras"
### 0.131s elapsed time, 0.506s cpu time, 0.100s GC time
Loading theory "Abstract-Rewriting.Seq" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting")
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
locale infinitely_many
  fixes p :: "nat => bool"
  assumes "infinitely_many p"
### Cannot skip proof of schematic goal statement
Found termination order: "size <*mlex*> {}"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
### Cannot skip proof of schematic goal statement
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Groups_Big_Fun"
### 0.507s elapsed time, 1.822s cpu time, 0.861s GC time
Loading theory "HOL-Library.Ramsey" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences" via "Well_Quasi_Orders.Almost_Full")
locale equivalence
  fixes S :: "('a, 'b) eq_object_scheme"  (structure)
  assumes "equivalence S"
locale partition
  fixes A :: "'a set"
    and B :: "'a set set"
  assumes "Congruence.partition A B"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Abstract-Rewriting.Seq"
### 0.568s elapsed time, 2.074s cpu time, 0.861s GC time
Loading theory "HOL-Library.Mapping" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Factorization.Precomputation" via "HOL-Library.RBT_Mapping")
consts
  list_of :: "'a iarray => 'a list"
consts
  tabulate :: "integer * (integer => 'a) => 'a iarray"
### theory "HOL-Algebra.Congruence"
### 0.962s elapsed time, 3.592s cpu time, 1.099s GC time
Loading theory "HOL-Algebra.Order" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice")
consts
  sub' :: "'a iarray * integer => 'a"
### theory "HOL-Library.IArray"
### 0.761s elapsed time, 2.810s cpu time, 0.999s GC time
Loading theory "Berlekamp_Zassenhaus.Arithmetic_Record_Based" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Matrix_Record_Based")
consts
  choice :: "('a => bool) => ('a * 'a) set => nat => 'a"
### theory "HOL-Library.Ramsey"
### 0.398s elapsed time, 1.560s cpu time, 0.139s GC time
Loading theory "HOL-Library.Poly_Mapping" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate" via "Polynomials.More_MPoly_Type" via "Polynomials.MPoly_Type")
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
instantiation
  mapping :: (type, type) equal
  equal_mapping == equal_class.equal ::
    ('a, 'b) mapping => ('a, 'b) mapping => bool
class zero = type +
  fixes zero :: "'a"
class monoid_add = semigroup_add + zero +
  assumes "add_0_left": "!!a. (0::'a) + a = a"
    and "add_0_right": "!!a. a + (0::'a) = a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
class group_add = cancel_semigroup_add + minus + monoid_add + uminus +
  assumes "left_minus": "!!a. - a + a = (0::'a)"
  assumes "add_uminus_conv_diff": "!!a b. a + - b = a - b"
class mult_zero = times + zero +
  assumes "mult_zero_left": "!!a. (0::'a) * a = (0::'a)"
  assumes "mult_zero_right": "!!a. a * (0::'a) = (0::'a)"
locale combine_mapping_abel_semigroup
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "combine_mapping_abel_semigroup (\<^bold>*)"
locale partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "partial_order L"
instantiation
  poly_mapping :: (type, zero) zero
  zero_poly_mapping == zero_class.zero :: 'a \<Rightarrow>\<^sub>0 'b
instantiation
  poly_mapping :: (type, monoid_add) monoid_add
  plus_poly_mapping == plus ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale weak_partial_order_bottom
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_bottom L"
instantiation
  poly_mapping :: (type, cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_poly_mapping == minus ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
locale weak_partial_order_top
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_top L"
instantiation
  poly_mapping :: (type, ab_group_add) ab_group_add
  uminus_poly_mapping == uminus ::
    ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
locale weak_total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_total_order L"
instantiation
  poly_mapping :: (zero, zero_neq_one) zero_neq_one
  one_poly_mapping == one_class.one :: 'a \<Rightarrow>\<^sub>0 'b
locale total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "total_order L"
### theory "HOL-Algebra.Order"
### 0.919s elapsed time, 3.576s cpu time, 0.550s GC time
Loading theory "HOL-Algebra.Lattice" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice")
instantiation
  poly_mapping :: (monoid_add, semiring_0) semiring_0
  times_poly_mapping == times ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
### theory "HOL-Library.Mapping"
### 1.118s elapsed time, 4.339s cpu time, 0.688s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.ExtrEqs")
instantiation
  poly_mapping :: (linorder, {zero,linorder}) linorder
  less_eq_poly_mapping == less_eq ::
    ('a \<Rightarrow>\<^sub>0 'b) => ('a \<Rightarrow>\<^sub>0 'b) => bool
  less_poly_mapping == less ::
    ('a \<Rightarrow>\<^sub>0 'b) => ('a \<Rightarrow>\<^sub>0 'b) => bool
locale weak_upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_upper_semilattice L"
locale weak_lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lower_semilattice L"
locale weak_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lattice L"
instantiation
  poly_mapping :: (type, zero) size
  size_poly_mapping == size :: ('a \<Rightarrow>\<^sub>0 'b) => nat
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
locale weak_bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_bounded_lattice L"
consts
  snth :: "'a stream => nat => 'a"
locale upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "upper_semilattice L"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
### theory "HOL-Library.Poly_Mapping"
### 1.439s elapsed time, 5.596s cpu time, 0.824s GC time
Loading theory "Polynomials.MPoly_Type" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate" via "Polynomials.More_MPoly_Type")
locale lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lower_semilattice L"
locale Lattice.lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lattice L"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
consts
  cycle :: "'a list => 'a stream"
instantiation
  mpoly :: (zero) zero
  zero_mpoly == zero_class.zero :: 'a mpoly
instantiation
  mpoly :: (monoid_add) monoid_add
  plus_mpoly == plus :: 'a mpoly => 'a mpoly => 'a mpoly
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
instantiation
  mpoly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_mpoly == minus :: 'a mpoly => 'a mpoly => 'a mpoly
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
instantiation
  mpoly :: (ab_group_add) ab_group_add
  uminus_mpoly == uminus :: 'a mpoly => 'a mpoly
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  mpoly :: (zero_neq_one) zero_neq_one
  one_mpoly == one_class.one :: 'a mpoly
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
consts
  flat :: "'a list stream => 'a stream"
locale arith_ops
  fixes ops :: "'i arith_ops_record"  (structure)
### theory "HOL-Algebra.Lattice"
### 0.936s elapsed time, 3.631s cpu time, 0.561s GC time
Loading theory "HOL-Algebra.Complete_Lattice" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group")
instantiation
  mpoly :: (semiring_0) semiring_0
  times_mpoly == times :: 'a mpoly => 'a mpoly => 'a mpoly
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
locale ring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "ring_ops ops R"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
locale idom_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "idom_ops ops R"
### theory "HOL-Library.Stream"
### 1.064s elapsed time, 4.114s cpu time, 0.700s GC time
Loading theory "Containers.Containers_Generator" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum")
locale idom_divide_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "idom_divide_ops ops R"
locale euclidean_semiring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "euclidean_semiring_ops ops R"
locale euclidean_ring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "euclidean_ring_ops ops R"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
### Ambiguous input (line 494 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>div" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale field_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "field_ops ops R"
### Ambiguous input (line 498 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>mod" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Berlekamp_Zassenhaus.Arithmetic_Record_Based"
### 2.174s elapsed time, 8.455s cpu time, 1.250s GC time
Loading theory "Containers.Set_Linorder" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order")
### Ambiguous input (line 502 of "$AFP/Polynomials/MPoly_Type.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 505 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 509 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Polynomials.MPoly_Type"
### 0.625s elapsed time, 2.405s cpu time, 0.409s GC time
Loading theory "Polynomials.More_MPoly_Type" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate")
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
signature CONTAINERS_GENERATOR =
  sig
    val HOLogic_list_conj: term list -> term
    val all_tys: term -> typ list -> term -> term
    val derive_is_c_dots_lemma:
       typ -> string -> thm list -> string -> theory -> theory
    val derive_none:
       string -> sort -> (typ -> term) -> string -> theory -> theory
    val derive_set_map_impl:
       string ->
         sort ->
           (string * term) list -> string -> string -> theory -> theory
    val is_class_instance: theory -> string -> sort -> bool
    val mk_Some: term -> term
    val mk_is_c_dots: typ -> string -> term
    val register_is_c_dots_lemma:
       string -> string -> thm -> theory -> theory
  end
structure Containers_Generator: CONTAINERS_GENERATOR
### theory "Containers.Containers_Generator"
### 0.485s elapsed time, 1.878s cpu time, 0.281s GC time
Loading theory "Containers.Collection_Enum" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
### theory "Polynomials.More_MPoly_Type"
### 0.327s elapsed time, 1.273s cpu time, 0.133s GC time
Loading theory "Containers.Collection_Eq" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set")
class cenum = type +
  fixes
    cEnum ::
      "('a list * (('a => bool) => bool) * (('a => bool) => bool)) option"
  assumes
    "UNIV_cenum":
      "!!enum enum_all enum_ex.
          cEnum = Some (enum, enum_all, enum_ex) ==> UNIV = set enum"
    and
    "cenum_all_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==>
          enum_all P = Ball UNIV P"
    and
    "cenum_ex_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==> enum_ex P = Bex UNIV P"
signature CENUM_GENERATOR =
  sig val derive_no_cenum: string -> theory -> theory end
structure Cenum_Generator: CENUM_GENERATOR
### theory "HOL-Algebra.Complete_Lattice"
### 0.796s elapsed time, 3.095s cpu time, 0.420s GC time
Loading theory "HOL-Algebra.Group" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct")
### Rewrite rule not in simpset:
### Wellfounded.accp all_n_lists_rel (?P1, ?n1) ==>
### all_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_all (%x. all_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
specification
  finite_complement_partition: finite ?A ==> ?A : infinite_complement_partition
  complement_partition: infinite UNIV ==>
(?A : infinite_complement_partition) =
(- ?A ~: infinite_complement_partition)
### Rewrite rule not in simpset:
### Wellfounded.accp ex_n_lists_rel (?P1, ?n1) ==>
### ex_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_ex (%x. ex_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
class ceq = type +
  fixes ceq :: "('a => 'a => bool) option"
  assumes "ceq": "!!eqa. ceq = Some eqa ==> eqa = (=)"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  fun :: (cenum, cenum) cenum
  cEnum_fun == cEnum ::
    (('a => 'b) list *
     ((('a => 'b) => bool) => bool) * ((('a => 'b) => bool) => bool)) option
### Ambiguous input (line 136 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" ys)
###                           ("\<^const>Fun.comp" ("_position" the)
###                             ("_applC" ("_position" map_of)
###                               ("_applC" ("_position" zip)
###                                 ("_cargs" ("_position" enum_a)
###                                   ("_position" ys))))))
###                         ("_applC" ("_position" List.n_lists)
###                           ("_cargs"
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))
###                             ("_position" enum_b)))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" all_n_lists)
###                           ("_cargs" ("_position" enum_all_b)
###                             ("_cargs"
###                               ("_lambda" ("_position" bs)
###                                 ("_applC" ("_position" P)
###                                   ("\<^const>Fun.comp" ("_position" the)
###                                     ("_applC" ("_position" map_of)
### ("_applC" ("_position" zip)
###   ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                               ("_applC" ("_position" length)
###                                 ("_position" enum_a))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" ex_n_lists)
###                             ("_cargs" ("_position" enum_ex_b)
###                               ("_cargs"
###                                 ("_lambda" ("_position" bs)
###                                   ("_applC" ("_position" P)
###                                     ("\<^const>Fun.comp" ("_position" the)
### ("_applC" ("_position" map_of)
###   ("_applC" ("_position" zip)
###     ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                                 ("_applC" ("_position" length)
###                                   ("_position" enum_a))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" ys)
###                       ("\<^const>Fun.comp" ("_position" the)
###                         ("_applC" ("_position" map_of)
###                           ("_applC" ("_position" zip)
###                             ("_cargs" ("_position" enum_a)
###                               ("_position" ys))))))
###                     ("_applC" ("_position" List.n_lists)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" enum_a))
###                         ("_position" enum_b)))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" all_n_lists)
###                       ("_cargs" ("_position" enum_all_b)
###                         ("_cargs"
###                           ("_lambda" ("_position" bs)
###                             ("_applC" ("_position" P)
###                               ("\<^const>Fun.comp" ("_position" the)
###                                 ("_applC" ("_position" map_of)
###                                   ("_applC" ("_position" zip)
###                                     ("_cargs" ("_position" enum_a)
### ("_position" bs)))))))
###                           ("_applC" ("_position" length)
###                             ("_position" enum_a))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" ex_n_lists)
###                         ("_cargs" ("_position" enum_ex_b)
###                           ("_cargs"
###                             ("_lambda" ("_position" bs)
###                               ("_applC" ("_position" P)
###                                 ("\<^const>Fun.comp" ("_position" the)
###                                   ("_applC" ("_position" map_of)
###                                     ("_applC" ("_position" zip)
### ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
signature CEQ_GENERATOR =
  sig
    val ceq_instance_via_eq: string -> theory -> theory
    val ceq_instance_via_equality: string -> theory -> theory
    val derive_no_ceq: string -> theory -> theory
  end
structure Ceq_Generator: CEQ_GENERATOR
deriving "ceq" instance for type "Product_Type.unit" via "="
instantiation
  set :: (cenum) cenum
  cEnum_set == cEnum ::
    ('a set list *
     (('a set => bool) => bool) * (('a set => bool) => bool)) option
derived is_ceq_unit-lemma
### Code generator: dropping subsumed code equation
### CEQ(unit) == Some (=)
deriving "ceq" instance for type "HOL.bool" via "="
derived is_ceq_bool-lemma
deriving "ceq" instance for type "Nat.nat" via "="
instantiation
  unit :: cenum
  cEnum_unit == cEnum ::
    (unit list * ((unit => bool) => bool) * ((unit => bool) => bool)) option
derived is_ceq_nat-lemma
deriving "ceq" instance for type "Int.int" via "="
instantiation
  bool :: cenum
  cEnum_bool == cEnum ::
    (bool list * ((bool => bool) => bool) * ((bool => bool) => bool)) option
derived is_ceq_int-lemma
deriving "ceq" instance for type "Enum.finite_1" via "="
instantiation
  prod :: (cenum, cenum) cenum
  cEnum_prod == cEnum ::
    (('a * 'b) list *
     (('a * 'b => bool) => bool) * (('a * 'b => bool) => bool)) option
derived is_ceq_finite_1-lemma
deriving "ceq" instance for type "Enum.finite_2" via "="
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
### Ambiguous input (line 225 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" List.product)
###                       ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" enum_all_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" enum_all_b)
###                               ("_lambda" ("_position" y)
###                                 ("_applC" ("_position" P)
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" y)))))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" enum_ex_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" enum_ex_b)
###                                 ("_lambda" ("_position" y)
###                                   ("_applC" ("_position" P)
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" y)))))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" List.product)
###                   ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" enum_all_a)
###                       ("_lambda" ("_position" x)
###                         ("_applC" ("_position" enum_all_b)
###                           ("_lambda" ("_position" y)
###                             ("_applC" ("_position" P)
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" y)))))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" enum_ex_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" enum_ex_b)
###                             ("_lambda" ("_position" y)
###                               ("_applC" ("_position" P)
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg"
###                                     ("_position" y)))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
derived is_ceq_finite_2-lemma
deriving "ceq" instance for type "Enum.finite_3" via "="
derived is_ceq_finite_3-lemma
deriving "ceq" instance for type "Enum.finite_4" via "="
derived is_ceq_finite_4-lemma
deriving "ceq" instance for type "Enum.finite_5" via "="
instantiation
  sum :: (cenum, cenum) cenum
  cEnum_sum == cEnum ::
    (('a + 'b) list *
     (('a + 'b => bool) => bool) * (('a + 'b => bool) => bool)) option
derived is_ceq_finite_5-lemma
deriving "ceq" instance for type "Code_Numeral.integer" via "="
### Ambiguous input (line 237 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_position" enum_all_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inl)
###                                   ("_position" x)))))
###                           ("_applC" ("_position" enum_all_b)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inr)
###                                   ("_position" x)))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("\<^const>HOL.disj"
###                             ("_applC" ("_position" enum_ex_a)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inl)
###                                     ("_position" x)))))
###                             ("_applC" ("_position" enum_ex_b)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inr)
###                                     ("_position" x)))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" enum_all_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inl) ("_position" x)))))
###                       ("_applC" ("_position" enum_all_b)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inr)
###                               ("_position" x)))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("\<^const>HOL.disj"
###                         ("_applC" ("_position" enum_ex_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inl)
###                                 ("_position" x)))))
###                         ("_applC" ("_position" enum_ex_b)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inr)
###                                 ("_position" x)))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
derived is_ceq_integer-lemma
deriving "ceq" instance for type "Code_Numeral.natural" via "="
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
derived is_ceq_natural-lemma
deriving "ceq" instance for type "String.char" via "="
derived is_ceq_char-lemma
deriving "ceq" instance for type "String.literal" via "="
instantiation
  option :: (cenum) cenum
  cEnum_option == cEnum ::
    ('a option list *
     (('a option => bool) => bool) * (('a option => bool) => bool)) option
derived is_ceq_literal-lemma
deriving "ceq" instance for type "Sum_Type.sum"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  Enum.finite_1 :: cenum
  cEnum_finite_1 == cEnum ::
    (Enum.finite_1 list *
     ((Enum.finite_1 => bool) => bool) *
     ((Enum.finite_1 => bool) => bool)) option
derived is_ceq_sum-lemma
deriving "ceq" instance for type "Product_Type.prod"
instantiation
  Enum.finite_2 :: cenum
  cEnum_finite_2 == cEnum ::
    (Enum.finite_2 list *
     ((Enum.finite_2 => bool) => bool) *
     ((Enum.finite_2 => bool) => bool)) option
instantiation
  Enum.finite_3 :: cenum
  cEnum_finite_3 == cEnum ::
    (Enum.finite_3 list *
     ((Enum.finite_3 => bool) => bool) *
     ((Enum.finite_3 => bool) => bool)) option
derived is_ceq_prod-lemma
deriving "ceq" instance for type "List.list"
instantiation
  Enum.finite_4 :: cenum
  cEnum_finite_4 == cEnum ::
    (Enum.finite_4 list *
     ((Enum.finite_4 => bool) => bool) *
     ((Enum.finite_4 => bool) => bool)) option
derived is_ceq_list-lemma
instantiation
  Enum.finite_5 :: cenum
  cEnum_finite_5 == cEnum ::
    (Enum.finite_5 list *
     ((Enum.finite_5 => bool) => bool) *
     ((Enum.finite_5 => bool) => bool)) option
deriving "ceq" instance for type "Option.option"
instantiation
  char :: cenum
  cEnum_char == cEnum ::
    (char list * ((char => bool) => bool) * ((char => bool) => bool)) option
derived is_ceq_option-lemma
use None as trivial implementation of ceq for type fun
use None as trivial implementation of cenum for type list
registered fun in class ceq
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
registered list in class cenum
use None as trivial implementation of cenum for type nat
instantiation
  set :: (ceq) ceq
  ceq_set == ceq :: ('a set => 'a set => bool) option
registered nat in class cenum
use None as trivial implementation of cenum for type int
registered int in class cenum
use None as trivial implementation of cenum for type integer
registered integer in class cenum
use None as trivial implementation of cenum for type natural
registered natural in class cenum
use None as trivial implementation of cenum for type literal
registered literal in class cenum
### theory "Containers.Collection_Enum"
### 0.675s elapsed time, 2.615s cpu time, 0.335s GC time
Loading theory "HOL-Library.Type_Length" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  Predicate.pred :: (ceq) ceq
  ceq_pred == ceq :: ('a Predicate.pred => 'a Predicate.pred => bool) option
### theory "Containers.Collection_Eq"
### 0.622s elapsed time, 2.399s cpu time, 0.335s GC time
Loading theory "Containers.DList_Set" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
overloading
  nat_pow \<equiv> pow :: ('a, 'b) monoid_scheme => 'a => nat => 'a
class len0 = type +
  fixes len_of :: "'a itself => nat"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
overloading
  int_pow \<equiv> pow :: ('a, 'b) monoid_scheme => 'a => int => 'a
class len = len0 +
  assumes "len_gt_0": "0 < LENGTH('a)"
instantiation
  0 :: len0
  1 :: len0
  len_of_num0 == len_of :: 0 itself => nat
  len_of_num1 == len_of :: 1 itself => nat
instantiation
  bit0 :: (len0) len0
  bit1 :: (len0) len0
  len_of_bit0 == len_of :: 'a bit0 itself => nat
  len_of_bit1 == len_of :: 'a bit1 itself => nat
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  Enum.finite_1 :: len
  len_of_finite_1 == len_of :: Enum.finite_1 itself => nat
instantiation
  Enum.finite_2 :: len
  len_of_finite_2 == len_of :: Enum.finite_2 itself => nat
instantiation
  Enum.finite_3 :: len
  len_of_finite_3 == len_of :: Enum.finite_3 itself => nat
locale equal_base
  fixes equal :: "'a => 'a => bool"
consts
  list_member :: "'a list => 'a => bool"
consts
  list_distinct :: "'a list => bool"
locale submonoid
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "submonoid H G"
consts
  list_remove1 :: "'a => 'a list => 'a list"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  list_remdups :: "'a list => 'a list"
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
locale subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "subgroup H G"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "HOL-Library.Type_Length"
### 0.655s elapsed time, 2.514s cpu time, 0.351s GC time
Loading theory "HOL-Library.Word" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
### theory "Containers.DList_Set"
### 0.775s elapsed time, 2.964s cpu time, 0.468s GC time
Loading theory "HOL-Library.RBT_Impl" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.RBT_ext")
instantiation
  word :: (len) comm_ring_1
  uminus_word == uminus :: 'a word => 'a word
  one_word == one_class.one :: 'a word
  times_word == times :: 'a word => 'a word => 'a word
  zero_word == zero_class.zero :: 'a word
  minus_word == minus :: 'a word => 'a word => 'a word
  plus_word == plus :: 'a word => 'a word => 'a word
class proper_interval = proper_intrvl +
  assumes
    "proper_interval_simps": "proper_interval None None = True"
      "!!y. proper_interval None (Some y) = (EX z. z < y)"
      "!!x. proper_interval (Some x) None = (EX z. x < z)"
      "!!x y. proper_interval (Some x) (Some y) = (EX z>x. z < y)"
locale group_hom
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and H :: "('c, 'd) monoid_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "group_hom G H h"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
signature WORD_LIB =
  sig
    val dest_binT: typ -> int
    val dest_wordT: typ -> int
    val is_wordT: typ -> bool
    val mk_wordT: int -> typ
  end
structure Word_Lib: WORD_LIB
instantiation
  word :: (len) equal
  equal_word == equal_class.equal :: 'a word => 'a word => bool
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale comm_group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_group G"
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
### theory "HOL-Algebra.Group"
### 2.498s elapsed time, 9.483s cpu time, 3.072s GC time
Loading theory "HOL-Algebra.Coset" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization" via "HOL-Algebra.Divisibility")
locale normal
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "normal H G"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
instantiation
  word :: (len) linorder
  less_eq_word == less_eq :: 'a word => 'a word => bool
  less_word == less :: 'a word => 'a word => bool
instantiation
  word :: (len) enum
  enum_word == enum_class.enum :: 'a word list
  enum_all_word == enum_class.enum_all :: ('a word => bool) => bool
  enum_ex_word == enum_class.enum_ex :: ('a word => bool) => bool
instantiation
  word :: (len) semiring_modulo
  modulo_word == modulo :: 'a word => 'a word => 'a word
  divide_word == divide :: 'a word => 'a word => 'a word
instantiation
  word :: (len) semiring_bits
  bit_word == bit :: 'a word => nat => bool
consts
  entries :: "('a, 'b) rbt => ('a * 'b) list"
instantiation
  word :: (len) ring_bit_operations
  not_word == not :: 'a word => 'a word
  and_word == and :: 'a word => 'a word => 'a word
  or_word == or :: 'a word => 'a word => 'a word
  xor_word == xor :: 'a word => 'a word => 'a word
  mask_word == mask :: nat => 'a word
  set_bit_word == set_bit :: nat => 'a word => 'a word
  unset_bit_word == unset_bit :: nat => 'a word => 'a word
  flip_bit_word == flip_bit :: nat => 'a word => 'a word
  push_bit_word == push_bit :: nat => 'a word => 'a word
  drop_bit_word == drop_bit :: nat => 'a word => 'a word
  take_bit_word == take_bit :: nat => 'a word => 'a word
### Ambiguous input (line 611 of "~~/src/HOL/Algebra/Coset.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###       ("_position" H))
###     ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" carrier) ("_position" G)))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" y)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>Set.member"
###             ("\<^const>Group.monoid.mult_indexed"
###               ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                 ("_position" x))
###               ("_index" ("_position" G)) ("_position" y))
###             ("_position" H)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###     ("\<^const>HOL.eq" ("_position" H)
###       ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" x)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" y)
###               ("_applC" ("_position" carrier) ("_position" G)))
###             ("\<^const>Set.member"
###               ("\<^const>Group.monoid.mult_indexed"
###                 ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                   ("_position" x))
###                 ("_index" ("_position" G)) ("_position" y))
###               ("_position" H))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
consts
  rbt_sorted :: "('a, 'b) rbt => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  rbt_lookup :: "('a, 'b) rbt => 'a => 'b option"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
consts
  color_of :: "('a, 'b) rbt => color"
consts
  bheight :: "('a, 'b) rbt => nat"
consts
  inv1 :: "('a, 'b) rbt => bool"
consts
  inv1l :: "('a, 'b) rbt => bool"
consts
  inv2 :: "('a, 'b) rbt => bool"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
### theory "HOL-Algebra.Coset"
### 1.398s elapsed time, 5.319s cpu time, 0.617s GC time
Loading theory "HOL-Algebra.FiniteProduct" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring")
Proofs for inductive predicate(s) "foldSetDp"
  Proving monotonicity ...
locale LCD
  fixes B :: "'b set"
    and D :: "'a set"
    and f :: "'b => 'a => 'a"  (infixl \<open>\<cdot>\<close> 70)
  assumes "LCD B D (\<cdot>)"
locale ACeD
  fixes D :: "'a set"
    and f :: "'a => 'a => 'a"  (infixl \<open>\<cdot>\<close> 70)
    and e :: "'a"
  assumes "ACeD D (\<cdot>) e"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
### theory "HOL-Algebra.FiniteProduct"
### 0.555s elapsed time, 2.076s cpu time, 0.309s GC time
Loading theory "HOL-Algebra.Ring" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring")
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
### Cannot skip proof of schematic goal statement
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Cannot skip proof of schematic goal statement
Found termination order: "{}"
class unique_euclidean_semiring_numeral =
  unique_euclidean_semiring_with_nat + linordered_semidom +
  fixes divmod :: "num => num => 'a * 'a"
    and divmod_step :: "num => 'a * 'a => 'a * 'a"
  assumes
    "div_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a div b = (0::'a)"
    and "mod_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a mod b = a"
    and
    "div_positive": "!!b a. [| (0::'a) < b; b <= a |] ==> (0::'a) < a div b"
    and "mod_less_eq_dividend": "!!a b. (0::'a) <= a ==> a mod b <= a"
    and "pos_mod_bound": "!!b a. (0::'a) < b ==> a mod b < b"
    and "pos_mod_sign": "!!b a. (0::'a) < b ==> (0::'a) <= a mod b"
    and
    "mod_mult2_eq":
      "!!c a b.
          (0::'a) <= c ==> a mod (b * c) = b * (a div b mod c) + a mod b"
    and
    "div_mult2_eq":
      "!!c a b. (0::'a) <= c ==> a div (b * c) = a div b div c"
  assumes "discrete": "!!a b. (a < b) = (a + (1::'a) <= b)"
  assumes
    "divmod_def":
      "!!m n.
          divmod m n = (numeral m div numeral n, numeral m mod numeral n)"
    and
    "divmod_step_def":
      "!!l qr.
          divmod_step l qr =
          (let (q, r) = qr
           in if numeral l <= r then ((2::'a) * q + (1::'a), r - numeral l)
              else ((2::'a) * q, r))"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Cannot skip proof of schematic goal statement
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
### Cannot skip proof of schematic goal statement
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### ML warning (line 44 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 47 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Matches are not exhaustive.
signature RINGSIMP =
  sig
    val add_struct: string * term list -> attribute
    val algebra_tac: Proof.context -> int -> tactic
    val del_struct: string * term list -> attribute
    val print_structures: Proof.context -> unit
  end
structure Ringsimp: RINGSIMP
Found termination order:
  "(%p. length (snd (snd (snd p)))) <*mlex*>
   (%p. length (fst (snd (snd p)))) <*mlex*> {}"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
instantiation
  word :: (len) size
  size_word == size :: 'a word => nat
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Min (\<le>s) (set (?x # ?xs)) == fold signed.min ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Max (\<le>s) (set (?x # ?xs)) == fold signed.max ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [?x] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted (?x # ?y # ?zs) == ?x \<le>s ?y & signed.sorted (?y # ?zs)
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted_list_of_set (set ?xs) == signed.sort (remdups ?xs)
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
locale ring_hom_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "ring_hom_cring R S h"
instantiation
  unit :: proper_interval
  proper_interval_unit == proper_interval ::
    unit option => unit option => bool
Found termination order: "{}"
instantiation
  bool :: proper_interval
  proper_interval_bool == proper_interval ::
    bool option => bool option => bool
val unat_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?v1 ... ?w1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.unat_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val unat_arith_tacs = fn: Proof.context -> tactic list
val unat_arith_tac = fn: Proof.context -> int -> tactic
Found termination order: "{}"
### theory "HOL-Algebra.Ring"
### 3.918s elapsed time, 14.599s cpu time, 4.119s GC time
Loading theory "HOL-Algebra.AbelCoset" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.RingHom" via "HOL-Algebra.Ideal")
instantiation
  nat :: proper_interval
  proper_interval_nat == proper_interval :: nat option => nat option => bool
val uint_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?a1 ... ?b1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.uint_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val uint_arith_tacs = fn: Proof.context -> tactic list
val uint_arith_tac = fn: Proof.context -> int -> tactic
Found termination order: "{}"
instantiation
  int :: proper_interval
  proper_interval_int == proper_interval :: int option => int option => bool
Found termination order: "{}"
instantiation
  integer :: proper_interval
  proper_interval_integer == proper_interval ::
    integer option => integer option => bool
instantiation
  natural :: proper_interval
  proper_interval_natural == proper_interval ::
    natural option => natural option => bool
instantiation
  char :: proper_interval
  proper_interval_char == proper_interval ::
    char option => char option => bool
Found termination order: "{}"
instantiation
  Enum.finite_1 :: proper_interval
  proper_interval_finite_1 == proper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: proper_interval
  proper_interval_finite_2 == proper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
Found termination order: "{}"
instantiation
  Enum.finite_3 :: proper_interval
  proper_interval_finite_3 == proper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
Found termination order: "{}"
locale abelian_group_hom
  fixes G :: "('a, 'b) ring_scheme"  (structure)
    and H :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "abelian_group_hom G H h"
locale word_rotate
### Cannot skip proof of schematic goal statement
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
signature SMT_WORD =
  sig
    val add_word_shift': term * string -> Context.generic -> Context.generic
  end
structure SMT_Word: SMT_WORD
### theory "HOL-Library.Word"
### 8.079s elapsed time, 30.305s cpu time, 7.875s GC time
Loading theory "HOL-Algebra.Module" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
locale additive_subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) ring_scheme"  (structure)
  assumes "additive_subgroup H G"
locale abelian_subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_subgroup H G"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Containers.Set_Linorder"
### 10.228s elapsed time, 38.524s cpu time, 9.004s GC time
Loading theory "HOL-Algebra.Generated_Groups" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
Proofs for inductive predicate(s) "generatep"
  Proving monotonicity ...
locale algebra
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "algebra R M"
### theory "HOL-Algebra.Generated_Groups"
### 0.775s elapsed time, 2.885s cpu time, 0.372s GC time
Loading theory "HOL-Algebra.Divisibility" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization")
locale submodule
  fixes H :: "'c set"
    and R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "submodule H R M"
locale monoid_cancel
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "monoid_cancel G"
locale comm_monoid_cancel
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_monoid_cancel G"
### theory "HOL-Algebra.Module"
### 1.768s elapsed time, 6.589s cpu time, 0.886s GC time
Loading theory "Jordan_Normal_Form.Missing_Ring" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
locale factorial_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "factorial_monoid G"
### theory "HOL-Algebra.AbelCoset"
### 3.204s elapsed time, 11.947s cpu time, 1.521s GC time
Loading theory "HOL-Algebra.Ideal" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.RingHom")
locale ideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ideal I R"
locale principalideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "principalideal I R"
class ordered_semiring_strict = comm_monoid_add +
  ordered_cancel_ab_semigroup_add + semiring +
  assumes
    "mult_strict_left_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> c * a < c * b"
  assumes
    "mult_strict_right_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> a * c < b * c"
locale maximalideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "maximalideal I R"
locale primeideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "primeideal I R"
locale gcd_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "gcd_condition_monoid G"
locale primeness_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "primeness_condition_monoid G"
locale divisor_chain_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "divisor_chain_condition_monoid G"
### theory "HOL-Algebra.Divisibility"
### 2.666s elapsed time, 9.617s cpu time, 1.576s GC time
Loading theory "HOL-Algebra.Elementary_Groups" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale group_disjoint_sum
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and A :: "'a set"
    and B :: "'a set"
  assumes "group_disjoint_sum G A B"
class ordered_idom = ordered_semiring_strict + idom +
  assumes "zero_less_one": "(0::'a) < (1::'a)"
### theory "HOL-Algebra.Elementary_Groups"
### 1.651s elapsed time, 5.956s cpu time, 3.968s GC time
Loading theory "Containers.Collection_Order" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
Found termination order: "{}"
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 Empty == Branch B Empty ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty ==
### Branch B (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1) ==
### Branch B Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1)
### theory "HOL-Algebra.Ideal"
### 3.427s elapsed time, 12.352s cpu time, 4.961s GC time
Loading theory "HOL-Algebra.RingHom" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale ring_hom_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "ring_hom_ring R S h"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
consts
  paint :: "color => ('a, 'b) rbt => ('a, 'b) rbt"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
signature CCOMPARE_GENERATOR =
  sig
    val ccompare_instance_via_comparator: string -> theory -> theory
    val ccompare_instance_via_compare: string -> theory -> theory
    val derive_no_ccompare: string -> theory -> theory
  end
structure CCompare_Generator: CCOMPARE_GENERATOR
deriving "compare_order" instance for type "Enum.finite_1"
deriving "compare" instance for type "Enum.finite_1"
deriving "compare_order" instance for type "Enum.finite_2"
deriving "compare" instance for type "Enum.finite_2"
deriving "compare_order" instance for type "Enum.finite_3"
deriving "compare" instance for type "Enum.finite_3"
deriving "compare_order" instance for type "Code_Numeral.natural"
deriving "compare" instance for type "Code_Numeral.natural"
deriving "compare_order" instance for type "String.literal"
deriving "compare" instance for type "String.literal"
deriving "ccompare_order" instance for type "Product_Type.unit" via compare_order
derived is_ccompare_unit-lemma
deriving "ccompare_order" instance for type "HOL.bool" via compare_order
derived is_ccompare_bool-lemma
deriving "ccompare_order" instance for type "Nat.nat" via compare_order
derived is_ccompare_nat-lemma
deriving "ccompare_order" instance for type "Int.int" via compare_order
derived is_ccompare_int-lemma
deriving "ccompare_order" instance for type "Enum.finite_1" via compare_order
derived is_ccompare_finite_1-lemma
deriving "ccompare_order" instance for type "Enum.finite_2" via compare_order
derived is_ccompare_finite_2-lemma
deriving "ccompare_order" instance for type "Enum.finite_3" via compare_order
derived is_ccompare_finite_3-lemma
deriving "ccompare_order" instance for type "Code_Numeral.integer" via compare_order
derived is_ccompare_integer-lemma
deriving "ccompare_order" instance for type "Code_Numeral.natural" via compare_order
derived is_ccompare_natural-lemma
deriving "ccompare_order" instance for type "String.char" via compare_order
derived is_ccompare_char-lemma
deriving "ccompare_order" instance for type "String.literal" via compare_order
derived is_ccompare_literal-lemma
use None as trivial implementation of ccompare for type finite_4
registered finite_4 in class ccompare
use None as trivial implementation of ccompare for type finite_5
registered finite_5 in class ccompare
deriving "ccompare" instance for type "Sum_Type.sum"
derived is_ccompare_sum-lemma
deriving "ccompare" instance for type "List.list"
derived is_ccompare_list-lemma
deriving "ccompare" instance for type "Option.option"
derived is_ccompare_option-lemma
deriving "ccompare" instance for type "Product_Type.prod"
derived is_ccompare_prod-lemma
use None as trivial implementation of ccompare for type fun
registered fun in class ccompare
instantiation
  set :: (ccompare) ccompare
  ccompare_set == ccompare :: ('a set => 'a set => order) option
use None as trivial implementation of ccompare for type pred
registered pred in class ccompare
class cproper_interval = ccompare +
  fixes cproper_interval :: "'a option => 'a option => bool"
  assumes
    "cproper_interval":
      "[| ID ccompare ~= None; finite UNIV |]
       ==> class.proper_interval cless cproper_interval"
instantiation
  unit :: cproper_interval
  cproper_interval_unit == cproper_interval ::
    unit option => unit option => bool
instantiation
  bool :: cproper_interval
  cproper_interval_bool == cproper_interval ::
    bool option => bool option => bool
instantiation
  nat :: cproper_interval
  cproper_interval_nat == cproper_interval ::
    nat option => nat option => bool
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
instantiation
  int :: cproper_interval
  cproper_interval_int == cproper_interval ::
    int option => int option => bool
instantiation
  integer :: cproper_interval
  cproper_interval_integer == cproper_interval ::
    integer option => integer option => bool
instantiation
  natural :: cproper_interval
  cproper_interval_natural == cproper_interval ::
    natural option => natural option => bool
instantiation
  char :: cproper_interval
  cproper_interval_char == cproper_interval ::
    char option => char option => bool
instantiation
  Enum.finite_1 :: cproper_interval
  cproper_interval_finite_1 == cproper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: cproper_interval
  cproper_interval_finite_2 == cproper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
instantiation
  Enum.finite_3 :: cproper_interval
  cproper_interval_finite_3 == cproper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
instantiation
  Enum.finite_4 :: cproper_interval
  cproper_interval_finite_4 == cproper_interval ::
    Enum.finite_4 option => Enum.finite_4 option => bool
instantiation
  Enum.finite_5 :: cproper_interval
  cproper_interval_finite_5 == cproper_interval ::
    Enum.finite_5 option => Enum.finite_5 option => bool
locale csemiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "csemiring R"
instantiation
  sum :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_sum == cproper_interval ::
    ('a + 'b) option => ('a + 'b) option => bool
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Algebra.RingHom"
### 1.037s elapsed time, 3.886s cpu time, 0.484s GC time
Loading theory "HOL-Algebra.UnivPoly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
Found termination order: "{}"
instantiation
  prod :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_prod == cproper_interval ::
    ('a * 'b) option => ('a * 'b) option => bool
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale bound
  fixes z :: "'a"
    and n :: "nat"
    and f :: "nat => 'a"
  assumes "bound z n f"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
### theory "Jordan_Normal_Form.Missing_Ring"
### 5.368s elapsed time, 19.581s cpu time, 5.907s GC time
Loading theory "Word_Lib.Bit_Comprehension" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "{}"
instantiation
  list :: (ccompare) cproper_interval
  cproper_interval_list == cproper_interval ::
    'a list option => 'a list option => bool
instantiation
  String.literal :: cproper_interval
  cproper_interval_literal == cproper_interval ::
    String.literal option => String.literal option => bool
instantiation
  option :: (cproper_interval) cproper_interval
  cproper_interval_option == cproper_interval ::
    'a option option => 'a option option => bool
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "{}"
instantiation
  set :: (cproper_interval) cproper_interval
  cproper_interval_set == cproper_interval ::
    'a set option => 'a set option => bool
### Not an equation, in theorem:
### cproper_interval_set_dom (None, None) ==> cproper_interval None None == True
### Not an equation, in theorem:
### cproper_interval_set_dom (None, Some ?B) ==>
### cproper_interval None (Some ?B) == ?B ~= {}
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, None) ==>
### cproper_interval (Some ?A) None == ?A ~= UNIV
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, Some ?B) ==>
### cproper_interval (Some ?A) (Some ?B) ==
### finite UNIV & (EX C. cless ?A C & cless C ?B)
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
Found termination order: "{}"
instantiation
  fun :: (type, type) cproper_interval
  cproper_interval_fun == cproper_interval ::
    ('a => 'b) option => ('a => 'b) option => bool
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  defines "P == UP R"
### theory "Containers.Collection_Order"
### 1.985s elapsed time, 7.419s cpu time, 0.936s GC time
Loading theory "Word_Lib.More_Divides" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit" via "Word_Lib.More_Word")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
### theory "Word_Lib.More_Divides"
### 0.197s elapsed time, 0.711s cpu time, 0.112s GC time
Loading theory "HOL-Library.Signed_Division" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Word_Lib.Signed_Division_Word")
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
class signed_division = type +
  fixes signed_divide :: "'a => 'a => 'a"
    and signed_modulo :: "'a => 'a => 'a"
instantiation
  int :: signed_division
  signed_divide_int == signed_divide :: int => int => int
  signed_modulo_int == signed_modulo :: int => int => int
### theory "HOL-Library.Signed_Division"
### 0.156s elapsed time, 0.572s cpu time, 0.081s GC time
Loading theory "Word_Lib.Signed_Division_Word" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
Found termination order: "{}"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  defines "P == UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
instantiation
  word :: (len) signed_division
  signed_divide_word == signed_divide :: 'a word => 'a word => 'a word
  signed_modulo_word == signed_modulo :: 'a word => 'a word => 'a word
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
class bit_comprehension = ring_bit_operations +
  fixes set_bits :: "(nat => bool) => 'a"
  assumes "set_bits_bit_eq": "!!a. set_bits (bit a) = a"
instantiation
  int :: bit_comprehension
  set_bits_int == set_bits :: (nat => bool) => int
instantiation
  word :: (len) bit_comprehension
  set_bits_word == set_bits :: (nat => bool) => 'a word
Proofs for inductive predicate(s) "wf_set_bits_int"
  Proving monotonicity ...
### theory "Word_Lib.Signed_Division_Word"
### 0.556s elapsed time, 1.997s cpu time, 0.349s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "Word_Lib.Bit_Comprehension"
### 1.409s elapsed time, 5.098s cpu time, 0.852s GC time
Loading theory "HOL-Library.While_Combinator" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method" via "Regular-Sets.Equivalence_Checking")
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "HOL-Library.While_Combinator"
### 12.738s elapsed time, 41.805s cpu time, 40.020s GC time
Loading theory "HOL-Types_To_Sets.Types_To_Sets" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field")
signature LOCAL_TYPEDEF =
  sig
    val cancel_type_definition: thm -> thm
    val cancel_type_definition_attr: attribute
  end
structure Local_Typedef: LOCAL_TYPEDEF
signature UNOVERLOADING =
  sig
    val unoverload: cterm -> thm -> thm
    val unoverload_attr: cterm -> attribute
  end
structure Unoverloading: UNOVERLOADING
consts
  left :: "'a tree => 'a tree"
signature INTERNALIZE_SORT =
  sig
    val internalize_sort: ctyp -> thm -> typ * thm
    val internalize_sort_attr: typ -> attribute
  end
structure Internalize_Sort: INTERNALIZE_SORT
consts
  right :: "'a tree => 'a tree"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
### ML warning (line 41 of "~~/src/HOL/Types_To_Sets/unoverload_type.ML"):
### Matches are not exhaustive.
signature UNOVERLOAD_TYPE =
  sig
    val unoverload_type: Context.generic -> indexname list -> thm -> thm
    val unoverload_type_attr: indexname list -> attribute
  end
structure Unoverload_Type: UNOVERLOAD_TYPE
Found termination order: "size <*mlex*> {}"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order: "size <*mlex*> {}"
### ML warning (line 36 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 36 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Value identifier (ctxt') has not been referenced.
### ML warning (line 40 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 66 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
structure Unoverload_Def:
  sig
    val unoverload_def: binding option -> thm -> theory -> theory
    val unoverload_def1_cmd:
       binding option * (Facts.ref * Token.src list) -> theory -> theory
  end
### theory "HOL-Types_To_Sets.Types_To_Sets"
### 0.286s elapsed time, 1.105s cpu time, 0.091s GC time
Loading theory "Deriving.Compare_Rat" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
deriving "compare_order" instance for type "Rat.rat"
deriving "compare" instance for type "Rat.rat"
### theory "Deriving.Compare_Rat"
### 0.274s elapsed time, 1.074s cpu time, 0.083s GC time
Loading theory "HOL-Library.FSet" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code" via "Polynomials.MPoly_Type_Class_FMap" via "Polynomials.Poly_Mapping_Finite_Map" via "HOL-Library.Finite_Map")
Found termination order: "size <*mlex*> {}"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (finite) finite
instantiation
  fset :: (type) {minus,bounded_lattice_bot,distrib_lattice}
  inf_fset == inf :: 'a fset => 'a fset => 'a fset
  bot_fset == bot :: 'a fset
  sup_fset == sup :: 'a fset => 'a fset => 'a fset
  less_eq_fset == less_eq :: 'a fset => 'a fset => bool
  less_fset == less :: 'a fset => 'a fset => bool
  minus_fset == minus :: 'a fset => 'a fset => 'a fset
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (equal) equal
  equal_fset == equal_class.equal :: 'a fset => 'a fset => bool
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (type) conditionally_complete_lattice
  Inf_fset == Inf :: 'a fset set => 'a fset
  Sup_fset == Sup :: 'a fset set => 'a fset
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (finite) complete_lattice
  top_fset == top :: 'a fset
instantiation
  fset :: (finite) complete_boolean_algebra
  uminus_fset == uminus :: 'a fset => 'a fset
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
Found termination order: "size <*mlex*> {}"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
### theory "HOL-Library.Tree"
### 14.409s elapsed time, 48.282s cpu time, 40.701s GC time
Loading theory "Draft.Templates" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.103s elapsed time, 0.386s cpu time, 0.111s GC time
Loading theory "Deriving.Compare_Real" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
deriving "compare_order" instance for type "Real.real"
deriving "compare" instance for type "Real.real"
### theory "Deriving.Compare_Real"
### 0.290s elapsed time, 1.138s cpu time, 0.063s GC time
Loading theory "Polynomials.More_Modules" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class")
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
### theory "Polynomials.More_Modules"
### 0.205s elapsed time, 0.799s cpu time, 0.090s GC time
Loading theory "Cauchy.CauchysMeanTheorem" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Explicit_Roots" via "Sqrt_Babylonian.Sqrt_Babylonian" via "Sqrt_Babylonian.NthRoot_Impl")
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
locale comp_fun_idem
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_idem f"
locale comm_monoid_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_fset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### Cannot skip proof of schematic goal statement
locale semilattice_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "semilattice_fset (\<^bold>*)"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### theory "Cauchy.CauchysMeanTheorem"
### 0.318s elapsed time, 1.219s cpu time, 0.230s GC time
Loading theory "Polynomial_Interpolation.Improved_Code_Equations" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Interpolation.Polynomial_Interpolation")
locale semilattice_order_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes "semilattice_order_fset (\<^bold>*) (\<^bold>\<le>) (\<^bold><)"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  defines "P == UP R"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Code generator: dropping subsumed code equation
### divmod_integer ?k ?l ==
### if ?k = 0 then (0, 0)
### else if 0 < ?l
###      then if 0 < ?k then Code_Numeral.divmod_abs ?k ?l
###           else case Code_Numeral.divmod_abs ?k ?l of
###                (r, s) => if s = 0 then (- r, 0) else (- r - 1, ?l - s)
###      else if ?l = 0 then (0, ?k)
###           else apsnd uminus
###                 (if ?k < 0 then Code_Numeral.divmod_abs ?k ?l
###                  else case Code_Numeral.divmod_abs ?k ?l of
###                       (r, s) =>
###                         if s = 0 then (- r, 0) else (- r - 1, - ?l - s))
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### let k = integer_of_nat ?m; l = integer_of_nat ?n
### in map_prod nat_of_integer nat_of_integer
###     (if k = 0 then (0, 0)
###      else if l = 0 then (0, k) else Code_Numeral.divmod_abs k l)
### Code generator: dropping subsumed code equation
### ?n choose ?k ==
### if ?n < ?k then 0
### else if ?n < 2 * ?k then ?n choose (?n - ?k)
###      else fold_atLeastAtMost_nat (*) (?n - ?k + 1) ?n 1 div fact ?k
### theory "Polynomial_Interpolation.Improved_Code_Equations"
### 0.346s elapsed time, 1.324s cpu time, 0.182s GC time
Loading theory "Polynomial_Interpolation.Neville_Aitken_Interpolation" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Interpolation.Polynomial_Interpolation")
instantiation
  fset :: (type) size
  size_fset == size :: 'a fset => nat
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P == UP R"
Found termination order: "size_list (%p. size (snd p)) <*mlex*> {}"
instantiation
  fset :: (exhaustive) exhaustive
  exhaustive_fset == exhaustive_class.exhaustive ::
    ('a fset => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  fset :: (full_exhaustive) full_exhaustive
  full_exhaustive_fset == full_exhaustive_class.full_exhaustive ::
    ('a fset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
instantiation
  fset :: (random) random
  random_fset == random_class.random ::
    natural
    => natural * natural => ('a fset * (unit => term)) * natural * natural
### theory "Polynomial_Interpolation.Neville_Aitken_Interpolation"
### 0.669s elapsed time, 2.565s cpu time, 0.320s GC time
Loading theory "Polynomials.MPoly_Type_Univariate" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection")
### Additional type variable(s) in specification of "random_aux_fset_rel": 'a
### Additional type variable(s) in specification of "random_aux_fset_dom": 'a
Found termination order: "(%p. nat_of_natural (fst p)) <*mlex*> {}"
### theory "HOL-Library.FSet"
### 3.184s elapsed time, 12.272s cpu time, 1.599s GC time
Loading theory "HOL-Library.Finite_Map" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code" via "Polynomials.MPoly_Type_Class_FMap" via "Polynomials.Poly_Mapping_Finite_Map")
locale UP_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
    and P :: "('a, nat => 'a) up_ring"  (structure)
    and s :: "'c"
    and Eval :: "(nat => 'a) => 'c"
  assumes "UP_univ_prop R S h s"
  defines "P == UP R"
    and "Eval == eval R S h s"
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P == UP R"
theorem
  map_add_transfer:
    rel_fun (rel_fun ?A1.0 (rel_option ?A2.0))
     (rel_fun (rel_fun ?A1.0 (rel_option ?A2.0))
       (rel_fun ?A1.0 (rel_option ?A2.0)))
     (++) (++)
### theory "Polynomials.MPoly_Type_Univariate"
### 0.665s elapsed time, 2.549s cpu time, 0.320s GC time
Loading theory "Berlekamp_Zassenhaus.Code_Abort_Gcd" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus")
theorem
  map_of_transfer:
    bi_unique ?A1.0 ==>
    rel_fun (list_all2 (rel_prod ?A1.0 ?A2.0))
     (rel_fun ?A1.0 (rel_option ?A2.0)) map_of map_of
theorem
  dom_transfer:
    bi_total ?A1.0 ==>
    ((?A1.0 ===> rel_option ?A2.0) ===> rel_set ?A1.0) dom dom
### Code generator: dropping subsumed code equation
### Gcd (set ?xs) == fold gcd ?xs 0
### Code generator: dropping subsumed code equation
### Lcm (set ?xs) == fold lcm ?xs 1
### Code generator: dropping subsumed code equation
### Gcd (set ?xs) == fold gcd ?xs 0
### Code generator: dropping subsumed code equation
### Lcm (set ?xs) == fold lcm ?xs 1
### Code generator: dropping subsumed code equation
### Gcd (set ?xs) == fold gcd ?xs 0
### Code generator: dropping subsumed code equation
### Lcm (set ?xs) == fold lcm ?xs 1
### theory "Berlekamp_Zassenhaus.Code_Abort_Gcd"
### 0.068s elapsed time, 0.273s cpu time, 0.000s GC time
Loading theory "Symmetric_Polynomials.Vieta" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Hermite_Lindemann.More_Multivariate_Polynomial_HLW" via "Power_Sum_Polynomials.Power_Sum_Polynomials_Library" via "Symmetric_Polynomials.Symmetric_Polynomials")
theorem
  map_upd_transfer:
    bi_unique ?A1.0 ==>
    (?A1.0 ===>
     ?A2.0 ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_upd map_upd
theorem
  map_filter_transfer:
    ((?A1.0 ===> (=)) ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_filter map_filter
theorem
  map_drop_transfer:
    bi_unique ?A1.0 ==>
    (?A1.0 ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_drop map_drop
theorem
  map_drop_set_transfer:
    bi_unique ?A1.0 ==>
    (rel_set ?A1.0 ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_drop_set map_drop_set
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
theorem
  map_restrict_set_transfer:
    bi_unique ?A1.0 ==>
    (rel_set ?A1.0 ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_restrict_set map_restrict_set
theorem
  map_pred_transfer:
    bi_total ?A1.0 ==>
    ((?A1.0 ===> ?A2.0 ===> (=)) ===>
     (?A1.0 ===> rel_option ?A2.0) ===> (=))
     map_pred map_pred
theorem
  map_comp_transfer:
    ((?A3.0 ===> rel_option ?A2.0) ===>
     (?A1.0 ===> rel_option ?A3.0) ===> ?A1.0 ===> rel_option ?A2.0)
     (\<circ>\<^sub>m) (\<circ>\<^sub>m)
### theory "Symmetric_Polynomials.Vieta"
### 0.863s elapsed time, 3.285s cpu time, 0.480s GC time
Loading theory "Symmetric_Polynomials.Symmetric_Polynomials" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Hermite_Lindemann.More_Multivariate_Polynomial_HLW" via "Power_Sum_Polynomials.Power_Sum_Polynomials_Library")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
consts
  rbt_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
instantiation
  fmap :: (type, type) size
  size_fmap == size :: ('a, 'b) fmap => nat
### Ignoring duplicate rewrite rule:
### length (sorted_list_of_set ?A1) == card ?A1
consts
  map :: "('a => 'b => 'c) => ('a, 'b) rbt => ('a, 'c) rbt"
locale ring_closed
  fixes A :: "'a set"
  assumes "ring_closed A"
instantiation
  fmap :: (type, equal) equal
  equal_fmap == equal_class.equal :: ('a, 'b) fmap => ('a, 'b) fmap => bool
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P == UP R"
locale ring_homomorphism
  fixes f :: "'a => 'b"
  assumes "ring_homomorphism f"
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
### theory "HOL-Library.Finite_Map"
### 2.760s elapsed time, 10.500s cpu time, 1.524s GC time
Loading theory "Berlekamp_Zassenhaus.Karatsuba_Multiplication" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Polynomial_Record_Based")
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Symmetric_Polynomials.Symmetric_Polynomials"
### 2.647s elapsed time, 9.854s cpu time, 1.676s GC time
Loading theory "Polynomial_Factorization.Missing_Polynomial_Factorial" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Polynomial_Factorization.Gauss_Lemma")
### Ignoring duplicate rewrite rule:
### is_unit ?p1 == ?p1 ~= 0 & degree ?p1 = 0
### theory "Polynomial_Factorization.Missing_Polynomial_Factorial"
### 0.183s elapsed time, 0.661s cpu time, 0.102s GC time
Loading theory "Power_Sum_Polynomials.Power_Sum_Polynomials_Library" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Hermite_Lindemann.More_Multivariate_Polynomial_HLW")
### theory "HOL-Algebra.UnivPoly"
### 22.638s elapsed time, 79.167s cpu time, 45.342s GC time
Loading theory "HOL-Algebra.Multiplicative_Group" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues")
### theory "Power_Sum_Polynomials.Power_Sum_Polynomials_Library"
### 0.779s elapsed time, 2.820s cpu time, 0.396s GC time
Loading theory "Hermite_Lindemann.More_Multivariate_Polynomial_HLW" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection")
### theory "Hermite_Lindemann.More_Multivariate_Polynomial_HLW"
### 0.209s elapsed time, 0.748s cpu time, 0.134s GC time
Loading theory "Polynomial_Interpolation.Lagrange_Interpolation" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Interpolation.Polynomial_Interpolation")
### theory "Polynomial_Interpolation.Lagrange_Interpolation"
### 0.122s elapsed time, 0.447s cpu time, 0.068s GC time
Loading theory "Subresultants.Coeff_Int" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Subresultants.Subresultant_Gcd" via "Subresultants.Subresultant")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
Found termination order:
  "(%p. size (snd (snd (snd p)))) <*mlex*>
   (%p. size (fst (snd p))) <*mlex*> {}"
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
### theory "Berlekamp_Zassenhaus.Karatsuba_Multiplication"
### 3.235s elapsed time, 11.688s cpu time, 1.934s GC time
Loading theory "Berlekamp_Zassenhaus.Polynomial_Record_Based" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
### theory "Subresultants.Coeff_Int"
### 2.079s elapsed time, 7.617s cpu time, 5.290s GC time
Loading theory "Sturm_Sequences.Misc_Polynomial" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library")
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
### theory "Sturm_Sequences.Misc_Polynomial"
### 0.562s elapsed time, 2.150s cpu time, 0.338s GC time
Loading theory "Sturm_Sequences.Sturm_Library" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Sturm_Sequences.Sturm_Theorem")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "Sturm_Sequences.Sturm_Library"
### 0.050s elapsed time, 0.194s cpu time, 0.000s GC time
Loading theory "Sturm_Sequences.Sturm_Theorem" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "{}"
locale quasi_sturm_seq
  fixes ps :: "real poly list"
  assumes "quasi_sturm_seq ps"
locale sturm_seq
  fixes ps :: "real poly list"
    and p :: "real poly"
  assumes "sturm_seq ps p"
### Missing patterns in function definition:
### !!b. split_sign_changes [] b = undefined
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
### theory "HOL-Algebra.Multiplicative_Group"
### 4.591s elapsed time, 16.951s cpu time, 6.856s GC time
Loading theory "Subresultants.Dichotomous_Lazard" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Subresultants.Subresultant_Gcd" via "Subresultants.Subresultant")
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
### theory "Subresultants.Dichotomous_Lazard"
### 0.255s elapsed time, 0.971s cpu time, 0.170s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.ExtrEqs")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Sturm_Sequences.Sturm_Theorem"
### 2.642s elapsed time, 9.900s cpu time, 5.994s GC time
Loading theory "Jordan_Normal_Form.Conjugate" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
class conjugate = type +
  fixes conjugate :: "'a => 'a"
  assumes "conjugate_id": "!!a. conjugate (conjugate a) = a"
    and
    "conjugate_cancel_iff": "!!a b. (conjugate a = conjugate b) = (a = b)"
class conjugatable_ring = conjugate + ring +
  assumes
    "conjugate_dist_mul":
      "!!a b. conjugate (a * b) = conjugate a * conjugate b"
    and
    "conjugate_dist_add":
      "!!a b. conjugate (a + b) = conjugate a + conjugate b"
    and "conjugate_neg": "!!a. conjugate (- a) = - conjugate a"
    and "conjugate_zero": "conjugate (0::'a) = (0::'a)"
### theory "HOL-Library.BigO"
### 2.296s elapsed time, 8.598s cpu time, 5.575s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Linear_Recurrences_TestTemplates")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.760s elapsed time, 2.891s cpu time, 0.327s GC time
Loading theory "HOL-Number_Theory.Totient" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues")
Found termination order:
  "(%p. size (snd (snd (snd p)))) <*mlex*>
   (%p. size (fst (snd p))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 1808 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" map_of)
###                 ("_cargs" ("_position" ys) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" map_of)
###                   ("_cargs" ("_position" ys) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class conjugatable_ordered_ring = conjugatable_ring +
  ordered_comm_monoid_add +
  assumes "conjugate_square_positive": "!!a. (0::'a) <= a * conjugate a"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
consts
  totient_naive :: "nat => nat => nat => nat"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Number_Theory.Totient"
### 0.651s elapsed time, 2.488s cpu time, 0.345s GC time
Loading theory "HOL-Number_Theory.Residues" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field")
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "{}"
locale ring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "ring_ops ops R"
locale residues
  fixes m :: "int"
    and R :: "int ring"  (structure)
  assumes "residues m"
  defines "R == residue_ring m"
locale idom_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "idom_ops ops R"
locale idom_divide_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "idom_divide_ops ops R"
locale field_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "field_ops ops R"
locale ring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "ring_ops ops R"
### theory "Berlekamp_Zassenhaus.Polynomial_Record_Based"
### 7.861s elapsed time, 29.640s cpu time, 12.886s GC time
Loading theory "Sqrt_Babylonian.Sqrt_Babylonian_Auxiliary" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Polynomial_Interpolation.Newton_Interpolation" via "Polynomial_Interpolation.Is_Rat_To_Rat")
locale residues
  fixes m :: "int"
    and R :: "int ring"  (structure)
  assumes "residues m"
  defines "R == residue_ring m"
locale residues_prime
  fixes p :: "nat"
    and R :: "int ring"  (structure)
  assumes "residues_prime p"
  defines "R == residue_ring (int p)"
Found termination order: "{}"
instantiation
  complex :: conjugatable_ordered_field
  conjugate_complex == conjugate :: complex => complex
instantiation
  real :: conjugatable_ordered_field
  conjugate_real == conjugate :: real => real
instantiation
  rat :: conjugatable_ordered_field
  conjugate_rat == conjugate :: rat => rat
instantiation
  int :: conjugatable_ordered_ring
  conjugate_int == conjugate :: int => int
### theory "Jordan_Normal_Form.Conjugate"
### 3.504s elapsed time, 13.297s cpu time, 1.792s GC time
Loading theory "Polynomial_Factorization.Missing_List" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization" via "Berlekamp_Zassenhaus.More_Missing_Multiset" via "Polynomial_Factorization.Missing_Multiset")
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "Sqrt_Babylonian.Sqrt_Babylonian_Auxiliary"
### 0.528s elapsed time, 1.982s cpu time, 0.274s GC time
Loading theory "Polynomial_Interpolation.Is_Rat_To_Rat" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Polynomial_Interpolation.Newton_Interpolation")
locale residues_prime
  fixes p :: "nat"
    and R :: "int ring"  (structure)
  assumes "residues_prime p"
  defines "R == residue_ring (int p)"
Found termination order: "size_list length <*mlex*> {}"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "length <*mlex*> {}"
### theory "HOL-Number_Theory.Residues"
### 2.074s elapsed time, 7.770s cpu time, 1.268s GC time
Loading theory "Berlekamp_Zassenhaus.Chinese_Remainder_Poly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
consts
  list_union :: "'a list => 'a list => 'a list"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
consts
  list_diff :: "'a list => 'a list => 'a list"
### Ignoring duplicate rewrite rule:
### set ?xs1 <= set ?ys1 == list_all (%x. x : set ?ys1) ?xs1
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
class is_rat = field_char_0 +
  fixes is_rat :: "'a => bool"
    and to_rat :: "'a => rat"
  assumes
    "is_rat":
      "!!x. is_rat x = (x : field_char_0.Rats (/) (1::'a) (+) (0::'a) (-))"
    and
    "to_rat":
      "!!x. to_rat x =
            (if x : field_char_0.Rats (/) (1::'a) (+) (0::'a) (-)
             then THE y.
                     x = field_char_0.of_rat (/) (1::'a) (+) (0::'a) (-) y
             else 0)"
instantiation
  rat :: is_rat
  is_rat_rat == is_rat :: rat => bool
  to_rat_rat == to_rat :: rat => rat
instantiation
  real :: is_rat
  is_rat_real == is_rat :: real => bool
  to_rat_real == to_rat :: real => rat
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
instantiation
  complex :: is_rat
  is_rat_complex == is_rat :: complex => bool
  to_rat_complex == to_rat :: complex => rat
Found termination order: "{}"
### Missing patterns in function definition:
### min_list [] = undefined
### theory "Polynomial_Interpolation.Is_Rat_To_Rat"
### 1.285s elapsed time, 4.744s cpu time, 0.838s GC time
Loading theory "Factor_Algebraic_Polynomial.Is_Int_To_Int" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly")
Found termination order: "length <*mlex*> {}"
### theory "Factor_Algebraic_Polynomial.Is_Int_To_Int"
### 0.076s elapsed time, 0.281s cpu time, 0.063s GC time
Loading theory "Sqrt_Babylonian.Log_Impl" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Explicit_Roots" via "Sqrt_Babylonian.Sqrt_Babylonian" via "Sqrt_Babylonian.NthRoot_Impl")
### theory "Berlekamp_Zassenhaus.Chinese_Remainder_Poly"
### 0.684s elapsed time, 2.529s cpu time, 0.417s GC time
Loading theory "Native_Word.Code_Int_Integer_Conversion" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
consts
  permut_aux :: "'a list => (nat => nat) => 'a list => 'a list"
### theory "Native_Word.Code_Int_Integer_Conversion"
### 0.059s elapsed time, 0.209s cpu time, 0.072s GC time
Loading theory "Open_Induction.Restricted_Predicates" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences" via "Well_Quasi_Orders.Almost_Full")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Sqrt_Babylonian.Log_Impl"
### 0.312s elapsed time, 1.140s cpu time, 0.255s GC time
Loading theory "Sqrt_Babylonian.NthRoot_Impl" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Explicit_Roots" via "Sqrt_Babylonian.Sqrt_Babylonian")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Proofs for inductive predicate(s) "accessible_on"
  Proving monotonicity ...
### theory "Open_Induction.Restricted_Predicates"
### 0.491s elapsed time, 1.781s cpu time, 0.416s GC time
Loading theory "Polynomial_Interpolation.Divmod_Int" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Polynomial_Interpolation.Newton_Interpolation")
locale fixed_root
  fixes p :: "nat"
    and pm :: "nat"
  assumes "fixed_root p pm"
### theory "Polynomial_Interpolation.Divmod_Int"
### 0.033s elapsed time, 0.131s cpu time, 0.000s GC time
Loading theory "Jordan_Normal_Form.Matrix" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
locale fixed_root
  fixes p :: "nat"
    and pm :: "nat"
  assumes "fixed_root p pm"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Polynomial_Factorization.Missing_List"
### 2.387s elapsed time, 8.728s cpu time, 1.808s GC time
Loading theory "Polynomial_Factorization.Missing_Multiset" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization" via "Berlekamp_Zassenhaus.More_Missing_Multiset")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "Sqrt_Babylonian.NthRoot_Impl"
### 0.771s elapsed time, 2.736s cpu time, 0.755s GC time
Loading theory "Sqrt_Babylonian.Sqrt_Babylonian" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Explicit_Roots")
### theory "Polynomial_Factorization.Missing_Multiset"
### 0.311s elapsed time, 1.097s cpu time, 0.268s GC time
Loading theory "Berlekamp_Zassenhaus.More_Missing_Multiset" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization")
locale sqrt_approximation
  fixes \<epsilon> :: "'a"
    and n :: "'a"
  assumes "sqrt_approximation \<epsilon> n"
Found termination order: "{}"
### theory "Sqrt_Babylonian.Sqrt_Babylonian"
### 0.408s elapsed time, 1.432s cpu time, 0.334s GC time
Loading theory "Polynomial_Factorization.Explicit_Roots" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
Found termination order: "size <*mlex*> {}"
### theory "Berlekamp_Zassenhaus.More_Missing_Multiset"
### 0.345s elapsed time, 1.206s cpu time, 0.267s GC time
Loading theory "Berlekamp_Zassenhaus.Sublist_Iteration" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Reconstruction")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Polynomial_Factorization.Explicit_Roots"
### 2.362s elapsed time, 8.660s cpu time, 6.941s GC time
Loading theory "Polynomial_Factorization.Prime_Factorization" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization")
instantiation
  vec :: (plus) plus
  plus_vec == plus :: 'a vec => 'a vec => 'a vec
instantiation
  vec :: (minus) minus
  minus_vec == minus :: 'a vec => 'a vec => 'a vec
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  vec :: (uminus) uminus
  uminus_vec == uminus :: 'a vec => 'a vec
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
instantiation
  vec :: (ord) ord
  less_eq_vec == less_eq :: 'a vec => 'a vec => bool
  less_vec == less :: 'a vec => 'a vec => bool
instantiation
  vec :: (preorder) preorder
instantiation
  vec :: (order) order
### theory "Polynomial_Factorization.Prime_Factorization"
### 0.783s elapsed time, 2.946s cpu time, 0.478s GC time
Loading theory "Algebraic_Numbers.Complex_Roots_Real_Poly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers")
Found termination order: "{}"
instantiation
  mat :: (ord) ord
  less_eq_mat == less_eq :: 'a mat => 'a mat => bool
  less_mat == less :: 'a mat => 'a mat => bool
instantiation
  mat :: (preorder) preorder
instantiation
  mat :: (order) order
instantiation
  mat :: (plus) plus
  plus_mat == plus :: 'a mat => 'a mat => 'a mat
locale subseqs_impl
  fixes f :: "'a => 'b => 'b"
    and sl_impl :: "('a, 'b, 'state) subseqs_impl"
locale correct_subseqs_impl
  fixes f :: "'a => 'b => 'b"
    and sl_impl :: "('a, 'b, 'state) subseqs_impl"
    and invariant :: "'b => 'a list => nat => 'state => bool"
  assumes "correct_subseqs_impl f sl_impl invariant"
instantiation
  mat :: (uminus) uminus
  uminus_mat == uminus :: 'a mat => 'a mat
instantiation
  mat :: (minus) minus
  minus_mat == minus :: 'a mat => 'a mat => 'a mat
instantiation
  mat :: (semiring_0) times
  times_mat == times :: 'a mat => 'a mat => 'a mat
Found termination order:
  "(%p. size (fst (snd (snd (snd p))))) <*mlex*>
   (%p. length (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Algebraic_Numbers.Complex_Roots_Real_Poly"
### 1.245s elapsed time, 4.631s cpu time, 0.763s GC time
Loading theory "Berlekamp_Zassenhaus.Unique_Factorization" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly")
Found termination order: "length <*mlex*> {}"
locale subseqs_foldr_impl
  fixes f :: "'a => 'b => 'b"
    and impl :: "('a, 'b, 'state) subseqs_foldr_impl"
locale correct_subseqs_foldr_impl
  fixes f :: "'a => 'b => 'b"
    and impl :: "('a, 'b, 'state) subseqs_foldr_impl"
    and invariant :: "'b => 'a list => nat => 'state => bool"
  assumes "correct_subseqs_foldr_impl f impl invariant"
locale my_subseqs
  fixes f :: "'a => 'b => 'b"
locale semiring_hom
  fixes hom :: "'a => 'b"
  assumes "semiring_hom hom"
instantiation
  vec :: (conjugate) conjugate
  conjugate_vec == conjugate :: 'a vec => 'a vec
### theory "Jordan_Normal_Form.Matrix"
### 6.479s elapsed time, 23.641s cpu time, 9.943s GC time
Loading theory "Jordan_Normal_Form.Gauss_Jordan_Elimination" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl")
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (snd (snd p))) <*mlex*> {}"
locale comm_monoid_mult_isom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_mult_isom hom"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
Found termination order:
  "case_sum (%p. size_list (%p. size (fst p)) (snd (snd p)))
    (%p. size_list (%p. size (fst p)) (fst (snd (snd p)))) <*mlex*>
   case_sum (%x. 0) (%x. Suc 0) <*mlex*>
   case_sum (%p. size_list (%p. size (fst p)) (snd (snd p)))
    (%p. size_list size (snd (snd (snd (snd p))))) <*mlex*>
   {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
### theory "Jordan_Normal_Form.Gauss_Jordan_Elimination"
### 3.368s elapsed time, 12.403s cpu time, 7.924s GC time
Loading theory "Jordan_Normal_Form.Column_Operations" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Subresultants.More_Homomorphisms" via "Jordan_Normal_Form.Determinant")
Found termination order: "{}"
### theory "Berlekamp_Zassenhaus.Sublist_Iteration"
### 8.945s elapsed time, 32.929s cpu time, 16.931s GC time
Loading theory "Polynomial_Factorization.Dvd_Int_Poly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class ufd = idom +
  assumes
    "mset_factors_exist":
      "!!x. [| x ~= (0::'a); ~ x dvd (1::'a) |] ==> EX F. mset_factors F x"
    and
    "mset_factors_unique":
      "!!x F G.
          [| mset_factors F x; mset_factors G x |] ==> rel_mset (ddvd) F G"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Jordan_Normal_Form.Column_Operations"
### 0.463s elapsed time, 1.778s cpu time, 0.166s GC time
Loading theory "Jordan_Normal_Form.Determinant" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Subresultants.More_Homomorphisms")
### theory "Polynomial_Factorization.Dvd_Int_Poly"
### 0.786s elapsed time, 2.982s cpu time, 0.373s GC time
Loading theory "Polynomial_Factorization.Gauss_Lemma" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim")
class ufd = idom +
  assumes
    "mset_factors_exist":
      "!!x. [| x ~= (0::'a); ~ x dvd (1::'a) |] ==> EX F. mset_factors F x"
    and
    "mset_factors_unique":
      "!!x F G.
          [| mset_factors F x; mset_factors G x |] ==> rel_mset (ddvd) F G"
locale comm_semiring_1_hom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_1_hom hom"
locale irreducibility_hom
  fixes hom :: "'a => 'b"
  assumes "irreducibility_hom hom"
locale unit_preserving_hom
  fixes hom :: "'a => 'b"
  assumes "unit_preserving_hom hom"
locale factor_preserving_hom
  fixes hom :: "'a => 'b"
  assumes "factor_preserving_hom hom"
locale comm_semiring_isom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_isom hom"
### theory "Jordan_Normal_Form.Determinant"
### 1.741s elapsed time, 6.609s cpu time, 0.977s GC time
Loading theory "Jordan_Normal_Form.Char_Poly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers")
### theory "Polynomial_Factorization.Gauss_Lemma"
### 1.403s elapsed time, 5.300s cpu time, 0.873s GC time
Loading theory "Polynomial_Factorization.Gcd_Rat_Poly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
### theory "Polynomial_Factorization.Gcd_Rat_Poly"
### 0.066s elapsed time, 0.258s cpu time, 0.000s GC time
Loading theory "Polynomial_Factorization.Rational_Root_Test" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
### theory "Polynomial_Factorization.Rational_Root_Test"
### 0.444s elapsed time, 1.672s cpu time, 0.195s GC time
Loading theory "Polynomial_Interpolation.Newton_Interpolation" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim")
class comm_monoid_gcd = gcd + comm_semiring_1 +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
locale inj_comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_ring_hom hom"
### theory "Jordan_Normal_Form.Char_Poly"
### 1.091s elapsed time, 4.097s cpu time, 0.575s GC time
Loading theory "Subresultants.More_Homomorphisms" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly")
class comm_monoid_gcd = gcd + comm_semiring_1 +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
### Rewrite rule not in simpset:
### [:?x1 * ?y1:] == [:?x1:] * [:?y1:]
### Rewrite rule not in simpset:
### [:?x1 + ?y1:] == [:?x1:] + [:?y1:]
### Rewrite rule not in simpset:
### [:- ?x1:] == - [:?x1:]
### theory "Subresultants.More_Homomorphisms"
### 0.771s elapsed time, 2.854s cpu time, 0.411s GC time
Loading theory "Subresultants.Resultant_Prelim" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Resultant")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### !!v va b c. divided_differences_impl (v # va) b c [] = undefined
Found termination order: "(%p. length (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Subresultants.Resultant_Prelim"
### 0.540s elapsed time, 2.006s cpu time, 0.309s GC time
Loading theory "Regular-Sets.Regular_Set" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method" via "Regular-Sets.Equivalence_Checking" via "Regular-Sets.NDerivative" via "Regular-Sets.Regular_Exp")
overloading
  lang_pow \<equiv> compow :: nat => 'a list set => 'a list set
consts
  lang_pow :: "nat => 'a list set => 'a list set"
### theory "Regular-Sets.Regular_Set"
### 0.302s elapsed time, 1.095s cpu time, 0.199s GC time
Loading theory "Regular-Sets.Regular_Exp" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method" via "Regular-Sets.Equivalence_Checking" via "Regular-Sets.NDerivative")
### Missing patterns in function definition:
### !!v va b c. divided_differences_impl_int (v # va) b c [] = undefined
Found termination order:
  "(%p. size_list (nat o abs) (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size_list (nat o abs) (snd p)) <*mlex*> {}"
### theory "Polynomial_Interpolation.Newton_Interpolation"
### 2.761s elapsed time, 10.180s cpu time, 1.628s GC time
Loading theory "Polynomial_Interpolation.Polynomial_Interpolation" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization")
locale gcd_condition
  fixes ty :: "'a itself"
  assumes "gcd_condition TYPE('a)"
### Cannot skip proof of schematic goal statement
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  lang :: "'a rexp => 'a list set"
consts
  nullable :: "'a rexp => bool"
consts
  rexp_empty :: "'a rexp => bool"
instantiation
  rexp :: (order) order
  less_eq_rexp == less_eq :: 'a rexp => 'a rexp => bool
  less_rexp == less :: 'a rexp => 'a rexp => bool
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Berlekamp_Zassenhaus.Unique_Factorization"
### 11.661s elapsed time, 42.891s cpu time, 13.107s GC time
Loading theory "Berlekamp_Zassenhaus.Unique_Factorization_Poly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim")
### Ambiguous input (line 2563 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" v))
###           ("_case_syntax"
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))
###               ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                 ("_applC" ("_position" Some)
###                   ("_applC" ("_position" f)
###                     ("_cargs" ("_position" k)
###                       ("_cargs" ("_position" w) ("_position" v)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" w))
###             ("_applC" ("_position" Some)
###               ("_applC" ("_position" f)
###                 ("_cargs" ("_position" k)
###                   ("_cargs" ("_position" w) ("_position" v)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Polynomial_Interpolation.Polynomial_Interpolation"
### 4.604s elapsed time, 16.855s cpu time, 10.124s GC time
Loading theory "Show.Show" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Show.Show_Poly" via "Show.Show_Instances")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  rexp :: (linorder) linorder
### theory "Regular-Sets.Regular_Exp"
### 5.350s elapsed time, 19.599s cpu time, 10.555s GC time
Loading theory "Regular-Sets.NDerivative" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method" via "Regular-Sets.Equivalence_Checking")
class show = type +
  fixes shows_prec :: "nat => 'a => char list => char list"
    and shows_list :: "'a list => char list => char list"
  assumes
    "shows_prec_append":
      "!!p x r s. shows_prec p x (r @ s) = shows_prec p x r @ s"
    and
    "shows_list_append":
      "!!xs r s. shows_list xs (r @ s) = shows_list xs r @ s"
instantiation
  fract :: (idom) {normalization_euclidean_semiring,euclidean_ring}
  normalize_fract == normalize :: 'a fract => 'a fract
  unit_factor_fract == unit_factor :: 'a fract => 'a fract
  euclidean_size_fract == euclidean_size :: 'a fract => nat
  modulo_fract == modulo :: 'a fract => 'a fract => 'a fract
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
instantiation
  fract :: (idom) euclidean_ring_gcd
  Gcd_fract == Gcd :: 'a fract set => 'a fract
  Lcm_fract == Lcm :: 'a fract set => 'a fract
  gcd_fract == gcd :: 'a fract => 'a fract => 'a fract
  lcm_fract == lcm :: 'a fract => 'a fract => 'a fract
instantiation
  char :: show
  shows_prec_char == shows_prec :: nat => char => char list => char list
  shows_list_char == shows_list :: char list => char list => char list
instantiation
  fract :: (idom) unique_euclidean_ring
  division_segment_fract == division_segment :: 'a fract => 'a fract
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 2939 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2972 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
signature SHOW_GENERATOR =
  sig
    val generate_showsp: string -> local_theory -> local_theory
    val register_foreign_partial_and_full_showsp:
       string ->
         int ->
           term ->
             term ->
               thm option ->
                 term ->
                   thm option ->
                     bool list -> thm -> local_theory -> local_theory
    val register_foreign_showsp:
       typ -> term -> thm -> local_theory -> local_theory
    val show_instance: string -> theory -> theory
  end
structure Show_Generator: SHOW_GENERATOR
instantiation
  list :: (show) show
  shows_prec_list == shows_prec :: nat => 'a list => char list => char list
  shows_list_list == shows_list :: 'a list list => char list => char list
instantiation
  String.literal :: show
  shows_prec_literal == shows_prec ::
    nat => String.literal => char list => char list
  shows_list_literal == shows_list ::
    String.literal list => char list => char list
### theory "Show.Show"
### 0.973s elapsed time, 3.693s cpu time, 0.613s GC time
Loading theory "Regular-Sets.Relation_Interpretation" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method")
### Code generator: dropping subsumed code equation
### keys (Branch ?c ?l ?k ?v ?r) == keys ?l @ ?k # keys ?r
### Code generator: dropping subsumed code equation
### keys Empty == []
### theory "HOL-Library.RBT_Impl"
### 69.885s elapsed time, 254.263s cpu time, 104.825s GC time
Loading theory "Containers.RBT_ext" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
consts
  rel :: "('a => ('b * 'b) set) => 'a rexp => ('b * 'b) set"
consts
  word_rel :: "('a => ('b * 'b) set) => 'a list => ('b * 'b) set"
### theory "Regular-Sets.Relation_Interpretation"
### 0.101s elapsed time, 0.376s cpu time, 0.109s GC time
Loading theory "Deriving.RBT_Comparator_Impl" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
### theory "Berlekamp_Zassenhaus.Unique_Factorization_Poly"
### 4.168s elapsed time, 15.656s cpu time, 9.576s GC time
Loading theory "HOL-Library.RBT" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Factorization.Precomputation" via "HOL-Library.RBT_Mapping")
consts
  rbt_comp_lookup :: "('a, 'b) rbt => 'a => 'b option"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Library.RBT"
### 0.609s elapsed time, 2.276s cpu time, 0.406s GC time
Loading theory "HOL-Library.RBT_Mapping" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Factorization.Precomputation")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "HOL-Library.RBT_Mapping"
### 0.296s elapsed time, 1.106s cpu time, 0.212s GC time
Loading theory "Algebraic_Numbers.Algebraic_Numbers_Prelim" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers")
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
consts
  RBT_Impl_diag :: "('a, 'b) rbt => ('a * 'a, 'b) rbt"
Found termination order:
  "(%p. size (fst p)) <*mlex*> (%p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
### Missing patterns in function definition:
### rbt_keys_next ([], rbt.Empty) = undefined
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### rbt_entries_next ([], rbt.Empty) = undefined
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Containers.RBT_ext"
### 2.172s elapsed time, 8.008s cpu time, 1.657s GC time
Loading theory "Algebraic_Numbers.Bivariate_Polynomials" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Resultant")
### Ignoring duplicate rewrite rule:
### content (pCons ?a1 ?p1) == gcd ?a1 (content ?p1)
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale dvd_preserving_hom
  fixes hom :: "'a => 'b"
  assumes "dvd_preserving_hom hom"
consts
  norm :: "'a rexp => 'a rexp"
consts
  nderiv :: "'a => 'a rexp => 'a rexp"
### theory "Regular-Sets.NDerivative"
### 39.533s elapsed time, 137.086s cpu time, 125.295s GC time
Loading theory "Berlekamp_Zassenhaus.Poly_Mod" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field")
Found termination order: "length <*mlex*> {}"
### theory "Algebraic_Numbers.Algebraic_Numbers_Prelim"
### 38.004s elapsed time, 131.433s cpu time, 123.974s GC time
Loading theory "Algebraic_Numbers.Interval_Arithmetic" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers")
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
### theory "Algebraic_Numbers.Bivariate_Polynomials"
### 37.331s elapsed time, 129.118s cpu time, 123.205s GC time
Loading theory "Algebraic_Numbers.Min_Int_Poly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
consts
  rbt_comp_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
### theory "Algebraic_Numbers.Min_Int_Poly"
### 0.175s elapsed time, 0.668s cpu time, 0.142s GC time
Loading theory "Algebraic_Numbers.Resultant" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers")
instantiation
  interval :: (zero) zero
  zero_interval == zero_class.zero :: 'a interval
instantiation
  interval :: (one) one
  one_interval == one_class.one :: 'a interval
locale poly_mod
  fixes m :: "int"
instantiation
  interval :: (plus) plus
  plus_interval == plus :: 'a interval => 'a interval => 'a interval
Found termination order: "{}"
instantiation
  interval :: (uminus) uminus
  uminus_interval == uminus :: 'a interval => 'a interval
Found termination order: "{}"
instantiation
  interval :: (minus) minus
  minus_interval == minus :: 'a interval => 'a interval => 'a interval
Found termination order: "{}"
instantiation
  interval :: ({times,ord}) times
  times_interval == times :: 'a interval => 'a interval => 'a interval
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale poly_mod
  fixes m :: "int"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
Found termination order: "{}"
instantiation
  interval :: ({inverse,times,ord}) inverse
  inverse_interval == inverse :: 'a interval => 'a interval
  divide_interval == divide :: 'a interval => 'a interval => 'a interval
locale poly_mod
  fixes m :: "int"
Found termination order: "{}"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
Found termination order: "{}"
locale poly_mod
  fixes m :: "int"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
locale poly_mod_prime
  fixes p :: "int"
  assumes "poly_mod_prime p"
locale poly_mod
  fixes m :: "int"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
### theory "Berlekamp_Zassenhaus.Poly_Mod"
### 2.107s elapsed time, 8.274s cpu time, 0.765s GC time
Loading theory "Regular-Sets.Equivalence_Checking" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method")
Proofs for coinductive predicate(s) "bisimilar"
  Proving monotonicity ...
consts
  add_atoms :: "'a rexp => 'a list => 'a list"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
### theory "Regular-Sets.Equivalence_Checking"
### 0.264s elapsed time, 1.056s cpu time, 0.000s GC time
Loading theory "Regular-Sets.Regexp_Method" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting")
consts
  rel_of_regexp :: "('a * 'a) set list => nat rexp => ('a * 'a) set"
consts
  rel_eq :: "nat rexp * nat rexp => ('a * 'a) set list => bool"
Found termination order: "(%p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
instantiation
  complex_interval :: comm_monoid_add
  zero_complex_interval == zero_class.zero :: complex_interval
  plus_complex_interval == plus ::
    complex_interval => complex_interval => complex_interval
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
instantiation
  complex_interval :: mult_zero
  times_complex_interval == times ::
    complex_interval => complex_interval => complex_interval
Found termination order: "{}"
instantiation
  complex_interval :: minus
  minus_complex_interval == minus ::
    complex_interval => complex_interval => complex_interval
### theory "Algebraic_Numbers.Resultant"
### 1.894s elapsed time, 7.448s cpu time, 0.800s GC time
Loading theory "Algebraic_Numbers.Algebraic_Numbers" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
Found termination order: "{}"
### theory "Algebraic_Numbers.Interval_Arithmetic"
### 2.634s elapsed time, 10.344s cpu time, 1.072s GC time
Loading theory "Factor_Algebraic_Polynomial.Roots_via_IA" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly")
val regexp_conv = fn: Proof.context -> conv
### theory "Regular-Sets.Regexp_Method"
### 0.750s elapsed time, 2.936s cpu time, 0.398s GC time
Loading theory "Abstract-Rewriting.Abstract_Rewriting" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders")
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Polynomial.poly" found.
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Factor_Algebraic_Polynomial.Roots_via_IA"
### 0.692s elapsed time, 2.709s cpu time, 0.432s GC time
Loading theory "Show.Show_Instances" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Show.Show_Poly")
### theory "Deriving.RBT_Comparator_Impl"
### 42.345s elapsed time, 148.290s cpu time, 126.168s GC time
Loading theory "Containers.RBT_Mapping2" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2")
locale idom_isom
  fixes hom :: "'a => 'b"
  assumes "idom_isom hom"
consts
  showsp_bool :: "nat => bool => char list => char list"
consts
  pshowsp_prod ::
    "nat
     => (char list => char list) * (char list => char list)
        => char list => char list"
Found termination order: "{}"
Found termination order: "{}"
Proofs for inductive predicate(s) "SN_partp"
  Proving monotonicity ...
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
deriving "show" instance for type "Option.option"
generating show function for type "Option.option"
### theory "Abstract-Rewriting.Abstract_Rewriting"
### 1.431s elapsed time, 5.600s cpu time, 0.847s GC time
Loading theory "Abstract-Rewriting.SN_Orders" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier")
deriving "show" instance for type "Sum_Type.sum"
generating show function for type "Sum_Type.sum"
deriving "show" instance for type "Product_Type.prod"
deriving "show" instance for type "Product_Type.unit"
### theory "Algebraic_Numbers.Algebraic_Numbers"
### 1.756s elapsed time, 6.865s cpu time, 1.033s GC time
Loading theory "Show.Show_Real" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Pretty" via "Show.Show_Complex")
deriving "show" instance for type "HOL.bool"
deriving "show" instance for type "Nat.nat"
deriving "show" instance for type "Int.int"
deriving "show" instance for type "Rat.rat"
class non_strict_order = ord +
  assumes "ge_refl": "!!x. x <= x"
    and "ge_trans": "!!y x z. [| y <= x; z <= y |] ==> z <= x"
    and "max_comm": "!!x y. max x y = max y x"
    and "max_ge_x": "!!x y. x <= max x y"
    and "max_id": "!!y x. y <= x ==> max x y = x"
    and "max_mono": "!!y x z. y <= x ==> max z y <= max z x"
### theory "Show.Show_Instances"
### 1.275s elapsed time, 4.969s cpu time, 0.774s GC time
Loading theory "Show.Show_Poly" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
deriving "show" instance for type "Real.real"
### theory "Show.Show_Real"
### 0.312s elapsed time, 1.218s cpu time, 0.173s GC time
Loading theory "Show.Show_Complex" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Pretty")
class ordered_ab_semigroup = ab_semigroup_add + monoid_add +
  non_strict_order +
  assumes "plus_left_mono": "!!y x z. y <= x ==> y + z <= x + z"
### Ambiguous input (line 247 of "$AFP/Containers/RBT_Mapping2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###             ("_case_syntax"
###               ("_applC" ("_position" lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v1)
###                           ("_position" v2))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###               ("_case_syntax"
###                 ("_applC" ("_position" lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v1) ("_position" v2))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.RBT_Mapping2"
### 1.341s elapsed time, 5.234s cpu time, 0.774s GC time
Loading theory "Containers.RBT_Set2" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
class SN_Orders.ordered_semiring_0 = semiring_0 + ordered_ab_semigroup +
  assumes
    "times_left_mono":
      "!!z y x. [| (0::'a) <= z; y <= x |] ==> y * z <= x * z"
    and
    "times_right_mono":
      "!!x z y. [| (0::'a) <= x; z <= y |] ==> x * z <= x * y"
    and
    "times_left_anti_mono":
      "!!y x z. [| y <= x; z <= (0::'a) |] ==> x * z <= y * z"
deriving "show" instance for type "Complex.complex"
### theory "Show.Show_Complex"
### 0.352s elapsed time, 1.382s cpu time, 0.131s GC time
Loading theory "Subresultants.Binary_Exponentiation" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Subresultants.Subresultant_Gcd" via "Subresultants.Subresultant")
class monoid_mult = semigroup_mult + power +
  assumes "mult_1_left": "!!a. (1::'a) * a = a"
    and "mult_1_right": "!!a. a * (1::'a) = a"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
### theory "Subresultants.Binary_Exponentiation"
### 0.221s elapsed time, 0.858s cpu time, 0.169s GC time
Loading theory "Berlekamp_Zassenhaus.Finite_Field" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp")
Found termination order: "{}"
class ordered_semiring_1 = semiring_1 + SN_Orders.ordered_semiring_0 +
  assumes "one_ge_zero": "(0::'a) <= (1::'a)"
locale order_pair
  fixes gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and default :: "'a"
  assumes "order_pair (\<succ>) default"
locale one_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
  assumes "one_mono_ordered_semiring_1 default (\<succ>)"
locale SN_one_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
  assumes "SN_one_mono_ordered_semiring_1 default (\<succ>)"
locale SN_strict_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and mono :: "'a => bool"
  assumes "SN_strict_mono_ordered_semiring_1 default (\<succ>) mono"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale both_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and arc_pos :: "'a => bool"
  assumes "both_mono_ordered_semiring_1 default (\<succ>) arc_pos"
locale SN_both_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and arc_pos :: "'a => bool"
  assumes "SN_both_mono_ordered_semiring_1 default (\<succ>) arc_pos"
locale weak_SN_strict_mono_ordered_semiring_1
  fixes weak_gt :: "'a => 'a => bool"
    and default :: "'a"
    and mono :: "'a => bool"
  assumes "weak_SN_strict_mono_ordered_semiring_1 weak_gt default mono"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale weak_SN_both_mono_ordered_semiring_1
  fixes weak_gt :: "'a => 'a => bool"
    and default :: "'a"
    and arc_pos :: "'a => bool"
  assumes "weak_SN_both_mono_ordered_semiring_1 weak_gt default arc_pos"
instantiation
  poly :: ({one,zero,show}) show
  shows_prec_poly == shows_prec :: nat => 'a poly => char list => char list
  shows_list_poly == shows_list :: 'a poly list => char list => char list
### theory "Show.Show_Poly"
### 0.863s elapsed time, 3.355s cpu time, 0.401s GC time
Loading theory "Draft.Show_RatFPS" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test")
locale poly_order_carrier
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and power_mono :: "bool"
    and discrete :: "bool"
  assumes "poly_order_carrier default (\<succ>) power_mono discrete"
instantiation
  ratfps :: ({field_gcd,show}) show
  shows_prec_ratfps == shows_prec ::
    nat => 'a ratfps => char list => char list
  shows_list_ratfps == shows_list ::
    'a ratfps list => char list => char list
### theory "Draft.Show_RatFPS"
### 0.466s elapsed time, 1.841s cpu time, 0.137s GC time
Loading theory "Draft.Linear_Recurrences_Pretty" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Containers.RBT_Set2"
### 1.521s elapsed time, 5.941s cpu time, 0.611s GC time
Loading theory "Polynomial_Factorization.Precomputation" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization")
class large_ordered_semiring_1 = poly_carrier +
  assumes "ex_large_of_nat": "!!y. EX x. y <= of_nat x"
class ordered_semiring_1 = semiring_1 + SN_Orders.ordered_semiring_0 +
  assumes "one_ge_zero": "(0::'a) <= (1::'a)"
instantiation
  mod_ring :: (finite) equal
  equal_mod_ring == equal_class.equal :: 'a mod_ring => 'a mod_ring => bool
instantiation
  mod_ring :: (finite) comm_ring
  uminus_mod_ring == uminus :: 'a mod_ring => 'a mod_ring
  times_mod_ring == times :: 'a mod_ring => 'a mod_ring => 'a mod_ring
  zero_mod_ring == zero_class.zero :: 'a mod_ring
  minus_mod_ring == minus :: 'a mod_ring => 'a mod_ring => 'a mod_ring
  plus_mod_ring == plus :: 'a mod_ring => 'a mod_ring => 'a mod_ring
### theory "Abstract-Rewriting.SN_Orders"
### 2.201s elapsed time, 8.601s cpu time, 0.889s GC time
Loading theory "Containers.Set_Impl" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
### theory "Polynomial_Factorization.Precomputation"
### 0.313s elapsed time, 1.219s cpu time, 0.105s GC time
Loading theory "Polynomial_Factorization.Kronecker_Factorization" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
### Additional type variable(s) in locale specification "nontriv": 'a
class nontriv = type +
  assumes "nontriv": "1 < CARD('a)"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
instantiation
  mod_ring :: (nontriv) comm_ring_1
  one_mod_ring == one_class.one :: 'a mod_ring
Found termination order: "(%p. size_list length (snd p)) <*mlex*> {}"
### theory "Draft.Linear_Recurrences_Pretty"
### 1.102s elapsed time, 4.331s cpu time, 0.331s GC time
Loading theory "Abstract-Rewriting.SN_Order_Carrier" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
### Additional type variable(s) in locale specification "prime_card": 'a
class prime_card = type +
  assumes "prime_card": "prime CARD('a)"
instantiation
  nat :: large_ordered_semiring_1
instantiation
  mod_ring :: (prime_card) field
  inverse_mod_ring == inverse :: 'a mod_ring => 'a mod_ring
  divide_mod_ring == divide :: 'a mod_ring => 'a mod_ring => 'a mod_ring
instantiation
  mod_ring :: (prime_card) {normalization_euclidean_semiring,euclidean_ring}
  normalize_mod_ring == normalize :: 'a mod_ring => 'a mod_ring
  unit_factor_mod_ring == unit_factor :: 'a mod_ring => 'a mod_ring
  euclidean_size_mod_ring == euclidean_size :: 'a mod_ring => nat
  modulo_mod_ring == modulo :: 'a mod_ring => 'a mod_ring => 'a mod_ring
instantiation
  mod_ring :: (prime_card) euclidean_ring_gcd
  Gcd_mod_ring == Gcd :: 'a mod_ring set => 'a mod_ring
  Lcm_mod_ring == Lcm :: 'a mod_ring set => 'a mod_ring
  gcd_mod_ring == gcd :: 'a mod_ring => 'a mod_ring => 'a mod_ring
  lcm_mod_ring == lcm :: 'a mod_ring => 'a mod_ring => 'a mod_ring
instantiation
  mod_ring :: (prime_card) unique_euclidean_ring
  division_segment_mod_ring == division_segment ::
    'a mod_ring => 'a mod_ring
### theory "Berlekamp_Zassenhaus.Finite_Field"
### 2.448s elapsed time, 9.596s cpu time, 0.877s GC time
Loading theory "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based")
instantiation
  int :: large_ordered_semiring_1
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  arctic :: ord
  less_eq_arctic == less_eq :: arctic => arctic => bool
  less_arctic == less :: arctic => arctic => bool
Found termination order: "{}"
### theory "Polynomial_Factorization.Kronecker_Factorization"
### 1.851s elapsed time, 7.241s cpu time, 0.767s GC time
Loading theory "Polynomial_Factorization.Rational_Factorization" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp")
Found termination order: "{}"
instantiation
  arctic :: ordered_semiring_1
  one_arctic == one_class.one :: arctic
  times_arctic == times :: arctic => arctic => arctic
  zero_arctic == zero_class.zero :: arctic
  plus_arctic == plus :: arctic => arctic => arctic
Found termination order: "{}"
Found termination order: "{}"
### Missing patterns in function definition:
### get_arctic_num MinInfty = undefined
Found termination order: "{}"
Found termination order: "{}"
locale poly_mod_type
  fixes m :: "int"
    and ty :: "'a itself"
  assumes "poly_mod_type TYPE('a) m"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
locale poly_mod_prime_type
  fixes m :: "int"
    and ty :: "'a itself"
  assumes "poly_mod_prime_type TYPE('a) m"
locale poly_mod_prime
  fixes p :: "int"
  assumes "poly_mod_prime p"
instantiation
  arctic_delta :: (ord) ord
  less_eq_arctic_delta == less_eq ::
    'a arctic_delta => 'a arctic_delta => bool
  less_arctic_delta == less :: 'a arctic_delta => 'a arctic_delta => bool
Found termination order: "{}"
### theory "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field"
### 1.783s elapsed time, 6.910s cpu time, 0.734s GC time
Loading theory "Subresultants.Subresultant" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Subresultants.Subresultant_Gcd")
Found termination order: "{}"
instantiation
  arctic_delta :: (linordered_field) ordered_semiring_1
  one_arctic_delta == one_class.one :: 'a arctic_delta
  times_arctic_delta == times ::
    'a arctic_delta => 'a arctic_delta => 'a arctic_delta
  zero_arctic_delta == zero_class.zero :: 'a arctic_delta
  plus_arctic_delta == plus ::
    'a arctic_delta => 'a arctic_delta => 'a arctic_delta
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Missing patterns in function definition:
### get_arctic_delta_num MinInfty_delta = undefined
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Abstract-Rewriting.SN_Order_Carrier"
### 2.926s elapsed time, 11.383s cpu time, 1.207s GC time
Loading theory "VectorSpace.FunctionLemmas" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace" via "VectorSpace.MonoidSums")
### theory "VectorSpace.FunctionLemmas"
### 0.030s elapsed time, 0.114s cpu time, 0.000s GC time
Loading theory "VectorSpace.RingModuleFacts" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
### theory "VectorSpace.RingModuleFacts"
### 0.675s elapsed time, 2.610s cpu time, 0.255s GC time
Loading theory "VectorSpace.MonoidSums" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
locale div_exp_param
  fixes div_exp :: "'a => 'a => nat => 'a"
locale div_exp_sound
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound div_exp"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### theory "VectorSpace.MonoidSums"
### 0.364s elapsed time, 1.403s cpu time, 0.211s GC time
Loading theory "VectorSpace.LinearCombinations" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
### theory "Polynomial_Factorization.Rational_Factorization"
### 2.768s elapsed time, 10.721s cpu time, 1.128s GC time
Loading theory "Well_Quasi_Orders.Infinite_Sequences" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences" via "Well_Quasi_Orders.Almost_Full")
### theory "Well_Quasi_Orders.Infinite_Sequences"
### 0.127s elapsed time, 0.481s cpu time, 0.122s GC time
Loading theory "Well_Quasi_Orders.Minimal_Elements" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences")
locale primitive_remainder_sequence
  fixes F :: "nat => 'a poly"
    and n :: "nat => nat"
    and \<delta> :: "nat => nat"
    and f :: "nat => 'a"
    and k :: "nat"
    and \<beta> :: "nat => 'a"
  assumes "primitive_remainder_sequence F n \<delta> f k \<beta>"
locale minimal_element
  fixes P :: "'a => 'a => bool"
    and A :: "'a set"
  assumes "minimal_element P A"
locale subresultant_prs_locale
  fixes F :: "nat => 'a fract poly"
    and n :: "nat => nat"
    and \<delta> :: "nat => nat"
    and f :: "nat => 'a fract"
    and k :: "nat"
    and \<beta> :: "nat => 'a fract"
    and G1 :: "'a poly"
    and G2 :: "'a poly"
  assumes "subresultant_prs_locale F n \<delta> f k \<beta> G1 G2"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Well_Quasi_Orders.Minimal_Elements"
### 0.272s elapsed time, 1.056s cpu time, 0.135s GC time
Loading theory "Well_Quasi_Orders.Least_Enum" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences" via "Well_Quasi_Orders.Almost_Full")
locale infinitely_many1
  fixes P :: "'a => bool"
  assumes "infinitely_many1 P"
### Additional type variable(s) in specification of "enum_rel": 'a
### Additional type variable(s) in specification of "enum_dom": 'a
Found termination order: "size <*mlex*> {}"
locale infinitely_many2
  fixes P :: "'a => 'a => bool"
    and N :: "'a"
  assumes "infinitely_many2 P N"
### Additional type variable(s) in specification of "enumchain_rel": 'a
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### Additional type variable(s) in specification of "enumchain_dom": 'a
Found termination order: "size <*mlex*> {}"
### theory "Well_Quasi_Orders.Least_Enum"
### 0.237s elapsed time, 0.891s cpu time, 0.181s GC time
Loading theory "Well_Quasi_Orders.Almost_Full" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences")
Found termination order: "size <*mlex*> {}"
locale subresultant_prs_locale2
  fixes F :: "nat => 'a fract poly"
    and n :: "nat => nat"
    and \<delta> :: "nat => nat"
    and f :: "nat => 'a fract"
    and k :: "nat"
    and \<beta> :: "nat => 'a fract"
    and G1 :: "'a poly"
    and G2 :: "'a poly"
  assumes "subresultant_prs_locale2 F n \<delta> f k \<beta> G1 G2"
Found termination order: "length <*mlex*> {}"
Proofs for inductive predicate(s) "af"
  Proving monotonicity ...
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
locale LinearCombinations.submodule
  fixes R :: "('a, 'b) ring_scheme"
    and N :: "'c set"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "LinearCombinations.submodule R N M"
### theory "Well_Quasi_Orders.Almost_Full"
### 1.281s elapsed time, 4.868s cpu time, 0.846s GC time
Loading theory "Well_Quasi_Orders.Minimal_Bad_Sequences" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale mbs
  fixes A :: "'a set"
structure Set_Complement_Eqs: NAMED_THMS
locale div_exp_sound
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound div_exp"
locale div_exp_param
  fixes div_exp :: "'a => 'a => nat => 'a"
### Cannot skip proof of schematic goal statement
locale div_exp_sound
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound div_exp"
### theory "Well_Quasi_Orders.Minimal_Bad_Sequences"
### 0.351s elapsed time, 1.328s cpu time, 0.188s GC time
Loading theory "Well_Quasi_Orders.Almost_Full_Relations" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils")
Found termination order: "{}"
locale mod_hom
  fixes R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"
    and N :: "('a, 'e, 'f) module_scheme"
    and f :: "'c => 'e"
  assumes "mod_hom R M N f"
### theory "Subresultants.Subresultant"
### 4.194s elapsed time, 16.044s cpu time, 2.320s GC time
Loading theory "Subresultants.Subresultant_Gcd" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp")
Found termination order: "{}"
locale mod_hom
  fixes R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"
    and N :: "('a, 'e, 'f) module_scheme"
    and f :: "'c => 'e"
  assumes "mod_hom R M N f"
### theory "Well_Quasi_Orders.Almost_Full_Relations"
### 0.523s elapsed time, 1.954s cpu time, 0.379s GC time
Loading theory "Polynomials.Utils" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class")
### Code generator: dropping subsumed code equation
### Collect ?P == set (filter ?P enum_class.enum)
locale div_exp_sound_gcd
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound_gcd div_exp"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### Ambiguous input (line 739 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 744 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Polynomials.Utils"
### 0.443s elapsed time, 1.644s cpu time, 0.393s GC time
Loading theory "Well_Quasi_Orders.Well_Quasi_Orders" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Power_Products")
locale subresultant_prs_gcd
  fixes F :: "nat => 'a fract poly"
    and n :: "nat => nat"
    and \<delta> :: "nat => nat"
    and f :: "nat => 'a fract"
    and k :: "nat"
    and \<beta> :: "nat => 'a fract"
    and G1 :: "'a poly"
    and G2 :: "'a poly"
  assumes "subresultant_prs_gcd F n \<delta> f k \<beta> G1 G2"
locale div_exp_sound_gcd
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound_gcd div_exp"
### Ambiguous input (line 823 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class wqo = preorder +
  assumes "good": "!!f. good (<=) f"
### Ambiguous input (line 838 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Partially applied constant "Dichotomous_Lazard.dichotomous_Lazard" on left hand side of equation, in theorem:
### div_exp_Lazard_gcd.gcd_impl_primitive ?G1.0 ?G2.0 ==
### normalize
###  (primitive_part (fst (div_exp_Lazard.subresultant_prs ?G1.0 ?G2.0)))
### theory "Subresultants.Subresultant_Gcd"
### 1.078s elapsed time, 4.003s cpu time, 0.844s GC time
Loading theory "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat")
### theory "Well_Quasi_Orders.Well_Quasi_Orders"
### 0.377s elapsed time, 1.376s cpu time, 0.274s GC time
Loading theory "Polynomials.Power_Products" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class")
### Code generator: dropping subsumed code equation
### Inf ?A ?x == INF f\<in>?A. f ?x
### Code generator: dropping subsumed code equation
### Sup ?A ?x == SUP f\<in>?A. f ?x
### Ambiguous input (line 951 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_applC" ("_position" ord.quicksort)
###                   ("_cargs"
###                     ("_applC" ("_position" lt_of_comp) ("_position" c))
###                     ("_applC" ("_position" list_of_dlist)
###                       ("_position" dxs))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_applC" ("_position" ord.quicksort)
###               ("_cargs" ("_applC" ("_position" lt_of_comp) ("_position" c))
###                 ("_applC" ("_position" list_of_dlist)
###                   ("_position" dxs))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "VectorSpace.LinearCombinations"
### 7.092s elapsed time, 26.878s cpu time, 13.111s GC time
Loading theory "VectorSpace.SumSpaces" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
### theory "VectorSpace.SumSpaces"
### 0.439s elapsed time, 1.732s cpu time, 0.104s GC time
Loading theory "VectorSpace.VectorSpace" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace")
locale vectorspace
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
  assumes "vectorspace K V"
locale subspace
  fixes K :: "('a, 'b) ring_scheme"
    and W :: "'c set"
    and V :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "subspace K W V"
### theory "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp"
### 4.322s elapsed time, 16.566s cpu time, 10.937s GC time
Loading theory "Algebraic_Numbers.Sturm_Rat" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
class plus = type +
  fixes plus :: "'a => 'a => 'a"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### Ignoring duplicate rewrite rule:
### carrier (vs ?y) == ?y
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class ninv_comm_monoid_add = comm_monoid_add +
  assumes "plus_eq_zero": "!!s t. s + t = (0::'a) ==> s = (0::'a)"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
### Ignoring duplicate rewrite rule:
### T \<zero>\<^bsub>V\<^esub> == \<zero>\<^bsub>W\<^esub>
class lcs_powerprod = comm_powerprod +
  fixes lcs :: "'a => 'a => 'a"
  assumes "adds_lcs": "!!s t. s adds lcs s t"
  assumes "lcs_adds": "!!s u t. [| s adds u; t adds u |] ==> lcs s t adds u"
  assumes "lcs_comm": "!!s t. lcs s t = lcs t s"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class graded_dickson_powerprod = ulcs_powerprod +
  assumes "ex_dgrad": "EX d. dickson_grading d"
class dickson_powerprod = ulcs_powerprod +
  assumes "dickson": "almost_full_on (adds) UNIV"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### Code generator: dropping subsumed code equation
### set_eq ?A ?B == ?A <= ?B & ?B <= ?A
### Ambiguous input (line 1326 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###             ("_case2" ("_case1" ("_list" ("_position" x)) ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem DList_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###               ("_case1" ("_list" ("_position" x)) ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal"
###                   ("_position" ''the_elem DList_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dxs))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1331 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" RBT_Mapping2.impl_of) ("_position" rbt))
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem RBT_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" RBT_Mapping2.impl_of)
###                 ("_position" rbt))
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal" ("_position" ''the_elem RBT_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1387 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_applC" ("_position" DList_Set.product)
###                     ("_cargs" ("_position" dxs) ("_position" dys))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_applC" ("_position" DList_Set.product)
###                 ("_cargs" ("_position" dxs) ("_position" dys))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1403 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.product)
###                     ("_cargs" ("_position" rbt1)
###                       ("_position" rbt2))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.product)
###                 ("_cargs" ("_position" rbt1) ("_position" rbt2))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class semi_canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_imp_add": "!!a b. a <= b ==> EX c. b = a + c"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  ninv_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
### Ambiguous input (line 1470 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" B))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" dxs)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" B))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" dxs) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Algebraic_Numbers.Sturm_Rat"
### 2.981s elapsed time, 11.548s cpu time, 1.350s GC time
Loading theory "Word_Lib.More_Arithmetic" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit" via "Word_Lib.More_Word")
### Ambiguous input (line 1477 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" C))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" rbt)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" C))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" rbt) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Word_Lib.More_Arithmetic"
### 0.088s elapsed time, 0.323s cpu time, 0.079s GC time
Loading theory "Word_Lib.More_Word" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit")
### Ambiguous input (line 1546 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'c)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("\<^const>HOL.not_equal"
### ("_applC" ("_position" c_b) ("_cargs" ("_position" y) ("_position" y')))
### ("_position" Eq))
###                                     ("_position" A)
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))))
###                                 ("_position" rbt2))))
###                           ("_cargs" ("_position" rbt1)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'c)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'c)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("\<^const>HOL.not_equal"
###                               ("_applC" ("_position" c_b)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_position" Eq))
###                             ("_position" A)
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))))
###                         ("_position" rbt2))))
###                   ("_cargs" ("_position" rbt1)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt2))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "VectorSpace.VectorSpace"
### 4.124s elapsed time, 15.943s cpu time, 1.964s GC time
Loading theory "Jordan_Normal_Form.Missing_VectorSpace" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect")
### Ambiguous input (line 1555 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CEQ" ("_position_sort" 'e)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" DList_Set.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" dxs1))))
###                                 ("_cargs" ("_position" rbt3)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs1))))
###                       ("_cargs" ("_position" rbt3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CEQ" ("_position_sort" 'e)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs1))))
###                     ("_cargs" ("_position" rbt3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs1))))
###                   ("_cargs" ("_position" rbt3)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale Missing_VectorSpace.comp_fun_commute_on
  fixes f :: "'a => 'a => 'a"
    and A :: "'a set"
  assumes "Missing_VectorSpace.comp_fun_commute_on f A"
locale Missing_VectorSpace.comp_fun_commute_on
  fixes f :: "'a => 'a => 'a"
    and A :: "'a set"
  assumes "Missing_VectorSpace.comp_fun_commute_on f A"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
locale vectorspace
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
  assumes "vectorspace K V"
### Ambiguous input (line 1566 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CCOMPARE" ("_position_sort" 'a)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" RBT_Set2.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" rbt4))))
###                                 ("_cargs" ("_position" dxs2)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" rbt4))))
###                       ("_cargs" ("_position" dxs2)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CCOMPARE" ("_position_sort" 'a)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'a)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" rbt4))))
###                     ("_cargs" ("_position" dxs2)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" rbt4))))
###                   ("_cargs" ("_position" dxs2)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Word_Lib.More_Word"
### 1.511s elapsed time, 5.758s cpu time, 0.774s GC time
Loading theory "Word_Lib.Bit_Shifts_Infix_Syntax" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Generic_set_bit" via "Word_Lib.Most_significant_bit")
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
### Ambiguous input (line 1577 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("_applC" ("_position" eq)
### ("_cargs" ("_position" y) ("_position" y')))
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))
###                                     ("_position" A)))
###                                 ("_position" dxs4))))
###                           ("_cargs" ("_position" dxs3)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs4))))
###                   ("_cargs" ("_position" dxs3)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1591 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" xs3))))
###                     ("_cargs" ("_position" rbt1)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" xs3))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1598 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" rbt5))))
###                     ("_cargs" ("_position" xs4)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt5))))
###                 ("_cargs" ("_position" xs4) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1605 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" xs5))))
###                     ("_cargs" ("_position" dxs3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" xs5))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
### Ambiguous input (line 1612 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs4))))
###                     ("_cargs" ("_position" xs6)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" xs6) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
### Ambiguous input (line 1629 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case1" ("_position" None)
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###                   ("_position" r)
###                   ("\<^const>HOL.not_equal"
###                     ("_applC" ("_position" c)
###                       ("_cargs" ("_position" x) ("_position" y)))
###                     ("_position" Eq)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###               ("_position" r)
###               ("\<^const>HOL.not_equal"
###                 ("_applC" ("_position" c)
###                   ("_cargs" ("_position" x) ("_position" y)))
###                 ("_position" Eq)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1722 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" filter)
###               ("_cargs" ("_position" P) ("_position" xs)))
###             ("_case2" ("_case1" ("_position" Nil) ("_position" False))
###               ("_case1"
###                 ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###                 ("_applC" ("_position" list_all)
###                   ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                     ("_position" xs)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" filter)
###                 ("_cargs" ("_position" P) ("_position" xs)))
###               ("_case1" ("_position" Nil) ("_position" False))))
###           ("_case1"
###             ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###             ("_applC" ("_position" list_all)
###               ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                 ("_position" xs)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
### theory "Word_Lib.Bit_Shifts_Infix_Syntax"
### 1.342s elapsed time, 5.092s cpu time, 0.822s GC time
Loading theory "Word_Lib.Least_significant_bit" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int")
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
class add_linorder_min = add_linorder +
  assumes "zero_min": "!!x. (0::'a) <= x"
### Ambiguous input (line 1833 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_position" DList_Set.empty))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_position" DList_Set.empty))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class set_impl = type +
  fixes set_impl :: "('a, set_impl) phantom"
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
signature SET_IMPL_GENERATOR =
  sig val derive_set_impl: string -> string -> theory -> theory end
structure Set_Impl_Generator: SET_IMPL_GENERATOR
use dlist as set_impl for type unit
registered unit in class set_impl
use dlist as set_impl for type bool
registered bool in class set_impl
use rbt as set_impl for type nat
registered nat in class set_impl
use set_RBT as set_impl for type int
registered int in class set_impl
use dlist as set_impl for type finite_1
### theory "Jordan_Normal_Form.Missing_VectorSpace"
### 2.595s elapsed time, 9.882s cpu time, 1.441s GC time
Loading theory "Jordan_Normal_Form.VS_Connect" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel")
registered finite_1 in class set_impl
use dlist as set_impl for type finite_2
registered finite_2 in class set_impl
use dlist as set_impl for type finite_3
registered finite_3 in class set_impl
use rbt as set_impl for type integer
registered integer in class set_impl
use rbt as set_impl for type natural
registered natural in class set_impl
use rbt as set_impl for type char
registered char in class set_impl
instantiation
  sum :: (set_impl, set_impl) set_impl
  set_impl_sum == set_impl :: ('a + 'b, set_impl) phantom
instantiation
  prod :: (set_impl, set_impl) set_impl
  set_impl_prod == set_impl :: ('a * 'b, set_impl) phantom
use choose as set_impl for type list
registered list in class set_impl
use rbt as set_impl for type literal
registered literal in class set_impl
instantiation
  option :: (set_impl) set_impl
  set_impl_option == set_impl :: ('a option, set_impl) phantom
use monad as set_impl for type fun
registered fun in class set_impl
use choose as set_impl for type set
registered set in class set_impl
instantiation
  phantom :: (type, set_impl) set_impl
  set_impl_phantom == set_impl :: (('a, 'b) phantom, set_impl) phantom
### Ambiguous input (line 1952 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2" ("_case1" ("_position" None) ("_position" Set_Monad))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" conv)
###                   ("_applC" ("_position" DList_set)
###                     ("_position" DList_Set.empty)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None) ("_position" Set_Monad))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" conv)
###               ("_applC" ("_position" DList_set)
###                 ("_position" DList_Set.empty)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.Set_Impl"
### 19.162s elapsed time, 73.506s cpu time, 18.679s GC time
Loading theory "Algebraic_Numbers.Compare_Complex" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers")
class lsb = semiring_bits +
  fixes lsb :: "'a => bool"
  assumes "lsb_odd": "lsb = odd"
instantiation
  int :: lsb
  lsb_int == lsb :: int => bool
instantiation
  word :: (len) lsb
  lsb_word == lsb :: 'a word => bool
### theory "Word_Lib.Least_significant_bit"
### 0.806s elapsed time, 3.092s cpu time, 0.436s GC time
Loading theory "Berlekamp_Zassenhaus.Degree_Bound" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Reconstruction")
### Cannot skip proof of schematic goal statement
instantiation
  complex :: finite_UNIV
  finite_UNIV_complex == finite_UNIV :: (complex, bool) phantom
instantiation
  complex :: compare
  compare_complex == compare :: complex => complex => order
instantiation
  nat :: add_linorder
instantiation
  nat :: add_linorder_min
instantiation
  nat :: add_wellorder
deriving "ceq" instance for type "Complex.complex" via "="
derived is_ceq_complex-lemma
deriving "ceq" instance for type "Real.real" via "="
derived is_ceq_real-lemma
deriving "ccompare_order" instance for type "Complex.complex" via compare_order
derived is_ccompare_complex-lemma
deriving "ccompare_order" instance for type "Real.real" via compare_order
derived is_ccompare_real-lemma
use dlist as set_impl for type complex
registered complex in class set_impl
use dlist as set_impl for type real
registered real in class set_impl
### theory "Algebraic_Numbers.Compare_Complex"
### 1.063s elapsed time, 4.095s cpu time, 0.494s GC time
Loading theory "Jordan_Normal_Form.Matrix_IArray_Impl" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl")
### Cannot skip proof of schematic goal statement
### theory "Berlekamp_Zassenhaus.Degree_Bound"
### 1.094s elapsed time, 4.190s cpu time, 0.557s GC time
Loading theory "Word_Lib.Most_significant_bit" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Generic_set_bit")
class msb = type +
  fixes msb :: "'a => bool"
instantiation
  int :: msb
  msb_int == msb :: int => bool
instantiation
  word :: (len) msb
  msb_word == msb :: 'a word => bool
instantiation
  int :: add_linorder_group
instantiation
  rat :: add_linorder_group
instantiation
  real :: add_linorder_group
### theory "Word_Lib.Most_significant_bit"
### 0.167s elapsed time, 0.644s cpu time, 0.086s GC time
Loading theory "Word_Lib.Generic_set_bit" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int")
### Cannot skip proof of schematic goal statement
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
### Cannot skip proof of schematic goal statement
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale matrix_ring
  fixes n :: "nat"
    and field_type :: "'a itself"
class set_bit = semiring_bits +
  fixes set_bit :: "'a => nat => bool => 'a"
  assumes
    "bit_set_bit_iff_2n":
      "!!a m b n.
          bit (set_bit_class.set_bit a m b) n =
          ((if m = n then b else bit a n) & (2::'a) ^ n ~= (0::'a))"
instantiation
  int :: set_bit
  set_bit_int == set_bit_class.set_bit :: int => nat => bool => int
instantiation
  word :: (len) set_bit
  set_bit_word == set_bit_class.set_bit :: 'a word => nat => bool => 'a word
locale od_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "od_powerprod (\<preceq>) (\<prec>)"
### theory "Word_Lib.Generic_set_bit"
### 0.871s elapsed time, 3.248s cpu time, 0.635s GC time
Loading theory "Native_Word.Code_Symbolic_Bits_Int" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
instantiation
  fun :: (type, add_linorder) lcs_powerprod
  lcs_fun == lcs :: ('a => 'b) => ('a => 'b) => 'a => 'b
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
### Cannot skip proof of schematic goal statement
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Native_Word.Code_Symbolic_Bits_Int"
### 0.628s elapsed time, 2.323s cpu time, 0.457s GC time
Loading theory "Native_Word.Bits_Integer" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
locale matrix_vs
  fixes nr :: "nat"
    and nc :: "nat"
    and field_type :: "'a itself"
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
### Cannot skip proof of schematic goal statement
instantiation
  vec :: (type) equal
  equal_vec == equal_class.equal :: 'a vec => 'a vec => bool
instantiation
  mat :: (type) equal
  equal_mat == equal_class.equal :: 'a mat => 'a mat => bool
deriving "ceq" instance for type "Matrix.mat" via "="
instantiation
  integer :: lsb
  lsb_integer == lsb :: integer => bool
derived is_ceq_mat-lemma
deriving "ceq" instance for type "Matrix.vec" via "="
instantiation
  integer :: msb
  msb_integer == msb :: integer => bool
derived is_ceq_vec-lemma
use None as trivial implementation of ccompare for type mat
instantiation
  integer :: set_bit
  set_bit_integer == set_bit_class.set_bit ::
    integer => nat => bool => integer
registered mat in class ccompare
use None as trivial implementation of ccompare for type vec
### Code generator: dropping subsumed code equation
### not ?k == - ?k - 1
registered vec in class ccompare
use dlist as set_impl for type mat
registered mat in class set_impl
use dlist as set_impl for type vec
registered vec in class set_impl
use None as trivial implementation of cenum for type mat
registered mat in class cenum
use None as trivial implementation of cenum for type vec
registered vec in class cenum
### theory "Jordan_Normal_Form.Matrix_IArray_Impl"
### 2.549s elapsed time, 9.498s cpu time, 1.754s GC time
Loading theory "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
### Code generator: dropping subsumed code equation
### and ?k ?l ==
### if ?k = 0 | ?l = 0 then 0
### else if ?k = - 1 then ?l
###      else if ?l = - 1 then ?k
###           else ?k mod 2 * (?l mod 2) + 2 * and (?k div 2) (?l div 2)
### Code generator: dropping subsumed code equation
### or ?k ?l ==
### if ?k = - 1 | ?l = - 1 then - 1
### else if ?k = 0 then ?l
###      else if ?l = 0 then ?k
###           else max (?k mod 2) (?l mod 2) + 2 * or (?k div 2) (?l div 2)
### Code generator: dropping subsumed code equation
### xor ?k ?l ==
### if ?k = - 1 then not ?l
### else if ?l = - 1 then not ?k
###      else if ?k = 0 then ?l
###           else if ?l = 0 then ?k
###                else \<bar>?k mod 2 - ?l mod 2\<bar> +
###                     2 * xor (?k div 2) (?l div 2)
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
### theory "Native_Word.Bits_Integer"
### 1.198s elapsed time, 4.417s cpu time, 0.842s GC time
(if ?x <= ?y then if ?x = ?y then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y = ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y <= ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?x < ?y then ?Q else ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x <= ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y < ?x then ?R else ?P) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x = ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y = ?x then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y < ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x < ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y <= ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x <= ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
MPoly (mapping_of ?x) = ?x
?y : UNIV ==> mapping_of (MPoly ?y) = ?y
(mapping_of ?x = mapping_of ?y) = (?x = ?y)
[| ?x : UNIV; ?y : UNIV |] ==> (MPoly ?x = MPoly ?y) = (?x = ?y)
[| ?y : UNIV; !!x. ?P (mapping_of x) |] ==> ?P ?y
(!!y. y : UNIV ==> ?P (MPoly y)) ==> ?P ?x
[| ?y : UNIV; !!x. ?y = mapping_of x ==> ?P |] ==> ?P
(!!y. [| ?x = MPoly y; y : UNIV |] ==> ?P) ==> ?P
instantiation
  poly_mapping :: (type, add_linorder) lcs_powerprod
  lcs_poly_mapping == lcs ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
### Cannot skip proof of schematic goal statement
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
"(Gcd (coeffs
        (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
          6 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
          8)),
  sdiv
   (Gcd (coeffs
          (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
            6 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
            8)))
   (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
    M [(1::'b) + (1::'b), 0::'b, (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
     6 +
    M [(1::'b) + (1::'b), 0::'b,
       (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
     8))"
  :: "'a * 'a mpoly"
carrier (| carrier = ?carrier, ... = ?more |) = ?carrier
partial_object.more (| carrier = ?carrier, ... = ?more |) = ?more
carrier_update ?carrier' (| carrier = ?carrier, ... = ?more |) =
(| carrier = ?carrier' ?carrier, ... = ?more |)
partial_object.more_update ?more' (| carrier = ?carrier, ... = ?more |) =
(| carrier = ?carrier, ... = ?more' ?more |)
(\<otimes>\<^bsub>(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |)\<^esub>) =
?mult
\<one>\<^bsub>(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |)\<^esub> =
?one
monoid.more
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
?more
mult_update ?mult'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult' ?mult, one = ?one, ... = ?more |)
one_update ?one'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult, one = ?one' ?one, ... = ?more |)
monoid.more_update ?more'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more' ?more |)
[| ?M <= carrier G; ?g : carrier G; ?h : carrier G |]
==> ?M #>\<^bsub>add_monoid G\<^esub> ?g #>\<^bsub>add_monoid G\<^esub> ?h =
    ?M #>\<^bsub>add_monoid G\<^esub> ?g \<oplus> ?h
[| abelian_group ?G; ?M <= carrier ?G; ?g : carrier ?G; ?h : carrier ?G |]
==> ?M +>\<^bsub>?G\<^esub> ?g +>\<^bsub>?G\<^esub> ?h =
    ?M +>\<^bsub>?G\<^esub> ?g \<oplus>\<^bsub>?G\<^esub> ?h
essentially_equal ?G ?fs1.0 ?fs2.0 =
(EX fs1'. mset ?fs1.0 = mset fs1' & fs1' [\<sim>]\<^bsub>?G\<^esub> ?fs2.0)
### theory "Polynomials.Power_Products"
### 15.593s elapsed time, 59.338s cpu time, 17.368s GC time
Loading theory "Polynomials.MPoly_Type_Class" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection")
### theory "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl"
### 1.797s elapsed time, 6.500s cpu time, 1.461s GC time
Loading theory "Berlekamp_Zassenhaus.Matrix_Record_Based" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based")
locale mat_space
  fixes f_ty :: "'a itself"
    and nc :: "nat"
    and nr :: "nat"
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
locale field_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "field_ops ops R"
### theory "Berlekamp_Zassenhaus.Matrix_Record_Based"
### 4.344s elapsed time, 16.341s cpu time, 12.890s GC time
(%n. mset (prime_factorization_nat n)) = prime_factorization
### Ambiguous input (line 1415 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
### Ambiguous input (line 1454 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1463 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("\<^const>Series.suminf_binder" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("_Sum_any" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
"''-3 * [x = 2] + 2x^2 * (-2) ^ x + (-1 + 2x) * (-1) ^ x''"
  :: "char list"
resultant = resultant_impl_basic
gcd = gcd_impl_Lazard
### theory "Polynomials.MPoly_Type_Class"
### 6.032s elapsed time, 22.635s cpu time, 13.993s GC time
Loading theory "Factor_Algebraic_Polynomial.MPoly_Container" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant")
Loading theory "Factor_Algebraic_Polynomial.Poly_Connection" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant")
locale idom_vec
  fixes n :: "nat"
    and f_ty :: "'a itself"
deriving "ceq" instance for type "Poly_Mapping.poly_mapping" via "="
derived is_ceq_poly_mapping-lemma
use dlist as set_impl for type poly_mapping
registered poly_mapping in class set_impl
use None as trivial implementation of ccompare for type poly_mapping
registered poly_mapping in class ccompare
### theory "Factor_Algebraic_Polynomial.MPoly_Container"
### 3.988s elapsed time, 15.390s cpu time, 12.632s GC time
Loading theory "Polynomials.MPoly_Type_Class_Ordered" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code" via "Polynomials.MPoly_Type_Class_FMap")
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
class the_min = linorder +
  fixes the_min :: "'a"
  assumes "the_min_min": "!!x. the_min <= x"
instantiation
  nat :: the_min
  the_min_nat == the_min :: nat
instantiation
  unit :: the_min
  the_min_unit == the_min :: unit
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
### Ambiguous input (line 246 of "$AFP/Factor_Algebraic_Polynomial/Poly_Connection.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" mpoly_to_mpoly_poly)
###       ("_cargs" ("_position" x) ("_position" p)))
###     ("\<^const>Series.suminf_binder" ("_position" m)
###       ("_applC" ("_position" Polynomial.monom)
###         ("_cargs"
###           ("_applC" ("_position" MPoly_Type.monom)
###             ("_cargs"
###               ("_applC" ("_position" remove_key)
###                 ("_cargs" ("_position" x) ("_position" m)))
###               ("_applC" ("_position" MPoly_Type.coeff)
###                 ("_cargs" ("_position" p) ("_position" m)))))
###           ("_applC" ("_position" lookup)
###             ("_cargs" ("_position" m) ("_position" x))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" mpoly_to_mpoly_poly)
###       ("_cargs" ("_position" x) ("_position" p)))
###     ("_Sum_any" ("_position" m)
###       ("_applC" ("_position" Polynomial.monom)
###         ("_cargs"
###           ("_applC" ("_position" MPoly_Type.monom)
###             ("_cargs"
###               ("_applC" ("_position" remove_key)
###                 ("_cargs" ("_position" x) ("_position" m)))
###               ("_applC" ("_position" MPoly_Type.coeff)
###                 ("_cargs" ("_position" p) ("_position" m)))))
###           ("_applC" ("_position" lookup)
###             ("_cargs" ("_position" m) ("_position" x))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale transfer_mpoly_to_mpoly_poly
  fixes x :: "nat"
"(215912063945802350977 / 152672884556058511392,
  1104427674243920646305299201 / 23309009678667569523128057147486993777664,
  True)"
  :: "rat * rat * bool"
### theory "Factor_Algebraic_Polynomial.Poly_Connection"
### 5.265s elapsed time, 20.357s cpu time, 13.044s GC time
Loading theory "Factor_Algebraic_Polynomial.MPoly_Divide" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code")
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
instantiation
  mpoly :: (comm_semiring_1) divide
  divide_mpoly == divide :: 'a mpoly => 'a mpoly => 'a mpoly
### theory "Jordan_Normal_Form.VS_Connect"
### 16.762s elapsed time, 63.463s cpu time, 30.534s GC time
Loading theory "Jordan_Normal_Form.Matrix_Kernel" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based")
instantiation
  mpoly :: ({idom,normalization_semidom}) normalization_semidom
  normalize_mpoly == normalize :: 'a mpoly => 'a mpoly
  unit_factor_mpoly == unit_factor :: 'a mpoly => 'a mpoly
locale kernel
  fixes nr :: "nat"
    and nc :: "nat"
    and A :: "'a mat"
  assumes "Matrix_Kernel.kernel nr nc A"
### theory "Factor_Algebraic_Polynomial.MPoly_Divide"
### 0.523s elapsed time, 2.031s cpu time, 0.208s GC time
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
### Cannot skip proof of schematic goal statement
locale vardim
  fixes f_ty :: "'a itself"
### theory "Jordan_Normal_Form.Matrix_Kernel"
### 2.219s elapsed time, 6.759s cpu time, 0.825s GC time
Loading theory "Berlekamp_Zassenhaus.Berlekamp_Type_Based" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization")
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
consts
  berlekamp_factorization_main ::
    "nat
     => 'a mod_ring poly list
        => 'a mod_ring poly list => nat => 'a mod_ring poly list"
### Cannot skip proof of schematic goal statement
locale gd_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "gd_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "od_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
### theory "Polynomials.MPoly_Type_Class_Ordered"
### 7.544s elapsed time, 20.908s cpu time, 2.530s GC time
### theory "Berlekamp_Zassenhaus.Berlekamp_Type_Based"
### 4.312s elapsed time, 8.528s cpu time, 1.253s GC time
Loading theory "Berlekamp_Zassenhaus.Distinct_Degree_Factorization" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization")
locale poly_mod_type_irr
  fixes m :: "int"
    and f :: "'a mod_ring poly"
  assumes "poly_mod_type_irr m f"
### theory "Berlekamp_Zassenhaus.Distinct_Degree_Factorization"
### 0.938s elapsed time, 1.046s cpu time, 0.159s GC time
Loading theory "Berlekamp_Zassenhaus.Finite_Field_Factorization" (required by "Draft.Linear_Recurrences_TestTemplates" via "Draft.Linear_Recurrences_Test" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based")
overloading
  use_distinct_degree_factorization \<equiv>
    use_distinct_degree_factorization :: bool
### theory "Berlekamp_Zassenhaus.Finite_Field_Factorization"
### 0.081s elapsed time, 0.081s cpu time, 0.000s GC time
*** Failed to load theory "Polynomials.Poly_Mapping_Finite_Map" (unresolved "HOL-Library.Finite_Map")
*** Failed to load theory "Native_Word.Code_Target_Bits_Int" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Native_Word.Code_Target_Word_Base" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Native_Word.Word_Type_Copies" (unresolved "Native_Word.Code_Target_Word_Base")
*** Failed to load theory "Native_Word.Uint32" (unresolved "Native_Word.Code_Target_Word_Base", "Native_Word.Word_Type_Copies")
*** Failed to load theory "Native_Word.Uint64" (unresolved "Native_Word.Code_Target_Word_Base", "Native_Word.Word_Type_Copies")
*** Failed to load theory "Berlekamp_Zassenhaus.Finite_Field_Record_Based" (unresolved "Native_Word.Code_Target_Bits_Int", "Native_Word.Uint32", "Native_Word.Uint64")
*** Failed to load theory "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" (unresolved "Berlekamp_Zassenhaus.Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Hensel_Lifting" (unresolved "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Mahler_Measure" (unresolved "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Factor_Bound" (unresolved "Berlekamp_Zassenhaus.Mahler_Measure")
*** Failed to load theory "Berlekamp_Zassenhaus.Suitable_Prime" (unresolved "Berlekamp_Zassenhaus.Finite_Field_Record_Based", "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Gcd_Finite_Field_Impl" (unresolved "Berlekamp_Zassenhaus.Suitable_Prime")
*** Failed to load theory "Berlekamp_Zassenhaus.Square_Free_Factorization_Int" (unresolved "Berlekamp_Zassenhaus.Gcd_Finite_Field_Impl", "Berlekamp_Zassenhaus.Suitable_Prime")
*** Failed to load theory "Polynomials.MPoly_Type_Class_FMap" (unresolved "Polynomials.Poly_Mapping_Finite_Map")
*** Failed to load theory "Factor_Algebraic_Polynomial.MPoly_Divide_Code" (unresolved "Polynomials.MPoly_Type_Class_FMap")
*** Failed to load theory "Factor_Algebraic_Polynomial.Multivariate_Resultant" (unresolved "Factor_Algebraic_Polynomial.MPoly_Divide_Code")
*** Failed to load theory "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" (unresolved "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Berlekamp_Hensel" (unresolved "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based", "Berlekamp_Zassenhaus.Hensel_Lifting")
*** Failed to load theory "Berlekamp_Zassenhaus.Reconstruction" (unresolved "Berlekamp_Zassenhaus.Berlekamp_Hensel", "Berlekamp_Zassenhaus.Factor_Bound")
*** Failed to load theory "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" (unresolved "Berlekamp_Zassenhaus.Berlekamp_Hensel", "Berlekamp_Zassenhaus.Reconstruction", "Berlekamp_Zassenhaus.Suitable_Prime")
*** Failed to load theory "Berlekamp_Zassenhaus.Factorize_Int_Poly" (unresolved "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus", "Berlekamp_Zassenhaus.Square_Free_Factorization_Int")
*** Failed to load theory "Algebraic_Numbers.Factors_of_Int_Poly" (unresolved "Berlekamp_Zassenhaus.Factorize_Int_Poly")
*** Failed to load theory "Algebraic_Numbers.Real_Algebraic_Numbers" (unresolved "Algebraic_Numbers.Factors_of_Int_Poly")
*** Failed to load theory "Algebraic_Numbers.Real_Roots" (unresolved "Algebraic_Numbers.Real_Algebraic_Numbers")
*** Failed to load theory "Algebraic_Numbers.Show_Real_Alg" (unresolved "Algebraic_Numbers.Real_Algebraic_Numbers")
*** Failed to load theory "Algebraic_Numbers.Show_Real_Precise" (unresolved "Algebraic_Numbers.Show_Real_Alg")
*** Failed to load theory "Algebraic_Numbers.Complex_Algebraic_Numbers" (unresolved "Algebraic_Numbers.Real_Roots")
*** Failed to load theory "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" (unresolved "Algebraic_Numbers.Complex_Algebraic_Numbers", "Factor_Algebraic_Polynomial.Multivariate_Resultant")
*** Failed to load theory "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" (unresolved "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly", "Polynomials.MPoly_Type_Class_FMap")
*** Failed to load theory "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" (unresolved "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl")
*** Failed to load theory "Factor_Algebraic_Polynomial.Factor_Complex_Poly" (unresolved "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly")
*** Failed to load theory "Draft.Linear_Recurrences_Solver" (unresolved "Factor_Algebraic_Polynomial.Factor_Complex_Poly")
*** Failed to load theory "Draft.Linear_Recurrences_Test" (unresolved "Algebraic_Numbers.Show_Real_Precise", "Draft.Linear_Recurrences_Solver")
*** Failed to load theory "Draft.Linear_Recurrences_TestTemplates" (unresolved "Draft.Linear_Recurrences_Test")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "4")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 653 of "$AFP/Native_Word/Bits_Integer.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "2")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 1440 of "~~/src/HOL/Library/Finite_Map.thy")
Exception- TOPLEVEL_ERROR raised
