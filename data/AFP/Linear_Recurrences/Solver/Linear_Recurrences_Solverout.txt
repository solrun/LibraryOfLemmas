Loading theory "Containers.Equal" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set")
Loading theory "Pure-ex.Guess" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library" via "Sturm_Sequences.Misc_Polynomial")
Loading theory "Containers.List_Fusion" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
Loading theory "Containers.Extend_Partial_Order" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder")
locale equal_base
  fixes equal :: "'a => 'a => bool"
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
### theory "Containers.Equal"
### 0.033s elapsed time, 0.129s cpu time, 0.000s GC time
Loading theory "Containers.Closure_Set" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
locale equal_base
  fixes equal :: "'a => 'a => bool"
### ML warning (line 99 of "~~/src/Pure/ex/Guess.thy"):
### Pattern is not exhaustive.
### ML warning (line 150 of "~~/src/Pure/ex/Guess.thy"):
### Matches are not exhaustive.
### ML warning (line 157 of "~~/src/Pure/ex/Guess.thy"):
### Pattern is not exhaustive.
signature GUESS =
  sig
    val guess:
       (binding * typ option * mixfix) list ->
         bool -> Proof.state -> Proof.state
    val guess_cmd:
       (binding * string option * mixfix) list ->
         bool -> Proof.state -> Proof.state
  end
structure Guess: GUESS
### theory "Pure-ex.Guess"
### 0.066s elapsed time, 0.243s cpu time, 0.022s GC time
Proofs for inductive predicate(s) "terminates_onp"
Loading theory "Deriving.Comparator" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
  Proving monotonicity ...
### theory "Containers.Closure_Set"
### 0.043s elapsed time, 0.143s cpu time, 0.022s GC time
Loading theory "Deriving.Derive_Manager" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
signature DERIVE_MANAGER =
  sig
    val derive: string -> string -> string -> theory -> theory
    val derive_cmd: string -> string -> string -> theory -> theory
    val print_info: theory -> unit
    val register_derive:
       string ->
         string ->
           (string -> string -> theory -> theory) -> theory -> theory
  end
structure Derive_Manager: DERIVE_MANAGER
### theory "Deriving.Derive_Manager"
### 0.036s elapsed time, 0.185s cpu time, 0.000s GC time
Loading theory "Deriving.Generator_Aux" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator" via "Deriving.Comparator_Generator")
signature BNF_ACCESS =
  sig
    val bnf_types: Proof.context -> string list -> typ list
    val case_consts: Proof.context -> string list -> term list
    val case_simps: Proof.context -> string list -> thm list list
    val case_thms: Proof.context -> string list -> thm list
    val constr_argument_types:
       Proof.context -> string list -> typ list list list
    val constr_terms: Proof.context -> string -> term list
    val distinct_thms: Proof.context -> string list -> thm list list
    val induct_thms: Proof.context -> string list -> thm list
    val inject_thms: Proof.context -> string list -> thm list list
    val map_comps: Proof.context -> string list -> thm list
    val map_simps: Proof.context -> string list -> thm list list
    val map_terms: Proof.context -> string list -> term list
    val set_simps: Proof.context -> string list -> thm list list
    val set_terms: Proof.context -> string list -> term list list
  end
structure Bnf_Access: BNF_ACCESS
### theory "Containers.Extend_Partial_Order"
### 0.170s elapsed time, 0.690s cpu time, 0.022s GC time
Loading theory "HOL-Library.AList" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Factorization.Precomputation" via "HOL-Library.RBT_Mapping" via "HOL-Library.Mapping")
signature GENERATOR_AUX =
  sig
    val OF_option: thm -> thm option list -> thm
    val add_used_tycos:
       Proof.context -> string -> string list -> string list
    val alist_to_string: (string * 'a) list -> string
    val conjI_tac:
       thm list ->
         Proof.context ->
           'a list -> (Proof.context -> int -> tactic) -> tactic
    val create_map:
       (typ -> term) ->
         (string * typ -> 'a -> term) ->
           'a ->
             (typ -> bool) ->
               (local_theory -> string -> bool list) ->
                 (local_theory -> string -> term) ->
                   (local_theory -> string -> 'a -> term) ->
                     string list ->
                       (local_theory -> string -> 'a) ->
                         typ -> local_theory -> term
    val create_partial:
       'a ->
         (typ -> bool) ->
           (local_theory -> string -> bool list) ->
             (local_theory -> string -> term) ->
               (local_theory -> string -> 'a -> term) ->
                 string list ->
                   (local_theory -> string -> 'a) ->
                     typ -> local_theory -> term
    val define_overloaded:
       string * term -> local_theory -> thm * local_theory
    val define_overloaded_generic:
       Attrib.binding * term -> local_theory -> thm * local_theory
    val drop_last: 'a list -> 'a list
    val freeify_tvars: typ -> typ
    val ind_case_to_idxs: 'a list list -> int -> int * int
    val infer_type: Proof.context -> term -> term
    val ints_to_subscript: int list -> string
    val is_class_instance: theory -> string -> sort -> bool
    val lambdas: term list -> term -> term
    val mk_case_tac:
       Proof.context ->
         term option list list ->
           thm ->
             (int ->
                Proof.context * thm list * (string * cterm) list -> tactic)
               -> tactic
    val mk_def: typ -> string -> term -> term
    val mk_id: typ -> term
    val mk_infer_const: string -> Proof.context -> term -> term
    val mutual_recursive_types:
       string -> Proof.context -> string list * typ list
    val prove_multi_future:
       Proof.context ->
         string list ->
           term list ->
             term list ->
               ({context: Proof.context, prems: thm list} -> tactic) ->
                 thm list
    val recursor:
       (string -> 'a) * ('a -> bool list) * string list ->
         bool ->
           (typ -> 'b) ->
             (typ -> 'b) ->
               (typ -> 'b) ->
                 ((typ * 'b option) list * 'a -> 'b) -> typ -> 'b
    val rename_types: (typ * typ) list -> term -> term
    val split_IHs:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list -> thm list -> thm list list
    val std_recursor_tac:
       (string -> 'a) * ('a -> bool list) * string list ->
         typ list ->
           ('a -> thm) ->
             thm list -> typ -> thm list -> Proof.context -> tactic
    val sub: string -> string
    val subT: string -> typ -> string
    val typ_and_vs_of_typname:
       theory -> string -> sort -> typ * (string * sort) list
    val typ_and_vs_of_used_typname:
       string ->
         bool list -> string list -> typ * (string * string list) list
    val type_parameters:
       typ -> Proof.context -> (string * sort) list * typ list
  end
structure Generator_Aux: GENERATOR_AUX
### theory "Deriving.Generator_Aux"
### 0.130s elapsed time, 0.501s cpu time, 0.070s GC time
Loading theory "Deriving.Equality_Generator" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set" via "Containers.Collection_Eq" via "Deriving.Equality_Instances")
consts
  update :: "'key => 'val => ('key * 'val) list => ('key * 'val) list"
locale list
  fixes g :: "('a, 's) generator"
consts
  list_has_next :: "'a list => bool"
### No equation for constructor "[]"
consts
  list_next :: "'a list => 'a * 'a list"
consts
  update_with_aux ::
    "'val
     => 'key => ('val => 'val) => ('key * 'val) list => ('key * 'val) list"
Found termination order: "{}"
locale comparator
  fixes comp :: "'a => 'a => order"
  assumes "comparator comp"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
signature EQUALITY_GENERATOR =
  sig
    val ensure_info: equality_type -> string -> local_theory -> local_theory
    datatype equality_type = BNF | EQ
    val generate_equality:
       equality_type -> string -> local_theory -> local_theory
    val generate_equalitys_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {equality: term,
        equality_def: thm option,
        equality_thm: thm,
        map: term,
        map_comp: thm option,
        partial_equality_thm: thm,
        pequality: term, used_positions: bool list}
    val register_equality_of: string -> local_theory -> local_theory
    val register_foreign_equality:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_equality:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm -> thm -> bool list -> local_theory -> local_theory
  end
structure Equality_Generator: EQUALITY_GENERATOR
### theory "Deriving.Equality_Generator"
### 0.265s elapsed time, 1.040s cpu time, 0.073s GC time
Loading theory "Deriving.Equality_Instances" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set" via "Containers.Collection_Eq")
generating equality for type "Sum_Type.sum"
generating equality for type "List.list"
generating equality for type "Product_Type.prod"
generating equality for type "Option.option"
### theory "Deriving.Equality_Instances"
### 0.100s elapsed time, 0.378s cpu time, 0.056s GC time
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Auxiliary" via "HOL-Library.Monad_Syntax")
Found termination order: "case_sum (%x. Suc 0) (%x. 0) <*mlex*> {}"
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.070s elapsed time, 0.278s cpu time, 0.000s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum" via "Containers.Containers_Auxiliary")
### theory "Deriving.Comparator"
### 0.641s elapsed time, 2.531s cpu time, 0.200s GC time
Loading theory "Deriving.Compare" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator")
### theory "HOL-Library.Monad_Syntax"
### 0.034s elapsed time, 0.138s cpu time, 0.000s GC time
Loading theory "Deriving.Comparator_Generator" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat" via "Deriving.Compare_Generator")
Proofs for inductive predicate(s) "filter_has_next"
class compare = type +
  fixes compare :: "'a => 'a => order"
  assumes "comparator_compare": "comparator compare"
  Proving monotonicity ...
class compare_order = compare + ord +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
### theory "Containers.List_Fusion"
### 1.068s elapsed time, 4.044s cpu time, 0.657s GC time
Loading theory "Containers.Containers_Auxiliary" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum")
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod" (infix \<open>\<sqsubset>\<close> 50)
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
Found termination order:
  "(%p. size_list size (snd (snd (snd p)))) <*mlex*> {}"
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
### theory "Containers.Containers_Auxiliary"
### 0.211s elapsed time, 0.821s cpu time, 0.084s GC time
Loading theory "Efficient-Mergesort.Efficient_Sort" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Reconstruction" via "Berlekamp_Zassenhaus.Degree_Bound")
### theory "HOL-Library.AList"
### 1.116s elapsed time, 4.203s cpu time, 0.719s GC time
Loading theory "HOL-Number_Theory.Cong" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues")
class compare_order = compare + linorder +
  assumes "ord_defs": "le_of_comp compare = (<=)" "lt_of_comp compare = (<)"
signature COMPARATOR_GENERATOR =
  sig
    datatype comparator_type = BNF | Linorder
    val ensure_info:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparator:
       comparator_type -> string -> local_theory -> local_theory
    val generate_comparators_from_bnf_fp:
       string ->
         local_theory ->
           ((term * thm list) list * (term * thm) list) * local_theory
    val get_info: Proof.context -> string -> info option
    type info =
       {comp: term,
        comp_def: thm option,
        comp_thm: thm,
        map: term,
        map_comp: thm option,
        partial_comp_thms: thm list, pcomp: term, used_positions: bool list}
    val register_comparator_of: string -> local_theory -> local_theory
    val register_foreign_comparator:
       typ -> term -> thm -> local_theory -> local_theory
    val register_foreign_partial_and_full_comparator:
       string ->
         term ->
           term ->
             term ->
               thm option ->
                 thm option ->
                   thm ->
                     thm ->
                       thm ->
                         thm -> bool list -> local_theory -> local_theory
  end
structure Comparator_Generator: COMPARATOR_GENERATOR
### theory "Deriving.Comparator_Generator"
### 0.755s elapsed time, 2.803s cpu time, 0.605s GC time
Loading theory "HOL-Library.Char_ord" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder" via "Containers.Lexicographic_Order")
instantiation
  char :: linorder
  less_eq_char == less_eq :: char => char => bool
  less_char == less :: char => char => bool
class unique_euclidean_semiring = euclidean_semiring_cancel +
  fixes division_segment :: "'a => 'a"
  assumes
    "euclidean_size_mult":
      "!!a b. euclidean_size (a * b) = euclidean_size a * euclidean_size b"
  assumes "is_unit_division_segment": "!!a. is_unit (division_segment a)"
    and
    "division_segment_mult":
      "!!a b.
          [| a ~= (0::'a); b ~= (0::'a) |]
          ==> division_segment (a * b) =
              division_segment a * division_segment b"
    and
    "division_segment_mod":
      "!!b a.
          [| b ~= (0::'a); ~ b dvd a |]
          ==> division_segment (a mod b) = division_segment b"
  assumes
    "div_bounded":
      "!!b r q.
          [| b ~= (0::'a); division_segment r = division_segment b;
             euclidean_size r < euclidean_size b |]
          ==> (q * b + r) div b = q"
signature COMPARE_CODE =
  sig
    val change_compare_code:
       term -> string list -> local_theory -> local_theory
  end
structure Compare_Code: COMPARE_CODE
### theory "Deriving.Compare"
### 0.797s elapsed time, 2.967s cpu time, 0.605s GC time
Loading theory "Deriving.Compare_Generator" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Deriving.Compare_Rat")
instantiation
  char :: distrib_lattice
  inf_char == inf :: char => char => char
  sup_char == sup :: char => char => char
### theory "HOL-Library.Char_ord"
### 0.085s elapsed time, 0.313s cpu time, 0.054s GC time
Loading theory "Containers.Lexicographic_Order" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order" via "Containers.Set_Linorder")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Containers.Lexicographic_Order"
### 0.253s elapsed time, 0.988s cpu time, 0.062s GC time
Loading theory "HOL-Library.Conditional_Parametricity" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code" via "Polynomials.MPoly_Type_Class_FMap" via "Polynomials.Poly_Mapping_Finite_Map" via "HOL-Library.Finite_Map")
signature COMPARE_GENERATOR =
  sig
    val compare_instance:
       Comparator_Generator.comparator_type -> string -> theory -> theory
    val compare_order_instance_via_comparator_of: string -> theory -> theory
    val compare_order_instance_via_compare: string -> theory -> theory
  end
structure Compare_Generator: COMPARE_GENERATOR
### theory "Deriving.Compare_Generator"
### 0.304s elapsed time, 1.174s cpu time, 0.116s GC time
Loading theory "Deriving.Compare_Instances" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order")
Found termination order:
  "case_sum length
    (case_sum (%p. length (snd (snd p)))
      (%p. length (snd (snd p)))) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. 0) (%x. Suc 0)) <*mlex*> {}"
deriving "compare_order" instance for type "Int.int"
deriving "compare" instance for type "Int.int"
deriving "compare_order" instance for type "Code_Numeral.integer"
deriving "compare" instance for type "Code_Numeral.integer"
deriving "compare_order" instance for type "Nat.nat"
deriving "compare" instance for type "Nat.nat"
deriving "compare_order" instance for type "String.char"
deriving "compare" instance for type "String.char"
deriving "compare" instance for type "Sum_Type.sum"
generating comparator for type "Sum_Type.sum"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
deriving "compare" instance for type "List.list"
generating comparator for type "List.list"
deriving "compare" instance for type "Product_Type.prod"
generating comparator for type "Product_Type.prod"
deriving "compare" instance for type "Option.option"
generating comparator for type "Option.option"
Found termination order: "size_list length <*mlex*> {}"
signature CONDITIONAL_PARAMETRICITY =
  sig
    exception WARNING of string
    val default_settings: settings
    val get_parametricity_theorems: Proof.context -> thm list
    val mk_cond_goal: Proof.context -> thm -> term * thm
    val mk_goal: Proof.context -> term -> term
    val mk_param_goal_from_eq_def: Proof.context -> thm -> term
    val parametric_constant:
       settings ->
         Attrib.binding * thm -> Proof.context -> thm * Proof.context
    val prove_find_goal_cond:
       settings -> Proof.context -> thm list -> thm option -> term -> thm
    val prove_goal: settings -> Proof.context -> thm option -> term -> thm
    val quiet_settings: settings
    type settings =
       {suppress_print_theorem: bool,
        suppress_warnings: bool,
        use_equality_heuristic: bool, warnings_as_errors: bool}
    val step_tac: settings -> Proof.context -> thm list -> int -> tactic
  end
structure Conditional_Parametricity: CONDITIONAL_PARAMETRICITY
### theory "HOL-Library.Conditional_Parametricity"
### 0.333s elapsed time, 1.285s cpu time, 0.124s GC time
Loading theory "HOL-Library.Fun_Lexorder" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate" via "Polynomials.More_MPoly_Type" via "Polynomials.MPoly_Type" via "HOL-Library.Poly_Mapping")
### theory "HOL-Number_Theory.Cong"
### 0.847s elapsed time, 3.263s cpu time, 0.325s GC time
Loading theory "HOL-Algebra.Congruence" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice" via "HOL-Algebra.Order")
Found termination order: "{}"
### theory "HOL-Library.Fun_Lexorder"
### 0.047s elapsed time, 0.191s cpu time, 0.000s GC time
Loading theory "HOL-Combinatorics.List_Permutation" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization" via "HOL-Algebra.Divisibility")
Found termination order: "{}"
deriving "compare" instance for type "HOL.bool"
deriving "compare" instance for type "Product_Type.unit"
deriving "compare_order" instance for type "HOL.bool"
deriving "compare_order" instance for type "Product_Type.unit"
### theory "Deriving.Compare_Instances"
### 0.431s elapsed time, 1.678s cpu time, 0.124s GC time
Loading theory "Jordan_Normal_Form.Missing_Misc" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring")
### theory "HOL-Combinatorics.List_Permutation"
### 0.073s elapsed time, 0.290s cpu time, 0.000s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Found termination order: "length <*mlex*> {}"
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "{}"
### theory "Jordan_Normal_Form.Missing_Misc"
### 0.334s elapsed time, 1.179s cpu time, 0.817s GC time
Loading theory "HOL-Library.Groups_Big_Fun" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate" via "Polynomials.More_MPoly_Type" via "Polynomials.MPoly_Type" via "HOL-Library.Poly_Mapping")
locale comm_monoid_fun
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_fun (\<^bold>*) \<^bold>1"
### theory "HOL-Library.Function_Algebras"
### 0.355s elapsed time, 1.259s cpu time, 0.817s GC time
Loading theory "HOL-Library.IArray" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
### theory "Efficient-Mergesort.Efficient_Sort"
### 1.413s elapsed time, 5.349s cpu time, 1.222s GC time
Loading theory "Abstract-Rewriting.Seq" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting")
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### Cannot skip proof of schematic goal statement
locale infinitely_many
  fixes p :: "nat => bool"
  assumes "infinitely_many p"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
### Cannot skip proof of schematic goal statement
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Groups_Big_Fun"
### 0.273s elapsed time, 1.064s cpu time, 0.080s GC time
Loading theory "HOL-Library.Ramsey" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences" via "Well_Quasi_Orders.Almost_Full")
locale equivalence
  fixes S :: "('a, 'b) eq_object_scheme"  (structure)
  assumes "equivalence S"
locale partition
  fixes A :: "'a set"
    and B :: "'a set set"
  assumes "Congruence.partition A B"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Abstract-Rewriting.Seq"
### 0.339s elapsed time, 1.336s cpu time, 0.115s GC time
Loading theory "HOL-Library.Mapping" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Factorization.Precomputation" via "HOL-Library.RBT_Mapping")
consts
  list_of :: "'a iarray => 'a list"
### theory "HOL-Algebra.Congruence"
### 0.930s elapsed time, 3.515s cpu time, 1.012s GC time
Loading theory "HOL-Algebra.Order" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice")
consts
  tabulate :: "integer * (integer => 'a) => 'a iarray"
consts
  sub' :: "'a iarray * integer => 'a"
### theory "HOL-Library.IArray"
### 0.568s elapsed time, 2.196s cpu time, 0.328s GC time
Loading theory "Berlekamp_Zassenhaus.Arithmetic_Record_Based" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Matrix_Record_Based")
consts
  choice :: "('a => bool) => ('a * 'a) set => nat => 'a"
### theory "HOL-Library.Ramsey"
### 0.419s elapsed time, 1.622s cpu time, 0.248s GC time
Loading theory "HOL-Library.Poly_Mapping" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate" via "Polynomials.More_MPoly_Type" via "Polynomials.MPoly_Type")
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
instantiation
  mapping :: (type, type) equal
  equal_mapping == equal_class.equal ::
    ('a, 'b) mapping => ('a, 'b) mapping => bool
class zero = type +
  fixes zero :: "'a"
class monoid_add = semigroup_add + zero +
  assumes "add_0_left": "!!a. (0::'a) + a = a"
    and "add_0_right": "!!a. a + (0::'a) = a"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class group_add = cancel_semigroup_add + minus + monoid_add + uminus +
  assumes "left_minus": "!!a. - a + a = (0::'a)"
  assumes "add_uminus_conv_diff": "!!a b. a + - b = a - b"
class mult_zero = times + zero +
  assumes "mult_zero_left": "!!a. (0::'a) * a = (0::'a)"
  assumes "mult_zero_right": "!!a. a * (0::'a) = (0::'a)"
locale partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "partial_order L"
locale combine_mapping_abel_semigroup
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "combine_mapping_abel_semigroup (\<^bold>*)"
instantiation
  poly_mapping :: (type, zero) zero
  zero_poly_mapping == zero_class.zero :: 'a \<Rightarrow>\<^sub>0 'b
locale weak_partial_order_bottom
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_bottom L"
instantiation
  poly_mapping :: (type, monoid_add) monoid_add
  plus_poly_mapping == plus ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
locale weak_partial_order_top
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_top L"
instantiation
  poly_mapping :: (type, cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_poly_mapping == minus ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
locale weak_total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_total_order L"
instantiation
  poly_mapping :: (type, ab_group_add) ab_group_add
  uminus_poly_mapping == uminus ::
    ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  poly_mapping :: (zero, zero_neq_one) zero_neq_one
  one_poly_mapping == one_class.one :: 'a \<Rightarrow>\<^sub>0 'b
locale total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "total_order L"
### theory "HOL-Algebra.Order"
### 0.864s elapsed time, 3.366s cpu time, 0.506s GC time
Loading theory "HOL-Algebra.Lattice" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice")
instantiation
  poly_mapping :: (monoid_add, semiring_0) semiring_0
  times_poly_mapping == times ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
instantiation
  poly_mapping :: (linorder, {zero,linorder}) linorder
  less_eq_poly_mapping == less_eq ::
    ('a \<Rightarrow>\<^sub>0 'b) => ('a \<Rightarrow>\<^sub>0 'b) => bool
  less_poly_mapping == less ::
    ('a \<Rightarrow>\<^sub>0 'b) => ('a \<Rightarrow>\<^sub>0 'b) => bool
### theory "HOL-Library.Mapping"
### 1.047s elapsed time, 4.065s cpu time, 0.615s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.ExtrEqs")
locale weak_upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_upper_semilattice L"
locale weak_lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lower_semilattice L"
locale weak_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lattice L"
instantiation
  poly_mapping :: (type, zero) size
  size_poly_mapping == size :: ('a \<Rightarrow>\<^sub>0 'b) => nat
locale weak_bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_bounded_lattice L"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
locale upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "upper_semilattice L"
locale lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lower_semilattice L"
### theory "HOL-Library.Poly_Mapping"
### 1.394s elapsed time, 5.399s cpu time, 0.888s GC time
Loading theory "Polynomials.MPoly_Type" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate" via "Polynomials.More_MPoly_Type")
locale Lattice.lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lattice L"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Poly_Mapping.poly_mapping" found.
consts
  sdrop :: "nat => 'a stream => 'a stream"
instantiation
  mpoly :: (zero) zero
  zero_mpoly == zero_class.zero :: 'a mpoly
instantiation
  mpoly :: (monoid_add) monoid_add
  plus_mpoly == plus :: 'a mpoly => 'a mpoly => 'a mpoly
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
instantiation
  mpoly :: (cancel_comm_monoid_add) cancel_comm_monoid_add
  minus_mpoly == minus :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: (ab_group_add) ab_group_add
  uminus_mpoly == uminus :: 'a mpoly => 'a mpoly
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
consts
  cycle :: "'a list => 'a stream"
### theory "HOL-Algebra.Lattice"
### 0.928s elapsed time, 3.579s cpu time, 0.631s GC time
Loading theory "HOL-Algebra.Complete_Lattice" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group")
instantiation
  mpoly :: (zero_neq_one) zero_neq_one
  one_mpoly == one_class.one :: 'a mpoly
instantiation
  mpoly :: (semiring_0) semiring_0
  times_mpoly == times :: 'a mpoly => 'a mpoly => 'a mpoly
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale arith_ops
  fixes ops :: "'i arith_ops_record"  (structure)
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
consts
  flat :: "'a list stream => 'a stream"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
locale ring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "ring_ops ops R"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
locale idom_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "idom_ops ops R"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
locale idom_divide_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "idom_divide_ops ops R"
### theory "HOL-Library.Stream"
### 1.056s elapsed time, 4.086s cpu time, 0.656s GC time
Loading theory "Containers.Containers_Generator" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.Collection_Enum")
locale euclidean_semiring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "euclidean_semiring_ops ops R"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
locale euclidean_ring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "euclidean_ring_ops ops R"
### Ambiguous input (line 494 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>div" ("_position" x) ("_position" y))
###     ("_The" ("_position" q')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" q')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" q)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 498 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>mod" ("_position" x) ("_position" y))
###     ("_The" ("_position" r')
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" a) ("_idts" ("_position" q) ("_position" r)))
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" pseudo_divmod_rel)
###             ("_cargs" ("_position" a)
###               ("_cargs" ("_position" x)
###                 ("_cargs" ("_position" y)
###                   ("_cargs" ("_position" q) ("_position" r))))))
###           ("\<^const>HOL.eq" ("_position" r')
###             ("_applC" ("_position" smult)
###               ("_cargs" ("_applC" ("_position" inverse) ("_position" a))
###                 ("_position" r)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 502 of "$AFP/Polynomials/MPoly_Type.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>Rings.modulo_class.modulo" ("_position" p)
###           ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple"
###       ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" divmod)
###       ("_cargs" ("_position" p) ("_position" q)))
###     ("_tuple" ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###       ("_tuple_arg"
###         ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 505 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.divide_class.divide" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.div" ("_position" p) ("_position" q))
###     ("_applC" ("_position" fst)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 509 of "$AFP/Polynomials/MPoly_Type.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Rings.modulo_class.modulo" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>MPoly_Type.mod" ("_position" p) ("_position" q))
###     ("_applC" ("_position" snd)
###       ("_applC" ("_position" divmod)
###         ("_cargs" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale field_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "field_ops ops R"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
### theory "Berlekamp_Zassenhaus.Arithmetic_Record_Based"
### 2.122s elapsed time, 8.229s cpu time, 1.242s GC time
Loading theory "Containers.Set_Linorder" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.Collection_Order")
### theory "Polynomials.MPoly_Type"
### 0.615s elapsed time, 2.379s cpu time, 0.353s GC time
Loading theory "Polynomials.More_MPoly_Type" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Univariate")
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
signature CONTAINERS_GENERATOR =
  sig
    val HOLogic_list_conj: term list -> term
    val all_tys: term -> typ list -> term -> term
    val derive_is_c_dots_lemma:
       typ -> string -> thm list -> string -> theory -> theory
    val derive_none:
       string -> sort -> (typ -> term) -> string -> theory -> theory
    val derive_set_map_impl:
       string ->
         sort ->
           (string * term) list -> string -> string -> theory -> theory
    val is_class_instance: theory -> string -> sort -> bool
    val mk_Some: term -> term
    val mk_is_c_dots: typ -> string -> term
    val register_is_c_dots_lemma:
       string -> string -> thm -> theory -> theory
  end
structure Containers_Generator: CONTAINERS_GENERATOR
### theory "Containers.Containers_Generator"
### 0.478s elapsed time, 1.860s cpu time, 0.251s GC time
Loading theory "Containers.Collection_Enum" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
### theory "Polynomials.More_MPoly_Type"
### 0.333s elapsed time, 1.298s cpu time, 0.147s GC time
Loading theory "Containers.Collection_Eq" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.DList_Set")
### theory "HOL-Algebra.Complete_Lattice"
### 0.827s elapsed time, 3.181s cpu time, 0.514s GC time
Loading theory "HOL-Algebra.Group" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct")
class cenum = type +
  fixes
    cEnum ::
      "('a list * (('a => bool) => bool) * (('a => bool) => bool)) option"
  assumes
    "UNIV_cenum":
      "!!enum enum_all enum_ex.
          cEnum = Some (enum, enum_all, enum_ex) ==> UNIV = set enum"
    and
    "cenum_all_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==>
          enum_all P = Ball UNIV P"
    and
    "cenum_ex_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==> enum_ex P = Bex UNIV P"
signature CENUM_GENERATOR =
  sig val derive_no_cenum: string -> theory -> theory end
structure Cenum_Generator: CENUM_GENERATOR
### Rewrite rule not in simpset:
### Wellfounded.accp all_n_lists_rel (?P1, ?n1) ==>
### all_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_all (%x. all_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class ceq = type +
  fixes ceq :: "('a => 'a => bool) option"
  assumes "ceq": "!!eqa. ceq = Some eqa ==> eqa = (=)"
specification
  finite_complement_partition: finite ?A ==> ?A : infinite_complement_partition
  complement_partition: infinite UNIV ==>
(?A : infinite_complement_partition) =
(- ?A ~: infinite_complement_partition)
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
signature CEQ_GENERATOR =
  sig
    val ceq_instance_via_eq: string -> theory -> theory
    val ceq_instance_via_equality: string -> theory -> theory
    val derive_no_ceq: string -> theory -> theory
  end
structure Ceq_Generator: CEQ_GENERATOR
deriving "ceq" instance for type "Product_Type.unit" via "="
derived is_ceq_unit-lemma
### Rewrite rule not in simpset:
### Wellfounded.accp ex_n_lists_rel (?P1, ?n1) ==>
### ex_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_ex (%x. ex_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
### Code generator: dropping subsumed code equation
### CEQ(unit) == Some (=)
deriving "ceq" instance for type "HOL.bool" via "="
derived is_ceq_bool-lemma
deriving "ceq" instance for type "Nat.nat" via "="
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
derived is_ceq_nat-lemma
deriving "ceq" instance for type "Int.int" via "="
derived is_ceq_int-lemma
deriving "ceq" instance for type "Enum.finite_1" via "="
instantiation
  fun :: (cenum, cenum) cenum
  cEnum_fun == cEnum ::
    (('a => 'b) list *
     ((('a => 'b) => bool) => bool) * ((('a => 'b) => bool) => bool)) option
derived is_ceq_finite_1-lemma
deriving "ceq" instance for type "Enum.finite_2" via "="
derived is_ceq_finite_2-lemma
deriving "ceq" instance for type "Enum.finite_3" via "="
### Ambiguous input (line 136 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" ys)
###                           ("\<^const>Fun.comp" ("_position" the)
###                             ("_applC" ("_position" map_of)
###                               ("_applC" ("_position" zip)
###                                 ("_cargs" ("_position" enum_a)
###                                   ("_position" ys))))))
###                         ("_applC" ("_position" List.n_lists)
###                           ("_cargs"
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))
###                             ("_position" enum_b)))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" all_n_lists)
###                           ("_cargs" ("_position" enum_all_b)
###                             ("_cargs"
###                               ("_lambda" ("_position" bs)
###                                 ("_applC" ("_position" P)
###                                   ("\<^const>Fun.comp" ("_position" the)
###                                     ("_applC" ("_position" map_of)
### ("_applC" ("_position" zip)
###   ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                               ("_applC" ("_position" length)
###                                 ("_position" enum_a))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" ex_n_lists)
###                             ("_cargs" ("_position" enum_ex_b)
###                               ("_cargs"
###                                 ("_lambda" ("_position" bs)
###                                   ("_applC" ("_position" P)
###                                     ("\<^const>Fun.comp" ("_position" the)
### ("_applC" ("_position" map_of)
###   ("_applC" ("_position" zip)
###     ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                                 ("_applC" ("_position" length)
###                                   ("_position" enum_a))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" ys)
###                       ("\<^const>Fun.comp" ("_position" the)
###                         ("_applC" ("_position" map_of)
###                           ("_applC" ("_position" zip)
###                             ("_cargs" ("_position" enum_a)
###                               ("_position" ys))))))
###                     ("_applC" ("_position" List.n_lists)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" enum_a))
###                         ("_position" enum_b)))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" all_n_lists)
###                       ("_cargs" ("_position" enum_all_b)
###                         ("_cargs"
###                           ("_lambda" ("_position" bs)
###                             ("_applC" ("_position" P)
###                               ("\<^const>Fun.comp" ("_position" the)
###                                 ("_applC" ("_position" map_of)
###                                   ("_applC" ("_position" zip)
###                                     ("_cargs" ("_position" enum_a)
### ("_position" bs)))))))
###                           ("_applC" ("_position" length)
###                             ("_position" enum_a))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" ex_n_lists)
###                         ("_cargs" ("_position" enum_ex_b)
###                           ("_cargs"
###                             ("_lambda" ("_position" bs)
###                               ("_applC" ("_position" P)
###                                 ("\<^const>Fun.comp" ("_position" the)
###                                   ("_applC" ("_position" map_of)
###                                     ("_applC" ("_position" zip)
### ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
derived is_ceq_finite_3-lemma
deriving "ceq" instance for type "Enum.finite_4" via "="
derived is_ceq_finite_4-lemma
deriving "ceq" instance for type "Enum.finite_5" via "="
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
derived is_ceq_finite_5-lemma
deriving "ceq" instance for type "Code_Numeral.integer" via "="
instantiation
  set :: (cenum) cenum
  cEnum_set == cEnum ::
    ('a set list *
     (('a set => bool) => bool) * (('a set => bool) => bool)) option
derived is_ceq_integer-lemma
deriving "ceq" instance for type "Code_Numeral.natural" via "="
derived is_ceq_natural-lemma
deriving "ceq" instance for type "String.char" via "="
instantiation
  unit :: cenum
  cEnum_unit == cEnum ::
    (unit list * ((unit => bool) => bool) * ((unit => bool) => bool)) option
derived is_ceq_char-lemma
deriving "ceq" instance for type "String.literal" via "="
instantiation
  bool :: cenum
  cEnum_bool == cEnum ::
    (bool list * ((bool => bool) => bool) * ((bool => bool) => bool)) option
derived is_ceq_literal-lemma
deriving "ceq" instance for type "Sum_Type.sum"
instantiation
  prod :: (cenum, cenum) cenum
  cEnum_prod == cEnum ::
    (('a * 'b) list *
     (('a * 'b => bool) => bool) * (('a * 'b => bool) => bool)) option
derived is_ceq_sum-lemma
deriving "ceq" instance for type "Product_Type.prod"
### Ambiguous input (line 225 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" List.product)
###                       ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" enum_all_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" enum_all_b)
###                               ("_lambda" ("_position" y)
###                                 ("_applC" ("_position" P)
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" y)))))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" enum_ex_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" enum_ex_b)
###                                 ("_lambda" ("_position" y)
###                                   ("_applC" ("_position" P)
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" y)))))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" List.product)
###                   ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" enum_all_a)
###                       ("_lambda" ("_position" x)
###                         ("_applC" ("_position" enum_all_b)
###                           ("_lambda" ("_position" y)
###                             ("_applC" ("_position" P)
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" y)))))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" enum_ex_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" enum_ex_b)
###                             ("_lambda" ("_position" y)
###                               ("_applC" ("_position" P)
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg"
###                                     ("_position" y)))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
derived is_ceq_prod-lemma
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
deriving "ceq" instance for type "List.list"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  sum :: (cenum, cenum) cenum
  cEnum_sum == cEnum ::
    (('a + 'b) list *
     (('a + 'b => bool) => bool) * (('a + 'b => bool) => bool)) option
derived is_ceq_list-lemma
deriving "ceq" instance for type "Option.option"
### Ambiguous input (line 237 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_position" enum_all_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inl)
###                                   ("_position" x)))))
###                           ("_applC" ("_position" enum_all_b)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inr)
###                                   ("_position" x)))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("\<^const>HOL.disj"
###                             ("_applC" ("_position" enum_ex_a)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inl)
###                                     ("_position" x)))))
###                             ("_applC" ("_position" enum_ex_b)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inr)
###                                     ("_position" x)))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" enum_all_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inl) ("_position" x)))))
###                       ("_applC" ("_position" enum_all_b)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inr)
###                               ("_position" x)))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("\<^const>HOL.disj"
###                         ("_applC" ("_position" enum_ex_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inl)
###                                 ("_position" x)))))
###                         ("_applC" ("_position" enum_ex_b)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inr)
###                                 ("_position" x)))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
derived is_ceq_option-lemma
use None as trivial implementation of ceq for type fun
registered fun in class ceq
instantiation
  set :: (ceq) ceq
  ceq_set == ceq :: ('a set => 'a set => bool) option
instantiation
  option :: (cenum) cenum
  cEnum_option == cEnum ::
    ('a option list *
     (('a option => bool) => bool) * (('a option => bool) => bool)) option
instantiation
  Enum.finite_1 :: cenum
  cEnum_finite_1 == cEnum ::
    (Enum.finite_1 list *
     ((Enum.finite_1 => bool) => bool) *
     ((Enum.finite_1 => bool) => bool)) option
instantiation
  Enum.finite_2 :: cenum
  cEnum_finite_2 == cEnum ::
    (Enum.finite_2 list *
     ((Enum.finite_2 => bool) => bool) *
     ((Enum.finite_2 => bool) => bool)) option
instantiation
  Enum.finite_3 :: cenum
  cEnum_finite_3 == cEnum ::
    (Enum.finite_3 list *
     ((Enum.finite_3 => bool) => bool) *
     ((Enum.finite_3 => bool) => bool)) option
instantiation
  Enum.finite_4 :: cenum
  cEnum_finite_4 == cEnum ::
    (Enum.finite_4 list *
     ((Enum.finite_4 => bool) => bool) *
     ((Enum.finite_4 => bool) => bool)) option
instantiation
  Enum.finite_5 :: cenum
  cEnum_finite_5 == cEnum ::
    (Enum.finite_5 list *
     ((Enum.finite_5 => bool) => bool) *
     ((Enum.finite_5 => bool) => bool)) option
instantiation
  char :: cenum
  cEnum_char == cEnum ::
    (char list * ((char => bool) => bool) * ((char => bool) => bool)) option
instantiation
  Predicate.pred :: (ceq) ceq
  ceq_pred == ceq :: ('a Predicate.pred => 'a Predicate.pred => bool) option
overloading
  nat_pow \<equiv> pow :: ('a, 'b) monoid_scheme => 'a => nat => 'a
use None as trivial implementation of cenum for type list
### theory "Containers.Collection_Eq"
### 0.640s elapsed time, 2.445s cpu time, 0.395s GC time
Loading theory "Containers.DList_Set" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
registered list in class cenum
use None as trivial implementation of cenum for type nat
registered nat in class cenum
use None as trivial implementation of cenum for type int
registered int in class cenum
use None as trivial implementation of cenum for type integer
registered integer in class cenum
use None as trivial implementation of cenum for type natural
registered natural in class cenum
use None as trivial implementation of cenum for type literal
overloading
  int_pow \<equiv> pow :: ('a, 'b) monoid_scheme => 'a => int => 'a
registered literal in class cenum
### theory "Containers.Collection_Enum"
### 0.738s elapsed time, 2.829s cpu time, 0.395s GC time
Loading theory "HOL-Library.Type_Length" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class len0 = type +
  fixes len_of :: "'a itself => nat"
locale equal_base
  fixes equal :: "'a => 'a => bool"
consts
  list_member :: "'a list => 'a => bool"
consts
  list_distinct :: "'a list => bool"
locale submonoid
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "submonoid H G"
consts
  list_remove1 :: "'a => 'a list => 'a list"
class len = len0 +
  assumes "len_gt_0": "0 < LENGTH('a)"
consts
  list_remdups :: "'a list => 'a list"
instantiation
  0 :: len0
  1 :: len0
  len_of_num0 == len_of :: 0 itself => nat
  len_of_num1 == len_of :: 1 itself => nat
instantiation
  bit0 :: (len0) len0
  bit1 :: (len0) len0
  len_of_bit0 == len_of :: 'a bit0 itself => nat
  len_of_bit1 == len_of :: 'a bit1 itself => nat
locale Equal.equal
  fixes equal :: "'a => 'a => bool"
  assumes "equal equal"
locale subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "subgroup H G"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  Enum.finite_1 :: len
  len_of_finite_1 == len_of :: Enum.finite_1 itself => nat
instantiation
  Enum.finite_2 :: len
  len_of_finite_2 == len_of :: Enum.finite_2 itself => nat
instantiation
  Enum.finite_3 :: len
  len_of_finite_3 == len_of :: Enum.finite_3 itself => nat
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "Containers.DList_Set"
### 0.711s elapsed time, 2.729s cpu time, 0.275s GC time
Loading theory "HOL-Library.RBT_Impl" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2" via "Containers.RBT_ext")
### theory "HOL-Library.Type_Length"
### 0.644s elapsed time, 2.468s cpu time, 0.275s GC time
Loading theory "HOL-Library.Word" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
locale group_hom
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and H :: "('c, 'd) monoid_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "group_hom G H h"
class proper_interval = proper_intrvl +
  assumes
    "proper_interval_simps": "proper_interval None None = True"
      "!!y. proper_interval None (Some y) = (EX z. z < y)"
      "!!x. proper_interval (Some x) None = (EX z. x < z)"
      "!!x y. proper_interval (Some x) (Some y) = (EX z>x. z < y)"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
instantiation
  word :: (len) comm_ring_1
  uminus_word == uminus :: 'a word => 'a word
  one_word == one_class.one :: 'a word
  times_word == times :: 'a word => 'a word => 'a word
  zero_word == zero_class.zero :: 'a word
  minus_word == minus :: 'a word => 'a word => 'a word
  plus_word == plus :: 'a word => 'a word => 'a word
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale comm_group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_group G"
signature WORD_LIB =
  sig
    val dest_binT: typ -> int
    val dest_wordT: typ -> int
    val is_wordT: typ -> bool
    val mk_wordT: int -> typ
  end
structure Word_Lib: WORD_LIB
instantiation
  word :: (len) equal
  equal_word == equal_class.equal :: 'a word => 'a word => bool
### theory "HOL-Algebra.Group"
### 1.866s elapsed time, 7.120s cpu time, 0.944s GC time
Loading theory "HOL-Algebra.Coset" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization" via "HOL-Algebra.Divisibility")
locale normal
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "normal H G"
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### Ambiguous input (line 611 of "~~/src/HOL/Algebra/Coset.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###       ("_position" H))
###     ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" x)
###           ("_applC" ("_position" carrier) ("_position" G)))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" y)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>Set.member"
###             ("\<^const>Group.monoid.mult_indexed"
###               ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                 ("_position" x))
###               ("_index" ("_position" G)) ("_position" y))
###             ("_position" H)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^fixed>r_congruent_indexed" ("_index" ("_position" G))
###     ("\<^const>HOL.eq" ("_position" H)
###       ("_Coll" ("_pattern" ("_position" x) ("_position" y))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" x)
###             ("_applC" ("_position" carrier) ("_position" G)))
###           ("\<^const>HOL.conj"
###             ("\<^const>Set.member" ("_position" y)
###               ("_applC" ("_position" carrier) ("_position" G)))
###             ("\<^const>Set.member"
###               ("\<^const>Group.monoid.mult_indexed"
###                 ("\<^const>Group.m_inv_indexed" ("_index" ("_position" G))
###                   ("_position" x))
###                 ("_index" ("_position" G)) ("_position" y))
###               ("_position" H))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  word :: (len) linorder
  less_eq_word == less_eq :: 'a word => 'a word => bool
  less_word == less :: 'a word => 'a word => bool
consts
  entries :: "('a, 'b) rbt => ('a * 'b) list"
instantiation
  word :: (len) enum
  enum_word == enum_class.enum :: 'a word list
  enum_all_word == enum_class.enum_all :: ('a word => bool) => bool
  enum_ex_word == enum_class.enum_ex :: ('a word => bool) => bool
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  word :: (len) semiring_modulo
  modulo_word == modulo :: 'a word => 'a word => 'a word
  divide_word == divide :: 'a word => 'a word => 'a word
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
instantiation
  word :: (len) semiring_bits
  bit_word == bit :: 'a word => nat => bool
consts
  rbt_sorted :: "('a, 'b) rbt => bool"
instantiation
  word :: (len) ring_bit_operations
  not_word == not :: 'a word => 'a word
  and_word == and :: 'a word => 'a word => 'a word
  or_word == or :: 'a word => 'a word => 'a word
  xor_word == xor :: 'a word => 'a word => 'a word
  mask_word == mask :: nat => 'a word
  set_bit_word == set_bit :: nat => 'a word => 'a word
  unset_bit_word == unset_bit :: nat => 'a word => 'a word
  flip_bit_word == flip_bit :: nat => 'a word => 'a word
  push_bit_word == push_bit :: nat => 'a word => 'a word
  drop_bit_word == drop_bit :: nat => 'a word => 'a word
  take_bit_word == take_bit :: nat => 'a word => 'a word
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  rbt_lookup :: "('a, 'b) rbt => 'a => 'b option"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  color_of :: "('a, 'b) rbt => color"
consts
  bheight :: "('a, 'b) rbt => nat"
consts
  inv1 :: "('a, 'b) rbt => bool"
consts
  inv1l :: "('a, 'b) rbt => bool"
consts
  inv2 :: "('a, 'b) rbt => bool"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
### theory "HOL-Algebra.Coset"
### 1.503s elapsed time, 5.592s cpu time, 0.868s GC time
Loading theory "HOL-Algebra.FiniteProduct" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring")
Proofs for inductive predicate(s) "foldSetDp"
  Proving monotonicity ...
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
locale LCD
  fixes B :: "'b set"
    and D :: "'a set"
    and f :: "'b => 'a => 'a"  (infixl \<open>\<cdot>\<close> 70)
  assumes "LCD B D (\<cdot>)"
locale ACeD
  fixes D :: "'a set"
    and f :: "'a => 'a => 'a"  (infixl \<open>\<cdot>\<close> 70)
    and e :: "'a"
  assumes "ACeD D (\<cdot>) e"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
### theory "HOL-Algebra.FiniteProduct"
### 1.306s elapsed time, 4.762s cpu time, 2.843s GC time
Loading theory "HOL-Algebra.Ring" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring")
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
### Cannot skip proof of schematic goal statement
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Cannot skip proof of schematic goal statement
Found termination order: "{}"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Cannot skip proof of schematic goal statement
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
### Cannot skip proof of schematic goal statement
class unique_euclidean_semiring_numeral =
  unique_euclidean_semiring_with_nat + linordered_semidom +
  fixes divmod :: "num => num => 'a * 'a"
    and divmod_step :: "num => 'a * 'a => 'a * 'a"
  assumes
    "div_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a div b = (0::'a)"
    and "mod_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a mod b = a"
    and
    "div_positive": "!!b a. [| (0::'a) < b; b <= a |] ==> (0::'a) < a div b"
    and "mod_less_eq_dividend": "!!a b. (0::'a) <= a ==> a mod b <= a"
    and "pos_mod_bound": "!!b a. (0::'a) < b ==> a mod b < b"
    and "pos_mod_sign": "!!b a. (0::'a) < b ==> (0::'a) <= a mod b"
    and
    "mod_mult2_eq":
      "!!c a b.
          (0::'a) <= c ==> a mod (b * c) = b * (a div b mod c) + a mod b"
    and
    "div_mult2_eq":
      "!!c a b. (0::'a) <= c ==> a div (b * c) = a div b div c"
  assumes "discrete": "!!a b. (a < b) = (a + (1::'a) <= b)"
  assumes
    "divmod_def":
      "!!m n.
          divmod m n = (numeral m div numeral n, numeral m mod numeral n)"
    and
    "divmod_step_def":
      "!!l qr.
          divmod_step l qr =
          (let (q, r) = qr
           in if numeral l <= r then ((2::'a) * q + (1::'a), r - numeral l)
              else ((2::'a) * q, r))"
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### ML warning (line 44 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 47 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Matches are not exhaustive.
signature RINGSIMP =
  sig
    val add_struct: string * term list -> attribute
    val algebra_tac: Proof.context -> int -> tactic
    val del_struct: string * term list -> attribute
    val print_structures: Proof.context -> unit
  end
structure Ringsimp: RINGSIMP
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Found termination order:
  "(%p. length (snd (snd (snd p)))) <*mlex*>
   (%p. length (fst (snd (snd p)))) <*mlex*> {}"
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
instantiation
  word :: (len) size
  size_word == size :: 'a word => nat
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Min (\<le>s) (set (?x # ?xs)) == fold signed.min ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Max (\<le>s) (set (?x # ?xs)) == fold signed.max ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [?x] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted (?x # ?y # ?zs) == ?x \<le>s ?y & signed.sorted (?y # ?zs)
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted_list_of_set (set ?xs) == signed.sort (remdups ?xs)
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
locale ring_hom_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "ring_hom_cring R S h"
instantiation
  unit :: proper_interval
  proper_interval_unit == proper_interval ::
    unit option => unit option => bool
Found termination order: "{}"
instantiation
  bool :: proper_interval
  proper_interval_bool == proper_interval ::
    bool option => bool option => bool
### theory "HOL-Algebra.Ring"
### 3.867s elapsed time, 14.461s cpu time, 4.012s GC time
Loading theory "HOL-Algebra.AbelCoset" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.RingHom" via "HOL-Algebra.Ideal")
Found termination order: "{}"
instantiation
  nat :: proper_interval
  proper_interval_nat == proper_interval :: nat option => nat option => bool
Found termination order: "{}"
instantiation
  int :: proper_interval
  proper_interval_int == proper_interval :: int option => int option => bool
Found termination order: "{}"
instantiation
  integer :: proper_interval
  proper_interval_integer == proper_interval ::
    integer option => integer option => bool
instantiation
  natural :: proper_interval
  proper_interval_natural == proper_interval ::
    natural option => natural option => bool
instantiation
  char :: proper_interval
  proper_interval_char == proper_interval ::
    char option => char option => bool
val unat_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?v1 ... ?w1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.unat_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val unat_arith_tacs = fn: Proof.context -> tactic list
val unat_arith_tac = fn: Proof.context -> int -> tactic
val uint_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?a1 ... ?b1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.uint_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val uint_arith_tacs = fn: Proof.context -> tactic list
val uint_arith_tac = fn: Proof.context -> int -> tactic
Found termination order: "{}"
instantiation
  Enum.finite_1 :: proper_interval
  proper_interval_finite_1 == proper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: proper_interval
  proper_interval_finite_2 == proper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
Found termination order: "{}"
instantiation
  Enum.finite_3 :: proper_interval
  proper_interval_finite_3 == proper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
Found termination order: "{}"
locale abelian_group_hom
  fixes G :: "('a, 'b) ring_scheme"  (structure)
    and H :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "abelian_group_hom G H h"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
### Cannot skip proof of schematic goal statement
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
locale word_rotate
locale additive_subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) ring_scheme"  (structure)
  assumes "additive_subgroup H G"
signature SMT_WORD =
  sig
    val add_word_shift': term * string -> Context.generic -> Context.generic
  end
structure SMT_Word: SMT_WORD
### theory "HOL-Library.Word"
### 8.362s elapsed time, 31.177s cpu time, 8.491s GC time
Loading theory "HOL-Algebra.Module" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
locale abelian_subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_subgroup H G"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Containers.Set_Linorder"
### 10.344s elapsed time, 38.773s cpu time, 9.478s GC time
Loading theory "HOL-Algebra.Generated_Groups" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
Proofs for inductive predicate(s) "generatep"
  Proving monotonicity ...
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
locale algebra
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "algebra R M"
### theory "HOL-Algebra.Generated_Groups"
### 0.779s elapsed time, 2.918s cpu time, 0.407s GC time
Loading theory "HOL-Algebra.Divisibility" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization")
locale monoid_cancel
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "monoid_cancel G"
locale comm_monoid_cancel
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_monoid_cancel G"
locale submodule
  fixes H :: "'c set"
    and R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "submodule H R M"
### theory "HOL-Algebra.Module"
### 1.722s elapsed time, 6.395s cpu time, 0.954s GC time
Loading theory "Jordan_Normal_Form.Missing_Ring" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
locale factorial_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "factorial_monoid G"
### theory "HOL-Algebra.AbelCoset"
### 3.317s elapsed time, 12.345s cpu time, 1.704s GC time
Loading theory "HOL-Algebra.Ideal" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly" via "HOL-Algebra.RingHom")
locale ideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ideal I R"
locale principalideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "principalideal I R"
class ordered_semiring_strict = comm_monoid_add +
  ordered_cancel_ab_semigroup_add + semiring +
  assumes
    "mult_strict_left_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> c * a < c * b"
  assumes
    "mult_strict_right_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> a * c < b * c"
locale maximalideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "maximalideal I R"
locale gcd_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "gcd_condition_monoid G"
locale primeness_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "primeness_condition_monoid G"
locale divisor_chain_condition_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "divisor_chain_condition_monoid G"
locale primeideal
  fixes I :: "'a set"
    and R :: "('a, 'b) ring_scheme"  (structure)
  assumes "primeideal I R"
### theory "HOL-Algebra.Divisibility"
### 2.632s elapsed time, 9.547s cpu time, 1.534s GC time
Loading theory "HOL-Algebra.Elementary_Groups" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale group_disjoint_sum
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and A :: "'a set"
    and B :: "'a set"
  assumes "group_disjoint_sum G A B"
class ordered_idom = ordered_semiring_strict + idom +
  assumes "zero_less_one": "(0::'a) < (1::'a)"
### theory "HOL-Algebra.Elementary_Groups"
### 0.725s elapsed time, 2.436s cpu time, 0.554s GC time
Loading theory "Containers.Collection_Order" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
Found termination order: "{}"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
### theory "HOL-Algebra.Ideal"
### 3.797s elapsed time, 13.556s cpu time, 5.316s GC time
Loading theory "HOL-Algebra.RingHom" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group" via "HOL-Algebra.UnivPoly")
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 Empty == Branch B Empty ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty ==
### Branch B (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1) ==
### Branch B Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1)
signature CCOMPARE_GENERATOR =
  sig
    val ccompare_instance_via_comparator: string -> theory -> theory
    val ccompare_instance_via_compare: string -> theory -> theory
    val derive_no_ccompare: string -> theory -> theory
  end
structure CCompare_Generator: CCOMPARE_GENERATOR
deriving "compare_order" instance for type "Enum.finite_1"
deriving "compare" instance for type "Enum.finite_1"
deriving "compare_order" instance for type "Enum.finite_2"
deriving "compare" instance for type "Enum.finite_2"
deriving "compare_order" instance for type "Enum.finite_3"
deriving "compare" instance for type "Enum.finite_3"
deriving "compare_order" instance for type "Code_Numeral.natural"
deriving "compare" instance for type "Code_Numeral.natural"
deriving "compare_order" instance for type "String.literal"
deriving "compare" instance for type "String.literal"
deriving "ccompare_order" instance for type "Product_Type.unit" via compare_order
derived is_ccompare_unit-lemma
deriving "ccompare_order" instance for type "HOL.bool" via compare_order
derived is_ccompare_bool-lemma
deriving "ccompare_order" instance for type "Nat.nat" via compare_order
derived is_ccompare_nat-lemma
deriving "ccompare_order" instance for type "Int.int" via compare_order
derived is_ccompare_int-lemma
deriving "ccompare_order" instance for type "Enum.finite_1" via compare_order
derived is_ccompare_finite_1-lemma
deriving "ccompare_order" instance for type "Enum.finite_2" via compare_order
derived is_ccompare_finite_2-lemma
deriving "ccompare_order" instance for type "Enum.finite_3" via compare_order
derived is_ccompare_finite_3-lemma
deriving "ccompare_order" instance for type "Code_Numeral.integer" via compare_order
derived is_ccompare_integer-lemma
deriving "ccompare_order" instance for type "Code_Numeral.natural" via compare_order
derived is_ccompare_natural-lemma
deriving "ccompare_order" instance for type "String.char" via compare_order
derived is_ccompare_char-lemma
deriving "ccompare_order" instance for type "String.literal" via compare_order
derived is_ccompare_literal-lemma
use None as trivial implementation of ccompare for type finite_4
registered finite_4 in class ccompare
use None as trivial implementation of ccompare for type finite_5
registered finite_5 in class ccompare
deriving "ccompare" instance for type "Sum_Type.sum"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
derived is_ccompare_sum-lemma
deriving "ccompare" instance for type "List.list"
locale ring_hom_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "ring_hom_ring R S h"
derived is_ccompare_list-lemma
deriving "ccompare" instance for type "Option.option"
derived is_ccompare_option-lemma
deriving "ccompare" instance for type "Product_Type.prod"
derived is_ccompare_prod-lemma
use None as trivial implementation of ccompare for type fun
registered fun in class ccompare
instantiation
  set :: (ccompare) ccompare
  ccompare_set == ccompare :: ('a set => 'a set => order) option
use None as trivial implementation of ccompare for type pred
registered pred in class ccompare
consts
  paint :: "color => ('a, 'b) rbt => ('a, 'b) rbt"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class cproper_interval = ccompare +
  fixes cproper_interval :: "'a option => 'a option => bool"
  assumes
    "cproper_interval":
      "[| ID ccompare ~= None; finite UNIV |]
       ==> class.proper_interval cless cproper_interval"
instantiation
  unit :: cproper_interval
  cproper_interval_unit == cproper_interval ::
    unit option => unit option => bool
instantiation
  bool :: cproper_interval
  cproper_interval_bool == cproper_interval ::
    bool option => bool option => bool
instantiation
  nat :: cproper_interval
  cproper_interval_nat == cproper_interval ::
    nat option => nat option => bool
instantiation
  int :: cproper_interval
  cproper_interval_int == cproper_interval ::
    int option => int option => bool
instantiation
  integer :: cproper_interval
  cproper_interval_integer == cproper_interval ::
    integer option => integer option => bool
instantiation
  natural :: cproper_interval
  cproper_interval_natural == cproper_interval ::
    natural option => natural option => bool
instantiation
  char :: cproper_interval
  cproper_interval_char == cproper_interval ::
    char option => char option => bool
instantiation
  Enum.finite_1 :: cproper_interval
  cproper_interval_finite_1 == cproper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: cproper_interval
  cproper_interval_finite_2 == cproper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
instantiation
  Enum.finite_3 :: cproper_interval
  cproper_interval_finite_3 == cproper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
instantiation
  Enum.finite_4 :: cproper_interval
  cproper_interval_finite_4 == cproper_interval ::
    Enum.finite_4 option => Enum.finite_4 option => bool
instantiation
  Enum.finite_5 :: cproper_interval
  cproper_interval_finite_5 == cproper_interval ::
    Enum.finite_5 option => Enum.finite_5 option => bool
instantiation
  sum :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_sum == cproper_interval ::
    ('a + 'b) option => ('a + 'b) option => bool
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale csemiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "csemiring R"
Found termination order: "{}"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
instantiation
  prod :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_prod == cproper_interval ::
    ('a * 'b) option => ('a * 'b) option => bool
### theory "HOL-Algebra.RingHom"
### 1.013s elapsed time, 3.815s cpu time, 0.430s GC time
Loading theory "HOL-Algebra.UnivPoly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues" via "HOL-Algebra.Multiplicative_Group")
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
Found termination order: "{}"
instantiation
  list :: (ccompare) cproper_interval
  cproper_interval_list == cproper_interval ::
    'a list option => 'a list option => bool
instantiation
  String.literal :: cproper_interval
  cproper_interval_literal == cproper_interval ::
    String.literal option => String.literal option => bool
instantiation
  option :: (cproper_interval) cproper_interval
  cproper_interval_option == cproper_interval ::
    'a option option => 'a option option => bool
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
### theory "Jordan_Normal_Form.Missing_Ring"
### 5.449s elapsed time, 19.716s cpu time, 6.161s GC time
Loading theory "Word_Lib.Bit_Comprehension" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
Found termination order: "{}"
instantiation
  set :: (cproper_interval) cproper_interval
  cproper_interval_set == cproper_interval ::
    'a set option => 'a set option => bool
locale bound
  fixes z :: "'a"
    and n :: "nat"
    and f :: "nat => 'a"
  assumes "bound z n f"
### Not an equation, in theorem:
### cproper_interval_set_dom (None, None) ==> cproper_interval None None == True
### Not an equation, in theorem:
### cproper_interval_set_dom (None, Some ?B) ==>
### cproper_interval None (Some ?B) == ?B ~= {}
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, None) ==>
### cproper_interval (Some ?A) None == ?A ~= UNIV
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, Some ?B) ==>
### cproper_interval (Some ?A) (Some ?B) ==
### finite UNIV & (EX C. cless ?A C & cless C ?B)
Found termination order: "{}"
instantiation
  fun :: (type, type) cproper_interval
  cproper_interval_fun == cproper_interval ::
    ('a => 'b) option => ('a => 'b) option => bool
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Containers.Collection_Order"
### 2.991s elapsed time, 11.048s cpu time, 4.629s GC time
Loading theory "Word_Lib.More_Divides" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit" via "Word_Lib.More_Word")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Word_Lib.More_Divides"
### 0.235s elapsed time, 0.867s cpu time, 0.144s GC time
Loading theory "HOL-Library.Signed_Division" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Word_Lib.Signed_Division_Word")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class signed_division = type +
  fixes signed_divide :: "'a => 'a => 'a"
    and signed_modulo :: "'a => 'a => 'a"
instantiation
  int :: signed_division
  signed_divide_int == signed_divide :: int => int => int
  signed_modulo_int == signed_modulo :: int => int => int
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  defines "P == UP R"
### theory "HOL-Library.Signed_Division"
### 0.147s elapsed time, 0.544s cpu time, 0.068s GC time
Loading theory "Word_Lib.Signed_Division_Word" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
instantiation
  word :: (len) signed_division
  signed_divide_word == signed_divide :: 'a word => 'a word => 'a word
  signed_modulo_word == signed_modulo :: 'a word => 'a word => 'a word
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  defines "P == UP R"
### theory "Word_Lib.Signed_Division_Word"
### 0.515s elapsed time, 1.891s cpu time, 0.258s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order: "{}"
class bit_comprehension = ring_bit_operations +
  fixes set_bits :: "(nat => bool) => 'a"
  assumes "set_bits_bit_eq": "!!a. set_bits (bit a) = a"
instantiation
  int :: bit_comprehension
  set_bits_int == set_bits :: (nat => bool) => int
instantiation
  word :: (len) bit_comprehension
  set_bits_word == set_bits :: (nat => bool) => 'a word
Proofs for inductive predicate(s) "wf_set_bits_int"
  Proving monotonicity ...
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
### theory "Word_Lib.Bit_Comprehension"
### 1.343s elapsed time, 4.926s cpu time, 0.748s GC time
Loading theory "HOL-Library.While_Combinator" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method" via "Regular-Sets.Equivalence_Checking")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
Found termination order: "{}"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order: "{}"
Found termination order: "{}"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
### theory "HOL-Library.While_Combinator"
### 13.144s elapsed time, 43.061s cpu time, 41.319s GC time
Loading theory "HOL-Types_To_Sets.Types_To_Sets" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field")
signature LOCAL_TYPEDEF =
  sig
    val cancel_type_definition: thm -> thm
    val cancel_type_definition_attr: attribute
  end
structure Local_Typedef: LOCAL_TYPEDEF
Found termination order: "size <*mlex*> {}"
signature UNOVERLOADING =
  sig
    val unoverload: cterm -> thm -> thm
    val unoverload_attr: cterm -> attribute
  end
structure Unoverloading: UNOVERLOADING
signature INTERNALIZE_SORT =
  sig
    val internalize_sort: ctyp -> thm -> typ * thm
    val internalize_sort_attr: typ -> attribute
  end
structure Internalize_Sort: INTERNALIZE_SORT
Found termination order: "size <*mlex*> {}"
### ML warning (line 41 of "~~/src/HOL/Types_To_Sets/unoverload_type.ML"):
### Matches are not exhaustive.
signature UNOVERLOAD_TYPE =
  sig
    val unoverload_type: Context.generic -> indexname list -> thm -> thm
    val unoverload_type_attr: indexname list -> attribute
  end
structure Unoverload_Type: UNOVERLOAD_TYPE
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
### ML warning (line 36 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 36 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Value identifier (ctxt') has not been referenced.
### ML warning (line 40 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 66 of "~~/src/HOL/Types_To_Sets/unoverload_def.ML"):
### Pattern is not exhaustive.
structure Unoverload_Def:
  sig
    val unoverload_def: binding option -> thm -> theory -> theory
    val unoverload_def1_cmd:
       binding option * (Facts.ref * Token.src list) -> theory -> theory
  end
### theory "HOL-Types_To_Sets.Types_To_Sets"
### 0.316s elapsed time, 1.205s cpu time, 0.195s GC time
Loading theory "Deriving.Compare_Rat" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
Found termination order: "size <*mlex*> {}"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order: "size <*mlex*> {}"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
Found termination order: "size <*mlex*> {}"
deriving "compare_order" instance for type "Rat.rat"
deriving "compare" instance for type "Rat.rat"
Found termination order: "size <*mlex*> {}"
### theory "Deriving.Compare_Rat"
### 0.279s elapsed time, 1.091s cpu time, 0.082s GC time
Loading theory "HOL-Library.FSet" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code" via "Polynomials.MPoly_Type_Class_FMap" via "Polynomials.Poly_Mapping_Finite_Map" via "HOL-Library.Finite_Map")
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (finite) finite
instantiation
  fset :: (type) {minus,bounded_lattice_bot,distrib_lattice}
  inf_fset == inf :: 'a fset => 'a fset => 'a fset
  bot_fset == bot :: 'a fset
  sup_fset == sup :: 'a fset => 'a fset => 'a fset
  less_eq_fset == less_eq :: 'a fset => 'a fset => bool
  less_fset == less :: 'a fset => 'a fset => bool
  minus_fset == minus :: 'a fset => 'a fset => 'a fset
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (equal) equal
  equal_fset == equal_class.equal :: 'a fset => 'a fset => bool
instantiation
  fset :: (type) conditionally_complete_lattice
  Inf_fset == Inf :: 'a fset set => 'a fset
  Sup_fset == Sup :: 'a fset set => 'a fset
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (finite) complete_lattice
  top_fset == top :: 'a fset
instantiation
  fset :: (finite) complete_boolean_algebra
  uminus_fset == uminus :: 'a fset => 'a fset
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
Found termination order: "size <*mlex*> {}"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
### theory "HOL-Library.Tree"
### 14.910s elapsed time, 49.847s cpu time, 42.155s GC time
Loading theory "Draft.Templates" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.101s elapsed time, 0.373s cpu time, 0.111s GC time
Loading theory "Deriving.Compare_Real" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
deriving "compare_order" instance for type "Real.real"
deriving "compare" instance for type "Real.real"
### theory "Deriving.Compare_Real"
### 0.296s elapsed time, 1.159s cpu time, 0.075s GC time
Loading theory "Polynomials.More_Modules" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class")
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
### theory "Polynomials.More_Modules"
### 0.203s elapsed time, 0.785s cpu time, 0.081s GC time
Loading theory "Cauchy.CauchysMeanTheorem" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Explicit_Roots" via "Sqrt_Babylonian.Sqrt_Babylonian" via "Sqrt_Babylonian.NthRoot_Impl")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
### theory "Cauchy.CauchysMeanTheorem"
### 0.322s elapsed time, 1.221s cpu time, 0.250s GC time
Loading theory "Polynomial_Interpolation.Improved_Code_Equations" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Interpolation.Polynomial_Interpolation")
locale comp_fun_idem
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_idem f"
locale comm_monoid_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_fset (\<^bold>*) \<^bold>1"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### Cannot skip proof of schematic goal statement
locale semilattice_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "semilattice_fset (\<^bold>*)"
locale semilattice_order_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes "semilattice_order_fset (\<^bold>*) (\<^bold>\<le>) (\<^bold><)"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
### Code generator: dropping subsumed code equation
### divmod_integer ?k ?l ==
### if ?k = 0 then (0, 0)
### else if 0 < ?l
###      then if 0 < ?k then Code_Numeral.divmod_abs ?k ?l
###           else case Code_Numeral.divmod_abs ?k ?l of
###                (r, s) => if s = 0 then (- r, 0) else (- r - 1, ?l - s)
###      else if ?l = 0 then (0, ?k)
###           else apsnd uminus
###                 (if ?k < 0 then Code_Numeral.divmod_abs ?k ?l
###                  else case Code_Numeral.divmod_abs ?k ?l of
###                       (r, s) =>
###                         if s = 0 then (- r, 0) else (- r - 1, - ?l - s))
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### let k = integer_of_nat ?m; l = integer_of_nat ?n
### in map_prod nat_of_integer nat_of_integer
###     (if k = 0 then (0, 0)
###      else if l = 0 then (0, k) else Code_Numeral.divmod_abs k l)
### Code generator: dropping subsumed code equation
### ?n choose ?k ==
### if ?n < ?k then 0
### else if ?n < 2 * ?k then ?n choose (?n - ?k)
###      else fold_atLeastAtMost_nat (*) (?n - ?k + 1) ?n 1 div fact ?k
### theory "Polynomial_Interpolation.Improved_Code_Equations"
### 0.345s elapsed time, 1.333s cpu time, 0.166s GC time
Loading theory "Polynomial_Interpolation.Neville_Aitken_Interpolation" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Interpolation.Polynomial_Interpolation")
locale UP
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  defines "P == UP R"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size_list (%p. size (snd p)) <*mlex*> {}"
instantiation
  fset :: (type) size
  size_fset == size :: 'a fset => nat
instantiation
  fset :: (exhaustive) exhaustive
  exhaustive_fset == exhaustive_class.exhaustive ::
    ('a fset => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P == UP R"
instantiation
  fset :: (full_exhaustive) full_exhaustive
  full_exhaustive_fset == full_exhaustive_class.full_exhaustive ::
    ('a fset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "length <*mlex*> {}"
### theory "Polynomial_Interpolation.Neville_Aitken_Interpolation"
### 0.657s elapsed time, 2.553s cpu time, 0.250s GC time
Loading theory "Polynomials.MPoly_Type_Univariate" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection")
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  fset :: (random) random
  random_fset == random_class.random ::
    natural
    => natural * natural => ('a fset * (unit => term)) * natural * natural
### Additional type variable(s) in specification of "random_aux_fset_rel": 'a
### Additional type variable(s) in specification of "random_aux_fset_dom": 'a
Found termination order: "(%p. nat_of_natural (fst p)) <*mlex*> {}"
### theory "HOL-Library.FSet"
### 3.200s elapsed time, 12.358s cpu time, 1.503s GC time
Loading theory "HOL-Library.Finite_Map" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code" via "Polynomials.MPoly_Type_Class_FMap" via "Polynomials.Poly_Mapping_Finite_Map")
locale UP_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
    and P :: "('a, nat => 'a) up_ring"  (structure)
    and s :: "'c"
    and Eval :: "(nat => 'a) => 'c"
  assumes "UP_univ_prop R S h s"
  defines "P == UP R"
    and "Eval == eval R S h s"
### theory "Polynomials.MPoly_Type_Univariate"
### 0.664s elapsed time, 2.544s cpu time, 0.315s GC time
Loading theory "Berlekamp_Zassenhaus.Code_Abort_Gcd" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus")
### Code generator: dropping subsumed code equation
### Gcd (set ?xs) == fold gcd ?xs 0
### Code generator: dropping subsumed code equation
### Lcm (set ?xs) == fold lcm ?xs 1
### Code generator: dropping subsumed code equation
### Gcd (set ?xs) == fold gcd ?xs 0
### Code generator: dropping subsumed code equation
### Lcm (set ?xs) == fold lcm ?xs 1
### Code generator: dropping subsumed code equation
### Gcd (set ?xs) == fold gcd ?xs 0
### Code generator: dropping subsumed code equation
### Lcm (set ?xs) == fold lcm ?xs 1
### theory "Berlekamp_Zassenhaus.Code_Abort_Gcd"
### 0.067s elapsed time, 0.269s cpu time, 0.000s GC time
Loading theory "Symmetric_Polynomials.Vieta" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Hermite_Lindemann.More_Multivariate_Polynomial_HLW" via "Power_Sum_Polynomials.Power_Sum_Polynomials_Library" via "Symmetric_Polynomials.Symmetric_Polynomials")
theorem
  map_add_transfer:
    rel_fun (rel_fun ?A1.0 (rel_option ?A2.0))
     (rel_fun (rel_fun ?A1.0 (rel_option ?A2.0))
       (rel_fun ?A1.0 (rel_option ?A2.0)))
     (++) (++)
theorem
  map_of_transfer:
    bi_unique ?A1.0 ==>
    rel_fun (list_all2 (rel_prod ?A1.0 ?A2.0))
     (rel_fun ?A1.0 (rel_option ?A2.0)) map_of map_of
theorem
  dom_transfer:
    bi_total ?A1.0 ==>
    ((?A1.0 ===> rel_option ?A2.0) ===> rel_set ?A1.0) dom dom
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P == UP R"
theorem
  map_upd_transfer:
    bi_unique ?A1.0 ==>
    (?A1.0 ===>
     ?A2.0 ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_upd map_upd
theorem
  map_filter_transfer:
    ((?A1.0 ===> (=)) ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_filter map_filter
theorem
  map_drop_transfer:
    bi_unique ?A1.0 ==>
    (?A1.0 ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_drop map_drop
theorem
  map_drop_set_transfer:
    bi_unique ?A1.0 ==>
    (rel_set ?A1.0 ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_drop_set map_drop_set
theorem
  map_restrict_set_transfer:
    bi_unique ?A1.0 ==>
    (rel_set ?A1.0 ===>
     (?A1.0 ===> rel_option ?A2.0) ===> ?A1.0 ===> rel_option ?A2.0)
     map_restrict_set map_restrict_set
theorem
  map_pred_transfer:
    bi_total ?A1.0 ==>
    ((?A1.0 ===> ?A2.0 ===> (=)) ===>
     (?A1.0 ===> rel_option ?A2.0) ===> (=))
     map_pred map_pred
theorem
  map_comp_transfer:
    ((?A3.0 ===> rel_option ?A2.0) ===>
     (?A1.0 ===> rel_option ?A3.0) ===> ?A1.0 ===> rel_option ?A2.0)
     (\<circ>\<^sub>m) (\<circ>\<^sub>m)
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
### theory "Symmetric_Polynomials.Vieta"
### 0.882s elapsed time, 3.365s cpu time, 0.472s GC time
Loading theory "Symmetric_Polynomials.Symmetric_Polynomials" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Hermite_Lindemann.More_Multivariate_Polynomial_HLW" via "Power_Sum_Polynomials.Power_Sum_Polynomials_Library")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ignoring duplicate rewrite rule:
### length (sorted_list_of_set ?A1) == card ?A1
locale ring_closed
  fixes A :: "'a set"
  assumes "ring_closed A"
instantiation
  fmap :: (type, type) size
  size_fmap == size :: ('a, 'b) fmap => nat
locale ring_homomorphism
  fixes f :: "'a => 'b"
  assumes "ring_homomorphism f"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
consts
  rbt_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
instantiation
  fmap :: (type, equal) equal
  equal_fmap == equal_class.equal :: ('a, 'b) fmap => ('a, 'b) fmap => bool
locale UP_pre_univ_prop
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_pre_univ_prop R S h"
  defines "P == UP R"
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
consts
  map :: "('a => 'b => 'c) => ('a, 'b) rbt => ('a, 'c) rbt"
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
### theory "HOL-Library.Finite_Map"
### 2.744s elapsed time, 10.459s cpu time, 1.529s GC time
Loading theory "Berlekamp_Zassenhaus.Karatsuba_Multiplication" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Polynomial_Record_Based")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Symmetric_Polynomials.Symmetric_Polynomials"
### 2.546s elapsed time, 9.537s cpu time, 1.648s GC time
Loading theory "Polynomial_Factorization.Missing_Polynomial_Factorial" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Polynomial_Factorization.Gauss_Lemma")
### Ignoring duplicate rewrite rule:
### is_unit ?p1 == ?p1 ~= 0 & degree ?p1 = 0
### theory "Polynomial_Factorization.Missing_Polynomial_Factorial"
### 0.200s elapsed time, 0.723s cpu time, 0.129s GC time
Loading theory "Power_Sum_Polynomials.Power_Sum_Polynomials_Library" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Hermite_Lindemann.More_Multivariate_Polynomial_HLW")
### theory "HOL-Algebra.UnivPoly"
### 22.956s elapsed time, 80.215s cpu time, 46.602s GC time
Loading theory "HOL-Algebra.Multiplicative_Group" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues")
### theory "Power_Sum_Polynomials.Power_Sum_Polynomials_Library"
### 0.786s elapsed time, 2.861s cpu time, 0.459s GC time
Loading theory "Hermite_Lindemann.More_Multivariate_Polynomial_HLW" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection")
### theory "Hermite_Lindemann.More_Multivariate_Polynomial_HLW"
### 0.194s elapsed time, 0.697s cpu time, 0.112s GC time
Loading theory "Polynomial_Interpolation.Lagrange_Interpolation" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Interpolation.Polynomial_Interpolation")
### theory "Polynomial_Interpolation.Lagrange_Interpolation"
### 0.116s elapsed time, 0.417s cpu time, 0.056s GC time
Loading theory "Subresultants.Coeff_Int" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Subresultants.Subresultant_Gcd" via "Subresultants.Subresultant")
locale UP_ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_ring R"
  defines "P == UP R"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
Found termination order:
  "(%p. size (snd (snd (snd p)))) <*mlex*>
   (%p. size (fst (snd p))) <*mlex*> {}"
### theory "Subresultants.Coeff_Int"
### 1.970s elapsed time, 7.386s cpu time, 5.058s GC time
Loading theory "Sturm_Sequences.Misc_Polynomial" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Sturm_Sequences.Sturm_Theorem" via "Sturm_Sequences.Sturm_Library")
### theory "Berlekamp_Zassenhaus.Karatsuba_Multiplication"
### 4.455s elapsed time, 16.502s cpu time, 6.574s GC time
Loading theory "Berlekamp_Zassenhaus.Polynomial_Record_Based" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
### theory "Sturm_Sequences.Misc_Polynomial"
### 0.581s elapsed time, 2.223s cpu time, 0.357s GC time
Loading theory "Sturm_Sequences.Sturm_Library" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Sturm_Sequences.Sturm_Theorem")
### theory "Sturm_Sequences.Sturm_Library"
### 0.049s elapsed time, 0.193s cpu time, 0.000s GC time
Loading theory "Sturm_Sequences.Sturm_Theorem" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat")
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale quasi_sturm_seq
  fixes ps :: "real poly list"
  assumes "quasi_sturm_seq ps"
locale sturm_seq
  fixes ps :: "real poly list"
    and p :: "real poly"
  assumes "sturm_seq ps p"
locale UP_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_cring R"
  defines "P == UP R"
### Missing patterns in function definition:
### !!b. split_sign_changes [] b = undefined
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
Found termination order: "{}"
locale UP_domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and P :: "('a, nat => 'a) up_ring"  (structure)
  assumes "UP_domain R"
  defines "P == UP R"
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
### theory "HOL-Algebra.Multiplicative_Group"
### 4.483s elapsed time, 16.768s cpu time, 6.529s GC time
Loading theory "Subresultants.Dichotomous_Lazard" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Subresultants.Subresultant_Gcd" via "Subresultants.Subresultant")
### theory "Sturm_Sequences.Sturm_Theorem"
### 1.252s elapsed time, 4.712s cpu time, 0.717s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.ExtrEqs")
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
### theory "Subresultants.Dichotomous_Lazard"
### 0.266s elapsed time, 0.994s cpu time, 0.160s GC time
Loading theory "Jordan_Normal_Form.Conjugate" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Jordan_Normal_Form.Matrix")
class conjugate = type +
  fixes conjugate :: "'a => 'a"
  assumes "conjugate_id": "!!a. conjugate (conjugate a) = a"
    and
    "conjugate_cancel_iff": "!!a b. (conjugate a = conjugate b) = (a = b)"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class conjugatable_ring = conjugate + ring +
  assumes
    "conjugate_dist_mul":
      "!!a b. conjugate (a * b) = conjugate a * conjugate b"
    and
    "conjugate_dist_add":
      "!!a b. conjugate (a + b) = conjugate a + conjugate b"
    and "conjugate_neg": "!!a. conjugate (- a) = - conjugate a"
    and "conjugate_zero": "conjugate (0::'a) = (0::'a)"
### theory "HOL-Library.BigO"
### 0.929s elapsed time, 3.409s cpu time, 0.485s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Linear_Recurrences_SolverTemplates")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.791s elapsed time, 2.845s cpu time, 0.449s GC time
Loading theory "HOL-Number_Theory.Totient" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field" via "HOL-Number_Theory.Residues")
class conjugatable_ordered_ring = conjugatable_ring +
  ordered_comm_monoid_add +
  assumes "conjugate_square_positive": "!!a. (0::'a) <= a * conjugate a"
Found termination order:
  "(%p. size (snd (snd (snd p)))) <*mlex*>
   (%p. size (fst (snd p))) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  totient_naive :: "nat => nat => nat => nat"
### Ambiguous input (line 1808 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" map_of)
###                 ("_cargs" ("_position" ys) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" map_of)
###                   ("_cargs" ("_position" ys) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "HOL-Number_Theory.Totient"
### 2.166s elapsed time, 7.993s cpu time, 6.019s GC time
Loading theory "HOL-Number_Theory.Residues" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Berlekamp_Zassenhaus.Finite_Field")
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
locale residues
  fixes m :: "int"
    and R :: "int ring"  (structure)
  assumes "residues m"
  defines "R == residue_ring m"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale ring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "ring_ops ops R"
Found termination order: "{}"
locale residues
  fixes m :: "int"
    and R :: "int ring"  (structure)
  assumes "residues m"
  defines "R == residue_ring m"
locale idom_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "idom_ops ops R"
locale idom_divide_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "idom_divide_ops ops R"
locale field_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "field_ops ops R"
locale ring_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "ring_ops ops R"
### theory "Berlekamp_Zassenhaus.Polynomial_Record_Based"
### 6.866s elapsed time, 25.527s cpu time, 8.665s GC time
Loading theory "Sqrt_Babylonian.Sqrt_Babylonian_Auxiliary" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Polynomial_Interpolation.Newton_Interpolation" via "Polynomial_Interpolation.Is_Rat_To_Rat")
locale residues_prime
  fixes p :: "nat"
    and R :: "int ring"  (structure)
  assumes "residues_prime p"
  defines "R == residue_ring (int p)"
instantiation
  complex :: conjugatable_ordered_field
  conjugate_complex == conjugate :: complex => complex
instantiation
  real :: conjugatable_ordered_field
  conjugate_real == conjugate :: real => real
instantiation
  rat :: conjugatable_ordered_field
  conjugate_rat == conjugate :: rat => rat
instantiation
  int :: conjugatable_ordered_ring
  conjugate_int == conjugate :: int => int
### theory "Jordan_Normal_Form.Conjugate"
### 5.135s elapsed time, 19.007s cpu time, 7.593s GC time
Loading theory "Polynomial_Factorization.Missing_List" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization" via "Berlekamp_Zassenhaus.More_Missing_Multiset" via "Polynomial_Factorization.Missing_Multiset")
Found termination order: "{}"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
locale residues_prime
  fixes p :: "nat"
    and R :: "int ring"  (structure)
  assumes "residues_prime p"
  defines "R == residue_ring (int p)"
### theory "Sqrt_Babylonian.Sqrt_Babylonian_Auxiliary"
### 0.521s elapsed time, 1.987s cpu time, 0.283s GC time
Loading theory "Polynomial_Interpolation.Is_Rat_To_Rat" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Polynomial_Interpolation.Newton_Interpolation")
Found termination order: "size_list length <*mlex*> {}"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
### theory "HOL-Number_Theory.Residues"
### 1.982s elapsed time, 7.506s cpu time, 1.095s GC time
Loading theory "Berlekamp_Zassenhaus.Chinese_Remainder_Poly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "{}"
consts
  list_union :: "'a list => 'a list => 'a list"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
consts
  list_diff :: "'a list => 'a list => 'a list"
### Ignoring duplicate rewrite rule:
### set ?xs1 <= set ?ys1 == list_all (%x. x : set ?ys1) ?xs1
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
### theory "Berlekamp_Zassenhaus.Chinese_Remainder_Poly"
### 0.677s elapsed time, 2.523s cpu time, 0.464s GC time
Loading theory "Sqrt_Babylonian.Log_Impl" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Explicit_Roots" via "Sqrt_Babylonian.Sqrt_Babylonian" via "Sqrt_Babylonian.NthRoot_Impl")
### Missing patterns in function definition:
### min_list [] = undefined
class is_rat = field_char_0 +
  fixes is_rat :: "'a => bool"
    and to_rat :: "'a => rat"
  assumes
    "is_rat":
      "!!x. is_rat x = (x : field_char_0.Rats (/) (1::'a) (+) (0::'a) (-))"
    and
    "to_rat":
      "!!x. to_rat x =
            (if x : field_char_0.Rats (/) (1::'a) (+) (0::'a) (-)
             then THE y.
                     x = field_char_0.of_rat (/) (1::'a) (+) (0::'a) (-) y
             else 0)"
instantiation
  rat :: is_rat
  is_rat_rat == is_rat :: rat => bool
  to_rat_rat == to_rat :: rat => rat
instantiation
  real :: is_rat
  is_rat_real == is_rat :: real => bool
  to_rat_real == to_rat :: real => rat
instantiation
  complex :: is_rat
  is_rat_complex == is_rat :: complex => bool
  to_rat_complex == to_rat :: complex => rat
Found termination order: "length <*mlex*> {}"
### theory "Polynomial_Interpolation.Is_Rat_To_Rat"
### 1.228s elapsed time, 4.569s cpu time, 0.849s GC time
Loading theory "Factor_Algebraic_Polynomial.Is_Int_To_Int" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly")
consts
  permut_aux :: "'a list => (nat => nat) => 'a list => 'a list"
### theory "Factor_Algebraic_Polynomial.Is_Int_To_Int"
### 0.052s elapsed time, 0.208s cpu time, 0.000s GC time
Loading theory "Native_Word.Code_Int_Integer_Conversion" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
### theory "Native_Word.Code_Int_Integer_Conversion"
### 0.056s elapsed time, 0.197s cpu time, 0.069s GC time
Loading theory "Open_Induction.Restricted_Predicates" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences" via "Well_Quasi_Orders.Almost_Full")
Found termination order: "{}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Sqrt_Babylonian.Log_Impl"
### 0.297s elapsed time, 1.107s cpu time, 0.188s GC time
Loading theory "Sqrt_Babylonian.NthRoot_Impl" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Explicit_Roots" via "Sqrt_Babylonian.Sqrt_Babylonian")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale fixed_root
  fixes p :: "nat"
    and pm :: "nat"
  assumes "fixed_root p pm"
Proofs for inductive predicate(s) "accessible_on"
  Proving monotonicity ...
### theory "Open_Induction.Restricted_Predicates"
### 0.462s elapsed time, 1.709s cpu time, 0.368s GC time
Loading theory "Polynomial_Interpolation.Divmod_Int" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Polynomial_Interpolation.Newton_Interpolation")
locale fixed_root
  fixes p :: "nat"
    and pm :: "nat"
  assumes "fixed_root p pm"
### theory "Polynomial_Interpolation.Divmod_Int"
### 0.054s elapsed time, 0.196s cpu time, 0.057s GC time
Loading theory "Jordan_Normal_Form.Matrix" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Polynomial_Factorization.Missing_List"
### 3.966s elapsed time, 14.818s cpu time, 7.859s GC time
Loading theory "Polynomial_Factorization.Missing_Multiset" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization" via "Berlekamp_Zassenhaus.More_Missing_Multiset")
### theory "Sqrt_Babylonian.NthRoot_Impl"
### 2.356s elapsed time, 8.802s cpu time, 6.750s GC time
Loading theory "Sqrt_Babylonian.Sqrt_Babylonian" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Explicit_Roots")
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
locale sqrt_approximation
  fixes \<epsilon> :: "'a"
    and n :: "'a"
  assumes "sqrt_approximation \<epsilon> n"
### theory "Polynomial_Factorization.Missing_Multiset"
### 0.276s elapsed time, 1.047s cpu time, 0.163s GC time
Loading theory "Berlekamp_Zassenhaus.More_Missing_Multiset" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Berlekamp_Zassenhaus.Unique_Factorization")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "Sqrt_Babylonian.Sqrt_Babylonian"
### 0.349s elapsed time, 1.345s cpu time, 0.163s GC time
Loading theory "Polynomial_Factorization.Explicit_Roots" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
### theory "Berlekamp_Zassenhaus.More_Missing_Multiset"
### 0.242s elapsed time, 0.939s cpu time, 0.075s GC time
Loading theory "Berlekamp_Zassenhaus.Sublist_Iteration" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Reconstruction")
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### theory "Polynomial_Factorization.Explicit_Roots"
### 0.520s elapsed time, 2.001s cpu time, 0.230s GC time
Loading theory "Polynomial_Factorization.Prime_Factorization" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization")
instantiation
  vec :: (plus) plus
  plus_vec == plus :: 'a vec => 'a vec => 'a vec
instantiation
  vec :: (minus) minus
  minus_vec == minus :: 'a vec => 'a vec => 'a vec
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  vec :: (uminus) uminus
  uminus_vec == uminus :: 'a vec => 'a vec
instantiation
  vec :: (ord) ord
  less_eq_vec == less_eq :: 'a vec => 'a vec => bool
  less_vec == less :: 'a vec => 'a vec => bool
instantiation
  vec :: (preorder) preorder
instantiation
  vec :: (order) order
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "Polynomial_Factorization.Prime_Factorization"
### 0.730s elapsed time, 2.777s cpu time, 0.447s GC time
Loading theory "Algebraic_Numbers.Complex_Roots_Real_Poly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers")
Found termination order: "{}"
locale subseqs_impl
  fixes f :: "'a => 'b => 'b"
    and sl_impl :: "('a, 'b, 'state) subseqs_impl"
locale correct_subseqs_impl
  fixes f :: "'a => 'b => 'b"
    and sl_impl :: "('a, 'b, 'state) subseqs_impl"
    and invariant :: "'b => 'a list => nat => 'state => bool"
  assumes "correct_subseqs_impl f sl_impl invariant"
instantiation
  mat :: (ord) ord
  less_eq_mat == less_eq :: 'a mat => 'a mat => bool
  less_mat == less :: 'a mat => 'a mat => bool
instantiation
  mat :: (preorder) preorder
instantiation
  mat :: (order) order
instantiation
  mat :: (plus) plus
  plus_mat == plus :: 'a mat => 'a mat => 'a mat
instantiation
  mat :: (uminus) uminus
  uminus_mat == uminus :: 'a mat => 'a mat
instantiation
  mat :: (minus) minus
  minus_mat == minus :: 'a mat => 'a mat => 'a mat
instantiation
  mat :: (semiring_0) times
  times_mat == times :: 'a mat => 'a mat => 'a mat
Found termination order:
  "(%p. size (fst (snd (snd (snd p))))) <*mlex*>
   (%p. length (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Algebraic_Numbers.Complex_Roots_Real_Poly"
### 1.181s elapsed time, 4.460s cpu time, 0.587s GC time
Loading theory "Berlekamp_Zassenhaus.Unique_Factorization" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly")
locale subseqs_foldr_impl
  fixes f :: "'a => 'b => 'b"
    and impl :: "('a, 'b, 'state) subseqs_foldr_impl"
Found termination order: "length <*mlex*> {}"
locale correct_subseqs_foldr_impl
  fixes f :: "'a => 'b => 'b"
    and impl :: "('a, 'b, 'state) subseqs_foldr_impl"
    and invariant :: "'b => 'a list => nat => 'state => bool"
  assumes "correct_subseqs_foldr_impl f impl invariant"
locale my_subseqs
  fixes f :: "'a => 'b => 'b"
locale semiring_hom
  fixes hom :: "'a => 'b"
  assumes "semiring_hom hom"
instantiation
  vec :: (conjugate) conjugate
  conjugate_vec == conjugate :: 'a vec => 'a vec
### theory "Jordan_Normal_Form.Matrix"
### 5.886s elapsed time, 22.196s cpu time, 8.408s GC time
Loading theory "Jordan_Normal_Form.Gauss_Jordan_Elimination" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl")
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
locale comm_monoid_mult_isom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_mult_isom hom"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (snd (snd p))) <*mlex*> {}"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
Found termination order:
  "case_sum (%p. size_list (%p. size (fst p)) (snd (snd p)))
    (%p. size_list (%p. size (fst p)) (fst (snd (snd p)))) <*mlex*>
   case_sum (%x. 0) (%x. Suc 0) <*mlex*>
   case_sum (%p. size_list (%p. size (fst p)) (snd (snd p)))
    (%p. size_list size (snd (snd (snd (snd p))))) <*mlex*>
   {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "{}"
### theory "Jordan_Normal_Form.Gauss_Jordan_Elimination"
### 1.517s elapsed time, 5.398s cpu time, 1.022s GC time
Loading theory "Jordan_Normal_Form.Column_Operations" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Subresultants.More_Homomorphisms" via "Jordan_Normal_Form.Determinant")
### theory "Berlekamp_Zassenhaus.Sublist_Iteration"
### 5.105s elapsed time, 18.891s cpu time, 2.967s GC time
Loading theory "Polynomial_Factorization.Dvd_Int_Poly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization")
class ufd = idom +
  assumes
    "mset_factors_exist":
      "!!x. [| x ~= (0::'a); ~ x dvd (1::'a) |] ==> EX F. mset_factors F x"
    and
    "mset_factors_unique":
      "!!x F G.
          [| mset_factors F x; mset_factors G x |] ==> rel_mset (ddvd) F G"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Jordan_Normal_Form.Column_Operations"
### 0.561s elapsed time, 1.942s cpu time, 0.393s GC time
Loading theory "Jordan_Normal_Form.Determinant" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly" via "Subresultants.More_Homomorphisms")
### theory "Polynomial_Factorization.Dvd_Int_Poly"
### 3.009s elapsed time, 10.963s cpu time, 8.163s GC time
Loading theory "Polynomial_Factorization.Gauss_Lemma" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim")
class ufd = idom +
  assumes
    "mset_factors_exist":
      "!!x. [| x ~= (0::'a); ~ x dvd (1::'a) |] ==> EX F. mset_factors F x"
    and
    "mset_factors_unique":
      "!!x F G.
          [| mset_factors F x; mset_factors G x |] ==> rel_mset (ddvd) F G"
locale comm_semiring_1_hom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_1_hom hom"
locale irreducibility_hom
  fixes hom :: "'a => 'b"
  assumes "irreducibility_hom hom"
locale unit_preserving_hom
  fixes hom :: "'a => 'b"
  assumes "unit_preserving_hom hom"
locale factor_preserving_hom
  fixes hom :: "'a => 'b"
  assumes "factor_preserving_hom hom"
locale comm_semiring_isom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_isom hom"
### theory "Jordan_Normal_Form.Determinant"
### 3.807s elapsed time, 14.185s cpu time, 8.541s GC time
Loading theory "Jordan_Normal_Form.Char_Poly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers")
### theory "Polynomial_Factorization.Gauss_Lemma"
### 1.407s elapsed time, 5.361s cpu time, 0.790s GC time
Loading theory "Polynomial_Factorization.Gcd_Rat_Poly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
### theory "Polynomial_Factorization.Gcd_Rat_Poly"
### 0.107s elapsed time, 0.403s cpu time, 0.126s GC time
Loading theory "Polynomial_Factorization.Rational_Root_Test" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
### theory "Polynomial_Factorization.Rational_Root_Test"
### 0.422s elapsed time, 1.632s cpu time, 0.146s GC time
Loading theory "Polynomial_Interpolation.Newton_Interpolation" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim")
class comm_monoid_gcd = gcd + comm_semiring_1 +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
locale inj_comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_ring_hom hom"
### theory "Jordan_Normal_Form.Char_Poly"
### 1.072s elapsed time, 4.100s cpu time, 0.563s GC time
Loading theory "Subresultants.More_Homomorphisms" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim" via "Berlekamp_Zassenhaus.Unique_Factorization_Poly")
class comm_monoid_gcd = gcd + comm_semiring_1 +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
### Rewrite rule not in simpset:
### [:?x1 * ?y1:] == [:?x1:] * [:?y1:]
### Rewrite rule not in simpset:
### [:?x1 + ?y1:] == [:?x1:] + [:?y1:]
### Rewrite rule not in simpset:
### [:- ?x1:] == - [:?x1:]
### theory "Subresultants.More_Homomorphisms"
### 0.727s elapsed time, 2.771s cpu time, 0.335s GC time
Loading theory "Subresultants.Resultant_Prelim" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Resultant")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### !!v va b c. divided_differences_impl (v # va) b c [] = undefined
Found termination order: "(%p. length (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Subresultants.Resultant_Prelim"
### 0.524s elapsed time, 1.991s cpu time, 0.251s GC time
Loading theory "Regular-Sets.Regular_Set" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method" via "Regular-Sets.Equivalence_Checking" via "Regular-Sets.NDerivative" via "Regular-Sets.Regular_Exp")
overloading
  lang_pow \<equiv> compow :: nat => 'a list set => 'a list set
consts
  lang_pow :: "nat => 'a list set => 'a list set"
### theory "Regular-Sets.Regular_Set"
### 0.296s elapsed time, 1.107s cpu time, 0.189s GC time
Loading theory "Regular-Sets.Regular_Exp" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method" via "Regular-Sets.Equivalence_Checking" via "Regular-Sets.NDerivative")
### Missing patterns in function definition:
### !!v va b c. divided_differences_impl_int (v # va) b c [] = undefined
Found termination order:
  "(%p. size_list (nat o abs) (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size_list (nat o abs) (snd p)) <*mlex*> {}"
### theory "Polynomial_Interpolation.Newton_Interpolation"
### 2.605s elapsed time, 9.864s cpu time, 1.381s GC time
Loading theory "Polynomial_Interpolation.Polynomial_Interpolation" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization")
locale gcd_condition
  fixes ty :: "'a itself"
  assumes "gcd_condition TYPE('a)"
### Cannot skip proof of schematic goal statement
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  lang :: "'a rexp => 'a list set"
consts
  nullable :: "'a rexp => bool"
consts
  rexp_empty :: "'a rexp => bool"
instantiation
  rexp :: (order) order
  less_eq_rexp == less_eq :: 'a rexp => 'a rexp => bool
  less_rexp == less :: 'a rexp => 'a rexp => bool
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Berlekamp_Zassenhaus.Unique_Factorization"
### 11.609s elapsed time, 43.098s cpu time, 13.272s GC time
Loading theory "Berlekamp_Zassenhaus.Unique_Factorization_Poly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers_Prelim")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 2563 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" v))
###           ("_case_syntax"
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))
###               ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                 ("_applC" ("_position" Some)
###                   ("_applC" ("_position" f)
###                     ("_cargs" ("_position" k)
###                       ("_cargs" ("_position" w) ("_position" v)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" w))
###             ("_applC" ("_position" Some)
###               ("_applC" ("_position" f)
###                 ("_cargs" ("_position" k)
###                   ("_cargs" ("_position" w) ("_position" v)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Polynomial_Interpolation.Polynomial_Interpolation"
### 2.186s elapsed time, 8.177s cpu time, 1.631s GC time
Loading theory "Show.Show" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Show.Show_Poly" via "Show.Show_Instances")
instantiation
  rexp :: (linorder) linorder
### theory "Regular-Sets.Regular_Exp"
### 2.846s elapsed time, 10.646s cpu time, 2.008s GC time
Loading theory "Regular-Sets.NDerivative" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method" via "Regular-Sets.Equivalence_Checking")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class show = type +
  fixes shows_prec :: "nat => 'a => char list => char list"
    and shows_list :: "'a list => char list => char list"
  assumes
    "shows_prec_append":
      "!!p x r s. shows_prec p x (r @ s) = shows_prec p x r @ s"
    and
    "shows_list_append":
      "!!xs r s. shows_list xs (r @ s) = shows_list xs r @ s"
instantiation
  fract :: (idom) {normalization_euclidean_semiring,euclidean_ring}
  normalize_fract == normalize :: 'a fract => 'a fract
  unit_factor_fract == unit_factor :: 'a fract => 'a fract
  euclidean_size_fract == euclidean_size :: 'a fract => nat
  modulo_fract == modulo :: 'a fract => 'a fract => 'a fract
instantiation
  fract :: (idom) euclidean_ring_gcd
  Gcd_fract == Gcd :: 'a fract set => 'a fract
  Lcm_fract == Lcm :: 'a fract set => 'a fract
  gcd_fract == gcd :: 'a fract => 'a fract => 'a fract
  lcm_fract == lcm :: 'a fract => 'a fract => 'a fract
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
instantiation
  fract :: (idom) unique_euclidean_ring
  division_segment_fract == division_segment :: 'a fract => 'a fract
instantiation
  char :: show
  shows_prec_char == shows_prec :: nat => char => char list => char list
  shows_list_char == shows_list :: char list => char list => char list
signature SHOW_GENERATOR =
  sig
    val generate_showsp: string -> local_theory -> local_theory
    val register_foreign_partial_and_full_showsp:
       string ->
         int ->
           term ->
             term ->
               thm option ->
                 term ->
                   thm option ->
                     bool list -> thm -> local_theory -> local_theory
    val register_foreign_showsp:
       typ -> term -> thm -> local_theory -> local_theory
    val show_instance: string -> theory -> theory
  end
structure Show_Generator: SHOW_GENERATOR
instantiation
  list :: (show) show
  shows_prec_list == shows_prec :: nat => 'a list => char list => char list
  shows_list_list == shows_list :: 'a list list => char list => char list
### theory "Berlekamp_Zassenhaus.Unique_Factorization_Poly"
### 4.337s elapsed time, 15.926s cpu time, 10.063s GC time
Loading theory "Algebraic_Numbers.Algebraic_Numbers_Prelim" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers")
instantiation
  String.literal :: show
  shows_prec_literal == shows_prec ::
    nat => String.literal => char list => char list
  shows_list_literal == shows_list ::
    String.literal list => char list => char list
### theory "Show.Show"
### 3.399s elapsed time, 12.448s cpu time, 9.319s GC time
Loading theory "Algebraic_Numbers.Bivariate_Polynomials" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers" via "Algebraic_Numbers.Resultant")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 2939 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2972 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Code generator: dropping subsumed code equation
### keys (Branch ?c ?l ?k ?v ?r) == keys ?l @ ?k # keys ?r
### Code generator: dropping subsumed code equation
### keys Empty == []
### theory "HOL-Library.RBT_Impl"
### 71.428s elapsed time, 260.131s cpu time, 109.184s GC time
Loading theory "Containers.RBT_ext" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
Found termination order:
  "(%p. size (fst p)) <*mlex*> (%p. size (snd p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
consts
  RBT_Impl_diag :: "('a, 'b) rbt => ('a * 'a, 'b) rbt"
### theory "Algebraic_Numbers.Bivariate_Polynomials"
### 1.650s elapsed time, 6.298s cpu time, 0.840s GC time
Loading theory "Deriving.RBT_Comparator_Impl" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2" via "Containers.RBT_Mapping2")
### Ignoring duplicate rewrite rule:
### content (pCons ?a1 ?p1) == gcd ?a1 (content ?p1)
locale dvd_preserving_hom
  fixes hom :: "'a => 'b"
  assumes "dvd_preserving_hom hom"
consts
  rbt_comp_lookup :: "('a, 'b) rbt => 'a => 'b option"
Found termination order: "length <*mlex*> {}"
Found termination order: "{}"
### Missing patterns in function definition:
### rbt_keys_next ([], rbt.Empty) = undefined
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
### Missing patterns in function definition:
### rbt_entries_next ([], rbt.Empty) = undefined
### theory "Algebraic_Numbers.Algebraic_Numbers_Prelim"
### 2.329s elapsed time, 8.845s cpu time, 1.304s GC time
Loading theory "HOL-Library.RBT" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Factorization.Precomputation" via "HOL-Library.RBT_Mapping")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Containers.RBT_ext"
### 2.147s elapsed time, 8.124s cpu time, 1.289s GC time
Loading theory "Algebraic_Numbers.Interval_Arithmetic" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
consts
  norm :: "'a rexp => 'a rexp"
consts
  nderiv :: "'a => 'a rexp => 'a rexp"
### theory "Regular-Sets.NDerivative"
### 6.144s elapsed time, 22.864s cpu time, 10.925s GC time
Loading theory "Algebraic_Numbers.Min_Int_Poly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
### theory "HOL-Library.RBT"
### 0.618s elapsed time, 2.308s cpu time, 0.426s GC time
Loading theory "HOL-Library.RBT_Mapping" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization" via "Polynomial_Factorization.Precomputation")
### theory "Algebraic_Numbers.Min_Int_Poly"
### 0.166s elapsed time, 0.605s cpu time, 0.115s GC time
Loading theory "Berlekamp_Zassenhaus.Poly_Mod" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field")
### theory "HOL-Library.RBT_Mapping"
### 0.309s elapsed time, 1.129s cpu time, 0.234s GC time
Loading theory "Algebraic_Numbers.Resultant" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Algebraic_Numbers")
instantiation
  interval :: (zero) zero
  zero_interval == zero_class.zero :: 'a interval
instantiation
  interval :: (one) one
  one_interval == one_class.one :: 'a interval
instantiation
  interval :: (plus) plus
  plus_interval == plus :: 'a interval => 'a interval => 'a interval
Found termination order: "{}"
instantiation
  interval :: (uminus) uminus
  uminus_interval == uminus :: 'a interval => 'a interval
Found termination order: "{}"
instantiation
  interval :: (minus) minus
  minus_interval == minus :: 'a interval => 'a interval => 'a interval
Found termination order: "{}"
instantiation
  interval :: ({times,ord}) times
  times_interval == times :: 'a interval => 'a interval => 'a interval
Found termination order: "{}"
instantiation
  interval :: ({inverse,times,ord}) inverse
  inverse_interval == inverse :: 'a interval => 'a interval
  divide_interval == divide :: 'a interval => 'a interval => 'a interval
Found termination order: "{}"
Found termination order: "{}"
locale poly_mod
  fixes m :: "int"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
locale poly_mod
  fixes m :: "int"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
instantiation
  complex_interval :: comm_monoid_add
  zero_complex_interval == zero_class.zero :: complex_interval
  plus_complex_interval == plus ::
    complex_interval => complex_interval => complex_interval
locale poly_mod
  fixes m :: "int"
Found termination order: "(%p. size (snd (snd (snd (snd p))))) <*mlex*> {}"
Found termination order: "{}"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
instantiation
  complex_interval :: mult_zero
  times_complex_interval == times ::
    complex_interval => complex_interval => complex_interval
locale poly_mod
  fixes m :: "int"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
Found termination order: "{}"
instantiation
  complex_interval :: minus
  minus_complex_interval == minus ::
    complex_interval => complex_interval => complex_interval
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "{}"
locale poly_mod_prime
  fixes p :: "int"
  assumes "poly_mod_prime p"
locale poly_mod
  fixes m :: "int"
### theory "Algebraic_Numbers.Interval_Arithmetic"
### 2.770s elapsed time, 10.156s cpu time, 1.883s GC time
Loading theory "Factor_Algebraic_Polynomial.Roots_via_IA" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly")
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
### theory "Berlekamp_Zassenhaus.Poly_Mod"
### 2.342s elapsed time, 8.546s cpu time, 1.596s GC time
Loading theory "Regular-Sets.Equivalence_Checking" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method")
### theory "Algebraic_Numbers.Resultant"
### 2.090s elapsed time, 7.619s cpu time, 1.415s GC time
Loading theory "Algebraic_Numbers.Algebraic_Numbers" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
Proofs for coinductive predicate(s) "bisimilar"
  Proving monotonicity ...
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
consts
  add_atoms :: "'a rexp => 'a list => 'a list"
consts
  rbt_comp_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
### theory "Regular-Sets.Equivalence_Checking"
### 38.462s elapsed time, 132.932s cpu time, 131.817s GC time
Loading theory "Regular-Sets.Relation_Interpretation" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting" via "Regular-Sets.Regexp_Method")
consts
  rel :: "('a => ('b * 'b) set) => 'a rexp => ('b * 'b) set"
consts
  word_rel :: "('a => ('b * 'b) set) => 'a list => ('b * 'b) set"
### theory "Regular-Sets.Relation_Interpretation"
### 0.063s elapsed time, 0.258s cpu time, 0.000s GC time
Loading theory "Regular-Sets.Regexp_Method" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders" via "Abstract-Rewriting.Abstract_Rewriting")
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Polynomial.poly" found.
consts
  rel_of_regexp :: "('a * 'a) set list => nat rexp => ('a * 'a) set"
consts
  rel_eq :: "nat rexp * nat rexp => ('a * 'a) set list => bool"
### theory "Factor_Algebraic_Polynomial.Roots_via_IA"
### 38.805s elapsed time, 134.286s cpu time, 131.875s GC time
Loading theory "Show.Show_Instances" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Show.Show_Poly")
consts
  showsp_bool :: "nat => bool => char list => char list"
consts
  pshowsp_prod ::
    "nat
     => (char list => char list) * (char list => char list)
        => char list => char list"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
locale idom_isom
  fixes hom :: "'a => 'b"
  assumes "idom_isom hom"
val regexp_conv = fn: Proof.context -> conv
### theory "Regular-Sets.Regexp_Method"
### 0.729s elapsed time, 2.890s cpu time, 0.174s GC time
Loading theory "Abstract-Rewriting.Abstract_Rewriting" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier" via "Abstract-Rewriting.SN_Orders")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
deriving "show" instance for type "Option.option"
generating show function for type "Option.option"
deriving "show" instance for type "Sum_Type.sum"
generating show function for type "Sum_Type.sum"
deriving "show" instance for type "Product_Type.prod"
deriving "show" instance for type "Product_Type.unit"
deriving "show" instance for type "HOL.bool"
deriving "show" instance for type "Nat.nat"
deriving "show" instance for type "Int.int"
deriving "show" instance for type "Rat.rat"
### theory "Algebraic_Numbers.Algebraic_Numbers"
### 1.711s elapsed time, 6.716s cpu time, 0.618s GC time
Loading theory "Subresultants.Binary_Exponentiation" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Subresultants.Subresultant_Gcd" via "Subresultants.Subresultant")
class monoid_mult = semigroup_mult + power +
  assumes "mult_1_left": "!!a. (1::'a) * a = a"
    and "mult_1_right": "!!a. a * (1::'a) = a"
### theory "Show.Show_Instances"
### 1.223s elapsed time, 4.798s cpu time, 0.496s GC time
Loading theory "Show.Show_Poly" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Subresultants.Binary_Exponentiation"
### 0.252s elapsed time, 0.973s cpu time, 0.246s GC time
Loading theory "Berlekamp_Zassenhaus.Finite_Field" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp")
Found termination order: "{}"
Proofs for inductive predicate(s) "SN_partp"
  Proving monotonicity ...
Found termination order: "{}"
Found termination order: "{}"
### theory "Abstract-Rewriting.Abstract_Rewriting"
### 1.419s elapsed time, 5.579s cpu time, 0.699s GC time
Loading theory "Abstract-Rewriting.SN_Orders" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Abstract-Rewriting.SN_Order_Carrier")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  poly :: ({one,zero,show}) show
  shows_prec_poly == shows_prec :: nat => 'a poly => char list => char list
  shows_list_poly == shows_list :: 'a poly list => char list => char list
### theory "Show.Show_Poly"
### 0.941s elapsed time, 3.662s cpu time, 0.675s GC time
Loading theory "Subresultants.Subresultant" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Subresultants.Subresultant_Gcd")
class non_strict_order = ord +
  assumes "ge_refl": "!!x. x <= x"
    and "ge_trans": "!!y x z. [| y <= x; z <= y |] ==> z <= x"
    and "max_comm": "!!x y. max x y = max y x"
    and "max_ge_x": "!!x y. x <= max x y"
    and "max_id": "!!y x. y <= x ==> max x y = x"
    and "max_mono": "!!y x z. y <= x ==> max z y <= max z x"
class ordered_ab_semigroup = ab_semigroup_add + monoid_add +
  non_strict_order +
  assumes "plus_left_mono": "!!y x z. y <= x ==> y + z <= x + z"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  mod_ring :: (finite) equal
  equal_mod_ring == equal_class.equal :: 'a mod_ring => 'a mod_ring => bool
### theory "Deriving.RBT_Comparator_Impl"
### 45.058s elapsed time, 157.927s cpu time, 135.681s GC time
Loading theory "Containers.RBT_Mapping2" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl" via "Containers.RBT_Set2")
instantiation
  mod_ring :: (finite) comm_ring
  uminus_mod_ring == uminus :: 'a mod_ring => 'a mod_ring
  times_mod_ring == times :: 'a mod_ring => 'a mod_ring => 'a mod_ring
  zero_mod_ring == zero_class.zero :: 'a mod_ring
  minus_mod_ring == minus :: 'a mod_ring => 'a mod_ring => 'a mod_ring
  plus_mod_ring == plus :: 'a mod_ring => 'a mod_ring => 'a mod_ring
class SN_Orders.ordered_semiring_0 = semiring_0 + ordered_ab_semigroup +
  assumes
    "times_left_mono":
      "!!z y x. [| (0::'a) <= z; y <= x |] ==> y * z <= x * z"
    and
    "times_right_mono":
      "!!x z y. [| (0::'a) <= x; z <= y |] ==> x * z <= x * y"
    and
    "times_left_anti_mono":
      "!!y x z. [| y <= x; z <= (0::'a) |] ==> x * z <= y * z"
### Additional type variable(s) in locale specification "nontriv": 'a
class nontriv = type +
  assumes "nontriv": "1 < CARD('a)"
class ordered_semiring_1 = semiring_1 + SN_Orders.ordered_semiring_0 +
  assumes "one_ge_zero": "(0::'a) <= (1::'a)"
locale order_pair
  fixes gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and default :: "'a"
  assumes "order_pair (\<succ>) default"
locale one_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
  assumes "one_mono_ordered_semiring_1 default (\<succ>)"
locale SN_one_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
  assumes "SN_one_mono_ordered_semiring_1 default (\<succ>)"
locale SN_strict_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and mono :: "'a => bool"
  assumes "SN_strict_mono_ordered_semiring_1 default (\<succ>) mono"
locale both_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and arc_pos :: "'a => bool"
  assumes "both_mono_ordered_semiring_1 default (\<succ>) arc_pos"
locale SN_both_mono_ordered_semiring_1
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and arc_pos :: "'a => bool"
  assumes "SN_both_mono_ordered_semiring_1 default (\<succ>) arc_pos"
locale weak_SN_strict_mono_ordered_semiring_1
  fixes weak_gt :: "'a => 'a => bool"
    and default :: "'a"
    and mono :: "'a => bool"
  assumes "weak_SN_strict_mono_ordered_semiring_1 weak_gt default mono"
locale weak_SN_both_mono_ordered_semiring_1
  fixes weak_gt :: "'a => 'a => bool"
    and default :: "'a"
    and arc_pos :: "'a => bool"
  assumes "weak_SN_both_mono_ordered_semiring_1 weak_gt default arc_pos"
instantiation
  mod_ring :: (nontriv) comm_ring_1
  one_mod_ring == one_class.one :: 'a mod_ring
### Additional type variable(s) in locale specification "prime_card": 'a
class prime_card = type +
  assumes "prime_card": "prime CARD('a)"
locale div_exp_param
  fixes div_exp :: "'a => 'a => nat => 'a"
locale div_exp_sound
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound div_exp"
locale poly_order_carrier
  fixes default :: "'a"
    and gt :: "'a => 'a => bool"  (infix \<open>\<succ>\<close> 50)
    and power_mono :: "bool"
    and discrete :: "bool"
  assumes "poly_order_carrier default (\<succ>) power_mono discrete"
instantiation
  mod_ring :: (prime_card) field
  inverse_mod_ring == inverse :: 'a mod_ring => 'a mod_ring
  divide_mod_ring == divide :: 'a mod_ring => 'a mod_ring => 'a mod_ring
instantiation
  mod_ring :: (prime_card) {normalization_euclidean_semiring,euclidean_ring}
  normalize_mod_ring == normalize :: 'a mod_ring => 'a mod_ring
  unit_factor_mod_ring == unit_factor :: 'a mod_ring => 'a mod_ring
  euclidean_size_mod_ring == euclidean_size :: 'a mod_ring => nat
  modulo_mod_ring == modulo :: 'a mod_ring => 'a mod_ring => 'a mod_ring
instantiation
  mod_ring :: (prime_card) euclidean_ring_gcd
  Gcd_mod_ring == Gcd :: 'a mod_ring set => 'a mod_ring
  Lcm_mod_ring == Lcm :: 'a mod_ring set => 'a mod_ring
  gcd_mod_ring == gcd :: 'a mod_ring => 'a mod_ring => 'a mod_ring
  lcm_mod_ring == lcm :: 'a mod_ring => 'a mod_ring => 'a mod_ring
### Ambiguous input (line 247 of "$AFP/Containers/RBT_Mapping2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###             ("_case_syntax"
###               ("_applC" ("_position" lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v1)
###                           ("_position" v2))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###               ("_case_syntax"
###                 ("_applC" ("_position" lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v1) ("_position" v2))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.RBT_Mapping2"
### 1.223s elapsed time, 4.813s cpu time, 0.305s GC time
Loading theory "Containers.RBT_Set2" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl" via "Containers.Set_Impl")
instantiation
  mod_ring :: (prime_card) unique_euclidean_ring
  division_segment_mod_ring == division_segment ::
    'a mod_ring => 'a mod_ring
### theory "Berlekamp_Zassenhaus.Finite_Field"
### 2.494s elapsed time, 9.803s cpu time, 0.887s GC time
Loading theory "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based")
class large_ordered_semiring_1 = poly_carrier +
  assumes "ex_large_of_nat": "!!y. EX x. y <= of_nat x"
locale primitive_remainder_sequence
  fixes F :: "nat => 'a poly"
    and n :: "nat => nat"
    and \<delta> :: "nat => nat"
    and f :: "nat => 'a"
    and k :: "nat"
    and \<beta> :: "nat => 'a"
  assumes "primitive_remainder_sequence F n \<delta> f k \<beta>"
class ordered_semiring_1 = semiring_1 + SN_Orders.ordered_semiring_0 +
  assumes "one_ge_zero": "(0::'a) <= (1::'a)"
locale subresultant_prs_locale
  fixes F :: "nat => 'a fract poly"
    and n :: "nat => nat"
    and \<delta> :: "nat => nat"
    and f :: "nat => 'a fract"
    and k :: "nat"
    and \<beta> :: "nat => 'a fract"
    and G1 :: "'a poly"
    and G2 :: "'a poly"
  assumes "subresultant_prs_locale F n \<delta> f k \<beta> G1 G2"
### theory "Abstract-Rewriting.SN_Orders"
### 2.187s elapsed time, 8.575s cpu time, 0.831s GC time
Loading theory "Abstract-Rewriting.SN_Order_Carrier" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  nat :: large_ordered_semiring_1
Found termination order: "size <*mlex*> {}"
locale subresultant_prs_locale2
  fixes F :: "nat => 'a fract poly"
    and n :: "nat => nat"
    and \<delta> :: "nat => nat"
    and f :: "nat => 'a fract"
    and k :: "nat"
    and \<beta> :: "nat => 'a fract"
    and G1 :: "'a poly"
    and G2 :: "'a poly"
  assumes "subresultant_prs_locale2 F n \<delta> f k \<beta> G1 G2"
locale poly_mod_type
  fixes m :: "int"
    and ty :: "'a itself"
  assumes "poly_mod_type TYPE('a) m"
instantiation
  int :: large_ordered_semiring_1
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale poly_mod_2
  fixes m :: "int"
  assumes "poly_mod_2 m"
locale poly_mod_prime_type
  fixes m :: "int"
    and ty :: "'a itself"
  assumes "poly_mod_prime_type TYPE('a) m"
### theory "Containers.RBT_Set2"
### 1.550s elapsed time, 6.047s cpu time, 0.692s GC time
Loading theory "Polynomial_Factorization.Precomputation" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization" via "Polynomial_Factorization.Kronecker_Factorization")
locale poly_mod_prime
  fixes p :: "int"
  assumes "poly_mod_prime p"
instantiation
  arctic :: ord
  less_eq_arctic == less_eq :: arctic => arctic => bool
  less_arctic == less :: arctic => arctic => bool
Found termination order: "{}"
Found termination order: "{}"
instantiation
  arctic :: ordered_semiring_1
  one_arctic == one_class.one :: arctic
  times_arctic == times :: arctic => arctic => arctic
  zero_arctic == zero_class.zero :: arctic
  plus_arctic == plus :: arctic => arctic => arctic
Found termination order: "{}"
### theory "Polynomial_Factorization.Precomputation"
### 0.325s elapsed time, 1.269s cpu time, 0.127s GC time
Loading theory "Containers.Set_Impl" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" via "Jordan_Normal_Form.Matrix_IArray_Impl")
### theory "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field"
### 1.861s elapsed time, 7.264s cpu time, 0.820s GC time
Loading theory "Polynomial_Factorization.Kronecker_Factorization" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" via "Polynomial_Factorization.Rational_Factorization")
Found termination order: "{}"
locale div_exp_sound
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound div_exp"
locale div_exp_param
  fixes div_exp :: "'a => 'a => nat => 'a"
### Missing patterns in function definition:
### get_arctic_num MinInfty = undefined
Found termination order: "{}"
locale div_exp_sound
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound div_exp"
Found termination order: "{}"
### theory "Subresultants.Subresultant"
### 3.907s elapsed time, 15.314s cpu time, 1.417s GC time
Loading theory "Subresultants.Subresultant_Gcd" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp")
instantiation
  arctic_delta :: (ord) ord
  less_eq_arctic_delta == less_eq ::
    'a arctic_delta => 'a arctic_delta => bool
  less_arctic_delta == less :: 'a arctic_delta => 'a arctic_delta => bool
locale div_exp_sound_gcd
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound_gcd div_exp"
Found termination order: "{}"
Found termination order: "{}"
instantiation
  arctic_delta :: (linordered_field) ordered_semiring_1
  one_arctic_delta == one_class.one :: 'a arctic_delta
  times_arctic_delta == times ::
    'a arctic_delta => 'a arctic_delta => 'a arctic_delta
  zero_arctic_delta == zero_class.zero :: 'a arctic_delta
  plus_arctic_delta == plus ::
    'a arctic_delta => 'a arctic_delta => 'a arctic_delta
Found termination order: "{}"
locale subresultant_prs_gcd
  fixes F :: "nat => 'a fract poly"
    and n :: "nat => nat"
    and \<delta> :: "nat => nat"
    and f :: "nat => 'a fract"
    and k :: "nat"
    and \<beta> :: "nat => 'a fract"
    and G1 :: "'a poly"
    and G2 :: "'a poly"
  assumes "subresultant_prs_gcd F n \<delta> f k \<beta> G1 G2"
Found termination order: "{}"
locale div_exp_sound_gcd
  fixes div_exp :: "'a => 'a => nat => 'a"
  assumes "div_exp_sound_gcd div_exp"
Found termination order: "{}"
### Missing patterns in function definition:
### get_arctic_delta_num MinInfty_delta = undefined
### Partially applied constant "Dichotomous_Lazard.dichotomous_Lazard" on left hand side of equation, in theorem:
### div_exp_Lazard_gcd.gcd_impl_primitive ?G1.0 ?G2.0 ==
### normalize
###  (primitive_part (fst (div_exp_Lazard.subresultant_prs ?G1.0 ?G2.0)))
Found termination order: "{}"
### theory "Subresultants.Subresultant_Gcd"
### 0.817s elapsed time, 3.209s cpu time, 0.266s GC time
Loading theory "VectorSpace.FunctionLemmas" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace" via "VectorSpace.MonoidSums")
### theory "VectorSpace.FunctionLemmas"
### 0.031s elapsed time, 0.127s cpu time, 0.000s GC time
Loading theory "VectorSpace.RingModuleFacts" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
Found termination order: "{}"
Found termination order: "{}"
### theory "Abstract-Rewriting.SN_Order_Carrier"
### 2.927s elapsed time, 11.456s cpu time, 1.176s GC time
Loading theory "Well_Quasi_Orders.Infinite_Sequences" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences" via "Well_Quasi_Orders.Almost_Full")
### theory "Well_Quasi_Orders.Infinite_Sequences"
### 0.089s elapsed time, 0.353s cpu time, 0.000s GC time
Loading theory "Well_Quasi_Orders.Minimal_Elements" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences")
locale minimal_element
  fixes P :: "'a => 'a => bool"
    and A :: "'a set"
  assumes "minimal_element P A"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Well_Quasi_Orders.Minimal_Elements"
### 0.310s elapsed time, 1.204s cpu time, 0.188s GC time
Loading theory "Well_Quasi_Orders.Least_Enum" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences" via "Well_Quasi_Orders.Almost_Full")
locale infinitely_many1
  fixes P :: "'a => bool"
  assumes "infinitely_many1 P"
### Additional type variable(s) in specification of "enum_rel": 'a
### Additional type variable(s) in specification of "enum_dom": 'a
Found termination order: "size <*mlex*> {}"
locale infinitely_many2
  fixes P :: "'a => 'a => bool"
    and N :: "'a"
  assumes "infinitely_many2 P N"
### theory "Polynomial_Factorization.Kronecker_Factorization"
### 1.921s elapsed time, 7.512s cpu time, 0.840s GC time
Loading theory "Polynomial_Factorization.Rational_Factorization" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat" via "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp")
### Additional type variable(s) in specification of "enumchain_rel": 'a
### Additional type variable(s) in specification of "enumchain_dom": 'a
Found termination order: "size <*mlex*> {}"
### theory "VectorSpace.RingModuleFacts"
### 0.745s elapsed time, 2.904s cpu time, 0.434s GC time
Loading theory "VectorSpace.MonoidSums" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
### theory "Well_Quasi_Orders.Least_Enum"
### 0.190s elapsed time, 0.740s cpu time, 0.085s GC time
Loading theory "Well_Quasi_Orders.Almost_Full" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations" via "Well_Quasi_Orders.Minimal_Bad_Sequences")
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### theory "VectorSpace.MonoidSums"
### 0.334s elapsed time, 1.300s cpu time, 0.113s GC time
Loading theory "VectorSpace.LinearCombinations" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
Proofs for inductive predicate(s) "af"
  Proving monotonicity ...
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
### theory "Well_Quasi_Orders.Almost_Full"
### 1.149s elapsed time, 4.456s cpu time, 0.432s GC time
Loading theory "Well_Quasi_Orders.Minimal_Bad_Sequences" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils" via "Well_Quasi_Orders.Almost_Full_Relations")
locale mbs
  fixes A :: "'a set"
### Cannot skip proof of schematic goal statement
### theory "Well_Quasi_Orders.Minimal_Bad_Sequences"
### 0.342s elapsed time, 1.307s cpu time, 0.181s GC time
Loading theory "Well_Quasi_Orders.Almost_Full_Relations" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Utils")
Found termination order: "{}"
Found termination order: "{}"
### theory "Well_Quasi_Orders.Almost_Full_Relations"
### 0.420s elapsed time, 1.624s cpu time, 0.143s GC time
Loading theory "Polynomials.Utils" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class")
locale LinearCombinations.submodule
  fixes R :: "('a, 'b) ring_scheme"
    and N :: "'c set"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "LinearCombinations.submodule R N M"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### theory "Polynomials.Utils"
### 0.363s elapsed time, 1.385s cpu time, 0.245s GC time
Loading theory "Well_Quasi_Orders.Well_Quasi_Orders" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class" via "Polynomials.Power_Products")
class wqo = preorder +
  assumes "good": "!!f. good (<=) f"
### theory "Well_Quasi_Orders.Well_Quasi_Orders"
### 0.343s elapsed time, 1.319s cpu time, 0.232s GC time
Loading theory "Polynomials.Power_Products" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection" via "Polynomials.MPoly_Type_Class")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale mod_hom
  fixes R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"
    and N :: "('a, 'e, 'f) module_scheme"
    and f :: "'c => 'e"
  assumes "mod_hom R M N f"
### theory "Polynomial_Factorization.Rational_Factorization"
### 2.813s elapsed time, 10.859s cpu time, 1.329s GC time
Loading theory "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Sturm_Rat")
locale mod_hom
  fixes R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"
    and N :: "('a, 'e, 'f) module_scheme"
    and f :: "'c => 'e"
  assumes "mod_hom R M N f"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "length <*mlex*> {}"
class plus = type +
  fixes plus :: "'a => 'a => 'a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### theory "VectorSpace.LinearCombinations"
### 3.965s elapsed time, 15.284s cpu time, 1.970s GC time
Loading theory "VectorSpace.SumSpaces" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace" via "VectorSpace.VectorSpace")
### theory "Berlekamp_Zassenhaus.Square_Free_Int_To_Square_Free_GFp"
### 1.678s elapsed time, 6.454s cpu time, 0.909s GC time
Loading theory "Algebraic_Numbers.Sturm_Rat" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
class ninv_comm_monoid_add = comm_monoid_add +
  assumes "plus_eq_zero": "!!s t. s + t = (0::'a) ==> s = (0::'a)"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "VectorSpace.SumSpaces"
### 0.514s elapsed time, 1.943s cpu time, 0.353s GC time
Loading theory "VectorSpace.VectorSpace" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect" via "Jordan_Normal_Form.Missing_VectorSpace")
structure Set_Complement_Eqs: NAMED_THMS
locale vectorspace
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
  assumes "vectorspace K V"
locale subspace
  fixes K :: "('a, 'b) ring_scheme"
    and W :: "'c set"
    and V :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "subspace K W V"
### Ignoring duplicate rewrite rule:
### carrier (vs ?y) == ?y
class lcs_powerprod = comm_powerprod +
  fixes lcs :: "'a => 'a => 'a"
  assumes "adds_lcs": "!!s t. s adds lcs s t"
  assumes "lcs_adds": "!!s u t. [| s adds u; t adds u |] ==> lcs s t adds u"
  assumes "lcs_comm": "!!s t. lcs s t = lcs t s"
### Code generator: dropping subsumed code equation
### Collect ?P == set (filter ?P enum_class.enum)
### Ambiguous input (line 739 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 744 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs" ("_position" RBT_Set2.insert)
###                       ("_cargs" ("_position" dxs)
###                         ("_position" rbt)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.union"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''union DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.union"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''union DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.union"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs" ("_position" RBT_Set2.insert)
###                   ("_cargs" ("_position" dxs) ("_position" rbt)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
### Ambiguous input (line 823 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter"
###       ("_applC" ("_position" DList_set) ("_position" dxs))
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter DList_set RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter DList_set RBT_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 838 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.inter_list)
###                     ("_cargs" ("_position" rbt)
###                       ("_applC" ("_position" list_of_dlist)
###                         ("_position" dxs)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.inter" ("_applC" ("_position" RBT_set) ("_position" rbt))
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''inter RBT_set DList_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Set.inter"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''inter RBT_set DList_set: ceq = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Set.inter"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.inter_list)
###                 ("_cargs" ("_position" rbt)
###                   ("_applC" ("_position" list_of_dlist)
###                     ("_position" dxs)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class graded_dickson_powerprod = ulcs_powerprod +
  assumes "ex_dgrad": "EX d. dickson_grading d"
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
### Ignoring duplicate rewrite rule:
### T \<zero>\<^bsub>V\<^esub> == \<zero>\<^bsub>W\<^esub>
class dickson_powerprod = ulcs_powerprod +
  assumes "dickson": "almost_full_on (adds) UNIV"
### Code generator: dropping subsumed code equation
### Inf ?A ?x == INF f\<in>?A. f ?x
### Code generator: dropping subsumed code equation
### Sup ?A ?x == SUP f\<in>?A. f ?x
### Ambiguous input (line 951 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_applC" ("_position" ord.quicksort)
###                   ("_cargs"
###                     ("_applC" ("_position" lt_of_comp) ("_position" c))
###                     ("_applC" ("_position" list_of_dlist)
###                       ("_position" dxs))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" csorted_list_of_set)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''csorted_list_of_set DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" csorted_list_of_set)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''csorted_list_of_set DList_set: ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" csorted_list_of_set)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_applC" ("_position" ord.quicksort)
###               ("_cargs" ("_applC" ("_position" lt_of_comp) ("_position" c))
###                 ("_applC" ("_position" list_of_dlist)
###                   ("_position" dxs))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class semi_canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_imp_add": "!!a b. a <= b ==> EX c. b = a + c"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  ninv_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
### theory "Algebraic_Numbers.Sturm_Rat"
### 3.236s elapsed time, 12.129s cpu time, 2.213s GC time
Loading theory "Word_Lib.More_Arithmetic" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit" via "Word_Lib.More_Word")
### theory "Word_Lib.More_Arithmetic"
### 2.894s elapsed time, 11.001s cpu time, 10.753s GC time
Loading theory "Word_Lib.More_Word" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
### theory "Word_Lib.More_Word"
### 1.527s elapsed time, 5.879s cpu time, 0.731s GC time
Loading theory "Word_Lib.Bit_Shifts_Infix_Syntax" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Generic_set_bit" via "Word_Lib.Most_significant_bit")
### theory "VectorSpace.VectorSpace"
### 7.361s elapsed time, 27.902s cpu time, 13.417s GC time
Loading theory "Jordan_Normal_Form.Missing_VectorSpace" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel" via "Jordan_Normal_Form.VS_Connect")
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
locale Missing_VectorSpace.comp_fun_commute_on
  fixes f :: "'a => 'a => 'a"
    and A :: "'a set"
  assumes "Missing_VectorSpace.comp_fun_commute_on f A"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
locale Missing_VectorSpace.comp_fun_commute_on
  fixes f :: "'a => 'a => 'a"
    and A :: "'a set"
  assumes "Missing_VectorSpace.comp_fun_commute_on f A"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
locale vectorspace
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
  assumes "vectorspace K V"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class add_linorder_min = add_linorder +
  assumes "zero_min": "!!x. (0::'a) <= x"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
### theory "Word_Lib.Bit_Shifts_Infix_Syntax"
### 1.305s elapsed time, 5.081s cpu time, 0.843s GC time
Loading theory "Word_Lib.Least_significant_bit" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int")
### Code generator: dropping subsumed code equation
### set_eq ?A ?B == ?A <= ?B & ?B <= ?A
### Ambiguous input (line 1326 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###             ("_case2" ("_case1" ("_list" ("_position" x)) ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem DList_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" DList_set) ("_position" dxs)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''the_elem DList_set: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" DList_set) ("_position" dxs)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" list_of_dlist) ("_position" dxs))
###               ("_case1" ("_list" ("_position" x)) ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal"
###                   ("_position" ''the_elem DList_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dxs))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1331 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" RBT_Mapping2.impl_of) ("_position" rbt))
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))
###               ("_case1" ("\<^const>Pure.dummy_pattern")
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''the_elem RBT_set: not unique''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" the_elem)
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_elem)
###       ("_applC" ("_position" RBT_set) ("_position" rbt)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''the_elem RBT_set: ccompare = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" the_elem)
###                   ("_applC" ("_position" RBT_set) ("_position" rbt)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" RBT_Mapping2.impl_of)
###                 ("_position" rbt))
###               ("_case1"
###                 ("_applC" ("_position" RBT_Impl.Branch)
###                   ("_cargs" ("\<^const>Pure.dummy_pattern")
###                     ("_cargs" ("_position" RBT_Impl.Empty)
###                       ("_cargs" ("_position" x)
###                         ("_cargs" ("\<^const>Pure.dummy_pattern")
###                           ("_position" RBT_Impl.Empty))))))
###                 ("_position" x))))
###           ("_case1" ("\<^const>Pure.dummy_pattern")
###             ("_applC" ("_position" Code.abort)
###               ("_cargs"
###                 ("_Literal" ("_position" ''the_elem RBT_set: not unique''))
###                 ("_lambda" ("_idtdummy")
###                   ("_applC" ("_position" the_elem)
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale linear_map
  fixes K :: "('a, 'b) ring_scheme"
    and V :: "('a, 'c, 'd) module_scheme"
    and W :: "('a, 'e, 'f) module_scheme"
    and T :: "'c => 'e"
  assumes "linear_map K V W T"
### Ambiguous input (line 1387 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_applC" ("_position" DList_Set.product)
###                     ("_cargs" ("_position" dxs) ("_position" dys))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" DList_set) ("_position" dxs))
###         ("_applC" ("_position" DList_set) ("_position" dys))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" DList_set) ("_position" dxs))
###                     ("_applC" ("_position" DList_set)
###                       ("_position" dys))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dys))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_applC" ("_position" DList_Set.product)
###                 ("_cargs" ("_position" dxs) ("_position" dys))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1403 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_set)
###                   ("_applC" ("_position" RBT_Set2.product)
###                     ("_cargs" ("_position" rbt1)
###                       ("_position" rbt2))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" Product_Type.product)
###       ("_cargs" ("_applC" ("_position" RBT_set) ("_position" rbt1))
###         ("_applC" ("_position" RBT_set) ("_position" rbt2))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''product RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" Product_Type.product)
###                   ("_cargs"
###                     ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                     ("_applC" ("_position" RBT_set)
###                       ("_position" rbt2))))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''product RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" Product_Type.product)
###                         ("_cargs"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_set)
###               ("_applC" ("_position" RBT_Set2.product)
###                 ("_cargs" ("_position" rbt1) ("_position" rbt2))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1470 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" B))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" dxs)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" DList_set) ("_position" dxs)) ("_position" B))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" DList_set) ("_position" dxs))
###                   ("_position" B))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" DList_set) ("_position" dxs))
###                         ("_position" B))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" B))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" dxs) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class lsb = semiring_bits +
  fixes lsb :: "'a => bool"
  assumes "lsb_odd": "lsb = odd"
instantiation
  int :: lsb
  lsb_int == lsb :: int => bool
instantiation
  word :: (len) lsb
  lsb_word == lsb :: 'a word => bool
### Ambiguous input (line 1477 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda"
###                       ("_pttrns"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_position" acc))
###                       ("\<^const>HOL.If"
###                         ("\<^const>Set.member" ("_position" x)
###                           ("_position" C))
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" y) ("_position" acc)))
###                         ("_position" acc)))
###                     ("_cargs" ("_position" rbt)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.Image"
###       ("_applC" ("_position" RBT_set) ("_position" rbt)) ("_position" C))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'c)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal" ("_position" ''Image RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.Image"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt))
###                   ("_position" C))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position" ''Image RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.Image"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt))
###                         ("_position" C))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda"
###                   ("_pttrns" ("_pattern" ("_position" x) ("_position" y))
###                     ("_position" acc))
###                   ("\<^const>HOL.If"
###                     ("\<^const>Set.member" ("_position" x) ("_position" C))
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" y) ("_position" acc)))
###                     ("_position" acc)))
###                 ("_cargs" ("_position" rbt) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Word_Lib.Least_significant_bit"
### 0.631s elapsed time, 2.444s cpu time, 0.278s GC time
Loading theory "Word_Lib.Most_significant_bit" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Generic_set_bit")
class msb = type +
  fixes msb :: "'a => bool"
instantiation
  int :: msb
  msb_int == msb :: int => bool
instantiation
  word :: (len) msb
  msb_word == msb :: 'a word => bool
### theory "Word_Lib.Most_significant_bit"
### 0.172s elapsed time, 0.659s cpu time, 0.124s GC time
Loading theory "Word_Lib.Generic_set_bit" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int")
### Ambiguous input (line 1546 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'c)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("\<^const>HOL.not_equal"
### ("_applC" ("_position" c_b) ("_cargs" ("_position" y) ("_position" y')))
### ("_position" Eq))
###                                     ("_position" A)
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))))
###                                 ("_position" rbt2))))
###                           ("_cargs" ("_position" rbt1)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'c)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("\<^const>HOL.not_equal"
###                                   ("_applC" ("_position" c_b)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_position" Eq))
###                                 ("_position" A)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))))
###                             ("_position" rbt2))))
###                       ("_cargs" ("_position" rbt1)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt2)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'c)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("\<^const>HOL.not_equal"
###                               ("_applC" ("_position" c_b)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_position" Eq))
###                             ("_position" A)
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))))
###                         ("_position" rbt2))))
###                   ("_cargs" ("_position" rbt1)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" RBT_set) ("_position" rbt2)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp RBT_set RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt2)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt1))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt2)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'c)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set RBT_set: ccompare3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt1))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt2))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt2))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
instantiation
  nat :: add_linorder
instantiation
  nat :: add_linorder_min
instantiation
  nat :: add_wellorder
### theory "Jordan_Normal_Form.Missing_VectorSpace"
### 2.581s elapsed time, 9.989s cpu time, 1.507s GC time
Loading theory "Jordan_Normal_Form.VS_Connect" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based" via "Jordan_Normal_Form.Matrix_Kernel")
class set_bit = semiring_bits +
  fixes set_bit :: "'a => nat => bool => 'a"
  assumes
    "bit_set_bit_iff_2n":
      "!!a m b n.
          bit (set_bit_class.set_bit a m b) n =
          ((if m = n then b else bit a n) & (2::'a) ^ n ~= (0::'a))"
instantiation
  int :: set_bit
  set_bit_int == set_bit_class.set_bit :: int => nat => bool => int
instantiation
  word :: (len) set_bit
  set_bit_word == set_bit_class.set_bit :: 'a word => nat => bool => 'a word
### Ambiguous input (line 1555 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CEQ" ("_position_sort" 'e)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" RBT_Set2.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" DList_Set.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" dxs1))))
###                                 ("_cargs" ("_position" rbt3)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'e)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs1))))
###                       ("_cargs" ("_position" rbt3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CEQ" ("_position_sort" 'e)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp RBT_set DList_set: ceq3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt3))
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs1)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" DList_Set.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" dxs1))))
###                             ("_cargs" ("_position" rbt3)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CEQ" ("_position_sort" 'e)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp RBT_set DList_set: ceq3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt3))
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs1)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" DList_Set.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" dxs1))))
###                         ("_cargs" ("_position" rbt3)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set DList_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs1)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp RBT_set DList_set: ceq3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt3))
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs1)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs1))))
###                     ("_cargs" ("_position" rbt3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt3))
###       ("_applC" ("_position" DList_set) ("_position" dxs1)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set DList_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs1)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp RBT_set DList_set: ceq2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs1))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp RBT_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs1)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" RBT_Set2.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs1))))
###                   ("_cargs" ("_position" rbt3)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Word_Lib.Generic_set_bit"
### 0.726s elapsed time, 2.796s cpu time, 0.358s GC time
Loading theory "Native_Word.Code_Symbolic_Bits_Int" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
instantiation
  int :: add_linorder_group
instantiation
  rat :: add_linorder_group
instantiation
  real :: add_linorder_group
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
### theory "Native_Word.Code_Symbolic_Bits_Int"
### 0.565s elapsed time, 2.172s cpu time, 0.259s GC time
Loading theory "Native_Word.Bits_Integer" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Record_Based" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
### Ambiguous input (line 1566 of "$AFP/Containers/Set_Impl.thy") produces 14 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                       ("_case_syntax"
###                         ("_applC" ("_position" ID)
###                           ("_CCOMPARE" ("_position_sort" 'a)))
###                         ("_case2"
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))
###                           ("_case1"
###                             ("_applC" ("_position" Some)
###                               ("\<^const>Pure.dummy_pattern"))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" x)
###                                     ("_position" y))
###                                   ("_applC" ("_position" RBT_Set2.fold)
###                                     ("_cargs"
### ("_lambda"
###   ("_pttrns" ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###   ("\<^const>HOL.If"
###     ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
###     ("_applC" ("_position" insert)
###       ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###         ("_position" A)))
###     ("_position" A)))
### ("_position" rbt4))))
###                                 ("_cargs" ("_position" dxs2)
###                                   ("\<^const>Set.empty"))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CCOMPARE" ("_position_sort" 'a)))
###                     ("_case2"
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case2"
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" RBT_Set2.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" rbt4))))
###                       ("_cargs" ("_position" dxs2)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))
###                     ("_case2"
###                       ("_case1"
###                         ("_applC" ("_position" Some) ("_position" eq))
###                         ("_case_syntax"
###                           ("_applC" ("_position" ID)
###                             ("_CCOMPARE" ("_position_sort" 'a)))
###                           ("_case1" ("_position" None)
###                             ("_applC" ("_position" Code.abort)
###                               ("_cargs"
###                                 ("_Literal"
###                                   ("_position"
###                                     ''relcomp DList_set RBT_set: ccompare3 = None''))
###                                 ("_lambda" ("_idtdummy")
###                                   ("\<^const>Relation.relcomp"
###                                     ("_applC" ("_position" DList_set)
### ("_position" dxs2))
###                                     ("_applC" ("_position" RBT_set)
### ("_position" rbt4)))))))))
###                       ("_case1"
###                         ("_applC" ("_position" Some)
###                           ("\<^const>Pure.dummy_pattern"))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pattern" ("_position" x) ("_position" y))
###                               ("_applC" ("_position" RBT_Set2.fold)
###                                 ("_cargs"
###                                   ("_lambda"
###                                     ("_pttrns"
### ("_pattern" ("_position" y') ("_position" z)) ("_position" A))
###                                     ("\<^const>HOL.If"
### ("_applC" ("_position" eq) ("_cargs" ("_position" y) ("_position" y')))
### ("_applC" ("_position" insert)
###   ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###     ("_position" A)))
### ("_position" A)))
###                                   ("_position" rbt4))))
###                             ("_cargs" ("_position" dxs2)
###                               ("\<^const>Set.empty"))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'd)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))
###               ("_case2"
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4)))))))))
###                 ("_case2"
###                   ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                     ("_case_syntax"
###                       ("_applC" ("_position" ID)
###                         ("_CCOMPARE" ("_position_sort" 'a)))
###                       ("_case1" ("_position" None)
###                         ("_applC" ("_position" Code.abort)
###                           ("_cargs"
###                             ("_Literal"
###                               ("_position"
###                                 ''relcomp DList_set RBT_set: ccompare3 = None''))
###                             ("_lambda" ("_idtdummy")
###                               ("\<^const>Relation.relcomp"
###                                 ("_applC" ("_position" DList_set)
###                                   ("_position" dxs2))
###                                 ("_applC" ("_position" RBT_set)
###                                   ("_position" rbt4)))))))))
###                   ("_case1"
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Pure.dummy_pattern"))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pattern" ("_position" x) ("_position" y))
###                           ("_applC" ("_position" RBT_Set2.fold)
###                             ("_cargs"
###                               ("_lambda"
###                                 ("_pttrns"
###                                   ("_pattern" ("_position" y')
###                                     ("_position" z))
###                                   ("_position" A))
###                                 ("\<^const>HOL.If"
###                                   ("_applC" ("_position" eq)
###                                     ("_cargs" ("_position" y)
### ("_position" y')))
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs"
### ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z))) ("_position" A)))
###                                   ("_position" A)))
###                               ("_position" rbt4))))
###                         ("_cargs" ("_position" dxs2)
###                           ("\<^const>Set.empty"))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set RBT_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs2))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt4)))))))))
###           ("_case2"
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'd)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case2"
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID)
###                     ("_CCOMPARE" ("_position_sort" 'a)))
###                   ("_case1" ("_position" None)
###                     ("_applC" ("_position" Code.abort)
###                       ("_cargs"
###                         ("_Literal"
###                           ("_position"
###                             ''relcomp DList_set RBT_set: ccompare3 = None''))
###                         ("_lambda" ("_idtdummy")
###                           ("\<^const>Relation.relcomp"
###                             ("_applC" ("_position" DList_set)
###                               ("_position" dxs2))
###                             ("_applC" ("_position" RBT_set)
###                               ("_position" rbt4)))))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" rbt4))))
###                     ("_cargs" ("_position" dxs2)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs2))
###       ("_applC" ("_position" RBT_set) ("_position" rbt4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set RBT_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs2))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'd)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'd)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set RBT_set: ccompare2 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs2))
###                               ("_applC" ("_position" RBT_set)
###                                 ("_position" rbt4))))))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID)
###                   ("_CCOMPARE" ("_position_sort" 'a)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set RBT_set: ccompare3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs2))
###                           ("_applC" ("_position" RBT_set)
###                             ("_position" rbt4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" RBT_Set2.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" rbt4))))
###                   ("_cargs" ("_position" dxs2)
###                     ("\<^const>Set.empty")))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
### Ambiguous input (line 1577 of "$AFP/Containers/Set_Impl.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_case_syntax"
###                   ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                   ("_case2"
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))
###                     ("_case1"
###                       ("_applC" ("_position" Some)
###                         ("\<^const>Pure.dummy_pattern"))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pattern" ("_position" x) ("_position" y))
###                             ("_applC" ("_position" DList_Set.fold)
###                               ("_cargs"
###                                 ("_lambda"
###                                   ("_pttrns"
###                                     ("_pattern" ("_position" y')
### ("_position" z))
###                                     ("_position" A))
###                                   ("\<^const>HOL.If"
###                                     ("_applC" ("_position" eq)
### ("_cargs" ("_position" y) ("_position" y')))
###                                     ("_applC" ("_position" insert)
### ("_cargs" ("_tuple" ("_position" x) ("_tuple_arg" ("_position" z)))
###   ("_position" A)))
###                                     ("_position" A)))
###                                 ("_position" dxs4))))
###                           ("_cargs" ("_position" dxs3)
###                             ("\<^const>Set.empty")))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case2"
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4)))))))))
###                 ("_case1"
###                   ("_applC" ("_position" Some)
###                     ("\<^const>Pure.dummy_pattern"))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pattern" ("_position" x) ("_position" y))
###                         ("_applC" ("_position" DList_Set.fold)
###                           ("_cargs"
###                             ("_lambda"
###                               ("_pttrns"
###                                 ("_pattern" ("_position" y')
###                                   ("_position" z))
###                                 ("_position" A))
###                               ("\<^const>HOL.If"
###                                 ("_applC" ("_position" eq)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs"
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" z)))
###                                     ("_position" A)))
###                                 ("_position" A)))
###                             ("_position" dxs4))))
###                       ("_cargs" ("_position" dxs3)
###                         ("\<^const>Set.empty")))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###               ("_case_syntax"
###                 ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq3 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))))
###             ("_case1"
###               ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###               ("_applC" ("_position" DList_Set.fold)
###                 ("_cargs"
###                   ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                     ("_applC" ("_position" DList_Set.fold)
###                       ("_cargs"
###                         ("_lambda"
###                           ("_pttrns"
###                             ("_pattern" ("_position" y') ("_position" z))
###                             ("_position" A))
###                           ("\<^const>HOL.If"
###                             ("_applC" ("_position" eq)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_applC" ("_position" insert)
###                               ("_cargs"
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg" ("_position" z)))
###                                 ("_position" A)))
###                             ("_position" A)))
###                         ("_position" dxs4))))
###                   ("_cargs" ("_position" dxs3)
###                     ("\<^const>Set.empty")))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Code.abort)
###                     ("_cargs"
###                       ("_Literal"
###                         ("_position"
###                           ''relcomp DList_set DList_set: ceq2 = None''))
###                       ("_lambda" ("_idtdummy")
###                         ("\<^const>Relation.relcomp"
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs3))
###                           ("_applC" ("_position" DList_set)
###                             ("_position" dxs4)))))))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                   ("_case_syntax"
###                     ("_applC" ("_position" ID)
###                       ("_CEQ" ("_position_sort" 'g)))
###                     ("_case1" ("_position" None)
###                       ("_applC" ("_position" Code.abort)
###                         ("_cargs"
###                           ("_Literal"
###                             ("_position"
###                               ''relcomp DList_set DList_set: ceq3 = None''))
###                           ("_lambda" ("_idtdummy")
###                             ("\<^const>Relation.relcomp"
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs3))
###                               ("_applC" ("_position" DList_set)
###                                 ("_position" dxs4))))))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1591 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" RBT_Set2.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" xs3))))
###                     ("_cargs" ("_position" rbt1)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" RBT_set) ("_position" rbt1))
###       ("_applC" ("_position" Set_Monad) ("_position" xs3)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp RBT_set Set_Monad: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs3)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp RBT_set Set_Monad: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" RBT_set) ("_position" rbt1))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs3)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" RBT_Set2.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" xs3))))
###                 ("_cargs" ("_position" rbt1) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1598 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'b)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" RBT_Set2.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("\<^const>HOL.not_equal"
###                                 ("_applC" ("_position" c_b)
###                                   ("_cargs" ("_position" y)
###                                     ("_position" y')))
###                                 ("_position" Eq))
###                               ("_position" A)
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))))
###                           ("_position" rbt5))))
###                     ("_cargs" ("_position" xs4)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs4))
###       ("_applC" ("_position" RBT_set) ("_position" rbt5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position"
###                   ''relcomp Set_Monad RBT_set: ccompare1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                   ("_applC" ("_position" RBT_set) ("_position" rbt5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'b)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad RBT_set: ccompare2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs4))
###                         ("_applC" ("_position" RBT_set)
###                           ("_position" rbt5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c_b))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" RBT_Set2.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("\<^const>HOL.not_equal"
###                             ("_applC" ("_position" c_b)
###                               ("_cargs" ("_position" y) ("_position" y')))
###                             ("_position" Eq))
###                           ("_position" A)
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))))
###                       ("_position" rbt5))))
###                 ("_cargs" ("_position" xs4) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1605 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###                 ("_applC" ("_position" DList_Set.fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" xs5))))
###                     ("_cargs" ("_position" dxs3)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" DList_set) ("_position" dxs3))
###       ("_applC" ("_position" Set_Monad) ("_position" xs5)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'e)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp DList_set Set_Monad: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" DList_set) ("_position" dxs3))
###                   ("_applC" ("_position" Set_Monad) ("_position" xs5)))))))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp DList_set Set_Monad: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs3))
###                         ("_applC" ("_position" Set_Monad)
###                           ("_position" xs5)))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_applC" ("_position" DList_Set.fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" xs5))))
###                 ("_cargs" ("_position" dxs3) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Cannot skip proof of schematic goal statement
### Ambiguous input (line 1612 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" fold)
###                   ("_cargs"
###                     ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                       ("_applC" ("_position" DList_Set.fold)
###                         ("_cargs"
###                           ("_lambda"
###                             ("_pttrns"
###                               ("_pattern" ("_position" y') ("_position" z))
###                               ("_position" A))
###                             ("\<^const>HOL.If"
###                               ("_applC" ("_position" eq)
###                                 ("_cargs" ("_position" y) ("_position" y')))
###                               ("_applC" ("_position" insert)
###                                 ("_cargs"
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" z)))
###                                   ("_position" A)))
###                               ("_position" A)))
###                           ("_position" dxs4))))
###                     ("_cargs" ("_position" xs6)
###                       ("\<^const>Set.empty"))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Relation.relcomp"
###       ("_applC" ("_position" Set_Monad) ("_position" xs6))
###       ("_applC" ("_position" DList_set) ("_position" dxs4)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'f)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''relcomp Set_Monad DList_set: ceq1 = None''))
###               ("_lambda" ("_idtdummy")
###                 ("\<^const>Relation.relcomp"
###                   ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                   ("_applC" ("_position" DList_set) ("_position" dxs4)))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'g)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''relcomp Set_Monad DList_set: ceq2 = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("\<^const>Relation.relcomp"
###                         ("_applC" ("_position" Set_Monad) ("_position" xs6))
###                         ("_applC" ("_position" DList_set)
###                           ("_position" dxs4)))))))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" fold)
###               ("_cargs"
###                 ("_lambda" ("_pattern" ("_position" x) ("_position" y))
###                   ("_applC" ("_position" DList_Set.fold)
###                     ("_cargs"
###                       ("_lambda"
###                         ("_pttrns"
###                           ("_pattern" ("_position" y') ("_position" z))
###                           ("_position" A))
###                         ("\<^const>HOL.If"
###                           ("_applC" ("_position" eq)
###                             ("_cargs" ("_position" y) ("_position" y')))
###                           ("_applC" ("_position" insert)
###                             ("_cargs"
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" z)))
###                               ("_position" A)))
###                           ("_position" A)))
###                       ("_position" dxs4))))
###                 ("_cargs" ("_position" xs6) ("\<^const>Set.empty"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  integer :: lsb
  lsb_integer == lsb :: integer => bool
instantiation
  integer :: msb
  msb_integer == msb :: integer => bool
instantiation
  integer :: set_bit
  set_bit_integer == set_bit_class.set_bit ::
    integer => nat => bool => integer
### Code generator: dropping subsumed code equation
### not ?k == - ?k - 1
locale od_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "od_powerprod (\<preceq>) (\<prec>)"
instantiation
  fun :: (type, add_linorder) lcs_powerprod
  lcs_fun == lcs :: ('a => 'b) => ('a => 'b) => 'a => 'b
### Code generator: dropping subsumed code equation
### and ?k ?l ==
### if ?k = 0 | ?l = 0 then 0
### else if ?k = - 1 then ?l
###      else if ?l = - 1 then ?k
###           else ?k mod 2 * (?l mod 2) + 2 * and (?k div 2) (?l div 2)
### Code generator: dropping subsumed code equation
### or ?k ?l ==
### if ?k = - 1 | ?l = - 1 then - 1
### else if ?k = 0 then ?l
###      else if ?l = 0 then ?k
###           else max (?k mod 2) (?l mod 2) + 2 * or (?k div 2) (?l div 2)
### Code generator: dropping subsumed code equation
### xor ?k ?l ==
### if ?k = - 1 then not ?l
### else if ?l = - 1 then not ?k
###      else if ?k = 0 then ?l
###           else if ?l = 0 then ?k
###                else \<bar>?k mod 2 - ?l mod 2\<bar> +
###                     2 * xor (?k div 2) (?l div 2)
### Cannot skip proof of schematic goal statement
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
### Ambiguous input (line 1629 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case1" ("_position" None)
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CCOMPARE" ("_position_sort" 'a)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))
###               ("_case1" ("_applC" ("_position" Some) ("_position" c))
###                 ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###                   ("_position" r)
###                   ("\<^const>HOL.not_equal"
###                     ("_applC" ("_position" c)
###                       ("_cargs" ("_position" x) ("_position" y)))
###                     ("_position" Eq)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff" ("_applC" ("_position" irrefl) ("_position" r))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###             ("_position" r)
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" eq)
###                 ("_cargs" ("_position" x) ("_position" y))))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax"
###               ("_applC" ("_position" ID)
###                 ("_CCOMPARE" ("_position_sort" 'a)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Code.abort)
###                   ("_cargs"
###                     ("_Literal"
###                       ("_position"
###                         ''irrefl: ceq = None & ccompare = None''))
###                     ("_lambda" ("_idtdummy")
###                       ("_applC" ("_position" irrefl) ("_position" r))))))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" c))
###             ("_Ball" ("_pattern" ("_position" x) ("_position" y))
###               ("_position" r)
###               ("\<^const>HOL.not_equal"
###                 ("_applC" ("_position" c)
###                   ("_cargs" ("_position" x) ("_position" y)))
###                 ("_position" Eq)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Ambiguous input (line 1722 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###           ("_case_syntax"
###             ("_applC" ("_position" filter)
###               ("_cargs" ("_position" P) ("_position" xs)))
###             ("_case2" ("_case1" ("_position" Nil) ("_position" False))
###               ("_case1"
###                 ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###                 ("_applC" ("_position" list_all)
###                   ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                     ("_position" xs)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" can_select)
###       ("_cargs" ("_position" P)
###         ("_applC" ("_position" Set_Monad) ("_position" xs))))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CEQ" ("_position_sort" 'a)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" Code.abort)
###             ("_cargs"
###               ("_Literal"
###                 ("_position" ''can_select Set_Monad: ceq = None''))
###               ("_lambda" ("_idtdummy")
###                 ("_applC" ("_position" can_select)
###                   ("_cargs" ("_position" P)
###                     ("_applC" ("_position" Set_Monad)
###                       ("_position" xs))))))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" eq))
###             ("_case_syntax"
###               ("_applC" ("_position" filter)
###                 ("_cargs" ("_position" P) ("_position" xs)))
###               ("_case1" ("_position" Nil) ("_position" False))))
###           ("_case1"
###             ("\<^const>List.list.Cons" ("_position" x) ("_position" xs))
###             ("_applC" ("_position" list_all)
###               ("_cargs" ("_applC" ("_position" eq) ("_position" x))
###                 ("_position" xs)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Cannot skip proof of schematic goal statement
### theory "Native_Word.Bits_Integer"
### 1.118s elapsed time, 4.294s cpu time, 0.539s GC time
(if ?x <= ?y then if ?x = ?y then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y = ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?y <= ?x then ?P else ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x <= ?y then if ?x < ?y then ?Q else ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x <= ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y < ?x then ?R else ?P) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?x = ?y then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x < ?y then ?Q else if ?y = ?x then ?P else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y < ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x < ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?y <= ?x then ?R else ?Q) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
(if ?x = ?y then ?P else if ?x <= ?y then ?Q else ?R) =
(case compare ?x ?y of Eq => ?P | Lt => ?Q | Gt => ?R)
MPoly (mapping_of ?x) = ?x
?y : UNIV ==> mapping_of (MPoly ?y) = ?y
(mapping_of ?x = mapping_of ?y) = (?x = ?y)
[| ?x : UNIV; ?y : UNIV |] ==> (MPoly ?x = MPoly ?y) = (?x = ?y)
[| ?y : UNIV; !!x. ?P (mapping_of x) |] ==> ?P ?y
(!!y. y : UNIV ==> ?P (MPoly y)) ==> ?P ?x
[| ?y : UNIV; !!x. ?y = mapping_of x ==> ?P |] ==> ?P
(!!y. [| ?x = MPoly y; y : UNIV |] ==> ?P) ==> ?P
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
### Cannot skip proof of schematic goal statement
"(Gcd (coeffs
        (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
          6 +
         M [(1::'b) + (1::'b), 0::'b,
            (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
          8)),
  sdiv
   (Gcd (coeffs
          (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
            6 +
           M [(1::'b) + (1::'b), 0::'b,
              (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
            8)))
   (M [1::'b, (1::'b) + (1::'b), (1::'b) + (1::'b) + (1::'b)] 4 +
    M [(1::'b) + (1::'b), 0::'b, (1::'b) + (1::'b) + ((1::'b) + (1::'b))]
     6 +
    M [(1::'b) + (1::'b), 0::'b,
       (1::'b) + (1::'b) + ((1::'b) + (1::'b)) + (1::'b)]
     8))"
  :: "'a * 'a mpoly"
carrier (| carrier = ?carrier, ... = ?more |) = ?carrier
partial_object.more (| carrier = ?carrier, ... = ?more |) = ?more
carrier_update ?carrier' (| carrier = ?carrier, ... = ?more |) =
(| carrier = ?carrier' ?carrier, ... = ?more |)
partial_object.more_update ?more' (| carrier = ?carrier, ... = ?more |) =
(| carrier = ?carrier, ... = ?more' ?more |)
(\<otimes>\<^bsub>(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |)\<^esub>) =
?mult
\<one>\<^bsub>(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |)\<^esub> =
?one
monoid.more
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
?more
mult_update ?mult'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult' ?mult, one = ?one, ... = ?more |)
one_update ?one'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult, one = ?one' ?one, ... = ?more |)
monoid.more_update ?more'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more' ?more |)
[| ?M <= carrier G; ?g : carrier G; ?h : carrier G |]
==> ?M #>\<^bsub>add_monoid G\<^esub> ?g #>\<^bsub>add_monoid G\<^esub> ?h =
    ?M #>\<^bsub>add_monoid G\<^esub> ?g \<oplus> ?h
[| abelian_group ?G; ?M <= carrier ?G; ?g : carrier ?G; ?h : carrier ?G |]
==> ?M +>\<^bsub>?G\<^esub> ?g +>\<^bsub>?G\<^esub> ?h =
    ?M +>\<^bsub>?G\<^esub> ?g \<oplus>\<^bsub>?G\<^esub> ?h
essentially_equal ?G ?fs1.0 ?fs2.0 =
(EX fs1'. mset ?fs1.0 = mset fs1' & fs1' [\<sim>]\<^bsub>?G\<^esub> ?fs2.0)
locale matrix_ring
  fixes n :: "nat"
    and field_type :: "'a itself"
### Ambiguous input (line 1833 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" DList_set)
###                   ("_position" DList_Set.empty))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_constrain" ("_position" set_empty_choose)
###       ("_tapp"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ceq) ("_class_name" ccompare))))
###         ("_type_name" set)))
###     ("_case_syntax" ("_CCOMPARE" ("_position_sort" 'a))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Set_Monad)
###                   ("\<^const>List.list.Nil")))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" DList_set)
###               ("_position" DList_Set.empty))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class set_impl = type +
  fixes set_impl :: "('a, set_impl) phantom"
signature SET_IMPL_GENERATOR =
  sig val derive_set_impl: string -> string -> theory -> theory end
structure Set_Impl_Generator: SET_IMPL_GENERATOR
use dlist as set_impl for type unit
registered unit in class set_impl
use dlist as set_impl for type bool
registered bool in class set_impl
use rbt as set_impl for type nat
registered nat in class set_impl
use set_RBT as set_impl for type int
registered int in class set_impl
use dlist as set_impl for type finite_1
registered finite_1 in class set_impl
use dlist as set_impl for type finite_2
registered finite_2 in class set_impl
use dlist as set_impl for type finite_3
registered finite_3 in class set_impl
use rbt as set_impl for type integer
registered integer in class set_impl
use rbt as set_impl for type natural
registered natural in class set_impl
use rbt as set_impl for type char
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
registered char in class set_impl
instantiation
  sum :: (set_impl, set_impl) set_impl
  set_impl_sum == set_impl :: ('a + 'b, set_impl) phantom
instantiation
  prod :: (set_impl, set_impl) set_impl
  set_impl_prod == set_impl :: ('a * 'b, set_impl) phantom
use choose as set_impl for type list
registered list in class set_impl
use rbt as set_impl for type literal
### Cannot skip proof of schematic goal statement
registered literal in class set_impl
instantiation
  option :: (set_impl) set_impl
  set_impl_option == set_impl :: ('a option, set_impl) phantom
use monad as set_impl for type fun
registered fun in class set_impl
use choose as set_impl for type set
registered set in class set_impl
instantiation
  phantom :: (type, set_impl) set_impl
  set_impl_phantom == set_impl :: (('a, 'b) phantom, set_impl) phantom
### Ambiguous input (line 1952 of "$AFP/Containers/Set_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case1" ("_position" None)
###           ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###             ("_case2" ("_case1" ("_position" None) ("_position" Set_Monad))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("\<^const>Pure.dummy_pattern"))
###                 ("_applC" ("_position" conv)
###                   ("_applC" ("_position" DList_set)
###                     ("_position" DList_Set.empty)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" set_aux) ("_position" set_Choose))
###     ("_case_syntax"
###       ("_CCOMPARE"
###         ("_ofsort" ("_position_sort" 'a)
###           ("_sort"
###             ("_classes" ("_class_name" ccompare) ("_class_name" ceq)))))
###       ("_case2"
###         ("_case1"
###           ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###           ("_applC" ("_position" conv)
###             ("_applC" ("_position" RBT_set) ("_position" RBT_Set2.empty))))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_case_syntax" ("_CEQ" ("_position_sort" 'a))
###               ("_case1" ("_position" None) ("_position" Set_Monad))))
###           ("_case1"
###             ("_applC" ("_position" Some) ("\<^const>Pure.dummy_pattern"))
###             ("_applC" ("_position" conv)
###               ("_applC" ("_position" DList_set)
###                 ("_position" DList_Set.empty)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Containers.Set_Impl"
### 19.584s elapsed time, 75.107s cpu time, 19.553s GC time
Loading theory "Algebraic_Numbers.Compare_Complex" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers")
instantiation
  poly_mapping :: (type, add_linorder) lcs_powerprod
  lcs_poly_mapping == lcs ::
    ('a \<Rightarrow>\<^sub>0 'b)
    => ('a \<Rightarrow>\<^sub>0 'b) => 'a \<Rightarrow>\<^sub>0 'b
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
locale matrix_vs
  fixes nr :: "nat"
    and nc :: "nat"
    and field_type :: "'a itself"
### Cannot skip proof of schematic goal statement
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Polynomials.Power_Products"
### 15.601s elapsed time, 59.601s cpu time, 17.814s GC time
Loading theory "Berlekamp_Zassenhaus.Degree_Bound" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Reconstruction")
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
instantiation
  complex :: finite_UNIV
  finite_UNIV_complex == finite_UNIV :: (complex, bool) phantom
instantiation
  complex :: compare
  compare_complex == compare :: complex => complex => order
deriving "ceq" instance for type "Complex.complex" via "="
derived is_ceq_complex-lemma
deriving "ceq" instance for type "Real.real" via "="
derived is_ceq_real-lemma
deriving "ccompare_order" instance for type "Complex.complex" via compare_order
derived is_ccompare_complex-lemma
deriving "ccompare_order" instance for type "Real.real" via compare_order
derived is_ccompare_real-lemma
use dlist as set_impl for type complex
registered complex in class set_impl
use dlist as set_impl for type real
registered real in class set_impl
### theory "Algebraic_Numbers.Compare_Complex"
### 1.067s elapsed time, 4.102s cpu time, 0.502s GC time
Loading theory "Jordan_Normal_Form.Matrix_IArray_Impl" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl")
### Cannot skip proof of schematic goal statement
### theory "Berlekamp_Zassenhaus.Degree_Bound"
### 1.012s elapsed time, 3.910s cpu time, 0.399s GC time
Loading theory "Polynomials.MPoly_Type_Class" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.Poly_Connection")
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
locale mat_space
  fixes f_ty :: "'a itself"
    and nc :: "nat"
    and nr :: "nat"
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
### Ambiguous input (line 1415 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monomial)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_position" a)))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monomial)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_position" a))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
instantiation
  vec :: (type) equal
  equal_vec == equal_class.equal :: 'a vec => 'a vec => bool
instantiation
  mat :: (type) equal
  equal_mat == equal_class.equal :: 'a mat => 'a mat => bool
### Ambiguous input (line 1454 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("\<^const>Series.suminf_binder" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_applC" ("_position" Sum_any) ("_position" f))
###         ("_cargs" ("_position" t) ("_position" p))))
###     ("_Sum_any" ("_position" c)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_applC" ("_position" f) ("_position" c))
###           ("_cargs" ("_position" t) ("_position" p)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1463 of "$AFP/Polynomials/MPoly_Type_Class.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("\<^const>Series.suminf_binder" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" monom_mult)
###       ("_cargs" ("_position" c)
###         ("_cargs" ("_position" t)
###           ("_applC" ("_position" Sum_any) ("_position" f)))))
###     ("_Sum_any" ("_position" p)
###       ("_applC" ("_position" monom_mult)
###         ("_cargs" ("_position" c)
###           ("_cargs" ("_position" t)
###             ("_applC" ("_position" f) ("_position" p))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
deriving "ceq" instance for type "Matrix.mat" via "="
derived is_ceq_mat-lemma
deriving "ceq" instance for type "Matrix.vec" via "="
derived is_ceq_vec-lemma
use None as trivial implementation of ccompare for type mat
registered mat in class ccompare
use None as trivial implementation of ccompare for type vec
registered vec in class ccompare
use dlist as set_impl for type mat
registered mat in class set_impl
use dlist as set_impl for type vec
registered vec in class set_impl
use None as trivial implementation of cenum for type mat
registered mat in class cenum
use None as trivial implementation of cenum for type vec
registered vec in class cenum
### theory "Jordan_Normal_Form.Matrix_IArray_Impl"
### 5.491s elapsed time, 20.939s cpu time, 12.674s GC time
Loading theory "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers")
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
locale term_powerprod
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
  assumes "term_powerprod pair_of_term term_of_pair"
"(215912063945802350977 / 152672884556058511392,
  1104427674243920646305299201 / 23309009678667569523128057147486993777664,
  True)"
  :: "rat * rat * bool"
(%n. mset (prime_factorization_nat n)) = prime_factorization
resultant = resultant_impl_basic
gcd = gcd_impl_Lazard
### theory "Polynomials.MPoly_Type_Class"
### 5.634s elapsed time, 21.519s cpu time, 12.766s GC time
Loading theory "Factor_Algebraic_Polynomial.MPoly_Container" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant")
Loading theory "Factor_Algebraic_Polynomial.Poly_Connection" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant")
locale idom_vec
  fixes n :: "nat"
    and f_ty :: "'a itself"
deriving "ceq" instance for type "Poly_Mapping.poly_mapping" via "="
derived is_ceq_poly_mapping-lemma
use dlist as set_impl for type poly_mapping
registered poly_mapping in class set_impl
use None as trivial implementation of ccompare for type poly_mapping
registered poly_mapping in class ccompare
### theory "Factor_Algebraic_Polynomial.MPoly_Container"
### 0.717s elapsed time, 3.093s cpu time, 0.317s GC time
Loading theory "Polynomials.MPoly_Type_Class_Ordered" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code" via "Polynomials.MPoly_Type_Class_FMap")
### theory "Jordan_Normal_Form.Gauss_Jordan_IArray_Impl"
### 1.686s elapsed time, 6.851s cpu time, 0.770s GC time
Loading theory "Berlekamp_Zassenhaus.Matrix_Record_Based" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based")
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
class the_min = linorder +
  fixes the_min :: "'a"
  assumes "the_min_min": "!!x. the_min <= x"
instantiation
  nat :: the_min
  the_min_nat == the_min :: nat
instantiation
  unit :: the_min
  the_min_unit == the_min :: unit
locale vec_module
  fixes f_ty :: "'a itself"
    and n :: "nat"
locale field_ops
  fixes ops :: "'i arith_ops_record"
    and R :: "'i => 'a => bool"
  assumes "field_ops ops R"
### Ambiguous input (line 246 of "$AFP/Factor_Algebraic_Polynomial/Poly_Connection.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" mpoly_to_mpoly_poly)
###       ("_cargs" ("_position" x) ("_position" p)))
###     ("\<^const>Series.suminf_binder" ("_position" m)
###       ("_applC" ("_position" Polynomial.monom)
###         ("_cargs"
###           ("_applC" ("_position" MPoly_Type.monom)
###             ("_cargs"
###               ("_applC" ("_position" remove_key)
###                 ("_cargs" ("_position" x) ("_position" m)))
###               ("_applC" ("_position" MPoly_Type.coeff)
###                 ("_cargs" ("_position" p) ("_position" m)))))
###           ("_applC" ("_position" lookup)
###             ("_cargs" ("_position" m) ("_position" x))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" mpoly_to_mpoly_poly)
###       ("_cargs" ("_position" x) ("_position" p)))
###     ("_Sum_any" ("_position" m)
###       ("_applC" ("_position" Polynomial.monom)
###         ("_cargs"
###           ("_applC" ("_position" MPoly_Type.monom)
###             ("_cargs"
###               ("_applC" ("_position" remove_key)
###                 ("_cargs" ("_position" x) ("_position" m)))
###               ("_applC" ("_position" MPoly_Type.coeff)
###                 ("_cargs" ("_position" p) ("_position" m)))))
###           ("_applC" ("_position" lookup)
###             ("_cargs" ("_position" m) ("_position" x))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale transfer_mpoly_to_mpoly_poly
  fixes x :: "nat"
### theory "Berlekamp_Zassenhaus.Matrix_Record_Based"
### 0.997s elapsed time, 3.871s cpu time, 0.429s GC time
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
### theory "Factor_Algebraic_Polynomial.Poly_Connection"
### 2.040s elapsed time, 8.237s cpu time, 0.877s GC time
Loading theory "Factor_Algebraic_Polynomial.MPoly_Divide" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Factor_Algebraic_Polynomial.Multivariate_Resultant" via "Factor_Algebraic_Polynomial.MPoly_Divide_Code")
instantiation
  mpoly :: (comm_semiring_1) divide
  divide_mpoly == divide :: 'a mpoly => 'a mpoly => 'a mpoly
instantiation
  mpoly :: ({idom,normalization_semidom}) normalization_semidom
  normalize_mpoly == normalize :: 'a mpoly => 'a mpoly
  unit_factor_mpoly == unit_factor :: 'a mpoly => 'a mpoly
### theory "Factor_Algebraic_Polynomial.MPoly_Divide"
### 0.387s elapsed time, 1.484s cpu time, 0.204s GC time
locale vec_space
  fixes f_ty :: "'a itself"
    and n :: "nat"
### theory "Jordan_Normal_Form.VS_Connect"
### 12.581s elapsed time, 48.617s cpu time, 15.850s GC time
Loading theory "Jordan_Normal_Form.Matrix_Kernel" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization" via "Berlekamp_Zassenhaus.Berlekamp_Type_Based")
locale ordered_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "ordered_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale kernel
  fixes nr :: "nat"
    and nc :: "nat"
    and A :: "'a mat"
  assumes "Matrix_Kernel.kernel nr nc A"
### Cannot skip proof of schematic goal statement
locale vardim
  fixes f_ty :: "'a itself"
### theory "Jordan_Normal_Form.Matrix_Kernel"
### 2.246s elapsed time, 6.499s cpu time, 0.867s GC time
Loading theory "Berlekamp_Zassenhaus.Berlekamp_Type_Based" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization")
locale ordered_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "ordered_powerprod (\<preceq>) (\<prec>)"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
consts
  berlekamp_factorization_main ::
    "nat
     => 'a mod_ring poly list
        => 'a mod_ring poly list => nat => 'a mod_ring poly list"
### Cannot skip proof of schematic goal statement
locale gd_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "gd_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
locale gd_powerprod
  fixes ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
  assumes "gd_powerprod (\<preceq>) (\<prec>)"
locale od_term
  fixes pair_of_term :: "'t => 'a * 'k"
    and term_of_pair :: "'a * 'k => 't"
    and ord :: "'a => 'a => bool"  (infixl \<open>\<preceq>\<close> 50)
    and ord_strict :: "'a => 'a => bool"  (infixl \<open>\<prec>\<close> 50)
    and
    ord_term :: "'t => 't => bool"
      (infixl \<open>\<preceq>\<^sub>t\<close> 50)
    and
    ord_term_strict :: "'t => 't => bool"
      (infixl \<open>\<prec>\<^sub>t\<close> 50)
  assumes
    "od_term pair_of_term term_of_pair (\<preceq>) (\<prec>)
      (\<preceq>\<^sub>t) (\<prec>\<^sub>t)"
### theory "Polynomials.MPoly_Type_Class_Ordered"
### 7.637s elapsed time, 20.994s cpu time, 2.860s GC time
### theory "Berlekamp_Zassenhaus.Berlekamp_Type_Based"
### 4.356s elapsed time, 8.501s cpu time, 1.330s GC time
Loading theory "Berlekamp_Zassenhaus.Distinct_Degree_Factorization" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" via "Berlekamp_Zassenhaus.Finite_Field_Factorization")
locale poly_mod_type_irr
  fixes m :: "int"
    and f :: "'a mod_ring poly"
  assumes "poly_mod_type_irr m f"
### theory "Berlekamp_Zassenhaus.Distinct_Degree_Factorization"
### 0.941s elapsed time, 1.051s cpu time, 0.159s GC time
Loading theory "Berlekamp_Zassenhaus.Finite_Field_Factorization" (required by "Draft.Linear_Recurrences_SolverTemplates" via "Draft.Linear_Recurrences_Solver" via "Factor_Algebraic_Polynomial.Factor_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" via "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" via "Algebraic_Numbers.Complex_Algebraic_Numbers" via "Algebraic_Numbers.Real_Roots" via "Algebraic_Numbers.Real_Algebraic_Numbers" via "Algebraic_Numbers.Factors_of_Int_Poly" via "Berlekamp_Zassenhaus.Factorize_Int_Poly" via "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" via "Berlekamp_Zassenhaus.Berlekamp_Hensel" via "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based")
overloading
  use_distinct_degree_factorization \<equiv>
    use_distinct_degree_factorization :: bool
### theory "Berlekamp_Zassenhaus.Finite_Field_Factorization"
### 0.078s elapsed time, 0.078s cpu time, 0.000s GC time
*** Failed to load theory "Polynomials.Poly_Mapping_Finite_Map" (unresolved "HOL-Library.Finite_Map")
*** Failed to load theory "Native_Word.Code_Target_Bits_Int" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Native_Word.Code_Target_Word_Base" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Native_Word.Word_Type_Copies" (unresolved "Native_Word.Code_Target_Word_Base")
*** Failed to load theory "Native_Word.Uint32" (unresolved "Native_Word.Code_Target_Word_Base", "Native_Word.Word_Type_Copies")
*** Failed to load theory "Native_Word.Uint64" (unresolved "Native_Word.Code_Target_Word_Base", "Native_Word.Word_Type_Copies")
*** Failed to load theory "Berlekamp_Zassenhaus.Finite_Field_Record_Based" (unresolved "Native_Word.Code_Target_Bits_Int", "Native_Word.Uint32", "Native_Word.Uint64")
*** Failed to load theory "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based" (unresolved "Berlekamp_Zassenhaus.Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Hensel_Lifting" (unresolved "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Mahler_Measure" (unresolved "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Factor_Bound" (unresolved "Berlekamp_Zassenhaus.Mahler_Measure")
*** Failed to load theory "Berlekamp_Zassenhaus.Suitable_Prime" (unresolved "Berlekamp_Zassenhaus.Finite_Field_Record_Based", "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Gcd_Finite_Field_Impl" (unresolved "Berlekamp_Zassenhaus.Suitable_Prime")
*** Failed to load theory "Berlekamp_Zassenhaus.Square_Free_Factorization_Int" (unresolved "Berlekamp_Zassenhaus.Gcd_Finite_Field_Impl", "Berlekamp_Zassenhaus.Suitable_Prime")
*** Failed to load theory "Polynomials.MPoly_Type_Class_FMap" (unresolved "Polynomials.Poly_Mapping_Finite_Map")
*** Failed to load theory "Factor_Algebraic_Polynomial.MPoly_Divide_Code" (unresolved "Polynomials.MPoly_Type_Class_FMap")
*** Failed to load theory "Factor_Algebraic_Polynomial.Multivariate_Resultant" (unresolved "Factor_Algebraic_Polynomial.MPoly_Divide_Code")
*** Failed to load theory "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based" (unresolved "Berlekamp_Zassenhaus.Poly_Mod_Finite_Field_Record_Based")
*** Failed to load theory "Berlekamp_Zassenhaus.Berlekamp_Hensel" (unresolved "Berlekamp_Zassenhaus.Finite_Field_Factorization_Record_Based", "Berlekamp_Zassenhaus.Hensel_Lifting")
*** Failed to load theory "Berlekamp_Zassenhaus.Reconstruction" (unresolved "Berlekamp_Zassenhaus.Berlekamp_Hensel", "Berlekamp_Zassenhaus.Factor_Bound")
*** Failed to load theory "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus" (unresolved "Berlekamp_Zassenhaus.Berlekamp_Hensel", "Berlekamp_Zassenhaus.Reconstruction", "Berlekamp_Zassenhaus.Suitable_Prime")
*** Failed to load theory "Berlekamp_Zassenhaus.Factorize_Int_Poly" (unresolved "Berlekamp_Zassenhaus.Berlekamp_Zassenhaus", "Berlekamp_Zassenhaus.Square_Free_Factorization_Int")
*** Failed to load theory "Algebraic_Numbers.Factors_of_Int_Poly" (unresolved "Berlekamp_Zassenhaus.Factorize_Int_Poly")
*** Failed to load theory "Algebraic_Numbers.Real_Algebraic_Numbers" (unresolved "Algebraic_Numbers.Factors_of_Int_Poly")
*** Failed to load theory "Algebraic_Numbers.Real_Roots" (unresolved "Algebraic_Numbers.Real_Algebraic_Numbers")
*** Failed to load theory "Algebraic_Numbers.Complex_Algebraic_Numbers" (unresolved "Algebraic_Numbers.Real_Roots")
*** Failed to load theory "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly" (unresolved "Algebraic_Numbers.Complex_Algebraic_Numbers", "Factor_Algebraic_Polynomial.Multivariate_Resultant")
*** Failed to load theory "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl" (unresolved "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly", "Polynomials.MPoly_Type_Class_FMap")
*** Failed to load theory "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly" (unresolved "Factor_Algebraic_Polynomial.Roots_of_Algebraic_Poly_Impl")
*** Failed to load theory "Factor_Algebraic_Polynomial.Factor_Complex_Poly" (unresolved "Factor_Algebraic_Polynomial.Roots_of_Real_Complex_Poly")
*** Failed to load theory "Draft.Linear_Recurrences_Solver" (unresolved "Factor_Algebraic_Polynomial.Factor_Complex_Poly")
*** Failed to load theory "Draft.Linear_Recurrences_SolverTemplates" (unresolved "Draft.Linear_Recurrences_Solver")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "4")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 653 of "$AFP/Native_Word/Bits_Integer.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "2")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 1440 of "~~/src/HOL/Library/Finite_Map.thy")
Exception- TOPLEVEL_ERROR raised
