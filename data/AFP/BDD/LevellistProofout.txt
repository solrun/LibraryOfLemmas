Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.LevellistProofMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Loading theory "HOL-Library.Old_Recdef" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoarePartial" via "Simpl.HoarePartialProps" via "Simpl.HoarePartialDef" via "Simpl.Semantic" via "Simpl.Language")
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.LevellistProofMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.LevellistProofMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.116s elapsed time, 0.489s cpu time, 0.000s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.LevellistProofMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.210s elapsed time, 0.853s cpu time, 0.085s GC time
Loading theory "HOL-Statespace.DistinctTreeProver" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "HOL-Statespace.StateSpaceLocale" via "HOL-Statespace.StateFun")
### theory "HOL-Library.Nat_Bijection"
### 0.271s elapsed time, 1.095s cpu time, 0.085s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.LevellistProofMoreTemplates" via "Draft.ExtrEqs")
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
### ML warning (line 435 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 523 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (Body) has not been referenced.
### ML warning (line 529 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (Body) has not been referenced.
### ML warning (line 535 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (Body) has not been referenced.
### ML warning (line 732 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 753 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 795 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (Body) has not been referenced.
### ML warning (line 1045 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (ldisjs) has not been referenced.
### ML warning (line 1152 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 1157 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 1196 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 1391 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 1391 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (sty) has not been referenced.
### ML warning (line 1394 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 1394 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (fty) has not been referenced.
### ML warning (line 1547 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 1725 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (A) has not been referenced.
### ML warning (line 1724 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (A) has not been referenced.
### ML warning (line 1730 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 1786 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 1801 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (rows) has not been referenced.
### ML warning (line 1850 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 1864 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (rows) has not been referenced.
### ML warning (line 1864 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (rstp) has not been referenced.
### ML warning (line 1881 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 1953 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 1968 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 2009 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 2014 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 2009 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 2120 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (ex) has not been referenced.
### ML warning (line 2120 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 2125 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 2159 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 2145 of "~~/src/HOL/Library/old_recdef.ML"):
### Matches are not exhaustive.
### ML warning (line 2234 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (R) has not been referenced.
### ML warning (line 2301 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 2302 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (lhs) has not been referenced.
### ML warning (line 2571 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (L) has not been referenced.
### ML warning (line 2578 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (dummy) has not been referenced.
### ML warning (line 2582 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (dummy) has not been referenced.
### ML warning (line 2584 of "~~/src/HOL/Library/old_recdef.ML"):
### Value identifier (dummy) has not been referenced.
### ML warning (line 2619 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
### ML warning (line 2838 of "~~/src/HOL/Library/old_recdef.ML"):
### Pattern is not exhaustive.
signature CASE_SPLIT =
  sig val splitto: Proof.context -> thm list -> thm -> thm end
signature UTILS =
  sig
    exception ERR of {func: string, mesg: string, module: string}
    val end_itlist: ('a -> 'a -> 'a) -> 'a list -> 'a
    val itlist2: ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val pluck: ('a -> bool) -> 'a list -> 'a * 'a list
    val take: ('a -> 'b) -> int * 'a list -> 'b list
    val zip3: 'a list -> 'b list -> 'c list -> ('a * 'b * 'c) list
  end
signature USYNTAX =
  sig
    val ARB: typ -> term
    val alpha: typ
    val dest_abs:
       string list -> term -> {Body: term, Bvar: term} * string list
    val dest_comb: term -> {Rand: term, Rator: term}
    val dest_conj: term -> {conj1: term, conj2: term}
    val dest_const: term -> {Name: string, Ty: typ}
    val dest_disj: term -> {disj1: term, disj2: term}
    val dest_eq: term -> {lhs: term, rhs: term}
    val dest_exists: term -> {Body: term, Bvar: term}
    val dest_forall: term -> {Body: term, Bvar: term}
    val dest_imp: term -> {ant: term, conseq: term}
    val dest_neg: term -> term
    val dest_pabs:
       string list ->
         term -> {body: term, used: string list, varstruct: term}
    val dest_pair: term -> {fst: term, snd: term}
    val dest_relation: term -> term * term * term
    val dest_term: term -> lambda
    val find_term: (term -> bool) -> term -> term option
    val free_vars_lr: term -> term list
    val gen_all: term -> term
    val inst: (typ * typ) list -> term -> term
    val is_WFR: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_exists: term -> bool
    val is_forall: term -> bool
    val is_imp: term -> bool
    val is_neg: term -> bool
    val is_pabs: term -> bool
    val is_pair: term -> bool
    val is_vartype: typ -> bool
    datatype lambda
    =
         COMB of {Rand: term, Rator: term}
       | CONST of {Name: string, Ty: typ}
       | LAMB of {Body: term, Bvar: term}
       | VAR of {Name: string, Ty: typ}
    val lhs: term -> term
    val list_mk_abs: term list * term -> term
    val list_mk_conj: term list -> term
    val list_mk_forall: term list * term -> term
    val list_mk_imp: term list * term -> term
    val mk_abs: {Body: term, Bvar: term} -> term
    val mk_conj: {conj1: term, conj2: term} -> term
    val mk_disj: {disj1: term, disj2: term} -> term
    val mk_exists: {Body: term, Bvar: term} -> term
    val mk_forall: {Body: term, Bvar: term} -> term
    val mk_imp: {ant: term, conseq: term} -> term
    val mk_pabs: {body: term, varstruct: term} -> term
    val mk_select: {Body: term, Bvar: term} -> term
    val mk_vartype: string -> typ
    val mk_vstruct: typ -> term list -> term
    val rand: term -> term
    val rhs: term -> term
    val strip_abs: term -> term list * term
    val strip_comb: term -> term * term list
    val strip_disj: term -> term list
    val strip_exists: term -> term list * term
    val strip_forall: term -> term list * term
    val strip_imp: term -> term list * term
    val strip_prod_type: typ -> typ list
    val type_vars: typ -> typ list
    val type_vars_in_term: term -> typ list
    val type_varsl: typ list -> typ list
  end
signature DCTERM =
  sig
    val cabs: cterm -> cterm -> cterm
    val capply: cterm -> cterm -> cterm
    val dest_abs: cterm -> cterm * cterm
    val dest_comb: cterm -> cterm * cterm
    val dest_conj: cterm -> cterm * cterm
    val dest_const: cterm -> {Name: string, Ty: typ}
    val dest_disj: cterm -> cterm * cterm
    val dest_eq: cterm -> cterm * cterm
    val dest_exists: cterm -> cterm * cterm
    val dest_forall: cterm -> cterm * cterm
    val dest_imp: cterm -> cterm * cterm
    val dest_neg: cterm -> cterm
    val dest_pair: cterm -> cterm * cterm
    val dest_var: cterm -> {Name: string, Ty: typ}
    val drop_prop: cterm -> cterm
    val is_conj: cterm -> bool
    val is_disj: cterm -> bool
    val is_eq: cterm -> bool
    val is_exists: cterm -> bool
    val is_forall: cterm -> bool
    val is_imp: cterm -> bool
    val is_neg: cterm -> bool
    val is_pair: cterm -> bool
    val list_mk_disj: cterm list -> cterm
    val mk_conj: cterm * cterm -> cterm
    val mk_disj: cterm * cterm -> cterm
    val mk_exists: cterm * cterm -> cterm
    val mk_prop: cterm -> cterm
    val strip_abs: cterm -> cterm list * cterm
    val strip_comb: cterm -> cterm * cterm list
    val strip_disj: cterm -> cterm list
    val strip_exists: cterm -> cterm list * cterm
    val strip_forall: cterm -> cterm list * cterm
    val strip_imp: cterm -> cterm list * cterm
  end
signature RULES =
  sig
    val ASSUME: cterm -> thm
    val CHOOSE: Proof.context -> cterm * thm -> thm -> thm
    val CONJUNCT1: thm -> thm
    val CONJUNCT2: thm -> thm
    val CONJUNCTS: thm -> thm list
    val CONTEXT_REWRITE_RULE:
       Proof.context ->
         term * term list * thm * thm list -> thm -> thm * term list
    val DISCH: cterm -> thm -> thm
    val DISCH_ALL: thm -> thm
    val DISJ_CASESL: thm -> thm list -> thm
    val EVEN_ORS: thm list -> thm list
    val EXISTS: Proof.context -> cterm * cterm -> thm -> thm
    val FILTER_DISCH_ALL: (term -> bool) -> thm -> thm
    val GEN: Proof.context -> cterm -> thm -> thm
    val GENL: Proof.context -> cterm list -> thm -> thm
    val GEN_ALL: Proof.context -> thm -> thm
    val IMP_TRANS: thm -> thm -> thm
    val ISPEC: cterm -> thm -> thm
    val ISPECL: cterm list -> thm -> thm
    val IT_EXISTS: Proof.context -> (cterm * cterm) list -> thm -> thm
    val LIST_CONJ: thm list -> thm
    val MATCH_MP: thm -> thm -> thm
    val MP: thm -> thm -> thm
    val PROVE_HYP: thm -> thm -> thm
    val REFL: cterm -> thm
    val RIGHT_ASSOC: Proof.context -> thm -> thm
    val SPEC: cterm -> thm -> thm
    val SPEC_ALL: thm -> thm
    val SUBS: Proof.context -> thm list -> thm -> thm
    val SYM: thm -> thm
    val UNDISCH: thm -> thm
    val dest_thm: thm -> term list * term
    val list_beta_conv: cterm -> cterm list -> thm
    val prove:
       Proof.context -> bool -> term -> (Proof.context -> tactic) -> thm
    val rbeta: thm -> thm
    val simpl_conv: Proof.context -> thm list -> cterm -> thm
    val tracing: bool ref
  end
signature THRY =
  sig
    val extract_info:
       theory -> {case_congs: thm list, case_rewrites: thm list}
    val induct_info:
       theory -> string -> {constructors: term list, nchotomy: thm} option
    val match_info:
       theory ->
         string -> {case_const: term, constructors: term list} option
    val match_term:
       theory -> term -> term -> (term * term) list * (typ * typ) list
    val match_type: theory -> typ -> typ -> (typ * typ) list
    val typecheck: theory -> term -> cterm
  end
signature PRIM =
  sig
    val mk_functional:
       theory -> term list -> {functional: term, pats: pattern list}
    val mk_induction:
       Proof.context ->
         {R: term,
          SV: term list,
          fconst: term, pat_TCs_list: (term * term list) list}
           -> thm
    type pattern
    val post_definition:
       Proof.context ->
         thm list ->
           thm * pattern list ->
             {TCs: term list list,
              full_pats_TCs: (term * term list) list,
              rows: int list, rules: thm}
    val postprocess:
       Proof.context ->
         bool ->
           {simplifier: Proof.context -> cterm -> thm,
            terminator: Proof.context -> tactic,
            wf_tac: Proof.context -> tactic}
             ->
             {TCs: term list list, induction: thm, rules: thm} ->
               {induction: thm, nested_tcs: thm list, rules: thm}
    val trace: bool ref
    val trace_cterm: Proof.context -> string -> cterm -> unit
    val trace_thms: Proof.context -> string -> thm list -> unit
    val wfrec_definition0: string -> term -> term -> theory -> thm * theory
  end
signature TFL =
  sig
    val define:
       bool ->
         thm list ->
           thm list ->
             xstring ->
               string ->
                 string list ->
                   Proof.context ->
                     {induct: thm,
                      lhs: term, rules: (thm * int) list, tcs: term list}
                     *
                     Proof.context
    val define_i:
       bool ->
         thm list ->
           thm list ->
             xstring ->
               term ->
                 term list ->
                   Proof.context ->
                     {induct: thm,
                      lhs: term, rules: (thm * int) list, tcs: term list}
                     *
                     Proof.context
  end
signature OLD_RECDEF =
  sig
    val add_recdef:
       bool ->
         xstring ->
           string ->
             ((binding * string) * Token.src list) list ->
               Token.src option ->
                 theory ->
                   theory *
                   {induct: thm,
                    lhs: term,
                    rules: thm list list, simps: thm list, tcs: term list}
    val add_recdef_i:
       bool ->
         xstring ->
           term ->
             ((binding * term) * attribute list) list ->
               theory ->
                 theory *
                 {induct: thm,
                  lhs: term,
                  rules: thm list list, simps: thm list, tcs: term list}
    val cong_add: attribute
    val cong_del: attribute
    val get_hints:
       Proof.context ->
         {congs: (string * thm) list, simps: thm list, wfs: thm list}
    val get_recdef:
       theory ->
         string ->
           {induct: thm,
            lhs: term,
            rules: thm list list, simps: thm list, tcs: term list}
           option
    val simp_add: attribute
    val simp_del: attribute
    val wf_add: attribute
    val wf_del: attribute
  end
structure Old_Recdef: OLD_RECDEF
### theory "HOL-Library.Old_Recdef"
### 0.876s elapsed time, 3.242s cpu time, 0.773s GC time
Loading theory "Simpl.Language" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoarePartial" via "Simpl.HoarePartialProps" via "Simpl.HoarePartialDef" via "Simpl.Semantic")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
consts
  snth :: "'a stream => nat => 'a"
Found termination order: "size <*mlex*> {}"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  set_of :: "'a tree => 'a set"
Found termination order: "size <*mlex*> {}"
consts
  all_distinct :: "'a tree => bool"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  delete :: "'a => 'a tree => 'a tree option"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  cycle :: "'a list => 'a stream"
consts
  subtract :: "'a tree => 'a tree => 'a tree option"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
### ML warning (line 36 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 36 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 40 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Pattern is not exhaustive.
### ML warning (line 67 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 56 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 75 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 75 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (order) has not been referenced.
### ML warning (line 69 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 69 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (order) has not been referenced.
### ML warning (line 198 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Pattern is not exhaustive.
### ML warning (line 249 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Pattern is not exhaustive.
### ML warning (line 266 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (xrs) has not been referenced.
### ML warning (line 271 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (yrs) has not been referenced.
### ML warning (line 271 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (yr) has not been referenced.
### ML warning (line 316 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (r) has not been referenced.
### ML warning (line 316 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 316 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 316 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (nT) has not been referenced.
### ML warning (line 307 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (ct) has not been referenced.
### ML warning (line 310 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Pattern is not exhaustive.
### ML warning (line 319 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Pattern is not exhaustive.
### ML warning (line 307 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Matches are not exhaustive.
### ML warning (line 337 of "~~/src/HOL/Statespace/distinct_tree_prover.ML"):
### Value identifier (f) has not been referenced.
signature DISTINCT_TREE_PROVER =
  sig
    val dest_tree: term -> term list
    datatype direction = Left | Right
    val discharge: Proof.context -> thm list -> thm -> thm
    val distinctFieldSolver: string list -> solver
    val distinctTreeProver:
       Proof.context -> thm -> direction list -> direction list -> thm
    val distinctTree_tac: string list -> Proof.context -> int -> tactic
    val distinct_implProver: Proof.context -> thm -> cterm -> thm
    val distinct_simproc: string list -> simproc
    val find_in_set: Proof.context -> term -> cterm -> thm
    val find_tree: term -> term -> direction list option
    val in_set: Proof.context -> direction list -> cterm -> thm
    val mk_tree: ('a -> term) -> typ -> 'a list -> term
    val neq_to_eq_False: thm
    val neq_x_y: Proof.context -> term -> term -> string -> thm option
    val subtractProver: Proof.context -> term -> cterm -> thm -> thm
  end
structure DistinctTreeProver: DISTINCT_TREE_PROVER
### theory "HOL-Statespace.DistinctTreeProver"
### 1.036s elapsed time, 3.849s cpu time, 0.934s GC time
Loading theory "HOL-Statespace.StateFun" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "HOL-Statespace.StateSpaceLocale")
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.035s elapsed time, 3.847s cpu time, 0.934s GC time
Loading theory "Simpl.Generalise" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg")
### theory "HOL-Statespace.StateFun"
### 0.067s elapsed time, 0.268s cpu time, 0.000s GC time
Loading theory "HOL-Statespace.StateSpaceLocale" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg")
Found termination order: "size <*mlex*> {}"
### ML warning (line 109 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 98 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 223 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 212 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 201 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 186 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 227 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 228 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 230 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 233 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 242 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 190 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 191 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 194 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 198 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 168 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 169 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 171 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 174 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 183 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 214 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 215 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 203 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 204 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 163 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
signature SPLIT_STATE =
  sig
    val abs_state: term -> term option
    val abs_var: Proof.context -> term -> string * typ
    val ex_tac: Proof.context -> term list -> tactic
    val isState: term -> bool
    val split_state:
       Proof.context -> string -> typ -> term -> term * term list
  end
functor GeneraliseFun (sig structure SplitState: SPLIT_STATE end): 
  sig
    val GENERALISE: Proof.context -> int -> tactic
    val OF_RAW: thm * thm -> thm
    val SIMPLE_OF: Proof.context -> thm -> thm list -> thm
    val SIMPLE_OF_RAW: Proof.context -> thm -> thm -> thm
    val conc_of: thm -> term
    val decomp:
       Proof.context ->
         term * cterm -> term list * cterm list * (thm list -> thm)
    val dest_All: term -> term
    val dest_prop: term -> term
    val eta_expand: Proof.context -> cterm -> cterm
    val genAll: thm
    val genAllShift: thm
    val genConj: thm
    val genEx: thm
    val genImp: thm
    val genImpl: thm
    val genRefl: thm
    val genRefl': thm
    val genTrans: thm
    val gen_all: thm
    val gen_allShift: thm
    val gen_thm:
       ('a * 'b -> 'a list * 'b list * ('c list -> 'c)) -> 'a * 'b -> 'c
    val generalise: Proof.context -> cterm -> thm
    val generalise_over_all_states_tac: Proof.context -> int -> tactic
    val generalise_over_tac:
       Proof.context -> (term -> term option) -> int -> thm -> thm Seq.seq
    val generalise_tac: Proof.context -> int -> thm -> thm Seq.seq
    val init: cterm -> thm
    val list_exists: (string * typ) list * term -> term
    val meta_spec: thm
    val prem_of: thm -> term
    val protectImp: thm
    val protectRefl: thm
    datatype qantifier = Hol_all | Hol_ex | Meta_all
    val spec': cterm -> thm -> thm
    val split_abs:
       Proof.context -> cterm -> (string * typ * term) * (cterm * cterm)
    val split_thm:
       qantifier -> Proof.context -> string -> typ -> term -> thm
  end
### theory "Simpl.Generalise"
### 0.078s elapsed time, 0.317s cpu time, 0.000s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.LevellistProofMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### ML warning (line 91 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 95 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 95 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 95 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 94 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (ys) has not been referenced.
### ML warning (line 94 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 94 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (sorted_subset) has not been referenced.
### ML warning (line 100 of "~~/src/HOL/Statespace/state_space.ML"):
### Matches are not exhaustive.
### ML warning (line 126 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (name) has not been referenced.
### ML warning (line 354 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (phi) has not been referenced.
### ML warning (line 412 of "~~/src/HOL/Statespace/state_space.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 410 of "~~/src/HOL/Statespace/state_space.ML"):
### Matches are not exhaustive.
### ML warning (line 665 of "~~/src/HOL/Statespace/state_space.ML"):
### Matches are not exhaustive.
### ML warning (line 670 of "~~/src/HOL/Statespace/state_space.ML"):
### Matches are not exhaustive.
### ML warning (line 702 of "~~/src/HOL/Statespace/state_space.ML"):
### Matches are not exhaustive.
signature STATE_SPACE =
  sig
    val define_statespace:
       string list ->
         string ->
           ((string * bool) *
            (string list * bstring * (string * string) list)
           )
           list
             -> (string * string) list -> theory -> theory
    val define_statespace_i:
       string option ->
         string list ->
           string ->
             ((string * bool) *
              (typ list * bstring * (string * string) list)
             )
             list
               -> (string * typ) list -> theory -> theory
    val distinctNameSolver: solver
    val distinctTree_tac: Proof.context -> int -> tactic
    val distinct_compsN: string
    val distinct_simproc: simproc
    val gen'_update_tr:
       bool -> bool -> Proof.context -> string -> term -> term -> term
    val gen_lookup_tr: Proof.context -> term -> string -> term
    val gen_update_tr:
       bool -> Proof.context -> string -> term -> term -> term
    val getN: string
    val get_comp: Context.generic -> string -> (typ * string) option
    val get_comp': Context.generic -> string -> (typ * string list) option
    val get_comps: Context.generic -> (typ * string list) Termtab.table
    val get_silent: Context.generic -> bool
    val injectN: string
    val is_statespace: Context.generic -> xstring -> bool
    val lookup_swap_tr: Proof.context -> term list -> term
    val lookup_tr: Proof.context -> term list -> term
    val lookup_tr': Proof.context -> term list -> term
    val namespaceN: string
    val namespace_definition:
       bstring ->
         typ ->
           (xstring, string) Expression.expr *
           (binding * string option * mixfix) list
             -> string list -> string list -> theory -> theory
    val neq_x_y: Proof.context -> term -> term -> thm option
    val projectN: string
    val putN: string
    val set_silent: bool -> Context.generic -> Context.generic
    val statespace_decl:
       ((string list * bstring) *
        (((string * bool) *
          (string list * xstring * (bstring * bstring) list)
         )
         list
         *
         (bstring * string) list)
       )
       parser
    val trace_name_space_data: Context.generic -> unit
    val trace_state_space_data: Context.generic -> unit
    val update_tr: Proof.context -> term list -> term
    val update_tr': Proof.context -> term list -> term
    val valuetypesN: string
  end
structure StateSpace: STATE_SPACE
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### ML warning (line 131 of "~~/src/HOL/Statespace/state_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 155 of "~~/src/HOL/Statespace/state_fun.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 135 of "~~/src/HOL/Statespace/state_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 191 of "~~/src/HOL/Statespace/state_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 193 of "~~/src/HOL/Statespace/state_fun.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 223 of "~~/src/HOL/Statespace/state_fun.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 226 of "~~/src/HOL/Statespace/state_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 303 of "~~/src/HOL/Statespace/state_fun.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 305 of "~~/src/HOL/Statespace/state_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 383 of "~~/src/HOL/Statespace/state_fun.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 361 of "~~/src/HOL/Statespace/state_fun.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 361 of "~~/src/HOL/Statespace/state_fun.ML"):
### Value identifier (comp) has not been referenced.
signature STATE_FUN =
  sig
    val ex_lookup_eq_simproc: simproc
    val ex_lookup_ss: simpset
    val lazy_conj_simproc: simproc
    val lookupN: string
    val lookup_simproc: simproc
    val mk_constr: theory -> typ -> term
    val mk_destr: theory -> typ -> term
    val string_eq_simp_tac: Proof.context -> int -> tactic
    val trace_data: Context.generic -> unit
    val updateN: string
    val update_simproc: simproc
  end
structure StateFun: STATE_FUN
locale project_inject
  fixes project :: "'value => 'a"
    and inject :: "'a => 'value"
  assumes "project_inject project inject"
### theory "HOL-Statespace.StateSpaceLocale"
### 0.382s elapsed time, 1.515s cpu time, 0.217s GC time
Loading theory "Simpl.Simpl_Heap" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Draft.General" via "Draft.BinDag")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Simpl.Simpl_Heap"
### 0.072s elapsed time, 0.288s cpu time, 0.000s GC time
Loading theory "Draft.BinDag" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Draft.General")
Found termination order: "size <*mlex*> {}"
consts
  set_of :: "dag => ref set"
consts
  DAG :: "dag => bool"
consts
  subdag :: "dag => dag => bool"
instantiation
  dag :: order
  less_eq_dag == less_eq :: dag => dag => bool
  less_dag == less :: dag => dag => bool
consts
  Dag :: "ref => (ref => ref) => (ref => ref) => dag => bool"
### theory "HOL-Library.Tree"
### 2.008s elapsed time, 7.699s cpu time, 1.417s GC time
Loading theory "Draft.Templates" (required by "Draft.LevellistProofMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.BigO"
### 0.736s elapsed time, 2.918s cpu time, 0.358s GC time
Loading theory "Simpl.HeapList" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof")
consts
  Path :: "ref => (ref => ref) => ref => ref list => bool"
### theory "Draft.BinDag"
### 0.432s elapsed time, 1.711s cpu time, 0.267s GC time
Loading theory "Draft.General" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.063s elapsed time, 0.252s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.LevellistProofMoreTemplates")
consts
  root :: "dag => ref"
### Missing patterns in function definition:
### !!vc vd ve va v vf vg.
###    isLeaf (Node (Node vc vd ve) va (Node v vf vg)) = undefined
### !!vb vf vg va vc vd ve.
###    isLeaf (Node (Node vb vf vg) va (Node vc vd ve)) = undefined
### theory "Simpl.HeapList"
### 0.147s elapsed time, 0.589s cpu time, 0.000s GC time
Found termination order: "{}"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.997s elapsed time, 3.170s cpu time, 1.221s GC time
Found termination order: "size <*mlex*> {}"
consts
  eval :: "bdt => bool list => bool"
Found termination order: "size <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### ordered_bdt (Bdt_Node Zero ?v1 Zero) == True
### Ignoring duplicate rewrite rule:
### ordered_bdt (Bdt_Node One ?v1 Zero) == True
### Ignoring duplicate rewrite rule:
### ordered_bdt (Bdt_Node Zero ?v1 One) == True
### Ignoring duplicate rewrite rule:
### ordered_bdt (Bdt_Node One ?v1 One) == True
consts
  switch ::
    "('s => 'v) => ('v set * ('s, 'p, 'f) com) list => ('s, 'p, 'f) com"
consts
  guards :: "('f * 's set) list => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  flatten :: "('s, 'p, 'f) com => ('s, 'p, 'f) com list"
consts
  sequence ::
    "(('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com)
     => ('s, 'p, 'f) com list => ('s, 'p, 'f) com"
Found termination order: "size <*mlex*> {}"
consts
  max_var :: "bdt => nat"
consts
  normalize :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  dag_map :: "(ref => ref) => dag => dag"
Proofs for inductive predicate(s) "Dagsp"
  Proving monotonicity ...
consts
  strip_guards :: "'f set => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
Found termination order: "size <*mlex*> {}"
consts
  mark_guards :: "'f => ('s, 'p, 'g) com => ('s, 'p, 'f) com"
consts
  reduced_bdt :: "bdt => bool"
### No equation for constructor "Skip"
### No equation for constructor "Basic"
### No equation for constructor "Spec"
### No equation for constructor "Seq"
### No equation for constructor "Cond"
### No equation for constructor "While"
### No equation for constructor "Call"
### No equation for constructor "DynCom"
### No equation for constructor "Throw"
### No equation for constructor "Catch"
consts
  dest_Guard :: "('s, 'p, 'f) com => 'f * 's set * ('s, 'p, 'f) com"
consts
  merge_guards :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
### theory "Draft.General"
### 1.901s elapsed time, 5.086s cpu time, 1.414s GC time
consts
  noguards :: "('s, 'p, 'f) com => bool"
consts
  nothrows :: "('s, 'p, 'f) com => bool"
Proofs for inductive predicate(s) "com_relp"
  Proving monotonicity ...
### Legacy feature! Old 'recdef' command -- use 'fun' or 'function' instead
Defining recursive function "Language.inter_guards" ...
Proving induction theorem ...
Postprocessing ...
Simplifying nested TCs ...
... Postprocessing finished
Proving unsplit equation...
th:
(Skip \<inter>\<^sub>g Skip) = None ==> (Skip \<inter>\<^sub>g Skip) = None
split ths:
(Skip \<inter>\<^sub>g Basic ?bc) = None
(Skip \<inter>\<^sub>g Spec ?bd) = None
(Skip \<inter>\<^sub>g Seq ?be ?bf) = None
(Skip \<inter>\<^sub>g Cond ?bg ?bh ?bi) = None
(Skip \<inter>\<^sub>g While ?bj ?bk) = None
(Skip \<inter>\<^sub>g Call ?bl) = None
(Skip \<inter>\<^sub>g DynCom ?bm) = None
(Skip \<inter>\<^sub>g Guard ?bn ?bo ?bp) = None
(Skip \<inter>\<^sub>g Throw) = None
(Skip \<inter>\<^sub>g Catch ?bq ?br) = None
(Basic ?w \<inter>\<^sub>g Skip) = None
(Basic ?w \<inter>\<^sub>g Spec ?cj) = None
(Basic ?w \<inter>\<^sub>g Seq ?ck ?cl) = None
(Basic ?w \<inter>\<^sub>g Cond ?cm ?cn ?co) = None
(Basic ?w \<inter>\<^sub>g While ?cp ?cq) = None
(Basic ?w \<inter>\<^sub>g Call ?cr) = None
(Basic ?w \<inter>\<^sub>g DynCom ?cs) = None
(Basic ?w \<inter>\<^sub>g Guard ?ct ?cu ?cv) = None
(Basic ?w \<inter>\<^sub>g Throw) = None
(Basic ?w \<inter>\<^sub>g Catch ?cw ?cx) = None
(Spec ?x \<inter>\<^sub>g Skip) = None
(Spec ?x \<inter>\<^sub>g Basic ?do) = None
(Spec ?x \<inter>\<^sub>g Seq ?dq ?dr) = None
(Spec ?x \<inter>\<^sub>g Cond ?ds ?dt ?du) = None
(Spec ?x \<inter>\<^sub>g While ?dv ?dw) = None
(Spec ?x \<inter>\<^sub>g Call ?dx) = None
(Spec ?x \<inter>\<^sub>g DynCom ?dy) = None
(Spec ?x \<inter>\<^sub>g Guard ?dz ?ea ?eb) = None
(Spec ?x \<inter>\<^sub>g Throw) = None
(Spec ?x \<inter>\<^sub>g Catch ?ec ?ed) = None
(Seq ?y ?z \<inter>\<^sub>g Skip) = None
(Seq ?y ?z \<inter>\<^sub>g Basic ?ev) = None
(Seq ?y ?z \<inter>\<^sub>g Spec ?ew) = None
(Seq ?y ?z \<inter>\<^sub>g Cond ?ez ?fa ?fb) = None
(Seq ?y ?z \<inter>\<^sub>g While ?fc ?fd) = None
(Seq ?y ?z \<inter>\<^sub>g Call ?fe) = None
(Seq ?y ?z \<inter>\<^sub>g DynCom ?ff) = None
(Seq ?y ?z \<inter>\<^sub>g Guard ?fg ?fh ?fi) = None
(Seq ?y ?z \<inter>\<^sub>g Throw) = None
(Seq ?y ?z \<inter>\<^sub>g Catch ?fj ?fk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Skip) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Basic ?gb) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Spec ?gc) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Seq ?gd ?ge) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g While ?gi ?gj) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Call ?gk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g DynCom ?gl) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Guard ?gm ?gn ?go) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Throw) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Catch ?gp ?gq) = None
(While ?ad ?ae \<inter>\<^sub>g Skip) = None
(While ?ad ?ae \<inter>\<^sub>g Basic ?hh) = None
(While ?ad ?ae \<inter>\<^sub>g Spec ?hi) = None
(While ?ad ?ae \<inter>\<^sub>g Seq ?hj ?hk) = None
(While ?ad ?ae \<inter>\<^sub>g Cond ?hl ?hm ?hn) = None
(While ?ad ?ae \<inter>\<^sub>g Call ?hq) = None
(While ?ad ?ae \<inter>\<^sub>g DynCom ?hr) = None
(While ?ad ?ae \<inter>\<^sub>g Guard ?hs ?ht ?hu) = None
(While ?ad ?ae \<inter>\<^sub>g Throw) = None
(While ?ad ?ae \<inter>\<^sub>g Catch ?hv ?hw) = None
(Call ?af \<inter>\<^sub>g Skip) = None
(Call ?af \<inter>\<^sub>g Basic ?in) = None
(Call ?af \<inter>\<^sub>g Spec ?io) = None
(Call ?af \<inter>\<^sub>g Seq ?ip ?iq) = None
(Call ?af \<inter>\<^sub>g Cond ?ir ?is ?it) = None
(Call ?af \<inter>\<^sub>g While ?iu ?iv) = None
(Call ?af \<inter>\<^sub>g DynCom ?ix) = None
(Call ?af \<inter>\<^sub>g Guard ?iy ?iz ?ja) = None
(Call ?af \<inter>\<^sub>g Throw) = None
(Call ?af \<inter>\<^sub>g Catch ?jb ?jc) = None
(DynCom ?ag \<inter>\<^sub>g Skip) = None
(DynCom ?ag \<inter>\<^sub>g Basic ?jt) = None
(DynCom ?ag \<inter>\<^sub>g Spec ?ju) = None
(DynCom ?ag \<inter>\<^sub>g Seq ?jv ?jw) = None
(DynCom ?ag \<inter>\<^sub>g Cond ?jx ?jy ?jz) = None
(DynCom ?ag \<inter>\<^sub>g While ?ka ?kb) = None
(DynCom ?ag \<inter>\<^sub>g Call ?kc) = None
(DynCom ?ag \<inter>\<^sub>g Guard ?ke ?kf ?kg) = None
(DynCom ?ag \<inter>\<^sub>g Throw) = None
(DynCom ?ag \<inter>\<^sub>g Catch ?kh ?ki) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Skip) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Basic ?kz) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Spec ?la) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Seq ?lb ?lc) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Cond ?ld ?le ?lf) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g While ?lg ?lh) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Call ?li) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g DynCom ?lj) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Throw) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Catch ?ln ?lo) = None
(Throw \<inter>\<^sub>g Skip) = None
(Throw \<inter>\<^sub>g Basic ?mf) = None
(Throw \<inter>\<^sub>g Spec ?mg) = None
(Throw \<inter>\<^sub>g Seq ?mh ?mi) = None
(Throw \<inter>\<^sub>g Cond ?mj ?mk ?ml) = None
(Throw \<inter>\<^sub>g While ?mm ?mn) = None
(Throw \<inter>\<^sub>g Call ?mo) = None
(Throw \<inter>\<^sub>g DynCom ?mp) = None
(Throw \<inter>\<^sub>g Guard ?mq ?mr ?ms) = None
(Throw \<inter>\<^sub>g Catch ?mt ?mu) = None
(Catch ?ak ?al \<inter>\<^sub>g Skip) = None
(Catch ?ak ?al \<inter>\<^sub>g Basic ?nl) = None
(Catch ?ak ?al \<inter>\<^sub>g Spec ?nm) = None
(Catch ?ak ?al \<inter>\<^sub>g Seq ?nn ?no) = None
(Catch ?ak ?al \<inter>\<^sub>g Cond ?np ?nq ?nr) = None
(Catch ?ak ?al \<inter>\<^sub>g While ?ns ?nt) = None
(Catch ?ak ?al \<inter>\<^sub>g Call ?nu) = None
(Catch ?ak ?al \<inter>\<^sub>g DynCom ?nv) = None
(Catch ?ak ?al \<inter>\<^sub>g Guard ?nw ?nx ?ny) = None
(Catch ?ak ?al \<inter>\<^sub>g Throw) = None
--
### recdef (solve_eq): splitto: cannot find variable to split on
Proofs for inductive predicate(s) "subseteq_guards"
  Proving monotonicity ...
### theory "Simpl.Language"
### 4.474s elapsed time, 11.772s cpu time, 2.320s GC time
Loading theory "Simpl.Semantic" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoarePartial" via "Simpl.HoarePartialProps" via "Simpl.HoarePartialDef")
Proofs for inductive predicate(s) "exec"
  Proving monotonicity ...
Proofs for inductive predicate(s) "execn"
  Proving monotonicity ...
### theory "Simpl.Semantic"
### 2.311s elapsed time, 3.500s cpu time, 1.459s GC time
Loading theory "Simpl.HoarePartialDef" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoarePartial" via "Simpl.HoarePartialProps")
Loading theory "Simpl.Termination" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoareTotal" via "Simpl.HoareTotalProps" via "Simpl.SmallStep")
Proofs for inductive predicate(s) "terminates"
### Ambiguous input (line 84 of "$AFP/Simpl/HoarePartialDef.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_position" n)
###       ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###         ("_position" \<Theta>) ("_position" n) ("_position" F)
###         ("_position" P) ("_position" c) ("_position" Q) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_tuple"
###       ("\<^const>HOL.All_binder" ("_position" n) ("_position" \<Gamma>))
###       ("_tuple_arg"
###         ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###           ("_position" n) ("_position" F) ("_position" P) ("_position" c)
###           ("_position" Q) ("_position" A)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoarep"
  Proving monotonicity ...
### theory "Simpl.HoarePartialDef"
### 0.436s elapsed time, 1.045s cpu time, 0.252s GC time
Loading theory "Simpl.HoarePartialProps" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoarePartial")
### Ambiguous input (line 1078 of "$AFP/Simpl/HoarePartialProps.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.All_binder" ("_position" n)
###             ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###               ("_position" \<Theta>) ("_position" n) ("_position" F)
###               ("_position" P') ("_position" c) ("_position" Q')
###               ("_position" A')))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("_tuple"
###             ("\<^const>HOL.All_binder" ("_position" n)
###               ("_position" \<Gamma>))
###             ("_tuple_arg"
###               ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###                 ("_position" n) ("_position" F) ("_position" P')
###                 ("_position" c) ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### No equation for constructor "Spec"
consts
  procs :: "('s, 'p, 'f) com => 'p set"
### theory "Simpl.Termination"
### 0.630s elapsed time, 1.411s cpu time, 0.252s GC time
Loading theory "Simpl.HoareTotalDef" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoareTotal" via "Simpl.HoareTotalProps")
Loading theory "Simpl.SmallStep" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoareTotal" via "Simpl.HoareTotalProps")
consts
  noSpec :: "('s, 'p, 'f) com => bool"
consts
  redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
Proofs for inductive predicate(s) "step"
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoaret"
  Proving monotonicity ...
### theory "Simpl.HoarePartialProps"
### 0.678s elapsed time, 2.003s cpu time, 0.422s GC time
Loading theory "Simpl.HoarePartial" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare")
### theory "Simpl.HoareTotalDef"
### 0.644s elapsed time, 2.106s cpu time, 0.422s GC time
val tranclp_induct2 =
   "[| ?r^++ (?aa, ?ab) (?ba, ?bb); !!a b. ?r (?aa, ?ab) (a, b) ==> ?P a b;
       !!a b aa ba.
          [| ?r^++ (?aa, ?ab) (a, b); ?r (a, b) (aa, ba); ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  subst_redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
val trancl_induct2 =
   "[| ((?aa, ?ab), ?ba, ?bb) : ?r^+;
       !!a b. ((?aa, ?ab), a, b) : ?r ==> ?P a b;
       !!a b aa ba.
          [| ((?aa, ?ab), a, b) : ?r^+; ((a, b), aa, ba) : ?r; ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  seq :: "(nat => ('s, 'p, 'f) com) => 'p => nat => ('s, 'p, 'f) com"
### theory "Simpl.HoarePartial"
### 0.698s elapsed time, 1.608s cpu time, 0.093s GC time
consts
  redexes :: "('s, 'p, 'f) com => ('s, 'p, 'f) com set"
### theory "Simpl.SmallStep"
### 1.244s elapsed time, 3.204s cpu time, 0.423s GC time
Loading theory "Simpl.HoareTotalProps" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare" via "Simpl.HoareTotal")
### theory "Simpl.HoareTotalProps"
### 0.648s elapsed time, 0.799s cpu time, 0.204s GC time
Loading theory "Simpl.HoareTotal" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace" via "Simpl.Hoare")
### theory "Simpl.HoareTotal"
### 0.546s elapsed time, 0.595s cpu time, 0.068s GC time
Loading theory "Simpl.Hoare" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg" via "Simpl.StateSpace")
"\<Gamma>|-/F P c Q"
  :: "bool"
locale hoare
  fixes \<Gamma> :: "'p => ('s, 'p, 'f) com option"
"\<Gamma>|-P c Q"
  :: "bool"
"\<Gamma>|-P c Q,A"
  :: "bool"
"\<Gamma>|-/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>|-tP c Q"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^bsub>/F \<^esub>P c Q,A"
  :: "bool"
"\<Gamma>|-tP c Q,A"
  :: "bool"
"\<Gamma>|-t/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>|-t/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-t/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^sub>t\<^bsub>/F\<^esub> P c Q,A"
  :: "bool"
consts
  assoc :: "('a * 'b) list => 'a => 'b"
### theory "Simpl.Hoare"
### 0.181s elapsed time, 0.201s cpu time, 0.000s GC time
Loading theory "Simpl.StateSpace" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs" via "Simpl.Vcg")
### theory "Simpl.StateSpace"
### 0.242s elapsed time, 0.242s cpu time, 0.000s GC time
Loading theory "Simpl.Vcg" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof" via "Draft.ProcedureSpecs")
### Ignoring duplicate rewrite rule:
### ~ ~ ?y == ?y
### Ignoring duplicate rewrite rule:
### (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
### Ignoring duplicate rewrite rule:
### ?P1 | ~ ?P1 == True
### Ignoring duplicate rewrite rule:
### ~ ?P1 | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?x1 = ?x1 == True
### Ignoring duplicate rewrite rule:
### ~ True == False
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### (~ ?P1) = ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 = (~ ?P1) == False
### Ignoring duplicate rewrite rule:
### True = ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y = True == ?y
### Ignoring duplicate rewrite rule:
### False = ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 = False == ~ ?P1
### Ignoring duplicate rewrite rule:
### True --> ?y == ?y
### Ignoring duplicate rewrite rule:
### False --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> True == True
### Ignoring duplicate rewrite rule:
### ?P1 --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> False == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 --> ~ ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?y & True == ?y
### Ignoring duplicate rewrite rule:
### True & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & False == False
### Ignoring duplicate rewrite rule:
### False & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 & ~ ?P1 == False
### Ignoring duplicate rewrite rule:
### ~ ?P1 & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 | True == True
### Ignoring duplicate rewrite rule:
### True | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?y | False == ?y
### Ignoring duplicate rewrite rule:
### False | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
### Ignoring duplicate rewrite rule:
### ALL x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 == True
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x == True
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x ~= ?t1 == False
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 ~= x == False
### ML warning (line 165 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 450 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 455 of "$AFP/Simpl/hoare.ML"):
### Value identifier (prf) has not been referenced.
### ML warning (line 472 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 469 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 628 of "$AFP/Simpl/hoare.ML"):
### Value identifier (default_state_kind) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare.ML"):
### Value identifier (generate_guard) has not been referenced.
### ML warning (line 897 of "$AFP/Simpl/hoare.ML"):
### Value identifier (less) has not been referenced.
### ML warning (line 902 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1085 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1150 of "$AFP/Simpl/hoare.ML"):
### Value identifier (pE) has not been referenced.
### ML warning (line 1270 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fold_com) has not been referenced.
### ML warning (line 1386 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t1) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 1433 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1493 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1770 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1773 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1775 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1782 of "$AFP/Simpl/hoare.ML"):
### Value identifier (hoare) has not been referenced.
### ML warning (line 1872 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1842 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1940 of "$AFP/Simpl/hoare.ML"):
### Value identifier (mode) has not been referenced.
### ML warning (line 1982 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2012 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Q) has not been referenced.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Value identifier (a_vT) has not been referenced.
### ML warning (line 2076 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gT) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2094 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2118 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 2137 of "$AFP/Simpl/hoare.ML"):
### Value identifier (G) has not been referenced.
### ML warning (line 2287 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2382 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 2404 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2412 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fs) has not been referenced.
### ML warning (line 2459 of "$AFP/Simpl/hoare.ML"):
### Value identifier (b) has not been referenced.
### ML warning (line 2478 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (A) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 2720 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2737 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2744 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2832 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (name) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (destr) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2920 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fld_idx) has not been referenced.
### ML warning (line 2968 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3011 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3126 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 3114 of "$AFP/Simpl/hoare.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x_upd') has not been referenced.
### ML warning (line 3172 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3282 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3283 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3296 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3298 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3330 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
### ML warning (line 3336 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
signature HOARE =
  sig
    val BasicSimpTac:
       Proof.context ->
         state_kind -> bool -> thm list -> (int -> tactic) -> int -> tactic
    val add_foldcongs: thm list -> theory -> theory
    val add_foldcongsimps: thm list -> theory -> theory
    val add_params:
       morphism ->
         string ->
           (par_kind * string) list -> Context.generic -> Context.generic
    val add_recursive:
       morphism -> string -> Context.generic -> Context.generic
    val add_state_kind:
       morphism ->
         string -> state_kind -> Context.generic -> Context.generic
    datatype 'a bodykind = BodyTerm of 'a | BodyTyp of 'a
    val chopsfx: string -> string -> string
    val clique_name: string list -> string
    val deco: string
    val extern: Proof.context -> string -> string
    val gen_proc_rec: Proof.context -> hoareMode -> int -> thm
    val generate_guard: Proof.context -> term -> term option
    val get_data: Proof.context -> hoare_data
    val get_default_state_kind: Proof.context -> state_kind
    val get_foldcong_ss: theory -> simpset
    val get_params:
       string -> Proof.context -> (par_kind * string) list option
    val get_state_kind: string -> Proof.context -> state_kind option
    val hoare: (Proof.context -> Proof.method) context_parser
    datatype hoareMode = Partial | Total
    type hoare_data =
       {active_procs: string list list,
        default_state_kind: state_kind,
        generate_guard: stamp * (Proof.context -> term -> term option),
        hoare_tacs: (string * hoare_tac) list,
        proc_info: proc_info Symtab.table,
        vcg_simps: thm list, wp_tacs: (string * hoare_tac) list}
    val hoare_raw: (Proof.context -> Proof.method) context_parser
    val hoare_rule: (Proof.context -> Proof.method) context_parser
    val hoare_rule_tac: Proof.context -> thm list -> int -> tactic
    type hoare_tac =
       (bool -> int -> tactic) ->
         Proof.context -> hoareMode -> int -> tactic
    val implementationN: string
    val install_generate_guard:
       (Proof.context -> term -> term option) ->
         Context.generic -> Context.generic
    val is_state_var: string -> bool
    val modeqN: string
    val modexN: string
    val par_deco: string -> string
    datatype par_kind = In | Out
    val proc_deco: string
    type proc_info =
       {params: (par_kind * string) list,
        recursive: bool, state_kind: state_kind}
    val proc_specs: (bstring * string) list parser
    val remdeco: Proof.context -> string -> string
    val remdeco': string -> string
    val resuffix: string -> string -> string -> string
    val set_default_state_kind:
       state_kind -> Context.generic -> Context.generic
    val specL: string
    datatype state_kind = Function | Record
    val undeco: Proof.context -> term -> term
    val varname: string -> string
    val vcg: (Proof.context -> Proof.method) context_parser
    val vcg_step: (Proof.context -> Proof.method) context_parser
    val vcg_tac:
       string -> string -> string list -> Proof.context -> int -> tactic
  end
structure Hoare: HOARE
### ML warning (line 98 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 97 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ys) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 107 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 242 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 271 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 282 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 281 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 279 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 322 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_val) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 5 is redundant.
### ML warning (line 469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 492 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 499 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 502 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 533 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 535 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 581 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 583 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 667 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 701 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 699 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 706 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 750 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 14 is redundant.
### ML warning (line 758 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 786 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 773 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 788 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 800 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 825 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 813 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 816 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 837 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 827 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 851 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 839 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 842 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 876 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 975 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 972 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 969 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 967 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 965 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 963 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 961 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 959 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 957 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 953 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 993 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1042 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (values) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (idxs) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (value) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1098 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 2 is redundant.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (constr) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (dest) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd') has not been referenced.
### ML warning (line 1165 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1152 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1143 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1178 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1211 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 1235 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1274 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1300 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1302 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (result) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1341 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1362 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1442 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1439 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1473 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1492 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1502 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1506 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1525 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1542 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1534 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1555 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 1611 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 1602 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
signature HOARE_SYNTAX =
  sig
    val antiquoteCur: string
    val antiquoteOld: string
    val antiquoteOld_tr: Proof.context -> term list -> term
    val antiquote_applied_only_to: (term -> bool) -> term -> bool
    val antiquote_varname_tr: string -> term list -> term
    val app_quote_tr': Proof.context -> term -> term list -> term
    val assert_tr': Proof.context -> term list -> term
    val assign_tr: Proof.context -> term list -> term
    val assign_tr': Proof.context -> term list -> term
    val basic_assigns_tr: Proof.context -> term list -> term
    val basic_tr: Proof.context -> term list -> term
    val basic_tr': Proof.context -> term list -> term
    val bexp_tr': string -> Proof.context -> term list -> term
    val bind_tr': Proof.context -> term list -> term
    val call_ass_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr': Proof.context -> term list -> term
    val dyn_call_tr': Proof.context -> term list -> term
    val fcall_tr: Proof.context -> term list -> term
    val fcall_tr': Proof.context -> term list -> term
    val guarded_Assign_tr: Proof.context -> term list -> term
    val guarded_Cond_tr: Proof.context -> term list -> term
    val guarded_NNew_tr: Proof.context -> term list -> term
    val guarded_New_tr: Proof.context -> term list -> term
    val guarded_WhileFix_tr: Proof.context -> term list -> term
    val guarded_While_tr: Proof.context -> term list -> term
    val guards_tr': Proof.context -> term list -> term
    val hide_guards: bool Config.T
    val init_tr: Proof.context -> term list -> term
    val init_tr': Proof.context -> term list -> term
    val loc_tr: Proof.context -> term list -> term
    val loc_tr': Proof.context -> term list -> term
    val new_tr: Proof.context -> term list -> term
    val new_tr': Proof.context -> term list -> term
    val nnew_tr: Proof.context -> term list -> term
    val nnew_tr': Proof.context -> term list -> term
    val proc_ass_tr: Proof.context -> term list -> term
    val proc_tr: Proof.context -> term list -> term
    val proc_tr': Proof.context -> term list -> term
    val quote_mult_tr':
       Proof.context -> (term -> bool) -> string -> string -> term -> term
    val quote_tr: Proof.context -> string -> term -> term
    val quote_tr': Proof.context -> string -> term -> term
    val raise_tr: Proof.context -> term list -> term
    val raise_tr': Proof.context -> term list -> term
    val switch_tr': Proof.context -> term list -> term
    val update_comp:
       Proof.context ->
         string list -> bool -> bool -> xstring -> term -> term -> term
    val use_call_tr': bool Config.T
    val whileAnnoGFix_tr': Proof.context -> term list -> term
    val whileAnnoG_tr': Proof.context -> term list -> term
  end
structure Hoare_Syntax: HOARE_SYNTAX
### theory "Simpl.Vcg"
### 2.791s elapsed time, 3.090s cpu time, 0.414s GC time
Loading theory "Draft.ProcedureSpecs" (required by "Draft.LevellistProofMoreTemplates" via "Draft.LevellistProof")
### theory "Draft.ProcedureSpecs"
### 0.610s elapsed time, 0.663s cpu time, 0.051s GC time
Loading theory "Draft.LevellistProof" (required by "Draft.LevellistProofMoreTemplates")
### theory "Draft.LevellistProof"
### 0.207s elapsed time, 0.207s cpu time, 0.000s GC time
Loading theory "Draft.LevellistProofMoreTemplates"
val templateLemmas =
   [("LevellistProof.dag_Null", "dag Null ?l ?r = Tip",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 2, template_hole 1), template_var 1),
         template_var 0),
       template_hole 0)),
    ("LevellistProof.first_simps", "first (?r # ?rs) = ?r",
     template_equation
      (template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_var 1)),
    ("LevellistProof.allD", "ALL ll. ?P ll ==> ?P ?ll",
     template_implication
      ([template_predicate (template_app (template_hole 0, t_empty))],
       template_predicate (template_app (template_var 1, template_var 0)))),
    ("LevellistProof.all_stop_cong", "(ALL x. ?P x) = (ALL x. ?P x)",
     template_equation
      (template_app (template_hole 0, t_empty),
       template_app (template_hole 0, t_empty))),
    ("LevellistProof.Levellist_length",
     "Levellist ?hds ?p ?ll ==> length ?ll = length ?hds",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_equation
        (template_app (template_hole 1, template_var 0),
         template_app (template_hole 0, template_var 2)))),
    ("LevellistProof.Levellist_unique",
     "[| Levellist ?hds ?next ?ll; Levellist ?hds ?next ?ll' |]
      ==> ?ll = ?ll'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 3),
                template_var 2),
              template_var 0)
            )],
       template_equation (template_var 1, template_var 0))),
    ("LevellistProof.wf_levellist_subset",
     "wf_levellist ?t ?ll ?ll' ?var ==>
      set (concat ?ll') <= set (concat ?ll) Un set_of ?t",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 5, template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_inequation
        (less_equals,
         template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app
          (template_app
            (template_hole 1,
             template_app
              (template_hole 3,
               template_app (template_hole 2, template_var 2))),
           template_app (template_hole 0, template_var 3))))),
    ("LevellistProof.Levellist_unique_ex_conj_simp",
     "Levellist ?hds ?next ?ll ==>
      (EX ll. Levellist ?hds ?next ll & ?P ll) = ?P ?ll",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_var 1)
            )],
       template_equation
        (template_app (template_hole 1, t_empty),
         template_app (template_var 0, template_var 1)))),
    ("LevellistProof.map_update",
     "?i < length ?xss ==>
      map ?f (?xss[?i := ?xs]) = (map ?f ?xss)[?i := ?f ?xs]",
     template_implication
      ([template_inequation
         (less_than, template_var 3,
          template_app (template_hole 4, template_var 2))],
       template_equation
        (template_app
          (template_app (template_hole 2, template_var 1),
           template_app
            (template_app
              (template_app (template_hole 1, template_var 2),
               template_var 3),
             template_var 0)),
         template_app
          (template_app
            (template_app
              (template_hole 0,
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_var 2)),
             template_var 3),
           template_app (template_var 1, template_var 0))))),
    ("LevellistProof.in_set_concat_idx",
     "?x : set (concat ?xss) ==> EX i<length ?xss. ?x : set (?xss ! i)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 7, template_var 1),
              template_app
               (template_hole 6,
                template_app (template_hole 5, template_var 0)))
            )],
       template_predicate (template_app (template_hole 4, t_empty)))),
    ("LevellistProof.Dag_unique_ex_conjI",
     "[| Dag ?p ?l ?r ?t; ?P ?t |] ==> EX t. Dag ?p ?l ?r t & ?P t",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 2, template_var 4),
                  template_var 3),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_var 0, template_var 1))],
       template_predicate (template_app (template_hole 1, t_empty)))),
    ("LevellistProof.Levellist_ext_to_all",
     "((EX ll. Levellist ?hds ?next ll & ?P ll) --> ?Q) =
      (ALL ll. Levellist ?hds ?next ll & ?P ll --> ?Q)",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, t_empty)),
         template_var 0),
       template_app (template_hole 0, t_empty))),
    ("LevellistProof.replicate_spec",
     "[| ALL i<?n. ?xs ! i = ?x; ?n = length ?xs |]
      ==> replicate (length ?xs) ?x = ?xs",
     template_implication
      ([template_predicate (template_app (template_hole 8, t_empty)),
        template_equation
         (template_var 2, template_app (template_hole 2, template_var 1))],
       template_equation
        (template_app
          (template_app
            (template_hole 0,
             template_app (template_hole 2, template_var 1)),
           template_var 0),
         template_var 1))),
    ("LevellistProof.Dag_RefD",
     "[| Dag ?p ?l ?r ?t; ?p ~= Null |]
      ==> EX lt rt.
             ?t = dag.Node lt ?p rt &
             Dag (?l ?p) ?l ?r lt & Dag (?r ?p) ?l ?r rt",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 7, template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            ),
        template_negation
         (template_equation (template_var 3, template_hole 4))],
       template_predicate (template_app (template_hole 3, t_empty))))]:
   (string * thm * template) list
### theory "Draft.LevellistProofMoreTemplates"
### 0.467s elapsed time, 0.694s cpu time, 0.161s GC time
val it = (): unit
