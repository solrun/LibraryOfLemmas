Loading theory "HOL-Eisbach.Eisbach" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_EqI" via "HOL-Eisbach.Eisbach_Tools")
Loading theory "Draft.Cache_Tactics" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Draft.OG_Syntax" via "Draft.OG_Tactics")
Loading theory "Draft.Language" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Draft.OG_Syntax" via "Draft.OG_Hoare" via "Draft.OG_Annotations" via "Draft.SmallStep")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.SumArrMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
signature CACHE_TACTICS =
  sig
    val PARALLEL_GOALS_CACHE: cache_id -> tactic -> tactic
    val SUBGOAL_CACHE: cache_id -> (term * int -> tactic) -> int -> tactic
    eqtype cache_id
    val cacheify_tactic:
       int ->
         (Proof.context * cache_id list -> int -> tactic) ->
           Proof.context -> int -> tactic
    val clear_subgoal_cache: cache_id -> unit
    val new_subgoal_cache: unit -> cache_id
  end
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
structure Cache_Tactics: CACHE_TACTICS
### theory "Draft.Cache_Tactics"
### 0.065s elapsed time, 0.256s cpu time, 0.000s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.SumArrMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
### theory "HOL-Library.Function_Algebras"
### 0.137s elapsed time, 0.530s cpu time, 0.031s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Type_Syntax" via "HOL-Library.Word" via "HOL-Library.Type_Length" via "HOL-Library.Numeral_Type" via "HOL-Library.Cardinality")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
structure Eisbach_Rule_Insts: sig end
Found termination order: "size_list size <*mlex*> {}"
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
### theory "HOL-Library.Nat_Bijection"
### 0.315s elapsed time, 1.234s cpu time, 0.127s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.SumArrMoreTemplates" via "Draft.ExtrEqs")
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
### theory "HOL-Eisbach.Eisbach"
### 0.475s elapsed time, 1.855s cpu time, 0.200s GC time
Loading theory "HOL-Eisbach.Eisbach_Tools" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Word_EqI")
val try_map = fn: 'a Seq.seq -> 'a Seq.seq -> 'a Seq.seq
val uncurry_rule = fn: thm -> thm
val curry_rule = fn: thm -> thm
### theory "HOL-Eisbach.Eisbach_Tools"
### 0.030s elapsed time, 0.114s cpu time, 0.000s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.SumArrMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### theory "HOL-Library.Phantom_Type"
### 0.509s elapsed time, 2.036s cpu time, 0.245s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Type_Syntax" via "HOL-Library.Word" via "HOL-Library.Type_Length" via "HOL-Library.Numeral_Type")
### theory "HOL-Library.Set_Algebras"
### 0.214s elapsed time, 0.877s cpu time, 0.170s GC time
Loading theory "HOL-Library.Signed_Division" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Signed_Division_Word")
### Additional type variable(s) in locale specification "CARD_1": 'a
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
class signed_division = type +
  fixes signed_divide :: "'a => 'a => 'a"
    and signed_modulo :: "'a => 'a => 'a"
instantiation
  int :: signed_division
  signed_divide_int == signed_divide :: int => int => int
  signed_modulo_int == signed_modulo :: int => int => int
consts
  shift :: "'a list => 'a stream => 'a stream"
### theory "HOL-Library.Signed_Division"
### 0.111s elapsed time, 0.448s cpu time, 0.000s GC time
Loading theory "HOL-Library.Sublist" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.More_Word_Operations" via "Word_Lib.Reversed_Bit_Lists")
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
### Additional type variable(s) in locale specification "card2": 'a
consts
  snth :: "'a stream => nat => 'a"
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
consts
  cycle :: "'a list => 'a stream"
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
consts
  flat :: "'a list stream => 'a stream"
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
consts
  prefixes :: "'a list => 'a list list"
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
### theory "HOL-Library.Cardinality"
### 0.891s elapsed time, 3.362s cpu time, 0.741s GC time
Loading theory "HOL-Library.Numeral_Type" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Type_Syntax" via "HOL-Library.Word" via "HOL-Library.Type_Length")
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.233s elapsed time, 4.741s cpu time, 0.890s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.SumArrMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  num1 :: CARD_1
instantiation
  num1 :: {comm_monoid_mult,numeral,comm_ring}
  uminus_num1 == uminus :: num1 => num1
  zero_num1 == zero_class.zero :: num1
  minus_num1 == minus :: num1 => num1 => num1
  plus_num1 == plus :: num1 => num1 => num1
  one_num1 == one_class.one :: num1
  times_num1 == times :: num1 => num1 => num1
instantiation
  num1 :: linorder
  less_eq_num1 == less_eq :: num1 => num1 => bool
  less_num1 == less :: num1 => num1 => bool
locale mod_type
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_type n Rep Abs"
locale mod_ring
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_ring n Rep Abs"
instantiation
  bit0 :: (finite) {minus,one,plus,times,uminus,zero}
  bit1 :: (finite) {minus,one,plus,times,uminus,zero}
  zero_bit0 == zero_class.zero :: 'a bit0
  uminus_bit0 == uminus :: 'a bit0 => 'a bit0
  times_bit0 == times :: 'a bit0 => 'a bit0 => 'a bit0
  plus_bit0 == plus :: 'a bit0 => 'a bit0 => 'a bit0
  one_bit0 == one_class.one :: 'a bit0
  minus_bit0 == minus :: 'a bit0 => 'a bit0 => 'a bit0
  zero_bit1 == zero_class.zero :: 'a bit1
  uminus_bit1 == uminus :: 'a bit1 => 'a bit1
  times_bit1 == times :: 'a bit1 => 'a bit1 => 'a bit1
  plus_bit1 == plus :: 'a bit1 => 'a bit1 => 'a bit1
  one_bit1 == one_class.one :: 'a bit1
  minus_bit1 == minus :: 'a bit1 => 'a bit1 => 'a bit1
instantiation
  bit0 :: (finite) linorder
  bit1 :: (finite) linorder
  less_eq_bit0 == less_eq :: 'a bit0 => 'a bit0 => bool
  less_bit0 == less :: 'a bit0 => 'a bit0 => bool
  less_eq_bit1 == less_eq :: 'a bit1 => 'a bit1 => bool
  less_bit1 == less :: 'a bit1 => 'a bit1 => bool
consts
  suffixes :: "'a list => 'a list list"
instantiation
  num0 :: equal
  equal_num0 == equal_class.equal :: num0 => num0 => bool
Proofs for inductive predicate(s) "list_emb"
  Proving monotonicity ...
instantiation
  num1 :: equal
  equal_num1 == equal_class.equal :: num1 => num1 => bool
instantiation
  num1 :: enum
  enum_num1 == enum_class.enum :: num1 list
  enum_all_num1 == enum_class.enum_all :: (num1 => bool) => bool
  enum_ex_num1 == enum_class.enum_ex :: (num1 => bool) => bool
instantiation
  num0 :: card_UNIV
  num1 :: card_UNIV
  card_UNIV_num0 == card_UNIV_class.card_UNIV :: (num0, nat) phantom
  finite_UNIV_num0 == finite_UNIV :: (num0, bool) phantom
  card_UNIV_num1 == card_UNIV_class.card_UNIV :: (num1, nat) phantom
  finite_UNIV_num1 == finite_UNIV :: (num1, bool) phantom
instantiation
  bit0 :: (finite) equal
  bit1 :: (finite) equal
  equal_bit0 == equal_class.equal :: 'a bit0 => 'a bit0 => bool
  equal_bit1 == equal_class.equal :: 'a bit1 => 'a bit1 => bool
instantiation
  bit0 :: (finite) enum
  enum_bit0 == enum_class.enum :: 'a bit0 list
  enum_all_bit0 == enum_class.enum_all :: ('a bit0 => bool) => bool
  enum_ex_bit0 == enum_class.enum_ex :: ('a bit0 => bool) => bool
instantiation
  bit1 :: (finite) enum
  enum_bit1 == enum_class.enum :: 'a bit1 list
  enum_all_bit1 == enum_class.enum_all :: ('a bit1 => bool) => bool
  enum_ex_bit1 == enum_class.enum_ex :: ('a bit1 => bool) => bool
instantiation
  bit0 :: (finite) finite_UNIV
  bit1 :: (finite) finite_UNIV
  finite_UNIV_bit0 == finite_UNIV :: ('a bit0, bool) phantom
  finite_UNIV_bit1 == finite_UNIV :: ('a bit1, bool) phantom
instantiation
  bit0 :: ({card_UNIV,finite}) card_UNIV
  bit1 :: ({card_UNIV,finite}) card_UNIV
  card_UNIV_bit0 == card_UNIV_class.card_UNIV :: ('a bit0, nat) phantom
  card_UNIV_bit1 == card_UNIV_class.card_UNIV :: ('a bit1, nat) phantom
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
### theory "HOL-Library.Numeral_Type"
### 0.793s elapsed time, 3.119s cpu time, 0.454s GC time
Loading theory "HOL-Library.Type_Length" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Type_Syntax" via "HOL-Library.Word")
Found termination order: "size <*mlex*> {}"
class len0 = type +
  fixes len_of :: "'a itself => nat"
Found termination order: "size <*mlex*> {}"
class len = len0 +
  assumes "len_gt_0": "0 < LENGTH('a)"
instantiation
  0 :: len0
  1 :: len0
  len_of_num0 == len_of :: 0 itself => nat
  len_of_num1 == len_of :: 1 itself => nat
instantiation
  bit0 :: (len0) len0
  bit1 :: (len0) len0
  len_of_bit0 == len_of :: 'a bit0 itself => nat
  len_of_bit1 == len_of :: 'a bit1 itself => nat
instantiation
  Enum.finite_1 :: len
  len_of_finite_1 == len_of :: Enum.finite_1 itself => nat
instantiation
  Enum.finite_2 :: len
  len_of_finite_2 == len_of :: Enum.finite_2 itself => nat
Found termination order: "size <*mlex*> {}"
instantiation
  Enum.finite_3 :: len
  len_of_finite_3 == len_of :: Enum.finite_3 itself => nat
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  sublists :: "'a list => 'a list list"
Found termination order: "size <*mlex*> {}"
consts
  switch ::
    "('s => 'v) => ('v set * ('s, 'p, 'f) com) list => ('s, 'p, 'f) com"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Sublist"
### 2.152s elapsed time, 8.113s cpu time, 2.037s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.SumArrMoreTemplates" via "Draft.ExtrEqs")
consts
  guards :: "('f * 's set) list => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Language"
### 3.081s elapsed time, 11.788s cpu time, 2.463s GC time
Loading theory "Draft.SmallStep" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Draft.OG_Syntax" via "Draft.OG_Hoare" via "Draft.OG_Annotations")
Found termination order: "size <*mlex*> {}"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "HOL-Library.Type_Length"
### 0.861s elapsed time, 3.195s cpu time, 0.992s GC time
Loading theory "HOL-Library.Word" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Type_Syntax")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
instantiation
  word :: (len) comm_ring_1
  uminus_word == uminus :: 'a word => 'a word
  one_word == one_class.one :: 'a word
  times_word == times :: 'a word => 'a word => 'a word
  zero_word == zero_class.zero :: 'a word
  minus_word == minus :: 'a word => 'a word => 'a word
  plus_word == plus :: 'a word => 'a word => 'a word
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
signature WORD_LIB =
  sig
    val dest_binT: typ -> int
    val dest_wordT: typ -> int
    val is_wordT: typ -> bool
    val mk_wordT: int -> typ
  end
structure Word_Lib: WORD_LIB
Found termination order: "size <*mlex*> {}"
instantiation
  word :: (len) equal
  equal_word == equal_class.equal :: 'a word => 'a word => bool
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  atom_com :: "('s, 'p, 'f) com => bool"
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
### theory "HOL-Library.BigO"
### 1.231s elapsed time, 4.632s cpu time, 1.500s GC time
Loading theory "Word_Lib.Enumeration" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Enumeration_Word")
Found termination order: "size <*mlex*> {}"
consts
  the_index :: "'a list => 'a => nat"
Proofs for inductive predicate(s) "step"
class enum = finite +
  fixes enum :: "'a list"
    and enum_all :: "('a => bool) => bool"
    and enum_ex :: "('a => bool) => bool"
  assumes "UNIV_enum": "UNIV = set enum_class.enum"
    and "enum_distinct": "distinct enum_class.enum"
  assumes "enum_all_UNIV": "!!P. enum_class.enum_all P = Ball UNIV P"
  assumes "enum_ex_UNIV": "!!P. enum_class.enum_ex P = Bex UNIV P"
  Proving monotonicity ...
class enum_alt = type +
  fixes enum_alt :: "nat => 'a option"
### theory "HOL-Library.Tree"
### 2.794s elapsed time, 10.591s cpu time, 2.861s GC time
Loading theory "Draft.Templates" (required by "Draft.SumArrMoreTemplates" via "Draft.ExtrEqs")
class enumeration_alt = enum_alt +
  assumes
    "enum_alt_one_bound":
      "!!x. enum_alt x = None ==> enum_alt (Suc x) = None"
  assumes "enum_alt_surj": "range enum_alt Un {None} = UNIV"
  assumes
    "enum_alt_inj":
      "!!x y. enum_alt x = enum_alt y ==> x = y | enum_alt x = None"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.090s elapsed time, 0.356s cpu time, 0.077s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.SumArrMoreTemplates")
class enumeration_both = enum + enum_alt +
  assumes "enum_alt_rel": "enum_alt = alt_from_ord enum_class.enum"
instantiation
  word :: (len) linorder
  less_eq_word == less_eq :: 'a word => 'a word => bool
  less_word == less :: 'a word => 'a word => bool
instantiation
  bool :: enumeration_both
  enum_alt_bool == enum_alt :: nat => bool option
instantiation
  word :: (len) enum
  enum_word == enum_class.enum :: 'a word list
  enum_all_word == enum_class.enum_all :: ('a word => bool) => bool
  enum_ex_word == enum_class.enum_ex :: ('a word => bool) => bool
instantiation
  nat :: enumeration_alt
  enum_alt_nat == enum_alt :: nat => nat option
instantiation
  word :: (len) semiring_modulo
  modulo_word == modulo :: 'a word => 'a word => 'a word
  divide_word == divide :: 'a word => 'a word => 'a word
### theory "Word_Lib.Enumeration"
### 0.537s elapsed time, 2.118s cpu time, 0.185s GC time
Loading theory "Word_Lib.Even_More_List" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Enumeration_Word")
instantiation
  word :: (len) semiring_bits
  bit_word == bit :: 'a word => nat => bool
### theory "Word_Lib.Even_More_List"
### 0.048s elapsed time, 0.192s cpu time, 0.000s GC time
Loading theory "Word_Lib.More_Arithmetic" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.More_Word")
instantiation
  word :: (len) ring_bit_operations
  not_word == not :: 'a word => 'a word
  and_word == and :: 'a word => 'a word => 'a word
  or_word == or :: 'a word => 'a word => 'a word
  xor_word == xor :: 'a word => 'a word => 'a word
  mask_word == mask :: nat => 'a word
  set_bit_word == set_bit :: nat => 'a word => 'a word
  unset_bit_word == unset_bit :: nat => 'a word => 'a word
  flip_bit_word == flip_bit :: nat => 'a word => 'a word
  push_bit_word == push_bit :: nat => 'a word => 'a word
  drop_bit_word == drop_bit :: nat => 'a word => 'a word
  take_bit_word == take_bit :: nat => 'a word => 'a word
### theory "Word_Lib.More_Arithmetic"
### 0.062s elapsed time, 0.253s cpu time, 0.000s GC time
Loading theory "Word_Lib.More_Misc" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.More_Word_Operations")
### theory "Word_Lib.More_Misc"
### 0.028s elapsed time, 0.112s cpu time, 0.000s GC time
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.706s elapsed time, 2.533s cpu time, 0.214s GC time
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class unique_euclidean_semiring_numeral =
  unique_euclidean_semiring_with_nat + linordered_semidom +
  fixes divmod :: "num => num => 'a * 'a"
    and divmod_step :: "num => 'a * 'a => 'a * 'a"
  assumes
    "div_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a div b = (0::'a)"
    and "mod_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a mod b = a"
    and
    "div_positive": "!!b a. [| (0::'a) < b; b <= a |] ==> (0::'a) < a div b"
    and "mod_less_eq_dividend": "!!a b. (0::'a) <= a ==> a mod b <= a"
    and "pos_mod_bound": "!!b a. (0::'a) < b ==> a mod b < b"
    and "pos_mod_sign": "!!b a. (0::'a) < b ==> (0::'a) <= a mod b"
    and
    "mod_mult2_eq":
      "!!c a b.
          (0::'a) <= c ==> a mod (b * c) = b * (a div b mod c) + a mod b"
    and
    "div_mult2_eq":
      "!!c a b. (0::'a) <= c ==> a div (b * c) = a div b div c"
  assumes "discrete": "!!a b. (a < b) = (a + (1::'a) <= b)"
  assumes
    "divmod_def":
      "!!m n.
          divmod m n = (numeral m div numeral n, numeral m mod numeral n)"
    and
    "divmod_step_def":
      "!!l qr.
          divmod_step l qr =
          (let (q, r) = qr
           in if numeral l <= r then ((2::'a) * q + (1::'a), r - numeral l)
              else ((2::'a) * q, r))"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
instantiation
  word :: (len) size
  size_word == size :: 'a word => nat
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Min (\<le>s) (set (?x # ?xs)) == fold signed.min ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Max (\<le>s) (set (?x # ?xs)) == fold signed.max ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [?x] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted (?x # ?y # ?zs) == ?x \<le>s ?y & signed.sorted (?y # ?zs)
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted_list_of_set (set ?xs) == signed.sort (remdups ?xs)
val unat_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?v1 ... ?w1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.unat_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val unat_arith_tacs = fn: Proof.context -> tactic list
val unat_arith_tac = fn: Proof.context -> int -> tactic
val uint_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?a1 ... ?b1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.uint_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val uint_arith_tacs = fn: Proof.context -> tactic list
val uint_arith_tac = fn: Proof.context -> int -> tactic
### theory "Draft.SmallStep"
### 5.207s elapsed time, 14.486s cpu time, 2.183s GC time
Loading theory "Draft.OG_Annotations" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Draft.OG_Syntax" via "Draft.OG_Hoare")
Loading theory "Draft.SeqCatch_decomp" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Draft.OG_Syntax" via "Draft.OG_Tactics" via "Draft.OG_Soundness")
locale word_rotate
### theory "Draft.SeqCatch_decomp"
### 0.214s elapsed time, 0.668s cpu time, 0.076s GC time
signature SMT_WORD =
  sig
    val add_word_shift': term * string -> Context.generic -> Context.generic
  end
structure SMT_Word: SMT_WORD
### theory "HOL-Library.Word"
### 5.286s elapsed time, 14.537s cpu time, 2.176s GC time
Loading theory "Word_Lib.Bit_Comprehension" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Rsplit" via "Word_Lib.Bits_Int")
Loading theory "Word_Lib.Legacy_Aliases" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.More_Word_Operations" via "Word_Lib.Reversed_Bit_Lists")
Loading theory "Word_Lib.More_Divides" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.More_Word")
locale abstract_boolean_algebra
  fixes
    conj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<sqinter>\<close> 70)
    and
    disj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<squnion>\<close> 65)
    and compl :: "'a => 'a"  (\<open>\<^bold>- _\<close> [81] 80)
    and zero :: "'a"  (\<open>\<^bold>0\<close>)
    and one :: "'a"  (\<open>\<^bold>1\<close>)
  assumes
    "abstract_boolean_algebra (\<^bold>\<sqinter>) (\<^bold>\<squnion>)
      compl \<^bold>0 \<^bold>1"
locale abstract_boolean_algebra_sym_diff
  fixes
    conj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<sqinter>\<close> 70)
    and
    disj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<squnion>\<close> 65)
    and compl :: "'a => 'a"  (\<open>\<^bold>- _\<close> [81] 80)
    and zero :: "'a"  (\<open>\<^bold>0\<close>)
    and one :: "'a"  (\<open>\<^bold>1\<close>)
    and
    xor :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<ominus>\<close> 65)
  assumes
    "abstract_boolean_algebra_sym_diff (\<^bold>\<sqinter>)
      (\<^bold>\<squnion>) compl \<^bold>0 \<^bold>1 (\<^bold>\<ominus>)"
### theory "Word_Lib.More_Divides"
### 0.163s elapsed time, 0.637s cpu time, 0.107s GC time
Loading theory "Word_Lib.Signed_Words" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas")
### theory "Word_Lib.Legacy_Aliases"
### 0.198s elapsed time, 0.787s cpu time, 0.107s GC time
Loading theory "Word_Lib.Type_Syntax" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas")
instantiation
  signed :: (len0) len0
  len_of_signed == len_of :: 'a signed itself => nat
structure Word_Syntax:
  sig
    val show_word_types: bool Config.T
    val tr': string -> Proof.context -> typ -> term list -> term
  end
### theory "Word_Lib.Signed_Words"
### 0.090s elapsed time, 0.353s cpu time, 0.000s GC time
Loading theory "Word_Lib.Word_Names" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32")
### theory "Word_Lib.Type_Syntax"
### 0.060s elapsed time, 0.240s cpu time, 0.000s GC time
Loading theory "Word_Lib.Word_Syntax" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32")
### theory "Word_Lib.Word_Names"
### 0.029s elapsed time, 0.113s cpu time, 0.000s GC time
Loading theory "Word_Lib.Signed_Division_Word" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas")
### theory "Word_Lib.Word_Syntax"
### 0.075s elapsed time, 0.304s cpu time, 0.000s GC time
Loading theory "Word_Lib.More_Word" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas")
instantiation
  word :: (len) signed_division
  signed_divide_word == signed_divide :: 'a word => 'a word => 'a word
  signed_modulo_word == signed_modulo :: 'a word => 'a word => 'a word
### theory "Word_Lib.Signed_Division_Word"
### 0.447s elapsed time, 1.773s cpu time, 0.186s GC time
Found termination order: "size <*mlex*> {}"
class bit_comprehension = ring_bit_operations +
  fixes set_bits :: "(nat => bool) => 'a"
  assumes "set_bits_bit_eq": "!!a. set_bits (bit a) = a"
Found termination order: "size <*mlex*> {}"
instantiation
  int :: bit_comprehension
  set_bits_int == set_bits :: (nat => bool) => int
instantiation
  word :: (len) bit_comprehension
  set_bits_word == set_bits :: (nat => bool) => 'a word
Proofs for inductive predicate(s) "wf_set_bits_int"
  Proving monotonicity ...
### theory "Word_Lib.Bit_Comprehension"
### 1.057s elapsed time, 3.913s cpu time, 0.350s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Proofs for inductive predicate(s) "ann_matches"
  Proving monotonicity ...
### theory "Word_Lib.More_Word"
### 1.244s elapsed time, 3.638s cpu time, 0.327s GC time
Loading theory "Word_Lib.Bit_Shifts_Infix_Syntax" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas" via "Word_Lib.Most_significant_bit")
Loading theory "Word_Lib.Enumeration_Word" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas")
Loading theory "Word_Lib.Least_significant_bit" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Rsplit" via "Word_Lib.Bits_Int")
consts
  ann_guards ::
    "'s set => ('f * 's set) list => ('s, 'p, 'f) ann => ('s, 'p, 'f) ann"
### theory "Draft.OG_Annotations"
### 1.920s elapsed time, 6.041s cpu time, 0.510s GC time
Loading theory "Draft.OG_Hoare" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Draft.OG_Syntax")
Proofs for inductive predicate(s) "atomicsR"
  Proving monotonicity ...
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Proofs for inductive predicate(s) "assertionsR"
  Proving monotonicity ...
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
instantiation
  word :: (len) enumeration_both
  enum_alt_word == enum_alt :: nat => 'a word option
### theory "Word_Lib.Enumeration_Word"
### 0.572s elapsed time, 2.272s cpu time, 0.151s GC time
class lsb = semiring_bits +
  fixes lsb :: "'a => bool"
  assumes "lsb_odd": "lsb = odd"
instantiation
  int :: lsb
  lsb_int == lsb :: int => bool
instantiation
  word :: (len) lsb
  lsb_word == lsb :: 'a word => bool
### theory "Word_Lib.Least_significant_bit"
### 0.658s elapsed time, 2.558s cpu time, 0.151s GC time
Proofs for inductive predicate(s) "oghoare", "oghoare_seq"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
  Proving monotonicity ...
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
### theory "Word_Lib.Bit_Shifts_Infix_Syntax"
### 1.004s elapsed time, 3.294s cpu time, 0.257s GC time
Loading theory "Word_Lib.Aligned" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas")
Loading theory "Word_Lib.Singleton_Bit_Shifts" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.More_Word_Operations" via "Word_Lib.Reversed_Bit_Lists")
Loading theory "Word_Lib.Most_significant_bit" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas")
class msb = type +
  fixes msb :: "'a => bool"
instantiation
  int :: msb
  msb_int == msb :: int => bool
instantiation
  word :: (len) msb
  msb_word == msb :: 'a word => bool
### theory "Word_Lib.Singleton_Bit_Shifts"
### 0.139s elapsed time, 0.547s cpu time, 0.100s GC time
### theory "Draft.OG_Hoare"
### 1.137s elapsed time, 3.791s cpu time, 0.357s GC time
Loading theory "Draft.OG_Soundness" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Draft.OG_Syntax" via "Draft.OG_Tactics")
### theory "Word_Lib.Most_significant_bit"
### 0.191s elapsed time, 0.704s cpu time, 0.100s GC time
Loading theory "Word_Lib.Generic_set_bit" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Rsplit" via "Word_Lib.Bits_Int")
### theory "Word_Lib.Aligned"
### 0.328s elapsed time, 1.100s cpu time, 0.100s GC time
Loading theory "Word_Lib.Word_EqI" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Word_Lemmas")
### Ambiguous input (line 101 of "$AFP/Complx/OG_Soundness.thy") produces 6 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>OG_Hoare.oghoare" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" x)
###       ("_position" Q) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_idts" ("_position" b) ("_position" c))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" x)
###           ("_applC" ("_position" Await)
###             ("_cargs" ("_position" b) ("_position" c))))
###         ("\<^const>HOL.Ex_binder"
###           ("_idts" ("_position" r)
###             ("_idts" ("_position" P')
###               ("_idts" ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" P)
###               ("_applC" ("_position" AnnRec)
###                 ("_cargs" ("_position" r) ("_position" P'))))
###             ("\<^const>Set.subset_eq"
###               ("\<^const>OG_Hoare.oghoare_seq" ("_position" \<Gamma>)
###                 ("_position" \<Theta>) ("_position" F)
###                 ("\<^const>Set.inter" ("_position" r) ("_position" b))
###                 ("_position" P') ("_position" c) ("_position" Q')
###                 ("\<^const>HOL.conj" ("_position" A')
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_position" atom_com) ("_position" c))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Set.subset_eq" ("_position" Q')
###                         ("_position" Q))
###                       ("_position" A')))))
###               ("_position" A))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>OG_Hoare.oghoare" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" x)
###       ("_position" Q) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_idts" ("_position" b) ("_position" c))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" x)
###           ("_applC" ("_position" Await)
###             ("_cargs" ("_position" b) ("_position" c))))
###         ("\<^const>HOL.Ex_binder"
###           ("_idts" ("_position" r)
###             ("_idts" ("_position" P')
###               ("_idts" ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" P)
###               ("_applC" ("_position" AnnRec)
###                 ("_cargs" ("_position" r) ("_position" P'))))
###             ("\<^const>HOL.conj"
###               ("\<^const>OG_Hoare.oghoare_seq" ("_position" \<Gamma>)
###                 ("_position" \<Theta>) ("_position" F)
###                 ("\<^const>Set.inter" ("_position" r) ("_position" b))
###                 ("_position" P') ("_position" c) ("_position" Q')
###                 ("\<^const>HOL.conj" ("_position" A')
###                   ("_applC" ("_position" atom_com) ("_position" c))))
###               ("\<^const>HOL.conj"
###                 ("\<^const>Set.subset_eq" ("_position" Q') ("_position" Q))
###                 ("\<^const>Set.subset_eq" ("_position" A')
###                   ("_position" A))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>OG_Hoare.oghoare" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" x)
###       ("_position" Q) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_idts" ("_position" b) ("_position" c))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" x)
###           ("_applC" ("_position" Await)
###             ("_cargs" ("_position" b) ("_position" c))))
###         ("\<^const>HOL.Ex_binder"
###           ("_idts" ("_position" r)
###             ("_idts" ("_position" P')
###               ("_idts" ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" P)
###               ("_applC" ("_position" AnnRec)
###                 ("_cargs" ("_position" r) ("_position" P'))))
###             ("\<^const>OG_Hoare.oghoare_seq" ("_position" \<Gamma>)
###               ("_position" \<Theta>) ("_position" F)
###               ("\<^const>Set.inter" ("_position" r) ("_position" b))
###               ("_position" P') ("_position" c) ("_position" Q')
###               ("\<^const>HOL.conj" ("_position" A')
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" atom_com) ("_position" c))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Set.subset_eq" ("_position" Q')
###                       ("_position" Q))
###                     ("\<^const>Set.subset_eq" ("_position" A')
###                       ("_position" A))))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>OG_Hoare.oghoare" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" x)
###       ("_position" Q) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_idts" ("_position" b) ("_position" c))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" x)
###           ("_applC" ("_position" Await)
###             ("_cargs" ("_position" b) ("_position" c))))
###         ("\<^const>HOL.Ex_binder"
###           ("_idts" ("_position" r)
###             ("_idts" ("_position" P')
###               ("_idts" ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" P)
###               ("_applC" ("_position" AnnRec)
###                 ("_cargs" ("_position" r) ("_position" P'))))
###             ("\<^const>HOL.conj"
###               ("\<^const>OG_Hoare.oghoare_seq" ("_position" \<Gamma>)
###                 ("_position" \<Theta>) ("_position" F)
###                 ("\<^const>Set.inter" ("_position" r) ("_position" b))
###                 ("_position" P') ("_position" c) ("_position" Q')
###                 ("_position" A'))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_position" atom_com) ("_position" c))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>Set.subset_eq" ("_position" Q')
###                     ("_position" Q))
###                   ("\<^const>Set.subset_eq" ("_position" A')
###                     ("_position" A)))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>OG_Hoare.oghoare" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" x)
###       ("_position" Q) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_idts" ("_position" b) ("_position" c))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" x)
###           ("_applC" ("_position" Await)
###             ("_cargs" ("_position" b) ("_position" c))))
###         ("\<^const>HOL.Ex_binder"
###           ("_idts" ("_position" r)
###             ("_idts" ("_position" P')
###               ("_idts" ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" P)
###               ("_applC" ("_position" AnnRec)
###                 ("_cargs" ("_position" r) ("_position" P'))))
###             ("\<^const>HOL.conj"
###               ("\<^const>OG_Hoare.oghoare_seq" ("_position" \<Gamma>)
###                 ("_position" \<Theta>) ("_position" F)
###                 ("\<^const>Set.inter" ("_position" r) ("_position" b))
###                 ("_position" P') ("_position" c) ("_position" Q')
###                 ("\<^const>HOL.conj" ("_position" A')
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_position" atom_com) ("_position" c))
###                     ("\<^const>Set.subset_eq" ("_position" Q')
###                       ("_position" Q)))))
###               ("\<^const>Set.subset_eq" ("_position" A')
###                 ("_position" A)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>OG_Hoare.oghoare" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" x)
###       ("_position" Q) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_idts" ("_position" b) ("_position" c))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.eq" ("_position" x)
###           ("_applC" ("_position" Await)
###             ("_cargs" ("_position" b) ("_position" c))))
###         ("\<^const>HOL.Ex_binder"
###           ("_idts" ("_position" r)
###             ("_idts" ("_position" P')
###               ("_idts" ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq" ("_position" P)
###               ("_applC" ("_position" AnnRec)
###                 ("_cargs" ("_position" r) ("_position" P'))))
###             ("\<^const>HOL.conj"
###               ("\<^const>Set.subset_eq"
###                 ("\<^const>OG_Hoare.oghoare_seq" ("_position" \<Gamma>)
###                   ("_position" \<Theta>) ("_position" F)
###                   ("\<^const>Set.inter" ("_position" r) ("_position" b))
###                   ("_position" P') ("_position" c) ("_position" Q')
###                   ("\<^const>HOL.conj" ("_position" A')
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" atom_com) ("_position" c))
###                       ("_position" Q'))))
###                 ("_position" Q))
###               ("\<^const>Set.subset_eq" ("_position" A')
###                 ("_position" A)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
class set_bit = semiring_bits +
  fixes set_bit :: "'a => nat => bool => 'a"
  assumes
    "bit_set_bit_iff_2n":
      "!!a m b n.
          bit (set_bit_class.set_bit a m b) n =
          ((if m = n then b else bit a n) & (2::'a) ^ n ~= (0::'a))"
instantiation
  int :: set_bit
  set_bit_int == set_bit_class.set_bit :: int => nat => bool => int
instantiation
  word :: (len) set_bit
  set_bit_word == set_bit_class.set_bit :: 'a word => nat => bool => 'a word
### theory "Word_Lib.Generic_set_bit"
### 0.492s elapsed time, 1.485s cpu time, 0.076s GC time
Loading theory "Word_Lib.Bits_Int" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.Rsplit")
### Ambiguous input (line 1754 of "$AFP/Complx/OG_Soundness.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.implies"
###       ("\<^const>OG_Hoare.oghoare" ("_position" \<Gamma>)
###         ("_position" \<Theta>) ("_position" F) ("_position" P)
###         ("_position" c) ("_position" Q) ("_position" A))
###       ("\<^const>OG_Hoare.valid" ("_position" \<Gamma>) ("_position" F)
###         ("_applC" ("_position" pre) ("_position" P)) ("_position" c)
###         ("_position" Q) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>OG_Hoare.oghoare_seq" ("_position" \<Gamma>)
###         ("_position" \<Theta>) ("_position" F) ("_position" P')
###         ("_position" P) ("_position" c) ("_position" Q) ("_position" A))
###       ("\<^const>OG_Hoare.valid" ("_position" \<Gamma>) ("_position" F)
###         ("_position" P') ("_position" c) ("_position" Q) ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.conj"
###     ("\<^const>HOL.implies"
###       ("\<^const>OG_Hoare.oghoare" ("_position" \<Gamma>)
###         ("_position" \<Theta>) ("_position" F) ("_position" P)
###         ("_position" c) ("_position" Q) ("_position" A))
###       ("\<^const>OG_Hoare.valid" ("_position" \<Gamma>) ("_position" F)
###         ("_applC" ("_position" pre) ("_position" P)) ("_position" c)
###         ("_position" Q) ("_position" A)))
###     ("\<^const>OG_Hoare.oghoare_seq" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P')
###       ("_position" P) ("_position" c) ("_position" Q)
###       ("\<^const>HOL.implies" ("_position" A)
###         ("\<^const>OG_Hoare.valid" ("_position" \<Gamma>) ("_position" F)
###           ("_position" P') ("_position" c) ("_position" Q)
###           ("_position" A))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.OG_Soundness"
### 0.576s elapsed time, 1.756s cpu time, 0.190s GC time
Loading theory "Draft.OG_Tactics" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Draft.OG_Syntax")
val hyp_tac = fn: int -> tactic
val remove_single_Bound_mem = fn: Proof.context -> int -> tactic
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### ML warning (line 598 of "$AFP/Complx/OG_Tactics.thy"):
### Value identifier (args) has not been referenced.
### ML warning (line 605 of "$AFP/Complx/OG_Tactics.thy"):
### Value identifier (args) has not been referenced.
### ML warning (line 614 of "$AFP/Complx/OG_Tactics.thy"):
### Value identifier (args) has not been referenced.
### ML warning (line 623 of "$AFP/Complx/OG_Tactics.thy"):
### Value identifier (args) has not been referenced.
### ML warning (line 633 of "$AFP/Complx/OG_Tactics.thy"):
### Value identifier (args) has not been referenced.
val rt = fn: Proof.context -> thm -> int -> tactic
val rts = fn: Proof.context -> thm list -> int -> tactic
val conjI_Tac = fn: Proof.context -> (int -> tactic) -> int -> tactic
val get_oghoare_simps = fn: Proof.context -> thm list
val simp = fn: Proof.context -> thm list -> int -> tactic
val simp_only = fn: Proof.context -> thm list -> int -> tactic
val prod_sel_simp = fn: Proof.context -> int -> tactic
val oghoare_simp = fn: Proof.context -> int -> tactic
val ParallelConseq = fn: Proof.context -> int -> tactic
val enable_trace = false: bool
val trace = fn: string -> unit
val HoareRuleTac = fn: Proof.context * int list -> int -> tactic
val Call_asm_inst = fn: Proof.context -> int -> tactic
val ParallelTac = fn: Proof.context * int list -> int -> tactic
val MapAnn_Tac = fn: Proof.context * int list -> int -> tactic
val interfree_Tac = fn: Proof.context * int list -> int -> tactic
val interfree_swap_Tac = fn: Proof.context * int list -> int -> tactic
val inter_aux_Par_Tac = fn: Proof.context * int list -> int -> tactic
val interfree_aux_Tac = fn: Proof.context * int list -> int -> tactic
val dest_inter_aux_Tac = fn: Proof.context * int list -> int -> tactic
val dest_inter_right_Tac = fn: Proof.context * int list -> int -> tactic
val oghoare_tac = fn: Proof.context -> int -> tactic
val oghoare_tac' = fn: Proof.context -> int -> thm -> thm Seq.seq
val oghoare_parallel_tac = fn: Proof.context -> int -> tactic
val oghoare_interfree_tac = fn: Proof.context -> int -> tactic
val oghoare_interfree_aux_tac = fn: Proof.context -> int -> tactic
### theory "Draft.OG_Tactics"
### 0.852s elapsed time, 2.572s cpu time, 0.117s GC time
Loading theory "Draft.OG_Syntax" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr")
Found termination order: "{}"
### theory "Word_Lib.Word_EqI"
### 1.661s elapsed time, 5.030s cpu time, 0.354s GC time
Loading theory "Word_Lib.Word_Lemmas" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32")
Found termination order: "{}"
val syntax_debug = false: bool
### theory "Draft.OG_Syntax"
### 0.508s elapsed time, 1.528s cpu time, 0.047s GC time
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### theory "Word_Lib.Bits_Int"
### 2.100s elapsed time, 5.923s cpu time, 0.398s GC time
Loading theory "Word_Lib.Rsplit" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32")
Loading theory "Word_Lib.Typedef_Morphisms" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.More_Word_Operations" via "Word_Lib.Reversed_Bit_Lists")
locale type_definition
  fixes Rep :: "'b => 'a"
    and Abs :: "'a => 'b"
    and A :: "'a set"
  assumes "type_definition Rep Abs A"
### theory "Word_Lib.Rsplit"
### 0.091s elapsed time, 0.277s cpu time, 0.000s GC time
locale td_ext
  fixes Rep :: "'a => 'b"
    and Abs :: "'b => 'a"
    and A :: "'b set"
    and norm :: "'b => 'b"
  assumes "td_ext Rep Abs A norm"
### theory "Word_Lib.Typedef_Morphisms"
### 0.252s elapsed time, 0.627s cpu time, 0.076s GC time
Loading theory "Word_Lib.Reversed_Bit_Lists" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32" via "Word_Lib.More_Word_Operations")
### theory "Word_Lib.Word_Lemmas"
### 1.363s elapsed time, 3.224s cpu time, 0.197s GC time
consts
  takefill :: "'a => nat => 'a list => 'a list"
consts
  bl_to_bin_aux :: "bool list => int => int"
consts
  bin_to_bl_aux :: "nat => int => bool list => bool list"
consts
  rbl_succ :: "bool list => bool list"
consts
  rbl_pred :: "bool list => bool list"
consts
  rbl_add :: "bool list => bool list => bool list"
consts
  rbl_mult :: "bool list => bool list => bool list"
locale Reversed_Bit_Lists.word_rotate
### theory "Word_Lib.Reversed_Bit_Lists"
### 1.371s elapsed time, 1.790s cpu time, 0.118s GC time
Loading theory "Word_Lib.Bitwise" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32")
Loading theory "Word_Lib.More_Word_Operations" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr" via "Word_Lib.Word_32")
### Ignoring duplicate rewrite rule:
### map ?f1 [] == []
### Ignoring duplicate rewrite rule:
### map ?f1 (?x21.1 # ?x22.1) == ?f1 ?x21.1 # map ?f1 ?x22.1
### Ignoring duplicate rewrite rule:
### map ?f1 [] == []
### Ignoring duplicate rewrite rule:
### map ?f1 (?x21.1 # ?x22.1) == ?f1 ?x21.1 # map ?f1 ?x22.1
### Ignoring duplicate rewrite rule:
### zip [] ?ys1 == []
### Ignoring duplicate rewrite rule:
### zip (?x1 # ?xs1) (?y1 # ?ys1) == (?x1, ?y1) # zip ?xs1 ?ys1
structure Word_Bitwise_Tac:
  sig
    val expand_upt_simproc: simproc
    val expand_word_eq_sss: simpset * simpset list
    val mk_nat_clist: cterm list -> cterm
    val nat_get_Suc_simproc: int -> term list -> simproc
    val nat_get_Suc_simproc_fn: int -> Proof.context -> cterm -> thm option
    val no_split_ss: simpset
    val tac: Proof.context -> int -> tactic
    val upt_conv: Proof.context -> cterm -> thm option
    val word_len_simproc: simproc
    val word_len_simproc_fn: Proof.context -> cterm -> thm option
    val word_ss: simpset
  end
### theory "Word_Lib.Bitwise"
### 0.222s elapsed time, 0.476s cpu time, 0.065s GC time
### theory "Word_Lib.More_Word_Operations"
### 0.567s elapsed time, 0.814s cpu time, 0.065s GC time
Loading theory "Word_Lib.Word_32" (required by "Draft.SumArrMoreTemplates" via "Draft.SumArr")
### theory "Word_Lib.Word_32"
### 0.626s elapsed time, 0.668s cpu time, 0.058s GC time
Loading theory "Draft.SumArr" (required by "Draft.SumArrMoreTemplates")
### Ambiguous input (line 135 of "$AFP/Complx/ex/SumArr.thy") produces 12 parse trees (10 displayed):
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnAssign"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                 ("_position" i))))
###           ("_position" tsum)
###           ("_Update" ("_antiquote" ("_position" tsum))
###             ("_updbind" ("_position" i)
###               ("\<^const>Groups.zero_class.zero"))))
###         ("_AnnAssign"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("\<^const>Groups.zero_class.zero"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i)))))
###           ("_position" ti)
###           ("_Update" ("_antiquote" ("_position" ti))
###             ("_updbind" ("_position" i)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("_Try_Catch"
###         ("_AnnWhile"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("\<^const>Groups.zero_class.zero"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))))
###           ("\<^const>Orderings.ord_class.less"
###             ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###             ("_position" NSUM))
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>Orderings.ord_class.less_eq"
###                   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###                   ("_position" NSUM))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>Orderings.ord_class.less_eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_position" MAXSUM))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_position" take)
###                           ("_cargs"
###                             ("_applC" ("_position" unat)
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))))))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i)))))))
###           ("_AnnSeq"
###             ("_AnnSeq"
###               ("_guards"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i)))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i))))))
###                           ("_applC"
###                             ("_antiquote"
###                               ("_position" sumarr_inv_till_lock))
###                             ("_position" i)))))))
###                 ("_last_grd"
###                   ("_grd" ("_position" InvalidMem)
###                     ("_Assert"
###                       ("_applC" ("_position" array_in_bound)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i)))))))
###                 ("_AnnAssign"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_position" tsum)
###                   ("_Update" ("_antiquote" ("_position" tsum))
###                     ("_updbind" ("_position" i)
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_applC" ("_position" array_nth)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))))
###               ("_guards"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" unat)
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i)))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i)))))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.implies"
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_position" array_nth)
###                                   ("_cargs"
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_position" MAXSUM)))
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.disj"
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM)))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i))))))))
###                 ("_last_grd"
###                   ("_grd" ("_position" InvalidMem)
###                     ("_Assert"
###                       ("_applC" ("_position" array_in_bound)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i)))))))
###                 ("_AnnCond1"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.implies"
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_position" array_nth)
###                                   ("_cargs"
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_position" MAXSUM)))
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.disj"
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM)))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("\<^const>HOL.disj"
###                     ("\<^const>Orderings.ord_class.greater_eq"
###                       ("_applC" ("_position" array_nth)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))))
###                       ("_position" MAXSUM))
###                     ("\<^const>Orderings.ord_class.greater_eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_position" MAXSUM)))
###                   ("_AnnSeq"
###                     ("_AnnAssign"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i))))))
###                       ("_position" tsum)
###                       ("_Update" ("_antiquote" ("_position" tsum))
###                         ("_updbind" ("_position" i) ("_position" MAXSUM))))
###                     ("_AnnThrow"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))))
###                   ("_AnnSkip"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))))))
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("_position" NSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" Suc)
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))))))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_position" ti)
###               ("_Update" ("_antiquote" ("_position" ti))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.plus_class.plus"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("\<^const>Groups.one_class.one")))))))
###         ("_AnnSkip"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i))))))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###               ("_position" i)))))
###       ("_AnnSeq"
###         ("_applC"
###           ("_tuple" ("_String" ("_position" ''lock''))
###             ("_tuple_arg" ("_position" i)))
###           ("\<^const>Groups.zero_class.zero"))
###         ("_AnnAssign"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                     ("\<^const>Groups.one_class.one"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" ghost_lock))
###                       ("_position" i))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i)))))))
###           ("_position" gsum)
###           ("\<^const>Groups.plus_class.plus"
###             ("_antiquote" ("_position" gsum))
###             ("_antiquote" ("_position" tsum)))))
###       ("_AnnSeq"
###         ("_AnnSeq" ("_position" i)
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                       ("\<^const>Groups.one_class.one"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" ghost_lock))
###                         ("_position" i))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                         ("_position" i)))))))
###             ("_position" gdone)
###             ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###               ("_antiquote" ("_position" gdone))
###               ("_applC" ("_antiquote" ("_position" tid)) ("_position" i)))))
###         ("_AnnSCall"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                     ("\<^const>Groups.one_class.one"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" ghost_lock))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" bit)
###                         ("_cargs" ("_antiquote" ("_position" gdone))
###                           ("_applC" ("_position" unat)
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_applC" ("_antiquote" ("_position" tid))
###                                 ("_position" i))
###                               ("\<^const>Groups.one_class.one")))))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                         ("_position" i))))))))
###           ("_tuple" ("_String" ("_position" ''unlock''))
###             ("_tuple_arg" ("_position" i)))
###           ("\<^const>Groups.zero_class.zero"))))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i))))
###             ("_position" tsum)
###             ("_Update" ("_antiquote" ("_position" tsum))
###               ("_updbind" ("_position" i)
###                 ("\<^const>Groups.zero_class.zero"))))
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("\<^const>Groups.zero_class.zero"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i)))))
###             ("_position" ti)
###             ("_Update" ("_antiquote" ("_position" ti))
###               ("_updbind" ("_position" i)
###                 ("\<^const>Groups.zero_class.zero")))))
###         ("_Try_Catch"
###           ("_AnnWhile"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("\<^const>Groups.zero_class.zero"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i))))))
###             ("\<^const>Orderings.ord_class.less"
###               ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###               ("_position" NSUM))
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>Orderings.ord_class.less_eq"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("_position" NSUM))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less_eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_position" MAXSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_applC" ("_position" local_sum)
###                           ("_applC" ("_position" take)
###                             ("_cargs"
###                               ("_applC" ("_position" unat)
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i)))
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))))))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i)))))))
###             ("_AnnSeq"
###               ("_AnnSeq"
###                 ("_guards"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_last_grd"
###                     ("_grd" ("_position" InvalidMem)
###                       ("_Assert"
###                         ("_applC" ("_position" array_in_bound)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))
###                   ("_AnnAssign"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("_position" tsum)
###                     ("_Update" ("_antiquote" ("_position" tsum))
###                       ("_updbind" ("_position" i)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" array_nth)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))))
###                 ("_guards"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i)))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.disj"
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM)))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i))))))))
###                   ("_last_grd"
###                     ("_grd" ("_position" InvalidMem)
###                       ("_Assert"
###                         ("_applC" ("_position" array_in_bound)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))
###                   ("_AnnCond1"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.disj"
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM)))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("\<^const>HOL.disj"
###                       ("\<^const>Orderings.ord_class.greater_eq"
###                         ("_applC" ("_position" array_nth)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))))
###                         ("_position" MAXSUM))
###                       ("\<^const>Orderings.ord_class.greater_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM)))
###                     ("_AnnSeq"
###                       ("_AnnAssign"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i))))))
###                         ("_position" tsum)
###                         ("_Update" ("_antiquote" ("_position" tsum))
###                           ("_updbind" ("_position" i)
###                             ("_position" MAXSUM))))
###                       ("_AnnThrow"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i)))))))))
###                     ("_AnnSkip"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))))))
###               ("_AnnAssign"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Suc)
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i))))))
###                           ("_applC"
###                             ("_antiquote"
###                               ("_position" sumarr_inv_till_lock))
###                             ("_position" i)))))))
###                 ("_position" ti)
###                 ("_Update" ("_antiquote" ("_position" ti))
###                   ("_updbind" ("_position" i)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("\<^const>Groups.one_class.one")))))))
###           ("_AnnSkip"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))))))
###       ("_AnnSCall"
###         ("_Assert"
###           ("\<^const>HOL.conj"
###             ("_applC" ("_antiquote" ("_position" sumarr_inv))
###               ("_position" i))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("_applC" ("_position" local_sum)
###                   ("_applC" ("_antiquote" ("_position" tarr))
###                     ("_position" i))))
###               ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                 ("_position" i)))))
###         ("_AnnSeq"
###           ("_applC"
###             ("_tuple" ("_String" ("_position" ''lock''))
###               ("_tuple_arg" ("_position" i)))
###             ("\<^const>Groups.zero_class.zero"))
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                       ("\<^const>Groups.one_class.one"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" ghost_lock))
###                         ("_position" i))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i)))))))
###             ("_position" gsum)
###             ("\<^const>Groups.plus_class.plus"
###               ("_antiquote" ("_position" gsum))
###               ("_antiquote" ("_position" tsum)))))
###         ("_AnnSeq" ("_position" i)
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                       ("\<^const>Groups.one_class.one"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" ghost_lock))
###                         ("_position" i))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                         ("_position" i)))))))
###             ("_position" gdone)
###             ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###               ("_antiquote" ("_position" gdone))
###               ("_applC" ("_antiquote" ("_position" tid))
###                 ("_position" i)))))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                 ("\<^const>Groups.one_class.one"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" ghost_lock))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" bit)
###                     ("_cargs" ("_antiquote" ("_position" gdone))
###                       ("_applC" ("_position" unat)
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_antiquote" ("_position" tid))
###                             ("_position" i))
###                           ("\<^const>Groups.one_class.one")))))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                     ("_position" i))))))))
###       ("_tuple" ("_String" ("_position" ''unlock''))
###         ("_tuple_arg" ("_position" i)))
###       ("\<^const>Groups.zero_class.zero"))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_AnnSeq"
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))
###               ("_position" tsum)
###               ("_Update" ("_antiquote" ("_position" tsum))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.zero_class.zero"))))
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i)))))
###               ("_position" ti)
###               ("_Update" ("_antiquote" ("_position" ti))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.zero_class.zero")))))
###           ("_Try_Catch"
###             ("_AnnWhile"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("\<^const>Groups.zero_class.zero"))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i))))))
###               ("\<^const>Orderings.ord_class.less"
###                 ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###                 ("_position" NSUM))
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less_eq"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("_position" NSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" unat)
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i)))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))))))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_AnnSeq"
###                 ("_AnnSeq"
###                   ("_guards"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("_last_grd"
###                       ("_grd" ("_position" InvalidMem)
###                         ("_Assert"
###                           ("_applC" ("_position" array_in_bound)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))
###                     ("_AnnAssign"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))
###                       ("_position" tsum)
###                       ("_Update" ("_antiquote" ("_position" tsum))
###                         ("_updbind" ("_position" i)
###                           ("\<^const>Groups.plus_class.plus"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" array_nth)
###                               ("_cargs"
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i)))))))))
###                   ("_guards"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.implies"
###                                   ("\<^const>HOL.disj"
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_position" array_nth)
###   ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_position" MAXSUM))
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM)))
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM)))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i))))))))
###                     ("_last_grd"
###                       ("_grd" ("_position" InvalidMem)
###                         ("_Assert"
###                           ("_applC" ("_position" array_in_bound)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))
###                     ("_AnnCond1"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.implies"
###                                   ("\<^const>HOL.disj"
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_position" array_nth)
###   ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_position" MAXSUM))
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM)))
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM)))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))
###                       ("\<^const>HOL.disj"
###                         ("\<^const>Orderings.ord_class.greater_eq"
###                           ("_applC" ("_position" array_nth)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))))
###                           ("_position" MAXSUM))
###                         ("\<^const>Orderings.ord_class.greater_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM)))
###                       ("_AnnSeq"
###                         ("_AnnAssign"
###                           ("_Assert"
###                             ("\<^const>HOL.conj"
###                               ("_applC"
###                                 ("_antiquote" ("_position" sumarr_inv))
###                                 ("_position" i))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i))
###                                   ("_position" NSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i))))))
###                           ("_position" tsum)
###                           ("_Update" ("_antiquote" ("_position" tsum))
###                             ("_updbind" ("_position" i)
###                               ("_position" MAXSUM))))
###                         ("_AnnThrow"
###                           ("_Assert"
###                             ("\<^const>HOL.conj"
###                               ("_applC"
###                                 ("_antiquote" ("_position" sumarr_inv))
###                                 ("_position" i))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i))
###                                   ("_position" NSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>HOL.conj"
###                                     ("\<^const>HOL.eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_applC" ("_position" local_sum)
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" sumarr_inv_till_lock)) ("_position" i)))))))))
###                       ("_AnnSkip"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_position" take)
###   ("_cargs"
###     ("_applC" ("_position" Suc)
###       ("_applC" ("_position" unat)
###         ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###     ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i)))))))))))
###                 ("_AnnAssign"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_position" ti)
###                   ("_Update" ("_antiquote" ("_position" ti))
###                     ("_updbind" ("_position" i)
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("\<^const>Groups.one_class.one")))))))
###             ("_AnnSkip"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_antiquote" ("_position" tarr))
###                           ("_position" i))))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i))))))))
###         ("_AnnSCall"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i)))))
###           ("_AnnSeq"
###             ("_applC"
###               ("_tuple" ("_String" ("_position" ''lock''))
###                 ("_tuple_arg" ("_position" i)))
###               ("\<^const>Groups.zero_class.zero"))
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_antiquote" ("_position" tarr))
###                           ("_position" i))))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                         ("\<^const>Groups.one_class.one"))
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" ghost_lock))
###                           ("_position" i))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_position" gsum)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_antiquote" ("_position" gsum))
###                 ("_antiquote" ("_position" tsum)))))
###           ("_position" i)))
###       ("_AnnAssign"
###         ("_Assert"
###           ("\<^const>HOL.conj"
###             ("_applC" ("_antiquote" ("_position" sumarr_inv))
###               ("_position" i))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("_applC" ("_position" local_sum)
###                   ("_applC" ("_antiquote" ("_position" tarr))
###                     ("_position" i))))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                   ("\<^const>Groups.one_class.one"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" ghost_lock))
###                     ("_position" i))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                     ("_position" i)))))))
###         ("_position" gdone)
###         ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###           ("_antiquote" ("_position" gdone))
###           ("_applC" ("_antiquote" ("_position" tid)) ("_position" i)))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                 ("\<^const>Groups.one_class.one"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" ghost_lock))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" bit)
###                     ("_cargs" ("_antiquote" ("_position" gdone))
###                       ("_applC" ("_position" unat)
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_antiquote" ("_position" tid))
###                             ("_position" i))
###                           ("\<^const>Groups.one_class.one")))))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                     ("_position" i))))))))
###       ("_tuple" ("_String" ("_position" ''unlock''))
###         ("_tuple_arg" ("_position" i)))
###       ("\<^const>Groups.zero_class.zero"))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnAssign"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                 ("_position" i))))
###           ("_position" tsum)
###           ("_Update" ("_antiquote" ("_position" tsum))
###             ("_updbind" ("_position" i)
###               ("\<^const>Groups.zero_class.zero"))))
###         ("_AnnAssign"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("\<^const>Groups.zero_class.zero"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i)))))
###           ("_position" ti)
###           ("_Update" ("_antiquote" ("_position" ti))
###             ("_updbind" ("_position" i)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("_Try_Catch"
###         ("_AnnWhile"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("\<^const>Groups.zero_class.zero"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))))
###           ("\<^const>Orderings.ord_class.less"
###             ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###             ("_position" NSUM))
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>Orderings.ord_class.less_eq"
###                   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###                   ("_position" NSUM))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>Orderings.ord_class.less_eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_position" MAXSUM))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_position" take)
###                           ("_cargs"
###                             ("_applC" ("_position" unat)
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))))))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i)))))))
###           ("_AnnSeq"
###             ("_AnnSeq"
###               ("_guards"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i)))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i))))))
###                           ("_applC"
###                             ("_antiquote"
###                               ("_position" sumarr_inv_till_lock))
###                             ("_position" i)))))))
###                 ("_last_grd"
###                   ("_grd" ("_position" InvalidMem)
###                     ("_Assert"
###                       ("_applC" ("_position" array_in_bound)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i)))))))
###                 ("_AnnAssign"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_position" tsum)
###                   ("_Update" ("_antiquote" ("_position" tsum))
###                     ("_updbind" ("_position" i)
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_applC" ("_position" array_nth)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))))
###               ("_guards"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" unat)
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i)))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i)))))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.implies"
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_position" array_nth)
###                                   ("_cargs"
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_position" MAXSUM)))
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.disj"
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM)))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i))))))))
###                 ("_last_grd"
###                   ("_grd" ("_position" InvalidMem)
###                     ("_Assert"
###                       ("_applC" ("_position" array_in_bound)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i)))))))
###                 ("_AnnCond1"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.implies"
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_position" array_nth)
###                                   ("_cargs"
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_position" MAXSUM)))
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.disj"
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM)))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("\<^const>HOL.disj"
###                     ("\<^const>Orderings.ord_class.greater_eq"
###                       ("_applC" ("_position" array_nth)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))))
###                       ("_position" MAXSUM))
###                     ("\<^const>Orderings.ord_class.greater_eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_position" MAXSUM)))
###                   ("_AnnSeq"
###                     ("_AnnAssign"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i))))))
###                       ("_position" tsum)
###                       ("_Update" ("_antiquote" ("_position" tsum))
###                         ("_updbind" ("_position" i) ("_position" MAXSUM))))
###                     ("_AnnThrow"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))))
###                   ("_AnnSkip"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))))))
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("_position" NSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" Suc)
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))))))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_position" ti)
###               ("_Update" ("_antiquote" ("_position" ti))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.plus_class.plus"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("\<^const>Groups.one_class.one")))))))
###         ("_AnnSkip"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i))))))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###               ("_position" i)))))
###       ("_tuple" ("_String" ("_position" ''lock''))
###         ("_tuple_arg" ("_position" i)))
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_AnnSeq" ("\<^const>Groups.zero_class.zero")
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_antiquote" ("_position" tarr))
###                           ("_position" i))))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                         ("\<^const>Groups.one_class.one"))
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" ghost_lock))
###                           ("_position" i))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_position" gsum)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_antiquote" ("_position" gsum))
###                 ("_applC" ("_antiquote" ("_position" tsum))
###                   ("_position" i)))))
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                       ("\<^const>Groups.one_class.one"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" ghost_lock))
###                         ("_position" i))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                         ("_position" i)))))))
###             ("_position" gdone)
###             ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###               ("_antiquote" ("_position" gdone))
###               ("_applC" ("_antiquote" ("_position" tid)) ("_position" i)))))
###         ("_AnnSCall"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                     ("\<^const>Groups.one_class.one"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" ghost_lock))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" bit)
###                         ("_cargs" ("_antiquote" ("_position" gdone))
###                           ("_applC" ("_position" unat)
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_applC" ("_antiquote" ("_position" tid))
###                                 ("_position" i))
###                               ("\<^const>Groups.one_class.one")))))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                         ("_position" i))))))))
###           ("_tuple" ("_String" ("_position" ''unlock''))
###             ("_tuple_arg" ("_position" i)))
###           ("\<^const>Groups.zero_class.zero"))))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i))))
###             ("_position" tsum)
###             ("_Update" ("_antiquote" ("_position" tsum))
###               ("_updbind" ("_position" i)
###                 ("\<^const>Groups.zero_class.zero"))))
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("\<^const>Groups.zero_class.zero"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i)))))
###             ("_position" ti)
###             ("_Update" ("_antiquote" ("_position" ti))
###               ("_updbind" ("_position" i)
###                 ("\<^const>Groups.zero_class.zero")))))
###         ("_Try_Catch"
###           ("_AnnWhile"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("\<^const>Groups.zero_class.zero"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i))))))
###             ("\<^const>Orderings.ord_class.less"
###               ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###               ("_position" NSUM))
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>Orderings.ord_class.less_eq"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("_position" NSUM))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less_eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_position" MAXSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_applC" ("_position" local_sum)
###                           ("_applC" ("_position" take)
###                             ("_cargs"
###                               ("_applC" ("_position" unat)
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i)))
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))))))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i)))))))
###             ("_AnnSeq"
###               ("_AnnSeq"
###                 ("_guards"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_last_grd"
###                     ("_grd" ("_position" InvalidMem)
###                       ("_Assert"
###                         ("_applC" ("_position" array_in_bound)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))
###                   ("_AnnAssign"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("_position" tsum)
###                     ("_Update" ("_antiquote" ("_position" tsum))
###                       ("_updbind" ("_position" i)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" array_nth)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))))
###                 ("_guards"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i)))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.disj"
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM)))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i))))))))
###                   ("_last_grd"
###                     ("_grd" ("_position" InvalidMem)
###                       ("_Assert"
###                         ("_applC" ("_position" array_in_bound)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))
###                   ("_AnnCond1"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.disj"
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM)))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("\<^const>HOL.disj"
###                       ("\<^const>Orderings.ord_class.greater_eq"
###                         ("_applC" ("_position" array_nth)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))))
###                         ("_position" MAXSUM))
###                       ("\<^const>Orderings.ord_class.greater_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM)))
###                     ("_AnnSeq"
###                       ("_AnnAssign"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i))))))
###                         ("_position" tsum)
###                         ("_Update" ("_antiquote" ("_position" tsum))
###                           ("_updbind" ("_position" i)
###                             ("_position" MAXSUM))))
###                       ("_AnnThrow"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i)))))))))
###                     ("_AnnSkip"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))))))
###               ("_AnnAssign"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Suc)
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i))))))
###                           ("_applC"
###                             ("_antiquote"
###                               ("_position" sumarr_inv_till_lock))
###                             ("_position" i)))))))
###                 ("_position" ti)
###                 ("_Update" ("_antiquote" ("_position" ti))
###                   ("_updbind" ("_position" i)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("\<^const>Groups.one_class.one")))))))
###           ("_AnnSkip"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))))))
###       ("_AnnSCall"
###         ("_Assert"
###           ("\<^const>HOL.conj"
###             ("_applC" ("_antiquote" ("_position" sumarr_inv))
###               ("_position" i))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("_applC" ("_position" local_sum)
###                   ("_applC" ("_antiquote" ("_position" tarr))
###                     ("_position" i))))
###               ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                 ("_position" i)))))
###         ("_tuple" ("_String" ("_position" ''lock''))
###           ("_tuple_arg" ("_position" i)))
###         ("_AnnSeq"
###           ("_AnnSeq" ("\<^const>Groups.zero_class.zero")
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_antiquote" ("_position" tarr))
###                           ("_position" i))))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                         ("\<^const>Groups.one_class.one"))
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" ghost_lock))
###                           ("_position" i))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_position" gsum)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_antiquote" ("_position" gsum))
###                 ("_applC" ("_antiquote" ("_position" tsum))
###                   ("_position" i)))))
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                       ("\<^const>Groups.one_class.one"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" ghost_lock))
###                         ("_position" i))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                         ("_position" i)))))))
###             ("_position" gdone)
###             ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###               ("_antiquote" ("_position" gdone))
###               ("_applC" ("_antiquote" ("_position" tid))
###                 ("_position" i)))))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                 ("\<^const>Groups.one_class.one"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" ghost_lock))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" bit)
###                     ("_cargs" ("_antiquote" ("_position" gdone))
###                       ("_applC" ("_position" unat)
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_antiquote" ("_position" tid))
###                             ("_position" i))
###                           ("\<^const>Groups.one_class.one")))))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                     ("_position" i))))))))
###       ("_tuple" ("_String" ("_position" ''unlock''))
###         ("_tuple_arg" ("_position" i)))
###       ("\<^const>Groups.zero_class.zero"))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_AnnSeq"
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))
###               ("_position" tsum)
###               ("_Update" ("_antiquote" ("_position" tsum))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.zero_class.zero"))))
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i)))))
###               ("_position" ti)
###               ("_Update" ("_antiquote" ("_position" ti))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.zero_class.zero")))))
###           ("_Try_Catch"
###             ("_AnnWhile"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("\<^const>Groups.zero_class.zero"))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i))))))
###               ("\<^const>Orderings.ord_class.less"
###                 ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###                 ("_position" NSUM))
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less_eq"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("_position" NSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" unat)
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i)))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))))))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_AnnSeq"
###                 ("_AnnSeq"
###                   ("_guards"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("_last_grd"
###                       ("_grd" ("_position" InvalidMem)
###                         ("_Assert"
###                           ("_applC" ("_position" array_in_bound)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))
###                     ("_AnnAssign"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))
###                       ("_position" tsum)
###                       ("_Update" ("_antiquote" ("_position" tsum))
###                         ("_updbind" ("_position" i)
###                           ("\<^const>Groups.plus_class.plus"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" array_nth)
###                               ("_cargs"
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i)))))))))
###                   ("_guards"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.implies"
###                                   ("\<^const>HOL.disj"
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_position" array_nth)
###   ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_position" MAXSUM))
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM)))
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM)))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i))))))))
###                     ("_last_grd"
###                       ("_grd" ("_position" InvalidMem)
###                         ("_Assert"
###                           ("_applC" ("_position" array_in_bound)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))
###                     ("_AnnCond1"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.implies"
###                                   ("\<^const>HOL.disj"
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_position" array_nth)
###   ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_position" MAXSUM))
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM)))
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM)))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))
###                       ("\<^const>HOL.disj"
###                         ("\<^const>Orderings.ord_class.greater_eq"
###                           ("_applC" ("_position" array_nth)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))))
###                           ("_position" MAXSUM))
###                         ("\<^const>Orderings.ord_class.greater_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM)))
###                       ("_AnnSeq"
###                         ("_AnnAssign"
###                           ("_Assert"
###                             ("\<^const>HOL.conj"
###                               ("_applC"
###                                 ("_antiquote" ("_position" sumarr_inv))
###                                 ("_position" i))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i))
###                                   ("_position" NSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i))))))
###                           ("_position" tsum)
###                           ("_Update" ("_antiquote" ("_position" tsum))
###                             ("_updbind" ("_position" i)
###                               ("_position" MAXSUM))))
###                         ("_AnnThrow"
###                           ("_Assert"
###                             ("\<^const>HOL.conj"
###                               ("_applC"
###                                 ("_antiquote" ("_position" sumarr_inv))
###                                 ("_position" i))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i))
###                                   ("_position" NSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>HOL.conj"
###                                     ("\<^const>HOL.eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_applC" ("_position" local_sum)
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" sumarr_inv_till_lock)) ("_position" i)))))))))
###                       ("_AnnSkip"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_position" take)
###   ("_cargs"
###     ("_applC" ("_position" Suc)
###       ("_applC" ("_position" unat)
###         ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###     ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i)))))))))))
###                 ("_AnnAssign"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_position" ti)
###                   ("_Update" ("_antiquote" ("_position" ti))
###                     ("_updbind" ("_position" i)
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("\<^const>Groups.one_class.one")))))))
###             ("_AnnSkip"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_antiquote" ("_position" tarr))
###                           ("_position" i))))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i))))))))
###         ("_AnnSCall"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i)))))
###           ("_tuple" ("_String" ("_position" ''lock''))
###             ("_tuple_arg" ("_position" i)))
###           ("_AnnSeq" ("\<^const>Groups.zero_class.zero")
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_antiquote" ("_position" tarr))
###                           ("_position" i))))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                         ("\<^const>Groups.one_class.one"))
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" ghost_lock))
###                           ("_position" i))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_position" gsum)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_antiquote" ("_position" gsum))
###                 ("_applC" ("_antiquote" ("_position" tsum))
###                   ("_position" i)))))))
###       ("_AnnAssign"
###         ("_Assert"
###           ("\<^const>HOL.conj"
###             ("_applC" ("_antiquote" ("_position" sumarr_inv))
###               ("_position" i))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("_applC" ("_position" local_sum)
###                   ("_applC" ("_antiquote" ("_position" tarr))
###                     ("_position" i))))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                   ("\<^const>Groups.one_class.one"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" ghost_lock))
###                     ("_position" i))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                     ("_position" i)))))))
###         ("_position" gdone)
###         ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###           ("_antiquote" ("_position" gdone))
###           ("_applC" ("_antiquote" ("_position" tid)) ("_position" i)))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                 ("\<^const>Groups.one_class.one"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" ghost_lock))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" bit)
###                     ("_cargs" ("_antiquote" ("_position" gdone))
###                       ("_applC" ("_position" unat)
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_antiquote" ("_position" tid))
###                             ("_position" i))
###                           ("\<^const>Groups.one_class.one")))))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                     ("_position" i))))))))
###       ("_tuple" ("_String" ("_position" ''unlock''))
###         ("_tuple_arg" ("_position" i)))
###       ("\<^const>Groups.zero_class.zero"))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_AnnSeq"
###             ("_AnnSeq"
###               ("_AnnAssign"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i))))
###                 ("_position" tsum)
###                 ("_Update" ("_antiquote" ("_position" tsum))
###                   ("_updbind" ("_position" i)
###                     ("\<^const>Groups.zero_class.zero"))))
###               ("_AnnAssign"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i)))))
###                 ("_position" ti)
###                 ("_Update" ("_antiquote" ("_position" ti))
###                   ("_updbind" ("_position" i)
###                     ("\<^const>Groups.zero_class.zero")))))
###             ("_Try_Catch"
###               ("_AnnWhile"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("\<^const>Groups.zero_class.zero"))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i))))))
###                 ("\<^const>Orderings.ord_class.less"
###                   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###                   ("_position" NSUM))
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less_eq"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i)))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i))))))
###                           ("_applC"
###                             ("_antiquote"
###                               ("_position" sumarr_inv_till_lock))
###                             ("_position" i)))))))
###                 ("_AnnSeq"
###                   ("_AnnSeq"
###                     ("_guards"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))
###                       ("_last_grd"
###                         ("_grd" ("_position" InvalidMem)
###                           ("_Assert"
###                             ("_applC" ("_position" array_in_bound)
###                               ("_cargs"
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i)))))))
###                       ("_AnnAssign"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_position" take)
###   ("_cargs"
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###     ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i)))))))
###                         ("_position" tsum)
###                         ("_Update" ("_antiquote" ("_position" tsum))
###                           ("_updbind" ("_position" i)
###                             ("\<^const>Groups.plus_class.plus"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" array_nth)
###                                 ("_cargs"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i))
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i)))))))))
###                     ("_guards"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.implies"
###                                   ("\<^const>HOL.conj"
###                                     ("\<^const>Orderings.ord_class.less"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM))
###                                     ("\<^const>Orderings.ord_class.less"
### ("_applC" ("_position" array_nth)
###   ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_position" MAXSUM)))
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_position" take)
###   ("_cargs"
###     ("_applC" ("_position" Suc)
###       ("_applC" ("_position" unat)
###         ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###     ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.implies"
###                                     ("\<^const>HOL.disj"
### ("\<^const>Orderings.ord_class.greater_eq"
###   ("_applC" ("_position" array_nth)
###     ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_position" MAXSUM))
### ("\<^const>Orderings.ord_class.greater_eq"
###   ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###   ("_position" MAXSUM)))
###                                     ("\<^const>HOL.eq"
### ("_applC" ("_position" local_sum)
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
### ("_position" MAXSUM)))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i))))))))
###                       ("_last_grd"
###                         ("_grd" ("_position" InvalidMem)
###                           ("_Assert"
###                             ("_applC" ("_position" array_in_bound)
###                               ("_cargs"
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i)))))))
###                       ("_AnnCond1"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.implies"
###                                   ("\<^const>HOL.conj"
###                                     ("\<^const>Orderings.ord_class.less"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM))
###                                     ("\<^const>Orderings.ord_class.less"
### ("_applC" ("_position" array_nth)
###   ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_position" MAXSUM)))
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_position" take)
###   ("_cargs"
###     ("_applC" ("_position" Suc)
###       ("_applC" ("_position" unat)
###         ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###     ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.implies"
###                                     ("\<^const>HOL.disj"
### ("\<^const>Orderings.ord_class.greater_eq"
###   ("_applC" ("_position" array_nth)
###     ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_position" MAXSUM))
### ("\<^const>Orderings.ord_class.greater_eq"
###   ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###   ("_position" MAXSUM)))
###                                     ("\<^const>HOL.eq"
### ("_applC" ("_position" local_sum)
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
### ("_position" MAXSUM)))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i)))))))
###                         ("\<^const>HOL.disj"
###                           ("\<^const>Orderings.ord_class.greater_eq"
###                             ("_applC" ("_position" array_nth)
###                               ("_cargs"
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))))
###                             ("_position" MAXSUM))
###                           ("\<^const>Orderings.ord_class.greater_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM)))
###                         ("_AnnSeq"
###                           ("_AnnAssign"
###                             ("_Assert"
###                               ("\<^const>HOL.conj"
###                                 ("_applC"
###                                   ("_antiquote" ("_position" sumarr_inv))
###                                   ("_position" i))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))
###                                     ("_position" NSUM))
###                                   ("\<^const>HOL.conj"
###                                     ("\<^const>HOL.eq"
### ("_applC" ("_position" local_sum)
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
### ("_position" MAXSUM))
###                                     ("_applC"
### ("_antiquote" ("_position" sumarr_inv_till_lock)) ("_position" i))))))
###                             ("_position" tsum)
###                             ("_Update" ("_antiquote" ("_position" tsum))
###                               ("_updbind" ("_position" i)
###                                 ("_position" MAXSUM))))
###                           ("_AnnThrow"
###                             ("_Assert"
###                               ("\<^const>HOL.conj"
###                                 ("_applC"
###                                   ("_antiquote" ("_position" sumarr_inv))
###                                   ("_position" i))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))
###                                     ("_position" NSUM))
###                                   ("\<^const>HOL.conj"
###                                     ("\<^const>Orderings.ord_class.less_eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM))
###                                     ("\<^const>HOL.conj"
### ("\<^const>HOL.eq"
###   ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###   ("_applC" ("_position" local_sum)
###     ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###   ("_position" i)))))))))
###                         ("_AnnSkip"
###                           ("_Assert"
###                             ("\<^const>HOL.conj"
###                               ("_applC"
###                                 ("_antiquote" ("_position" sumarr_inv))
###                                 ("_position" i))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i))
###                                   ("_position" NSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>HOL.conj"
###                                     ("\<^const>HOL.eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_applC" ("_position" local_sum)
###   ("_applC" ("_position" take)
###     ("_cargs"
###       ("_applC" ("_position" Suc)
###         ("_applC" ("_position" unat)
###           ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###       ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                     ("_applC"
### ("_antiquote" ("_position" sumarr_inv_till_lock)) ("_position" i)))))))))))
###                   ("_AnnAssign"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("_position" ti)
###                     ("_Update" ("_antiquote" ("_position" ti))
###                       ("_updbind" ("_position" i)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("\<^const>Groups.one_class.one")))))))
###               ("_AnnSkip"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_applC" ("_position" local_sum)
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i))))))))
###           ("_AnnSCall"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i)))))
###             ("_tuple" ("_String" ("_position" ''lock''))
###               ("_tuple_arg" ("_position" i)))
###             ("\<^const>Groups.zero_class.zero")))
###         ("_AnnAssign"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                     ("\<^const>Groups.one_class.one"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" ghost_lock))
###                       ("_position" i))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i)))))))
###           ("_position" gsum)
###           ("\<^const>Groups.plus_class.plus"
###             ("_antiquote" ("_position" gsum))
###             ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i)))))
###       ("_AnnAssign"
###         ("_Assert"
###           ("\<^const>HOL.conj"
###             ("_applC" ("_antiquote" ("_position" sumarr_inv))
###               ("_position" i))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("_applC" ("_position" local_sum)
###                   ("_applC" ("_antiquote" ("_position" tarr))
###                     ("_position" i))))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                   ("\<^const>Groups.one_class.one"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" ghost_lock))
###                     ("_position" i))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                     ("_position" i)))))))
###         ("_position" gdone)
###         ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###           ("_antiquote" ("_position" gdone))
###           ("_applC" ("_antiquote" ("_position" tid)) ("_position" i)))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                 ("\<^const>Groups.one_class.one"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" ghost_lock))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" bit)
###                     ("_cargs" ("_antiquote" ("_position" gdone))
###                       ("_applC" ("_position" unat)
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_antiquote" ("_position" tid))
###                             ("_position" i))
###                           ("\<^const>Groups.one_class.one")))))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                     ("_position" i))))))))
###       ("_tuple" ("_String" ("_position" ''unlock''))
###         ("_tuple_arg" ("_position" i)))
###       ("\<^const>Groups.zero_class.zero"))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnAssign"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                 ("_position" i))))
###           ("_position" tsum)
###           ("_Update" ("_antiquote" ("_position" tsum))
###             ("_updbind" ("_position" i)
###               ("\<^const>Groups.zero_class.zero"))))
###         ("_AnnAssign"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("\<^const>Groups.zero_class.zero"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i)))))
###           ("_position" ti)
###           ("_Update" ("_antiquote" ("_position" ti))
###             ("_updbind" ("_position" i)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("_Try_Catch"
###         ("_AnnWhile"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("\<^const>Groups.zero_class.zero"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))))
###           ("\<^const>Orderings.ord_class.less"
###             ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###             ("_position" NSUM))
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>Orderings.ord_class.less_eq"
###                   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###                   ("_position" NSUM))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>Orderings.ord_class.less_eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_position" MAXSUM))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_position" take)
###                           ("_cargs"
###                             ("_applC" ("_position" unat)
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))))))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i)))))))
###           ("_AnnSeq"
###             ("_AnnSeq"
###               ("_guards"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i)))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i))))))
###                           ("_applC"
###                             ("_antiquote"
###                               ("_position" sumarr_inv_till_lock))
###                             ("_position" i)))))))
###                 ("_last_grd"
###                   ("_grd" ("_position" InvalidMem)
###                     ("_Assert"
###                       ("_applC" ("_position" array_in_bound)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i)))))))
###                 ("_AnnAssign"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_position" tsum)
###                   ("_Update" ("_antiquote" ("_position" tsum))
###                     ("_updbind" ("_position" i)
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_applC" ("_position" array_nth)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))))
###               ("_guards"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" unat)
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i)))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i)))))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.implies"
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_position" array_nth)
###                                   ("_cargs"
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_position" MAXSUM)))
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.disj"
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM)))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i))))))))
###                 ("_last_grd"
###                   ("_grd" ("_position" InvalidMem)
###                     ("_Assert"
###                       ("_applC" ("_position" array_in_bound)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i)))))))
###                 ("_AnnCond1"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.implies"
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_position" array_nth)
###                                   ("_cargs"
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_position" MAXSUM)))
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.disj"
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.greater_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM)))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("\<^const>HOL.disj"
###                     ("\<^const>Orderings.ord_class.greater_eq"
###                       ("_applC" ("_position" array_nth)
###                         ("_cargs"
###                           ("_applC" ("_antiquote" ("_position" tarr))
###                             ("_position" i))
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))))
###                       ("_position" MAXSUM))
###                     ("\<^const>Orderings.ord_class.greater_eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_position" MAXSUM)))
###                   ("_AnnSeq"
###                     ("_AnnAssign"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))
###                                 ("_position" MAXSUM))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i))))))
###                       ("_position" tsum)
###                       ("_Update" ("_antiquote" ("_position" tsum))
###                         ("_updbind" ("_position" i) ("_position" MAXSUM))))
###                     ("_AnnThrow"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))))
###                   ("_AnnSkip"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))))))
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("_position" NSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" Suc)
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i))))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))))))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_position" ti)
###               ("_Update" ("_antiquote" ("_position" ti))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.plus_class.plus"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("\<^const>Groups.one_class.one")))))))
###         ("_AnnSkip"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i))))))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###               ("_position" i)))))
###       ("_AnnSeq"
###         ("_applC"
###           ("_tuple" ("_String" ("_position" ''lock''))
###             ("_tuple_arg" ("_position" i)))
###           ("\<^const>Groups.zero_class.zero"))
###         ("_Assert"
###           ("\<^const>HOL.conj"
###             ("_applC" ("_antiquote" ("_position" sumarr_inv))
###               ("_position" i))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("_applC" ("_position" local_sum)
###                   ("_applC" ("_antiquote" ("_position" tarr))
###                     ("_position" i))))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                   ("\<^const>Groups.one_class.one"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" ghost_lock))
###                     ("_position" i))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))))))
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_Assign" ("_position" gsum)
###             ("\<^const>Groups.plus_class.plus"
###               ("_antiquote" ("_position" gsum))
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))))
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                       ("\<^const>Groups.one_class.one"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" ghost_lock))
###                         ("_position" i))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                         ("_position" i)))))))
###             ("_position" gdone)
###             ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###               ("_antiquote" ("_position" gdone))
###               ("_applC" ("_antiquote" ("_position" tid)) ("_position" i)))))
###         ("_AnnSCall"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                     ("\<^const>Groups.one_class.one"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" ghost_lock))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" bit)
###                         ("_cargs" ("_antiquote" ("_position" gdone))
###                           ("_applC" ("_position" unat)
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_applC" ("_antiquote" ("_position" tid))
###                                 ("_position" i))
###                               ("\<^const>Groups.one_class.one")))))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                         ("_position" i))))))))
###           ("_tuple" ("_String" ("_position" ''unlock''))
###             ("_tuple_arg" ("_position" i)))
###           ("\<^const>Groups.zero_class.zero"))))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i))))
###             ("_position" tsum)
###             ("_Update" ("_antiquote" ("_position" tsum))
###               ("_updbind" ("_position" i)
###                 ("\<^const>Groups.zero_class.zero"))))
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("\<^const>Groups.zero_class.zero"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i)))))
###             ("_position" ti)
###             ("_Update" ("_antiquote" ("_position" ti))
###               ("_updbind" ("_position" i)
###                 ("\<^const>Groups.zero_class.zero")))))
###         ("_Try_Catch"
###           ("_AnnWhile"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("\<^const>Groups.zero_class.zero"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i))))))
###             ("\<^const>Orderings.ord_class.less"
###               ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###               ("_position" NSUM))
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>Orderings.ord_class.less_eq"
###                     ("_applC" ("_antiquote" ("_position" ti))
###                       ("_position" i))
###                     ("_position" NSUM))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less_eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_position" MAXSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_applC" ("_position" local_sum)
###                           ("_applC" ("_position" take)
###                             ("_cargs"
###                               ("_applC" ("_position" unat)
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i)))
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))))))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i)))))))
###             ("_AnnSeq"
###               ("_AnnSeq"
###                 ("_guards"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_last_grd"
###                     ("_grd" ("_position" InvalidMem)
###                       ("_Assert"
###                         ("_applC" ("_position" array_in_bound)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))
###                   ("_AnnAssign"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("_position" tsum)
###                     ("_Update" ("_antiquote" ("_position" tsum))
###                       ("_updbind" ("_position" i)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" array_nth)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))))
###                 ("_guards"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" unat)
###                                     ("_applC"
### ("_antiquote" ("_position" ti)) ("_position" i)))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i)))))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.disj"
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM)))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i))))))))
###                   ("_last_grd"
###                     ("_grd" ("_position" InvalidMem)
###                       ("_Assert"
###                         ("_applC" ("_position" array_in_bound)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i)))))))
###                   ("_AnnCond1"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.implies"
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_position" array_nth)
###                                     ("_cargs"
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_position" MAXSUM)))
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" Suc)
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.disj"
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.greater_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM)))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("\<^const>HOL.disj"
###                       ("\<^const>Orderings.ord_class.greater_eq"
###                         ("_applC" ("_position" array_nth)
###                           ("_cargs"
###                             ("_applC" ("_antiquote" ("_position" tarr))
###                               ("_position" i))
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))))
###                         ("_position" MAXSUM))
###                       ("\<^const>Orderings.ord_class.greater_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM)))
###                     ("_AnnSeq"
###                       ("_AnnAssign"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                   ("_position" MAXSUM))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i))))))
###                         ("_position" tsum)
###                         ("_Update" ("_antiquote" ("_position" tsum))
###                           ("_updbind" ("_position" i)
###                             ("_position" MAXSUM))))
###                       ("_AnnThrow"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i)))))))))
###                     ("_AnnSkip"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))))))
###               ("_AnnAssign"
###                 ("_Assert"
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("_position" NSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>HOL.eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" local_sum)
###                               ("_applC" ("_position" take)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Suc)
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tarr))
###                                     ("_position" i))))))
###                           ("_applC"
###                             ("_antiquote"
###                               ("_position" sumarr_inv_till_lock))
###                             ("_position" i)))))))
###                 ("_position" ti)
###                 ("_Update" ("_antiquote" ("_position" ti))
###                   ("_updbind" ("_position" i)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("\<^const>Groups.one_class.one")))))))
###           ("_AnnSkip"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))))))
###       ("_AnnSCall"
###         ("_Assert"
###           ("\<^const>HOL.conj"
###             ("_applC" ("_antiquote" ("_position" sumarr_inv))
###               ("_position" i))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("_applC" ("_position" local_sum)
###                   ("_applC" ("_antiquote" ("_position" tarr))
###                     ("_position" i))))
###               ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                 ("_position" i)))))
###         ("_AnnSeq"
###           ("_applC"
###             ("_tuple" ("_String" ("_position" ''lock''))
###               ("_tuple_arg" ("_position" i)))
###             ("\<^const>Groups.zero_class.zero"))
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                     ("\<^const>Groups.one_class.one"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" ghost_lock))
###                       ("_position" i))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i))))))))
###         ("_AnnSeq"
###           ("_Assign" ("_position" gsum)
###             ("\<^const>Groups.plus_class.plus"
###               ("_antiquote" ("_position" gsum))
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))))
###           ("_AnnAssign"
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                       ("\<^const>Groups.one_class.one"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" ghost_lock))
###                         ("_position" i))
###                       ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                         ("_position" i)))))))
###             ("_position" gdone)
###             ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###               ("_antiquote" ("_position" gdone))
###               ("_applC" ("_antiquote" ("_position" tid))
###                 ("_position" i)))))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                 ("\<^const>Groups.one_class.one"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" ghost_lock))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" bit)
###                     ("_cargs" ("_antiquote" ("_position" gdone))
###                       ("_applC" ("_position" unat)
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_antiquote" ("_position" tid))
###                             ("_position" i))
###                           ("\<^const>Groups.one_class.one")))))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                     ("_position" i))))))))
###       ("_tuple" ("_String" ("_position" ''unlock''))
###         ("_tuple_arg" ("_position" i)))
###       ("\<^const>Groups.zero_class.zero"))))
### ("\<^const>Pure.eq" ("_applC" ("_position" sumarr) ("_position" i))
###   ("_AnnSeq"
###     ("_AnnSeq"
###       ("_AnnSeq"
###         ("_AnnSeq"
###           ("_AnnSeq"
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("_applC"
###                     ("_antiquote" ("_position" sumarr_inv_till_lock))
###                     ("_position" i))))
###               ("_position" tsum)
###               ("_Update" ("_antiquote" ("_position" tsum))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.zero_class.zero"))))
###             ("_AnnAssign"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i)))))
###               ("_position" ti)
###               ("_Update" ("_antiquote" ("_position" ti))
###                 ("_updbind" ("_position" i)
###                   ("\<^const>Groups.zero_class.zero")))))
###           ("_Try_Catch"
###             ("_AnnWhile"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("\<^const>Groups.zero_class.zero"))
###                   ("\<^const>HOL.conj"
###                     ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                       ("_position" i))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>HOL.eq"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("\<^const>Groups.zero_class.zero"))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i))))))
###               ("\<^const>Orderings.ord_class.less"
###                 ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))
###                 ("_position" NSUM))
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>Orderings.ord_class.less_eq"
###                       ("_applC" ("_antiquote" ("_position" ti))
###                         ("_position" i))
###                       ("_position" NSUM))
###                     ("\<^const>HOL.conj"
###                       ("\<^const>Orderings.ord_class.less_eq"
###                         ("_applC" ("_antiquote" ("_position" tsum))
###                           ("_position" i))
###                         ("_position" MAXSUM))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>HOL.eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_applC" ("_position" local_sum)
###                             ("_applC" ("_position" take)
###                               ("_cargs"
###                                 ("_applC" ("_position" unat)
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i)))
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))))))
###                         ("_applC"
###                           ("_antiquote" ("_position" sumarr_inv_till_lock))
###                           ("_position" i)))))))
###               ("_AnnSeq"
###                 ("_AnnSeq"
###                   ("_guards"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_applC" ("_position" local_sum)
###                                   ("_applC" ("_position" take)
###                                     ("_cargs"
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                               ("_applC"
###                                 ("_antiquote"
###                                   ("_position" sumarr_inv_till_lock))
###                                 ("_position" i)))))))
###                     ("_last_grd"
###                       ("_grd" ("_position" InvalidMem)
###                         ("_Assert"
###                           ("_applC" ("_position" array_in_bound)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))
###                     ("_AnnAssign"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less_eq"
###                                 ("_applC" ("_antiquote" ("_position" tsum))
###                                   ("_position" i))
###                                 ("_position" MAXSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" unat)
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))
###                       ("_position" tsum)
###                       ("_Update" ("_antiquote" ("_position" tsum))
###                         ("_updbind" ("_position" i)
###                           ("\<^const>Groups.plus_class.plus"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_applC" ("_position" array_nth)
###                               ("_cargs"
###                                 ("_applC" ("_antiquote" ("_position" tarr))
###                                   ("_position" i))
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i)))))))))
###                   ("_guards"
###                     ("_Assert"
###                       ("\<^const>HOL.conj"
###                         ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                           ("_position" i))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less"
###                             ("_applC" ("_antiquote" ("_position" ti))
###                               ("_position" i))
###                             ("_position" NSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less_eq"
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" unat)
### ("_applC" ("_antiquote" ("_position" ti)) ("_position" i)))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i)))))
###                               ("_position" MAXSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.implies"
###                                   ("\<^const>HOL.disj"
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_position" array_nth)
###   ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_position" MAXSUM))
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM)))
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM)))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i))))))))
###                     ("_last_grd"
###                       ("_grd" ("_position" InvalidMem)
###                         ("_Assert"
###                           ("_applC" ("_position" array_in_bound)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i)))))))
###                     ("_AnnCond1"
###                       ("_Assert"
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                             ("_position" i))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>Orderings.ord_class.less"
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))
###                               ("_position" NSUM))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>HOL.implies"
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>Orderings.ord_class.less"
###                                     ("_applC" ("_position" array_nth)
### ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_position" MAXSUM)))
###                                 ("\<^const>HOL.eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_applC" ("_position" local_sum)
###                                     ("_applC" ("_position" take)
### ("_cargs"
###   ("_applC" ("_position" Suc)
###     ("_applC" ("_position" unat)
###       ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))))))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>HOL.implies"
###                                   ("\<^const>HOL.disj"
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_position" array_nth)
###   ("_cargs" ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))
###     ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
### ("_position" MAXSUM))
###                                     ("\<^const>Orderings.ord_class.greater_eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_position" MAXSUM)))
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM)))
###                                 ("_applC"
###                                   ("_antiquote"
###                                     ("_position" sumarr_inv_till_lock))
###                                   ("_position" i)))))))
###                       ("\<^const>HOL.disj"
###                         ("\<^const>Orderings.ord_class.greater_eq"
###                           ("_applC" ("_position" array_nth)
###                             ("_cargs"
###                               ("_applC" ("_antiquote" ("_position" tarr))
###                                 ("_position" i))
###                               ("_applC" ("_antiquote" ("_position" ti))
###                                 ("_position" i))))
###                           ("_position" MAXSUM))
###                         ("\<^const>Orderings.ord_class.greater_eq"
###                           ("_applC" ("_antiquote" ("_position" tsum))
###                             ("_position" i))
###                           ("_position" MAXSUM)))
###                       ("_AnnSeq"
###                         ("_AnnAssign"
###                           ("_Assert"
###                             ("\<^const>HOL.conj"
###                               ("_applC"
###                                 ("_antiquote" ("_position" sumarr_inv))
###                                 ("_position" i))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i))
###                                   ("_position" NSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i)))
###                                     ("_position" MAXSUM))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i))))))
###                           ("_position" tsum)
###                           ("_Update" ("_antiquote" ("_position" tsum))
###                             ("_updbind" ("_position" i)
###                               ("_position" MAXSUM))))
###                         ("_AnnThrow"
###                           ("_Assert"
###                             ("\<^const>HOL.conj"
###                               ("_applC"
###                                 ("_antiquote" ("_position" sumarr_inv))
###                                 ("_position" i))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less"
###                                   ("_applC" ("_antiquote" ("_position" ti))
###                                     ("_position" i))
###                                   ("_position" NSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>Orderings.ord_class.less_eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_position" MAXSUM))
###                                   ("\<^const>HOL.conj"
###                                     ("\<^const>HOL.eq"
### ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
### ("_applC" ("_position" local_sum)
###   ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" sumarr_inv_till_lock)) ("_position" i)))))))))
###                       ("_AnnSkip"
###                         ("_Assert"
###                           ("\<^const>HOL.conj"
###                             ("_applC"
###                               ("_antiquote" ("_position" sumarr_inv))
###                               ("_position" i))
###                             ("\<^const>HOL.conj"
###                               ("\<^const>Orderings.ord_class.less"
###                                 ("_applC" ("_antiquote" ("_position" ti))
###                                   ("_position" i))
###                                 ("_position" NSUM))
###                               ("\<^const>HOL.conj"
###                                 ("\<^const>Orderings.ord_class.less_eq"
###                                   ("_applC"
###                                     ("_antiquote" ("_position" tsum))
###                                     ("_position" i))
###                                   ("_position" MAXSUM))
###                                 ("\<^const>HOL.conj"
###                                   ("\<^const>HOL.eq"
###                                     ("_applC"
### ("_antiquote" ("_position" tsum)) ("_position" i))
###                                     ("_applC" ("_position" local_sum)
### ("_applC" ("_position" take)
###   ("_cargs"
###     ("_applC" ("_position" Suc)
###       ("_applC" ("_position" unat)
###         ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###     ("_applC" ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                                   ("_applC"
###                                     ("_antiquote"
### ("_position" sumarr_inv_till_lock))
###                                     ("_position" i)))))))))))
###                 ("_AnnAssign"
###                   ("_Assert"
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                         ("_position" i))
###                       ("\<^const>HOL.conj"
###                         ("\<^const>Orderings.ord_class.less"
###                           ("_applC" ("_antiquote" ("_position" ti))
###                             ("_position" i))
###                           ("_position" NSUM))
###                         ("\<^const>HOL.conj"
###                           ("\<^const>Orderings.ord_class.less_eq"
###                             ("_applC" ("_antiquote" ("_position" tsum))
###                               ("_position" i))
###                             ("_position" MAXSUM))
###                           ("\<^const>HOL.conj"
###                             ("\<^const>HOL.eq"
###                               ("_applC" ("_antiquote" ("_position" tsum))
###                                 ("_position" i))
###                               ("_applC" ("_position" local_sum)
###                                 ("_applC" ("_position" take)
###                                   ("_cargs"
###                                     ("_applC" ("_position" Suc)
### ("_applC" ("_position" unat)
###   ("_applC" ("_antiquote" ("_position" ti)) ("_position" i))))
###                                     ("_applC"
### ("_antiquote" ("_position" tarr)) ("_position" i))))))
###                             ("_applC"
###                               ("_antiquote"
###                                 ("_position" sumarr_inv_till_lock))
###                               ("_position" i)))))))
###                   ("_position" ti)
###                   ("_Update" ("_antiquote" ("_position" ti))
###                     ("_updbind" ("_position" i)
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_applC" ("_antiquote" ("_position" ti))
###                           ("_position" i))
###                         ("\<^const>Groups.one_class.one")))))))
###             ("_AnnSkip"
###               ("_Assert"
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                     ("_position" i))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq"
###                       ("_applC" ("_antiquote" ("_position" tsum))
###                         ("_position" i))
###                       ("_applC" ("_position" local_sum)
###                         ("_applC" ("_antiquote" ("_position" tarr))
###                           ("_position" i))))
###                     ("_applC"
###                       ("_antiquote" ("_position" sumarr_inv_till_lock))
###                       ("_position" i))))))))
###         ("_AnnSCall"
###           ("_Assert"
###             ("\<^const>HOL.conj"
###               ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                 ("_position" i))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq"
###                   ("_applC" ("_antiquote" ("_position" tsum))
###                     ("_position" i))
###                   ("_applC" ("_position" local_sum)
###                     ("_applC" ("_antiquote" ("_position" tarr))
###                       ("_position" i))))
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv_till_lock))
###                   ("_position" i)))))
###           ("_AnnSeq"
###             ("_applC"
###               ("_tuple" ("_String" ("_position" ''lock''))
###                 ("_tuple_arg" ("_position" i)))
###               ("\<^const>Groups.zero_class.zero"))
###             ("_Assert"
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" sumarr_inv))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("\<^const>HOL.eq"
###                     ("_applC" ("_antiquote" ("_position" tsum))
###                       ("_position" i))
###                     ("_applC" ("_position" local_sum)
###                       ("_applC" ("_antiquote" ("_position" tarr))
###                         ("_position" i))))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                       ("\<^const>Groups.one_class.one"))
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_antiquote" ("_position" ghost_lock))
###                         ("_position" i))
###                       ("_applC"
###                         ("_antiquote" ("_position" sumarr_inv_till_lock))
###                         ("_position" i))))))))
###           ("_Assign" ("_position" gsum)
###             ("\<^const>Groups.plus_class.plus"
###               ("_antiquote" ("_position" gsum))
###               ("_applC" ("_antiquote" ("_position" tsum))
###                 ("_position" i))))))
###       ("_AnnAssign"
###         ("_Assert"
###           ("\<^const>HOL.conj"
###             ("_applC" ("_antiquote" ("_position" sumarr_inv))
###               ("_position" i))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###                 ("_applC" ("_position" local_sum)
###                   ("_applC" ("_antiquote" ("_position" tarr))
###                     ("_position" i))))
###               ("\<^const>HOL.conj"
###                 ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                   ("\<^const>Groups.one_class.one"))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_antiquote" ("_position" ghost_lock))
###                     ("_position" i))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock1))
###                     ("_position" i)))))))
###         ("_position" gdone)
###         ("\<^const>Bit_Operations.semiring_bit_operations_class.or"
###           ("_antiquote" ("_position" gdone))
###           ("_applC" ("_antiquote" ("_position" tid)) ("_position" i)))))
###     ("_AnnSCall"
###       ("_Assert"
###         ("\<^const>HOL.conj"
###           ("_applC" ("_antiquote" ("_position" sumarr_inv)) ("_position" i))
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_antiquote" ("_position" tsum)) ("_position" i))
###               ("_applC" ("_position" local_sum)
###                 ("_applC" ("_antiquote" ("_position" tarr))
###                   ("_position" i))))
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.eq" ("_antiquote" ("_position" glock))
###                 ("\<^const>Groups.one_class.one"))
###               ("\<^const>HOL.conj"
###                 ("_applC" ("_antiquote" ("_position" ghost_lock))
###                   ("_position" i))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" bit)
###                     ("_cargs" ("_antiquote" ("_position" gdone))
###                       ("_applC" ("_position" unat)
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_antiquote" ("_position" tid))
###                             ("_position" i))
###                           ("\<^const>Groups.one_class.one")))))
###                   ("_applC" ("_antiquote" ("_position" sumarr_in_lock2))
###                     ("_position" i))))))))
###       ("_tuple" ("_String" ("_position" ''unlock''))
###         ("_tuple_arg" ("_position" i)))
###       ("\<^const>Groups.zero_class.zero"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
val TRY' = fn: ('a -> tactic) -> 'a -> tactic
### Ambiguous input (line 455 of "$AFP/Complx/ex/SumArr.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_oghoare_seq" ("_position" \<Gamma>) ("_position" \<Theta>)
###     ("_position" F) ("_Assert" ("_antiquote" ("_position" precond)))
###     ("_PAR"
###       ("_prg_scheme" ("\<^const>Groups.zero_class.zero") ("_position" m)
###         ("_Numeral" ("_constify" ("_position" 2))) ("_position" call_sumarr)
###         ("_applC" ("_position" m)
###           ("_Assert"
###             ("_applC" ("_antiquote" ("_position" local_postcond))
###               ("_position" m))))
###         ("_Assert" ("_position" False))))
###     ("_Assert" ("_antiquote" ("_position" postcond)))
###     ("_Assert" ("_position" False))))
### ("\<^const>HOL.Trueprop"
###   ("_oghoare_seq" ("_position" \<Gamma>) ("_position" \<Theta>)
###     ("_position" F) ("_Assert" ("_antiquote" ("_position" precond)))
###     ("_PAR"
###       ("_prg_scheme" ("\<^const>Groups.zero_class.zero") ("_position" m)
###         ("_Numeral" ("_constify" ("_position" 2)))
###         ("_applC" ("_position" call_sumarr) ("_position" m))
###         ("_Assert"
###           ("_applC" ("_antiquote" ("_position" local_postcond))
###             ("_position" m)))
###         ("_Assert" ("_position" False))))
###     ("_Assert" ("_antiquote" ("_position" postcond)))
###     ("_Assert" ("_position" False))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.SumArr"
### 12.237s elapsed time, 16.541s cpu time, 5.991s GC time
Loading theory "Draft.SumArrMoreTemplates"
val templateLemmas =
   [("SumArr.word_min_0", "min 0 ?x = 0",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_hole 0)),
    ("SumArr.word_min_0", "min ?x 0 = 0",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_hole 0)),
    ("SumArr.MAXSUM_le_plus", "?x < MAXSUM ==> MAXSUM <= MAXSUM + ?x",
     template_implication
      ([template_inequation (less_than, template_var 0, template_hole 2)],
       template_inequation
        (less_equals, template_hole 2,
         template_app
          (template_app (template_hole 0, template_hole 2),
           template_var 0)))),
    ("SumArr.sumarr_proc_simp", "[ann (lock ?n)] ! 0 = ann (lock ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_hole 3,
                 template_app (template_hole 2, template_var 0))),
             template_hole 1)),
         template_hole 0),
       template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)))),
    ("SumArr.sumarr_proc_simp", "[ann (sumarr ?n)] ! 0 = ann (sumarr ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_hole 3,
                 template_app (template_hole 2, template_var 0))),
             template_hole 1)),
         template_hole 0),
       template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)))),
    ("SumArr.sumarr_proc_simp", "[ann (unlock ?n)] ! 0 = ann (unlock ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_hole 3,
                 template_app (template_hole 2, template_var 0))),
             template_hole 1)),
         template_hole 0),
       template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)))),
    ("SumArr.post_call_sumarr",
     "[| local_postcond ?x 0; local_postcond ?x 1 |]
      ==> SumArr.postcond ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 0),
              template_hole 2)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 0),
              template_hole 1)
            )],
       template_predicate
        (template_app (template_hole 0, template_var 0)))),
    ("SumArr.less_than_two_2", "?i < 2 ==> Suc 0 - ?i < 2",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 5,
            template_app (template_hole 4, template_hole 3)))],
       template_inequation
        (less_than,
         template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_hole 0)),
           template_var 0),
         template_app
          (template_hole 5,
           template_app (template_hole 4, template_hole 3))))),
    ("SumArr.local_sum_MAXSUM",
     "[| ?k < length ?arr; MAXSUM <= ?arr ! ?k |]
      ==> local_sum ?arr = MAXSUM",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app (template_hole 5, template_var 0)),
        template_inequation
         (less_equals, template_hole 3,
          template_app
           (template_app (template_hole 2, template_var 0),
            template_var 1))],
       template_equation
        (template_app (template_hole 0, template_var 0), template_hole 3))),
    ("SumArr.pre_call_sumarr",
     "[| ?i < 2; SumArr.precond ?x |] ==> ?x : pre (ann (call_sumarr ?i))",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_hole 5))),
        template_predicate
         (template_app (template_hole 4, template_var 0))],
       template_predicate
        (
           template_app
            (template_app (template_hole 3, template_var 0),
             template_app
              (template_hole 2,
               template_app
                (template_hole 1,
                 template_app (template_hole 0, template_var 1))))
           ))),
    ("SumArr.imp_disjL_context'",
     "((?P --> ?R) & (?Q --> ?R)) = ((?P --> ?R) & (~ ?P & ?Q --> ?R))",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 0), template_var 1)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app
                (template_hole 2,
                 template_app (template_hole 0, template_var 2)),
               template_var 0)),
           template_var 1)))),
    ("SumArr.map_of_prod_1",
     "?i < ?n ==>
      map_of (map (%i. ((?p, i), ?g i)) [0..<?n]) (?p, ?i) = Some (?g ?i)",
     template_implication
      ([template_inequation (less_than, template_var 3, template_var 2)],
       template_equation
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 5, t_empty),
               template_app
                (template_app (template_hole 2, template_hole 1),
                 template_var 2))),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 3)),
         template_app
          (template_hole 0,
           template_app (template_var 0, template_var 3))))),
    ("SumArr.oghoare_call_sumarr",
     "?i < 2 ==>
      \<Gamma>, \<Theta>
      |\<turnstile>\<^bsub>/?F\<^esub> call_sumarr ?i
 \<lbrace>\<acute>local_postcond ?i\<rbrace>, \<lbrace>False\<rbrace>",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app
           (template_hole 11,
            template_app (template_hole 10, template_hole 9)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 8, template_hole 7),
                       template_hole 6),
                     template_var 0),
                   template_app
                    (template_hole 5,
                     template_app (template_hole 4, template_var 1))),
                 template_app
                  (template_hole 3,
                   template_app (template_hole 4, template_var 1))),
               template_app (template_hole 2, t_empty)),
             template_app (template_hole 2, t_empty))
           ))),
    ("SumArr.oghoare_sumarr",
     "?i < 2 ==>
      \<Gamma>, \<Theta>
      |\<turnstile>\<^bsub>/?F\<^esub> sumarr ?i
 \<lbrace>\<acute>local_postcond ?i\<rbrace>, \<lbrace>False\<rbrace>",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app
           (template_hole 11,
            template_app (template_hole 10, template_hole 9)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 8, template_hole 7),
                       template_hole 6),
                     template_var 0),
                   template_app
                    (template_hole 5,
                     template_app (template_hole 4, template_var 1))),
                 template_app
                  (template_hole 3,
                   template_app (template_hole 4, template_var 1))),
               template_app (template_hole 2, t_empty)),
             template_app (template_hole 2, t_empty))
           ))),
    ("SumArr.less_than_two_inv",
     "[| ?i < 2; ?j < 2; ?i ~= ?j |] ==> Suc 0 - ?i = ?j",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_hole 5))),
        template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_hole 5))),
        template_negation
         (template_equation (template_var 1, template_var 0))],
       template_equation
        (template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_hole 0)),
           template_var 1),
         template_var 0))),
    ("SumArr.map_of_prod_2",
     "[| ?i < ?n; ?p ~= ?q |]
      ==> (?m ++ map_of (map (%i. ((?p, i), ?g i)) [0..<?n])) (?q, ?i) =
          ?m (?q, ?i)",
     template_implication
      ([template_inequation (less_than, template_var 5, template_var 4),
        template_negation
         (template_equation (template_var 3, template_var 2))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 6, template_var 1),
             template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, t_empty),
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 4)))),
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 5)),
         template_app
          (template_var 1,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 5))))),
    ("SumArr.local_sum_MAXSUM'",
     "[| ?k < length ?arr; MAXSUM <= local_sum (take ?k ?arr) + ?arr ! ?k;
         local_sum (take ?k ?arr) <= MAXSUM; ?arr ! ?k <= MAXSUM |]
      ==> local_sum ?arr = MAXSUM",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app (template_hole 7, template_var 0)),
        template_inequation
         (less_equals, template_hole 5,
          template_app
           (template_app
             (template_hole 4,
              template_app
               (template_hole 3,
                template_app
                 (template_app (template_hole 2, template_var 1),
                  template_var 0))),
            template_app
             (template_app (template_hole 1, template_var 0),
              template_var 1))),
        template_inequation
         (less_equals,
          template_app
           (template_hole 3,
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 0)),
          template_hole 5),
        template_inequation
         (less_equals,
          template_app
           (template_app (template_hole 1, template_var 0), template_var 1),
          template_hole 5)],
       template_equation
        (template_app (template_hole 3, template_var 0), template_hole 5))),
    ("SumArr.local_sum_Suc",
     "[| ?n < length ?arr; local_sum (take ?n ?arr) + ?arr ! ?n < MAXSUM;
         ?arr ! ?n < MAXSUM |]
      ==> local_sum (take ?n ?arr) + ?arr ! ?n =
          local_sum (take (Suc ?n) ?arr)",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app (template_hole 8, template_var 0)),
        template_inequation
         (less_than,
          template_app
           (template_app
             (template_hole 6,
              template_app
               (template_hole 5,
                template_app
                 (template_app (template_hole 4, template_var 1),
                  template_var 0))),
            template_app
             (template_app (template_hole 3, template_var 0),
              template_var 1)),
          template_hole 2),
        template_inequation
         (less_than,
          template_app
           (template_app (template_hole 3, template_var 0), template_var 1),
          template_hole 2)],
       template_equation
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_var 1),
                 template_var 0))),
           template_app
            (template_app (template_hole 3, template_var 0),
             template_var 1)),
         template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app (template_hole 0, template_var 1)),
             template_var 0))))),
    ("SumArr.sumarr_correct",
     "\<Gamma>, \<Theta>
      |\<tturnstile>\<^bsub>/?F\<^esub> \<lbrace>\<acute>SumArr.precond\<rbrace>
  COBEGIN
    SCHEME [0 \<le> m < 2]
      call_sumarr m
      \<lbrace>\<acute>local_postcond m\<rbrace>, \<lbrace>False\<rbrace>
  COEND
  \<lbrace>\<acute>SumArr.postcond\<rbrace>, \<lbrace>False\<rbrace>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 21, template_hole 20),
                       template_hole 19),
                     template_var 0),
                   template_app (template_hole 18, t_empty)),
                 template_app
                  (template_hole 16,
                   template_app
                    (template_app (template_hole 15, t_empty),
                     template_app
                      (template_app (template_hole 8, template_hole 7),
                       template_app
                        (template_hole 6,
                         template_app
                          (template_hole 5, template_hole 4)))))),
               template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, t_empty),
                   template_app
                    (template_app (template_hole 8, template_hole 7),
                     template_app
                      (template_hole 6,
                       template_app (template_hole 5, template_hole 4)))))),
             template_app (template_hole 18, t_empty)),
           template_app (template_hole 18, t_empty))
         )),
    ("SumArr.inter_aux_call_sumarr",
     "[| ?i < 2; ?j < 2; ?i ~= ?j |]
      ==> interfree_aux \<Gamma> \<Theta> ?F
           (com (call_sumarr ?i),
            (ann (call_sumarr ?i),
             \<lbrace>\<acute>local_postcond ?i\<rbrace>, {}),
            com (call_sumarr ?j), ann (call_sumarr ?j))",
     template_implication
      ([template_inequation
         (less_than, template_var 2,
          template_app
           (template_hole 18,
            template_app (template_hole 17, template_hole 16))),
        template_inequation
         (less_than, template_var 1,
          template_app
           (template_hole 18,
            template_app (template_hole 17, template_hole 16))),
        template_negation
         (template_equation (template_var 2, template_var 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app (template_hole 13, template_hole 12),
                 template_hole 11),
               template_var 0),
             template_app
              (template_app
                (template_hole 10,
                 template_app
                  (template_hole 9,
                   template_app (template_hole 8, template_var 2))),
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app
                      (template_hole 6,
                       template_app
                        (template_hole 5,
                         template_app (template_hole 8, template_var 2))),
                     template_app
                      (template_app
                        (template_hole 4,
                         template_app (template_hole 3, t_empty)),
                       template_hole 1))),
                 template_app
                  (template_app
                    (template_hole 0,
                     template_app
                      (template_hole 9,
                       template_app (template_hole 8, template_var 1))),
                   template_app
                    (template_hole 5,
                     template_app (template_hole 8, template_var 1))))))
           ))),
    ("SumArr.sumarr_proc_simp",
     "?n < 2 ==> \<Gamma> (''lock'', ?n) = Some (com (lock ?n))",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 13,
            template_app (template_hole 12, template_hole 11)))],
       template_equation
        (template_app
          (template_hole 9,
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 6, template_hole 5),
                                 template_hole 5),
                               template_hole 4),
                             template_hole 4),
                           template_hole 5),
                         template_hole 4),
                       template_hole 4),
                     template_hole 5)),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 6, template_hole 4),
                                   template_hole 4),
                                 template_hole 4),
                               template_hole 4),
                             template_hole 5),
                           template_hole 4),
                         template_hole 4),
                       template_hole 5)),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 6, template_hole 4),
                                     template_hole 4),
                                   template_hole 5),
                                 template_hole 5),
                               template_hole 5),
                             template_hole 4),
                           template_hole 4),
                         template_hole 5)),
                     template_app
                      (template_app
                        (template_hole 7,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 6, template_hole 4), template_hole 4),
                                     template_hole 5),
                                   template_hole 4),
                                 template_hole 5),
                               template_hole 4),
                             template_hole 4),
                           template_hole 5)),
                       template_hole 3))))),
             template_var 0)),
         template_app
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))))),
    ("SumArr.sumarr_proc_simp",
     "?n < 2 ==> \<Theta> (''lock'', ?n) = Some [ann (lock ?n)]",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 15,
            template_app (template_hole 14, template_hole 13)))],
       template_equation
        (template_app
          (template_hole 11,
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app
                  (template_hole 9,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 8, template_hole 7),
                                 template_hole 7),
                               template_hole 6),
                             template_hole 6),
                           template_hole 7),
                         template_hole 6),
                       template_hole 6),
                     template_hole 7)),
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 8, template_hole 6),
                                   template_hole 6),
                                 template_hole 6),
                               template_hole 6),
                             template_hole 7),
                           template_hole 6),
                         template_hole 6),
                       template_hole 7)),
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 8, template_hole 6),
                                     template_hole 6),
                                   template_hole 7),
                                 template_hole 7),
                               template_hole 7),
                             template_hole 6),
                           template_hole 6),
                         template_hole 7)),
                     template_app
                      (template_app
                        (template_hole 9,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 8, template_hole 6), template_hole 6),
                                     template_hole 7),
                                   template_hole 6),
                                 template_hole 7),
                               template_hole 6),
                             template_hole 6),
                           template_hole 7)),
                       template_hole 5))))),
             template_var 0)),
         template_app
          (template_hole 4,
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_hole 2,
                 template_app (template_hole 1, template_var 0))),
             template_hole 0))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "?n < 2 ==>
      \<Gamma> (''lock'', ?n) =
      Some
       (Await \<lbrace>\<acute>glock = 0\<rbrace>
         (Seq (Basic (glock_update (%_. 1)))
           (Basic (%s. s(| ghost_lock := (ghost_lock s)(?n := True) |)))))",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 23,
            template_app (template_hole 22, template_hole 21)))],
       template_equation
        (template_app
          (template_hole 19,
           template_app
            (template_app
              (template_hole 18,
               template_app
                (template_app
                  (template_hole 17,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 16, template_hole 15),
                                 template_hole 15),
                               template_hole 14),
                             template_hole 14),
                           template_hole 15),
                         template_hole 14),
                       template_hole 14),
                     template_hole 15)),
                 template_app
                  (template_app
                    (template_hole 17,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 16, template_hole 14),
                                   template_hole 14),
                                 template_hole 14),
                               template_hole 14),
                             template_hole 15),
                           template_hole 14),
                         template_hole 14),
                       template_hole 15)),
                   template_app
                    (template_app
                      (template_hole 17,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 16, template_hole 14),
                                     template_hole 14),
                                   template_hole 15),
                                 template_hole 15),
                               template_hole 15),
                             template_hole 14),
                           template_hole 14),
                         template_hole 15)),
                     template_app
                      (template_app
                        (template_hole 17,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 16, template_hole 14), template_hole 14),
                                     template_hole 15),
                                   template_hole 14),
                                 template_hole 15),
                               template_hole 14),
                             template_hole 14),
                           template_hole 15)),
                       template_hole 13))))),
             template_var 0)),
         template_app
          (template_hole 12,
           template_app
            (template_app
              (template_hole 11, template_app (template_hole 10, t_empty)),
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_hole 5,
                   template_app (template_hole 4, t_empty))),
               template_app (template_hole 5, t_empty))))))),
    ("SumArr.sumarr_proc_simp",
     "?n < 2 ==> \<Gamma> (''unlock'', ?n) = Some (com (unlock ?n))",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 13,
            template_app (template_hole 12, template_hole 11)))],
       template_equation
        (template_app
          (template_hole 9,
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 6, template_hole 5),
                                 template_hole 4),
                               template_hole 5),
                             template_hole 4),
                           template_hole 5),
                         template_hole 5),
                       template_hole 5),
                     template_hole 4)),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 6, template_hole 4),
                                   template_hole 5),
                                 template_hole 5),
                               template_hole 5),
                             template_hole 4),
                           template_hole 5),
                         template_hole 5),
                       template_hole 4)),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 6, template_hole 4),
                                     template_hole 4),
                                   template_hole 5),
                                 template_hole 5),
                               template_hole 4),
                             template_hole 5),
                           template_hole 5),
                         template_hole 4)),
                     template_app
                      (template_app
                        (template_hole 7,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 6, template_hole 5), template_hole 5),
                                     template_hole 5),
                                   template_hole 5),
                                 template_hole 4),
                               template_hole 5),
                             template_hole 5),
                           template_hole 4)),
                       template_app
                        (template_app
                          (template_hole 7,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 6, template_hole 5), template_hole 5),
 template_hole 4),
                                     template_hole 4),
                                   template_hole 4),
                                 template_hole 5),
                               template_hole 5),
                             template_hole 4)),
                         template_app
                          (template_app
                            (template_hole 7,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 6, template_hole 5), template_hole 5),
   template_hole 4),
 template_hole 5),
                                     template_hole 4),
                                   template_hole 5),
                                 template_hole 5),
                               template_hole 4)),
                           template_hole 3))))))),
             template_var 0)),
         template_app
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))))),
    ("SumArr.sumarr_proc_simp",
     "?n < 2 ==> \<Gamma> (''sumarr'', ?n) = Some (com (sumarr ?n))",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 13,
            template_app (template_hole 12, template_hole 11)))],
       template_equation
        (template_app
          (template_hole 9,
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 6, template_hole 5),
                                 template_hole 5),
                               template_hole 4),
                             template_hole 4),
                           template_hole 5),
                         template_hole 5),
                       template_hole 5),
                     template_hole 4)),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 6, template_hole 5),
                                   template_hole 4),
                                 template_hole 5),
                               template_hole 4),
                             template_hole 5),
                           template_hole 5),
                         template_hole 5),
                       template_hole 4)),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 6, template_hole 5),
                                     template_hole 4),
                                   template_hole 5),
                                 template_hole 5),
                               template_hole 4),
                             template_hole 5),
                           template_hole 5),
                         template_hole 4)),
                     template_app
                      (template_app
                        (template_hole 7,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 6, template_hole 5), template_hole 4),
                                     template_hole 4),
                                   template_hole 4),
                                 template_hole 4),
                               template_hole 5),
                             template_hole 5),
                           template_hole 4)),
                       template_app
                        (template_app
                          (template_hole 7,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 6, template_hole 4), template_hole 5),
 template_hole 4),
                                     template_hole 4),
                                   template_hole 5),
                                 template_hole 5),
                               template_hole 5),
                             template_hole 4)),
                         template_app
                          (template_app
                            (template_hole 7,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 6, template_hole 4), template_hole 5),
   template_hole 4),
 template_hole 4),
                                     template_hole 5),
                                   template_hole 5),
                                 template_hole 5),
                               template_hole 4)),
                           template_hole 3))))))),
             template_var 0)),
         template_app
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)))))),
    ("SumArr.sumarr_proc_simp",
     "?n < 2 ==> \<Theta> (''unlock'', ?n) = Some [ann (unlock ?n)]",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 15,
            template_app (template_hole 14, template_hole 13)))],
       template_equation
        (template_app
          (template_hole 11,
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app
                  (template_hole 9,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 8, template_hole 7),
                                 template_hole 6),
                               template_hole 7),
                             template_hole 6),
                           template_hole 7),
                         template_hole 7),
                       template_hole 7),
                     template_hole 6)),
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 8, template_hole 6),
                                   template_hole 7),
                                 template_hole 7),
                               template_hole 7),
                             template_hole 6),
                           template_hole 7),
                         template_hole 7),
                       template_hole 6)),
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 8, template_hole 6),
                                     template_hole 6),
                                   template_hole 7),
                                 template_hole 7),
                               template_hole 6),
                             template_hole 7),
                           template_hole 7),
                         template_hole 6)),
                     template_app
                      (template_app
                        (template_hole 9,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 8, template_hole 7), template_hole 7),
                                     template_hole 7),
                                   template_hole 7),
                                 template_hole 6),
                               template_hole 7),
                             template_hole 7),
                           template_hole 6)),
                       template_app
                        (template_app
                          (template_hole 9,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 8, template_hole 7), template_hole 7),
 template_hole 6),
                                     template_hole 6),
                                   template_hole 6),
                                 template_hole 7),
                               template_hole 7),
                             template_hole 6)),
                         template_app
                          (template_app
                            (template_hole 9,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 8, template_hole 7), template_hole 7),
   template_hole 6),
 template_hole 7),
                                     template_hole 6),
                                   template_hole 7),
                                 template_hole 7),
                               template_hole 6)),
                           template_hole 5))))))),
             template_var 0)),
         template_app
          (template_hole 4,
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_hole 2,
                 template_app (template_hole 1, template_var 0))),
             template_hole 0))))),
    ("SumArr.sumarr_proc_simp",
     "?n < 2 ==> \<Theta> (''sumarr'', ?n) = Some [ann (sumarr ?n)]",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 15,
            template_app (template_hole 14, template_hole 13)))],
       template_equation
        (template_app
          (template_hole 11,
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app
                  (template_hole 9,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 8, template_hole 7),
                                 template_hole 7),
                               template_hole 6),
                             template_hole 6),
                           template_hole 7),
                         template_hole 7),
                       template_hole 7),
                     template_hole 6)),
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 8, template_hole 7),
                                   template_hole 6),
                                 template_hole 7),
                               template_hole 6),
                             template_hole 7),
                           template_hole 7),
                         template_hole 7),
                       template_hole 6)),
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 8, template_hole 7),
                                     template_hole 6),
                                   template_hole 7),
                                 template_hole 7),
                               template_hole 6),
                             template_hole 7),
                           template_hole 7),
                         template_hole 6)),
                     template_app
                      (template_app
                        (template_hole 9,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 8, template_hole 7), template_hole 6),
                                     template_hole 6),
                                   template_hole 6),
                                 template_hole 6),
                               template_hole 7),
                             template_hole 7),
                           template_hole 6)),
                       template_app
                        (template_app
                          (template_hole 9,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 8, template_hole 6), template_hole 7),
 template_hole 6),
                                     template_hole 6),
                                   template_hole 7),
                                 template_hole 7),
                               template_hole 7),
                             template_hole 6)),
                         template_app
                          (template_app
                            (template_hole 9,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 8, template_hole 6), template_hole 7),
   template_hole 6),
 template_hole 6),
                                     template_hole 7),
                                   template_hole 7),
                                 template_hole 7),
                               template_hole 6)),
                           template_hole 5))))))),
             template_var 0)),
         template_app
          (template_hole 4,
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_hole 2,
                 template_app (template_hole 1, template_var 0))),
             template_hole 0))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "?n < 2 ==>
      \<Gamma> (''unlock'', ?n) =
      Some
       (Await \<lbrace>True\<rbrace>
         (Seq (Basic (glock_update (%_. 0)))
           (Basic
             (%s. s(| ghost_lock := (ghost_lock s)(?n := False) |)))))",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 20,
            template_app (template_hole 19, template_hole 18)))],
       template_equation
        (template_app
          (template_hole 16,
           template_app
            (template_app
              (template_hole 15,
               template_app
                (template_app
                  (template_hole 14,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 13, template_hole 12),
                                 template_hole 11),
                               template_hole 12),
                             template_hole 11),
                           template_hole 12),
                         template_hole 12),
                       template_hole 12),
                     template_hole 11)),
                 template_app
                  (template_app
                    (template_hole 14,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 13, template_hole 11),
                                   template_hole 12),
                                 template_hole 12),
                               template_hole 12),
                             template_hole 11),
                           template_hole 12),
                         template_hole 12),
                       template_hole 11)),
                   template_app
                    (template_app
                      (template_hole 14,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 13, template_hole 11),
                                     template_hole 11),
                                   template_hole 12),
                                 template_hole 12),
                               template_hole 11),
                             template_hole 12),
                           template_hole 12),
                         template_hole 11)),
                     template_app
                      (template_app
                        (template_hole 14,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 13, template_hole 12), template_hole 12),
                                     template_hole 12),
                                   template_hole 12),
                                 template_hole 11),
                               template_hole 12),
                             template_hole 12),
                           template_hole 11)),
                       template_app
                        (template_app
                          (template_hole 14,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 13, template_hole 12), template_hole 12),
 template_hole 11),
                                     template_hole 11),
                                   template_hole 11),
                                 template_hole 12),
                               template_hole 12),
                             template_hole 11)),
                         template_app
                          (template_app
                            (template_hole 14,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 13, template_hole 12), template_hole 12),
   template_hole 11),
 template_hole 12),
                                     template_hole 11),
                                   template_hole 12),
                                 template_hole 12),
                               template_hole 11)),
                           template_hole 10))))))),
             template_var 0)),
         template_app
          (template_hole 9,
           template_app
            (template_app
              (template_hole 8, template_app (template_hole 7, t_empty)),
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_hole 5,
                   template_app (template_hole 4, t_empty))),
               template_app (template_hole 5, t_empty))))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "?n < 2 ==>
      \<Theta> (''lock'', ?n) =
      Some
       [AnnRec
         \<lbrace>(\<acute>lock_inv &
                   \<acute>tarr_inv ?n &
                   \<acute>garr_inv ?n &
                   \<acute>tid ?n = word_of_nat ?n + 1) &
                  \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                  \<acute>sumarr_inv_till_lock ?n\<rbrace>
         (AnnComp (AnnExpr FAKE_ANN) (AnnExpr FAKE_ANN))]",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 52,
            template_app (template_hole 51, template_hole 50)))],
       template_equation
        (template_app
          (template_hole 48,
           template_app
            (template_app
              (template_hole 47,
               template_app
                (template_app
                  (template_hole 46,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 45, template_hole 44),
                                 template_hole 44),
                               template_hole 43),
                             template_hole 43),
                           template_hole 44),
                         template_hole 43),
                       template_hole 43),
                     template_hole 44)),
                 template_app
                  (template_app
                    (template_hole 46,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 45, template_hole 43),
                                   template_hole 43),
                                 template_hole 43),
                               template_hole 43),
                             template_hole 44),
                           template_hole 43),
                         template_hole 43),
                       template_hole 44)),
                   template_app
                    (template_app
                      (template_hole 46,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 45, template_hole 43),
                                     template_hole 43),
                                   template_hole 44),
                                 template_hole 44),
                               template_hole 44),
                             template_hole 43),
                           template_hole 43),
                         template_hole 44)),
                     template_app
                      (template_app
                        (template_hole 46,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 45, template_hole 43), template_hole 43),
                                     template_hole 44),
                                   template_hole 43),
                                 template_hole 44),
                               template_hole 43),
                             template_hole 43),
                           template_hole 44)),
                       template_hole 42))))),
             template_var 0)),
         template_app
          (template_hole 41,
           template_app
            (template_app
              (template_hole 40,
               template_app
                (template_app
                  (template_hole 39,
                   template_app (template_hole 38, t_empty)),
                 template_app
                  (template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_hole 1)),
                   template_app (template_hole 2, template_hole 1)))),
             template_hole 0))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "?n < 2 ==>
      \<Theta> (''unlock'', ?n) =
      Some
       [AnnRec
         \<lbrace>(\<acute>lock_inv &
                   \<acute>tarr_inv ?n &
                   \<acute>garr_inv ?n &
                   \<acute>tid ?n = word_of_nat ?n + 1) &
                  \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                  \<acute>glock = 1 &
                  \<acute>ghost_lock ?n &
                  bit \<acute>gdone (unat (\<acute>tid ?n - 1)) &
                  \<acute>sumarr_in_lock2 ?n\<rbrace>
         (AnnComp (AnnExpr FAKE_ANN) (AnnExpr FAKE_ANN))]",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 51,
            template_app (template_hole 50, template_hole 49)))],
       template_equation
        (template_app
          (template_hole 47,
           template_app
            (template_app
              (template_hole 46,
               template_app
                (template_app
                  (template_hole 45,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 44, template_hole 43),
                                 template_hole 42),
                               template_hole 43),
                             template_hole 42),
                           template_hole 43),
                         template_hole 43),
                       template_hole 43),
                     template_hole 42)),
                 template_app
                  (template_app
                    (template_hole 45,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 44, template_hole 42),
                                   template_hole 43),
                                 template_hole 43),
                               template_hole 43),
                             template_hole 42),
                           template_hole 43),
                         template_hole 43),
                       template_hole 42)),
                   template_app
                    (template_app
                      (template_hole 45,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 44, template_hole 42),
                                     template_hole 42),
                                   template_hole 43),
                                 template_hole 43),
                               template_hole 42),
                             template_hole 43),
                           template_hole 43),
                         template_hole 42)),
                     template_app
                      (template_app
                        (template_hole 45,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 44, template_hole 43), template_hole 43),
                                     template_hole 43),
                                   template_hole 43),
                                 template_hole 42),
                               template_hole 43),
                             template_hole 43),
                           template_hole 42)),
                       template_app
                        (template_app
                          (template_hole 45,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 44, template_hole 43), template_hole 43),
 template_hole 42),
                                     template_hole 42),
                                   template_hole 42),
                                 template_hole 43),
                               template_hole 43),
                             template_hole 42)),
                         template_app
                          (template_app
                            (template_hole 45,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 44, template_hole 43), template_hole 43),
   template_hole 42),
 template_hole 43),
                                     template_hole 42),
                                   template_hole 43),
                                 template_hole 43),
                               template_hole 42)),
                           template_hole 41))))))),
             template_var 0)),
         template_app
          (template_hole 40,
           template_app
            (template_app
              (template_hole 39,
               template_app
                (template_app
                  (template_hole 38,
                   template_app (template_hole 37, t_empty)),
                 template_app
                  (template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_hole 1)),
                   template_app (template_hole 2, template_hole 1)))),
             template_hole 0))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "[AnnRec
        \<lbrace>(\<acute>lock_inv &
                  \<acute>tarr_inv ?n &
                  \<acute>garr_inv ?n &
                  \<acute>tid ?n = word_of_nat ?n + 1) &
                 \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                 \<acute>glock = 1 &
                 \<acute>ghost_lock ?n &
                 bit \<acute>gdone (unat (\<acute>tid ?n - 1)) &
                 \<acute>sumarr_in_lock2 ?n\<rbrace>
        (AnnComp (AnnExpr FAKE_ANN) (AnnExpr FAKE_ANN))] !
      0 =
      AnnRec
       \<lbrace>(\<acute>lock_inv &
                 \<acute>tarr_inv ?n &
                 \<acute>garr_inv ?n &
                 \<acute>tid ?n = word_of_nat ?n + 1) &
                \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                \<acute>glock = 1 &
                \<acute>ghost_lock ?n &
                bit \<acute>gdone (unat (\<acute>tid ?n - 1)) &
                \<acute>sumarr_in_lock2 ?n\<rbrace>
       (AnnComp (AnnExpr FAKE_ANN) (AnnExpr FAKE_ANN))",
     template_equation
      (template_app
        (template_app
          (template_hole 40,
           template_app
            (template_app
              (template_hole 39,
               template_app
                (template_app
                  (template_hole 38,
                   template_app (template_hole 37, t_empty)),
                 template_app
                  (template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_hole 1)),
                   template_app (template_hole 2, template_hole 1)))),
             template_hole 0)),
         template_hole 30),
       template_app
        (template_app
          (template_hole 38, template_app (template_hole 37, t_empty)),
         template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_hole 1)),
           template_app (template_hole 2, template_hole 1))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "[AnnRec
        \<lbrace>(\<acute>lock_inv &
                  \<acute>tarr_inv ?n &
                  \<acute>garr_inv ?n &
                  \<acute>tid ?n = word_of_nat ?n + 1) &
                 \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                 \<acute>sumarr_inv_till_lock ?n\<rbrace>
        (AnnComp (AnnExpr FAKE_ANN) (AnnExpr FAKE_ANN))] !
      0 =
      AnnRec
       \<lbrace>(\<acute>lock_inv &
                 \<acute>tarr_inv ?n &
                 \<acute>garr_inv ?n &
                 \<acute>tid ?n = word_of_nat ?n + 1) &
                \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                \<acute>sumarr_inv_till_lock ?n\<rbrace>
       (AnnComp (AnnExpr FAKE_ANN) (AnnExpr FAKE_ANN))",
     template_equation
      (template_app
        (template_app
          (template_hole 41,
           template_app
            (template_app
              (template_hole 40,
               template_app
                (template_app
                  (template_hole 39,
                   template_app (template_hole 38, t_empty)),
                 template_app
                  (template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_hole 1)),
                   template_app (template_hole 2, template_hole 1)))),
             template_hole 0)),
         template_hole 31),
       template_app
        (template_app
          (template_hole 39, template_app (template_hole 38, t_empty)),
         template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_hole 1)),
           template_app (template_hole 2, template_hole 1))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "?n < 2 ==>
      \<Gamma> (''sumarr'', ?n) =
      Some
       (Seq (Seq (Seq (Seq (Seq (Seq (Basic
 (%s. s(| tsum := (tsum s)(?n := 0) |)))
                                  (Basic
                                    (%s. s(| ti := (ti s)(?n := 0) |))))
                             (Catch
                               (While \<lbrace>\<acute>ti ?n < NSUM\<rbrace>
                                 (Seq (Seq
  (Guard
    (fst (InvalidMem,
          \<lbrace>array_in_bound (\<acute>tarr ?n)
                    (\<acute>ti ?n)\<rbrace>))
    (snd (InvalidMem,
          \<lbrace>array_in_bound (\<acute>tarr ?n)
                    (\<acute>ti ?n)\<rbrace>))
    (Basic
      (%s. s(| tsum := (tsum s)
                 (?n := tsum s ?n + array_nth (tarr s ?n) (ti s ?n)) |))))
  (Guard
    (fst (InvalidMem,
          \<lbrace>array_in_bound (\<acute>tarr ?n)
                    (\<acute>ti ?n)\<rbrace>))
    (snd (InvalidMem,
          \<lbrace>array_in_bound (\<acute>tarr ?n)
                    (\<acute>ti ?n)\<rbrace>))
    (Cond
      \<lbrace>MAXSUM <= array_nth (\<acute>tarr ?n) (\<acute>ti ?n) |
               MAXSUM <= \<acute>tsum ?n\<rbrace>
      (Seq (Basic (%s. s(| tsum := (tsum s)(?n := MAXSUM) |))) Throw)
      Skip)))
                                   (Basic
                                     (%s. s
   (| ti := (ti s)(?n := ti s ?n + 1) |)))))
                               Skip))
                        (Call (''lock'', ?n)))
                   (Basic (%s. s(| gsum := gsum s + tsum s ?n |))))
              (Basic (%s. s(| gdone := gdone s || tid s ?n |))))
         (Call (''unlock'', ?n)))",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 47,
            template_app (template_hole 46, template_hole 45)))],
       template_equation
        (template_app
          (template_hole 43,
           template_app
            (template_app
              (template_hole 42,
               template_app
                (template_app
                  (template_hole 41,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 40, template_hole 39),
                                 template_hole 39),
                               template_hole 38),
                             template_hole 38),
                           template_hole 39),
                         template_hole 39),
                       template_hole 39),
                     template_hole 38)),
                 template_app
                  (template_app
                    (template_hole 41,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 40, template_hole 39),
                                   template_hole 38),
                                 template_hole 39),
                               template_hole 38),
                             template_hole 39),
                           template_hole 39),
                         template_hole 39),
                       template_hole 38)),
                   template_app
                    (template_app
                      (template_hole 41,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 40, template_hole 39),
                                     template_hole 38),
                                   template_hole 39),
                                 template_hole 39),
                               template_hole 38),
                             template_hole 39),
                           template_hole 39),
                         template_hole 38)),
                     template_app
                      (template_app
                        (template_hole 41,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 40, template_hole 39), template_hole 38),
                                     template_hole 38),
                                   template_hole 38),
                                 template_hole 38),
                               template_hole 39),
                             template_hole 39),
                           template_hole 38)),
                       template_app
                        (template_app
                          (template_hole 41,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 40, template_hole 38), template_hole 39),
 template_hole 38),
                                     template_hole 38),
                                   template_hole 39),
                                 template_hole 39),
                               template_hole 39),
                             template_hole 38)),
                         template_app
                          (template_app
                            (template_hole 41,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 40, template_hole 38), template_hole 39),
   template_hole 38),
 template_hole 38),
                                     template_hole 39),
                                   template_hole 39),
                                 template_hole 39),
                               template_hole 38)),
                           template_hole 37))))))),
             template_var 0)),
         template_app
          (template_hole 36,
           template_app
            (template_app
              (template_hole 35,
               template_app
                (template_app
                  (template_hole 35,
                   template_app
                    (template_app
                      (template_hole 35,
                       template_app
                        (template_app
                          (template_hole 35,
                           template_app
                            (template_app
                              (template_hole 35,
                               template_app
                                (template_app
                                  (template_hole 35,
                                   template_app
                                    (template_hole 34, t_empty)),
                                 template_app (template_hole 34, t_empty))),
                             template_app
                              (template_app
                                (template_hole 27,
                                 template_app
                                  (template_app
                                    (template_hole 26,
                                     template_app
(template_hole 25, t_empty)),
                                   template_app
                                    (template_app
(template_hole 35,
 template_app
  (template_app
    (template_hole 35,
     template_app
      (template_app
        (template_app
          (template_hole 22,
           template_app
            (template_hole 21,
             template_app
              (template_app (template_hole 20, template_hole 19),
               template_app (template_hole 25, t_empty)))),
         template_app
          (template_hole 16,
           template_app
            (template_app (template_hole 20, template_hole 19),
             template_app (template_hole 25, t_empty)))),
       template_app (template_hole 34, t_empty))),
   template_app
    (template_app
      (template_app
        (template_hole 22,
         template_app
          (template_hole 21,
           template_app
            (template_app (template_hole 20, template_hole 19),
             template_app (template_hole 25, t_empty)))),
       template_app
        (template_hole 16,
         template_app
          (template_app (template_hole 20, template_hole 19),
           template_app (template_hole 25, t_empty)))),
     template_app
      (template_app
        (template_app
          (template_hole 13, template_app (template_hole 25, t_empty)),
         template_app
          (template_app
            (template_hole 35, template_app (template_hole 34, t_empty)),
           template_hole 9)),
       template_hole 8)))),
                                     template_app
(template_hole 34, t_empty)))),
                               template_hole 8))),
                         template_app
                          (template_hole 6,
                           template_app
                            (template_app
                              (template_hole 42,
                               template_app
                                (template_app
                                  (template_hole 41,
                                   template_app
                                    (template_app
(template_app
  (template_app
    (template_app
      (template_app
        (template_app
          (template_app (template_hole 40, template_hole 38),
           template_hole 38),
         template_hole 39),
       template_hole 39),
     template_hole 38),
   template_hole 39),
 template_hole 39),
                                     template_hole 38)),
                                 template_app
                                  (template_app
                                    (template_hole 41,
                                     template_app
(template_app
  (template_app
    (template_app
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 40, template_hole 39),
             template_hole 39),
           template_hole 39),
         template_hole 39),
       template_hole 38),
     template_hole 39),
   template_hole 39),
 template_hole 38)),
                                   template_app
                                    (template_app
(template_hole 41,
 template_app
  (template_app
    (template_app
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app (template_hole 40, template_hole 39),
               template_hole 39),
             template_hole 38),
           template_hole 38),
         template_hole 38),
       template_hole 39),
     template_hole 39),
   template_hole 38)),
                                     template_app
(template_app
  (template_hole 41,
   template_app
    (template_app
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 40, template_hole 39),
                 template_hole 39),
               template_hole 38),
             template_hole 39),
           template_hole 38),
         template_hole 39),
       template_hole 39),
     template_hole 38)),
 template_hole 37))))),
                             template_var 0)))),
                     template_app (template_hole 34, t_empty))),
                 template_app (template_hole 34, t_empty))),
             template_app
              (template_hole 6,
               template_app
                (template_app
                  (template_hole 42,
                   template_app
                    (template_app
                      (template_hole 41,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 40, template_hole 39),
                                     template_hole 38),
                                   template_hole 39),
                                 template_hole 38),
                               template_hole 39),
                             template_hole 39),
                           template_hole 39),
                         template_hole 38)),
                     template_app
                      (template_app
                        (template_hole 41,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 40, template_hole 38), template_hole 39),
                                     template_hole 39),
                                   template_hole 39),
                                 template_hole 38),
                               template_hole 39),
                             template_hole 39),
                           template_hole 38)),
                       template_app
                        (template_app
                          (template_hole 41,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 40, template_hole 38), template_hole 38),
 template_hole 39),
                                     template_hole 39),
                                   template_hole 38),
                                 template_hole 39),
                               template_hole 39),
                             template_hole 38)),
                         template_app
                          (template_app
                            (template_hole 41,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 40, template_hole 39), template_hole 39),
   template_hole 39),
 template_hole 39),
                                     template_hole 38),
                                   template_hole 39),
                                 template_hole 39),
                               template_hole 38)),
                           template_app
                            (template_app
                              (template_hole 41,
                               template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app
      (template_app (template_hole 40, template_hole 39), template_hole 39),
     template_hole 38),
   template_hole 38),
 template_hole 38),
                                     template_hole 39),
                                   template_hole 39),
                                 template_hole 38)),
                             template_app
                              (template_app
                                (template_hole 41,
                                 template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app
      (template_app
        (template_app (template_hole 40, template_hole 39),
         template_hole 39),
       template_hole 38),
     template_hole 39),
   template_hole 38),
 template_hole 39),
                                     template_hole 39),
                                   template_hole 38)),
                               template_hole 37))))))),
                 template_var 0))))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "?n < 2 ==>
      \<Theta> (''sumarr'', ?n) =
      Some
       [AnnComp
         (AnnComp
           (AnnComp
             (AnnComp
               (AnnComp
                 (AnnComp
                   (AnnExpr
                     \<lbrace>(\<acute>lock_inv &
                               \<acute>tarr_inv ?n &
                               \<acute>garr_inv ?n &
                               \<acute>tid ?n = word_of_nat ?n + 1) &
                              \<acute>sumarr_inv_till_lock ?n\<rbrace>)
                   (AnnExpr
                     \<lbrace>\<acute>tsum ?n = 0 &
                              (\<acute>lock_inv &
                               \<acute>tarr_inv ?n &
                               \<acute>garr_inv ?n &
                               \<acute>tid ?n = word_of_nat ?n + 1) &
                              \<acute>sumarr_inv_till_lock ?n\<rbrace>))
                 (AnnComp
                   (AnnWhile
                     \<lbrace>\<acute>tsum ?n = 0 &
                              (\<acute>lock_inv &
                               \<acute>tarr_inv ?n &
                               \<acute>garr_inv ?n &
                               \<acute>tid ?n = word_of_nat ?n + 1) &
                              \<acute>ti ?n = 0 &
                              \<acute>sumarr_inv_till_lock ?n\<rbrace>
                     \<lbrace>(\<acute>lock_inv &
                               \<acute>tarr_inv ?n &
                               \<acute>garr_inv ?n &
                               \<acute>tid ?n = word_of_nat ?n + 1) &
                              \<acute>ti ?n <= NSUM &
                              \<acute>tsum ?n <= MAXSUM &
                              \<acute>tsum ?n =
                              local_sum
                               (take (unat (\<acute>ti ?n))
                                 (\<acute>tarr ?n)) &
                              \<acute>sumarr_inv_till_lock ?n\<rbrace>
                     (AnnComp
                       (AnnComp
                         (AnnRec
                           \<lbrace>(\<acute>lock_inv &
                                     \<acute>tarr_inv ?n &
                                     \<acute>garr_inv ?n &
                                     \<acute>tid ?n = word_of_nat ?n + 1) &
                                    \<acute>ti ?n < NSUM &
                                    \<acute>tsum ?n <= MAXSUM &
                                    \<acute>tsum ?n =
                                    local_sum
                                     (take (unat (\<acute>ti ?n))
 (\<acute>tarr ?n)) &
                                    \<acute>sumarr_inv_till_lock ?n\<rbrace>
                           (AnnExpr
                             \<lbrace>(\<acute>lock_inv &
 \<acute>tarr_inv ?n &
 \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
\<acute>ti ?n < NSUM &
\<acute>tsum ?n <= MAXSUM &
\<acute>tsum ?n =
local_sum (take (unat (\<acute>ti ?n)) (\<acute>tarr ?n)) &
\<acute>sumarr_inv_till_lock ?n\<rbrace>))
                         (AnnRec
                           \<lbrace>(\<acute>lock_inv &
                                     \<acute>tarr_inv ?n &
                                     \<acute>garr_inv ?n &
                                     \<acute>tid ?n = word_of_nat ?n + 1) &
                                    \<acute>ti ?n < NSUM &
                                    local_sum
                                     (take (unat (\<acute>ti ?n))
 (\<acute>tarr ?n))
                                    <= MAXSUM &
                                    (\<acute>tsum ?n < MAXSUM &
                                     array_nth (\<acute>tarr ?n)
(\<acute>ti ?n)
                                     < MAXSUM -->
                                     \<acute>tsum ?n =
                                     local_sum
(take (Suc (unat (\<acute>ti ?n))) (\<acute>tarr ?n))) &
                                    (MAXSUM
                                     <= array_nth (\<acute>tarr ?n)
   (\<acute>ti ?n) |
                                     MAXSUM <= \<acute>tsum ?n -->
                                     local_sum (\<acute>tarr ?n) = MAXSUM) &
                                    \<acute>sumarr_inv_till_lock ?n\<rbrace>
                           (AnnBin
                             \<lbrace>(\<acute>lock_inv &
 \<acute>tarr_inv ?n &
 \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
\<acute>ti ?n < NSUM &
(\<acute>tsum ?n < MAXSUM &
 array_nth (\<acute>tarr ?n) (\<acute>ti ?n) < MAXSUM -->
 \<acute>tsum ?n =
 local_sum (take (Suc (unat (\<acute>ti ?n))) (\<acute>tarr ?n))) &
(MAXSUM <= array_nth (\<acute>tarr ?n) (\<acute>ti ?n) |
 MAXSUM <= \<acute>tsum ?n -->
 local_sum (\<acute>tarr ?n) = MAXSUM) &
\<acute>sumarr_inv_till_lock ?n\<rbrace>
                             (AnnComp
                               (AnnExpr
                                 \<lbrace>(\<acute>lock_inv &
     \<acute>tarr_inv ?n &
     \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
    \<acute>ti ?n < NSUM &
    local_sum (\<acute>tarr ?n) = MAXSUM &
    \<acute>sumarr_inv_till_lock ?n\<rbrace>)
                               (AnnExpr
                                 \<lbrace>(\<acute>lock_inv &
     \<acute>tarr_inv ?n &
     \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
    \<acute>ti ?n < NSUM &
    \<acute>tsum ?n <= MAXSUM &
    \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
    \<acute>sumarr_inv_till_lock ?n\<rbrace>))
                             (AnnExpr
                               \<lbrace>(\<acute>lock_inv &
   \<acute>tarr_inv ?n &
   \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
  \<acute>ti ?n < NSUM &
  \<acute>tsum ?n <= MAXSUM &
  \<acute>tsum ?n =
  local_sum (take (Suc (unat (\<acute>ti ?n))) (\<acute>tarr ?n)) &
  \<acute>sumarr_inv_till_lock ?n\<rbrace>))))
                       (AnnExpr
                         \<lbrace>(\<acute>lock_inv &
                                   \<acute>tarr_inv ?n &
                                   \<acute>garr_inv ?n &
                                   \<acute>tid ?n = word_of_nat ?n + 1) &
                                  \<acute>ti ?n < NSUM &
                                  \<acute>tsum ?n <= MAXSUM &
                                  \<acute>tsum ?n =
                                  local_sum
                                   (take (Suc (unat (\<acute>ti ?n)))
                                     (\<acute>tarr ?n)) &
                                  \<acute>sumarr_inv_till_lock
                                   ?n\<rbrace>)))
                   (AnnExpr
                     \<lbrace>(\<acute>lock_inv &
                               \<acute>tarr_inv ?n &
                               \<acute>garr_inv ?n &
                               \<acute>tid ?n = word_of_nat ?n + 1) &
                              \<acute>tsum ?n =
                              local_sum (\<acute>tarr ?n) &
                              \<acute>sumarr_inv_till_lock ?n\<rbrace>)))
               (AnnCall
                 \<lbrace>(\<acute>lock_inv &
                           \<acute>tarr_inv ?n &
                           \<acute>garr_inv ?n &
                           \<acute>tid ?n = word_of_nat ?n + 1) &
                          \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                          \<acute>sumarr_inv_till_lock ?n\<rbrace>
                 0))
             (AnnExpr
               \<lbrace>(\<acute>lock_inv &
                         \<acute>tarr_inv ?n &
                         \<acute>garr_inv ?n &
                         \<acute>tid ?n = word_of_nat ?n + 1) &
                        \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                        \<acute>glock = 1 &
                        \<acute>ghost_lock ?n &
                        \<acute>sumarr_inv_till_lock ?n\<rbrace>))
           (AnnExpr
             \<lbrace>(\<acute>lock_inv &
                       \<acute>tarr_inv ?n &
                       \<acute>garr_inv ?n &
                       \<acute>tid ?n = word_of_nat ?n + 1) &
                      \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                      \<acute>glock = 1 &
                      \<acute>ghost_lock ?n &
                      \<acute>sumarr_in_lock1 ?n\<rbrace>))
         (AnnCall
           \<lbrace>(\<acute>lock_inv &
                     \<acute>tarr_inv ?n &
                     \<acute>garr_inv ?n &
                     \<acute>tid ?n = word_of_nat ?n + 1) &
                    \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                    \<acute>glock = 1 &
                    \<acute>ghost_lock ?n &
                    bit \<acute>gdone (unat (\<acute>tid ?n - 1)) &
                    \<acute>sumarr_in_lock2 ?n\<rbrace>
           0)]",
     template_implication
      ([template_inequation
         (less_than, template_var 0,
          template_app
           (template_hole 64,
            template_app (template_hole 63, template_hole 62)))],
       template_equation
        (template_app
          (template_hole 60,
           template_app
            (template_app
              (template_hole 59,
               template_app
                (template_app
                  (template_hole 58,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_hole 57, template_hole 56),
                                 template_hole 56),
                               template_hole 55),
                             template_hole 55),
                           template_hole 56),
                         template_hole 56),
                       template_hole 56),
                     template_hole 55)),
                 template_app
                  (template_app
                    (template_hole 58,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 57, template_hole 56),
                                   template_hole 55),
                                 template_hole 56),
                               template_hole 55),
                             template_hole 56),
                           template_hole 56),
                         template_hole 56),
                       template_hole 55)),
                   template_app
                    (template_app
                      (template_hole 58,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 57, template_hole 56),
                                     template_hole 55),
                                   template_hole 56),
                                 template_hole 56),
                               template_hole 55),
                             template_hole 56),
                           template_hole 56),
                         template_hole 55)),
                     template_app
                      (template_app
                        (template_hole 58,
                         template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app (template_hole 57, template_hole 56), template_hole 55),
                                     template_hole 55),
                                   template_hole 55),
                                 template_hole 55),
                               template_hole 56),
                             template_hole 56),
                           template_hole 55)),
                       template_app
                        (template_app
                          (template_hole 58,
                           template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app (template_hole 57, template_hole 55), template_hole 56),
 template_hole 55),
                                     template_hole 55),
                                   template_hole 56),
                                 template_hole 56),
                               template_hole 56),
                             template_hole 55)),
                         template_app
                          (template_app
                            (template_hole 58,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_app
  (template_app
    (template_app (template_hole 57, template_hole 55), template_hole 56),
   template_hole 55),
 template_hole 55),
                                     template_hole 56),
                                   template_hole 56),
                                 template_hole 56),
                               template_hole 55)),
                           template_hole 54))))))),
             template_var 0)),
         template_app
          (template_hole 53,
           template_app
            (template_app
              (template_hole 52,
               template_app
                (template_app
                  (template_hole 51,
                   template_app
                    (template_app
                      (template_hole 51,
                       template_app
                        (template_app
                          (template_hole 51,
                           template_app
                            (template_app
                              (template_hole 51,
                               template_app
                                (template_app
                                  (template_hole 51,
                                   template_app
                                    (template_app
(template_hole 51,
 template_app (template_hole 50, template_app (template_hole 49, t_empty))),
                                     template_app
(template_hole 50, template_app (template_hole 49, t_empty)))),
                                 template_app
                                  (template_app
                                    (template_hole 51,
                                     template_app
(template_app
  (template_app
    (template_hole 15, template_app (template_hole 49, t_empty)),
   template_app (template_hole 49, t_empty)),
 template_app
  (template_app
    (template_hole 51,
     template_app
      (template_app
        (template_hole 51,
         template_app
          (template_app
            (template_hole 9, template_app (template_hole 49, t_empty)),
           template_app
            (template_hole 50, template_app (template_hole 49, t_empty)))),
       template_app
        (template_app
          (template_hole 9, template_app (template_hole 49, t_empty)),
         template_app
          (template_app
            (template_app
              (template_hole 5, template_app (template_hole 49, t_empty)),
             template_app
              (template_app
                (template_hole 51,
                 template_app
                  (template_hole 50,
                   template_app (template_hole 49, t_empty))),
               template_app
                (template_hole 50,
                 template_app (template_hole 49, t_empty)))),
           template_app
            (template_hole 50,
             template_app (template_hole 49, t_empty)))))),
   template_app
    (template_hole 50, template_app (template_hole 49, t_empty))))),
                                   template_app
                                    (template_hole 50,
                                     template_app
(template_hole 49, t_empty))))),
                             template_app
                              (template_app
                                (template_hole 4,
                                 template_app (template_hole 49, t_empty)),
                               template_hole 42))),
                         template_app
                          (template_hole 50,
                           template_app (template_hole 49, t_empty)))),
                     template_app
                      (template_hole 50,
                       template_app (template_hole 49, t_empty)))),
                 template_app
                  (template_app
                    (template_hole 4,
                     template_app (template_hole 49, t_empty)),
                   template_hole 42))),
             template_hole 0))))),
    ("SumArr.sumarr_proc_simp_unfolded",
     "[AnnComp
        (AnnComp
          (AnnComp
            (AnnComp
              (AnnComp
                (AnnComp
                  (AnnExpr
                    \<lbrace>(\<acute>lock_inv &
                              \<acute>tarr_inv ?n &
                              \<acute>garr_inv ?n &
                              \<acute>tid ?n = word_of_nat ?n + 1) &
                             \<acute>sumarr_inv_till_lock ?n\<rbrace>)
                  (AnnExpr
                    \<lbrace>\<acute>tsum ?n = 0 &
                             (\<acute>lock_inv &
                              \<acute>tarr_inv ?n &
                              \<acute>garr_inv ?n &
                              \<acute>tid ?n = word_of_nat ?n + 1) &
                             \<acute>sumarr_inv_till_lock ?n\<rbrace>))
                (AnnComp
                  (AnnWhile
                    \<lbrace>\<acute>tsum ?n = 0 &
                             (\<acute>lock_inv &
                              \<acute>tarr_inv ?n &
                              \<acute>garr_inv ?n &
                              \<acute>tid ?n = word_of_nat ?n + 1) &
                             \<acute>ti ?n = 0 &
                             \<acute>sumarr_inv_till_lock ?n\<rbrace>
                    \<lbrace>(\<acute>lock_inv &
                              \<acute>tarr_inv ?n &
                              \<acute>garr_inv ?n &
                              \<acute>tid ?n = word_of_nat ?n + 1) &
                             \<acute>ti ?n <= NSUM &
                             \<acute>tsum ?n <= MAXSUM &
                             \<acute>tsum ?n =
                             local_sum
                              (take (unat (\<acute>ti ?n))
                                (\<acute>tarr ?n)) &
                             \<acute>sumarr_inv_till_lock ?n\<rbrace>
                    (AnnComp
                      (AnnComp
                        (AnnRec
                          \<lbrace>(\<acute>lock_inv &
                                    \<acute>tarr_inv ?n &
                                    \<acute>garr_inv ?n &
                                    \<acute>tid ?n = word_of_nat ?n + 1) &
                                   \<acute>ti ?n < NSUM &
                                   \<acute>tsum ?n <= MAXSUM &
                                   \<acute>tsum ?n =
                                   local_sum
                                    (take (unat (\<acute>ti ?n))
(\<acute>tarr ?n)) &
                                   \<acute>sumarr_inv_till_lock ?n\<rbrace>
                          (AnnExpr
                            \<lbrace>(\<acute>lock_inv &
\<acute>tarr_inv ?n &
\<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
                                     \<acute>ti ?n < NSUM &
                                     \<acute>tsum ?n <= MAXSUM &
                                     \<acute>tsum ?n =
                                     local_sum
(take (unat (\<acute>ti ?n)) (\<acute>tarr ?n)) &
                                     \<acute>sumarr_inv_till_lock
?n\<rbrace>))
                        (AnnRec
                          \<lbrace>(\<acute>lock_inv &
                                    \<acute>tarr_inv ?n &
                                    \<acute>garr_inv ?n &
                                    \<acute>tid ?n = word_of_nat ?n + 1) &
                                   \<acute>ti ?n < NSUM &
                                   local_sum
                                    (take (unat (\<acute>ti ?n))
(\<acute>tarr ?n))
                                   <= MAXSUM &
                                   (\<acute>tsum ?n < MAXSUM &
                                    array_nth (\<acute>tarr ?n)
                                     (\<acute>ti ?n)
                                    < MAXSUM -->
                                    \<acute>tsum ?n =
                                    local_sum
                                     (take (Suc (unat (\<acute>ti ?n)))
 (\<acute>tarr ?n))) &
                                   (MAXSUM
                                    <= array_nth (\<acute>tarr ?n)
  (\<acute>ti ?n) |
                                    MAXSUM <= \<acute>tsum ?n -->
                                    local_sum (\<acute>tarr ?n) = MAXSUM) &
                                   \<acute>sumarr_inv_till_lock ?n\<rbrace>
                          (AnnBin
                            \<lbrace>(\<acute>lock_inv &
\<acute>tarr_inv ?n &
\<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
                                     \<acute>ti ?n < NSUM &
                                     (\<acute>tsum ?n < MAXSUM &
array_nth (\<acute>tarr ?n) (\<acute>ti ?n) < MAXSUM -->
\<acute>tsum ?n =
local_sum (take (Suc (unat (\<acute>ti ?n))) (\<acute>tarr ?n))) &
                                     (MAXSUM
<= array_nth (\<acute>tarr ?n) (\<acute>ti ?n) |
MAXSUM <= \<acute>tsum ?n -->
local_sum (\<acute>tarr ?n) = MAXSUM) &
                                     \<acute>sumarr_inv_till_lock
?n\<rbrace>
                            (AnnComp
                              (AnnExpr
                                \<lbrace>(\<acute>lock_inv &
    \<acute>tarr_inv ?n &
    \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
   \<acute>ti ?n < NSUM &
   local_sum (\<acute>tarr ?n) = MAXSUM &
   \<acute>sumarr_inv_till_lock ?n\<rbrace>)
                              (AnnExpr
                                \<lbrace>(\<acute>lock_inv &
    \<acute>tarr_inv ?n &
    \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
   \<acute>ti ?n < NSUM &
   \<acute>tsum ?n <= MAXSUM &
   \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
   \<acute>sumarr_inv_till_lock ?n\<rbrace>))
                            (AnnExpr
                              \<lbrace>(\<acute>lock_inv &
  \<acute>tarr_inv ?n &
  \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
 \<acute>ti ?n < NSUM &
 \<acute>tsum ?n <= MAXSUM &
 \<acute>tsum ?n =
 local_sum (take (Suc (unat (\<acute>ti ?n))) (\<acute>tarr ?n)) &
 \<acute>sumarr_inv_till_lock ?n\<rbrace>))))
                      (AnnExpr
                        \<lbrace>(\<acute>lock_inv &
                                  \<acute>tarr_inv ?n &
                                  \<acute>garr_inv ?n &
                                  \<acute>tid ?n = word_of_nat ?n + 1) &
                                 \<acute>ti ?n < NSUM &
                                 \<acute>tsum ?n <= MAXSUM &
                                 \<acute>tsum ?n =
                                 local_sum
                                  (take (Suc (unat (\<acute>ti ?n)))
                                    (\<acute>tarr ?n)) &
                                 \<acute>sumarr_inv_till_lock ?n\<rbrace>)))
                  (AnnExpr
                    \<lbrace>(\<acute>lock_inv &
                              \<acute>tarr_inv ?n &
                              \<acute>garr_inv ?n &
                              \<acute>tid ?n = word_of_nat ?n + 1) &
                             \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                             \<acute>sumarr_inv_till_lock ?n\<rbrace>)))
              (AnnCall
                \<lbrace>(\<acute>lock_inv &
                          \<acute>tarr_inv ?n &
                          \<acute>garr_inv ?n &
                          \<acute>tid ?n = word_of_nat ?n + 1) &
                         \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                         \<acute>sumarr_inv_till_lock ?n\<rbrace>
                0))
            (AnnExpr
              \<lbrace>(\<acute>lock_inv &
                        \<acute>tarr_inv ?n &
                        \<acute>garr_inv ?n &
                        \<acute>tid ?n = word_of_nat ?n + 1) &
                       \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                       \<acute>glock = 1 &
                       \<acute>ghost_lock ?n &
                       \<acute>sumarr_inv_till_lock ?n\<rbrace>))
          (AnnExpr
            \<lbrace>(\<acute>lock_inv &
                      \<acute>tarr_inv ?n &
                      \<acute>garr_inv ?n &
                      \<acute>tid ?n = word_of_nat ?n + 1) &
                     \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                     \<acute>glock = 1 &
                     \<acute>ghost_lock ?n &
                     \<acute>sumarr_in_lock1 ?n\<rbrace>))
        (AnnCall
          \<lbrace>(\<acute>lock_inv &
                    \<acute>tarr_inv ?n &
                    \<acute>garr_inv ?n &
                    \<acute>tid ?n = word_of_nat ?n + 1) &
                   \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                   \<acute>glock = 1 &
                   \<acute>ghost_lock ?n &
                   bit \<acute>gdone (unat (\<acute>tid ?n - 1)) &
                   \<acute>sumarr_in_lock2 ?n\<rbrace>
          0)] !
      0 =
      AnnComp
       (AnnComp
         (AnnComp
           (AnnComp
             (AnnComp
               (AnnComp
                 (AnnExpr
                   \<lbrace>(\<acute>lock_inv &
                             \<acute>tarr_inv ?n &
                             \<acute>garr_inv ?n &
                             \<acute>tid ?n = word_of_nat ?n + 1) &
                            \<acute>sumarr_inv_till_lock ?n\<rbrace>)
                 (AnnExpr
                   \<lbrace>\<acute>tsum ?n = 0 &
                            (\<acute>lock_inv &
                             \<acute>tarr_inv ?n &
                             \<acute>garr_inv ?n &
                             \<acute>tid ?n = word_of_nat ?n + 1) &
                            \<acute>sumarr_inv_till_lock ?n\<rbrace>))
               (AnnComp
                 (AnnWhile
                   \<lbrace>\<acute>tsum ?n = 0 &
                            (\<acute>lock_inv &
                             \<acute>tarr_inv ?n &
                             \<acute>garr_inv ?n &
                             \<acute>tid ?n = word_of_nat ?n + 1) &
                            \<acute>ti ?n = 0 &
                            \<acute>sumarr_inv_till_lock ?n\<rbrace>
                   \<lbrace>(\<acute>lock_inv &
                             \<acute>tarr_inv ?n &
                             \<acute>garr_inv ?n &
                             \<acute>tid ?n = word_of_nat ?n + 1) &
                            \<acute>ti ?n <= NSUM &
                            \<acute>tsum ?n <= MAXSUM &
                            \<acute>tsum ?n =
                            local_sum
                             (take (unat (\<acute>ti ?n))
                               (\<acute>tarr ?n)) &
                            \<acute>sumarr_inv_till_lock ?n\<rbrace>
                   (AnnComp
                     (AnnComp
                       (AnnRec
                         \<lbrace>(\<acute>lock_inv &
                                   \<acute>tarr_inv ?n &
                                   \<acute>garr_inv ?n &
                                   \<acute>tid ?n = word_of_nat ?n + 1) &
                                  \<acute>ti ?n < NSUM &
                                  \<acute>tsum ?n <= MAXSUM &
                                  \<acute>tsum ?n =
                                  local_sum
                                   (take (unat (\<acute>ti ?n))
                                     (\<acute>tarr ?n)) &
                                  \<acute>sumarr_inv_till_lock ?n\<rbrace>
                         (AnnExpr
                           \<lbrace>(\<acute>lock_inv &
                                     \<acute>tarr_inv ?n &
                                     \<acute>garr_inv ?n &
                                     \<acute>tid ?n = word_of_nat ?n + 1) &
                                    \<acute>ti ?n < NSUM &
                                    \<acute>tsum ?n <= MAXSUM &
                                    \<acute>tsum ?n =
                                    local_sum
                                     (take (unat (\<acute>ti ?n))
 (\<acute>tarr ?n)) &
                                    \<acute>sumarr_inv_till_lock
                                     ?n\<rbrace>))
                       (AnnRec
                         \<lbrace>(\<acute>lock_inv &
                                   \<acute>tarr_inv ?n &
                                   \<acute>garr_inv ?n &
                                   \<acute>tid ?n = word_of_nat ?n + 1) &
                                  \<acute>ti ?n < NSUM &
                                  local_sum
                                   (take (unat (\<acute>ti ?n))
                                     (\<acute>tarr ?n))
                                  <= MAXSUM &
                                  (\<acute>tsum ?n < MAXSUM &
                                   array_nth (\<acute>tarr ?n)
                                    (\<acute>ti ?n)
                                   < MAXSUM -->
                                   \<acute>tsum ?n =
                                   local_sum
                                    (take (Suc (unat (\<acute>ti ?n)))
(\<acute>tarr ?n))) &
                                  (MAXSUM
                                   <= array_nth (\<acute>tarr ?n)
 (\<acute>ti ?n) |
                                   MAXSUM <= \<acute>tsum ?n -->
                                   local_sum (\<acute>tarr ?n) = MAXSUM) &
                                  \<acute>sumarr_inv_till_lock ?n\<rbrace>
                         (AnnBin
                           \<lbrace>(\<acute>lock_inv &
                                     \<acute>tarr_inv ?n &
                                     \<acute>garr_inv ?n &
                                     \<acute>tid ?n = word_of_nat ?n + 1) &
                                    \<acute>ti ?n < NSUM &
                                    (\<acute>tsum ?n < MAXSUM &
                                     array_nth (\<acute>tarr ?n)
(\<acute>ti ?n)
                                     < MAXSUM -->
                                     \<acute>tsum ?n =
                                     local_sum
(take (Suc (unat (\<acute>ti ?n))) (\<acute>tarr ?n))) &
                                    (MAXSUM
                                     <= array_nth (\<acute>tarr ?n)
   (\<acute>ti ?n) |
                                     MAXSUM <= \<acute>tsum ?n -->
                                     local_sum (\<acute>tarr ?n) = MAXSUM) &
                                    \<acute>sumarr_inv_till_lock ?n\<rbrace>
                           (AnnComp
                             (AnnExpr
                               \<lbrace>(\<acute>lock_inv &
   \<acute>tarr_inv ?n &
   \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
  \<acute>ti ?n < NSUM &
  local_sum (\<acute>tarr ?n) = MAXSUM &
  \<acute>sumarr_inv_till_lock ?n\<rbrace>)
                             (AnnExpr
                               \<lbrace>(\<acute>lock_inv &
   \<acute>tarr_inv ?n &
   \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
  \<acute>ti ?n < NSUM &
  \<acute>tsum ?n <= MAXSUM &
  \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
  \<acute>sumarr_inv_till_lock ?n\<rbrace>))
                           (AnnExpr
                             \<lbrace>(\<acute>lock_inv &
 \<acute>tarr_inv ?n &
 \<acute>garr_inv ?n & \<acute>tid ?n = word_of_nat ?n + 1) &
\<acute>ti ?n < NSUM &
\<acute>tsum ?n <= MAXSUM &
\<acute>tsum ?n =
local_sum (take (Suc (unat (\<acute>ti ?n))) (\<acute>tarr ?n)) &
\<acute>sumarr_inv_till_lock ?n\<rbrace>))))
                     (AnnExpr
                       \<lbrace>(\<acute>lock_inv &
                                 \<acute>tarr_inv ?n &
                                 \<acute>garr_inv ?n &
                                 \<acute>tid ?n = word_of_nat ?n + 1) &
                                \<acute>ti ?n < NSUM &
                                \<acute>tsum ?n <= MAXSUM &
                                \<acute>tsum ?n =
                                local_sum
                                 (take (Suc (unat (\<acute>ti ?n)))
                                   (\<acute>tarr ?n)) &
                                \<acute>sumarr_inv_till_lock ?n\<rbrace>)))
                 (AnnExpr
                   \<lbrace>(\<acute>lock_inv &
                             \<acute>tarr_inv ?n &
                             \<acute>garr_inv ?n &
                             \<acute>tid ?n = word_of_nat ?n + 1) &
                            \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                            \<acute>sumarr_inv_till_lock ?n\<rbrace>)))
             (AnnCall
               \<lbrace>(\<acute>lock_inv &
                         \<acute>tarr_inv ?n &
                         \<acute>garr_inv ?n &
                         \<acute>tid ?n = word_of_nat ?n + 1) &
                        \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                        \<acute>sumarr_inv_till_lock ?n\<rbrace>
               0))
           (AnnExpr
             \<lbrace>(\<acute>lock_inv &
                       \<acute>tarr_inv ?n &
                       \<acute>garr_inv ?n &
                       \<acute>tid ?n = word_of_nat ?n + 1) &
                      \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                      \<acute>glock = 1 &
                      \<acute>ghost_lock ?n &
                      \<acute>sumarr_inv_till_lock ?n\<rbrace>))
         (AnnExpr
           \<lbrace>(\<acute>lock_inv &
                     \<acute>tarr_inv ?n &
                     \<acute>garr_inv ?n &
                     \<acute>tid ?n = word_of_nat ?n + 1) &
                    \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                    \<acute>glock = 1 &
                    \<acute>ghost_lock ?n &
                    \<acute>sumarr_in_lock1 ?n\<rbrace>))
       (AnnCall
         \<lbrace>(\<acute>lock_inv &
                   \<acute>tarr_inv ?n &
                   \<acute>garr_inv ?n &
                   \<acute>tid ?n = word_of_nat ?n + 1) &
                  \<acute>tsum ?n = local_sum (\<acute>tarr ?n) &
                  \<acute>glock = 1 &
                  \<acute>ghost_lock ?n &
                  bit \<acute>gdone (unat (\<acute>tid ?n - 1)) &
                  \<acute>sumarr_in_lock2 ?n\<rbrace>
         0)",
     template_equation
      (template_app
        (template_app
          (template_hole 53,
           template_app
            (template_app
              (template_hole 52,
               template_app
                (template_app
                  (template_hole 51,
                   template_app
                    (template_app
                      (template_hole 51,
                       template_app
                        (template_app
                          (template_hole 51,
                           template_app
                            (template_app
                              (template_hole 51,
                               template_app
                                (template_app
                                  (template_hole 51,
                                   template_app
                                    (template_app
(template_hole 51,
 template_app (template_hole 50, template_app (template_hole 49, t_empty))),
                                     template_app
(template_hole 50, template_app (template_hole 49, t_empty)))),
                                 template_app
                                  (template_app
                                    (template_hole 51,
                                     template_app
(template_app
  (template_app
    (template_hole 15, template_app (template_hole 49, t_empty)),
   template_app (template_hole 49, t_empty)),
 template_app
  (template_app
    (template_hole 51,
     template_app
      (template_app
        (template_hole 51,
         template_app
          (template_app
            (template_hole 9, template_app (template_hole 49, t_empty)),
           template_app
            (template_hole 50, template_app (template_hole 49, t_empty)))),
       template_app
        (template_app
          (template_hole 9, template_app (template_hole 49, t_empty)),
         template_app
          (template_app
            (template_app
              (template_hole 5, template_app (template_hole 49, t_empty)),
             template_app
              (template_app
                (template_hole 51,
                 template_app
                  (template_hole 50,
                   template_app (template_hole 49, t_empty))),
               template_app
                (template_hole 50,
                 template_app (template_hole 49, t_empty)))),
           template_app
            (template_hole 50,
             template_app (template_hole 49, t_empty)))))),
   template_app
    (template_hole 50, template_app (template_hole 49, t_empty))))),
                                   template_app
                                    (template_hole 50,
                                     template_app
(template_hole 49, t_empty))))),
                             template_app
                              (template_app
                                (template_hole 4,
                                 template_app (template_hole 49, t_empty)),
                               template_hole 42))),
                         template_app
                          (template_hole 50,
                           template_app (template_hole 49, t_empty)))),
                     template_app
                      (template_hole 50,
                       template_app (template_hole 49, t_empty)))),
                 template_app
                  (template_app
                    (template_hole 4,
                     template_app (template_hole 49, t_empty)),
                   template_hole 42))),
             template_hole 0)),
         template_hole 42),
       template_app
        (template_app
          (template_hole 51,
           template_app
            (template_app
              (template_hole 51,
               template_app
                (template_app
                  (template_hole 51,
                   template_app
                    (template_app
                      (template_hole 51,
                       template_app
                        (template_app
                          (template_hole 51,
                           template_app
                            (template_app
                              (template_hole 51,
                               template_app
                                (template_hole 50,
                                 template_app (template_hole 49, t_empty))),
                             template_app
                              (template_hole 50,
                               template_app (template_hole 49, t_empty)))),
                         template_app
                          (template_app
                            (template_hole 51,
                             template_app
                              (template_app
                                (template_app
                                  (template_hole 15,
                                   template_app
                                    (template_hole 49, t_empty)),
                                 template_app (template_hole 49, t_empty)),
                               template_app
                                (template_app
                                  (template_hole 51,
                                   template_app
                                    (template_app
(template_hole 51,
 template_app
  (template_app (template_hole 9, template_app (template_hole 49, t_empty)),
   template_app
    (template_hole 50, template_app (template_hole 49, t_empty)))),
                                     template_app
(template_app (template_hole 9, template_app (template_hole 49, t_empty)),
 template_app
  (template_app
    (template_app
      (template_hole 5, template_app (template_hole 49, t_empty)),
     template_app
      (template_app
        (template_hole 51,
         template_app
          (template_hole 50, template_app (template_hole 49, t_empty))),
       template_app
        (template_hole 50, template_app (template_hole 49, t_empty)))),
   template_app
    (template_hole 50, template_app (template_hole 49, t_empty)))))),
                                 template_app
                                  (template_hole 50,
                                   template_app
                                    (template_hole 49, t_empty))))),
                           template_app
                            (template_hole 50,
                             template_app (template_hole 49, t_empty))))),
                     template_app
                      (template_app
                        (template_hole 4,
                         template_app (template_hole 49, t_empty)),
                       template_hole 42))),
                 template_app
                  (template_hole 50,
                   template_app (template_hole 49, t_empty)))),
             template_app
              (template_hole 50,
               template_app (template_hole 49, t_empty)))),
         template_app
          (template_app
            (template_hole 4, template_app (template_hole 49, t_empty)),
           template_hole 42))))]:
   (string * thm * template) list
### theory "Draft.SumArrMoreTemplates"
### 0.768s elapsed time, 1.041s cpu time, 0.110s GC time
val it = (): unit
