Loading theory "Draft.List-Interleavings" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe" via "Draft.CoCallImplTTree" via "Draft.TTreeAnalysisSig" via "Draft.TTree-HOLCF" via "Draft.TTree")
Loading theory "Draft.ConstOn" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CardArityTransformSafe" via "Draft.CardinalityAnalysisSpec")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Stream" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.ExtrEqs")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
Proofs for inductive predicate(s) "interleave'"
  Proving monotonicity ...
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
### theory "Draft.ConstOn"
### 0.044s elapsed time, 0.210s cpu time, 0.000s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### theory "HOL-Library.Function_Algebras"
### 0.135s elapsed time, 0.548s cpu time, 0.046s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Set_Algebras"
### 0.200s elapsed time, 0.782s cpu time, 0.046s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.ExtrEqs")
### theory "Draft.List-Interleavings"
### 0.353s elapsed time, 1.405s cpu time, 0.159s GC time
Loading theory "Draft.TTree" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe" via "Draft.CoCallImplTTree" via "Draft.TTreeAnalysisSig" via "Draft.TTree-HOLCF")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
### theory "HOL-Library.Stream"
### 0.902s elapsed time, 3.554s cpu time, 0.374s GC time
Loading theory "Draft.Set-Cpo" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl" via "Draft.Env-Set-Cpo")
instantiation
  set :: (type) below
  below_set == below :: 'a set => 'a set => bool
Found termination order: "size <*mlex*> {}"
### theory "Draft.Set-Cpo"
### 0.251s elapsed time, 0.856s cpu time, 0.601s GC time
Loading theory "Draft.Arity" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityAnalysisSig" via "Draft.AEnv")
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.987s elapsed time, 3.719s cpu time, 0.978s GC time
Loading theory "Draft.EtaExpansion" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityEtaExpansionSafe" via "Draft.EtaExpansionSafe")
instantiation
  Arity :: po
  below_Arity == below :: Arity => Arity => bool
Found termination order: "(%p. length (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
instantiation
  Arity :: zero
  zero_Arity == zero_class.zero :: Arity
### Ignoring conversion rule for operator Set.member
### Ignoring conversion rule for operator Set.member
instantiation
  Arity :: one
  one_Arity == one_class.one :: Arity
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "Draft.Arity"
### 0.209s elapsed time, 0.820s cpu time, 0.049s GC time
Loading theory "Draft.SestoftConf" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityEtaExpansionSafe" via "Draft.EtaExpansionSafe" via "Draft.Sestoft")
### theory "Draft.EtaExpansion"
### 0.129s elapsed time, 0.522s cpu time, 0.000s GC time
Loading theory "Draft.AEnv" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityAnalysisSig")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "substitute''"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
### theory "Draft.TTree"
### 1.187s elapsed time, 4.531s cpu time, 0.962s GC time
Loading theory "Draft.Env-Set-Cpo" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl")
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Env-Set-Cpo"
### 0.219s elapsed time, 0.866s cpu time, 0.107s GC time
Loading theory "Draft.AList-Utils-HOLCF" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl" via "Draft.CoCallFix" via "Draft.CoCallAnalysisBinds")
instantiation
  stack_elem :: pt
  permute_stack_elem == permute :: perm => stack_elem => stack_elem
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### theory "Draft.AEnv"
### 0.758s elapsed time, 2.965s cpu time, 0.356s GC time
Loading theory "Draft.AnalBinds" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe" via "Draft.CoCallImplTTree" via "Draft.TTreeAnalysisSig")
Found termination order: "size <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
### theory "Draft.AList-Utils-HOLCF"
### 0.500s elapsed time, 1.960s cpu time, 0.209s GC time
Loading theory "Draft.Cardinality-Domain" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CardArityTransformSafe" via "Draft.CardinalityAnalysisSpec" via "Draft.CardinalityAnalysisSig")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 2.183s elapsed time, 8.438s cpu time, 1.391s GC time
Loading theory "Draft.Templates" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.ExtrEqs")
### theory "Draft.Cardinality-Domain"
### 0.117s elapsed time, 0.446s cpu time, 0.092s GC time
Loading theory "Draft.CoCallGraph" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl" via "Draft.CoCallFix" via "Draft.CoCallAnalysisSig")
Found termination order: "size_list size <*mlex*> {}"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.095s elapsed time, 0.366s cpu time, 0.092s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.CallArityEnd2EndSafeTemplates")
Proofs for inductive predicate(s) "boring_step"
  Proving monotonicity ...
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Proofs for inductive predicate(s) "invariant"
  Proving monotonicity ...
Found termination order: "{}"
Found termination order: "{}"
locale ExpAnalysis
  fixes exp :: "exp => 'a -> 'b"
### Additional type variable(s) in specification of "AnalBinds_rel": 'a
### theory "Draft.SestoftConf"
### 1.458s elapsed time, 5.715s cpu time, 0.670s GC time
Loading theory "Draft.ArityStack" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityEtaExpansionSafe")
### Additional type variable(s) in specification of "AnalBinds_dom": 'a
Found termination order: "size_list (%p. size (snd p)) <*mlex*> {}"
### theory "Draft.AnalBinds"
### 0.775s elapsed time, 3.046s cpu time, 0.314s GC time
Loading theory "Draft.Sestoft" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityEtaExpansionSafe" via "Draft.EtaExpansionSafe")
Proofs for inductive predicate(s) "step"
  Proving monotonicity ...
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.705s elapsed time, 2.783s cpu time, 0.246s GC time
Loading theory "Draft.CardinalityAnalysisSig" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CardArityTransformSafe" via "Draft.CardinalityAnalysisSpec")
### theory "Draft.Sestoft"
### 0.219s elapsed time, 0.864s cpu time, 0.081s GC time
Loading theory "Draft.EtaExpansionSafe" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityEtaExpansionSafe")
instantiation
  CoCalls :: po
  below_CoCalls == below :: CoCalls => CoCalls => bool
Found termination order: "size_list size <*mlex*> {}"
### theory "Draft.EtaExpansionSafe"
### 0.314s elapsed time, 1.235s cpu time, 0.127s GC time
Loading theory "Draft.SestoftGC" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CardArityTransformSafe")
Found termination order: "size_list size <*mlex*> {}"
### theory "Draft.ArityStack"
### 0.638s elapsed time, 2.508s cpu time, 0.208s GC time
Loading theory "Draft.TTree-HOLCF" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe" via "Draft.CoCallImplTTree" via "Draft.TTreeAnalysisSig")
Proofs for inductive predicate(s) "gc_step"
  Proving monotonicity ...
Found termination order: "{}"
### Ambiguous input (line 284 of "$AFP/Call_Arity/CoCallGraph.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^fixed>ccSquare" ("_position" S))
###     ("_applC" ("_position" ccProd)
###       ("_cargs" ("_position" S) ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^const>Power.power_class.power2" ("_position" S))
###     ("_applC" ("_position" ccProd)
###       ("_cargs" ("_position" S) ("_position" S)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 286 of "$AFP/Call_Arity/CoCallGraph.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" ccField)
###       ("\<^const>CoCallGraph.ccSquare" ("_position" S)))
###     ("_position" S)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" ccField)
###       ("\<^const>Power.power_class.power2" ("_position" S)))
###     ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 289 of "$AFP/Call_Arity/CoCallGraph.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Porder.below_class.below" ("_position" G)
###       ("\<^const>Power.power_class.power2" ("_position" S)))
###     ("\<^const>Set.subset_eq"
###       ("_applC" ("_position" ccField) ("_position" G)) ("_position" S))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Porder.below_class.below" ("_position" G)
###       ("\<^const>CoCallGraph.ccSquare" ("_position" S)))
###     ("\<^const>Set.subset_eq"
###       ("_applC" ("_position" ccField) ("_position" G)) ("_position" S))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 292 of "$AFP/Call_Arity/CoCallGraph.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>CoCallGraph.cc_restr_sym"
###       ("\<^const>CoCallGraph.ccSquare" ("_position" S')) ("_position" S))
###     ("\<^const>CoCallGraph.ccSquare"
###       ("\<^const>Set.inter" ("_position" S') ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>CoCallGraph.cc_restr_sym"
###       ("\<^const>Power.power_class.power2" ("_position" S'))
###       ("_position" S))
###     ("\<^const>CoCallGraph.ccSquare"
###       ("\<^const>Set.inter" ("_position" S') ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>CoCallGraph.cc_restr_sym"
###       ("\<^const>CoCallGraph.ccSquare" ("_position" S')) ("_position" S))
###     ("\<^const>Power.power_class.power2"
###       ("\<^const>Set.inter" ("_position" S') ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>CoCallGraph.cc_restr_sym"
###       ("\<^const>Power.power_class.power2" ("_position" S'))
###       ("_position" S))
###     ("\<^const>Power.power_class.power2"
###       ("\<^const>Set.inter" ("_position" S') ("_position" S)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 295 of "$AFP/Call_Arity/CoCallGraph.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>CoCallGraph.ccSquare" ("\<^const>Set.empty"))
###     ("\<^const>Pcpo.pcpo_class.bottom")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Power.power_class.power2" ("\<^const>Set.empty"))
###     ("\<^const>Pcpo.pcpo_class.bottom")))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Proofs for inductive predicate(s) "list_pairs"
  Proving monotonicity ...
### theory "Draft.SestoftGC"
### 0.300s elapsed time, 1.173s cpu time, 0.145s GC time
Loading theory "Draft.Arity-Nominal" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityAnalysisSig")
### theory "Draft.CoCallGraph"
### 1.358s elapsed time, 5.328s cpu time, 0.518s GC time
Loading theory "Draft.CoCallAnalysisSig" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl" via "Draft.CoCallFix")
locale CardinalityPrognosis
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
locale CardinalityHeap
  fixes
    cHeap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => one\<^sub>\<bottom>"
### theory "Draft.CardinalityAnalysisSig"
### 0.654s elapsed time, 2.553s cpu time, 0.272s GC time
Loading theory "Draft.Cardinality-Domain-Lists" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe" via "Draft.TTreeAnalysisSpec")
instantiation
  Arity :: pure
  permute_Arity == permute :: perm => Arity => Arity
### theory "Draft.Arity-Nominal"
### 0.829s elapsed time, 3.154s cpu time, 1.318s GC time
Loading theory "Draft.ArityAnalysisSig" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform")
instantiation
  ttree :: (type) below
  below_ttree == below :: 'a ttree => 'a ttree => bool
locale CoCallAnalysis
  fixes ccExp :: "exp => Arity -> CoCalls"
locale CoCallAnalyisHeap
  fixes ccHeap :: "(Vars.var * exp) list => exp => Arity -> CoCalls"
### theory "Draft.CoCallAnalysisSig"
### 0.977s elapsed time, 3.734s cpu time, 1.377s GC time
Loading theory "Draft.CoCallGraph-Nominal" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl" via "Draft.CoCallFix" via "Draft.CoCallAnalysisBinds")
### theory "Draft.TTree-HOLCF"
### 1.263s elapsed time, 4.855s cpu time, 1.522s GC time
Loading theory "Draft.CoCallGraph-TTree" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe" via "Draft.CoCallImplTTree")
instantiation
  CoCalls :: pt
  permute_CoCalls == permute :: perm => CoCalls => CoCalls
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Draft.CoCallGraph-Nominal"
### 0.300s elapsed time, 1.187s cpu time, 0.067s GC time
Loading theory "Draft.TTreeAnalysisSig" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe" via "Draft.CoCallImplTTree")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Proofs for inductive predicate(s) "valid_listsp"
  Proving monotonicity ...
### theory "Draft.Cardinality-Domain-Lists"
### 1.395s elapsed time, 5.388s cpu time, 1.501s GC time
Loading theory "Draft.CoCallAnalysisBinds" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl" via "Draft.CoCallFix")
locale ArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
locale ArityAnalysisHeap
  fixes
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
locale EdomArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "EdomArityAnalysis Aexp"
locale ArityAnalysisHeapEqvt
  fixes
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisHeapEqvt Aheap"
### theory "Draft.ArityAnalysisSig"
### 0.660s elapsed time, 2.603s cpu time, 0.183s GC time
Loading theory "Draft.ArityAnalysisAbinds" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl" via "Draft.CoCallFix" via "Draft.ArityAnalysisFix")
locale ArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
Proofs for inductive predicate(s) "valid_lists'"
  Proving monotonicity ...
### theory "Draft.CoCallGraph-TTree"
### 0.656s elapsed time, 2.584s cpu time, 0.209s GC time
Loading theory "Draft.ArityAnalysisStack" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CardArityTransformSafe")
Found termination order: "size_list size <*mlex*> {}"
locale EdomArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "EdomArityAnalysis Aexp"
### theory "Draft.ArityAnalysisAbinds"
### 0.776s elapsed time, 2.905s cpu time, 1.490s GC time
Loading theory "Draft.ArityAnalysisSpec" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CardArityTransformSafe" via "Draft.CardinalityAnalysisSpec")
locale SubstArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "SubstArityAnalysis Aexp"
locale ArityAnalysisSafe
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisSafe Aexp"
locale ArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
locale ArityAnalysisHeapSafe
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisHeapSafe Aexp Aheap"
locale TTreeAnalysis
  fixes Texp :: "exp => Arity -> Vars.var ttree"
### theory "Draft.TTreeAnalysisSig"
### 1.205s elapsed time, 4.600s cpu time, 1.629s GC time
Loading theory "Draft.ArityAnalysisFix" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl" via "Draft.CoCallFix")
locale ArityAnalysisLetSafe
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisLetSafe Aexp Aheap"
locale ArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
locale ArityAnalysisLetSafeNoCard
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisLetSafeNoCard Aexp Aheap"
locale SubstArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "SubstArityAnalysis Aexp"
locale ArityAnalysisSafe
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisSafe Aexp"
locale ArityAnalysisLetSafe
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisLetSafe Aexp Aheap"
### theory "Draft.ArityAnalysisSpec"
### 0.331s elapsed time, 1.296s cpu time, 0.083s GC time
Loading theory "Draft.CardinalityAnalysisSpec" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CardArityTransformSafe")
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
locale EdomArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "EdomArityAnalysis Aexp"
### theory "Draft.ArityAnalysisFix"
### 0.152s elapsed time, 0.608s cpu time, 0.000s GC time
Loading theory "Draft.ArityAnalysisFixProps" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplSafe")
locale EdomArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "EdomArityAnalysis Aexp"
### theory "Draft.ArityAnalysisStack"
### 1.009s elapsed time, 3.831s cpu time, 1.487s GC time
Loading theory "Draft.ArityConsistent" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CardArityTransformSafe")
locale SubstArityAnalysis
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "SubstArityAnalysis Aexp"
### theory "Draft.ArityAnalysisFixProps"
### 0.203s elapsed time, 0.790s cpu time, 0.064s GC time
Loading theory "Draft.CoCallAritySig" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplSafe" via "Draft.CoCallAnalysisSpec")
locale CoCallAnalysis
  fixes ccExp :: "exp => Arity -> CoCalls"
### Ambiguous input (line 12 of "$AFP/Call_Arity/CoCallAnalysisBinds.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Cfun.cfun.Rep_cfun"
###       ("_applC" ("_position" ccBind)
###         ("_cargs" ("_position" v) ("_position" e)))
###       ("_tuple" ("_position" ae) ("_tuple_arg" ("_position" G))))
###     ("\<^const>HOL.If"
###       ("\<^const>HOL.disj"
###         ("\<^const>CoCallGraph.notInCC" ("_position" v) ("_position" v)
###           ("_position" G))
###         ("\<^const>HOL.Not" ("_applC" ("_position" isVal) ("_position" e))))
###       ("\<^const>CoCallGraph.cc_restr_sym"
###         ("_applC"
###           ("\<^const>local.ccExp_bot_syn"
###             ("_applC" ("_position" ae) ("_position" v)))
###           ("_position" e))
###         ("_applC" ("_position" fv) ("_position" e)))
###       ("\<^const>Power.power_class.power2"
###         ("_applC" ("_position" fv) ("_position" e))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Cfun.cfun.Rep_cfun"
###       ("_applC" ("_position" ccBind)
###         ("_cargs" ("_position" v) ("_position" e)))
###       ("_tuple" ("_position" ae) ("_tuple_arg" ("_position" G))))
###     ("\<^const>HOL.If"
###       ("\<^const>HOL.disj"
###         ("\<^const>CoCallGraph.notInCC" ("_position" v) ("_position" v)
###           ("_position" G))
###         ("\<^const>HOL.Not" ("_applC" ("_position" isVal) ("_position" e))))
###       ("\<^const>CoCallGraph.cc_restr_sym"
###         ("_applC"
###           ("\<^const>local.ccExp_bot_syn"
###             ("_applC" ("_position" ae) ("_position" v)))
###           ("_position" e))
###         ("_applC" ("_position" fv) ("_position" e)))
###       ("\<^const>CoCallGraph.ccSquare"
###         ("_applC" ("_position" fv) ("_position" e))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.CoCallAnalysisBinds"
### 1.567s elapsed time, 6.017s cpu time, 1.708s GC time
Loading theory "Draft.TTreeAnalysisSpec" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe")
locale CardinalityPrognosisEdom
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
  assumes "CardinalityPrognosisEdom prognosis"
locale CardinalityPrognosisShape
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
  assumes "CardinalityPrognosisShape prognosis"
locale CardinalityPrognosisApp
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
  assumes "CardinalityPrognosisApp prognosis"
locale CardinalityPrognosisLam
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
  assumes "CardinalityPrognosisLam prognosis"
locale CardinalityPrognosisVar
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
  assumes "CardinalityPrognosisVar prognosis"
locale CoCallArity
  fixes ccExp :: "exp => Arity -> CoCalls"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
### theory "Draft.CoCallAritySig"
### 0.366s elapsed time, 1.459s cpu time, 0.072s GC time
locale CardinalityPrognosisIfThenElse
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
  assumes "CardinalityPrognosisIfThenElse prognosis"
Loading theory "Draft.CoCallAnalysisSpec" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplSafe")
locale ArityAnalysisLetSafe
  fixes Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisLetSafe Aexp Aheap"
locale CardinalityPrognosisLet
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
    and
    cHeap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => one\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "CardinalityPrognosisLet prognosis cHeap Aheap"
Proofs for inductive predicate(s) "stack_consistent"
  Proving monotonicity ...
locale CardinalityHeapSafe
  fixes
    cHeap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => one\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "CardinalityHeapSafe cHeap Aheap"
Proofs for inductive predicate(s) "a_consistent"
locale CardinalityPrognosisSafe
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
    and
    cHeap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => one\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "CardinalityPrognosisSafe prognosis cHeap Aheap Aexp"
### theory "Draft.CardinalityAnalysisSpec"
### 0.720s elapsed time, 2.842s cpu time, 0.203s GC time
Loading theory "Draft.CoCallImplTTree" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CoCallImplTTreeSafe")
  Proving monotonicity ...
### theory "Draft.ArityConsistent"
### 0.782s elapsed time, 3.097s cpu time, 0.203s GC time
Loading theory "Draft.TTreeImplCardinality" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.TTreeImplCardinalitySafe")
locale CoCallArityEdom
  fixes ccExp :: "exp => Arity -> CoCalls"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "CoCallArityEdom Aexp"
locale CoCallAritySafe
  fixes ccExp :: "exp => Arity -> CoCalls"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and ccHeap :: "(Vars.var * exp) list => exp => Arity -> CoCalls"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "CoCallAritySafe ccExp Aexp ccHeap Aheap"
### theory "Draft.CoCallAnalysisSpec"
### 0.358s elapsed time, 1.409s cpu time, 0.131s GC time
Loading theory "Draft.TransformTools" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.AbstractTransform")
locale TTreeAnalysisCarrier
  fixes Texp :: "exp => Arity -> Vars.var ttree"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "TTreeAnalysisCarrier Texp Aexp"
locale TTreeAnalysisSafe
  fixes Texp :: "exp => Arity -> Vars.var ttree"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "TTreeAnalysisSafe Texp Aexp"
locale TTreeAnalysisCardinalityHeap
  fixes Texp :: "exp => Arity -> Vars.var ttree"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and Theap :: "(Vars.var * exp) list => exp => Arity -> Vars.var ttree"
  assumes "TTreeAnalysisCardinalityHeap Texp Aexp Aheap Theap"
### theory "Draft.TTreeAnalysisSpec"
### 0.865s elapsed time, 3.418s cpu time, 0.207s GC time
Loading theory "Draft.CoCallFix" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.CoCallAnalysisImpl")
locale TTreeAnalysis
  fixes Texp :: "exp => Arity -> Vars.var ttree"
locale CoCallArity
  fixes ccExp :: "exp => Arity -> CoCalls"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
### theory "Draft.CoCallImplTTree"
### 0.910s elapsed time, 3.596s cpu time, 0.221s GC time
Loading theory "Draft.CoCallImplTTreeSafe" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe")
Found termination order: "{}"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
locale supp_bounded_transform
  fixes trans :: "'a => exp => exp"
  assumes "supp_bounded_transform trans"
### theory "Draft.TransformTools"
### 0.807s elapsed time, 3.190s cpu time, 0.229s GC time
Loading theory "Draft.AbstractTransform" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform")
locale AbstractAnalProp
  fixes PropApp :: "'a => 'a"
    and PropLam :: "'a => 'a"
    and AnalLet :: "(Vars.var * exp) list => exp => 'a => 'b"
    and PropLetBody :: "'b => 'a"
    and PropLetHeap :: "'b => Vars.var => 'a\<^sub>\<bottom>"
    and PropIfScrut :: "'a => 'a"
  assumes
    "AbstractAnalProp PropApp PropLam AnalLet PropLetBody PropLetHeap
      PropIfScrut"
locale AbstractAnalPropSubst
  fixes PropApp :: "'a => 'a"
    and PropLam :: "'a => 'a"
    and AnalLet :: "(Vars.var * exp) list => exp => 'a => 'b"
    and PropLetBody :: "'b => 'a"
    and PropLetHeap :: "'b => Vars.var => 'a\<^sub>\<bottom>"
    and PropIfScrut :: "'a => 'a"
  assumes
    "AbstractAnalPropSubst PropApp PropLam AnalLet PropLetBody PropLetHeap
      PropIfScrut"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
locale AbstractTransform
  fixes PropApp :: "'a => 'a"
    and PropLam :: "'a => 'a"
    and AnalLet :: "(Vars.var * exp) list => exp => 'a => 'b"
    and PropLetBody :: "'b => 'a"
    and PropLetHeap :: "'b => Vars.var => 'a\<^sub>\<bottom>"
    and PropIfScrut :: "'a => 'a"
    and TransVar :: "'a => Vars.var => exp"
    and TransApp :: "'a => exp => Vars.var => exp"
    and TransLam :: "'a => Vars.var => exp => exp"
    and TransLet :: "'b => (Vars.var * exp) list => exp => exp"
  assumes
    "AbstractTransform PropApp PropLam AnalLet PropLetBody PropLetHeap
      PropIfScrut TransVar TransApp TransLam TransLet"
locale CoCallArityAnalysis
  fixes
    cccExp ::
      "exp => Arity -> (Vars.var => Arity\<^sub>\<bottom>) * CoCalls"
Found termination order: "{}"
### theory "Draft.TTreeImplCardinality"
### 1.147s elapsed time, 4.524s cpu time, 0.367s GC time
Loading theory "Draft.TTreeImplCardinalitySafe" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe")
locale CoCallArityAnalysis
  fixes
    cccExp ::
      "exp => Arity -> (Vars.var => Arity\<^sub>\<bottom>) * CoCalls"
locale CoCallArityEdom
  fixes ccExp :: "exp => Arity -> CoCalls"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "CoCallArityEdom Aexp"
locale CoCallArityAnalysis
  fixes
    cccExp ::
      "exp => Arity -> (Vars.var => Arity\<^sub>\<bottom>) * CoCalls"
locale CoCallAritySafe
  fixes ccExp :: "exp => Arity -> CoCalls"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and ccHeap :: "(Vars.var * exp) list => exp => Arity -> CoCalls"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "CoCallAritySafe ccExp Aexp ccHeap Aheap"
### theory "Draft.CoCallImplTTreeSafe"
### 0.683s elapsed time, 2.693s cpu time, 0.233s GC time
Loading theory "Draft.ArityEtaExpansion" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform" via "Draft.ArityEtaExpansionSafe")
locale CoCallArityAnalysis
  fixes
    cccExp ::
      "exp => Arity -> (Vars.var => Arity\<^sub>\<bottom>) * CoCalls"
locale AbstractTransformSubst
  fixes PropApp :: "'a => 'a"
    and PropLam :: "'a => 'a"
    and AnalLet :: "(Vars.var * exp) list => exp => 'a => 'b"
    and PropLetBody :: "'b => 'a"
    and PropLetHeap :: "'b => Vars.var => 'a\<^sub>\<bottom>"
    and PropIfScrut :: "'a => 'a"
    and TransVar :: "'a => Vars.var => exp"
    and TransApp :: "'a => exp => Vars.var => exp"
    and TransLam :: "'a => Vars.var => exp => exp"
    and TransLet :: "'b => (Vars.var * exp) list => exp => exp"
  assumes
    "AbstractTransformSubst PropApp PropLam AnalLet PropLetBody PropLetHeap
      PropIfScrut TransVar TransApp TransLam TransLet"
### theory "Draft.CoCallFix"
### 1.147s elapsed time, 4.523s cpu time, 0.390s GC time
Loading theory "Draft.CoCallAnalysisImpl" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End")
locale AbstractTransformBound
  fixes PropApp :: "'a => 'a"
    and PropLam :: "'a => 'a"
    and AnalLet :: "(Vars.var * exp) list => exp => 'a => 'b"
    and PropLetBody :: "'b => 'a"
    and PropLetHeap :: "'b => Vars.var => 'a\<^sub>\<bottom>"
    and PropIfScrut :: "'a => 'a"
    and trans :: "'c => exp => exp"
    and PropLetHeapTrans :: "'b => Vars.var => 'c\<^sub>\<bottom>"
  assumes
    "AbstractTransformBound PropApp PropLam AnalLet PropLetBody PropLetHeap
      PropIfScrut trans PropLetHeapTrans"
locale TTreeAnalysisCarrier
  fixes Texp :: "exp => Arity -> Vars.var ttree"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "TTreeAnalysisCarrier Texp Aexp"
locale TTreeAnalysisSafe
  fixes Texp :: "exp => Arity -> Vars.var ttree"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "TTreeAnalysisSafe Texp Aexp"
locale AbstractTransformBoundSubst
  fixes PropApp :: "'a => 'a"
    and PropLam :: "'a => 'a"
    and AnalLet :: "(Vars.var * exp) list => exp => 'a => 'b"
    and PropLetBody :: "'b => 'a"
    and PropLetHeap :: "'b => Vars.var => 'a\<^sub>\<bottom>"
    and PropIfScrut :: "'a => 'a"
    and trans :: "'c => exp => exp"
    and PropLetHeapTrans :: "'b => Vars.var => 'c\<^sub>\<bottom>"
  assumes
    "AbstractTransformBoundSubst PropApp PropLam AnalLet PropLetBody
      PropLetHeap PropIfScrut trans PropLetHeapTrans"
### theory "Draft.AbstractTransform"
### 0.980s elapsed time, 3.865s cpu time, 0.316s GC time
locale TTreeAnalysisCardinalityHeap
  fixes Texp :: "exp => Arity -> Vars.var ttree"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and Theap :: "(Vars.var * exp) list => exp => Arity -> Vars.var ttree"
  assumes "TTreeAnalysisCardinalityHeap Texp Aexp Aheap Theap"
### theory "Draft.TTreeImplCardinalitySafe"
### 0.893s elapsed time, 3.486s cpu time, 0.307s GC time
### theory "Draft.ArityEtaExpansion"
### 0.623s elapsed time, 2.318s cpu time, 0.221s GC time
Loading theory "Draft.ArityEtaExpansionSafe" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End" via "Draft.ArityTransform")
Found termination order: "{}"
### theory "Draft.ArityEtaExpansionSafe"
### 0.563s elapsed time, 1.174s cpu time, 0.126s GC time
Loading theory "Draft.ArityTransform" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe" via "Draft.CallArityEnd2End")
locale CoCallAnalysisImpl
### Ambiguous input (line 218 of "$AFP/Call_Arity/CoCallAnalysisImpl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>CoCallAnalysisImpl.CoCallAnalysisImpl.ccExp_syn''"
###         ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>Terms.Lam" ("_position" x) ("_position" e)))
###     ("\<^const>CoCallGraph.ccSquare"
###       ("_applC" ("_position" fv)
###         ("\<^const>Terms.Lam" ("_position" x) ("_position" e))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC"
###       ("\<^const>CoCallAnalysisImpl.CoCallAnalysisImpl.ccExp_syn''"
###         ("\<^const>Groups.zero_class.zero"))
###       ("\<^const>Terms.Lam" ("_position" x) ("_position" e)))
###     ("\<^const>Power.power_class.power2"
###       ("_applC" ("_position" fv)
###         ("\<^const>Terms.Lam" ("_position" x) ("_position" e))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Replacing existing raw equivariance theorem for "Aheap".
### Replacing existing raw equivariance theorem for "Aheap".
### theory "Draft.CoCallAnalysisImpl"
### 1.325s elapsed time, 3.609s cpu time, 0.305s GC time
Loading theory "Draft.CoCallImplSafe" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe")
locale ArityAnalysisHeapEqvt
  fixes
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "ArityAnalysisHeapEqvt Aheap"
### theory "Draft.ArityTransform"
### 0.599s elapsed time, 1.223s cpu time, 0.079s GC time
Loading theory "Draft.CardArityTransformSafe" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe")
Loading theory "Draft.CallArityEnd2End" (required by "Draft.CallArityEnd2EndSafeTemplates" via "Draft.CallArityEnd2EndSafe")
locale CoCallImplSafe
### Replacing existing raw equivariance theorem for "Aheap".
### Replacing existing raw equivariance theorem for "Aheap".
### theory "Draft.CoCallImplSafe"
### 0.528s elapsed time, 1.241s cpu time, 0.046s GC time
locale CallArityEnd2End
### Replacing existing raw equivariance theorem for "Aheap".
### Replacing existing raw equivariance theorem for "Aheap".
### theory "Draft.CallArityEnd2End"
### 0.590s elapsed time, 1.378s cpu time, 0.083s GC time
locale CardinalityPrognosisSafe
  fixes
    prognosis ::
      "(Vars.var => Arity\<^sub>\<bottom>)
       => Arity list
          => Arity
             => (Vars.var * exp) list * exp * stack_elem list
                => Vars.var => one\<^sub>\<bottom>"
    and
    cHeap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => one\<^sub>\<bottom>"
    and
    Aheap ::
      "(Vars.var * exp) list
       => exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
    and Aexp :: "exp => Arity -> Vars.var => Arity\<^sub>\<bottom>"
  assumes "CardinalityPrognosisSafe prognosis cHeap Aheap Aexp"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Proofs for inductive predicate(s) "consistent"
  Proving monotonicity ...
### theory "Draft.CardArityTransformSafe"
### 1.287s elapsed time, 2.133s cpu time, 0.159s GC time
Loading theory "Draft.CallArityEnd2EndSafe" (required by "Draft.CallArityEnd2EndSafeTemplates")
locale CallArityEnd2EndSafe
### Replacing existing raw equivariance theorem for "Aheap".
### Replacing existing raw equivariance theorem for "Aheap".
### theory "Draft.CallArityEnd2EndSafe"
### 1.353s elapsed time, 1.427s cpu time, 0.096s GC time
Loading theory "Draft.CallArityEnd2EndSafeTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.CallArityEnd2EndSafeTemplates"
### 0.677s elapsed time, 0.837s cpu time, 0.091s GC time
val it = (): unit
