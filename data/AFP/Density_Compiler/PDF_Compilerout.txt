Loading theory "HOL-Library.Function_Algebras" (required by "Draft.PDF_CompilerTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "Draft.Density_Predicates" (required by "Draft.PDF_CompilerTemplates" via "Draft.PDF_Compiler" via "Draft.PDF_Compiler_Pred" via "Draft.PDF_Semantics" via "Draft.PDF_Values")
Loading theory "Draft.Templates" (required by "Draft.PDF_CompilerTemplates" via "Draft.ExtrEqs")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.085s elapsed time, 0.288s cpu time, 0.000s GC time
### theory "HOL-Library.Function_Algebras"
### 0.135s elapsed time, 0.392s cpu time, 0.040s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.PDF_CompilerTemplates" via "Draft.ExtrEqs")
### theory "Draft.Density_Predicates"
### 0.309s elapsed time, 0.746s cpu time, 0.040s GC time
Loading theory "Draft.PDF_Transformations" (required by "Draft.PDF_CompilerTemplates" via "Draft.PDF_Compiler" via "Draft.PDF_Compiler_Pred")
Loading theory "Draft.PDF_Values" (required by "Draft.PDF_CompilerTemplates" via "Draft.PDF_Compiler" via "Draft.PDF_Compiler_Pred" via "Draft.PDF_Semantics")
### theory "Draft.PDF_Transformations"
### 0.163s elapsed time, 0.488s cpu time, 0.081s GC time
### theory "HOL-Library.BigO"
### 0.640s elapsed time, 1.499s cpu time, 0.176s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.PDF_CompilerTemplates")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.513s elapsed time, 1.046s cpu time, 0.059s GC time
### No equation for constructor "UnitVal"
### No equation for constructor "BoolVal"
### No equation for constructor "IntVal"
### No equation for constructor "RealVal"
consts
  extract_pair' :: "(val => 'a) => (val => 'b) => val => 'a * 'b"
Found termination order: "size <*mlex*> {}"
consts
  stock_measure :: "pdf_type => val measure"
### theory "Draft.PDF_Values"
### 1.798s elapsed time, 3.071s cpu time, 0.333s GC time
Loading theory "Draft.PDF_Semantics" (required by "Draft.PDF_CompilerTemplates" via "Draft.PDF_Compiler" via "Draft.PDF_Compiler_Pred")
class expr = type +
  fixes free_vars :: "'a => nat set"
instantiation
  expr :: expr
  free_vars_expr == free_vars :: expr => nat set
consts
  free_vars_expr :: "expr => nat set"
consts
  free_vars_expr_code :: "expr => nat set"
consts
  dist_param_type :: "pdf_dist => pdf_type"
consts
  dist_result_type :: "pdf_dist => pdf_type"
consts
  dist_measure :: "pdf_dist => val => val measure"
consts
  dist_dens :: "pdf_dist => val => val => ennreal"
consts
  op_type :: "pdf_operator => pdf_type => pdf_type option"
### Ambiguous input (line 414 of "$AFP/Density_Compiler/PDF_Semantics.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>expr_typing" ("_position" \<Gamma>) ("_position" e1)
###       ("_position" t1)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_typing"
###         ("\<^const>PDF_Semantics.de_bruijn_insert" ("_position" t1)
###           ("_position" \<Gamma>))
###         ("_position" e2) ("_position" t2)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_typing" ("_position" \<Gamma>)
###         ("_applC" ("_position" LetVar)
###           ("_cargs" ("_position" e1) ("_position" e2)))
###         ("_position" t2)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>expr_typing" ("_position" \<Gamma>) ("_position" e1)
###       ("_position" t1)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_typing"
###         ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt"
###           ("_position" t1) ("_position" \<Gamma>))
###         ("_position" e2) ("_position" t2)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_typing" ("_position" \<Gamma>)
###         ("_applC" ("_position" LetVar)
###           ("_cargs" ("_position" e1) ("_position" e2)))
###         ("_position" t2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "expr_typing"
  Proving monotonicity ...
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  countable_type :: "pdf_type => bool"
Found termination order: "{}"
### Ambiguous input (line 607 of "$AFP/Density_Compiler/PDF_Semantics.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" expr_sem)
###       ("_cargs" ("_position" \<sigma>)
###         ("\<^const>PDF_Semantics.expr.LetVar" ("_position" e1)
###           ("_position" e2))))
###     ("_do_block"
###       ("_do_cons"
###         ("_do_bind" ("_position" v)
###           ("_applC" ("_position" expr_sem)
###             ("_cargs" ("_position" \<sigma>) ("_position" e1))))
###         ("_do_final"
###           ("_applC" ("_position" expr_sem)
###             ("_cargs"
###               ("\<^const>PDF_Semantics.de_bruijn_insert" ("_position" v)
###                 ("_position" \<sigma>))
###               ("_position" e2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" expr_sem)
###       ("_cargs" ("_position" \<sigma>)
###         ("\<^const>PDF_Semantics.expr.LetVar" ("_position" e1)
###           ("_position" e2))))
###     ("_do_block"
###       ("_do_cons"
###         ("_do_bind" ("_position" v)
###           ("_applC" ("_position" expr_sem)
###             ("_cargs" ("_position" \<sigma>) ("_position" e1))))
###         ("_do_final"
###           ("_applC" ("_position" expr_sem)
###             ("_cargs"
###               ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt"
###                 ("_position" v) ("_position" \<sigma>))
###               ("_position" e2))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  expr_sem :: "(nat => val) => expr => val measure"
Found termination order: "size <*mlex*> {}"
### Ambiguous input (line 965 of "$AFP/Density_Compiler/PDF_Semantics.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" expr_sem_rf)
###       ("_cargs" ("_position" \<sigma>)
###         ("_applC" ("_position" LetVar)
###           ("_cargs" ("_position" e1) ("_position" e2)))))
###     ("_applC" ("_position" expr_sem_rf)
###       ("_cargs"
###         ("\<^const>PDF_Semantics.de_bruijn_insert"
###           ("_applC" ("_position" expr_sem_rf)
###             ("_cargs" ("_position" \<sigma>) ("_position" e1)))
###           ("_position" \<sigma>))
###         ("_position" e2)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" expr_sem_rf)
###       ("_cargs" ("_position" \<sigma>)
###         ("_applC" ("_position" LetVar)
###           ("_cargs" ("_position" e1) ("_position" e2)))))
###     ("_applC" ("_position" expr_sem_rf)
###       ("_cargs"
###         ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt"
###           ("_applC" ("_position" expr_sem_rf)
###             ("_cargs" ("_position" \<sigma>) ("_position" e1)))
###           ("_position" \<sigma>))
###         ("_position" e2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  expr_sem_rf :: "(nat => val) => expr => val"
### theory "Draft.PDF_Semantics"
### 4.554s elapsed time, 5.250s cpu time, 0.887s GC time
Loading theory "Draft.PDF_Density_Contexts" (required by "Draft.PDF_CompilerTemplates" via "Draft.PDF_Compiler" via "Draft.PDF_Compiler_Pred")
Loading theory "Draft.PDF_Target_Semantics" (required by "Draft.PDF_CompilerTemplates" via "Draft.PDF_Compiler" via "Draft.PDF_Target_Density_Contexts")
locale density_context
  fixes V :: "nat set"
    and V' :: "nat set"
    and \<Gamma> :: "nat => pdf_type"
    and \<delta> :: "(nat => val) => ennreal"
  assumes "density_context V V' \<Gamma> \<delta>"
### theory "Draft.PDF_Density_Contexts"
### 0.736s elapsed time, 1.791s cpu time, 0.815s GC time
Loading theory "Draft.PDF_Compiler_Pred" (required by "Draft.PDF_CompilerTemplates" via "Draft.PDF_Compiler")
### Ambiguous input (line 36 of "$AFP/Density_Compiler/PDF_Compiler_Pred.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_has_density"
###         ("_tuple" ("\<^const>Set.empty")
###           ("_tuple_args"
###             ("\<^const>Set.union" ("_position" V) ("_position" V'))
###             ("_tuple_args" ("_position" \<Gamma>)
###               ("_tuple_arg"
###                 ("_lambda" ("_idtdummy")
###                   ("\<^const>Groups.one_class.one"))))))
###         ("_position" e1) ("_position" f)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>expr_has_density"
###           ("_tuple" ("_applC" ("_position" shift_var_set) ("_position" V))
###             ("_tuple_args"
###               ("\<^const>Set.image" ("_position" Suc) ("_position" V'))
###               ("_tuple_args"
###                 ("\<^const>PDF_Semantics.de_bruijn_insert"
###                   ("_applC" ("_position" the)
###                     ("_applC" ("_position" expr_type)
###                       ("_cargs" ("_position" \<Gamma>) ("_position" e1))))
###                   ("_position" \<Gamma>))
###                 ("_tuple_arg"
###                   ("_applC" ("_position" insert_dens)
###                     ("_cargs" ("_position" V)
###                       ("_cargs" ("_position" V')
###                         ("_cargs" ("_position" f)
###                           ("_position" \<delta>)))))))))
###           ("_position" e2) ("_position" g)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>expr_has_density"
###       ("_tuple" ("_position" V)
###         ("_tuple_args" ("_position" V')
###           ("_tuple_args" ("_position" \<Gamma>)
###             ("_tuple_arg" ("_position" \<delta>)))))
###       ("_applC" ("_position" LetVar)
###         ("_cargs" ("_position" e1) ("_position" e2)))
###       ("_lambda" ("_position" \<rho>)
###         ("_applC" ("_position" g)
###           ("_applC" ("_position" case_nat)
###             ("_cargs" ("_position" undefined) ("_position" \<rho>))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_has_density"
###         ("_tuple" ("\<^const>Set.empty")
###           ("_tuple_args"
###             ("\<^const>Set.union" ("_position" V) ("_position" V'))
###             ("_tuple_args" ("_position" \<Gamma>)
###               ("_tuple_arg"
###                 ("_lambda" ("_idtdummy")
###                   ("\<^const>Groups.one_class.one"))))))
###         ("_position" e1) ("_position" f)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^fixed>expr_has_density"
###           ("_tuple" ("_applC" ("_position" shift_var_set) ("_position" V))
###             ("_tuple_args"
###               ("\<^const>Set.image" ("_position" Suc) ("_position" V'))
###               ("_tuple_args"
###                 ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt"
###                   ("_applC" ("_position" the)
###                     ("_applC" ("_position" expr_type)
###                       ("_cargs" ("_position" \<Gamma>) ("_position" e1))))
###                   ("_position" \<Gamma>))
###                 ("_tuple_arg"
###                   ("_applC" ("_position" insert_dens)
###                     ("_cargs" ("_position" V)
###                       ("_cargs" ("_position" V')
###                         ("_cargs" ("_position" f)
###                           ("_position" \<delta>)))))))))
###           ("_position" e2) ("_position" g)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>expr_has_density"
###       ("_tuple" ("_position" V)
###         ("_tuple_args" ("_position" V')
###           ("_tuple_args" ("_position" \<Gamma>)
###             ("_tuple_arg" ("_position" \<delta>)))))
###       ("_applC" ("_position" LetVar)
###         ("_cargs" ("_position" e1) ("_position" e2)))
###       ("_lambda" ("_position" \<rho>)
###         ("_applC" ("_position" g)
###           ("_applC" ("_position" case_nat)
###             ("_cargs" ("_position" undefined) ("_position" \<rho>))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "expr_has_density"
  Proving monotonicity ...
instantiation
  cexpr :: expr
  free_vars_cexpr == free_vars :: cexpr => nat set
consts
  free_vars_cexpr :: "cexpr => nat set"
### Ambiguous input (line 86 of "$AFP/Density_Compiler/PDF_Target_Semantics.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>cexpr_typing"
###       ("\<^const>PDF_Semantics.de_bruijn_insert" ("_position" t)
###         ("_position" \<Gamma>))
###       ("_position" e) ("_position" REAL)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>cexpr_typing" ("_position" \<Gamma>)
###       ("\<^const>PDF_Target_Semantics.cexpr.CIntegral" ("_position" e)
###         ("_position" t))
###       ("_position" REAL))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>cexpr_typing"
###       ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt" ("_position" t)
###         ("_position" \<Gamma>))
###       ("_position" e) ("_position" REAL)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>cexpr_typing" ("_position" \<Gamma>)
###       ("\<^const>PDF_Target_Semantics.cexpr.CIntegral" ("_position" e)
###         ("_position" t))
###       ("_position" REAL))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "cexpr_typing"
  Proving monotonicity ...
### theory "Draft.PDF_Compiler_Pred"
### 0.932s elapsed time, 1.955s cpu time, 0.228s GC time
consts
  cexpr_type :: "(nat => pdf_type) => cexpr => pdf_type option"
### Ambiguous input (line 215 of "$AFP/Density_Compiler/PDF_Target_Semantics.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" cexpr_sem)
###       ("_cargs" ("_position" \<sigma>)
###         ("\<^const>PDF_Target_Semantics.cexpr.CIntegral" ("_position" e)
###           ("_position" t))))
###     ("_applC" ("_position" RealVal)
###       ("_lebesgue_integral" ("_position" x)
###         ("_applC" ("_position" extract_real)
###           ("_applC" ("_position" cexpr_sem)
###             ("_cargs"
###               ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt"
###                 ("_position" x) ("_position" \<sigma>))
###               ("_position" e))))
###         ("_applC" ("_position" stock_measure) ("_position" t))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" cexpr_sem)
###       ("_cargs" ("_position" \<sigma>)
###         ("\<^const>PDF_Target_Semantics.cexpr.CIntegral" ("_position" e)
###           ("_position" t))))
###     ("_applC" ("_position" RealVal)
###       ("_lebesgue_integral" ("_position" x)
###         ("_applC" ("_position" extract_real)
###           ("_applC" ("_position" cexpr_sem)
###             ("_cargs"
###               ("\<^const>PDF_Semantics.de_bruijn_insert" ("_position" x)
###                 ("_position" \<sigma>))
###               ("_position" e))))
###         ("_applC" ("_position" stock_measure) ("_position" t))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  cexpr_sem :: "(nat => val) => cexpr => val"
consts
  map_vars :: "(nat => nat) => cexpr => cexpr"
consts
  cexpr_subst :: "nat => cexpr => cexpr => cexpr"
consts
  cexpr_comp_aux :: "nat => cexpr => cexpr => cexpr"
consts
  cexpr_subst_val_aux :: "nat => cexpr => val => cexpr"
consts
  expr_rf_to_cexpr :: "expr => cexpr"
consts
  dist_dens_cexpr :: "pdf_dist => cexpr => cexpr => cexpr"
### theory "Draft.PDF_Target_Semantics"
### 2.516s elapsed time, 5.209s cpu time, 1.882s GC time
Loading theory "Draft.PDF_Target_Density_Contexts" (required by "Draft.PDF_CompilerTemplates" via "Draft.PDF_Compiler")
### theory "Draft.PDF_Target_Density_Contexts"
### 0.481s elapsed time, 0.514s cpu time, 0.049s GC time
Loading theory "Draft.PDF_Compiler" (required by "Draft.PDF_CompilerTemplates")
### Ambiguous input (line 26 of "$AFP/Density_Compiler/PDF_Compiler.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>expr_has_density_cexpr"
###       ("_tuple" ("\<^const>List.list.Nil")
###         ("_tuple_args"
###           ("\<^const>List.append" ("_position" vs) ("_position" vs'))
###           ("_tuple_args" ("_position" \<Gamma>)
###             ("_tuple_arg"
###               ("_applC" ("_position" CReal)
###                 ("\<^const>Groups.one_class.one"))))))
###       ("_position" e) ("_position" f)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_has_density_cexpr"
###         ("_tuple" ("_applC" ("_position" shift_vars) ("_position" vs))
###           ("_tuple_args"
###             ("_applC" ("_position" map)
###               ("_cargs" ("_position" Suc) ("_position" vs')))
###             ("_tuple_args"
###               ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt"
###                 ("_applC" ("_position" the)
###                   ("_applC" ("_position" expr_type)
###                     ("_cargs" ("_position" \<Gamma>) ("_position" e))))
###                 ("_position" \<Gamma>))
###               ("_tuple_arg"
###                 ("\<^const>PDF_Target_Semantics.cexpr_Mult"
###                   ("_applC" ("_position" map_vars)
###                     ("_cargs" ("_position" Suc) ("_position" \<delta>)))
###                   ("_position" f))))))
###         ("_position" e') ("_position" g)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_has_density_cexpr"
###         ("_tuple" ("_position" vs)
###           ("_tuple_args" ("_position" vs')
###             ("_tuple_args" ("_position" \<Gamma>)
###               ("_tuple_arg" ("_position" \<delta>)))))
###         ("\<^const>PDF_Semantics.expr.LetVar" ("_position" e)
###           ("_position" e'))
###         ("_applC" ("_position" map_vars)
###           ("_cargs"
###             ("_lambda" ("_position" x)
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("\<^const>Groups.one_class.one")))
###             ("_position" g)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>expr_has_density_cexpr"
###       ("_tuple" ("\<^const>List.list.Nil")
###         ("_tuple_args"
###           ("\<^const>List.append" ("_position" vs) ("_position" vs'))
###           ("_tuple_args" ("_position" \<Gamma>)
###             ("_tuple_arg"
###               ("_applC" ("_position" CReal)
###                 ("\<^const>Groups.one_class.one"))))))
###       ("_position" e) ("_position" f)))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_has_density_cexpr"
###         ("_tuple" ("_applC" ("_position" shift_vars) ("_position" vs))
###           ("_tuple_args"
###             ("_applC" ("_position" map)
###               ("_cargs" ("_position" Suc) ("_position" vs')))
###             ("_tuple_args"
###               ("\<^const>PDF_Semantics.de_bruijn_insert"
###                 ("_applC" ("_position" the)
###                   ("_applC" ("_position" expr_type)
###                     ("_cargs" ("_position" \<Gamma>) ("_position" e))))
###                 ("_position" \<Gamma>))
###               ("_tuple_arg"
###                 ("\<^const>PDF_Target_Semantics.cexpr_Mult"
###                   ("_applC" ("_position" map_vars)
###                     ("_cargs" ("_position" Suc) ("_position" \<delta>)))
###                   ("_position" f))))))
###         ("_position" e') ("_position" g)))
###     ("\<^const>HOL.Trueprop"
###       ("\<^fixed>expr_has_density_cexpr"
###         ("_tuple" ("_position" vs)
###           ("_tuple_args" ("_position" vs')
###             ("_tuple_args" ("_position" \<Gamma>)
###               ("_tuple_arg" ("_position" \<delta>)))))
###         ("\<^const>PDF_Semantics.expr.LetVar" ("_position" e)
###           ("_position" e'))
###         ("_applC" ("_position" map_vars)
###           ("_cargs"
###             ("_lambda" ("_position" x)
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("\<^const>Groups.one_class.one")))
###             ("_position" g)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "expr_has_density_cexpr"
  Proving monotonicity ...
### Ambiguous input (line 87 of "$AFP/Density_Compiler/PDF_Compiler.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" cdens_ctxt_invar)
###     ("_cargs" ("_applC" ("_position" shift_vars) ("_position" vs))
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" Suc) ("_position" vs')))
###         ("_cargs"
###           ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt"
###             ("_position" t') ("_position" \<Gamma>))
###           ("\<^const>PDF_Target_Semantics.cexpr_Mult"
###             ("_applC" ("_position" map_vars)
###               ("_cargs" ("_position" Suc) ("_position" \<delta>)))
###             ("_position" f)))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" cdens_ctxt_invar)
###     ("_cargs" ("_applC" ("_position" shift_vars) ("_position" vs))
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" Suc) ("_position" vs')))
###         ("_cargs"
###           ("\<^const>PDF_Semantics.de_bruijn_insert" ("_position" t')
###             ("_position" \<Gamma>))
###           ("\<^const>PDF_Target_Semantics.cexpr_Mult"
###             ("_applC" ("_position" map_vars)
###               ("_cargs" ("_position" Suc) ("_position" \<delta>)))
###             ("_position" f)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "expr_compiles_to"
  Proving monotonicity ...
### Ambiguous input (line 1372 of "$AFP/Density_Compiler/PDF_Compiler.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>PDF_Target_Semantics.cexpr_typing"
###     ("\<^const>PDF_Semantics.de_bruijn_insert" ("_position" t)
###       ("_position" \<Gamma>'))
###     ("_position" f) ("_position" REAL)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>PDF_Target_Semantics.cexpr_typing"
###     ("\<^const>Linear_Temporal_Logic_on_Streams.HLD_nxt" ("_position" t)
###       ("_position" \<Gamma>'))
###     ("_position" f) ("_position" REAL)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.PDF_Compiler"
### 33.361s elapsed time, 33.744s cpu time, 0.596s GC time
Loading theory "Draft.PDF_CompilerTemplates"
"{(INTEG,
   CReal 1 *\<^sub>c \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)}"
  :: "(pdf_type * cexpr) set"
"{(INTEG,
   \<integral>\<^sub>c \<langle>fst\<^sub>c (CVar 0) =\<^sub>c
                                CVar 1\<rangle>\<^sub>c *\<^sub>c
                       (CReal 1 *\<^sub>c
                        \<langle>CVar 0 =\<^sub>c
                                 CVal
                                  <|IntVal
                                     13, IntVal
    37|>\<rangle>\<^sub>c) \<partial>PRODUCT INTEG INTEG),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       \<langle><CVar 1, CVar 0>\<^sub>c =\<^sub>c
                                CVal
                                 <|IntVal
                                    13, IntVal
   37|>\<rangle>\<^sub>c \<partial>INTEG)}"
  :: "(pdf_type * cexpr) set"
"{(INTEG,
   \<integral>\<^sub>c \<langle>-\<^sub>c CVar 0 =\<^sub>c
                                CVar 1\<rangle>\<^sub>c *\<^sub>c
                       (CReal 1 *\<^sub>c
                        \<langle>CVar 0 =\<^sub>c
                                 CInt 42\<rangle>\<^sub>c) \<partial>INTEG),
  (INTEG,
   CReal 1 *\<^sub>c
   \<langle>-\<^sub>c CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)}"
  :: "(pdf_type * cexpr) set"
val templateLemmas =
   [("PDF_Compiler.eq_i_oI",
     "Predicate.eq ?x ?xa ==> pred.eval (eq_i_o ?x) ?xa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 1)),
             template_var 0)
           ))),
    ("PDF_Compiler.eq_o_iI",
     "Predicate.eq ?x ?xa ==> pred.eval (eq_o_i ?xa) ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 0)),
             template_var 1)
           ))),
    ("PDF_Compiler.eq_i_iI",
     "Predicate.eq ?x ?xa ==> pred.eval (eq_i_i ?x ?xa) ()",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0)),
             template_hole 0)
           ))),
    ("PDF_Compiler.expr_compiles_to_sound",
     "?e : ?t \<Rightarrow>\<^sub>c ?f ==> ?\<Gamma> \<turnstile> ?e : ?t",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 1, template_var 3),
                template_var 2),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 0),
               template_var 3),
             template_var 2)
           ))),
    ("PDF_Compiler.expr_compiles_to_i_o_iI",
     "?x : ?xa \<Rightarrow>\<^sub>c ?xb ==>
      pred.eval (expr_compiles_to_i_o_i ?x ?xb) ?xa",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 0)),
             template_var 1)
           ))),
    ("PDF_Compiler.expr_compiles_to_i_i_oI",
     "?x : ?xa \<Rightarrow>\<^sub>c ?xb ==>
      pred.eval (expr_compiles_to_i_i_o ?x ?xa) ?xb",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)),
             template_var 0)
           ))),
    ("PDF_Compiler.expr_has_density_cexpr_Piiii_i_oI",
     "?x \<turnstile>\<^sub>c ?xa \<Rightarrow> ?xb ==>
      pred.eval (expr_has_density_cexpr_Piiii_i_o ?x ?xa) ?xb",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)),
             template_var 0)
           ))),
    ("PDF_Compiler.expr_typing_i_i_oI",
     "?x \<turnstile> ?xa : ?xb ==>
      pred.eval (expr_typing_i_i_o ?x ?xa) ?xb",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)),
             template_var 0)
           ))),
    ("PDF_Compiler_Pred.prob_space_empty_dens_ctxt",
     "prob_space
       (dens_ctxt_measure ({}, {}, ?\<Gamma>, %_. 1) (%_. undefined))",
     template_predicate
      (
         template_app
          (template_hole 7,
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_hole 4),
                 template_app
                  (template_app (template_hole 3, template_hole 4),
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     t_empty)))),
             t_empty))
         )),
    ("PDF_Compiler.expr_compiles_to_sound",
     "?e : ?t \<Rightarrow>\<^sub>c ?f ==> free_vars ?f <= {0}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_inequation
        (less_equals, template_app (template_hole 3, template_var 0),
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_hole 0)))),
    ("PDF_Compiler.expr_compiles_to_sound",
     "?e : ?t \<Rightarrow>\<^sub>c ?f ==>
      case_nat ?t ?\<Gamma>' \<turnstile>\<^sub>c ?f : REAL",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 0)),
               template_var 1),
             template_hole 0)
           ))),
    ("PDF_Compiler.expr_compiles_to_i_o_oI",
     "?x : ?xa \<Rightarrow>\<^sub>c ?xb ==>
      pred.eval (expr_compiles_to_i_o_o ?x) (?xa, ?xb)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("PDF_Compiler.expr_compiles_to_i_i_iI",
     "?x : ?xa \<Rightarrow>\<^sub>c ?xb ==>
      pred.eval (expr_compiles_to_i_i_i ?x ?xa ?xb) ()",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 1),
                 template_var 0)),
             template_hole 0)
           ))),
    ("PDF_Compiler.expr_has_density_cexpr_Piiii_i_iI",
     "?x \<turnstile>\<^sub>c ?xa \<Rightarrow> ?xb ==>
      pred.eval (expr_has_density_cexpr_Piiii_i_i ?x ?xa ?xb) ()",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 1),
                 template_var 0)),
             template_hole 0)
           ))),
    ("PDF_Compiler.expr_typing_i_i_iI",
     "?x \<turnstile> ?xa : ?xb ==>
      pred.eval (expr_typing_i_i_i ?x ?xa ?xb) ()",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 2),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 1),
                 template_var 0)),
             template_hole 0)
           ))),
    ("PDF_Compiler_Pred.branch_prob_empty_ctxt",
     "branch_prob ({}, {}, ?\<Gamma>, %_. 1) (%_. undefined) = 1",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_hole 4),
             template_app
              (template_app (template_hole 3, template_hole 4),
               template_app
                (template_app (template_hole 2, template_var 0),
                 t_empty)))),
         t_empty),
       template_hole 1)),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "(?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Fail ?t \<Rightarrow> (%_ _. 0)",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_var 4),
                 template_app
                  (template_app (template_hole 3, template_var 3),
                   template_app
                    (template_app (template_hole 2, template_var 2),
                     template_var 1)))),
             template_app (template_hole 1, template_var 0)),
           t_empty)
         )),
    ("PDF_Compiler.nonneg_cexpr_shift_iff",
     "nonneg_cexpr (shift_var_set ?V) (case_nat ?t ?\<Gamma>)
       (map_vars Suc ?e) =
      nonneg_cexpr ?V ?\<Gamma> ?e",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 4,
             template_app (template_hole 3, template_var 3)),
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 1, template_hole 0),
           template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 1),
         template_var 0))),
    ("PDF_Compiler_Pred.restrict_state_measure",
     "(%x. restrict x ?V')
      : state_measure (?V Un ?V') ?\<Gamma> \<rightarrow>\<^sub>M
        state_measure ?V' ?\<Gamma>",
     template_predicate
      (
         template_app
          (template_app (template_hole 4, t_empty),
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_hole 1,
                   template_app
                    (template_app (template_hole 0, template_var 1),
                     template_var 2)),
                 template_var 0)),
             template_app
              (template_app (template_hole 1, template_var 2),
               template_var 0)))
         )),
    ("PDF_Compiler.eq_i_oE",
     "[| pred.eval (eq_i_o ?x) ?xa; Predicate.eq ?x ?xa ==> ?P |] ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app (template_hole 1, template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.eq_o_iE",
     "[| pred.eval (eq_o_i ?xa) ?x; Predicate.eq ?x ?xa ==> ?P |] ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app (template_hole 1, template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 2)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_compiles_to_sound",
     "?e : ?t \<Rightarrow>\<^sub>c ?f ==>
      ALL x:type_universe ?t. 0 <= eval_cexpr ?f ?\<sigma>' x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app (template_hole 3, template_var 2)),
             t_empty)
           ))),
    ("PDF_Compiler.eq_i_iE",
     "[| pred.eval (eq_i_i ?x ?xa) ?y; Predicate.eq ?x ?xa ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app (template_hole 0, template_var 3),
                 template_var 2)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_compiles_to_i_o_iE",
     "[| pred.eval (expr_compiles_to_i_o_i ?x ?xb) ?xa;
         ?x : ?xa \<Rightarrow>\<^sub>c ?xb ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 1),
                 template_var 2)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_typing_i_i_oE",
     "[| pred.eval (expr_typing_i_i_o ?x ?xa) ?xb;
         ?x \<turnstile> ?xa : ?xb ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 2),
                 template_var 1)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_compiles_to_i_i_oE",
     "[| pred.eval (expr_compiles_to_i_i_o ?x ?xa) ?xb;
         ?x : ?xa \<Rightarrow>\<^sub>c ?xb ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 2),
                 template_var 1)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_has_density_cexpr_Piiii_i_oE",
     "[| pred.eval (expr_has_density_cexpr_Piiii_i_o ?x ?xa) ?xb;
         ?x \<turnstile>\<^sub>c ?xa \<Rightarrow> ?xb ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 2),
                 template_var 1)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_compiles_to_i_o_oE",
     "[| pred.eval (expr_compiles_to_i_o_o ?x) (?xa, ?xb);
         ?x : ?xa \<Rightarrow>\<^sub>c ?xb ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 3,
                template_app (template_hole 2, template_var 3)),
              template_app
               (template_app (template_hole 1, template_var 2),
                template_var 1))
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 2),
                 template_var 1)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_compiles_to_i_i_iE",
     "[| pred.eval (expr_compiles_to_i_i_i ?x ?xa ?xb) ?y;
         ?x : ?xa \<Rightarrow>\<^sub>c ?xb ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app
                   (template_app (template_hole 1, template_var 4),
                    template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 4),
                   template_var 3),
                 template_var 2)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_has_density_cexpr_Piiii_i_iE",
     "[| pred.eval (expr_has_density_cexpr_Piiii_i_i ?x ?xa ?xb) ?y;
         ?x \<turnstile>\<^sub>c ?xa \<Rightarrow> ?xb ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app
                   (template_app (template_hole 1, template_var 4),
                    template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 4),
                   template_var 3),
                 template_var 2)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_typing_i_i_iE",
     "[| pred.eval (expr_typing_i_i_i ?x ?xa ?xb) ?y;
         ?x \<turnstile> ?xa : ?xb ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app
                   (template_app (template_hole 1, template_var 4),
                    template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 4),
                   template_var 3),
                 template_var 2)
               )],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("PDF_Compiler.expr_compiles_to_sound",
     "?e : ?t \<Rightarrow>\<^sub>c ?f ==>
      expr_sem ?\<sigma> ?e =
      density (stock_measure ?t)
       (%x. ennreal (eval_cexpr ?f ?\<sigma>' x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 4),
                template_var 3),
              template_var 2)
            )],
       template_equation
        (template_app
          (template_app (template_hole 4, template_var 1), template_var 4),
         template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_var 3)),
           t_empty)))),
    ("PDF_Compiler.case_nat_case_nat",
     "(case case ?i of 0 => ?y | Suc x => ?m x of 0 => ?x | Suc x => ?n x) =
      (case ?i of 0 => case ?y of 0 => ?x | Suc x => ?n x
       | Suc i' => case ?m i' of 0 => ?x | Suc x => ?n x)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_var 4), template_var 3),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 3),
               template_var 2)),
           t_empty),
         template_var 0))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "?x : ?V ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Var ?x \<Rightarrow> marg_dens (?V, ?V', ?\<Gamma>, ?\<delta>) ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 4),
              template_var 3)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app (template_hole 4, template_var 3),
                   template_app
                    (template_app (template_hole 3, template_var 2),
                     template_app
                      (template_app (template_hole 2, template_var 1),
                       template_var 0)))),
               template_app (template_hole 1, template_var 4)),
             template_app
              (template_app
                (template_hole 0,
                 template_app
                  (template_app (template_hole 4, template_var 3),
                   template_app
                    (template_app (template_hole 3, template_var 2),
                     template_app
                      (template_app (template_hole 2, template_var 1),
                       template_var 0)))),
               template_var 4))
           ))),
    ("PDF_Compiler.nonneg_cexpr_shift_iff2",
     "nonneg_cexpr (shift_var_set (shift_var_set ?V))
       (case_nat ?t1.0 (case_nat ?t2.0 ?\<Gamma>))
       (map_vars (case_nat 0 (%x. Suc (Suc x))) ?e) =
      nonneg_cexpr (shift_var_set ?V) (case_nat ?t1.0 ?\<Gamma>) ?e",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_hole 5,
               template_app (template_hole 5, template_var 4))),
           template_app
            (template_app (template_hole 4, template_var 3),
             template_app
              (template_app (template_hole 4, template_var 2),
               template_var 1))),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_hole 1), t_empty)),
           template_var 0)),
       template_app
        (template_app
          (template_app
            (template_hole 6,
             template_app (template_hole 5, template_var 4)),
           template_app
            (template_app (template_hole 4, template_var 3),
             template_var 1)),
         template_var 0))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "(?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       ?e \<Rightarrow> ?f ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Random ?dst ?e \<Rightarrow> apply_dist_to_dens ?dst ?f",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 5,
                  template_app
                   (template_app (template_hole 4, template_var 6),
                    template_app
                     (template_app (template_hole 3, template_var 5),
                      template_app
                       (template_app (template_hole 2, template_var 4),
                        template_var 3)))),
                template_var 2),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app (template_hole 4, template_var 6),
                   template_app
                    (template_app (template_hole 3, template_var 5),
                     template_app
                      (template_app (template_hole 2, template_var 4),
                       template_var 3)))),
               template_app
                (template_app (template_hole 1, template_var 0),
                 template_var 2)),
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 1))
           ))),
    ("PDF_Compiler_Pred.has_subprob_density_distr_Fst",
     "has_subprob_density ?M (stock_measure (PRODUCT ?t1.0 ?t2.0)) ?f ==>
      has_subprob_density (distr ?M (stock_measure ?t1.0) (op_sem Fst))
       (stock_measure ?t1.0)
       (%x. \<integral>\<^sup>+ y. ?f <|x, y|>
                               \<partial>stock_measure ?t2.0)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_app
                 (template_hole 6,
                  template_app
                   (template_app (template_hole 5, template_var 2),
                    template_var 1))),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_app
                    (template_app (template_hole 4, template_var 3),
                     template_app (template_hole 6, template_var 2)),
                   template_app (template_hole 3, template_hole 2))),
               template_app (template_hole 6, template_var 2)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.has_subprob_density_distr_Snd",
     "has_subprob_density ?M (stock_measure (PRODUCT ?t1.0 ?t2.0)) ?f ==>
      has_subprob_density (distr ?M (stock_measure ?t2.0) (op_sem Snd))
       (stock_measure ?t2.0)
       (%y. \<integral>\<^sup>+ x. ?f <|x, y|>
                               \<partial>stock_measure ?t1.0)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_app
                 (template_hole 6,
                  template_app
                   (template_app (template_hole 5, template_var 2),
                    template_var 1))),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_app
                    (template_app (template_hole 4, template_var 3),
                     template_app (template_hole 6, template_var 1)),
                   template_app (template_hole 3, template_hole 2))),
               template_app (template_hole 6, template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "(?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       ?e \<Rightarrow> ?f ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Minus $$ ?e \<Rightarrow>
       (%\<sigma> x. ?f \<sigma> (op_sem Minus x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 6,
                  template_app
                   (template_app (template_hole 5, template_var 5),
                    template_app
                     (template_app (template_hole 4, template_var 4),
                      template_app
                       (template_app (template_hole 3, template_var 3),
                        template_var 2)))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_app (template_hole 5, template_var 5),
                   template_app
                    (template_app (template_hole 4, template_var 4),
                     template_app
                      (template_app (template_hole 3, template_var 3),
                       template_var 2)))),
               template_app
                (template_app (template_hole 2, template_hole 1),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler.space_state_measure_shift_iff",
     "(?\<sigma>
       : space (state_measure (shift_var_set ?V) (case_nat ?t ?\<Gamma>))) =
      (EX x \<sigma>'.
          x : type_universe ?t &
          \<sigma>' : space (state_measure ?V ?\<Gamma>) &
          ?\<sigma> = case_nat x \<sigma>')",
     template_equation
      (template_app
        (template_app (template_hole 11, template_var 3),
         template_app
          (template_hole 10,
           template_app
            (template_app
              (template_hole 9,
               template_app (template_hole 8, template_var 2)),
             template_app
              (template_app (template_hole 7, template_var 1),
               template_var 0)))),
       template_app (template_hole 6, t_empty))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "countable_type (val_type ?v) ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Val ?v \<Rightarrow>
       (%\<rho> x.
           branch_prob (?V, ?V', ?\<Gamma>, ?\<delta>) \<rho> *
           indicator {?v} x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 11,
              template_app (template_hole 10, template_var 4))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 9,
                 template_app
                  (template_app (template_hole 8, template_var 3),
                   template_app
                    (template_app (template_hole 7, template_var 2),
                     template_app
                      (template_app (template_hole 6, template_var 1),
                       template_var 0)))),
               template_app (template_hole 5, template_var 4)),
             t_empty)
           ))),
    ("PDF_Compiler.space_state_measureD_shift",
     "?\<sigma>
      : space (state_measure (shift_var_set ?V) (case_nat ?t ?\<Gamma>)) ==>
      EX x \<sigma>'.
         x : type_universe ?t &
         \<sigma>' : space (state_measure ?V ?\<Gamma>) &
         ?\<sigma> = case_nat x \<sigma>'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 11, template_var 3),
              template_app
               (template_hole 10,
                template_app
                 (template_app
                   (template_hole 9,
                    template_app (template_hole 8, template_var 2)),
                  template_app
                   (template_app (template_hole 7, template_var 1),
                    template_var 0))))
            )],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("PDF_Compiler.expr_has_density_cexpr_sound",
     "[| ([], [], ?\<Gamma>, CReal 1) \<turnstile>\<^sub>c
          ?e \<Rightarrow> ?f;
         ?\<Gamma> \<turnstile> ?e : ?t; free_vars ?e = {} |]
      ==> free_vars ?f <= {0}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 15,
                  template_app
                   (template_app (template_hole 14, template_hole 13),
                    template_app
                     (template_app (template_hole 12, template_hole 13),
                      template_app
                       (template_app (template_hole 11, template_var 3),
                        template_app
                         (template_hole 10,
                          template_app
                           (template_hole 9, template_hole 8)))))),
                template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_var 2),
              template_var 0)
            ),
        template_equation
         (template_app (template_hole 5, template_var 2), template_hole 4)],
       template_inequation
        (less_equals, template_app (template_hole 2, template_var 1),
         template_app
          (template_app (template_hole 1, template_hole 0),
           template_hole 4)))),
    ("PDF_Compiler_Pred.dens_ctxt_measure_empty_bind",
     "[| ?\<rho> : space (state_measure ?V' ?\<Gamma>);
         ?f : state_measure ?V' ?\<Gamma> \<rightarrow>\<^sub>M
              subprob_algebra ?N |]
      ==> dens_ctxt_measure ({}, ?V', ?\<Gamma>, %_. 1) ?\<rho> >>= ?f =
          ?f ?\<rho>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 13, template_var 4),
              template_app
               (template_hole 12,
                template_app
                 (template_app (template_hole 11, template_var 3),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 1),
              template_app
               (template_app
                 (template_hole 9,
                  template_app
                   (template_app (template_hole 11, template_var 3),
                    template_var 2)),
                template_app (template_hole 8, template_var 0)))
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_app
                    (template_app (template_hole 2, template_var 3),
                     template_app
                      (template_app (template_hole 1, template_var 2),
                       t_empty)))),
               template_var 4)),
           template_var 1),
         template_app (template_var 1, template_var 4)))),
    ("PDF_Compiler_Pred.expr_has_density_sound",
     "[| ({}, {}, ?\<Gamma>, %_. 1) \<turnstile>\<^sub>d
          ?e \<Rightarrow> ?f;
         ?\<Gamma> \<turnstile> ?e : ?t; free_vars ?e = {} |]
      ==> has_subprob_density (expr_sem ?\<sigma> ?e) (stock_measure ?t)
           (?f (%_. undefined))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 12,
                  template_app
                   (template_app (template_hole 11, template_hole 10),
                    template_app
                     (template_app (template_hole 9, template_hole 10),
                      template_app
                       (template_app (template_hole 8, template_var 4),
                        t_empty)))),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 4),
                template_var 3),
              template_var 1)
            ),
        template_equation
         (template_app (template_hole 4, template_var 3),
          template_hole 10)],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_var 0),
                   template_var 3)),
               template_app (template_hole 1, template_var 1)),
             template_app (template_var 2, t_empty))
           ))),
    ("PDF_Compiler.nonneg_cexprI_shift",
     "(!!x \<sigma>.
          [| x : type_universe ?t;
             \<sigma> : space (state_measure ?V ?\<Gamma>) |]
          ==> 0 <= extract_real (cexpr_sem (case_nat x \<sigma>) ?e)) ==>
      nonneg_cexpr (shift_var_set ?V) (case_nat ?t ?\<Gamma>) ?e",
     template_implication
      ([template_predicate (template_app (template_hole 15, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 2,
                 template_app (template_hole 1, template_var 2)),
               template_app
                (template_app (template_hole 0, template_var 3),
                 template_var 1)),
             template_var 0)
           ))),
    ("PDF_Compiler.expr_has_density_cexpr_sound",
     "[| ([], [], ?\<Gamma>, CReal 1) \<turnstile>\<^sub>c
          ?e \<Rightarrow> ?f;
         ?\<Gamma> \<turnstile> ?e : ?t; free_vars ?e = {};
         ?\<Gamma>' 0 = ?t |]
      ==> ?\<Gamma>' \<turnstile>\<^sub>c ?f : REAL",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 15,
                  template_app
                   (template_app (template_hole 14, template_hole 13),
                    template_app
                     (template_app (template_hole 12, template_hole 13),
                      template_app
                       (template_app (template_hole 11, template_var 4),
                        template_app
                         (template_hole 10,
                          template_app
                           (template_hole 9, template_hole 8)))))),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 4),
                template_var 3),
              template_var 1)
            ),
        template_equation
         (template_app (template_hole 5, template_var 3), template_hole 4),
        template_equation
         (template_app (template_var 0, template_hole 2), template_var 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 0),
               template_var 2),
             template_hole 0)
           ))),
    ("PDF_Compiler.expr_has_density_cexpr_sound",
     "[| ([], [], ?\<Gamma>, CReal 1) \<turnstile>\<^sub>c
          ?e \<Rightarrow> ?f;
         ?\<Gamma> \<turnstile> ?e : ?t; free_vars ?e = {} |]
      ==> has_subprob_density (expr_sem ?\<sigma> ?e) (stock_measure ?t)
           (%x. ennreal (eval_cexpr ?f ?\<sigma> x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 16,
                  template_app
                   (template_app (template_hole 15, template_hole 14),
                    template_app
                     (template_app (template_hole 13, template_hole 14),
                      template_app
                       (template_app (template_hole 12, template_var 4),
                        template_app
                         (template_hole 11,
                          template_app
                           (template_hole 10, template_hole 9)))))),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 4),
                template_var 3),
              template_var 1)
            ),
        template_equation
         (template_app (template_hole 6, template_var 3), template_hole 5)],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 3, template_var 0),
                   template_var 3)),
               template_app (template_hole 2, template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler.expr_has_density_cexpr_sound",
     "[| ([], [], ?\<Gamma>, CReal 1) \<turnstile>\<^sub>c
          ?e \<Rightarrow> ?f;
         ?\<Gamma> \<turnstile> ?e : ?t; free_vars ?e = {} |]
      ==> ALL x:type_universe ?t.
             0 <= extract_real (cexpr_sem (case_nat x ?\<sigma>) ?f)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 18,
                  template_app
                   (template_app (template_hole 17, template_hole 16),
                    template_app
                     (template_app (template_hole 15, template_hole 16),
                      template_app
                       (template_app (template_hole 14, template_var 4),
                        template_app
                         (template_hole 13,
                          template_app
                           (template_hole 12, template_hole 11)))))),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 10, template_var 4),
                template_var 3),
              template_var 1)
            ),
        template_equation
         (template_app (template_hole 8, template_var 3), template_hole 7)],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 6,
               template_app (template_hole 5, template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "(?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       ?e \<Rightarrow> ?f ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Fst $$ ?e \<Rightarrow>
       (%\<rho> x.
           \<integral>\<^sup>+ y. ?f \<rho> <|x, y|>
                              \<partial>stock_measure
   (the (expr_type ?\<Gamma> (Snd $$ ?e))))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 11,
                  template_app
                   (template_app (template_hole 10, template_var 5),
                    template_app
                     (template_app (template_hole 9, template_var 4),
                      template_app
                       (template_app (template_hole 8, template_var 3),
                        template_var 2)))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 11,
                 template_app
                  (template_app (template_hole 10, template_var 5),
                   template_app
                    (template_app (template_hole 9, template_var 4),
                     template_app
                      (template_app (template_hole 8, template_var 3),
                       template_var 2)))),
               template_app
                (template_app (template_hole 7, template_hole 6),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "(?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       ?e \<Rightarrow> ?f ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Inverse $$ ?e \<Rightarrow>
       (%\<sigma> x.
           ?f \<sigma> (op_sem Inverse x) *
           ennreal ((inverse (extract_real x))\<^sup>2))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 14,
                  template_app
                   (template_app (template_hole 13, template_var 5),
                    template_app
                     (template_app (template_hole 12, template_var 4),
                      template_app
                       (template_app (template_hole 11, template_var 3),
                        template_var 2)))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 14,
                 template_app
                  (template_app (template_hole 13, template_var 5),
                   template_app
                    (template_app (template_hole 12, template_var 4),
                     template_app
                      (template_app (template_hole 11, template_var 3),
                       template_var 2)))),
               template_app
                (template_app (template_hole 10, template_hole 9),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "(?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       ?e \<Rightarrow> ?f ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Snd $$ ?e \<Rightarrow>
       (%\<rho> y.
           \<integral>\<^sup>+ x. ?f \<rho> <|x, y|>
                              \<partial>stock_measure
   (the (expr_type ?\<Gamma> (Fst $$ ?e))))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 11,
                  template_app
                   (template_app (template_hole 10, template_var 5),
                    template_app
                     (template_app (template_hole 9, template_var 4),
                      template_app
                       (template_app (template_hole 8, template_var 3),
                        template_var 2)))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 11,
                 template_app
                  (template_app (template_hole 10, template_var 5),
                   template_app
                    (template_app (template_hole 9, template_var 4),
                     template_app
                      (template_app (template_hole 8, template_var 3),
                       template_var 2)))),
               template_app
                (template_app (template_hole 7, template_hole 6),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "[| randomfree ?e; free_vars ?e <= ?V' |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           Random ?dst ?e \<Rightarrow>
           (%\<rho> x.
               branch_prob (?V, ?V', ?\<Gamma>, ?\<delta>) \<rho> *
               dist_dens ?dst (expr_sem_rf \<rho> ?e) x)",
     template_implication
      ([template_predicate
         (template_app (template_hole 11, template_var 5)),
        template_inequation
         (less_equals, template_app (template_hole 9, template_var 5),
          template_var 4)],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 8,
                 template_app
                  (template_app (template_hole 7, template_var 3),
                   template_app
                    (template_app (template_hole 6, template_var 4),
                     template_app
                      (template_app (template_hole 5, template_var 2),
                       template_var 1)))),
               template_app
                (template_app (template_hole 4, template_var 0),
                 template_var 5)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "[| ?x : ?V; ?y : ?V; ?x ~= ?y |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           <Var ?x ,  Var ?y> \<Rightarrow>
           marg_dens2 (?V, ?V', ?\<Gamma>, ?\<delta>) ?x ?y",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 5),
              template_var 4)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 3),
              template_var 4)
            ),
        template_negation
         (template_equation (template_var 5, template_var 3))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_app (template_hole 5, template_var 4),
                   template_app
                    (template_app (template_hole 4, template_var 2),
                     template_app
                      (template_app (template_hole 3, template_var 1),
                       template_var 0)))),
               template_app
                (template_app
                  (template_hole 2,
                   template_app (template_hole 1, template_var 5)),
                 template_app (template_hole 1, template_var 3))),
             template_app
              (template_app
                (template_app
                  (template_hole 0,
                   template_app
                    (template_app (template_hole 5, template_var 4),
                     template_app
                      (template_app (template_hole 4, template_var 2),
                       template_app
                        (template_app (template_hole 3, template_var 1),
                         template_var 0)))),
                 template_var 5),
               template_var 3))
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "(?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       ?e \<Rightarrow> ?f ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Add $$ ?e \<Rightarrow>
       (%\<sigma> z.
           \<integral>\<^sup>+ x. ?f \<sigma>
                                   <|x, op_sem Add <|z, op_sem Minus x|>|>
                              \<partial>stock_measure (val_type z))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 11,
                  template_app
                   (template_app (template_hole 10, template_var 5),
                    template_app
                     (template_app (template_hole 9, template_var 4),
                      template_app
                       (template_app (template_hole 8, template_var 3),
                        template_var 2)))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 11,
                 template_app
                  (template_app (template_hole 10, template_var 5),
                   template_app
                    (template_app (template_hole 9, template_var 4),
                     template_app
                      (template_app (template_hole 8, template_var 3),
                       template_var 2)))),
               template_app
                (template_app (template_hole 7, template_hole 6),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "(?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       ?e \<Rightarrow> ?f ==>
      (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
       Exp $$ ?e \<Rightarrow>
       (%\<sigma> x.
           if 0 < extract_real x
           then ?f \<sigma> (lift_RealVal safe_ln x) *
                ennreal (inverse (extract_real x))
           else 0)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 15,
                  template_app
                   (template_app (template_hole 14, template_var 5),
                    template_app
                     (template_app (template_hole 13, template_var 4),
                      template_app
                       (template_app (template_hole 12, template_var 3),
                        template_var 2)))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 15,
                 template_app
                  (template_app (template_hole 14, template_var 5),
                   template_app
                    (template_app (template_hole 13, template_var 4),
                     template_app
                      (template_app (template_hole 12, template_var 3),
                       template_var 2)))),
               template_app
                (template_app (template_hole 11, template_hole 10),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler.nonneg_cexpr_Add",
     "[| ?\<Gamma> \<turnstile>\<^sub>c ?e1.0 : REAL;
         ?\<Gamma> \<turnstile>\<^sub>c ?e2.0 : REAL; free_vars ?e1.0 <= ?V;
         free_vars ?e2.0 <= ?V; nonneg_cexpr ?V ?\<Gamma> ?e1.0;
         nonneg_cexpr ?V ?\<Gamma> ?e2.0 |]
      ==> nonneg_cexpr ?V ?\<Gamma> (?e1.0 +\<^sub>c ?e2.0)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_var 2),
              template_hole 6)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_var 1),
              template_hole 6)
            ),
        template_inequation
         (less_equals, template_app (template_hole 4, template_var 2),
          template_var 0),
        template_inequation
         (less_equals, template_app (template_hole 4, template_var 1),
          template_var 0),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 0),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 0),
                template_var 3),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 0),
               template_var 3),
             template_app
              (template_app (template_hole 2, template_hole 1),
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)))
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "[| (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
          ?e \<Rightarrow> ?f;
         randomfree ?e'; free_vars ?e' <= ?V' |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           Add $$ <?e ,  ?e'> \<Rightarrow>
           (%\<rho> x.
               ?f \<rho>
                (op_sem Add <|x, expr_sem_rf \<rho> (Minus $$ ?e')|>))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 13,
                  template_app
                   (template_app (template_hole 12, template_var 6),
                    template_app
                     (template_app (template_hole 11, template_var 5),
                      template_app
                       (template_app (template_hole 10, template_var 4),
                        template_var 3)))),
                template_var 2),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 9, template_var 0)),
        template_inequation
         (less_equals, template_app (template_hole 7, template_var 0),
          template_var 5)],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 13,
                 template_app
                  (template_app (template_hole 12, template_var 6),
                   template_app
                    (template_app (template_hole 11, template_var 5),
                     template_app
                      (template_app (template_hole 10, template_var 4),
                       template_var 3)))),
               template_app
                (template_app (template_hole 6, template_hole 5),
                 template_app
                  (template_app (template_hole 4, template_var 2),
                   template_var 0))),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "[| countable_type (the (expr_type ?\<Gamma> (?oper $$ ?e)));
         (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
          ?e \<Rightarrow> ?f |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           ?oper $$ ?e \<Rightarrow>
           (%\<rho> y.
               \<integral>\<^sup>+ x. (if op_sem ?oper x = y then 1
 else 0) *
?f \<rho> x
                                  \<partial>stock_measure
       (the (expr_type ?\<Gamma> ?e)))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 15,
              template_app
               (template_hole 14,
                template_app
                 (template_app (template_hole 13, template_var 6),
                  template_app
                   (template_app (template_hole 12, template_var 5),
                    template_var 4))))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 11,
                  template_app
                   (template_app (template_hole 10, template_var 3),
                    template_app
                     (template_app (template_hole 9, template_var 2),
                      template_app
                       (template_app (template_hole 8, template_var 6),
                        template_var 1)))),
                template_var 4),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 11,
                 template_app
                  (template_app (template_hole 10, template_var 3),
                   template_app
                    (template_app (template_hole 9, template_var 2),
                     template_app
                      (template_app (template_hole 8, template_var 6),
                       template_var 1)))),
               template_app
                (template_app (template_hole 12, template_var 5),
                 template_var 4)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "[| ({}, ?V Un ?V', ?\<Gamma>, %_. 1) \<turnstile>\<^sub>d
          ?e1.0 \<Rightarrow> ?f;
         (shift_var_set ?V, Suc ` ?V',
          case_nat (the (expr_type ?\<Gamma> ?e1.0)) ?\<Gamma>,
          insert_dens ?V ?V' ?f ?\<delta>) \<turnstile>\<^sub>d
          ?e2.0 \<Rightarrow> ?g |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           LET ?e1.0 IN ?e2.0 \<Rightarrow>
           (%\<rho>. ?g (case_nat undefined \<rho>))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 16,
                  template_app
                   (template_app (template_hole 15, template_hole 14),
                    template_app
                     (template_app
                       (template_hole 13,
                        template_app
                         (template_app (template_hole 12, template_var 7),
                          template_var 6)),
                      template_app
                       (template_app (template_hole 11, template_var 5),
                        t_empty)))),
                template_var 4),
              template_var 3)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 16,
                  template_app
                   (template_app
                     (template_hole 15,
                      template_app (template_hole 9, template_var 7)),
                    template_app
                     (template_app
                       (template_hole 13,
                        template_app
                         (template_app (template_hole 8, template_hole 7),
                          template_var 6)),
                      template_app
                       (template_app
                         (template_hole 11,
                          template_app
                           (template_app
                             (template_hole 6,
                              template_app
                               (template_hole 5,
                                template_app
                                 (template_app
                                   (template_hole 4, template_var 5),
                                  template_var 4))),
                            template_var 5)),
                        template_app
                         (template_app
                           (template_app
                             (template_app
                               (template_hole 3, template_var 7),
                              template_var 6),
                            template_var 3),
                          template_var 2))))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 16,
                 template_app
                  (template_app (template_hole 15, template_var 7),
                   template_app
                    (template_app (template_hole 13, template_var 6),
                     template_app
                      (template_app (template_hole 11, template_var 5),
                       template_var 2)))),
               template_app
                (template_app (template_hole 2, template_var 4),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "[| randomfree ?b;
         (?V, ?V', ?\<Gamma>,
          if_dens_det ?\<delta> ?b True) \<turnstile>\<^sub>d
          ?e1.0 \<Rightarrow> ?g1.0;
         (?V, ?V', ?\<Gamma>,
          if_dens_det ?\<delta> ?b False) \<turnstile>\<^sub>d
          ?e2.0 \<Rightarrow> ?g2.0 |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           IF ?b THEN ?e1.0 ELSE ?e2.0 \<Rightarrow>
           (%\<rho> x. ?g1.0 \<rho> x + ?g2.0 \<rho> x)",
     template_implication
      ([template_predicate (template_app (template_hole 9, template_var 8)),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 8,
                  template_app
                   (template_app (template_hole 7, template_var 7),
                    template_app
                     (template_app (template_hole 6, template_var 6),
                      template_app
                       (template_app (template_hole 5, template_var 5),
                        template_app
                         (template_app
                           (template_app (template_hole 4, template_var 4),
                            template_var 8),
                          template_hole 3))))),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 8,
                  template_app
                   (template_app (template_hole 7, template_var 7),
                    template_app
                     (template_app (template_hole 6, template_var 6),
                      template_app
                       (template_app (template_hole 5, template_var 5),
                        template_app
                         (template_app
                           (template_app (template_hole 4, template_var 4),
                            template_var 8),
                          template_hole 2))))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 8,
                 template_app
                  (template_app (template_hole 7, template_var 7),
                   template_app
                    (template_app (template_hole 6, template_var 6),
                     template_app
                      (template_app (template_hole 5, template_var 5),
                       template_var 4)))),
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 8),
                   template_var 3),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "[| (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
          ?e \<Rightarrow> ?f;
         val_type ?c = REAL; ?c ~= RealVal 0 |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           Mult $$ <?e ,  Val ?c> \<Rightarrow>
           (%\<rho> x.
               ?f \<rho> (op_sem Mult <|x, op_sem Inverse ?c|>) *
               ennreal (inverse \<bar>extract_real ?c\<bar>))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 22,
                  template_app
                   (template_app (template_hole 21, template_var 6),
                    template_app
                     (template_app (template_hole 20, template_var 5),
                      template_app
                       (template_app (template_hole 19, template_var 4),
                        template_var 3)))),
                template_var 2),
              template_var 1)
            ),
        template_equation
         (template_app (template_hole 17, template_var 0),
          template_hole 16),
        template_negation
         (
            template_equation
             (template_var 0,
              template_app (template_hole 13, template_hole 12))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 22,
                 template_app
                  (template_app (template_hole 21, template_var 6),
                   template_app
                    (template_app (template_hole 20, template_var 5),
                     template_app
                      (template_app (template_hole 19, template_var 4),
                       template_var 3)))),
               template_app
                (template_app (template_hole 11, template_hole 10),
                 template_app
                  (template_app (template_hole 9, template_var 2),
                   template_app (template_hole 8, template_var 0)))),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.expr_has_density_sound_aux",
     "[| (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
          ?e \<Rightarrow> ?f;
         ?\<Gamma> \<turnstile> ?e : ?t;
         density_context ?V ?V' ?\<Gamma> ?\<delta>;
         free_vars ?e <= ?V Un ?V' |]
      ==> has_parametrized_subprob_density (state_measure ?V' ?\<Gamma>)
           (%\<rho>.
               dens_ctxt_measure (?V, ?V', ?\<Gamma>, ?\<delta>) \<rho> >>=
               (%\<sigma>. expr_sem \<sigma> ?e))
           (stock_measure ?t) ?f",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 14,
                  template_app
                   (template_app (template_hole 13, template_var 6),
                    template_app
                     (template_app (template_hole 12, template_var 5),
                      template_app
                       (template_app (template_hole 11, template_var 4),
                        template_var 3)))),
                template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 10, template_var 4),
                template_var 2),
              template_var 0)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 9, template_var 6),
                  template_var 5),
                template_var 4),
              template_var 3)
            ),
        template_inequation
         (less_equals, template_app (template_hole 7, template_var 2),
          template_app
           (template_app (template_hole 6, template_var 6),
            template_var 5))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 4, template_var 5),
                     template_var 4)),
                 t_empty),
               template_app (template_hole 0, template_var 0)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.addc_density_measurable",
     "[| (%(x, y). ?f x y)
         : borel_measurable
            (state_measure ?V' ?\<Gamma> \<Otimes>\<^sub>M
             stock_measure ?t);
         ?t = REAL | ?t = INTEG; ?\<Gamma> \<turnstile> ?e' : ?t;
         randomfree ?e'; free_vars ?e' <= ?V' |]
      ==> (%(\<rho>, x).
              ?f \<rho>
               (op_sem Add <|x, expr_sem_rf \<rho> (Minus $$ ?e')|>))
          : borel_measurable
             (state_measure ?V' ?\<Gamma> \<Otimes>\<^sub>M
              stock_measure ?t)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 20,
                template_app (template_hole 19, template_var 4)),
              template_app
               (template_app
                 (template_hole 18,
                  template_app
                   (template_app
                     (template_hole 17,
                      template_app
                       (template_app (template_hole 16, template_var 3),
                        template_var 2)),
                    template_app (template_hole 15, template_var 1))),
                template_hole 14))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 13,
                template_app
                 (template_app (template_hole 12, template_var 1),
                  template_hole 11)),
              template_app
               (template_app (template_hole 12, template_var 1),
                template_hole 10))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 2),
                template_var 0),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 8, template_var 0)),
        template_inequation
         (less_equals, template_app (template_hole 6, template_var 0),
          template_var 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 20, template_app (template_hole 19, t_empty)),
             template_app
              (template_app
                (template_hole 18,
                 template_app
                  (template_app
                    (template_hole 17,
                     template_app
                      (template_app (template_hole 16, template_var 3),
                       template_var 2)),
                   template_app (template_hole 15, template_var 1))),
               template_hole 14))
           ))),
    ("PDF_Compiler.expr_has_density_cexpr_sound_aux",
     "[| ?\<Gamma> \<turnstile> ?e : ?t;
         (?vs, ?vs', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>c
          ?e \<Rightarrow> ?f;
         cdens_ctxt_invar ?vs ?vs' ?\<Gamma> ?\<delta>;
         free_vars ?e <= set ?vs Un set ?vs' |]
      ==> dens_ctxt_\<alpha>
           (?vs, ?vs', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           ?e \<Rightarrow> (%x xa. ennreal (eval_cexpr ?f x xa)) &
          is_density_expr (?vs, ?vs', ?\<Gamma>, ?\<delta>) ?t ?f",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 15, template_var 6),
                template_var 5),
              template_var 4)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 14,
                  template_app
                   (template_app (template_hole 13, template_var 3),
                    template_app
                     (template_app (template_hole 12, template_var 2),
                      template_app
                       (template_app (template_hole 11, template_var 6),
                        template_var 1)))),
                template_var 5),
              template_var 0)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 10, template_var 3),
                  template_var 2),
                template_var 6),
              template_var 1)
            ),
        template_inequation
         (less_equals, template_app (template_hole 8, template_var 5),
          template_app
           (template_app
             (template_hole 7,
              template_app (template_hole 6, template_var 3)),
            template_app (template_hole 6, template_var 2)))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_app
                    (template_hole 4,
                     template_app
                      (template_hole 3,
                       template_app
                        (template_app (template_hole 13, template_var 3),
                         template_app
                          (template_app (template_hole 12, template_var 2),
                           template_app
                            (template_app
                              (template_hole 11, template_var 6),
                             template_var 1))))),
                   template_var 5),
                 t_empty)),
             template_app
              (template_app
                (template_app
                  (template_hole 0,
                   template_app
                    (template_app (template_hole 13, template_var 3),
                     template_app
                      (template_app (template_hole 12, template_var 2),
                       template_app
                        (template_app (template_hole 11, template_var 6),
                         template_var 1)))),
                 template_var 4),
               template_var 0))
           ))),
    ("PDF_Compiler_Pred.expr_has_density_intros",
     "[| ({}, ?V Un ?V', ?\<Gamma>, %_. 1) \<turnstile>\<^sub>d
          ?b \<Rightarrow> ?f;
         (?V, ?V', ?\<Gamma>,
          if_dens ?\<delta> ?f True) \<turnstile>\<^sub>d
          ?e1.0 \<Rightarrow> ?g1.0;
         (?V, ?V', ?\<Gamma>,
          if_dens ?\<delta> ?f False) \<turnstile>\<^sub>d
          ?e2.0 \<Rightarrow> ?g2.0 |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           IF ?b THEN ?e1.0 ELSE ?e2.0 \<Rightarrow>
           (%\<rho> x. ?g1.0 \<rho> x + ?g2.0 \<rho> x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 11,
                  template_app
                   (template_app (template_hole 10, template_hole 9),
                    template_app
                     (template_app
                       (template_hole 8,
                        template_app
                         (template_app (template_hole 7, template_var 9),
                          template_var 8)),
                      template_app
                       (template_app (template_hole 6, template_var 7),
                        t_empty)))),
                template_var 6),
              template_var 5)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 11,
                  template_app
                   (template_app (template_hole 10, template_var 9),
                    template_app
                     (template_app (template_hole 8, template_var 8),
                      template_app
                       (template_app (template_hole 6, template_var 7),
                        template_app
                         (template_app
                           (template_app (template_hole 4, template_var 4),
                            template_var 5),
                          template_hole 3))))),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 11,
                  template_app
                   (template_app (template_hole 10, template_var 9),
                    template_app
                     (template_app (template_hole 8, template_var 8),
                      template_app
                       (template_app (template_hole 6, template_var 7),
                        template_app
                         (template_app
                           (template_app (template_hole 4, template_var 4),
                            template_var 5),
                          template_hole 2))))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 11,
                 template_app
                  (template_app (template_hole 10, template_var 9),
                   template_app
                    (template_app (template_hole 8, template_var 8),
                     template_app
                      (template_app (template_hole 6, template_var 7),
                       template_var 4)))),
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 6),
                   template_var 3),
                 template_var 1)),
             t_empty)
           ))),
    ("PDF_Compiler_Pred.hd_cong",
     "[| (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
          ?e \<Rightarrow> ?f;
         density_context ?V ?V' ?\<Gamma> ?\<delta>;
         ?\<Gamma> \<turnstile> ?e : ?t; free_vars ?e <= ?V Un ?V';
         !!\<rho> x.
            [| \<rho> : space (state_measure ?V' ?\<Gamma>);
               x : space (stock_measure ?t) |]
            ==> ?f \<rho> x = ?f' \<rho> x |]
      ==> (?V, ?V', ?\<Gamma>, ?\<delta>) \<turnstile>\<^sub>d
           ?e \<Rightarrow> ?f'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 17,
                  template_app
                   (template_app (template_hole 16, template_var 7),
                    template_app
                     (template_app (template_hole 15, template_var 6),
                      template_app
                       (template_app (template_hole 14, template_var 5),
                        template_var 4)))),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 13, template_var 7),
                  template_var 6),
                template_var 5),
              template_var 4)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 12, template_var 5),
                template_var 3),
              template_var 1)
            ),
        template_inequation
         (less_equals, template_app (template_hole 10, template_var 3),
          template_app
           (template_app (template_hole 9, template_var 7),
            template_var 6)),
        template_predicate (template_app (template_hole 8, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 17,
                 template_app
                  (template_app (template_hole 16, template_var 7),
                   template_app
                    (template_app (template_hole 15, template_var 6),
                     template_app
                      (template_app (template_hole 14, template_var 5),
                       template_var 4)))),
               template_var 3),
             template_var 0)
           ))),
    ("PDF_Compiler.cdens_ctxt_invar_insert_bool",
     "[| dens_ctxt_\<alpha>
          ([], ?vs @ ?vs', ?\<Gamma>, CReal 1) \<turnstile>\<^sub>d
          ?b \<Rightarrow> (%\<rho> x. ennreal (eval_cexpr ?f \<rho> x));
         is_density_expr ([], ?vs @ ?vs', ?\<Gamma>, CReal 1) BOOL ?f;
         ?\<Gamma> \<turnstile> ?b : BOOL;
         free_vars ?b <= set ?vs Un set ?vs';
         cdens_ctxt_invar ?vs ?vs' ?\<Gamma> ?\<delta> |]
      ==> cdens_ctxt_invar ?vs ?vs' ?\<Gamma>
           (?\<delta> *\<^sub>c cexpr_subst_val ?f (BoolVal ?v))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 24,
                  template_app
                   (template_hole 23,
                    template_app
                     (template_app (template_hole 22, template_hole 21),
                      template_app
                       (template_app
                         (template_hole 20,
                          template_app
                           (template_app (template_hole 19, template_var 6),
                            template_var 5)),
                        template_app
                         (template_app (template_hole 18, template_var 4),
                          template_app
                           (template_hole 17,
                            template_app
                             (template_hole 16, template_hole 15))))))),
                template_var 3),
              t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 12,
                  template_app
                   (template_app (template_hole 22, template_hole 21),
                    template_app
                     (template_app
                       (template_hole 20,
                        template_app
                         (template_app (template_hole 19, template_var 6),
                          template_var 5)),
                      template_app
                       (template_app (template_hole 18, template_var 4),
                        template_app
                         (template_hole 17,
                          template_app
                           (template_hole 16, template_hole 15)))))),
                template_hole 11),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 10, template_var 4),
                template_var 3),
              template_hole 11)
            ),
        template_inequation
         (less_equals, template_app (template_hole 8, template_var 3),
          template_app
           (template_app
             (template_hole 7,
              template_app (template_hole 6, template_var 6)),
            template_app (template_hole 6, template_var 5))),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 5, template_var 6),
                  template_var 5),
                template_var 4),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app (template_hole 5, template_var 6),
                 template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 4, template_hole 3),
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_app (template_hole 0, template_var 0)))))
           ))),
    ("PDF_Compiler.cdens_ctxt_invar_insert",
     "[| cdens_ctxt_invar ?vs ?vs' ?\<Gamma> ?\<delta>;
         ?\<Gamma> \<turnstile> ?e : ?t';
         free_vars ?e <= set ?vs Un set ?vs';
         dens_ctxt_\<alpha>
          ([], ?vs @ ?vs', ?\<Gamma>, CReal 1) \<turnstile>\<^sub>d
          ?e \<Rightarrow> (%x xa. ennreal (eval_cexpr ?f x xa));
         is_density_expr ([], ?vs @ ?vs', ?\<Gamma>, CReal 1) ?t' ?f |]
      ==> cdens_ctxt_invar (shift_vars ?vs) (map Suc ?vs')
           (case_nat ?t' ?\<Gamma>) (map_vars Suc ?\<delta> *\<^sub>c ?f)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 26, template_var 6),
                  template_var 5),
                template_var 4),
              template_var 3)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 25, template_var 4),
                template_var 2),
              template_var 1)
            ),
        template_inequation
         (less_equals, template_app (template_hole 23, template_var 2),
          template_app
           (template_app
             (template_hole 22,
              template_app (template_hole 21, template_var 6)),
            template_app (template_hole 21, template_var 5))),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 20,
                  template_app
                   (template_hole 19,
                    template_app
                     (template_app (template_hole 18, template_hole 17),
                      template_app
                       (template_app
                         (template_hole 16,
                          template_app
                           (template_app (template_hole 15, template_var 6),
                            template_var 5)),
                        template_app
                         (template_app (template_hole 14, template_var 4),
                          template_app
                           (template_hole 13,
                            template_app
                             (template_hole 12, template_hole 11))))))),
                template_var 2),
              t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 8,
                  template_app
                   (template_app (template_hole 18, template_hole 17),
                    template_app
                     (template_app
                       (template_hole 16,
                        template_app
                         (template_app (template_hole 15, template_var 6),
                          template_var 5)),
                      template_app
                       (template_app (template_hole 14, template_var 4),
                        template_app
                         (template_hole 13,
                          template_app
                           (template_hole 12, template_hole 11)))))),
                template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_hole 26,
                   template_app (template_hole 7, template_var 6)),
                 template_app
                  (template_app (template_hole 6, template_hole 5),
                   template_var 5)),
               template_app
                (template_app (template_hole 4, template_var 1),
                 template_var 4)),
             template_app
              (template_app (template_hole 3, template_hole 2),
               template_app
                (template_app
                  (template_hole 1,
                   template_app
                    (template_app (template_hole 0, template_hole 5),
                     template_var 3)),
                 template_var 0)))
           ))),
    ("PDF_Compiler_Pred.expr_has_density_sound_op",
     "[| density_context ?V ?V' ?\<Gamma> ?\<delta>;
         has_parametrized_subprob_density (state_measure ?V' ?\<Gamma>)
          (%\<rho>.
              dens_ctxt_measure (?V, ?V', ?\<Gamma>, ?\<delta>) \<rho> >>=
              (%\<sigma>. expr_sem \<sigma> ?e))
          (stock_measure ?t) ?f;
         (%(x, y). ?g x y)
         : borel_measurable
            (state_measure ?V' ?\<Gamma> \<Otimes>\<^sub>M
             stock_measure ?t');
         !!M \<rho>.
            has_subprob_density M (stock_measure ?t) (?f \<rho>) ==>
            has_density (distr M (stock_measure ?t') (op_sem ?oper))
             (stock_measure ?t') (?g \<rho>);
         ?\<Gamma> \<turnstile> ?e : ?t; op_type ?oper ?t = Some ?t';
         free_vars (?oper $$ ?e) <= ?V Un ?V' |]
      ==> has_parametrized_subprob_density (state_measure ?V' ?\<Gamma>)
           (%\<rho>.
               dens_ctxt_measure (?V, ?V', ?\<Gamma>, ?\<delta>) \<rho> >>=
               (%\<sigma>. expr_sem \<sigma> (?oper $$ ?e)))
           (stock_measure ?t') ?g",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 28, template_var 9),
                  template_var 8),
                template_var 7),
              template_var 6)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_hole 27,
                    template_app
                     (template_app (template_hole 26, template_var 8),
                      template_var 7)),
                  t_empty),
                template_app (template_hole 19, template_var 4)),
              template_var 3)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 18,
                template_app (template_hole 17, template_var 2)),
              template_app
               (template_app
                 (template_hole 16,
                  template_app
                   (template_app
                     (template_hole 15,
                      template_app
                       (template_app (template_hole 26, template_var 8),
                        template_var 7)),
                    template_app (template_hole 19, template_var 1))),
                template_hole 14))
            ),
        template_predicate (template_app (template_hole 13, t_empty)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 7),
                template_var 5),
              template_var 4)
            ),
        template_equation
         (template_app
           (template_app (template_hole 5, template_var 0), template_var 4),
          template_app (template_hole 4, template_var 1)),
        template_inequation
         (less_equals,
          template_app
           (template_hole 2,
            template_app
             (template_app (template_hole 1, template_var 0),
              template_var 5)),
          template_app
           (template_app (template_hole 0, template_var 9),
            template_var 8))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_hole 27,
                   template_app
                    (template_app (template_hole 26, template_var 8),
                     template_var 7)),
                 t_empty),
               template_app (template_hole 19, template_var 1)),
             template_var 2)
           )))]:
   (string * thm * template) list
### theory "Draft.PDF_CompilerTemplates"
### 1.933s elapsed time, 7.361s cpu time, 0.646s GC time
"{(INTEG,
   CReal 1 *\<^sub>c
   \<langle>(CVar 0 -\<^sub>c -\<^sub>c CInt 13) =\<^sub>c
            CInt 37\<rangle>\<^sub>c)}"
  :: "(pdf_type * cexpr) set"
"{(INTEG,
   \<integral>\<^sub>c \<langle>Add $$\<^sub>c (CVar 0) =\<^sub>c
                                CVar 1\<rangle>\<^sub>c *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (CReal 1 *\<^sub>c
                         \<langle>snd\<^sub>c (CVar 0) =\<^sub>c
                                  CInt 13\<rangle>\<^sub>c) *\<^sub>c
                        \<integral>\<^sub>c \<langle>-\<^sub>c CVar
                          0 =\<^sub>c
               fst\<^sub>c (CVar 1)\<rangle>\<^sub>c *\<^sub>c
      (CReal 1 *\<^sub>c
       \<langle>CVar 0 =\<^sub>c
                CInt
                 37\<rangle>\<^sub>c) \<partial>INTEG) \<partial>PRODUCT
                            INTEG INTEG),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        \<langle>snd\<^sub>c
                                  <CVar
                                    0, CVar 1 -\<^sub>c
 CVar 0>\<^sub>c =\<^sub>c
                                 CInt 13\<rangle>\<^sub>c) *\<^sub>c
                       \<integral>\<^sub>c \<langle>-\<^sub>c CVar
                         0 =\<^sub>c
              fst\<^sub>c
               <CVar
                 1, CVar 2 -\<^sub>c
                    CVar 1>\<^sub>c\<rangle>\<^sub>c *\<^sub>c
     (CReal 1 *\<^sub>c
      \<langle>CVar 0 =\<^sub>c
               CInt 37\<rangle>\<^sub>c) \<partial>INTEG \<partial>INTEG),
  (INTEG,
   \<integral>\<^sub>c \<langle>Add $$\<^sub>c (CVar 0) =\<^sub>c
                                CVar 1\<rangle>\<^sub>c *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (CReal 1 *\<^sub>c
                         \<langle>snd\<^sub>c (CVar 0) =\<^sub>c
                                  CInt 13\<rangle>\<^sub>c) *\<^sub>c
                        (CReal 1 *\<^sub>c
                         \<langle>-\<^sub>c fst\<^sub>c (CVar 0) =\<^sub>c
                                  CInt
                                   37\<rangle>\<^sub>c)) \<partial>PRODUCT
                              INTEG INTEG),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        \<langle>snd\<^sub>c
                                  <CVar
                                    0, CVar 1 -\<^sub>c
 CVar 0>\<^sub>c =\<^sub>c
                                 CInt 13\<rangle>\<^sub>c) *\<^sub>c
                       (CReal 1 *\<^sub>c
                        \<langle>-\<^sub>c fst\<^sub>c
      <CVar 0, CVar 1 -\<^sub>c CVar 0>\<^sub>c =\<^sub>c
                                 CInt
                                  37\<rangle>\<^sub>c) \<partial>INTEG)}"
  :: "(pdf_type * cexpr) set"
"{(BOOL,
   CReal 1 *\<^sub>c
   (IF\<^sub>c CReal 0 \<le>\<^sub>c CReal (1 / 2) \<and>\<^sub>c
               CReal (1 / 2) \<le>\<^sub>c
               CReal
                1 THEN IF\<^sub>c CVar
                                   0 THEN CReal
     (1 / 2) ELSE CReal 1 -\<^sub>c CReal (1 / 2) ELSE CReal 0))}"
  :: "(pdf_type * cexpr) set"
"{(BOOL,
   CReal 1 *\<^sub>c
   (CReal 1 *\<^sub>c
    (IF\<^sub>c CReal 0 \<le>\<^sub>c CReal (1 / 2) \<and>\<^sub>c
                CReal (1 / 2) \<le>\<^sub>c
                CReal
                 1 THEN IF\<^sub>c CVal
                                    TRUE THEN CReal
         (1 /
          2) ELSE CReal 1 -\<^sub>c CReal (1 / 2) ELSE CReal 0)) *\<^sub>c
   (IF\<^sub>c CReal 0 \<le>\<^sub>c CReal (1 / 4) \<and>\<^sub>c
               CReal (1 / 4) \<le>\<^sub>c
               CReal
                1 THEN IF\<^sub>c CVar
                                   0 THEN CReal
     (1 / 4) ELSE CReal 1 -\<^sub>c CReal (1 / 4) ELSE CReal 0) +\<^sub>c
   CReal 1 *\<^sub>c
   (CReal 1 *\<^sub>c
    (IF\<^sub>c CReal 0 \<le>\<^sub>c CReal (1 / 2) \<and>\<^sub>c
                CReal (1 / 2) \<le>\<^sub>c
                CReal
                 1 THEN IF\<^sub>c CVal
                                    FALSE THEN CReal
          (1 /
           2) ELSE CReal 1 -\<^sub>c CReal (1 / 2) ELSE CReal 0)) *\<^sub>c
   (IF\<^sub>c CReal 0 \<le>\<^sub>c CReal (3 / 4) \<and>\<^sub>c
               CReal (3 / 4) \<le>\<^sub>c
               CReal
                1 THEN IF\<^sub>c CVar
                                   0 THEN CReal
     (3 / 4) ELSE CReal 1 -\<^sub>c CReal (3 / 4) ELSE CReal 0))}"
  :: "(pdf_type * cexpr) set"
"{(REAL,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c CReal 0 <\<^sub>c
                                    snd\<^sub>c
                                     <CReal
 0, CReal
     1>\<^sub>c THEN exp\<^sub>c
                      (-\<^sub>c ((snd\<^sub>c
                                    <CVar
0, CVar 1 -\<^sub>c CVar 0>\<^sub>c -\<^sub>c
                                   fst\<^sub>c
                                    <CReal 0, CReal 1>\<^sub>c) ^\<^sub>c
                                  CInt 2 /\<^sub>c
                                  (CReal 2 *\<^sub>c
                                   snd\<^sub>c
                                    <CReal 0, CReal 1>\<^sub>c ^\<^sub>c
                                   CInt 2))) /\<^sub>c
                     sqrt\<^sub>c
                      (CReal 2 *\<^sub>c \<pi>\<^sub>c *\<^sub>c
                       snd\<^sub>c <CReal 0, CReal 1>\<^sub>c ^\<^sub>c
                       CInt 2) ELSE CReal 0)) *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c CReal 0 <\<^sub>c
                                    snd\<^sub>c
                                     <CReal
 0, CReal
     1>\<^sub>c THEN exp\<^sub>c
                      (-\<^sub>c ((fst\<^sub>c
                                    <CVar
0, CVar 1 -\<^sub>c CVar 0>\<^sub>c -\<^sub>c
                                   fst\<^sub>c
                                    <CReal 0, CReal 1>\<^sub>c) ^\<^sub>c
                                  CInt 2 /\<^sub>c
                                  (CReal 2 *\<^sub>c
                                   snd\<^sub>c
                                    <CReal 0, CReal 1>\<^sub>c ^\<^sub>c
                                   CInt 2))) /\<^sub>c
                     sqrt\<^sub>c
                      (CReal 2 *\<^sub>c \<pi>\<^sub>c *\<^sub>c
                       snd\<^sub>c <CReal 0, CReal 1>\<^sub>c ^\<^sub>c
                       CInt 2) ELSE CReal 0)) \<partial>REAL)}"
  :: "(pdf_type * cexpr) set"
"{(INTEG,
   \<integral>\<^sub>c \<langle>Add $$\<^sub>c (CVar 0) =\<^sub>c
                                CVar 1\<rangle>\<^sub>c *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (CReal 1 *\<^sub>c
                         (IF\<^sub>c fst\<^sub>c
<CInt 1, CInt 6>\<^sub>c \<le>\<^sub>c
                                     snd\<^sub>c
<CInt 1, CInt 6>\<^sub>c \<and>\<^sub>c
                                     fst\<^sub>c
<CInt 1, CInt 6>\<^sub>c \<le>\<^sub>c
                                     snd\<^sub>c (CVar 0) \<and>\<^sub>c
                                     snd\<^sub>c (CVar 0) \<le>\<^sub>c
                                     snd\<^sub>c
<CInt
  1, CInt
      6>\<^sub>c THEN inverse\<^sub>c
                       (\<langle>snd\<^sub>c
                                  <CInt 1, CInt 6>\<^sub>c -\<^sub>c
                                 fst\<^sub>c
                                  <CInt 1, CInt 6>\<^sub>c +\<^sub>c
                                 CInt
                                  1\<rangle>\<^sub>c) ELSE CReal
                      0)) *\<^sub>c
                        (CReal 1 *\<^sub>c
                         (IF\<^sub>c fst\<^sub>c
<CInt 1, CInt 6>\<^sub>c \<le>\<^sub>c
                                     snd\<^sub>c
<CInt 1, CInt 6>\<^sub>c \<and>\<^sub>c
                                     fst\<^sub>c
<CInt 1, CInt 6>\<^sub>c \<le>\<^sub>c
                                     fst\<^sub>c (CVar 0) \<and>\<^sub>c
                                     fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                     snd\<^sub>c
<CInt
  1, CInt
      6>\<^sub>c THEN inverse\<^sub>c
                       (\<langle>snd\<^sub>c
                                  <CInt 1, CInt 6>\<^sub>c -\<^sub>c
                                 fst\<^sub>c
                                  <CInt 1, CInt 6>\<^sub>c +\<^sub>c
                                 CInt
                                  1\<rangle>\<^sub>c) ELSE CReal
                      0))) \<partial>PRODUCT INTEG INTEG),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c
                                     <CInt 1, CInt 6>\<^sub>c \<le>\<^sub>c
                                    snd\<^sub>c
                                     <CInt 1, CInt 6>\<^sub>c \<and>\<^sub>c
                                    fst\<^sub>c
                                     <CInt 1, CInt 6>\<^sub>c \<le>\<^sub>c
                                    snd\<^sub>c
                                     <CVar
 0, CVar 1 -\<^sub>c CVar 0>\<^sub>c \<and>\<^sub>c
                                    snd\<^sub>c
                                     <CVar
 0, CVar 1 -\<^sub>c CVar 0>\<^sub>c \<le>\<^sub>c
                                    snd\<^sub>c
                                     <CInt
 1, CInt
     6>\<^sub>c THEN inverse\<^sub>c
                      (\<langle>snd\<^sub>c
                                 <CInt 1, CInt 6>\<^sub>c -\<^sub>c
                                fst\<^sub>c
                                 <CInt 1, CInt 6>\<^sub>c +\<^sub>c
                                CInt
                                 1\<rangle>\<^sub>c) ELSE CReal
                     0)) *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c
                                     <CInt 1, CInt 6>\<^sub>c \<le>\<^sub>c
                                    snd\<^sub>c
                                     <CInt 1, CInt 6>\<^sub>c \<and>\<^sub>c
                                    fst\<^sub>c
                                     <CInt 1, CInt 6>\<^sub>c \<le>\<^sub>c
                                    fst\<^sub>c
                                     <CVar
 0, CVar 1 -\<^sub>c CVar 0>\<^sub>c \<and>\<^sub>c
                                    fst\<^sub>c
                                     <CVar
 0, CVar 1 -\<^sub>c CVar 0>\<^sub>c \<le>\<^sub>c
                                    snd\<^sub>c
                                     <CInt
 1, CInt
     6>\<^sub>c THEN inverse\<^sub>c
                      (\<langle>snd\<^sub>c
                                 <CInt 1, CInt 6>\<^sub>c -\<^sub>c
                                fst\<^sub>c
                                 <CInt 1, CInt 6>\<^sub>c +\<^sub>c
                                CInt
                                 1\<rangle>\<^sub>c) ELSE CReal
                     0)) \<partial>INTEG)}"
  :: "(pdf_type * cexpr) set"
"{(BOOL,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c CReal 0 \<le>\<^sub>c
                                    CReal (1 / 2) \<and>\<^sub>c
                                    CReal (1 / 2) \<le>\<^sub>c
                                    CReal
                                     1 THEN IF\<^sub>c CVar
                  0 THEN CReal
                          (1 /
                           2) ELSE CReal 1 -\<^sub>c
                                   CReal (1 / 2) ELSE CReal 0)) *\<^sub>c
                       \<langle>CVar
                                 0\<rangle>\<^sub>c \<partial>BOOL *\<^sub>c
   (IF\<^sub>c CReal 0 \<le>\<^sub>c CReal (1 / 4) \<and>\<^sub>c
               CReal (1 / 4) \<le>\<^sub>c
               CReal
                1 THEN IF\<^sub>c CVar
                                   0 THEN CReal
     (1 / 4) ELSE CReal 1 -\<^sub>c CReal (1 / 4) ELSE CReal 0) +\<^sub>c
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c CReal 0 \<le>\<^sub>c
                                    CReal (1 / 2) \<and>\<^sub>c
                                    CReal (1 / 2) \<le>\<^sub>c
                                    CReal
                                     1 THEN IF\<^sub>c CVar
                  0 THEN CReal
                          (1 /
                           2) ELSE CReal 1 -\<^sub>c
                                   CReal (1 / 2) ELSE CReal 0)) *\<^sub>c
                       \<langle>\<not>\<^sub>c CVar
          0\<rangle>\<^sub>c \<partial>BOOL *\<^sub>c
   (IF\<^sub>c CReal 0 \<le>\<^sub>c CReal (3 / 4) \<and>\<^sub>c
               CReal (3 / 4) \<le>\<^sub>c
               CReal
                1 THEN IF\<^sub>c CVar
                                   0 THEN CReal
     (3 / 4) ELSE CReal 1 -\<^sub>c CReal (3 / 4) ELSE CReal 0))}"
  :: "(pdf_type * cexpr) set"
"{(REAL,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c
                                     <CReal 0, CReal 1>\<^sub>c <\<^sub>c
                                    snd\<^sub>c
                                     <CReal
 0, CReal 1>\<^sub>c \<and>\<^sub>c
                                    fst\<^sub>c
                                     <CReal
 0, CReal 1>\<^sub>c \<le>\<^sub>c
                                    (CVar 1 -\<^sub>c
                                     CReal 1) \<and>\<^sub>c
                                    (CVar 1 -\<^sub>c CReal 1) \<le>\<^sub>c
                                    snd\<^sub>c
                                     <CReal
 0, CReal
     1>\<^sub>c THEN inverse\<^sub>c
                      (snd\<^sub>c <CReal 0, CReal 1>\<^sub>c -\<^sub>c
                       fst\<^sub>c
                        <CReal 0, CReal 1>\<^sub>c) ELSE CReal 0)) *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c CReal 0 \<le>\<^sub>c
                                    (CVar 1 -\<^sub>c
                                     CReal 1) \<and>\<^sub>c
                                    (CVar 1 -\<^sub>c CReal 1) \<le>\<^sub>c
                                    CReal
                                     1 THEN IF\<^sub>c CVar
                  0 THEN CVar 1 -\<^sub>c
                         CReal
                          1 ELSE CReal 1 -\<^sub>c
                                 (CVar 1 -\<^sub>c
                                  CReal 1) ELSE CReal 0)) *\<^sub>c
                       \<langle>CVar
                                 0\<rangle>\<^sub>c \<partial>BOOL +\<^sub>c
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c
                                     <CReal 0, CReal 1>\<^sub>c <\<^sub>c
                                    snd\<^sub>c
                                     <CReal
 0, CReal 1>\<^sub>c \<and>\<^sub>c
                                    fst\<^sub>c
                                     <CReal
 0, CReal 1>\<^sub>c \<le>\<^sub>c
                                    CVar 1 \<and>\<^sub>c
                                    CVar 1 \<le>\<^sub>c
                                    snd\<^sub>c
                                     <CReal
 0, CReal
     1>\<^sub>c THEN inverse\<^sub>c
                      (snd\<^sub>c <CReal 0, CReal 1>\<^sub>c -\<^sub>c
                       fst\<^sub>c
                        <CReal 0, CReal 1>\<^sub>c) ELSE CReal 0)) *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c CReal 0 \<le>\<^sub>c
                                    CVar 1 \<and>\<^sub>c
                                    CVar 1 \<le>\<^sub>c
                                    CReal
                                     1 THEN IF\<^sub>c CVar
                  0 THEN CVar
                          1 ELSE CReal 1 -\<^sub>c
                                 CVar 1 ELSE CReal 0)) *\<^sub>c
                       \<langle>\<not>\<^sub>c CVar
          0\<rangle>\<^sub>c \<partial>BOOL)}"
  :: "(pdf_type * cexpr) set"
"{(INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       \<integral>\<^sub>c CReal 1 *\<^sub>c
     \<langle>CVar 0 =\<^sub>c
              CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
     (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                 snd\<^sub>c (CVar 0) \<and>\<^sub>c
                 fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                 CVar 1 \<le>\<^sub>c
                 snd\<^sub>c
                  (CVar
                    0) THEN inverse\<^sub>c
                             (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
 fst\<^sub>c (CVar 0) +\<^sub>c
 CInt
  1\<rangle>\<^sub>c) ELSE CReal 0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                       \<langle>CInt 42 <\<^sub>c
                                CVar
                                 0\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
   \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c +\<^sub>c
   (\<integral>\<^sub>c \<integral>\<^sub>c \<integral>\<^sub>c CReal
                           1 *\<^sub>c
                          \<integral>\<^sub>c CReal 1 *\<^sub>c
        \<langle>CVar 0 =\<^sub>c
                 CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
        (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                    snd\<^sub>c (CVar 0) \<and>\<^sub>c
                    fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                    CVar 1 \<le>\<^sub>c
                    snd\<^sub>c
                     (CVar
                       0) THEN inverse\<^sub>c
                                (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
    fst\<^sub>c (CVar 0) +\<^sub>c
    CInt
     1\<rangle>\<^sub>c) ELSE CReal
                               0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                          \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
            CVar 0\<rangle>\<^sub>c *\<^sub>c
                          \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
                                   CVar 0 *\<^sub>c CInt 5 <\<^sub>c
                                   (CInt 42 +\<^sub>c
                                    CInt 1)\<rangle>\<^sub>c *\<^sub>c
                          \<integral>\<^sub>c CReal 1 *\<^sub>c
        \<langle>CVar 0 =\<^sub>c
                 CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
        (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                    snd\<^sub>c (CVar 0) \<and>\<^sub>c
                    fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 2 \<and>\<^sub>c
                    CVar 2 \<le>\<^sub>c
                    snd\<^sub>c
                     (CVar
                       0) THEN inverse\<^sub>c
                                (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
    fst\<^sub>c (CVar 0) +\<^sub>c
    CInt
     1\<rangle>\<^sub>c) ELSE CReal
                               0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                          \<langle>CInt 42 <\<^sub>c
                                   CVar
                                    0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
                        \<langle>CVar 0 =\<^sub>c
                                 CVal
                                  <|IntVal
                                     1, IntVal
   10|>\<rangle>\<^sub>c *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                    snd\<^sub>c (CVar 0) \<and>\<^sub>c
                                    fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                    (CVar 1 -\<^sub>c
                                     CInt 42) \<and>\<^sub>c
                                    (CVar 1 -\<^sub>c CInt 42) \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVar
 0) THEN inverse\<^sub>c
          (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                    fst\<^sub>c (CVar 0) +\<^sub>c
                    CInt
                     1\<rangle>\<^sub>c) ELSE CReal
         0) \<partial>PRODUCT INTEG INTEG +\<^sub>c
    \<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
CVar 1 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 2 \<and>\<^sub>c
CVar 2 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar
                               0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    \<langle>(CVar 0 -\<^sub>c CInt 42) =\<^sub>c
             CInt 0\<rangle>\<^sub>c +\<^sub>c
    \<integral>\<^sub>c CReal 1 *\<^sub>c
                        \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<langle>CVar 0 =\<^sub>c
               CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
      (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                  snd\<^sub>c (CVar 0) \<and>\<^sub>c
                  fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                  CVar 1 \<le>\<^sub>c
                  snd\<^sub>c
                   (CVar
                     0) THEN inverse\<^sub>c
                              (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
  fst\<^sub>c (CVar 0) +\<^sub>c
  CInt
   1\<rangle>\<^sub>c) ELSE CReal 0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                        \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
          CVar 0\<rangle>\<^sub>c *\<^sub>c
                        \<langle>\<not>\<^sub>c (CVar 0 <\<^sub>c
           CInt 6 \<or>\<^sub>c
           CVar 0 *\<^sub>c CInt 5 <\<^sub>c
           (CInt 42 +\<^sub>c
            CInt 1))\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
    \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       \<integral>\<^sub>c CReal 1 *\<^sub>c
     \<langle>CVar 0 =\<^sub>c
              CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
     (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                 snd\<^sub>c (CVar 0) \<and>\<^sub>c
                 fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                 CVar 1 \<le>\<^sub>c
                 snd\<^sub>c
                  (CVar
                    0) THEN inverse\<^sub>c
                             (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
 fst\<^sub>c (CVar 0) +\<^sub>c
 CInt
  1\<rangle>\<^sub>c) ELSE CReal 0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                       \<langle>CInt 42 <\<^sub>c
                                CVar
                                 0\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
   \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c +\<^sub>c
   (\<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
CVar 1 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 2 \<and>\<^sub>c
CVar 2 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>CInt 42 <\<^sub>c
               CVar
                0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<le>\<^sub>c
                snd\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<and>\<^sub>c
                fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<le>\<^sub>c
                (CVar 0 -\<^sub>c CInt 42) \<and>\<^sub>c
                (CVar 0 -\<^sub>c CInt 42) \<le>\<^sub>c
                snd\<^sub>c
                 (CVal
                   <|IntVal
                      1, IntVal
                          10|>) THEN inverse\<^sub>c
(\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 10|>) -\<^sub>c
          fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) +\<^sub>c
          CInt 1\<rangle>\<^sub>c) ELSE CReal 0) +\<^sub>c
    \<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
CVar 1 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 2 \<and>\<^sub>c
CVar 2 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar
                               0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    \<langle>(CVar 0 -\<^sub>c CInt 42) =\<^sub>c
             CInt 0\<rangle>\<^sub>c +\<^sub>c
    \<integral>\<^sub>c CReal 1 *\<^sub>c
                        \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<langle>CVar 0 =\<^sub>c
               CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
      (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                  snd\<^sub>c (CVar 0) \<and>\<^sub>c
                  fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                  CVar 1 \<le>\<^sub>c
                  snd\<^sub>c
                   (CVar
                     0) THEN inverse\<^sub>c
                              (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
  fst\<^sub>c (CVar 0) +\<^sub>c
  CInt
   1\<rangle>\<^sub>c) ELSE CReal 0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                        \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
          CVar 0\<rangle>\<^sub>c *\<^sub>c
                        \<langle>\<not>\<^sub>c (CVar 0 <\<^sub>c
           CInt 6 \<or>\<^sub>c
           CVar 0 *\<^sub>c CInt 5 <\<^sub>c
           (CInt 42 +\<^sub>c
            CInt 1))\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
    \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       \<integral>\<^sub>c CReal 1 *\<^sub>c
     \<langle>CVar 0 =\<^sub>c
              CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
     (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                 snd\<^sub>c (CVar 0) \<and>\<^sub>c
                 fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                 CVar 1 \<le>\<^sub>c
                 snd\<^sub>c
                  (CVar
                    0) THEN inverse\<^sub>c
                             (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
 fst\<^sub>c (CVar 0) +\<^sub>c
 CInt
  1\<rangle>\<^sub>c) ELSE CReal 0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                       \<langle>CInt 42 <\<^sub>c
                                CVar
                                 0\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
   \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c +\<^sub>c
   (\<integral>\<^sub>c \<integral>\<^sub>c \<integral>\<^sub>c CReal
                           1 *\<^sub>c
                          \<integral>\<^sub>c CReal 1 *\<^sub>c
        \<langle>CVar 0 =\<^sub>c
                 CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
        (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                    snd\<^sub>c (CVar 0) \<and>\<^sub>c
                    fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                    CVar 1 \<le>\<^sub>c
                    snd\<^sub>c
                     (CVar
                       0) THEN inverse\<^sub>c
                                (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
    fst\<^sub>c (CVar 0) +\<^sub>c
    CInt
     1\<rangle>\<^sub>c) ELSE CReal
                               0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                          \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
            CVar 0\<rangle>\<^sub>c *\<^sub>c
                          \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
                                   CVar 0 *\<^sub>c CInt 5 <\<^sub>c
                                   (CInt 42 +\<^sub>c
                                    CInt 1)\<rangle>\<^sub>c *\<^sub>c
                          (CReal 1 *\<^sub>c
                           (IF\<^sub>c fst\<^sub>c
  (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
 snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
 fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
 CVar 1 \<and>\<^sub>c
 CVar 1 \<le>\<^sub>c
 snd\<^sub>c
  (CVal
    <|IntVal
       1, IntVal
           100|>) THEN inverse\<^sub>c
                        (\<langle>snd\<^sub>c
                                   (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                                  fst\<^sub>c
                                   (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                                  CInt
                                   1\<rangle>\<^sub>c) ELSE CReal
                       0)) *\<^sub>c
                          \<langle>CInt 42 <\<^sub>c
                                   CVar
                                    0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
                        \<langle>CVar 0 =\<^sub>c
                                 CVal
                                  <|IntVal
                                     1, IntVal
   10|>\<rangle>\<^sub>c *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                    snd\<^sub>c (CVar 0) \<and>\<^sub>c
                                    fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                    (CVar 1 -\<^sub>c
                                     CInt 42) \<and>\<^sub>c
                                    (CVar 1 -\<^sub>c CInt 42) \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVar
 0) THEN inverse\<^sub>c
          (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                    fst\<^sub>c (CVar 0) +\<^sub>c
                    CInt
                     1\<rangle>\<^sub>c) ELSE CReal
         0) \<partial>PRODUCT INTEG INTEG +\<^sub>c
    \<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
CVar 1 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 1 \<and>\<^sub>c
                   CVar 1 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar
                               0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    \<langle>(CVar 0 -\<^sub>c CInt 42) =\<^sub>c
             CInt 0\<rangle>\<^sub>c +\<^sub>c
    \<integral>\<^sub>c CReal 1 *\<^sub>c
                        \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<langle>CVar 0 =\<^sub>c
               CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
      (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                  snd\<^sub>c (CVar 0) \<and>\<^sub>c
                  fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                  CVar 1 \<le>\<^sub>c
                  snd\<^sub>c
                   (CVar
                     0) THEN inverse\<^sub>c
                              (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
  fst\<^sub>c (CVar 0) +\<^sub>c
  CInt
   1\<rangle>\<^sub>c) ELSE CReal 0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                        \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
          CVar 0\<rangle>\<^sub>c *\<^sub>c
                        \<langle>\<not>\<^sub>c (CVar 0 <\<^sub>c
           CInt 6 \<or>\<^sub>c
           CVar 0 *\<^sub>c CInt 5 <\<^sub>c
           (CInt 42 +\<^sub>c
            CInt 1))\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
    \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       \<integral>\<^sub>c CReal 1 *\<^sub>c
     \<langle>CVar 0 =\<^sub>c
              CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
     (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                 snd\<^sub>c (CVar 0) \<and>\<^sub>c
                 fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                 CVar 1 \<le>\<^sub>c
                 snd\<^sub>c
                  (CVar
                    0) THEN inverse\<^sub>c
                             (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
 fst\<^sub>c (CVar 0) +\<^sub>c
 CInt
  1\<rangle>\<^sub>c) ELSE CReal 0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                       \<langle>CInt 42 <\<^sub>c
                                CVar
                                 0\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
   \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c +\<^sub>c
   (\<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
CVar 1 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 1 \<and>\<^sub>c
                   CVar 1 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>CInt 42 <\<^sub>c
               CVar
                0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<le>\<^sub>c
                snd\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<and>\<^sub>c
                fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<le>\<^sub>c
                (CVar 0 -\<^sub>c CInt 42) \<and>\<^sub>c
                (CVar 0 -\<^sub>c CInt 42) \<le>\<^sub>c
                snd\<^sub>c
                 (CVal
                   <|IntVal
                      1, IntVal
                          10|>) THEN inverse\<^sub>c
(\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 10|>) -\<^sub>c
          fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) +\<^sub>c
          CInt 1\<rangle>\<^sub>c) ELSE CReal 0) +\<^sub>c
    \<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
CVar 1 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 1 \<and>\<^sub>c
                   CVar 1 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar
                               0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    \<langle>(CVar 0 -\<^sub>c CInt 42) =\<^sub>c
             CInt 0\<rangle>\<^sub>c +\<^sub>c
    \<integral>\<^sub>c CReal 1 *\<^sub>c
                        \<integral>\<^sub>c CReal 1 *\<^sub>c
      \<langle>CVar 0 =\<^sub>c
               CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
      (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                  snd\<^sub>c (CVar 0) \<and>\<^sub>c
                  fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 1 \<and>\<^sub>c
                  CVar 1 \<le>\<^sub>c
                  snd\<^sub>c
                   (CVar
                     0) THEN inverse\<^sub>c
                              (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
  fst\<^sub>c (CVar 0) +\<^sub>c
  CInt
   1\<rangle>\<^sub>c) ELSE CReal 0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                        \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
          CVar 0\<rangle>\<^sub>c *\<^sub>c
                        \<langle>\<not>\<^sub>c (CVar 0 <\<^sub>c
           CInt 6 \<or>\<^sub>c
           CVar 0 *\<^sub>c CInt 5 <\<^sub>c
           (CInt 42 +\<^sub>c
            CInt 1))\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
    \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                                    fst\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                    CVar 0 \<and>\<^sub>c
                                    CVar 0 \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVal
 <|IntVal
    1, IntVal
        100|>) THEN inverse\<^sub>c
                     (\<langle>snd\<^sub>c
                                (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                               fst\<^sub>c
                                (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                               CInt
                                1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
                       \<langle>CInt 42 <\<^sub>c
                                CVar
                                 0\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
   \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c +\<^sub>c
   (\<integral>\<^sub>c \<integral>\<^sub>c \<integral>\<^sub>c CReal
                           1 *\<^sub>c
                          (CReal 1 *\<^sub>c
                           (IF\<^sub>c fst\<^sub>c
  (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
 snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
 fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
 CVar 0 \<and>\<^sub>c
 CVar 0 \<le>\<^sub>c
 snd\<^sub>c
  (CVal
    <|IntVal
       1, IntVal
           100|>) THEN inverse\<^sub>c
                        (\<langle>snd\<^sub>c
                                   (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                                  fst\<^sub>c
                                   (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                                  CInt
                                   1\<rangle>\<^sub>c) ELSE CReal
                       0)) *\<^sub>c
                          \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
            CVar 0\<rangle>\<^sub>c *\<^sub>c
                          \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
                                   CVar 0 *\<^sub>c CInt 5 <\<^sub>c
                                   (CInt 42 +\<^sub>c
                                    CInt 1)\<rangle>\<^sub>c *\<^sub>c
                          \<integral>\<^sub>c CReal 1 *\<^sub>c
        \<langle>CVar 0 =\<^sub>c
                 CVal <|IntVal 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
        (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                    snd\<^sub>c (CVar 0) \<and>\<^sub>c
                    fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 2 \<and>\<^sub>c
                    CVar 2 \<le>\<^sub>c
                    snd\<^sub>c
                     (CVar
                       0) THEN inverse\<^sub>c
                                (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
    fst\<^sub>c (CVar 0) +\<^sub>c
    CInt
     1\<rangle>\<^sub>c) ELSE CReal
                               0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
                          \<langle>CInt 42 <\<^sub>c
                                   CVar
                                    0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
                        \<langle>CVar 0 =\<^sub>c
                                 CVal
                                  <|IntVal
                                     1, IntVal
   10|>\<rangle>\<^sub>c *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                    snd\<^sub>c (CVar 0) \<and>\<^sub>c
                                    fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                    (CVar 1 -\<^sub>c
                                     CInt 42) \<and>\<^sub>c
                                    (CVar 1 -\<^sub>c CInt 42) \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVar
 0) THEN inverse\<^sub>c
          (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                    fst\<^sub>c (CVar 0) +\<^sub>c
                    CInt
                     1\<rangle>\<^sub>c) ELSE CReal
         0) \<partial>PRODUCT INTEG INTEG +\<^sub>c
    \<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 0 \<and>\<^sub>c
                   CVar 0 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 2 \<and>\<^sub>c
CVar 2 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar
                               0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    \<langle>(CVar 0 -\<^sub>c CInt 42) =\<^sub>c
             CInt 0\<rangle>\<^sub>c +\<^sub>c
    \<integral>\<^sub>c CReal 1 *\<^sub>c
                        (CReal 1 *\<^sub>c
                         (IF\<^sub>c fst\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                     snd\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                                     fst\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                     CVar 0 \<and>\<^sub>c
                                     CVar 0 \<le>\<^sub>c
                                     snd\<^sub>c
(CVal
  <|IntVal
     1, IntVal
         100|>) THEN inverse\<^sub>c
                      (\<langle>snd\<^sub>c
                                 (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                                fst\<^sub>c
                                 (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                                CInt
                                 1\<rangle>\<^sub>c) ELSE CReal
                     0)) *\<^sub>c
                        \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
          CVar 0\<rangle>\<^sub>c *\<^sub>c
                        \<langle>\<not>\<^sub>c (CVar 0 <\<^sub>c
           CInt 6 \<or>\<^sub>c
           CVar 0 *\<^sub>c CInt 5 <\<^sub>c
           (CInt 42 +\<^sub>c
            CInt 1))\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
    \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                                    fst\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                    CVar 0 \<and>\<^sub>c
                                    CVar 0 \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVal
 <|IntVal
    1, IntVal
        100|>) THEN inverse\<^sub>c
                     (\<langle>snd\<^sub>c
                                (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                               fst\<^sub>c
                                (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                               CInt
                                1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
                       \<langle>CInt 42 <\<^sub>c
                                CVar
                                 0\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
   \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c +\<^sub>c
   (\<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 0 \<and>\<^sub>c
                   CVar 0 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 2 \<and>\<^sub>c
CVar 2 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>CInt 42 <\<^sub>c
               CVar
                0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<le>\<^sub>c
                snd\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<and>\<^sub>c
                fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<le>\<^sub>c
                (CVar 0 -\<^sub>c CInt 42) \<and>\<^sub>c
                (CVar 0 -\<^sub>c CInt 42) \<le>\<^sub>c
                snd\<^sub>c
                 (CVal
                   <|IntVal
                      1, IntVal
                          10|>) THEN inverse\<^sub>c
(\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 10|>) -\<^sub>c
          fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) +\<^sub>c
          CInt 1\<rangle>\<^sub>c) ELSE CReal 0) +\<^sub>c
    \<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 0 \<and>\<^sub>c
                   CVar 0 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      \<integral>\<^sub>c CReal 1 *\<^sub>c
                          \<langle>CVar 0 =\<^sub>c
                                   CVal
                                    <|IntVal
 1, IntVal 100|>\<rangle>\<^sub>c *\<^sub>c
                          (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
snd\<^sub>c (CVar 0) \<and>\<^sub>c
fst\<^sub>c (CVar 0) \<le>\<^sub>c CVar 2 \<and>\<^sub>c
CVar 2 \<le>\<^sub>c
snd\<^sub>c
 (CVar
   0) THEN inverse\<^sub>c
            (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                      fst\<^sub>c (CVar 0) +\<^sub>c
                      CInt
                       1\<rangle>\<^sub>c) ELSE CReal
           0) \<partial>PRODUCT INTEG INTEG *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar
                               0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    \<langle>(CVar 0 -\<^sub>c CInt 42) =\<^sub>c
             CInt 0\<rangle>\<^sub>c +\<^sub>c
    \<integral>\<^sub>c CReal 1 *\<^sub>c
                        (CReal 1 *\<^sub>c
                         (IF\<^sub>c fst\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                     snd\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                                     fst\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                     CVar 0 \<and>\<^sub>c
                                     CVar 0 \<le>\<^sub>c
                                     snd\<^sub>c
(CVal
  <|IntVal
     1, IntVal
         100|>) THEN inverse\<^sub>c
                      (\<langle>snd\<^sub>c
                                 (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                                fst\<^sub>c
                                 (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                                CInt
                                 1\<rangle>\<^sub>c) ELSE CReal
                     0)) *\<^sub>c
                        \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
          CVar 0\<rangle>\<^sub>c *\<^sub>c
                        \<langle>\<not>\<^sub>c (CVar 0 <\<^sub>c
           CInt 6 \<or>\<^sub>c
           CVar 0 *\<^sub>c CInt 5 <\<^sub>c
           (CInt 42 +\<^sub>c
            CInt 1))\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
    \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                                    fst\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                    CVar 0 \<and>\<^sub>c
                                    CVar 0 \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVal
 <|IntVal
    1, IntVal
        100|>) THEN inverse\<^sub>c
                     (\<langle>snd\<^sub>c
                                (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                               fst\<^sub>c
                                (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                               CInt
                                1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
                       \<langle>CInt 42 <\<^sub>c
                                CVar
                                 0\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
   \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c +\<^sub>c
   (\<integral>\<^sub>c \<integral>\<^sub>c \<integral>\<^sub>c CReal
                           1 *\<^sub>c
                          (CReal 1 *\<^sub>c
                           (IF\<^sub>c fst\<^sub>c
  (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
 snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
 fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
 CVar 0 \<and>\<^sub>c
 CVar 0 \<le>\<^sub>c
 snd\<^sub>c
  (CVal
    <|IntVal
       1, IntVal
           100|>) THEN inverse\<^sub>c
                        (\<langle>snd\<^sub>c
                                   (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                                  fst\<^sub>c
                                   (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                                  CInt
                                   1\<rangle>\<^sub>c) ELSE CReal
                       0)) *\<^sub>c
                          \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
            CVar 0\<rangle>\<^sub>c *\<^sub>c
                          \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
                                   CVar 0 *\<^sub>c CInt 5 <\<^sub>c
                                   (CInt 42 +\<^sub>c
                                    CInt 1)\<rangle>\<^sub>c *\<^sub>c
                          (CReal 1 *\<^sub>c
                           (IF\<^sub>c fst\<^sub>c
  (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
 snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
 fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
 CVar 1 \<and>\<^sub>c
 CVar 1 \<le>\<^sub>c
 snd\<^sub>c
  (CVal
    <|IntVal
       1, IntVal
           100|>) THEN inverse\<^sub>c
                        (\<langle>snd\<^sub>c
                                   (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                                  fst\<^sub>c
                                   (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                                  CInt
                                   1\<rangle>\<^sub>c) ELSE CReal
                       0)) *\<^sub>c
                          \<langle>CInt 42 <\<^sub>c
                                   CVar
                                    0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
                        \<langle>CVar 0 =\<^sub>c
                                 CVal
                                  <|IntVal
                                     1, IntVal
   10|>\<rangle>\<^sub>c *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                    snd\<^sub>c (CVar 0) \<and>\<^sub>c
                                    fst\<^sub>c (CVar 0) \<le>\<^sub>c
                                    (CVar 1 -\<^sub>c
                                     CInt 42) \<and>\<^sub>c
                                    (CVar 1 -\<^sub>c CInt 42) \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVar
 0) THEN inverse\<^sub>c
          (\<langle>snd\<^sub>c (CVar 0) -\<^sub>c
                    fst\<^sub>c (CVar 0) +\<^sub>c
                    CInt
                     1\<rangle>\<^sub>c) ELSE CReal
         0) \<partial>PRODUCT INTEG INTEG +\<^sub>c
    \<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 0 \<and>\<^sub>c
                   CVar 0 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 1 \<and>\<^sub>c
                   CVar 1 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar
                               0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    \<langle>(CVar 0 -\<^sub>c CInt 42) =\<^sub>c
             CInt 0\<rangle>\<^sub>c +\<^sub>c
    \<integral>\<^sub>c CReal 1 *\<^sub>c
                        (CReal 1 *\<^sub>c
                         (IF\<^sub>c fst\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                     snd\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                                     fst\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                     CVar 0 \<and>\<^sub>c
                                     CVar 0 \<le>\<^sub>c
                                     snd\<^sub>c
(CVal
  <|IntVal
     1, IntVal
         100|>) THEN inverse\<^sub>c
                      (\<langle>snd\<^sub>c
                                 (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                                fst\<^sub>c
                                 (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                                CInt
                                 1\<rangle>\<^sub>c) ELSE CReal
                     0)) *\<^sub>c
                        \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
          CVar 0\<rangle>\<^sub>c *\<^sub>c
                        \<langle>\<not>\<^sub>c (CVar 0 <\<^sub>c
           CInt 6 \<or>\<^sub>c
           CVar 0 *\<^sub>c CInt 5 <\<^sub>c
           (CInt 42 +\<^sub>c
            CInt 1))\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
    \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c)),
  (INTEG,
   \<integral>\<^sub>c CReal 1 *\<^sub>c
                       (CReal 1 *\<^sub>c
                        (IF\<^sub>c fst\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                                    fst\<^sub>c
                                     (CVal
 <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                    CVar 0 \<and>\<^sub>c
                                    CVar 0 \<le>\<^sub>c
                                    snd\<^sub>c
                                     (CVal
 <|IntVal
    1, IntVal
        100|>) THEN inverse\<^sub>c
                     (\<langle>snd\<^sub>c
                                (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                               fst\<^sub>c
                                (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                               CInt
                                1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
                       \<langle>CInt 42 <\<^sub>c
                                CVar
                                 0\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
   \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c +\<^sub>c
   (\<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 0 \<and>\<^sub>c
                   CVar 0 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 1 \<and>\<^sub>c
                   CVar 1 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>CInt 42 <\<^sub>c
               CVar
                0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<le>\<^sub>c
                snd\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<and>\<^sub>c
                fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) \<le>\<^sub>c
                (CVar 0 -\<^sub>c CInt 42) \<and>\<^sub>c
                (CVar 0 -\<^sub>c CInt 42) \<le>\<^sub>c
                snd\<^sub>c
                 (CVal
                   <|IntVal
                      1, IntVal
                          10|>) THEN inverse\<^sub>c
(\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 10|>) -\<^sub>c
          fst\<^sub>c (CVal <|IntVal 1, IntVal 10|>) +\<^sub>c
          CInt 1\<rangle>\<^sub>c) ELSE CReal 0) +\<^sub>c
    \<integral>\<^sub>c \<integral>\<^sub>c CReal 1 *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 0 \<and>\<^sub>c
                   CVar 0 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar 0\<rangle>\<^sub>c *\<^sub>c
      \<langle>CVar 0 <\<^sub>c CInt 6 \<or>\<^sub>c
               CVar 0 *\<^sub>c CInt 5 <\<^sub>c
               (CInt 42 +\<^sub>c CInt 1)\<rangle>\<^sub>c *\<^sub>c
      (CReal 1 *\<^sub>c
       (IF\<^sub>c fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                   fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                   CVar 1 \<and>\<^sub>c
                   CVar 1 \<le>\<^sub>c
                   snd\<^sub>c
                    (CVal
                      <|IntVal
                         1, IntVal
                             100|>) THEN inverse\<^sub>c
    (\<langle>snd\<^sub>c (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
              fst\<^sub>c (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
              CInt 1\<rangle>\<^sub>c) ELSE CReal 0)) *\<^sub>c
      \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
                              CVar
                               0\<rangle>\<^sub>c \<partial>INTEG \<partial>INTEG *\<^sub>c
    \<langle>(CVar 0 -\<^sub>c CInt 42) =\<^sub>c
             CInt 0\<rangle>\<^sub>c +\<^sub>c
    \<integral>\<^sub>c CReal 1 *\<^sub>c
                        (CReal 1 *\<^sub>c
                         (IF\<^sub>c fst\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                     snd\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<and>\<^sub>c
                                     fst\<^sub>c
(CVal <|IntVal 1, IntVal 100|>) \<le>\<^sub>c
                                     CVar 0 \<and>\<^sub>c
                                     CVar 0 \<le>\<^sub>c
                                     snd\<^sub>c
(CVal
  <|IntVal
     1, IntVal
         100|>) THEN inverse\<^sub>c
                      (\<langle>snd\<^sub>c
                                 (CVal <|IntVal 1, IntVal 100|>) -\<^sub>c
                                fst\<^sub>c
                                 (CVal <|IntVal 1, IntVal 100|>) +\<^sub>c
                                CInt
                                 1\<rangle>\<^sub>c) ELSE CReal
                     0)) *\<^sub>c
                        \<langle>\<not>\<^sub>c CInt 42 <\<^sub>c
          CVar 0\<rangle>\<^sub>c *\<^sub>c
                        \<langle>\<not>\<^sub>c (CVar 0 <\<^sub>c
           CInt 6 \<or>\<^sub>c
           CVar 0 *\<^sub>c CInt 5 <\<^sub>c
           (CInt 42 +\<^sub>c
            CInt 1))\<rangle>\<^sub>c \<partial>INTEG *\<^sub>c
    \<langle>CVar 0 =\<^sub>c CInt 42\<rangle>\<^sub>c))}"
  :: "(pdf_type * cexpr) set"
val it = (): unit
