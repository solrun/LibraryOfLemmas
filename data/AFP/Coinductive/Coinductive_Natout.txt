Loading theory "HOL-Library.Complete_Partial_Order2" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.Coinductive_Nat")
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.Coinductive_Nat" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity" via "HOL-Library.Countable_Complete_Lattices" via "HOL-Library.Countable_Set")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |]
          ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> \<Squnion> A <= z"
### theory "HOL-Library.Function_Algebras"
### 0.153s elapsed time, 0.632s cpu time, 0.046s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.Coinductive_Nat" via "HOL-Library.Extended_Nat" via "HOL-Library.Countable")
Found termination order: "size_list size <*mlex*> {}"
consts
  enumerate :: "'a set => nat => 'a"
val cont_intro_tac = fn: Proof.context -> int -> tactic
val cont_intro_simproc = fn: Proof.context -> cterm -> thm option
### theory "HOL-Library.Nat_Bijection"
### 0.325s elapsed time, 1.305s cpu time, 0.110s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.ExtrEqs")
class preorder = ord +
  assumes "less_le_not_le": "!!x y. (x < y) = (x <= y & ~ y <= x)"
    and "order_refl": "!!x. x <= x"
    and "order_trans": "!!x y z. [| x <= y; y <= z |] ==> x <= z"
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
### theory "HOL-Library.Infinite_Set"
### 0.400s elapsed time, 1.602s cpu time, 0.110s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |]
          ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> \<Squnion> A <= z"
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
### theory "HOL-Library.Set_Algebras"
### 0.295s elapsed time, 1.149s cpu time, 0.151s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.572s elapsed time, 2.249s cpu time, 0.215s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.Coinductive_Nat" via "HOL-Library.Extended_Nat")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |]
          ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> \<Squnion> A <= z"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |]
          ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> \<Squnion> A <= z"
consts
  sdrop :: "nat => 'a stream => 'a stream"
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
Proofs for inductive predicate(s) "compact"
  Proving monotonicity ...
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |]
          ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> \<Squnion> A <= z"
consts
  cycle :: "'a list => 'a stream"
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |]
          ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> \<Squnion> A <= z"
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
consts
  flat :: "'a list stream => 'a stream"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
### Additional type variable(s) in locale specification "countable": 'a
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.105s elapsed time, 4.179s cpu time, 0.800s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.ExtrEqs")
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |]
          ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> \<Squnion> A <= z"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
Found termination order: "size <*mlex*> {}"
class complete_distrib_lattice = complete_lattice + distrib_lattice +
  assumes
    "Inf_Sup_le":
      "!!A. \<Sqinter> (Sup ` A)
            <= \<Squnion> (Inf ` {f ` A |f. ALL Y:A. f Y : Y})"
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class complete_lattice = ccpo + conditionally_complete_lattice +
  bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Countable"
### 1.388s elapsed time, 5.298s cpu time, 0.933s GC time
Loading theory "HOL-Library.Countable_Set" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.Coinductive_Nat" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity" via "HOL-Library.Countable_Complete_Lattices")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.872s elapsed time, 3.433s cpu time, 0.360s GC time
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
### theory "HOL-Library.Complete_Partial_Order2"
### 2.570s elapsed time, 9.721s cpu time, 1.415s GC time
### theory "HOL-Library.Countable_Set"
### 0.486s elapsed time, 1.666s cpu time, 0.221s GC time
Loading theory "HOL-Library.Countable_Complete_Lattices" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.Coinductive_Nat" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity")
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 2.494s elapsed time, 8.674s cpu time, 2.039s GC time
Loading theory "Draft.Templates" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.067s elapsed time, 0.166s cpu time, 0.031s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Coinductive_NatMoreTemplates")
class countable_complete_lattice = Inf + Sup + lattice + bot + top +
  assumes "ccInf_lower": "!!A x. [| countable A; x : A |] ==> Inf A <= x"
  assumes
    "ccInf_greatest":
      "!!A z. [| countable A; !!x. x : A ==> z <= x |] ==> z <= Inf A"
  assumes "ccSup_upper": "!!A x. [| countable A; x : A |] ==> x <= Sup A"
  assumes
    "ccSup_least":
      "!!A z. [| countable A; !!x. x : A ==> x <= z |] ==> Sup A <= z"
  assumes "ccInf_empty": "Inf {} = top"
  assumes "ccSup_empty": "Sup {} = bot"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.543s elapsed time, 1.121s cpu time, 0.076s GC time
class countable_complete_distrib_lattice = countable_complete_lattice +
  assumes
    "sup_ccInf": "!!B a. countable B ==> sup a (Inf B) = Inf (sup a ` B)"
  assumes
    "inf_ccSup": "!!B a. countable B ==> inf a (Sup B) = Sup (inf a ` B)"
### theory "HOL-Library.Countable_Complete_Lattices"
### 1.891s elapsed time, 3.585s cpu time, 1.011s GC time
Loading theory "HOL-Library.Order_Continuity" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.Coinductive_Nat" via "HOL-Library.Extended_Nat")
### theory "HOL-Library.Order_Continuity"
### 0.408s elapsed time, 0.473s cpu time, 0.061s GC time
Loading theory "HOL-Library.Extended_Nat" (required by "Draft.Coinductive_NatMoreTemplates" via "Draft.Coinductive_Nat")
class infinity = type +
  fixes infinity :: "'a"
instantiation
  enat :: infinity
  infinity_enat == infinity :: enat
Proofs for inductive predicate(s) "rec_set_enat"
### No equation for constructor "Extended_Nat.infinity_class.infinity"
### in definition of function "the_enat"
consts
  the_enat :: "enat => nat"
instantiation
  enat :: zero_neq_one
  one_enat == one_class.one :: enat
  zero_enat == zero_class.zero :: enat
instantiation
  enat :: comm_monoid_add
  plus_enat == plus :: enat => enat => enat
instantiation
  enat :: {comm_semiring_1,semiring_no_zero_divisors}
  times_enat == times :: enat => enat => enat
instantiation
  enat :: minus
  minus_enat == minus :: enat => enat => enat
instantiation
  enat :: linordered_ab_semigroup_add
  less_eq_enat == less_eq :: enat => enat => bool
  less_enat == less :: enat => enat => bool
instantiation
  enat :: {order_bot,order_top}
  top_enat == top :: enat
  bot_enat == bot :: enat
structure Cancel_Enat_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
instantiation
  enat :: complete_lattice
  Inf_enat == Inf :: enat set => enat
  Sup_enat == Sup :: enat set => enat
  sup_enat == sup :: enat => enat => enat
  inf_enat == inf :: enat => enat => enat
### theory "HOL-Library.Extended_Nat"
### 0.479s elapsed time, 0.522s cpu time, 0.060s GC time
Loading theory "Draft.Coinductive_Nat" (required by "Draft.Coinductive_NatMoreTemplates")
Proofs for coinductive predicate(s) "enat_setp"
  Proving monotonicity ...
locale co
Proofs for coinductive predicate(s) "Le_enatp"
  Proving monotonicity ...
### theory "Draft.Coinductive_Nat"
### 0.759s elapsed time, 1.399s cpu time, 0.906s GC time
Loading theory "Draft.Coinductive_NatMoreTemplates"
val templateLemmas =
   [("Coinductive_Nat.inj_enat", "inj_on enat ?A",
     template_predicate
      (
         template_app
          (template_app (template_hole 1, template_hole 0), template_var 0)
         )),
    ("Coinductive_Nat.epred_eSuc", "epred (eSuc ?n) = ?n",
     template_equation
      (template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)),
       template_var 0)),
    ("Coinductive_Nat.enat_le_plus_same", "?x <= ?x + ?y",
     template_inequation
      (less_equals, template_var 1,
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("Coinductive_Nat.enat_le_plus_same", "?x <= ?y + ?x",
     template_inequation
      (less_equals, template_var 1,
       template_app
        (template_app (template_hole 0, template_var 0), template_var 1))),
    ("Coinductive_Nat.enat_cocase_0",
     "(case 0 of 0 => ?z | eSuc x => ?s x) = ?z",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_var 1), template_var 0),
         template_hole 0),
       template_var 1)),
    ("Coinductive_Nat.epred_conv_minus", "epred ?n = ?n - 1",
     template_equation
      (template_app (template_hole 2, template_var 0),
       template_app
        (template_app (template_hole 1, template_var 0), template_hole 0))),
    ("Coinductive_Nat.numeral_eq_eSuc",
     "numeral ?k = eSuc (epred_numeral ?k)",
     template_equation
      (template_app (template_hole 2, template_var 0),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.epred_numeral",
     "epred (numeral ?i) = epred_numeral ?i",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("Coinductive_Nat.monotone_enat_minus1",
     "monotone (<=) (<=) (%n. n - ?m)",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.monotone_eadd1", "monotone (<=) (<=) (%x. x + ?y)",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.monotone_eadd2", "monotone (<=) (<=) ((+) ?x)",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.monotone_max_enat1",
     "monotone (<=) (<=) (%x. max x ?y)",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.monotone_max_enat2", "monotone (<=) (<=) (max ?x)",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.case_enat_0",
     "(case 0 of enat x => ?f x | \<infinity> => ?i) = ?f 0",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 2, template_var 1), template_var 0),
         template_hole 1),
       template_app (template_var 1, template_hole 0))),
    ("Coinductive_Nat.epred_numeral_simps",
     "epred_numeral (num.Bit0 ?k) = numeral (Num.BitM ?k)",
     template_equation
      (template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.epred_numeral_simps",
     "epred_numeral (num.Bit1 ?k) = numeral (num.Bit0 ?k)",
     template_equation
      (template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.enat_cocase_eSuc",
     "(case eSuc ?n of 0 => ?z | eSuc x => ?s x) = ?s ?n",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_var 2), template_var 1),
         template_app (template_hole 0, template_var 0)),
       template_app (template_var 1, template_var 0))),
    ("Coinductive_Nat.finite_lessThan_enat_iff",
     "finite {..<?m} = (?m ~= \<infinity>)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 4,
              template_app (template_hole 3, template_var 0))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 0)))),
    ("Coinductive_Nat.infinity_eq_eSuc_iff",
     "(\<infinity> = eSuc ?n) = (?n = \<infinity>)",
     template_bimplication
      (template_equation
        (template_hole 1, template_app (template_hole 0, template_var 0)),
       template_equation (template_var 0, template_hole 1))),
    ("Coinductive_Nat.eSuc_eq_infinity_iff",
     "(eSuc ?n = \<infinity>) = (?n = \<infinity>)",
     template_bimplication
      (template_equation
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_equation (template_var 0, template_hole 0))),
    ("Coinductive_Nat.epred_Sup",
     "epred (\<Squnion> ?A) = \<Squnion> (epred ` ?A)",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_hole 2),
           template_var 0)))),
    ("Coinductive_Nat.epred_enat", "epred (enat ?m) = enat (?m - 1)",
     template_equation
      (template_app
        (template_hole 3, template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 0),
           template_hole 0)))),
    ("Coinductive_Nat.eSuc_Inf",
     "eSuc (\<Sqinter> ?A) = \<Sqinter> (eSuc ` ?A)",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_hole 2),
           template_var 0)))),
    ("Coinductive_Nat.mcont_eadd1", "mcont Sup (<=) Sup (<=) (%x. x + ?y)",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 3, template_hole 2),
                 template_hole 1),
               template_hole 2),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.mcont_eadd2", "mcont Sup (<=) Sup (<=) ((+) ?x)",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 3, template_hole 2),
                 template_hole 1),
               template_hole 2),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.mcont_max_enat1",
     "mcont Sup (<=) Sup (<=) (%x. max x ?y)",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 3, template_hole 2),
                 template_hole 1),
               template_hole 2),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.mcont_max_enat2", "mcont Sup (<=) Sup (<=) (max ?x)",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 3, template_hole 2),
                 template_hole 1),
               template_hole 2),
             template_hole 1),
           t_empty)
         )),
    ("Coinductive_Nat.enat_cocase_inf",
     "(case \<infinity> of 0 => ?a | eSuc b => ?f b) = ?f \<infinity>",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_var 1), t_empty),
         template_hole 0),
       template_app (template_var 0, template_hole 0))),
    ("Coinductive_Nat.Le_enat_eq_ile", "((?m, ?n) : Le_enat) = (?m <= ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 1),
             template_var 0)),
         template_hole 1),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("Coinductive_Nat.enat_unfold_eq_0",
     "(enat_unfold ?stop ?next ?a = 0) = ?stop ?a",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 2),
               template_var 1),
             template_var 0)),
         template_hole 0),
       template_app (template_var 2, template_var 0))),
    ("Coinductive_Nat.eSuc_plus", "eSuc ?m + ?n = eSuc (?m + ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_var 0),
       template_app
        (template_hole 0,
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("Coinductive_Nat.finite_lessThan_enatI",
     "?m ~= \<infinity> ==> finite {..<?m}",
     template_implication
      ([template_negation
         (template_equation (template_var 0, template_hole 2))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0))
           ))),
    ("Coinductive_Nat.Suc_eq_numeral",
     "(eSuc ?n = numeral ?k) = (?n = epred_numeral ?k)",
     template_bimplication
      (template_equation
        (template_app (template_hole 2, template_var 1),
         template_app (template_hole 1, template_var 0)),
       template_equation
        (template_var 1, template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.eq_numeral_eSuc",
     "(numeral ?k = eSuc ?n) = (epred_numeral ?k = ?n)",
     template_bimplication
      (template_equation
        (template_app (template_hole 2, template_var 1),
         template_app (template_hole 1, template_var 0)),
       template_equation
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("Coinductive_Nat.less_eSuc_numeral",
     "(eSuc ?n < numeral ?k) = (?n < epred_numeral ?k)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.less_numeral_Suc",
     "(numeral ?k < eSuc ?n) = (epred_numeral ?k < ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app
          (template_hole 3, template_app (template_hole 0, template_var 1)),
         template_var 0))),
    ("Coinductive_Nat.le_eSuc_numeral",
     "(eSuc ?n <= numeral ?k) = (?n <= epred_numeral ?k)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.le_numeral_eSuc",
     "(numeral ?k <= eSuc ?n) = (epred_numeral ?k <= ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app
          (template_hole 3, template_app (template_hole 0, template_var 1)),
         template_var 0))),
    ("Coinductive_Nat.epred_max",
     "epred (max ?x ?y) = max (epred ?x) (epred ?y)",
     template_equation
      (template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 1, template_var 0)))),
    ("Coinductive_Nat.epred_min",
     "epred (min ?a ?b) = min (epred ?a) (epred ?b)",
     template_equation
      (template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 1, template_var 0)))),
    ("Coinductive_Nat.diff_eSuc_numeral",
     "eSuc ?n - numeral ?k = ?n - epred_numeral ?k",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.diff_numeral_eSuc",
     "numeral ?k - eSuc ?n = epred_numeral ?k - ?n",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app
          (template_hole 3, template_app (template_hole 0, template_var 1)),
         template_var 0))),
    ("Coinductive_Nat.max_eSuc_eSuc",
     "max (eSuc ?n) (eSuc ?m) = eSuc (max ?n ?m)",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_hole 0,
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("Coinductive_Nat.min_eSuc_eSuc",
     "min (eSuc ?n) (eSuc ?m) = eSuc (min ?n ?m)",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_hole 0,
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("Coinductive_Nat.enat_unfold_stop",
     "?stop ?a ==> enat_unfold ?stop ?next ?a = 0",
     template_implication
      ([template_predicate (template_app (template_var 2, template_var 1))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 0),
           template_var 1),
         template_hole 0))),
    ("Coinductive_Nat.ile_into_Le_enat", "?m <= ?n ==> (?m, ?n) : Le_enat",
     template_implication
      ([template_inequation (less_equals, template_var 1, template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0)),
             template_hole 0)
           ))),
    ("Coinductive_Nat.epred_le_epredI", "?n <= ?m ==> epred ?n <= epred ?m",
     template_implication
      ([template_inequation (less_equals, template_var 1, template_var 0)],
       template_inequation
        (less_equals, template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.Le_enat_imp_ile", "(?m, ?n) : Le_enat ==> ?m <= ?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 3,
                template_app
                 (template_app (template_hole 2, template_var 1),
                  template_var 0)),
              template_hole 1)
            )],
       template_inequation (less_equals, template_var 1, template_var 0))),
    ("Coinductive_Nat.neq_zero_conv_eSuc",
     "(?n ~= 0) = (EX n'. ?n = eSuc n')",
     template_equation
      (template_app
        (template_hole 4,
         template_app
          (template_app (template_hole 3, template_var 0),
           template_hole 2)),
       template_app (template_hole 1, t_empty))),
    ("Coinductive_Nat.max_eSuc_numeral",
     "max (eSuc ?n) (numeral ?k) = eSuc (max ?n (epred_numeral ?k))",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app (template_hole 0, template_var 0))))),
    ("Coinductive_Nat.max_numeral_eSuc",
     "max (numeral ?k) (eSuc ?n) = eSuc (max (epred_numeral ?k) ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 0, template_var 1)),
           template_var 0)))),
    ("Coinductive_Nat.min_eSuc_numeral",
     "min (eSuc ?n) (numeral ?k) = eSuc (min ?n (epred_numeral ?k))",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app (template_hole 0, template_var 0))))),
    ("Coinductive_Nat.min_numeral_eSuc",
     "min (numeral ?k) (eSuc ?n) = eSuc (min (epred_numeral ?k) ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 0, template_var 1)),
           template_var 0)))),
    ("Coinductive_Nat.enat_the_enat",
     "?n ~= \<infinity> ==> enat (the_enat ?n) = ?n",
     template_implication
      ([template_negation
         (template_equation (template_var 0, template_hole 2))],
       template_equation
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 0)),
         template_var 0))),
    ("Coinductive_Nat.eSuc_epred", "?n ~= 0 ==> eSuc (epred ?n) = ?n",
     template_implication
      ([template_negation
         (template_equation (template_var 0, template_hole 2))],
       template_equation
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 0)),
         template_var 0))),
    ("Coinductive_Nat.enat_cocase_numeral",
     "(case numeral ?v of 0 => ?a | eSuc x => ?f x) =
      Let (epred_numeral ?v) ?f",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 0)),
         t_empty))),
    ("Coinductive_Nat.case_enat_numeral",
     "(case numeral ?v of enat x => ?f x | \<infinity> => ?i) =
      Let (numeral ?v) ?f",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 0)),
         t_empty))),
    ("Coinductive_Nat.enat_less_enat_plusI",
     "?x < ?y ==> enat ?x < enat ?y + ?z",
     template_implication
      ([template_inequation (less_than, template_var 2, template_var 1)],
       template_inequation
        (less_than, template_app (template_hole 1, template_var 2),
         template_app
          (template_app
            (template_hole 0,
             template_app (template_hole 1, template_var 1)),
           template_var 0)))),
    ("Coinductive_Nat.enat_minus_mono1", "?x <= ?y ==> ?x - ?m <= ?y - ?m",
     template_implication
      ([template_inequation (less_equals, template_var 2, template_var 1)],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 0, template_var 2), template_var 0),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Coinductive_Nat.plus_enat_eq_0_conv",
     "(?m + ?n = 0) = (?m = 0 & ?n = 0)",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 2, template_var 1), template_var 0),
         template_hole 1),
       template_predicate
        (
           template_app
            (template_app
              (template_hole 0,
               template_app
                (template_app (template_hole 3, template_var 1),
                 template_hole 1)),
             template_app
              (template_app (template_hole 3, template_var 0),
               template_hole 1))
           ))),
    ("Coinductive_Nat.enat_min_eq_0_iff",
     "(min ?a ?b = 0) = (?a = 0 | ?b = 0)",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 2, template_var 1), template_var 0),
         template_hole 1),
       template_predicate
        (
           template_app
            (template_app
              (template_hole 0,
               template_app
                (template_app (template_hole 3, template_var 1),
                 template_hole 1)),
             template_app
              (template_app (template_hole 3, template_var 0),
               template_hole 1))
           ))),
    ("Coinductive_Nat.enat_add2_eq",
     "(?y + enat ?x = ?z + enat ?x) = (?y = ?z)",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 1, template_var 2),
           template_app (template_hole 0, template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_app (template_hole 0, template_var 1))),
       template_equation (template_var 2, template_var 0))),
    ("Coinductive_Nat.enat_add1_eq",
     "(enat ?x + ?y = enat ?x + ?z) = (?y = ?z)",
     template_bimplication
      (template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 2)),
           template_var 1),
         template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 2)),
           template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("Coinductive_Nat.enat_add_mono",
     "(enat ?x + ?y < enat ?x + ?z) = (?y < ?z)",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 2)),
             template_var 1)),
         template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 2)),
           template_var 0)),
       template_app
        (template_app (template_hole 2, template_var 1), template_var 0))),
    ("Coinductive_Nat.min_enat2_conv_enat",
     "min ?a (enat ?b) =
      enat (case ?a of enat a' => min a' ?b | \<infinity> => ?b)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, t_empty), template_var 0),
           template_var 1)))),
    ("Coinductive_Nat.min_enat1_conv_enat",
     "min (enat ?a) ?b =
      enat (case ?b of enat b' => min ?a b' | \<infinity> => ?a)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_var 0),
       template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, t_empty), template_var 1),
           template_var 0)))),
    ("Coinductive_Nat.max_enat_minus1",
     "max ?n ?m - ?k = max (?n - ?k) (?m - ?k)",
     template_equation
      (template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("Coinductive_Nat.enat_add_sub_same",
     "?a ~= \<infinity> ==> ?a + ?b - ?a = ?b",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 2))],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0)),
           template_var 1),
         template_var 0))),
    ("Coinductive_Nat.the_enat_eSuc",
     "?n ~= \<infinity> ==> the_enat (eSuc ?n) = Suc (the_enat ?n)",
     template_implication
      ([template_negation
         (template_equation (template_var 0, template_hole 4))],
       template_equation
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_app
          (template_hole 0,
           template_app (template_hole 2, template_var 0))))),
    ("Coinductive_Nat.eSuc_le_iff",
     "(eSuc ?x <= ?y) = (EX y'. ?y = eSuc y' & ?x <= y')",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, template_var 1)),
         template_var 0),
       template_app (template_hole 2, t_empty))),
    ("Coinductive_Nat.enat_unfold",
     "enat_unfold ?stop ?next ?a =
      (if ?stop ?a then 0 else eSuc (enat_unfold ?stop ?next (?next ?a)))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 2,
             template_app (template_var 2, template_var 0)),
           template_hole 1),
         template_app
          (template_hole 0,
           template_app
            (template_app
              (template_app (template_hole 3, template_var 2),
               template_var 1),
             template_app (template_var 1, template_var 0)))))),
    ("Coinductive_Nat.epred_enat_unfold",
     "epred (enat_unfold ?stop ?next ?a) =
      (if ?stop ?a then 0 else enat_unfold ?stop ?next (?next ?a))",
     template_equation
      (template_app
        (template_hole 3,
         template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_var 2, template_var 0)),
           template_hole 0),
         template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_app (template_var 1, template_var 0))))),
    ("Coinductive_Nat.epred_iadd1",
     "?a ~= 0 ==> epred (?a + ?b) = epred ?a + ?b",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 2))],
       template_equation
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0)),
         template_app
          (template_app
            (template_hole 0,
             template_app (template_hole 1, template_var 1)),
           template_var 0)))),
    ("Coinductive_Nat.mcont_enat_minus",
     "?m ~= \<infinity> ==> mcont Sup (<=) Sup (<=) (%n. n - ?m)",
     template_implication
      ([template_negation
         (template_equation (template_var 0, template_hole 4))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_hole 1),
                 template_hole 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.epred_minus_epred",
     "?m ~= 0 ==> epred ?n - epred ?m = ?n - ?m",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 2))],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)),
           template_app (template_hole 0, template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_var 1)))),
    ("Coinductive_Nat.enat_less_enat_plusI2",
     "enat ?y < ?z ==> enat (?x + ?y) < enat ?x + ?z",
     template_implication
      ([template_inequation
         (less_than, template_app (template_hole 2, template_var 2),
          template_var 1)],
       template_inequation
        (less_than,
         template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 0),
             template_var 2)),
         template_app
          (template_app
            (template_hole 0,
             template_app (template_hole 2, template_var 0)),
           template_var 1)))),
    ("Coinductive_Nat.eSuc_mono",
     "monotone (fun_ord (<=)) (<=) ?f ==>
      monotone (fun_ord (<=)) (<=) (%x. eSuc (?f x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_hole 2)),
                template_hole 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 3, template_hole 2)),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.mono2mono_epred",
     "monotone ?orda (<=) ?t ==> monotone ?orda (<=) (%x. epred (?t x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 1),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 1),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.mono2mono_eSuc",
     "monotone ?orda (<=) ?t ==> monotone ?orda (<=) (%x. eSuc (?t x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 1),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 1),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.monotone_fun_eSuc", "gfp.mono_body (%f. eSuc (f ?x))",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 3, template_app (template_hole 2, t_empty)),
             t_empty),
           t_empty)
         )),
    ("Coinductive_Nat.enat_cocase_add_eq_if",
     "(case numeral ?v + ?n of 0 => ?a | eSuc x => ?f x) =
      (let pv = epred_numeral ?v in ?f (pv + ?n))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_var 1)),
           template_var 0)),
       template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         t_empty))),
    ("Coinductive_Nat.enat_unfold_next",
     "~ ?stop ?a ==>
      enat_unfold ?stop ?next ?a =
      eSuc (enat_unfold ?stop ?next (?next ?a))",
     template_implication
      ([template_negation
         (
            template_predicate
             (template_app (template_var 2, template_var 1))
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 0),
           template_var 1),
         template_app
          (template_hole 0,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 2),
               template_var 0),
             template_app (template_var 0, template_var 1)))))),
    ("Coinductive_Nat.mono2mono_enat_minus1",
     "monotone ?orda (<=) ?t ==> monotone ?orda (<=) (%x. ?t x - ?m1)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.chain_epredI",
     "Complete_Partial_Order.chain (<=) ?Y ==>
      Complete_Partial_Order.chain (<=) (epred ` (?Y Int {x. x ~= 0}))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_hole 7),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 8, template_hole 7),
             template_app
              (template_app (template_hole 6, template_hole 5),
               template_app
                (template_app (template_hole 4, template_var 0),
                 template_app (template_hole 3, t_empty))))
           ))),
    ("Coinductive_Nat.enat_less_imp_le",
     "(!!k. ?n < enat k ==> ?m < enat k) ==> ?m <= ?n",
     template_implication
      ([template_predicate (template_app (template_hole 4, t_empty))],
       template_inequation (less_equals, template_var 0, template_var 1))),
    ("Coinductive_Nat.Le_enat_imp_ile_enat_k",
     "[| (?m, ?n) : Le_enat; ?n < enat ?l |] ==> ?m < enat ?l",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app
                 (template_app (template_hole 3, template_var 2),
                  template_var 1)),
              template_hole 2)
            ),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 0, template_var 0))],
       template_inequation
        (less_than, template_var 2,
         template_app (template_hole 0, template_var 0)))),
    ("Coinductive_Nat.max_Sup_enat2",
     "?Y ~= {} ==> max ?x (\<Squnion> ?Y) = \<Squnion> (max ?x ` ?Y)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 4))],
       template_equation
        (template_app
          (template_app (template_hole 2, template_var 0),
           template_app (template_hole 1, template_var 1)),
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, t_empty), template_var 1))))),
    ("Coinductive_Nat.max_Sup_enat1",
     "?Y ~= {} ==> max (\<Squnion> ?Y) ?x = (\<Squnion>y\<in>?Y. max y ?x)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 4))],
       template_equation
        (template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 1)),
           template_var 0),
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, t_empty), template_var 1))))),
    ("Coinductive_Nat.Sup_image_eadd1",
     "?Y ~= {} ==> (\<Squnion>y\<in>?Y. y + ?x) = \<Squnion> ?Y + ?x",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 4))],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, t_empty), template_var 1)),
         template_app
          (template_app
            (template_hole 0,
             template_app (template_hole 2, template_var 1)),
           template_var 0)))),
    ("Coinductive_Nat.Sup_image_eadd2",
     "?Y ~= {} ==> \<Squnion> ((+) ?x ` ?Y) = ?x + \<Squnion> ?Y",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 4))],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, t_empty), template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_app (template_hole 2, template_var 1))))),
    ("Coinductive_Nat.Sup_enat_minus1",
     "?m ~= \<infinity> ==>
      \<Squnion> ?A - ?m = (\<Squnion>n\<in>?A. n - ?m)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 3))],
       template_equation
        (template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 0)),
           template_var 1),
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, t_empty), template_var 0))))),
    ("Coinductive_Nat.epred_Max",
     "[| finite ?A; ?A ~= {} |] ==> epred (Max ?A) = Max (epred ` ?A)",
     template_implication
      ([template_predicate (template_app (template_hole 7, template_var 0)),
        template_negation
         (template_equation (template_var 0, template_hole 4))],
       template_equation
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_hole 2),
             template_var 0))))),
    ("Coinductive_Nat.mcont2mcont_epred",
     "mcont ?lub ?ord Sup (<=) ?t ==>
      mcont ?lub ?ord Sup (<=) (%x. epred (?t x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 2),
                    template_var 1),
                  template_hole 2),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 3, template_var 2),
                   template_var 1),
                 template_hole 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.mcont2mcont_eSuc",
     "mcont ?lub ?ord Sup (<=) ?t ==>
      mcont ?lub ?ord Sup (<=) (%x. eSuc (?t x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 2),
                    template_var 1),
                  template_hole 2),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 3, template_var 2),
                   template_var 1),
                 template_hole 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.finite_imageD2",
     "[| finite (?f ` ?A); inj_on ?f (?A - ?B); finite ?B |] ==> finite ?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 4,
              template_app
               (template_app (template_hole 3, template_var 2),
                template_var 1))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 2),
              template_app
               (template_app (template_hole 1, template_var 1),
                template_var 0))
            ),
        template_predicate
         (template_app (template_hole 0, template_var 0))],
       template_predicate
        (template_app (template_hole 0, template_var 1)))),
    ("Coinductive_Nat.enat_coexhaust",
     "[| ?n = 0 ==> ?thesis; !!n'. ?n = eSuc n' ==> ?thesis |] ==> ?thesis",
     template_implication
      ([template_implication
         ([template_equation (template_var 1, template_hole 2)],
          template_predicate (template_var 0)),
        template_predicate (template_app (template_hole 1, t_empty))],
       template_predicate (template_var 0))),
    ("Coinductive_Nat.enat_diff_cancel_left",
     "[| ?m <= ?x; ?m <= ?y |] ==> (?x - ?m = ?y - ?m) = (?x = ?y)",
     template_implication
      ([template_inequation (less_equals, template_var 2, template_var 1),
        template_inequation (less_equals, template_var 2, template_var 0)],
       template_bimplication
        (template_equation
          (template_app
            (template_app (template_hole 0, template_var 1),
             template_var 2),
           template_app
            (template_app (template_hole 0, template_var 0),
             template_var 2)),
         template_equation (template_var 1, template_var 0)))),
    ("Coinductive_Nat.epred_inject",
     "[| ?x ~= 0; ?y ~= 0 |] ==> (epred ?x = epred ?y) = (?x = ?y)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 2)),
        template_negation
         (template_equation (template_var 0, template_hole 2))],
       template_bimplication
        (template_equation
          (template_app (template_hole 0, template_var 1),
           template_app (template_hole 0, template_var 0)),
         template_equation (template_var 1, template_var 0)))),
    ("Coinductive_Nat.enat_unfold_unique",
     "(!!x. ?h x = (if ?stop x then 0 else eSuc (?h (?next x)))) ==>
      ?h ?x = enat_unfold ?stop ?next ?x",
     template_implication
      ([template_predicate (template_app (template_hole 6, t_empty))],
       template_equation
        (template_app (template_var 3, template_var 0),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1),
           template_var 0)))),
    ("Coinductive_Nat.Max_enat_minus1",
     "[| finite ?A; ?A ~= {} |] ==> Max ?A - ?m = (MAX n\<in>?A. n - ?m)",
     template_implication
      ([template_predicate (template_app (template_hole 7, template_var 1)),
        template_negation
         (template_equation (template_var 1, template_hole 4))],
       template_equation
        (template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 1)),
           template_var 0),
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, t_empty), template_var 1))))),
    ("Coinductive_Nat.enat_cosplit",
     "?P (case ?n of 0 => ?c | eSuc x => ?d x) =
      ((?n = 0 --> ?P ?c) & (ALL m. ?n = eSuc m --> ?P (?d m)))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_var 3,
              template_app
               (template_app
                 (template_app (template_hole 6, template_var 2),
                  template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 0),
                     template_hole 2)),
                 template_app (template_var 3, template_var 2))),
             template_app (template_hole 1, t_empty))
           ))),
    ("Coinductive_Nat.eadd_partial_function_mono",
     "[| monotone (fun_ord (<=)) (<=) ?f; monotone (fun_ord (<=)) (<=) ?g |]
      ==> monotone (fun_ord (<=)) (<=) (%x. ?f x + ?g x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_hole 2)),
                template_hole 1),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_hole 2)),
                template_hole 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 3, template_hole 2)),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.max_enat_partial_function_mono",
     "[| monotone (fun_ord (<=)) (<=) ?f; monotone (fun_ord (<=)) (<=) ?g |]
      ==> monotone (fun_ord (<=)) (<=) (%x. max (?f x) (?g x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_hole 2)),
                template_hole 1),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_hole 2)),
                template_hole 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 3, template_hole 2)),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.mono2mono_eadd",
     "[| monotone ?orda (<=) ?t; monotone ?orda (<=) ?t' |]
      ==> monotone ?orda (<=) (%x. ?t x + ?t' x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_hole 1),
              t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.mono2mono_max_enat",
     "[| monotone ?orda (<=) ?t; monotone ?orda (<=) ?t' |]
      ==> monotone ?orda (<=) (%x. max (?t x) (?t' x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_hole 1),
              t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 2),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.enat_cosplit_asm",
     "?P (case ?n of 0 => ?c | eSuc x => ?d x) =
      (~ (?n = 0 & ~ ?P ?c | (EX m. ?n = eSuc m & ~ ?P (?d m))))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_var 3,
              template_app
               (template_app
                 (template_app (template_hole 7, template_var 2),
                  template_var 1),
                template_var 0))
            )],
       template_negation
        (
           template_predicate
            (
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, template_var 0),
                         template_hole 2)),
                     template_app
                      (template_hole 6,
                       template_app (template_var 3, template_var 2)))),
                 template_app (template_hole 1, t_empty))
               )
           ))),
    ("Coinductive_Nat.mcont2mcont_enat_minus",
     "[| ?m1 ~= \<infinity>; mcont ?lub ?ord Sup (<=) ?t |]
      ==> mcont ?lub ?ord Sup (<=) (%x. ?t x - ?m1)",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 4)),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 2),
                    template_var 1),
                  template_hole 2),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 3, template_var 2),
                   template_var 1),
                 template_hole 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.enat_cocase_mono",
     "[| monotone ?orda ?ordb ?zero;
         !!n. monotone ?orda ?ordb (%f. ?esuc f n) |]
      ==> monotone ?orda ?ordb
           (%f. case ?x of 0 => ?zero f | eSuc x => ?esuc f x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 2, template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_predicate (template_app (template_hole 1, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 4),
               template_var 3),
             t_empty)
           ))),
    ("Coinductive_Nat.mcont2mcont_eadd",
     "[| mcont ?lub ?ord Sup (<=) ?f; mcont ?lub ?ord Sup (<=) ?g |]
      ==> mcont ?lub ?ord Sup (<=) (%x. ?f x + ?g x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 3),
                    template_var 2),
                  template_hole 2),
                template_hole 1),
              t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 3),
                    template_var 2),
                  template_hole 2),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 3, template_var 3),
                   template_var 2),
                 template_hole 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.mcont2mcont_max_enat",
     "[| mcont ?lub ?ord Sup (<=) ?f; mcont ?lub ?ord Sup (<=) ?g |]
      ==> mcont ?lub ?ord Sup (<=) (%x. max (?f x) (?g x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 3),
                    template_var 2),
                  template_hole 2),
                template_hole 1),
              t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 3, template_var 3),
                    template_var 2),
                  template_hole 2),
                template_hole 1),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 3, template_var 3),
                   template_var 2),
                 template_hole 2),
               template_hole 1),
             t_empty)
           ))),
    ("Coinductive_Nat.enat_cocase_mcont",
     "[| mcont ?luba ?orda ?lubb ?ordb ?zero;
         !!n. mcont ?luba ?orda ?lubb ?ordb (%f. ?esuc f n) |]
      ==> mcont ?luba ?orda ?lubb ?ordb
           (%f. case ?x of 0 => ?zero f | eSuc x => ?esuc f x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 2, template_var 6),
                    template_var 5),
                  template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_predicate (template_app (template_hole 1, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 2, template_var 6),
                   template_var 5),
                 template_var 4),
               template_var 3),
             t_empty)
           ))),
    ("Coinductive_Nat.monotone_enat_le_case",
     "[| monotone (<=) ?ord (%x. ?f x (eSuc x));
         !!x. ?ord ?bot (?f x (eSuc x)); ?ord ?bot ?bot |]
      ==> monotone (<=) ?ord
           (%x. case x of 0 => ?bot | eSuc x' => ?f x' x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_hole 3),
                template_var 2),
              t_empty)
            ),
        template_predicate (template_app (template_hole 1, t_empty)),
        template_predicate
         (
            template_app
             (template_app (template_var 2, template_var 0), template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_hole 3),
               template_var 2),
             t_empty)
           ))),
    ("Coinductive_Nat.mcont_enat_le_case",
     "[| class.ccpo ?lub ?ord (mk_less ?ord);
         mcont Sup (<=) ?lub ?ord (%x. ?f x (eSuc x));
         !!x. ?ord ?bot (?f x (eSuc x)) |]
      ==> mcont Sup (<=) ?lub ?ord
           (%x. case x of 0 => ?bot | eSuc x' => ?f x' x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_var 2),
              template_app (template_hole 6, template_var 2))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 5, template_hole 4),
                    template_hole 3),
                  template_var 3),
                template_var 2),
              t_empty)
            ),
        template_predicate (template_app (template_hole 1, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app (template_hole 5, template_hole 4),
                   template_hole 3),
                 template_var 3),
               template_var 2),
             t_empty)
           ))),
    ("Coinductive_Nat.enat_coinduct",
     "[| ?P ?m ?n;
         !!m n.
            ?P m n ==>
            (m = 0) = (n = 0) &
            (m ~= 0 -->
             n ~= 0 --> ?P (epred m) (epred n) | epred m = epred n) |]
      ==> ?m = ?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_var 2, template_var 1), template_var 0)
            ),
        template_predicate (template_app (template_hole 8, t_empty))],
       template_equation (template_var 1, template_var 0))),
    ("Coinductive_Nat.enat_equalityI",
     "[| (?m, ?n) : ?X;
         !!m n.
            (m, n) : ?X ==>
            m = 0 & n = 0 |
            (EX m' n'.
                m = eSuc m' & n = eSuc n' & ((m', n') : ?X | m' = n')) |]
      ==> ?m = ?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app (template_hole 7, template_var 2),
                  template_var 1)),
              template_var 0)
            ),
        template_predicate (template_app (template_hole 6, t_empty))],
       template_equation (template_var 2, template_var 1))),
    ("Coinductive_Nat.enat_le_coinduct",
     "[| ?P ?m ?n;
         !!m n.
            ?P m n ==>
            (n = 0 --> m = 0) &
            (m ~= 0 -->
             n ~= 0 -->
             (EX k n'. ?P (epred m) n' & epred n = n' + k) |
             epred m <= epred n) |]
      ==> ?m <= ?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_var 2, template_var 1), template_var 0)
            ),
        template_predicate (template_app (template_hole 10, t_empty))],
       template_inequation (less_equals, template_var 1, template_var 0))),
    ("Coinductive_Nat.enat_leI",
     "[| (?m, ?n) : ?X;
         !!m n.
            (m, n) : ?X ==>
            m = 0 |
            (EX m' n' k.
                m = eSuc m' &
                n = n' + enat k & k ~= 0 & ((m', n') : ?X | m' <= n')) |]
      ==> ?m <= ?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 15,
                template_app
                 (template_app (template_hole 14, template_var 2),
                  template_var 1)),
              template_var 0)
            ),
        template_predicate (template_app (template_hole 13, t_empty))],
       template_inequation (less_equals, template_var 2, template_var 1))),
    ("Coinductive_Nat.enat_coinduct2",
     "[| ?P ?m ?n; !!m n. ?P m n ==> (m = 0) = (n = 0);
         !!m n.
            [| ?P m n; m ~= 0; n ~= 0 |]
            ==> ?P (epred m) (epred n) | epred m = epred n |]
      ==> ?m = ?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_var 2, template_var 1), template_var 0)
            ),
        template_predicate (template_app (template_hole 6, t_empty)),
        template_predicate (template_app (template_hole 6, t_empty))],
       template_equation (template_var 1, template_var 0)))]:
   (string * thm * template) list
### theory "Draft.Coinductive_NatMoreTemplates"
### 0.414s elapsed time, 0.563s cpu time, 0.046s GC time
val it = (): unit
