Loading theory "HOL-Library.BNF_Corec" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
Loading theory "HOL-Library.FuncSet" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Lambert_WMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Lambert_WMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
locale cong
  fixes rel :: "('a => 'a => bool) => 'b => 'b => bool"
    and eval :: "'b => 'a"
    and retr :: "('a => 'a => bool) => 'a => 'a => bool"
  assumes "cong rel eval retr"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.126s elapsed time, 0.526s cpu time, 0.044s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Lambert_WMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.205s elapsed time, 0.805s cpu time, 0.084s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Lambert_WMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Nat_Bijection"
### 0.337s elapsed time, 1.351s cpu time, 0.129s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Lambert_WMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.FuncSet"
### 0.414s elapsed time, 1.641s cpu time, 0.204s GC time
Loading theory "HOL-Real_Asymp.Inst_Existentials" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
signature BNF_GFP_GREC_TACTICS =
  sig
    val mk_Lam_Inl_Inr_tac: Proof.context -> thm -> thm -> tactic
    val mk_Retr_coinduct_tac: Proof.context -> thm -> thm -> tactic
    val mk_algLam_algLam_tac:
       Proof.context ->
         thm -> thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_algLam_algrho_tac: Proof.context -> thm -> thm -> tactic
    val mk_algLam_base_tac:
       Proof.context ->
         term ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm ->
                         thm list ->
                           thm ->
                             thm list -> thm list -> thm -> thm -> tactic
    val mk_algLam_step_tac: Proof.context -> thm -> thm -> thm -> tactic
    val mk_cong_locale_tac:
       Proof.context ->
         thm -> thm list -> thm -> thm -> thm list -> thm -> thm -> tactic
    val mk_corecUU_Inl_tac:
       Proof.context ->
         term ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm list ->
                     thm -> thm list -> thm -> thm -> thm -> thm -> tactic
    val mk_corecUU_pointfree_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_corecUU_unique_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_corecU_pointfree_tac:
       Proof.context ->
         thm ->
           thm ->
             thm list ->
               thm ->
                 thm list -> thm -> thm list -> thm -> thm -> thm -> tactic
    val mk_dtor_algLam_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm list ->
                       thm ->
                         thm ->
                           thm list -> thm -> thm -> thm -> thm -> tactic
    val mk_dtor_algrho_tac:
       Proof.context -> thm -> thm -> thm -> thm -> tactic
    val mk_dtor_transfer_tac: Proof.context -> thm -> tactic
    val mk_equivp_Retr_tac:
       Proof.context -> thm -> thm -> thm -> thm -> tactic
    val mk_eval_Oper_tac:
       Proof.context ->
         int ->
           thm ->
             thm -> thm -> thm -> thm -> thm list -> thm -> thm -> tactic
    val mk_eval_V_or_CLeaf_tac:
       Proof.context ->
         thm -> thm -> thm -> thm -> thm -> thm list -> thm -> tactic
    val mk_eval_core_embL_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm ->
                         thm ->
                           thm ->
                             thm list ->
                               thm list -> thm list -> thm -> tactic
    val mk_eval_core_flat_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm list ->
                         thm ->
                           thm list ->
                             thm -> thm -> thm -> thm list -> tactic
    val mk_eval_core_k_as_ssig_tac:
       Proof.context ->
         thm ->
           thm -> thm -> thm list -> thm -> thm -> thm -> thm list -> tactic
    val mk_eval_embL_tac:
       Proof.context -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_eval_flat_tac:
       Proof.context ->
         thm -> thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_eval_sctr_tac:
       Proof.context -> thm -> thm -> thm -> thm -> tactic
    val mk_extdd_mor_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_extdd_o_VLeaf_tac:
       Proof.context ->
         thm ->
           thm -> thm -> thm list -> thm list -> thm -> thm -> thm -> tactic
    val mk_flat_VLeaf_or_flat_tac:
       Proof.context -> thm -> thm -> thm list -> tactic
    val mk_flat_embL_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm list -> thm list -> thm list -> thm list -> tactic
    val mk_mor_cutSsig_flat_tac:
       Proof.context ->
         term ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm list ->
                         thm ->
                           thm ->
                             thm ->
                               thm ->
                                 thm -> thm -> thm -> thm -> thm -> tactic
    val mk_natural_by_unfolding_tac: Proof.context -> thm list -> tactic
    val mk_natural_from_transfer_tac:
       Proof.context ->
         int ->
           bool list -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_sig_transfer_tac:
       Proof.context -> thm -> thm list -> thm -> tactic
    val mk_transfer_by_transfer_prover_tac:
       Proof.context -> thm list -> thm list -> thm list -> tactic
    val transfer_prover_add_tac:
       Proof.context -> thm list -> thm list -> int -> tactic
    val transfer_prover_eq_tac: Proof.context -> int -> tactic
  end
structure BNF_GFP_Grec_Tactics: BNF_GFP_GREC_TACTICS
signature INST_EXISTENTIALS =
  sig val tac: Proof.context -> term list -> int -> tactic end
structure Inst_Existentials: INST_EXISTENTIALS
### theory "HOL-Real_Asymp.Inst_Existentials"
### 0.042s elapsed time, 0.174s cpu time, 0.000s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Lambert_WMoreTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  sdrop :: "nat => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 0.989s elapsed time, 3.808s cpu time, 0.806s GC time
Loading theory "HOL-Library.Landau_Symbols" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
### theory "HOL-Library.BigO"
### 0.874s elapsed time, 3.364s cpu time, 0.730s GC time
Loading theory "HOL-Real_Asymp.Eventuallize" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
Found termination order: "size <*mlex*> {}"
signature EVENTUALLIZE =
  sig val eventuallize: Proof.context -> thm -> int option -> thm end
structure Eventuallize: EVENTUALLIZE
### theory "HOL-Real_Asymp.Eventuallize"
### 0.080s elapsed time, 0.312s cpu time, 0.078s GC time
Loading theory "HOL-Real_Asymp.Lazy_Eval" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds" via "HOL-Real_Asymp.Multiseries_Expansion")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale landau_symbol
  fixes L :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and L' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and Lr :: "'a filter => ('a => real) => ('a => real) set"
  assumes "landau_symbol L L' Lr"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  CMP_BRANCH :: "cmp_result => 'a => 'a => 'a => 'a"
locale landau_pair
  fixes L :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and l :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and L' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and l' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and Lr :: "'a filter => ('a => real) => ('a => real) set"
    and lr :: "'a filter => ('a => real) => ('a => real) set"
    and R :: "real => real => bool"
  assumes "landau_pair L l L' l' Lr lr R"
### ML warning (line 177 of "~~/src/HOL/Real_Asymp/lazy_eval.ML"):
### Value identifier (instantiate) has not been referenced.
### ML warning (line 180 of "~~/src/HOL/Real_Asymp/lazy_eval.ML"):
### Value identifier (rhs) has not been referenced.
signature LAZY_EVAL =
  sig
    val add_facts: thm list -> eval_ctxt -> eval_ctxt
    val add_hook: eval_hook -> eval_ctxt -> eval_ctxt
    type constructor = string * int
    val constructor_arity: constructor list -> string -> int option
    type equation = {function: term, pats: pat list, rhs: term, thm: thm}
    type eval_ctxt = {ctxt: eval_ctxt', hooks: eval_hook list}
    type eval_ctxt' =
       {constructors: constructor list,
        equations: equation list,
        facts: thm Net.net, pctxt: Proof.context, verbose: bool}
    type eval_hook = eval_ctxt' -> term -> (term * conv) option
    val get_constructors: eval_ctxt -> constructor list
    val get_ctxt: eval_ctxt -> Proof.context
    val get_facts: eval_ctxt -> thm list
    val get_verbose: eval_ctxt -> bool
    val is_constructor_name: constructor list -> string -> bool
    val match:
       eval_ctxt ->
         pat ->
           term ->
             (indexname * term) list option ->
               (indexname * term) list option * term * conv
    val match_all:
       eval_ctxt ->
         pat list ->
           term list ->
             (indexname * term) list option ->
               (indexname * term) list option * term list * conv
    val mk_eval_ctxt:
       Proof.context -> constructor list -> thm list -> eval_ctxt
    datatype pat = AnyPat of indexname | ConsPat of string * pat list
    val set_constructors: constructor list -> eval_ctxt -> eval_ctxt
    val set_verbose: bool -> eval_ctxt -> eval_ctxt
    val whnf: eval_ctxt -> term -> term * conv
  end
structure Lazy_Eval: LAZY_EVAL
### theory "HOL-Real_Asymp.Lazy_Eval"
### 0.503s elapsed time, 1.983s cpu time, 0.164s GC time
locale landau_pair
  fixes L :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and l :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and L' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and l' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and Lr :: "'a filter => ('a => real) => ('a => real) set"
    and lr :: "'a filter => ('a => real) => ('a => real) set"
    and R :: "real => real => bool"
  assumes "landau_pair L l L' l' Lr lr R"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale landau_pair
  fixes L :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and l :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and L' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and l' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and Lr :: "'a filter => ('a => real) => ('a => real) set"
    and lr :: "'a filter => ('a => real) => ('a => real) set"
    and R :: "real => real => bool"
  assumes "landau_pair L l L' l' Lr lr R"
Found termination order: "size <*mlex*> {}"
locale landau_symbol
  fixes L :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and L' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and Lr :: "'a filter => ('a => real) => ('a => real) set"
  assumes "landau_symbol L L' Lr"
### theory "HOL-Library.Tree"
### 2.017s elapsed time, 7.468s cpu time, 1.139s GC time
Loading theory "Draft.Templates" (required by "Draft.Lambert_WMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.083s elapsed time, 0.262s cpu time, 0.081s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Lambert_WMoreTemplates")
locale landau_symbol
  fixes L :: "'a filter => ('a => 'b) => ('a => 'b) set"
    and L' :: "'c filter => ('c => 'b) => ('c => 'b) set"
    and Lr :: "'a filter => ('a => real) => ('a => real) set"
  assumes "landau_symbol L L' Lr"
bundle asymp_equiv_notation
### theory "HOL-Library.Landau_Symbols"
### 1.919s elapsed time, 6.395s cpu time, 1.254s GC time
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.845s elapsed time, 2.608s cpu time, 0.840s GC time
### ML warning (line 261 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 290 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 456 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 512 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 563 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 603 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 900 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 1233 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 1268 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 1294 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 1621 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 1670 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 1808 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 1809 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2059 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2064 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2133 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2149 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2150 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2151 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2152 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2154 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2155 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2157 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2158 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2183 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2370 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2371 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2400 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2401 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2402 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2404 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2408 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2412 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2436 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2477 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2267 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 2594 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2599 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2711 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2712 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2713 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2752 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2753 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2754 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2756 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2758 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2765 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2792 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 2569 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 2914 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 3014 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
### ML warning (line 3064 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3072 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3078 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3085 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Value identifier (fp_alives) has not been referenced.
### ML warning (line 3093 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3149 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Pattern is not exhaustive.
### ML warning (line 3212 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec.ML"):
### Matches are not exhaustive.
signature BNF_GFP_GREC =
  sig
    val Tsubst: typ -> typ -> typ -> typ
    val bnf_kill_all_but:
       int -> BNF_Def.bnf -> local_theory -> BNF_Def.bnf * local_theory
    type buffer =
       {CLeaf: term,
        Oper: term,
        VLeaf: term, ctr_wrapper: term, friends: (typ * term) Symtab.table}
    type corec_info =
       {Lam: term,
        Lam_pointful_natural: thm,
        Lam_transfer: thm,
        Retr: term,
        Retr_coinduct: thm,
        Y: typ,
        Z: typ,
        algLam: term,
        algLam_thm: thm,
        all_algLam_algs: thm list,
        all_dead_k_bnfs: BNF_Def.bnf list,
        buffer: buffer,
        corecUU: term,
        corecUU_thm: thm,
        corecUU_transfer: thm,
        corecUU_unique: thm,
        dtor_algLam: thm, dtor_coinduct_info: dtor_coinduct_info, ...}
    val corec_info_of: typ -> local_theory -> corec_info * local_theory
    val corec_infos_of: Proof.context -> string -> corec_info list
    val corec_infos_of_generic:
       Context.generic -> Symtab.key -> corec_info list
    val define_const:
       bool ->
         binding ->
           int ->
             string -> term -> local_theory -> (term * thm) * local_theory
    type dtor_coinduct_info =
       {cong_alg_intros: thm list,
        cong_base: thm,
        cong_def: thm,
        cong_locale: thm,
        cong_refl: thm, cong_sym: thm, cong_trans: thm, dtor_coinduct: thm}
    val dummify_atomic_types: term -> term
    val freeze_types:
       Proof.context -> (indexname * sort) list -> typ list -> typ list
    type friend_info = {algLam_algrho: thm, algrho: term, dtor_algrho: thm}
    val has_no_corec_info: Proof.context -> string -> bool
    val map_buffer: (term -> term) -> buffer -> buffer
    val maybe_corec_info_of: Proof.context -> typ -> corec_info option
    val mk_fp_binding: binding -> string -> binding
    val not_codatatype: Proof.context -> typ -> 'a
    val prepare_friend_corec:
       string ->
         typ ->
           local_theory ->
             (corec_info * binding * int * typ * typ * typ * typ * typ *
              BNF_Def.bnf * BNF_Def.bnf * BNF_FP_Def_Sugar.fp_sugar *
              BNF_FP_Def_Sugar.fp_sugar * buffer)
             *
             local_theory
    val print_corec_infos: Proof.context -> unit
    val register_friend_corec:
       string ->
         binding ->
           int ->
             typ ->
               typ ->
                 typ ->
                   BNF_Def.bnf ->
                     BNF_FP_Def_Sugar.fp_sugar ->
                       BNF_FP_Def_Sugar.fp_sugar ->
                         term ->
                           term ->
                             thm ->
                               corec_info ->
                                 local_theory -> friend_info * local_theory
    val specialize_buffer_types: buffer -> buffer
    val substT: typ -> typ -> term -> term
  end
structure BNF_GFP_Grec: BNF_GFP_GREC
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 163 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 188 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Pattern is not exhaustive.
### ML warning (line 329 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar_util.ML"):
### Matches are not exhaustive.
signature BNF_GFP_GREC_SUGAR_UTIL =
  sig
    exception UNNATURAL of unit
    val corec_parse_info_of:
       Proof.context ->
         typ list -> typ -> BNF_GFP_Grec.buffer -> s_parse_info
    val friend_parse_info_of:
       Proof.context ->
         typ list ->
           typ -> BNF_GFP_Grec.buffer -> s_parse_info * rho_parse_info
    val generalize_types: int -> typ -> typ -> typ
    val mk_abs_transfer: Proof.context -> string -> thm
    val mk_const_transfer_goal: Proof.context -> string * typ -> term
    val mk_curry_uncurryN_balanced: Proof.context -> int -> thm
    val mk_pointful_natural_from_transfer: Proof.context -> thm -> thm
    val mk_rep_transfer: Proof.context -> string -> thm
    type rho_parse_info =
       {discs: term Symtab.table,
        it: term,
        mk_case: typ -> term,
        pattern_ctrs: (term * term list) Symtab.table,
        sels: term Symtab.table}
    type s_parse_info =
       {ctr_guards: term Symtab.table,
        inner_buffer: BNF_GFP_Grec.buffer,
        outer_buffer: BNF_GFP_Grec.buffer}
  end
structure BNF_GFP_Grec_Sugar_Util: BNF_GFP_GREC_SUGAR_UTIL
signature BNF_GFP_GREC_SUGAR_TACTICS =
  sig
    val mk_case_dtor_tac:
       Proof.context ->
         term -> thm -> thm -> thm list -> thm -> thm list -> tactic
    val mk_code_tac:
       Proof.context ->
         int ->
           term list ->
             term ->
               term ->
                 thm ->
                   thm ->
                     thm list ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm ->
                               thm ->
                                 thm list ->
                                   thm list ->
                                     thm ->
                                       thm list ->
   thm list -> thm list -> thm list -> ...
    val mk_cong_intro_ctr_or_friend_tac:
       Proof.context -> thm -> thm list -> thm -> tactic
    val mk_eq_algrho_tac:
       Proof.context ->
         term list ->
           term ->
             term ->
               term ->
                 term ->
                   term ->
                     thm ->
                       thm ->
                         thm list ->
                           thm list ->
                             thm list ->
                               thm list ->
                                 thm ->
                                   thm ->
                                     thm ->
                                       thm list ->
   thm list -> thm list -> thm -> ...
    val mk_eq_corecUU_tac:
       Proof.context ->
         int ->
           term list ->
             term ->
               term ->
                 thm ->
                   thm ->
                     thm list ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm ->
                               thm ->
                                 thm list ->
                                   thm list ->
                                     thm list ->
                                       thm list ->
   thm list -> thm list -> thm list -> ...
    val mk_last_disc_tac: Proof.context -> term -> thm -> thm list -> tactic
    val mk_rho_transfer_tac:
       Proof.context -> bool -> thm -> thm list -> tactic
    val mk_unique_tac:
       Proof.context ->
         int ->
           term list ->
             term ->
               term ->
                 thm ->
                   thm ->
                     thm list ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm ->
                               thm ->
                                 thm list ->
                                   thm list ->
                                     thm list ->
                                       thm list ->
   thm list -> thm list -> thm list -> ...
    val rho_transfer_simps: thm list
  end
structure BNF_GFP_Grec_Sugar_Tactics: BNF_GFP_GREC_SUGAR_TACTICS
### ML warning (line 62 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (ctrN) has not been referenced.
### ML warning (line 63 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (discN) has not been referenced.
### ML warning (line 64 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (disc_iffN) has not been referenced.
### ML warning (line 72 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (selN) has not been referenced.
### ML warning (line 78 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (simp_attrs) has not been referenced.
### ML warning (line 218 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 223 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 254 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 256 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 316 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 319 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 321 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 360 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 362 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (file "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 417 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 439 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 442 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 445 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (file "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 541 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 542 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 561 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 562 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (file "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 595 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 597 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (file "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 621 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 623 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 626 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (file "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 643 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (file "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 660 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 652 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 713 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 785 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 786 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 799 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1091 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1092 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1150 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1151 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1187 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1219 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1214 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1243 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1316 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1368 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1399 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1658 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1692 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1737 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1806 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1807 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1817 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1853 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1862 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1825 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1875 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1878 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1880 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1938 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1918 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1955 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1970 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Value identifier (transfer) has not been referenced.
### ML warning (line 1971 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2029 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2031 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2032 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2033 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2037 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2050 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2120 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2204 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2214 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2229 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2248 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2288 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2320 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2330 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2338 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_sugar.ML"):
### Pattern is not exhaustive.
signature BNF_GFP_GREC_SUGAR =
  sig
    val build_corecUU_arg_and_goals:
       bool ->
         term ->
           term list * term ->
             local_theory ->
               (((thm list * thm list * thm list) * term list) * term) *
               local_theory
    val coinduction_upto_cmd:
       string * string -> local_theory -> local_theory
    val corec_cmd:
       bool ->
         corec_option list ->
           (binding * string option * mixfix) list * string ->
             local_theory -> local_theory
    datatype corec_option
    =
         Friend_Option
       | Plugins_Option of Proof.context -> Plugin_Name.filter
       | Transfer_Option
    val corecursive_cmd:
       bool ->
         corec_option list ->
           (binding * string option * mixfix) list * string ->
             local_theory -> Proof.state
    val derive_eq_corecUU:
       Proof.context ->
         BNF_GFP_Grec.corec_info -> term -> term -> thm -> thm
    val derive_unique:
       Proof.context ->
         morphism -> term -> BNF_GFP_Grec.corec_info -> string -> thm -> thm
    val explore_corec_equation:
       Proof.context ->
         bool ->
           bool ->
             string ->
               term ->
                 BNF_GFP_Grec_Sugar_Util.s_parse_info ->
                   typ -> term list * term -> term list * term
    val friend_of_corec_cmd:
       (string * string option) * string -> local_theory -> Proof.state
    val parse_corec_equation:
       Proof.context -> term list -> term -> term list * term
  end
structure BNF_GFP_Grec_Sugar: BNF_GFP_GREC_SUGAR
### ML warning (line 58 of "~~/src/HOL/Tools/BNF/bnf_gfp_grec_unique_sugar.ML"):
### Pattern is not exhaustive.
signature BNF_GFP_GREC_UNIQUE_SUGAR =
  sig val corec_unique_tac: Proof.context -> int -> tactic end
structure BNF_GFP_Grec_Unique_Sugar: BNF_GFP_GREC_UNIQUE_SUGAR
### theory "HOL-Library.BNF_Corec"
### 4.876s elapsed time, 13.891s cpu time, 3.013s GC time
Loading theory "HOL-Real_Asymp.Multiseries_Expansion" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W" via "HOL-Real_Asymp.Real_Asymp" via "HOL-Real_Asymp.Multiseries_Expansion_Bounds")
consts
  mssnth :: "'a msstream => nat => 'a"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  msllist_of_msstream :: "'a msstream => 'a msllist"
consts
  mssalternate :: "'a => 'a => 'a msstream"
consts
  exp_series_stream_aux :: "real => real => real msstream"
consts
  ln_series_stream_aux :: "bool => real => real msstream"
consts
  gbinomial_series_aux :: "bool => real => real => real => real msllist"
consts
  sin_series_stream_aux :: "bool => real => real => real msstream"
consts
  arctan_series_stream_aux :: "bool => real => real msstream"
class multiseries = inverse + minus + plus + times + uminus +
  fixes is_expansion :: "'a => (real => real) list => bool"
    and expansion_level :: "'a itself => nat"
    and eval :: "'a => real => real"
    and zero_expansion :: "'a"
    and const_expansion :: "real => 'a"
    and powr_expansion :: "bool => 'a => real => 'a"
    and power_expansion :: "bool => 'a => nat => 'a"
    and trimmed :: "'a => bool"
    and dominant_term :: "'a => real * real list"
  assumes
    "is_expansion_length":
      "!!F basis.
          is_expansion F basis ==> length basis = expansion_level TYPE('a)"
  assumes
    "is_expansion_zero":
      "!!basis.
          [| basis_wf basis; length basis = expansion_level TYPE('a) |]
          ==> is_expansion zero_expansion basis"
  assumes
    "is_expansion_const":
      "!!basis c.
          [| basis_wf basis; length basis = expansion_level TYPE('a) |]
          ==> is_expansion (const_expansion c) basis"
  assumes
    "is_expansion_uminus":
      "!!basis F.
          [| basis_wf basis; is_expansion F basis |]
          ==> is_expansion (- F) basis"
  assumes
    "is_expansion_add":
      "!!basis F G.
          [| basis_wf basis; is_expansion F basis; is_expansion G basis |]
          ==> is_expansion (F + G) basis"
  assumes
    "is_expansion_minus":
      "!!basis F G.
          [| basis_wf basis; is_expansion F basis; is_expansion G basis |]
          ==> is_expansion (F - G) basis"
  assumes
    "is_expansion_mult":
      "!!basis F G.
          [| basis_wf basis; is_expansion F basis; is_expansion G basis |]
          ==> is_expansion (F * G) basis"
  assumes
    "is_expansion_inverse":
      "!!basis F.
          [| basis_wf basis; trimmed F; is_expansion F basis |]
          ==> is_expansion (inverse F) basis"
  assumes
    "is_expansion_divide":
      "!!basis G F.
          [| basis_wf basis; trimmed G; is_expansion F basis;
             is_expansion G basis |]
          ==> is_expansion (F / G) basis"
  assumes
    "is_expansion_powr":
      "!!basis F abort p.
          [| basis_wf basis; trimmed F; 0 < fst (dominant_term F);
             is_expansion F basis |]
          ==> is_expansion (powr_expansion abort F p) basis"
  assumes
    "is_expansion_power":
      "!!basis F abort n.
          [| basis_wf basis; trimmed F; is_expansion F basis |]
          ==> is_expansion (power_expansion abort F n) basis"
  assumes
    "is_expansion_imp_smallo":
      "!!basis F b e.
          [| basis_wf basis; is_expansion F basis;
             filterlim b at_top at_top;
             ALL g:set basis. (%x. ln (g x)) : o(%x. ln (b x)); 0 < e |]
          ==> eval F : o(%x. b x powr e)"
  assumes
    "is_expansion_imp_smallomega":
      "!!basis F b e.
          [| basis_wf basis; is_expansion F basis;
             filterlim b at_top at_top; trimmed F;
             ALL g:set basis. (%x. ln (g x)) : o(%x. ln (b x)); e < 0 |]
          ==> eval F : \<omega>(%x. b x powr e)"
  assumes
    "trimmed_imp_eventually_sgn":
      "!!basis F.
          [| basis_wf basis; is_expansion F basis; trimmed F |]
          ==> \<forall>\<^sub>F x in at_top.
                 sgn (eval F x) = sgn (fst (dominant_term F))"
  assumes
    "trimmed_imp_eventually_nz":
      "!!basis F.
          [| basis_wf basis; is_expansion F basis; trimmed F |]
          ==> \<forall>\<^sub>F x in at_top. eval F x ~= 0"
  assumes
    "trimmed_imp_dominant_term_nz":
      "!!F. trimmed F ==> fst (dominant_term F) ~= 0"
  assumes
    "dominant_term":
      "!!basis F.
          [| basis_wf basis; is_expansion F basis; trimmed F |]
          ==> eval F \<sim>[at_top] eval_monom (dominant_term F) basis"
  assumes
    "dominant_term_bigo":
      "!!basis F.
          [| basis_wf basis; is_expansion F basis |]
          ==> eval F : O(eval_monom (1, snd (dominant_term F)) basis)"
  assumes
    "length_dominant_term":
      "!!F. length (snd (dominant_term F)) = expansion_level TYPE('a)"
  assumes
    "fst_dominant_term_uminus":
      "!!F. fst (dominant_term (- F)) = - fst (dominant_term F)"
  assumes "trimmed_uminus_iff": "!!F. trimmed (- F) = trimmed F"
  assumes "add_zero_expansion_left": "!!F. zero_expansion + F = F"
  assumes "add_zero_expansion_right": "!!F. F + zero_expansion = F"
  assumes "eval_zero": "!!x. eval zero_expansion x = 0"
  assumes "eval_const": "!!c x. eval (const_expansion c) x = c"
  assumes "eval_uminus": "!!F. eval (- F) = (%x. - eval F x)"
  assumes "eval_plus": "!!F G. eval (F + G) = (%x. eval F x + eval G x)"
  assumes "eval_minus": "!!F G. eval (F - G) = (%x. eval F x - eval G x)"
  assumes "eval_times": "!!F G. eval (F * G) = (%x. eval F x * eval G x)"
  assumes "eval_inverse": "!!F. eval (inverse F) = (%x. inverse (eval F x))"
  assumes "eval_divide": "!!F G. eval (F / G) = (%x. eval F x / eval G x)"
  assumes
    "eval_powr":
      "!!abort F p. eval (powr_expansion abort F p) = (%x. eval F x powr p)"
  assumes
    "eval_power":
      "!!abort F n. eval (power_expansion abort F n) = (%x. eval F x ^ n)"
  assumes "minus_eq_plus_uminus": "!!F G. F - G = F + - G"
  assumes "times_const_expansion_1": "!!F. const_expansion 1 * F = F"
  assumes
    "trimmed_const_expansion": "!!c. trimmed (const_expansion c) = (c ~= 0)"
instantiation
  real :: multiseries
  is_expansion_real == is_expansion :: real => (real => real) list => bool
  expansion_level_real == expansion_level :: real itself => nat
  eval_real == eval :: real => real => real
  zero_expansion_real == zero_expansion :: real
  const_expansion_real == const_expansion :: real => real
  powr_expansion_real == powr_expansion :: bool => real => real => real
  power_expansion_real == power_expansion :: bool => real => nat => real
  trimmed_real == trimmed :: real => bool
  dominant_term_real == dominant_term :: real => real * real list
Proofs for inductive predicate(s) "is_expansion_real"
  Proving monotonicity ...
consts
  ms_exp_gt :: "real => real option => bool"
Proofs for coinductive predicate(s) "is_expansion_aux"
  Proving monotonicity ...
consts
  plus_ms_aux ::
    "('a * real) msllist => ('a * real) msllist => ('a * real) msllist"
consts
  times_ms_aux ::
    "('a * real) msllist => ('a * real) msllist => ('a * real) msllist"
consts
  powser_ms_aux ::
    "real msllist => ('a * real) msllist => ('a * real) msllist"
### Missing patterns in function definition:
### inverse_ms_aux MSLNil = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### !!a c. powr_ms_aux a MSLNil c = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### !!a c. power_ms_aux a MSLNil c = undefined
Found termination order: "{}"
Proofs for inductive predicate(s) "ms_closure"
  Proving monotonicity ...
instantiation
  ms :: (uminus) uminus
  uminus_ms == uminus :: 'a ms => 'a ms
consts
  uminus_ms :: "'a ms => 'a ms"
instantiation
  ms :: (plus) plus
  plus_ms == plus :: 'a ms => 'a ms => 'a ms
Found termination order: "{}"
instantiation
  ms :: ({plus,uminus}) minus
  minus_ms == minus :: 'a ms => 'a ms => 'a ms
instantiation
  ms :: ({plus,times}) times
  times_ms == times :: 'a ms => 'a ms => 'a ms
Found termination order: "{}"
instantiation
  ms :: (multiseries) inverse
  inverse_ms == inverse :: 'a ms => 'a ms
  divide_ms == divide :: 'a ms => 'a ms => 'a ms
Found termination order: "{}"
Found termination order: "{}"
instantiation
  ms :: (multiseries) multiseries
  is_expansion_ms == is_expansion :: 'a ms => (real => real) list => bool
  expansion_level_ms == expansion_level :: 'a ms itself => nat
  eval_ms == eval :: 'a ms => real => real
  zero_expansion_ms == zero_expansion :: 'a ms
  const_expansion_ms == const_expansion :: real => 'a ms
  powr_expansion_ms == powr_expansion :: bool => 'a ms => real => 'a ms
  power_expansion_ms == power_expansion :: bool => 'a ms => nat => 'a ms
  trimmed_ms == trimmed :: 'a ms => bool
  dominant_term_ms == dominant_term :: 'a ms => real * real list
consts
  is_expansion_ms :: "'a ms => (real => real) list => bool"
consts
  eval_ms :: "'a ms => real => real"
consts
  powr_expansion_ms :: "bool => 'a ms => real => 'a ms"
consts
  power_expansion_ms :: "bool => 'a ms => nat => 'a ms"
consts
  trimmed_ms :: "'a ms => bool"
consts
  dominant_term_ms :: "'a ms => real * real list"
Proofs for inductive predicate(s) "expands_to"
  Proving monotonicity ...
Proofs for coinductive predicate(s) "asymp_powser"
  Proving monotonicity ...
consts
  flip_cmp_result :: "cmp_result => cmp_result"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
consts
  compare_list_0 :: "real list => cmp_result"
signature ASYMPTOTIC_BASIS =
  sig
    exception BASIS of string * basis
    datatype basis = SEmpty | SNE of basis'
    datatype basis'
    = SCons of basis_info * basis_ln_info * basis' | SSng of basis_info
    val basis_eq: basis -> basis -> bool
    val basis_eq': basis' -> basis' -> bool
    type basis_info = {head: term, wf_thm: thm}
    type basis_ln_info = {ln_thm: thm, trimmed_thm: thm}
    val basis_size: basis -> int
    val basis_size': basis' -> int
    val check_basis: basis -> basis
    val check_basis': basis' -> basis'
    val combine_lifts: lifting -> lifting -> lifting
    val default_basis: basis
    val extract_basis_list: thm -> term list
    val get_basis_head: basis -> term
    val get_basis_head': basis' -> term
    val get_basis_list: basis -> term list
    val get_basis_list': basis' -> term list
    val get_basis_term: basis -> term
    val get_basis_wf_thm: basis -> thm
    val get_basis_wf_thm': basis' -> thm
    val get_ln_info: basis -> basis_ln_info option
    val insert_ln: basis -> basis
    val insert_ln': basis' -> basis'
    val lift: basis -> thm -> thm
    val lift_expands_to_thm: lifting -> thm -> thm
    val lift_modification: basis -> basis -> basis
    val lift_modification': basis' -> basis' -> basis'
    val lift_trimmed_pos_thm: lifting -> thm -> thm
    val lift_trimmed_thm: lifting -> thm -> thm
    type lifting
    val mk_expansion_level_eq_thm: basis -> thm
    val mk_expansion_level_eq_thm': basis' -> thm
    val mk_lifting: term list -> basis -> lifting
    val split_basis:
       basis -> (basis_info * basis_ln_info option * basis) option
    val split_basis': basis' -> basis_info * basis_ln_info option * basis
    val tl_basis: basis -> basis
    val tl_basis': basis' -> basis
  end
structure Asymptotic_Basis: ASYMPTOTIC_BASIS
### ML warning (line 518 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
### ML warning (line 551 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
### ML warning (line 583 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
### ML warning (line 615 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
### ML warning (line 646 of "~~/src/HOL/Real_Asymp/exp_log_expression.ML"):
### Matches are not exhaustive.
signature EXP_LOG_EXPRESSION =
  sig
    exception DUP
    type custom_handler =
       Lazy_Eval.eval_ctxt ->
         term ->
           thm list * Asymptotic_Basis.basis -> thm * Asymptotic_Basis.basis
    val expand_custom: Proof.context -> string -> custom_handler option
    datatype expr
    =
         Absolute of expr
       | Add of expr * expr
       | ArcTan of expr
       | Ceiling of expr
       | ConstExpr of term
       | Cos of expr
       | Custom of string * term * expr list
       | Div of expr * expr
       | Exp of expr
       | ExpLn of expr
       | Floor of expr
       | Frac of expr
       | Inverse of expr
       | Ln of expr
       | LnPowr of expr * expr
       | Max of expr * expr
       | Min of expr * expr
       | Minus of expr * expr
       | Mult of ...
       | ...
    val expr_to_term: expr -> term
    val limit_maple: string -> string
    val limit_mathematica: string -> string
    val limit_maxima: string -> string
    val limit_sage: string -> string
    val limit_sympy: string -> string
    val preproc_term_conv: Proof.context -> conv
    val register_custom:
       binding -> term -> custom_handler -> local_theory -> local_theory
    val register_custom_from_thm:
       binding -> thm -> custom_handler -> local_theory -> local_theory
    val reify: Proof.context -> term -> expr * thm
    val reify_maple: Proof.context -> term -> string
    val reify_mathematica: Proof.context -> term -> string
    val reify_maxima: Proof.context -> term -> string
    val reify_sage: Proof.context -> term -> string
    val reify_simple: Proof.context -> term -> expr * thm
    val reify_sympy: Proof.context -> term -> string
    val to_maple: expr -> string
    val to_mathematica: expr -> string
    val to_maxima: expr -> string
    val to_sage: expr -> string
    val to_sympy: expr -> string
  end
structure Exp_Log_Expression: EXP_LOG_EXPRESSION
signature EXPANSION_INTERFACE =
  sig
    type T
    val expand_term:
       Lazy_Eval.eval_ctxt ->
         term -> Asymptotic_Basis.basis -> T * Asymptotic_Basis.basis
    val expand_terms:
       Lazy_Eval.eval_ctxt ->
         term list ->
           Asymptotic_Basis.basis -> T list * Asymptotic_Basis.basis
    val prove_asymp_equiv:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_at_0: Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_bot:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_infinity:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_left_0:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_right_0:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_at_top:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_bigo:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_bigtheta:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_eventually_greater:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_eventually_less:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
    val prove_eventually_nonzero:
       Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_nhds: Lazy_Eval.eval_ctxt -> T * Asymptotic_Basis.basis -> thm
    val prove_smallo:
       Lazy_Eval.eval_ctxt -> T * T * Asymptotic_Basis.basis -> thm
  end
### ML warning (line 575 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Value identifier (ectxt) has not been referenced.
### ML warning (line 1174 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1175 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1255 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1246 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1379 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1404 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1399 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Matches are not exhaustive.
### ML warning (line 1501 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 1490 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2010 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2033 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2068 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Matches are not exhaustive.
### ML warning (line 2077 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2129 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2144 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2176 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
### ML warning (line 2191 of "~~/src/HOL/Real_Asymp/multiseries_expansion.ML"):
### Pattern is not exhaustive.
signature MULTISERIES_EXPANSION =
  sig
    val arctan_expansion:
       Lazy_Eval.eval_ctxt -> basis -> expansion_thm -> expansion_thm
    type basis
    val check_expansion: expr -> expansion_thm -> expansion_thm
    val compare_expansions:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis ->
           order * thm * expansion_thm * expansion_thm
    val compare_expansions':
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> comparison_result
    datatype comparison_result
    =
         Cmp_Asymp_Equiv of thm * thm
       | Cmp_Dominated of
           order * thm list * zeroness * trimmed_thm * expansion_thm *
           expansion_thm
    val compute_limit: Lazy_Eval.eval_ctxt -> term -> limit * thm
    val const_expansion:
       Lazy_Eval.eval_ctxt -> basis -> term -> expansion_thm
    val ev_zeroness_oracle: Lazy_Eval.eval_ctxt -> term -> thm option
    val exp_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm -> basis -> expansion_thm * basis
    val expand:
       Lazy_Eval.eval_ctxt -> expr -> basis -> expansion_thm * basis
    val expand_term:
       Lazy_Eval.eval_ctxt -> term -> basis -> expansion_thm * basis
    val expand_terms:
       Lazy_Eval.eval_ctxt ->
         term list -> basis -> expansion_thm list * basis
    val expands_to_hd: thm -> thm
    type expansion_thm
    eqtype expr
    val extract_terms:
       int * bool ->
         Lazy_Eval.eval_ctxt -> basis -> term -> term * term option
    val get_coeff: term -> term
    val get_eval: term -> term
    val get_expanded_fun: thm -> term
    val get_expansion: thm -> term
    val get_exponent: term -> term
    val get_intyness: Proof.context -> cterm -> intyness
    val get_parity: cterm -> parity
    val get_sign_oracles:
       Context.generic -> (string * (Proof.context -> int -> tactic)) list
    datatype intyness = Nat of thm | Neg_Nat of thm | No_Nat
    datatype limit
    =
         Finite_Limit of term
       | Infinite_Limit of bool option
       | Zero_Limit of bool option
    val limit_of_expansion:
       bool * bool -> Lazy_Eval.eval_ctxt -> thm * basis -> limit * thm
    val ln_expansion:
       Lazy_Eval.eval_ctxt ->
         trimmed_thm -> expansion_thm -> basis -> expansion_thm * basis
    val max_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm
    val min_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm
    val mk_eval_ctxt: Proof.context -> Lazy_Eval.eval_ctxt
    datatype parity = Even of thm | Odd of thm | Unknown_Parity
    val power_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val powr_const_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val powr_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm * basis
    val powr_nat_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm * basis
    val prove_asymp_equiv: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_asymptotic_relation:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> order * thm
    val prove_at_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_bot: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_infinity: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_left_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_right_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_top: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_bigo: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_bigtheta: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_compare_expansions: order -> thm list -> thm
    val prove_eventually_greater:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_eventually_less:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_eventually_nonzero: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_nhds: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_smallo: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val register_sign_oracle:
       binding * (Proof.context -> int -> tactic) ->
         Context.generic -> Context.generic
    val retrim_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * basis -> expansion_thm * thm
    val retrim_pos_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * basis * trimmed_thm ->
           expansion_thm * thm * trimmed_thm
    val root_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val sgn_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * basis -> expansion_thm
    val simplify_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm -> expansion_thm
    val simplify_term: Lazy_Eval.eval_ctxt -> term -> term
    val simplify_trimmed_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * trimmed_thm -> expansion_thm * trimmed_thm
    val solve_eval_eq: thm -> thm
    val trim_expansion:
       bool ->
         trim_mode option ->
           Lazy_Eval.eval_ctxt ->
             expansion_thm * basis ->
               expansion_thm * zeroness * trimmed_thm option
    val trim_expansion_while_greater:
       bool ->
         term list option ->
           bool ->
             trim_mode option ->
               Lazy_Eval.eval_ctxt ->
                 thm * basis -> thm * trim_result * (zeroness * thm) list
    datatype trim_mode = Neg_Trim | Pos_Trim | Sgn_Trim | Simple_Trim
    datatype trim_result
    = Aborted of order | Trimmed of zeroness * trimmed_thm option
    type trimmed_thm
    val try_drop_leading_term_ex:
       bool -> Lazy_Eval.eval_ctxt -> expansion_thm -> expansion_thm option
    val try_prove_ev_eq: Lazy_Eval.eval_ctxt -> term * term -> thm option
    val try_prove_real_eq:
       bool -> Lazy_Eval.eval_ctxt -> term * term -> thm option
    val whnf_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm -> term option * expansion_thm * thm
    val zero_expansion: basis -> expansion_thm
    datatype zeroness = IsNeg | IsNonZero | IsPos | IsZero
    val zeroness_oracle:
       bool ->
         trim_mode option ->
           Lazy_Eval.eval_ctxt -> term -> zeroness * thm option
  end
structure Multiseries_Expansion: MULTISERIES_EXPANSION
structure Multiseries_Expansion_Basic: EXPANSION_INTERFACE
### ML warning (line 45 of "~~/src/HOL/Real_Asymp/real_asymp.ML"):
### Pattern is not exhaustive.
### ML warning (line 58 of "~~/src/HOL/Real_Asymp/real_asymp.ML"):
### Pattern is not exhaustive.
signature REAL_ASYMP =
  sig val tac: bool -> Proof.context -> int -> tactic end
structure Real_Asymp_Basic: REAL_ASYMP
functor Real_Asymp (Exp: EXPANSION_INTERFACE): REAL_ASYMP
### theory "HOL-Real_Asymp.Multiseries_Expansion"
### 14.228s elapsed time, 16.330s cpu time, 2.857s GC time
Loading theory "HOL-Real_Asymp.Multiseries_Expansion_Bounds" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W" via "HOL-Real_Asymp.Real_Asymp")
### ML warning (line 365 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Matches are not exhaustive.
### ML warning (line 365 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Value identifier (convert_bounds') has not been referenced.
### ML warning (line 396 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Matches are not exhaustive.
### ML warning (line 481 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 451 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 510 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 589 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 632 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 709 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 826 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 957 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 944 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 1003 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 1043 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Value identifier (nonneg_power_expansion_bounds) has not been referenced.
### ML warning (line 1211 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 1217 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
### ML warning (line 1223 of "~~/src/HOL/Real_Asymp/multiseries_expansion_bounds.ML"):
### Pattern is not exhaustive.
signature MULTISERIES_EXPANSION =
  sig
    val arctan_expansion:
       Lazy_Eval.eval_ctxt -> basis -> expansion_thm -> expansion_thm
    type basis
    datatype bounds
    =
         Bounds of lower_bound option * upper_bound option
       | Exact of expansion_thm
    val check_expansion: expr -> expansion_thm -> expansion_thm
    val compare_expansions:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis ->
           order * thm * expansion_thm * expansion_thm
    val compare_expansions':
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> comparison_result
    datatype comparison_result
    =
         Cmp_Asymp_Equiv of thm * thm
       | Cmp_Dominated of
           order * thm list * zeroness * trimmed_thm * expansion_thm *
           expansion_thm
    val compute_limit: Lazy_Eval.eval_ctxt -> term -> limit * thm
    val const_expansion:
       Lazy_Eval.eval_ctxt -> basis -> term -> expansion_thm
    val ev_zeroness_oracle: Lazy_Eval.eval_ctxt -> term -> thm option
    val exp_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm -> basis -> expansion_thm * basis
    val expand:
       Lazy_Eval.eval_ctxt -> expr -> basis -> expansion_thm * basis
    val expand_term:
       Lazy_Eval.eval_ctxt -> term -> basis -> expansion_thm * basis
    val expand_term_bounds:
       Lazy_Eval.eval_ctxt -> term -> basis -> bounds * basis
    val expand_terms:
       Lazy_Eval.eval_ctxt ->
         term list -> basis -> expansion_thm list * basis
    val expand_terms_bounds:
       Lazy_Eval.eval_ctxt -> term list -> basis -> bounds list * basis
    val expands_to_hd: thm -> thm
    type expansion_thm
    eqtype expr
    val extract_terms:
       int * bool ->
         Lazy_Eval.eval_ctxt -> basis -> term -> term * term option
    val find_greater_expansion:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm * thm * thm
    val find_smaller_expansion:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm * thm * thm
    val get_coeff: term -> term
    val get_eval: term -> term
    val get_expanded_fun: thm -> term
    val get_expanded_fun_bounds: bounds -> term
    val get_expansion: thm -> term
    val get_exponent: term -> term
    val get_intyness: Proof.context -> cterm -> intyness
    val get_parity: cterm -> parity
    val get_sign_oracles:
       Context.generic -> (string * (Proof.context -> int -> tactic)) list
    datatype intyness = Nat of thm | Neg_Nat of thm | No_Nat
    val is_vacuous: bounds -> bool
    val lift_bounds: basis -> bounds -> bounds
    datatype limit
    =
         Finite_Limit of term
       | Infinite_Limit of bool option
       | Zero_Limit of bool option
    val limit_of_expansion:
       bool * bool -> Lazy_Eval.eval_ctxt -> thm * basis -> limit * thm
    val limit_of_expansion_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> limit_result
    datatype limit_result
    = Exact_Limit of term | Limit_Bounds of term option * term option
    val ln_expansion:
       Lazy_Eval.eval_ctxt ->
         trimmed_thm -> expansion_thm -> basis -> expansion_thm * basis
    type lower_bound = expansion_thm * lower_bound_thm
    type lower_bound_thm
    val max_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm
    val min_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm
    val mk_eval_ctxt: Proof.context -> Lazy_Eval.eval_ctxt
    val mult_expansion_bounds:
       Lazy_Eval.eval_ctxt -> basis -> bounds -> bounds -> bounds
    datatype parity = Even of thm | Odd of thm | Unknown_Parity
    val power_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val power_expansion_bounds:
       Lazy_Eval.eval_ctxt -> bounds * term * basis -> bounds
    val powr_const_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val powr_const_expansion_bounds:
       Lazy_Eval.eval_ctxt -> bounds * term * basis -> bounds
    val powr_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm * basis
    val powr_expansion_bounds:
       Lazy_Eval.eval_ctxt -> basis -> bounds -> bounds -> bounds * basis
    val powr_nat_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * expansion_thm * basis -> expansion_thm * basis
    val powr_nat_expansion_bounds:
       Lazy_Eval.eval_ctxt -> basis -> bounds -> bounds -> bounds * basis
    val prove_asymp_equiv: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_asymp_equiv_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_asymptotic_relation:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> order * thm
    val prove_at_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_0_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_bot: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_bot_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_infinity: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_infinity_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_left_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_left_0_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_right_0: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_right_0_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_at_top: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_at_top_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_bigo: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_bigo_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_bigtheta: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_bigtheta_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_compare_expansions: order -> thm list -> thm
    val prove_eventually_greater:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_eventually_greater_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_eventually_less:
       Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_eventually_less_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val prove_eventually_nonzero: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_eventually_nonzero_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_nhds: Lazy_Eval.eval_ctxt -> thm * basis -> thm
    val prove_nhds_bounds: Lazy_Eval.eval_ctxt -> bounds * basis -> thm
    val prove_smallo: Lazy_Eval.eval_ctxt -> thm * thm * basis -> thm
    val prove_smallo_bounds:
       Lazy_Eval.eval_ctxt -> bounds * bounds * basis -> thm
    val register_sign_oracle:
       binding * (Proof.context -> int -> tactic) ->
         Context.generic -> Context.generic
    val retrim_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * basis -> expansion_thm * thm
    val retrim_pos_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * basis * trimmed_thm ->
           expansion_thm * thm * trimmed_thm
    val root_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * term * basis -> expansion_thm
    val sgn_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm * basis -> expansion_thm
    val sgn_expansion_bounds:
       Lazy_Eval.eval_ctxt -> bounds * basis -> bounds
    val simplify_expansion:
       Lazy_Eval.eval_ctxt -> expansion_thm -> expansion_thm
    val simplify_term: Lazy_Eval.eval_ctxt -> term -> term
    val simplify_trimmed_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm * trimmed_thm -> expansion_thm * trimmed_thm
    val solve_eval_eq: thm -> thm
    val trim_expansion:
       bool ->
         trim_mode option ->
           Lazy_Eval.eval_ctxt ->
             expansion_thm * basis ->
               expansion_thm * zeroness * trimmed_thm option
    val trim_expansion_while_greater:
       bool ->
         term list option ->
           bool ->
             trim_mode option ->
               Lazy_Eval.eval_ctxt ->
                 thm * basis -> thm * trim_result * (zeroness * thm) list
    datatype trim_mode = Neg_Trim | Pos_Trim | Sgn_Trim | Simple_Trim
    datatype trim_result
    = Aborted of order | Trimmed of zeroness * trimmed_thm option
    type trimmed_thm
    val try_drop_leading_term_ex:
       bool -> Lazy_Eval.eval_ctxt -> expansion_thm -> expansion_thm option
    val try_prove_ev_eq: Lazy_Eval.eval_ctxt -> term * term -> thm option
    val try_prove_real_eq:
       bool -> Lazy_Eval.eval_ctxt -> term * term -> thm option
    type upper_bound = expansion_thm * upper_bound_thm
    type upper_bound_thm
    val whnf_expansion:
       Lazy_Eval.eval_ctxt ->
         expansion_thm -> term option * expansion_thm * thm
    val zero_expansion: basis -> expansion_thm
    datatype zeroness = IsNeg | IsNonZero | IsPos | IsZero
    val zeroness_oracle:
       bool ->
         trim_mode option ->
           Lazy_Eval.eval_ctxt -> term -> zeroness * thm option
  end
structure Multiseries_Expansion: MULTISERIES_EXPANSION
structure Multiseries_Expansion_Bounds: EXPANSION_INTERFACE
structure Real_Asymp_Bounds: REAL_ASYMP
### theory "HOL-Real_Asymp.Multiseries_Expansion_Bounds"
### 1.283s elapsed time, 1.398s cpu time, 0.124s GC time
Loading theory "HOL-Real_Asymp.Real_Asymp" (required by "Draft.Lambert_WMoreTemplates" via "Draft.Lambert_W")
signature REAL_ASYMP_DIAG =
  sig
    val expansion:
       Proof.context ->
         thm list ->
           bool * int -> term -> term -> term * Asymptotic_Basis.basis
    val expansion_cmd:
       Proof.context ->
         (Facts.ref * Token.src list) list list ->
           bool * int -> string -> string option -> unit
    val limit:
       Proof.context ->
         thm list -> term -> term -> Multiseries_Expansion.limit_result
    val limit_cmd:
       Proof.context ->
         (Facts.ref * Token.src list) list list ->
           string -> string option -> unit
    val pretty_limit: Proof.context -> term -> Pretty.T
  end
structure Real_Asymp_Diag: REAL_ASYMP_DIAG
### theory "HOL-Real_Asymp.Real_Asymp"
### 0.155s elapsed time, 0.162s cpu time, 0.014s GC time
Loading theory "Draft.Lambert_W" (required by "Draft.Lambert_WMoreTemplates")
### theory "Draft.Lambert_W"
### 0.626s elapsed time, 0.701s cpu time, 0.102s GC time
Loading theory "Draft.Lambert_WMoreTemplates"
val templateLemmas =
   [("Lambert_W.Lambert_W'_neg", "Lambert_W' ?x < 0",
     template_inequation
      (less_than, template_app (template_hole 1, template_var 0),
       template_hole 0)),
    ("Lambert_W.Lambert_W'_nz", "Lambert_W' ?x ~= 0",
     template_negation
      (
         template_equation
          (template_app (template_hole 1, template_var 0), template_hole 0)
         )),
    ("Lambert_W.Lambert_W_ge", "- 1 <= Lambert_W ?x",
     template_inequation
      (less_equals, template_app (template_hole 2, template_hole 1),
       template_app (template_hole 0, template_var 0))),
    ("Lambert_W.Lambert_W'_le", "Lambert_W' ?x <= - 1",
     template_inequation
      (less_equals, template_app (template_hole 2, template_var 0),
       template_app (template_hole 1, template_hole 0))),
    ("Lambert_W.Lambert_W_eq_0_iff", "(Lambert_W ?x = 0) = (?x = 0)",
     template_bimplication
      (template_equation
        (template_app (template_hole 1, template_var 0), template_hole 0),
       template_equation (template_var 0, template_hole 0))),
    ("Lambert_W.Lambert_W_pos_iff", "(0 < Lambert_W ?x) = (0 < ?x)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 2, template_hole 1), template_var 0))),
    ("Lambert_W.Lambert_W_neg_iff", "(Lambert_W ?x < 0) = (?x < 0)",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_hole 0),
       template_app
        (template_app (template_hole 2, template_var 0), template_hole 0))),
    ("Lambert_W.Lambert_W_nonneg_iff", "(0 <= Lambert_W ?x) = (0 <= ?x)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1),
         template_app (template_hole 0, template_var 0)),
       template_app
        (template_app (template_hole 2, template_hole 1), template_var 0))),
    ("Lambert_W.Lambert_W_nonpos_iff", "(Lambert_W ?x <= 0) = (?x <= 0)",
     template_equation
      (template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_hole 0),
       template_app
        (template_app (template_hole 2, template_var 0), template_hole 0))),
    ("Lambert_W.exp_times_self_ge", "- exp (- 1) <= ?x * exp ?x",
     template_inequation
      (less_equals,
       template_app
        (template_hole 3,
         template_app
          (template_hole 2,
           template_app (template_hole 3, template_hole 1))),
       template_app
        (template_app (template_hole 0, template_var 0),
         template_app (template_hole 2, template_var 0)))),
    ("Lambert_W.Lambert_W'_ge_zero", "0 <= ?x ==> Lambert_W' ?x = - 1",
     template_implication
      ([template_inequation (less_equals, template_hole 4, template_var 0)],
       template_equation
        (template_app (template_hole 2, template_var 0),
         template_app (template_hole 1, template_hole 0)))),
    ("Lambert_W.Lambert_W_less_ln", "exp 1 < ?x ==> Lambert_W ?x < ln ?x",
     template_implication
      ([template_inequation
         (less_than, template_app (template_hole 3, template_hole 2),
          template_var 0)],
       template_inequation
        (less_than, template_app (template_hole 1, template_var 0),
         template_app (template_hole 0, template_var 0)))),
    ("Lambert_W.Lambert_W_gtI", "?y * exp ?y < ?x ==> ?y < Lambert_W ?x",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_app (template_hole 2, template_var 1),
            template_app (template_hole 1, template_var 1)),
          template_var 0)],
       template_inequation
        (less_than, template_var 1,
         template_app (template_hole 0, template_var 0)))),
    ("Lambert_W.Lambert_W_geI", "?y * exp ?y <= ?x ==> ?y <= Lambert_W ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_app (template_hole 2, template_var 1),
            template_app (template_hole 1, template_var 1)),
          template_var 0)],
       template_inequation
        (less_equals, template_var 1,
         template_app (template_hole 0, template_var 0)))),
    ("Lambert_W.Lambert_W'_exp_times_self",
     "?x <= - 1 ==> Lambert_W' (?x * exp ?x) = ?x",
     template_implication
      ([template_inequation
         (less_equals, template_var 0,
          template_app (template_hole 5, template_hole 4))],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 0),
             template_app (template_hole 0, template_var 0))),
         template_var 0))),
    ("Lambert_W.Lambert_W'_exp_times_self'",
     "?x <= - 1 ==> Lambert_W' (exp ?x * ?x) = ?x",
     template_implication
      ([template_inequation
         (less_equals, template_var 0,
          template_app (template_hole 5, template_hole 4))],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 0)),
             template_var 0)),
         template_var 0))),
    ("Lambert_W.Lambert_W_exp_times_self",
     "- 1 <= ?x ==> Lambert_W (?x * exp ?x) = ?x",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 5, template_hole 4),
          template_var 0)],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 0),
             template_app (template_hole 0, template_var 0))),
         template_var 0))),
    ("Lambert_W.Lambert_W_exp_times_self'",
     "- 1 <= ?x ==> Lambert_W (exp ?x * ?x) = ?x",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 5, template_hole 4),
          template_var 0)],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 0)),
             template_var 0)),
         template_var 0))),
    ("Lambert_W.Lambert_W_le_minus_one",
     "?x <= - exp (- 1) ==> Lambert_W ?x = - 1",
     template_implication
      ([template_inequation
         (less_equals, template_var 0,
          template_app
           (template_hole 4,
            template_app
             (template_hole 3,
              template_app (template_hole 4, template_hole 2))))],
       template_equation
        (template_app (template_hole 0, template_var 0),
         template_app (template_hole 4, template_hole 2)))),
    ("Lambert_W.Lambert_W'_le_minus_one",
     "?x <= - exp (- 1) ==> Lambert_W' ?x = - 1",
     template_implication
      ([template_inequation
         (less_equals, template_var 0,
          template_app
           (template_hole 4,
            template_app
             (template_hole 3,
              template_app (template_hole 4, template_hole 2))))],
       template_equation
        (template_app (template_hole 0, template_var 0),
         template_app (template_hole 4, template_hole 2)))),
    ("Lambert_W.ln_Lambert_W",
     "0 < ?x ==> ln (Lambert_W ?x) = ln ?x - Lambert_W ?x",
     template_implication
      ([template_inequation (less_than, template_hole 4, template_var 0)],
       template_equation
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_app
          (template_app
            (template_hole 0,
             template_app (template_hole 2, template_var 0)),
           template_app (template_hole 1, template_var 0))))),
    ("Lambert_W.exp_times_self_eqD",
     "?w * exp ?w = ?x ==> - exp (- 1) <= ?x",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 4, template_var 1),
            template_app (template_hole 3, template_var 1)),
          template_var 0)],
       template_inequation
        (less_equals,
         template_app
          (template_hole 1,
           template_app
            (template_hole 3,
             template_app (template_hole 1, template_hole 0))),
         template_var 0))),
    ("Lambert_W.Lambert_W_gt_ln_minus_ln_ln",
     "exp 1 < ?x ==> ln ?x - ln (ln ?x) < Lambert_W ?x",
     template_implication
      ([template_inequation
         (less_than, template_app (template_hole 4, template_hole 3),
          template_var 0)],
       template_inequation
        (less_than,
         template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 0)),
           template_app
            (template_hole 1,
             template_app (template_hole 1, template_var 0))),
         template_app (template_hole 0, template_var 0)))),
    ("Lambert_W.Lambert_W_times_ln_self",
     "exp (- 1) <= ?x ==> Lambert_W (?x * ln ?x) = ln ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 6,
            template_app (template_hole 5, template_hole 4)),
          template_var 0)],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 0),
             template_app (template_hole 0, template_var 0))),
         template_app (template_hole 0, template_var 0)))),
    ("Lambert_W.Lambert_W_times_ln_self'",
     "exp (- 1) <= ?x ==> Lambert_W (ln ?x * ?x) = ln ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 6,
            template_app (template_hole 5, template_hole 4)),
          template_var 0)],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 0)),
             template_var 0)),
         template_app (template_hole 0, template_var 0)))),
    ("Lambert_W.sqrt_sqrt_mult",
     "0 <= ?x ==> sqrt ?x * (sqrt ?x * ?y) = ?x * ?y",
     template_implication
      ([template_inequation (less_equals, template_hole 3, template_var 1)],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 1)),
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 1)),
             template_var 0)),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("Lambert_W.Lambert_W'_neg_ln_over_self",
     "exp 1 <= ?x ==> Lambert_W' (- ln ?x / ?x) = - ln ?x",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 6, template_hole 5),
          template_var 0)],
       template_equation
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_hole 1,
                 template_app (template_hole 0, template_var 0))),
             template_var 0)),
         template_app
          (template_hole 1,
           template_app (template_hole 0, template_var 0))))),
    ("Lambert_W.exp_times_self_gt",
     "?x ~= - 1 ==> - exp (- 1) < ?x * exp ?x",
     template_implication
      ([template_negation
         (
            template_equation
             (template_var 0,
              template_app (template_hole 4, template_hole 3))
            )],
       template_inequation
        (less_than,
         template_app
          (template_hole 4,
           template_app
            (template_hole 1,
             template_app (template_hole 4, template_hole 3))),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_app (template_hole 1, template_var 0))))),
    ("Lambert_W.Lambert_W_times_exp_self",
     "- exp (- 1) <= ?x ==> Lambert_W ?x * exp (Lambert_W ?x) = ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_var 0)],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)),
           template_app
            (template_hole 4,
             template_app (template_hole 0, template_var 0))),
         template_var 0))),
    ("Lambert_W.Lambert_W_times_exp_self'",
     "- exp (- 1) <= ?x ==> exp (Lambert_W ?x) * Lambert_W ?x = ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_var 0)],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_hole 4,
               template_app (template_hole 0, template_var 0))),
           template_app (template_hole 0, template_var 0)),
         template_var 0))),
    ("Lambert_W.Lambert_W'_lessI",
     "[| ?y * exp ?y < ?x; ?x < 0 |] ==> Lambert_W' ?x < ?y",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_app (template_hole 3, template_var 1),
            template_app (template_hole 2, template_var 1)),
          template_var 0),
        template_inequation (less_than, template_var 0, template_hole 1)],
       template_inequation
        (less_than, template_app (template_hole 0, template_var 0),
         template_var 1))),
    ("Lambert_W.Lambert_W'_leI",
     "[| ?y * exp ?y <= ?x; ?x < 0 |] ==> Lambert_W' ?x <= ?y",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_app (template_hole 4, template_var 1),
            template_app (template_hole 3, template_var 1)),
          template_var 0),
        template_inequation (less_than, template_var 0, template_hole 1)],
       template_inequation
        (less_equals, template_app (template_hole 0, template_var 0),
         template_var 1))),
    ("Lambert_W.exp_Lambert_W'",
     "?x : {- exp (- 1)..<0} ==> exp (Lambert_W' ?x) = ?x / Lambert_W' ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 0),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            )],
       template_equation
        (template_app
          (template_hole 5, template_app (template_hole 1, template_var 0)),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_app (template_hole 1, template_var 0))))),
    ("Lambert_W.Lambert_W'_times_exp_self",
     "?x : {- exp (- 1)..<0} ==> Lambert_W' ?x * exp (Lambert_W' ?x) = ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 0),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0)),
           template_app
            (template_hole 5,
             template_app (template_hole 0, template_var 0))),
         template_var 0))),
    ("Lambert_W.Lambert_W'_times_exp_self'",
     "?x : {- exp (- 1)..<0} ==> exp (Lambert_W' ?x) * Lambert_W' ?x = ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 0),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_hole 5,
               template_app (template_hole 0, template_var 0))),
           template_app (template_hole 0, template_var 0)),
         template_var 0))),
    ("Lambert_W.Lambert_W'_eqI",
     "[| ?w <= - 1; ?w * exp ?w = ?x |] ==> Lambert_W' ?x = ?w",
     template_implication
      ([template_inequation
         (less_equals, template_var 1,
          template_app (template_hole 5, template_hole 4)),
        template_equation
         (template_app
           (template_app (template_hole 2, template_var 1),
            template_app (template_hole 1, template_var 1)),
          template_var 0)],
       template_equation
        (template_app (template_hole 0, template_var 0), template_var 1))),
    ("Lambert_W.Lambert_W_eqI",
     "[| - 1 <= ?w; ?w * exp ?w = ?x |] ==> Lambert_W ?x = ?w",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 5, template_hole 4),
          template_var 1),
        template_equation
         (template_app
           (template_app (template_hole 2, template_var 1),
            template_app (template_hole 1, template_var 1)),
          template_var 0)],
       template_equation
        (template_app (template_hole 0, template_var 0), template_var 1))),
    ("Lambert_W.Lambert_W_strict_mono",
     "[| - exp (- 1) <= ?x; ?x < ?y |] ==> Lambert_W ?x < Lambert_W ?y",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 4,
            template_app
             (template_hole 3,
              template_app (template_hole 4, template_hole 2))),
          template_var 1),
        template_inequation (less_than, template_var 1, template_var 0)],
       template_inequation
        (less_than, template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("Lambert_W.Lambert_W_mono",
     "[| - exp (- 1) <= ?x; ?x <= ?y |] ==> Lambert_W ?x <= Lambert_W ?y",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 3,
            template_app
             (template_hole 2,
              template_app (template_hole 3, template_hole 1))),
          template_var 1),
        template_inequation (less_equals, template_var 1, template_var 0)],
       template_inequation
        (less_equals, template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("Lambert_W.bij_betw_exp_times_self_atLeast",
     "- 1 <= ?a ==> bij_betw (%x. x * exp x) {?a..} {?a * exp ?a..}",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 5, template_hole 4),
          template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, t_empty),
               template_app (template_hole 0, template_var 0)),
             template_app
              (template_hole 0,
               template_app
                (template_app (template_hole 2, template_var 0),
                 template_app (template_hole 1, template_var 0))))
           ))),
    ("Lambert_W.has_field_derivative_Lambert_W",
     "- exp (- 1) < ?x ==>
      (Lambert_W has_real_derivative inverse (?x + exp (Lambert_W ?x)))
       (at ?x within ?A)",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_hole 7,
            template_app
             (template_hole 6,
              template_app (template_hole 7, template_hole 5))),
          template_var 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_hole 3),
               template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 1),
                   template_app
                    (template_hole 6,
                     template_app (template_hole 3, template_var 1))))),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("Lambert_W.Lambert_W_neg_ln_over_self",
     "?x : {exp (- 1)..exp 1} ==> Lambert_W (- ln ?x / ?x) = - ln ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 0),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app (template_hole 5, template_hole 4))),
                template_app (template_hole 6, template_hole 4)))
            )],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_hole 5,
                 template_app (template_hole 0, template_var 0))),
             template_var 0)),
         template_app
          (template_hole 5,
           template_app (template_hole 0, template_var 0))))),
    ("Lambert_W.exp_times_self_strict_antimono",
     "[| ?y <= - 1; ?x < ?y |] ==> ?y * exp ?y < ?x * exp ?x",
     template_implication
      ([template_inequation
         (less_equals, template_var 1,
          template_app (template_hole 4, template_hole 3)),
        template_inequation (less_than, template_var 0, template_var 1)],
       template_inequation
        (less_than,
         template_app
          (template_app (template_hole 1, template_var 1),
           template_app (template_hole 0, template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_app (template_hole 0, template_var 0))))),
    ("Lambert_W.exp_times_self_antimono",
     "[| ?y <= - 1; ?x <= ?y |] ==> ?y * exp ?y <= ?x * exp ?x",
     template_implication
      ([template_inequation
         (less_equals, template_var 1,
          template_app (template_hole 3, template_hole 2)),
        template_inequation (less_equals, template_var 0, template_var 1)],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 1, template_var 1),
           template_app (template_hole 0, template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_app (template_hole 0, template_var 0))))),
    ("Lambert_W.exp_times_self_strict_mono",
     "[| - 1 <= ?x; ?x < ?y |] ==> ?x * exp ?x < ?y * exp ?y",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 4, template_hole 3),
          template_var 1),
        template_inequation (less_than, template_var 1, template_var 0)],
       template_inequation
        (less_than,
         template_app
          (template_app (template_hole 1, template_var 1),
           template_app (template_hole 0, template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_app (template_hole 0, template_var 0))))),
    ("Lambert_W.exp_times_self_mono",
     "[| - 1 <= ?x; ?x <= ?y |] ==> ?x * exp ?x <= ?y * exp ?y",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 3, template_hole 2),
          template_var 1),
        template_inequation (less_equals, template_var 1, template_var 0)],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 1, template_var 1),
           template_app (template_hole 0, template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_app (template_hole 0, template_var 0))))),
    ("Lambert_W.exp_times_self_eqD",
     "?w * exp ?w = ?x ==> ?w = Lambert_W ?x | ?x < 0 & ?w = Lambert_W' ?x",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 7, template_var 1),
            template_app (template_hole 6, template_var 1)),
          template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 8, template_var 1),
                 template_app (template_hole 4, template_var 0))),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_var 0),
                   template_hole 1)),
               template_app
                (template_app (template_hole 8, template_var 1),
                 template_app (template_hole 0, template_var 0))))
           ))),
    ("Lambert_W.Lambert_W_ex1",
     "- exp (- 1) <= ?x ==> EX! w. - 1 <= w & w * exp w = ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 6,
            template_app
             (template_hole 5,
              template_app (template_hole 6, template_hole 4))),
          template_var 0)],
       template_predicate (template_app (template_hole 3, t_empty)))),
    ("Lambert_W.ln_minus_Lambert_W'",
     "?x : {- exp (- 1)..<0} ==>
      ln (- Lambert_W' ?x) = ln (- ?x) - Lambert_W' ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 0),
              template_app
               (template_app
                 (template_hole 8,
                  template_app
                   (template_hole 7,
                    template_app
                     (template_hole 6,
                      template_app (template_hole 7, template_hole 5)))),
                template_hole 4))
            )],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_hole 7,
             template_app (template_hole 1, template_var 0))),
         template_app
          (template_app
            (template_hole 0,
             template_app
              (template_hole 2,
               template_app (template_hole 7, template_var 0))),
           template_app (template_hole 1, template_var 0))))),
    ("Lambert_W.has_field_derivative_Lambert_W'",
     "?x : {- exp (- 1)<..<0} ==>
      (Lambert_W' has_real_derivative inverse (?x + exp (Lambert_W' ?x)))
       (at ?x within ?A)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 1),
              template_app
               (template_app
                 (template_hole 9,
                  template_app
                   (template_hole 8,
                    template_app
                     (template_hole 7,
                      template_app (template_hole 8, template_hole 6)))),
                template_hole 5))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_hole 3),
               template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 1),
                   template_app
                    (template_hole 7,
                     template_app (template_hole 3, template_var 1))))),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("Lambert_W.exp_Lambert_W",
     "[| - exp (- 1) <= ?x; ?x ~= 0 |]
      ==> exp (Lambert_W ?x) = ?x / Lambert_W ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 7,
            template_app
             (template_hole 6,
              template_app (template_hole 7, template_hole 5))),
          template_var 0),
        template_negation
         (template_equation (template_var 0, template_hole 2))],
       template_equation
        (template_app
          (template_hole 6, template_app (template_hole 1, template_var 0)),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_app (template_hole 1, template_var 0))))),
    ("Lambert_W.Lambert_W'_ex1",
     "?x : {- exp (- 1)..<0} ==> EX! w. w <= - 1 & w * exp w = ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 0),
              template_app
               (template_app
                 (template_hole 9,
                  template_app
                   (template_hole 8,
                    template_app
                     (template_hole 7,
                      template_app (template_hole 8, template_hole 6)))),
                template_hole 5))
            )],
       template_predicate (template_app (template_hole 4, t_empty)))),
    ("Lambert_W.Lambert_W'_strict_antimono",
     "[| - exp (- 1) <= ?x; ?x < ?y; ?y < 0 |]
      ==> Lambert_W' ?y < Lambert_W' ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_var 1),
        template_inequation (less_than, template_var 1, template_var 0),
        template_inequation (less_than, template_var 0, template_hole 1)],
       template_inequation
        (less_than, template_app (template_hole 0, template_var 0),
         template_app (template_hole 0, template_var 1)))),
    ("Lambert_W.Lambert_W'_antimono",
     "[| - exp (- 1) <= ?x; ?x <= ?y; ?y < 0 |]
      ==> Lambert_W' ?y <= Lambert_W' ?x",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_var 1),
        template_inequation (less_equals, template_var 1, template_var 0),
        template_inequation (less_than, template_var 0, template_hole 1)],
       template_inequation
        (less_equals, template_app (template_hole 0, template_var 0),
         template_app (template_hole 0, template_var 1)))),
    ("Lambert_W.tendsto_Lambert_W_2",
     "[| (?f \<longlongrightarrow> ?L) ?F; - exp (- 1) < ?L |]
      ==> ((%x. Lambert_W (?f x)) \<longlongrightarrow> Lambert_W ?L) ?F",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 2),
                template_app (template_hole 5, template_var 1)),
              template_var 0)
            ),
        template_inequation
         (less_than,
          template_app
           (template_hole 3,
            template_app
             (template_hole 2,
              template_app (template_hole 3, template_hole 1))),
          template_var 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, t_empty),
               template_app
                (template_hole 5,
                 template_app (template_hole 0, template_var 1))),
             template_var 0)
           ))),
    ("Lambert_W.Lambert_W_eq_iff",
     "[| - exp (- 1) <= ?x; - exp (- 1) <= ?y |]
      ==> (Lambert_W ?x = Lambert_W ?y) = (?x = ?y)",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_var 1),
        template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_var 0)],
       template_bimplication
        (template_equation
          (template_app (template_hole 0, template_var 1),
           template_app (template_hole 0, template_var 0)),
         template_equation (template_var 1, template_var 0)))),
    ("Lambert_W.Lambert_W_less_iff",
     "[| - exp (- 1) <= ?x; - exp (- 1) <= ?y |]
      ==> (Lambert_W ?x < Lambert_W ?y) = (?x < ?y)",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_var 1),
        template_inequation
         (less_equals,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_var 0)],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 1)),
           template_app (template_hole 0, template_var 0)),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("Lambert_W.Lambert_W_le_iff",
     "[| - exp (- 1) <= ?x; - exp (- 1) <= ?y |]
      ==> (Lambert_W ?x <= Lambert_W ?y) = (?x <= ?y)",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 4,
            template_app
             (template_hole 3,
              template_app (template_hole 4, template_hole 2))),
          template_var 1),
        template_inequation
         (less_equals,
          template_app
           (template_hole 4,
            template_app
             (template_hole 3,
              template_app (template_hole 4, template_hole 2))),
          template_var 0)],
       template_equation
        (template_app
          (template_app
            (template_hole 5,
             template_app (template_hole 0, template_var 1)),
           template_app (template_hole 0, template_var 0)),
         template_app
          (template_app (template_hole 5, template_var 1),
           template_var 0)))),
    ("Lambert_W.Lambert_W'_gtI",
     "[| ?x < ?y * exp ?y; ?y <= - 1; - exp (- 1) <= ?x |]
      ==> ?y <= Lambert_W' ?x",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app
           (template_app (template_hole 5, template_var 0),
            template_app (template_hole 4, template_var 0))),
        template_inequation
         (less_equals, template_var 0,
          template_app (template_hole 2, template_hole 1)),
        template_inequation
         (less_equals,
          template_app
           (template_hole 2,
            template_app
             (template_hole 4,
              template_app (template_hole 2, template_hole 1))),
          template_var 1)],
       template_inequation
        (less_equals, template_var 0,
         template_app (template_hole 0, template_var 1)))),
    ("Lambert_W.Lambert_W_lessI",
     "[| ?x < ?y * exp ?y; - 1 <= ?y; - exp (- 1) <= ?x |]
      ==> Lambert_W ?x < ?y",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app
           (template_app (template_hole 5, template_var 0),
            template_app (template_hole 4, template_var 0))),
        template_inequation
         (less_equals, template_app (template_hole 2, template_hole 1),
          template_var 0),
        template_inequation
         (less_equals,
          template_app
           (template_hole 2,
            template_app
             (template_hole 4,
              template_app (template_hole 2, template_hole 1))),
          template_var 1)],
       template_inequation
        (less_than, template_app (template_hole 0, template_var 1),
         template_var 0))),
    ("Lambert_W.Lambert_W'_geI",
     "[| ?x <= ?y * exp ?y; ?y <= - 1; - exp (- 1) <= ?x |]
      ==> ?y <= Lambert_W' ?x",
     template_implication
      ([template_inequation
         (less_equals, template_var 1,
          template_app
           (template_app (template_hole 4, template_var 0),
            template_app (template_hole 3, template_var 0))),
        template_inequation
         (less_equals, template_var 0,
          template_app (template_hole 2, template_hole 1)),
        template_inequation
         (less_equals,
          template_app
           (template_hole 2,
            template_app
             (template_hole 3,
              template_app (template_hole 2, template_hole 1))),
          template_var 1)],
       template_inequation
        (less_equals, template_var 0,
         template_app (template_hole 0, template_var 1)))),
    ("Lambert_W.Lambert_W_leI",
     "[| ?x <= ?y * exp ?y; - 1 <= ?y; - exp (- 1) <= ?x |]
      ==> Lambert_W ?x <= ?y",
     template_implication
      ([template_inequation
         (less_equals, template_var 1,
          template_app
           (template_app (template_hole 4, template_var 0),
            template_app (template_hole 3, template_var 0))),
        template_inequation
         (less_equals, template_app (template_hole 2, template_hole 1),
          template_var 0),
        template_inequation
         (less_equals,
          template_app
           (template_hole 2,
            template_app
             (template_hole 3,
              template_app (template_hole 2, template_hole 1))),
          template_var 1)],
       template_inequation
        (less_equals, template_app (template_hole 0, template_var 1),
         template_var 0))),
    ("Lambert_W.exp_times_self_eq_iff",
     "(?w * exp ?w = ?x) =
      (- exp (- 1) <= ?x &
       (?w = Lambert_W ?x | ?x < 0 & ?w = Lambert_W' ?x))",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 10, template_var 1),
           template_app (template_hole 9, template_var 1)),
         template_var 0),
       template_predicate
        (
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_hole 6,
                     template_app
                      (template_hole 9,
                       template_app (template_hole 6, template_hole 5)))),
                 template_var 0)),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 11, template_var 1),
                   template_app (template_hole 3, template_var 0))),
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     template_hole 1)),
                 template_app
                  (template_app (template_hole 11, template_var 1),
                   template_app (template_hole 0, template_var 0)))))
           ))),
    ("Lambert_W.continuous_on_Lambert_W_alt",
     "[| continuous_on ?A ?f; !!x. x : ?A ==> - exp (- 1) <= ?f x |]
      ==> continuous_on ?A (%x. Lambert_W (?f x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 7, template_var 1),
              template_var 0)
            ),
        template_predicate (template_app (template_hole 6, t_empty))],
       template_predicate
        (
           template_app
            (template_app (template_hole 7, template_var 1), t_empty)
           ))),
    ("Lambert_W.tendsto_Lambert_W_1",
     "[| (?f \<longlongrightarrow> ?L) ?F;
         \<forall>\<^sub>F x in ?F. - exp (- 1) <= ?f x |]
      ==> ((%x. Lambert_W (?f x)) \<longlongrightarrow> Lambert_W ?L) ?F",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 2),
                template_app (template_hole 6, template_var 1)),
              template_var 0)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, t_empty), template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 7, t_empty),
               template_app
                (template_hole 6,
                 template_app (template_hole 0, template_var 1))),
             template_var 0)
           ))),
    ("Lambert_W.bij_betw_exp_times_self_atLeastAtMost'",
     "[| ?a <= ?b; ?b <= - 1 |]
      ==> bij_betw (%x. x * exp x) {?a..?b} {?b * exp ?b..?a * exp ?a}",
     template_implication
      ([template_inequation (less_equals, template_var 1, template_var 0),
        template_inequation
         (less_equals, template_var 0,
          template_app (template_hole 5, template_hole 4))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, t_empty),
               template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 0)),
             template_app
              (template_app
                (template_hole 0,
                 template_app
                  (template_app (template_hole 2, template_var 0),
                   template_app (template_hole 1, template_var 0))),
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_app (template_hole 1, template_var 1))))
           ))),
    ("Lambert_W.continuous_on_Lambert_W'_alt",
     "[| continuous_on ?A ?f; !!x. x : ?A ==> ?f x : {- exp (- 1)..<0} |]
      ==> continuous_on ?A (%x. Lambert_W' (?f x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 1),
              template_var 0)
            ),
        template_predicate (template_app (template_hole 8, t_empty))],
       template_predicate
        (
           template_app
            (template_app (template_hole 9, template_var 1), t_empty)
           ))),
    ("Lambert_W.bij_betw_exp_times_self_atLeastAtMost",
     "[| - 1 <= ?a; ?a <= ?b |]
      ==> bij_betw (%x. x * exp x) {?a..?b} {?a * exp ?a..?b * exp ?b}",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 5, template_hole 4),
          template_var 1),
        template_inequation (less_equals, template_var 1, template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, t_empty),
               template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 0)),
             template_app
              (template_app
                (template_hole 0,
                 template_app
                  (template_app (template_hole 2, template_var 1),
                   template_app (template_hole 1, template_var 1))),
               template_app
                (template_app (template_hole 2, template_var 0),
                 template_app (template_hole 1, template_var 0))))
           ))),
    ("Lambert_W.Lambert_W'_eq_iff",
     "[| ?x : {- exp (- 1)..<0}; ?y : {- exp (- 1)..<0} |]
      ==> (Lambert_W' ?x = Lambert_W' ?y) = (?x = ?y)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 1),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 0),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            )],
       template_bimplication
        (template_equation
          (template_app (template_hole 0, template_var 1),
           template_app (template_hole 0, template_var 0)),
         template_equation (template_var 1, template_var 0)))),
    ("Lambert_W.Lambert_W'_less_iff",
     "[| ?x : {- exp (- 1)..<0}; ?y : {- exp (- 1)..<0} |]
      ==> (Lambert_W' ?x < Lambert_W' ?y) = (?y < ?x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 1),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 0),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 1)),
           template_app (template_hole 0, template_var 0)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_var 1)))),
    ("Lambert_W.Lambert_W'_le_iff",
     "[| ?x : {- exp (- 1)..<0}; ?y : {- exp (- 1)..<0} |]
      ==> (Lambert_W' ?x <= Lambert_W' ?y) = (?y <= ?x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 1),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 0),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 1)),
           template_app (template_hole 0, template_var 0)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_var 1)))),
    ("Lambert_W.tendsto_Lambert_W'_2",
     "[| (?f \<longlongrightarrow> ?L) ?F; - exp (- 1) < ?L; ?L < 0 |]
      ==> ((%x. Lambert_W' (?f x)) \<longlongrightarrow> Lambert_W' ?L) ?F",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 2),
                template_app (template_hole 6, template_var 1)),
              template_var 0)
            ),
        template_inequation
         (less_than,
          template_app
           (template_hole 4,
            template_app
             (template_hole 3,
              template_app (template_hole 4, template_hole 2))),
          template_var 1),
        template_inequation (less_than, template_var 1, template_hole 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 7, t_empty),
               template_app
                (template_hole 6,
                 template_app (template_hole 0, template_var 1))),
             template_var 0)
           ))),
    ("Lambert_W.Lambert_W_plus_Lambert_W_eq",
     "[| 0 < ?x; 0 < ?y |]
      ==> Lambert_W ?x + Lambert_W ?y =
          Lambert_W (?x * ?y * (1 / Lambert_W ?x + 1 / Lambert_W ?y))",
     template_implication
      ([template_inequation (less_than, template_hole 6, template_var 1),
        template_inequation (less_than, template_hole 6, template_var 0)],
       template_equation
        (template_app
          (template_app
            (template_hole 4,
             template_app (template_hole 3, template_var 1)),
           template_app (template_hole 3, template_var 0)),
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_var 0)),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_app (template_hole 3, template_var 1))),
               template_app
                (template_app (template_hole 1, template_hole 0),
                 template_app (template_hole 3, template_var 0)))))))),
    ("Lambert_W.tendsto_Lambert_W'_1",
     "[| (?f \<longlongrightarrow> ?L) ?F;
         \<forall>\<^sub>F x in ?F. - exp (- 1) <= ?f x; ?L < 0 |]
      ==> ((%x. Lambert_W' (?f x)) \<longlongrightarrow> Lambert_W' ?L) ?F",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 2),
                template_app (template_hole 8, template_var 1)),
              template_var 0)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 7, t_empty), template_var 0)
            ),
        template_inequation (less_than, template_var 1, template_hole 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 9, t_empty),
               template_app
                (template_hole 8,
                 template_app (template_hole 0, template_var 1))),
             template_var 0)
           ))),
    ("Lambert_W.continuous_Lambert_W",
     "[| continuous ?F ?f;
         - exp (- 1) < ?f (Lim ?F (%x. x)) |
         (\<forall>\<^sub>F x in ?F. - exp (- 1) <= ?f x) |]
      ==> continuous ?F (%x. Lambert_W (?f x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 1),
              template_var 0)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app
                   (template_hole 7,
                    template_app
                     (template_hole 6,
                      template_app
                       (template_hole 5,
                        template_app (template_hole 6, template_hole 4)))),
                  template_app
                   (template_var 0,
                    template_app
                     (template_app (template_hole 3, template_var 1),
                      t_empty)))),
              template_app
               (template_app (template_hole 2, t_empty), template_var 1))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 9, template_var 1), t_empty)
           ))),
    ("Lambert_W.has_field_derivative_Lambert_W_gen",
     "[| (?f has_real_derivative ?f') (at ?x within ?A);
         - exp (- 1) < ?f ?x |]
      ==> ((%x. Lambert_W (?f x)) has_real_derivative
           ?f' / (?f ?x + exp (Lambert_W (?f ?x))))
           (at ?x within ?A)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 7, template_var 1),
                template_var 0))
            ),
        template_inequation
         (less_than,
          template_app
           (template_hole 5,
            template_app
             (template_hole 4,
              template_app (template_hole 5, template_hole 3))),
          template_app (template_var 3, template_var 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 8, t_empty),
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_app
                  (template_app
                    (template_hole 0,
                     template_app (template_var 3, template_var 1)),
                   template_app
                    (template_hole 4,
                     template_app
                      (template_hole 2,
                       template_app (template_var 3, template_var 1)))))),
             template_app
              (template_app (template_hole 7, template_var 1),
               template_var 0))
           ))),
    ("Lambert_W.tendsto_Lambert_W",
     "[| (?f \<longlongrightarrow> ?L) ?F;
         (\<forall>\<^sub>F x in ?F. - exp (- 1) <= ?f x) |
         - exp (- 1) < ?L |]
      ==> ((%x. Lambert_W (?f x)) \<longlongrightarrow> Lambert_W ?L) ?F",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 2),
                template_app (template_hole 8, template_var 1)),
              template_var 0)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, t_empty), template_var 0)),
              template_app
               (template_app
                 (template_hole 1,
                  template_app
                   (template_hole 4,
                    template_app
                     (template_hole 3,
                      template_app (template_hole 4, template_hole 2)))),
                template_var 1))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 9, t_empty),
               template_app
                (template_hole 8,
                 template_app (template_hole 0, template_var 1))),
             template_var 0)
           ))),
    ("Lambert_W.has_field_derivative_Lambert_W'_gen",
     "[| (?f has_real_derivative ?f') (at ?x within ?A);
         ?f ?x : {- exp (- 1)<..<0} |]
      ==> ((%x. Lambert_W' (?f x)) has_real_derivative
           ?f' / (?f ?x + exp (Lambert_W' (?f ?x))))
           (at ?x within ?A)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 10, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 9, template_var 1),
                template_var 0))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app (template_var 3, template_var 1)),
              template_app
               (template_app
                 (template_hole 7,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app (template_hole 6, template_hole 4)))),
                template_hole 3))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 10, t_empty),
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_app
                  (template_app
                    (template_hole 0,
                     template_app (template_var 3, template_var 1)),
                   template_app
                    (template_hole 5,
                     template_app
                      (template_hole 2,
                       template_app (template_var 3, template_var 1)))))),
             template_app
              (template_app (template_hole 9, template_var 1),
               template_var 0))
           ))),
    ("Lambert_W.Lambert_W'_plus_Lambert_W'_eq",
     "[| ?x : {- exp (- 1)..<0}; ?y : {- exp (- 1)..<0} |]
      ==> Lambert_W' ?x + Lambert_W' ?y =
          Lambert_W' (?x * ?y * (1 / Lambert_W' ?x + 1 / Lambert_W' ?y))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 1),
              template_app
               (template_app
                 (template_hole 9,
                  template_app
                   (template_hole 8,
                    template_app
                     (template_hole 7,
                      template_app (template_hole 8, template_hole 6)))),
                template_hole 5))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 0),
              template_app
               (template_app
                 (template_hole 9,
                  template_app
                   (template_hole 8,
                    template_app
                     (template_hole 7,
                      template_app (template_hole 8, template_hole 6)))),
                template_hole 5))
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_var 1)),
           template_app (template_hole 2, template_var 0)),
         template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0)),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 0, template_hole 6),
                   template_app (template_hole 2, template_var 1))),
               template_app
                (template_app (template_hole 0, template_hole 6),
                 template_app (template_hole 2, template_var 0)))))))),
    ("Lambert_W.tendsto_Lambert_W'",
     "[| (?f \<longlongrightarrow> ?L) ?F;
         (\<forall>\<^sub>F x in ?F. - exp (- 1) <= ?f x) |
         - exp (- 1) < ?L;
         ?L < 0 |]
      ==> ((%x. Lambert_W' (?f x)) \<longlongrightarrow> Lambert_W' ?L) ?F",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 10, template_var 2),
                template_app (template_hole 9, template_var 1)),
              template_var 0)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app (template_hole 7, t_empty), template_var 0)),
              template_app
               (template_app
                 (template_hole 2,
                  template_app
                   (template_hole 5,
                    template_app
                     (template_hole 4,
                      template_app (template_hole 5, template_hole 3)))),
                template_var 1))
            ),
        template_inequation (less_than, template_var 1, template_hole 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 10, t_empty),
               template_app
                (template_hole 9,
                 template_app (template_hole 0, template_var 1))),
             template_var 0)
           ))),
    ("Lambert_W.continuous_Lambert_W'",
     "[| continuous ?F ?f;
         - exp (- 1) < ?f (Lim ?F (%x. x)) |
         (\<forall>\<^sub>F x in ?F. - exp (- 1) <= ?f x);
         ?f (Lim ?F (%x. x)) < 0 |]
      ==> continuous ?F (%x. Lambert_W' (?f x))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 1),
              template_var 0)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 9,
                template_app
                 (template_app
                   (template_hole 8,
                    template_app
                     (template_hole 7,
                      template_app
                       (template_hole 6,
                        template_app (template_hole 7, template_hole 5)))),
                  template_app
                   (template_var 0,
                    template_app
                     (template_app (template_hole 4, template_var 1),
                      t_empty)))),
              template_app
               (template_app (template_hole 3, t_empty), template_var 1))
            ),
        template_inequation
         (less_than,
          template_app
           (template_var 0,
            template_app
             (template_app (template_hole 4, template_var 1), t_empty)),
          template_hole 1)],
       template_predicate
        (
           template_app
            (template_app (template_hole 10, template_var 1), t_empty)
           ))),
    ("Lambert_W.asymp_equiv_sandwich''",
     "[| !!c'. c' : {?l<..<1} ==>
               \<forall>\<^sub>F x in ?F. c' * ?g x <= ?f x;
         !!c'. c' : {1<..<?u} ==>
               \<forall>\<^sub>F x in ?F. ?f x <= c' * ?g x;
         ?l < 1; 1 < ?u |]
      ==> ?f \<sim>[?F] ?g",
     template_implication
      ([template_predicate (template_app (template_hole 9, t_empty)),
        template_predicate (template_app (template_hole 9, t_empty)),
        template_inequation (less_than, template_var 4, template_hole 5),
        template_inequation (less_than, template_hole 5, template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 2),
               template_var 1),
             template_var 3)
           ))),
    ("Lambert_W.asymp_equiv_sandwich'",
     "[| !!c'. c' : {?l<..<?c} ==>
               \<forall>\<^sub>F x in ?F. c' * ?g x <= ?f x;
         !!c'. c' : {?c<..<?u} ==>
               \<forall>\<^sub>F x in ?F. ?f x <= c' * ?g x;
         ?l < ?c; ?c < ?u; ?c ~= 0 |]
      ==> ?f \<sim>[?F] (%x. ?c * ?g x)",
     template_implication
      ([template_predicate (template_app (template_hole 11, t_empty)),
        template_predicate (template_app (template_hole 11, t_empty)),
        template_inequation (less_than, template_var 5, template_var 4),
        template_inequation (less_than, template_var 4, template_var 0),
        template_negation
         (template_equation (template_var 4, template_hole 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 2),
               template_var 1),
             t_empty)
           )))]:
   (string * thm * template) list
### theory "Draft.Lambert_WMoreTemplates"
### 0.471s elapsed time, 0.690s cpu time, 0.117s GC time
val it = (): unit
