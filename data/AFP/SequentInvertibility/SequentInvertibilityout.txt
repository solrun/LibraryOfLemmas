Loading theory "HOL-Library.Cancellation" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility" via "Draft.MultiSequents" via "HOL-Library.Multiset")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility" via "Draft.NominalSequents" via "HOL-Nominal.Nominal")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "HOL-Library.Function_Algebras"
### 0.133s elapsed time, 0.544s cpu time, 0.048s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility" via "Draft.NominalSequents" via "HOL-Nominal.Nominal")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  enumerate :: "'a set => nat => 'a"
Found termination order: "size_list size <*mlex*> {}"
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
### theory "HOL-Library.Infinite_Set"
### 0.338s elapsed time, 1.358s cpu time, 0.107s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
### theory "HOL-Library.Nat_Bijection"
### 0.363s elapsed time, 1.460s cpu time, 0.107s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.ExtrEqs")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.435s elapsed time, 1.749s cpu time, 0.107s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility" via "Draft.MultiSequents")
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.404s elapsed time, 1.588s cpu time, 0.166s GC time
Loading theory "HOL-Nominal.Nominal" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility" via "Draft.NominalSequents")
### theory "HOL-Library.Set_Algebras"
### 0.217s elapsed time, 0.851s cpu time, 0.107s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  flat :: "'a list stream => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Stream"
### 1.153s elapsed time, 4.334s cpu time, 1.019s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
overloading
  perm_fun \<equiv> perm :: ('x * 'x) list => ('a => 'b) => 'a => 'b
  perm_bool \<equiv> perm :: ('x * 'x) list => bool => bool
  perm_set \<equiv> perm :: ('x * 'x) list => 'a set => 'a set
  perm_unit \<equiv> perm :: ('x * 'x) list => unit => unit
  perm_prod \<equiv> perm :: ('x * 'x) list => 'a * 'b => 'a * 'b
  perm_list \<equiv> perm :: ('x * 'x) list => 'a list => 'a list
  perm_option \<equiv> perm :: ('x * 'x) list => 'a option => 'a option
  perm_char \<equiv> perm :: ('x * 'x) list => char => char
  perm_nat \<equiv> perm :: ('x * 'x) list => nat => nat
  perm_int \<equiv> perm :: ('x * 'x) list => int => int
  perm_noption \<equiv> perm :: ('x * 'x) list => 'a noption => 'a noption
  perm_nprod \<equiv> perm ::
    ('x * 'x) list => ('a, 'b) nprod => ('a, 'b) nprod
consts
  perm_unit :: "('x * 'x) list => unit => unit"
consts
  perm_prod :: "('x * 'x) list => 'a * 'b => 'a * 'b"
consts
  perm_list :: "('x * 'x) list => 'a list => 'a list"
consts
  perm_option :: "('x * 'x) list => 'a option => 'a option"
Found termination order: "size <*mlex*> {}"
consts
  perm_noption :: "('x * 'x) list => 'a noption => 'a noption"
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
consts
  perm_nprod :: "('x * 'x) list => ('a, 'b) nprod => ('a, 'b) nprod"
Found termination order: "size <*mlex*> {}"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
Found termination order: "size <*mlex*> {}"
val mksimps_pairs =
   [("Nominal.fresh",
     ["?a \<sharp> (?x, ?y) ==> ?a \<sharp> ?x",
      "?a \<sharp> (?x, ?y) ==> ?a \<sharp> ?y"]),
    ("Set.Ball", ["[| ALL x:?A. ?P x; ?x : ?A |] ==> ?P ?x"]),
    ("HOL.implies", ["[| ?P --> ?Q; ?P |] ==> ?Q"]),
    ("HOL.conj", ["?P & ?Q ==> ?P", "?P & ?Q ==> ?Q"]),
    ("HOL.All", ["ALL x. ?P x ==> ?P ?x"]), ("HOL.True", []),
    ("HOL.False", []),
    ("HOL.If",
     ["if ?P1 then ?Q1 else ?R1 ==> (?P1 --> ?Q1) & (~ ?P1 --> ?R1)"])]:
   (string * thm list) list
Found termination order: "size <*mlex*> {}"
consts
  mset :: "'a list => 'a multiset"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "HOL-Library.BigO"
### 1.172s elapsed time, 4.422s cpu time, 1.319s GC time
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
Found termination order: "size <*mlex*> {}"
overloading
  fresh_star_set \<equiv> fresh_star :: 'b set => 'a => bool
overloading
  frsh_star_list \<equiv> fresh_star :: 'b list => 'a => bool
### theory "HOL-Library.Tree"
### 2.600s elapsed time, 9.433s cpu time, 2.420s GC time
Loading theory "Draft.Templates" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.ExtrEqs")
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.088s elapsed time, 0.280s cpu time, 0.094s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.SequentInvertibilityMoreTemplates")
Proofs for inductive predicate(s) "ABS_setp"
  Proving monotonicity ...
### ML warning (line 73 of "~~/src/HOL/Nominal/nominal_thmdecls.ML"):
### Pattern is not exhaustive.
### ML warning (line 104 of "~~/src/HOL/Nominal/nominal_thmdecls.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 102 of "~~/src/HOL/Nominal/nominal_thmdecls.ML"):
### Value identifier (typrm) has not been referenced.
### ML warning (line 149 of "~~/src/HOL/Nominal/nominal_thmdecls.ML"):
### Value identifier (typrm) has not been referenced.
signature NOMINAL_THMDECLS =
  sig
    val eqvt_add: attribute
    val eqvt_del: attribute
    val eqvt_force_add: attribute
    val eqvt_force_del: attribute
    val get_eqvt_thms: Proof.context -> thm list
    val nominal_eqvt_debug: bool Config.T
    val setup: theory -> theory
  end
structure NominalThmDecls: NOMINAL_THMDECLS
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.943s elapsed time, 2.980s cpu time, 1.253s GC time
### ML warning (line 132 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (prems) has not been referenced.
### ML warning (line 171 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (swap_eqs) has not been referenced.
### ML warning (line 205 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (prm_eqs) has not been referenced.
### ML warning (line 241 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (perm_defs) has not been referenced.
### ML warning (line 263 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 322 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 369 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 368 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (fs_inst_thms) has not been referenced.
### ML warning (line 416 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 417 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 453 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 454 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 636 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (cp_bool_inst) has not been referenced.
### ML warning (line 751 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (supp_def) has not been referenced.
### ML warning (line 893 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (inst_pt_pt_at_cp) has not been referenced.
signature NOMINAL_ATOMS =
  sig
    val at_inst_of: theory -> string -> thm
    type atom_info
    val atoms_of: theory -> string list
    val cp_class_of: theory -> string -> string -> string
    val cp_inst_of: theory -> string -> string -> thm
    val create_nom_typedecls: string list -> theory -> theory
    val dj_thm_of: theory -> string -> string -> thm
    val fs_class_of: theory -> string -> string
    val get_atom_info: theory -> string -> atom_info option
    val get_atom_infos: theory -> atom_info Symtab.table
    val mk_permT: typ -> typ
    val pt_class_of: theory -> string -> string
    val pt_inst_of: theory -> string -> thm
    val the_atom_info: theory -> string -> atom_info
  end
structure NominalAtoms: NOMINAL_ATOMS
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
### ML warning (line 104 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 104 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (pi) has not been referenced.
### ML warning (line 120 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 132 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (pi) has not been referenced.
### ML warning (line 291 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 290 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 289 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 312 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Pattern is not exhaustive.
### ML warning (line 356 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Pattern is not exhaustive.
### ML warning (line 376 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (eqvt_simp_tac) has not been referenced.
signature NOMINAL_PERMEQ =
  sig
    val finite_guess_meth: (Proof.context -> Proof.method) context_parser
    val finite_guess_meth_debug:
       (Proof.context -> Proof.method) context_parser
    val finite_guess_tac: Proof.context -> int -> tactic
    val fresh_guess_meth: (Proof.context -> Proof.method) context_parser
    val fresh_guess_meth_debug:
       (Proof.context -> Proof.method) context_parser
    val fresh_guess_tac: Proof.context -> int -> tactic
    val perm_extend_simp_meth:
       (Proof.context -> Proof.method) context_parser
    val perm_extend_simp_meth_debug:
       (Proof.context -> Proof.method) context_parser
    val perm_extend_simp_tac: Proof.context -> int -> tactic
    val perm_simp_meth: (Proof.context -> Proof.method) context_parser
    val perm_simp_meth_debug: (Proof.context -> Proof.method) context_parser
    val perm_simp_tac: Proof.context -> int -> tactic
    val perm_simproc_app: simproc
    val perm_simproc_fun: simproc
    val supports_meth: (Proof.context -> Proof.method) context_parser
    val supports_meth_debug: (Proof.context -> Proof.method) context_parser
    val supports_tac: Proof.context -> int -> tactic
  end
structure NominalPermeq: NOMINAL_PERMEQ
### ML warning (line 94 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 89 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 88 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (j) has not been referenced.
### ML warning (line 137 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 139 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 150 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (i) has not been referenced.
val gen_res_inst_tac_term = fn:
   Proof.context ->
     ((typ * ctyp) list -> (term * cterm) list -> thm -> thm) ->
       (typ * typ) list ->
         (term * term) list -> bool -> thm -> int -> thm -> thm Seq.seq
val res_inst_tac_term = fn:
   Proof.context ->
     (typ * typ) list ->
       (term * term) list -> bool -> thm -> int -> thm -> thm Seq.seq
val res_inst_tac_term' = fn:
   Proof.context ->
     (term * term) list -> bool -> thm -> int -> thm -> thm Seq.seq
val cut_inst_tac_term' = fn:
   Proof.context -> (term * term) list -> thm -> int -> thm -> thm Seq.seq
val get_dyn_thm = fn: theory -> xstring -> string -> thm
val at_exists_fresh' =
   "[| at TYPE(?'x); finite (supp ?x) |] ==> EX c. c \<sharp> ?x": thm
val fresh_fun_app' =
   "[| pt TYPE(?'a) TYPE(?'x); at TYPE(?'x); finite (supp ?h);
       ?a \<sharp> ?h; ?a \<sharp> ?h ?a |]
    ==> fresh_fun ?h = ?h ?a":
   thm
val fresh_prod = "?a \<sharp> (?x, ?y) = (?a \<sharp> ?x & ?a \<sharp> ?y)":
   thm
val generate_fresh_tac = fn: Proof.context -> string -> tactic
val get_inner_fresh_fun = fn: term -> string option
val generate_fresh_fun_tac = fn: Proof.context -> tactic
val search_fun = fn: EqSubst.searchinfo -> term -> EqSubst.match Seq.seq
val search_fun_asm = fn:
   EqSubst.searchinfo -> int -> term -> EqSubst.match EqSubst.skipseq
val subst_inner_tac = fn: Proof.context -> thm -> int -> thm -> thm Seq.seq
val subst_inner_asm_tac_aux = fn:
   int -> Proof.context -> thm -> int -> tactic
val subst_inner_asm_tac = fn: Proof.context -> thm -> int -> tactic
val fresh_fun_tac = fn: Proof.context -> bool -> int -> tactic
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
### theory "HOL-Library.Multiset"
### 4.344s elapsed time, 14.366s cpu time, 4.016s GC time
Loading theory "Draft.ModalSequents" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility")
Loading theory "Draft.MultiSequents" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility")
Loading theory "Draft.SRCTransforms" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility")
### ML warning (line 62 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (put_nominal_datatypes) has not been referenced.
### ML warning (line 89 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 93 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 101 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 183 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (constrs) has not been referenced.
### ML warning (line 183 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (tvs) has not been referenced.
### ML warning (line 185 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (cargs) has not been referenced.
### ML warning (line 189 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (rps) has not been referenced.
### ML warning (line 197 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (mx) has not been referenced.
### ML warning (line 199 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (mx) has not been referenced.
### ML warning (line 202 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (new_type_names') has not been referenced.
### ML warning (line 257 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (perm_simps) has not been referenced.
### ML warning (line 277 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 278 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 278 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (T1) has not been referenced.
### ML warning (line 316 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (at_pt_inst) has not been referenced.
### ML warning (line 441 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (perm_thmss) has not been referenced.
### ML warning (line 474 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 553 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 692 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 708 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 711 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 744 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (full_new_type_names) has not been referenced.
### ML warning (line 780 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 829 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 830 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 850 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (dist_rewrites) has not been referenced.
### ML warning (line 1137 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1156 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 1162 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (xss) has not been referenced.
### ML warning (line 1213 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (induct) has not been referenced.
### ML warning (line 1216 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1228 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (induct') has not been referenced.
### ML warning (line 1245 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1247 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1269 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1280 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1312 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (prems2) has not been referenced.
### ML warning (line 1334 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1366 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1400 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1439 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1465 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 1464 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (rs) has not been referenced.
### ML warning (line 1645 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1649 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1662 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1699 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1717 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1773 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (asms) has not been referenced.
### ML warning (line 1775 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1777 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1778 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1780 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1786 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1874 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1875 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1881 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1909 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1926 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1932 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1949 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1963 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1988 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 2055 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 2057 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
signature NOMINAL_DATATYPE =
  sig
    type descr
    val fresh_const: typ -> typ -> term
    val fresh_star_const: typ -> typ -> term
    val get_nominal_datatype:
       theory -> string -> nominal_datatype_info option
    val get_nominal_datatypes: theory -> nominal_datatype_info Symtab.table
    val mk_not_sym: thm list -> thm list
    val mk_perm: typ list -> term -> term -> term
    val nominal_datatype:
       Old_Datatype_Aux.config -> Old_Datatype.spec list -> theory -> theory
    val nominal_datatype_cmd:
       Old_Datatype_Aux.config ->
         Old_Datatype.spec_cmd list -> theory -> theory
    type nominal_datatype_info
    val perm_of_pair: term * term -> term
    val perm_simproc: simproc
  end
structure NominalDatatype: NOMINAL_DATATYPE
### ML warning (line 144 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Matches are not exhaustive.
### ML warning (line 155 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (rs) has not been referenced.
### ML warning (line 155 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (ls) has not been referenced.
### ML warning (line 173 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 204 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (tname) has not been referenced.
### ML warning (line 213 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 223 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (dt_info) has not been referenced.
### ML warning (line 233 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 232 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 248 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 287 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 289 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 290 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 291 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 292 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
signature NOMINAL_PRIMREC =
  sig
    val primrec:
       term list option ->
         term option ->
           (binding * typ option * mixfix) list ->
             (binding * typ option * mixfix) list ->
               Specification.multi_specs -> local_theory -> Proof.state
    val primrec_cmd:
       string list option ->
         string option ->
           (binding * string option * mixfix) list ->
             (binding * string option * mixfix) list ->
               Specification.multi_specs_cmd -> local_theory -> Proof.state
  end
structure NominalPrimrec: NOMINAL_PRIMREC
### Ambiguous input (line 47 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 2 parse trees:
### ("\<^const>Pure.eq" ("\<^const>Set.supset" ("_position" p) ("_position" q))
###   ("_applC" ("_position" Compound)
###     ("_cargs" ("_position" imp)
###       ("_list" ("_args" ("_position" p) ("_position" q))))))
### ("\<^const>Pure.eq" ("\<^fixed>imp_form" ("_position" p) ("_position" q))
###   ("_applC" ("_position" Compound)
###     ("_cargs" ("_position" imp)
###       ("_list" ("_args" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### ML warning (line 74 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 74 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 63 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 64 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 83 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 83 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 82 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (names) has not been referenced.
### ML warning (line 94 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 107 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern 3 is redundant.
### ML warning (line 121 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 121 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (s') has not been referenced.
### ML warning (line 207 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 213 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 306 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 371 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 420 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (name) has not been referenced.
### ML warning (line 422 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 423 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 437 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 451 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (prem) has not been referenced.
### ML warning (line 478 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 574 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 623 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 635 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
signature NOMINAL_INDUCTIVE =
  sig
    val prove_eqvt: string -> string list -> local_theory -> local_theory
    val prove_strong_ind:
       string -> (string * string list) list -> local_theory -> Proof.state
  end
structure NominalInductive: NOMINAL_INDUCTIVE
consts
  antec :: "'a sequent => 'a form multiset"
consts
  succ :: "'a sequent => 'a form multiset"
consts
  mset :: "'a sequent => 'a form multiset"
consts
  seq_size :: "'a sequent => nat"
overloading
  extend \<equiv> extend :: 'a sequent => 'a sequent => 'a sequent
  extendRule \<equiv> extendRule ::
    'a sequent
    => 'a sequent list * 'a sequent => 'a sequent list * 'a sequent
  uniqueConclusion \<equiv> uniqueConclusion ::
    ('a sequent list * 'a sequent) set => bool
consts
  max_list :: "nat list => nat"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "Axp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "upRulesp"
### ML warning (line 56 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (transp) has not been referenced.
### ML warning (line 79 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 79 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 67 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 68 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 88 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 88 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 87 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Matches are not exhaustive.
### ML warning (line 107 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (names) has not been referenced.
### ML warning (line 99 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 112 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern 3 is redundant.
### ML warning (line 126 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 126 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (s') has not been referenced.
### ML warning (line 161 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (ind_params) has not been referenced.
### ML warning (line 163 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (elims) has not been referenced.
### ML warning (line 194 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Matches are not exhaustive.
### ML warning (line 233 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 239 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Matches are not exhaustive.
### ML warning (line 329 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 337 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 341 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 370 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (pi_sets) has not been referenced.
### ML warning (line 462 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (induct_cases') has not been referenced.
### ML warning (line 465 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (thsss) has not been referenced.
### ML warning (line 479 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
signature NOMINAL_INDUCTIVE2 =
  sig
    val prove_strong_ind:
       string ->
         string option ->
           (string * string list) list -> local_theory -> Proof.state
  end
structure NominalInductive2: NOMINAL_INDUCTIVE2
  Proving monotonicity ...
### Ambiguous input (line 101 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" seq)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" seq) ("_position" r))
###           ("_position" R))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" seq) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" seq) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "extRulesp"
  Proving monotonicity ...
### ML warning (line 17 of "~~/src/HOL/Nominal/nominal_induct.ML"):
### Value identifier (tupleT) has not been referenced.
### ML warning (line 48 of "~~/src/HOL/Nominal/nominal_induct.ML"):
### Pattern is not exhaustive.
structure NominalInduct:
  sig
    val nominal_induct_method:
       (Proof.context -> Proof.method) context_parser
    val nominal_induct_tac:
       bool ->
         (binding option * (term * bool)) option list list ->
           (string * typ) list ->
             (string * typ) list list ->
               thm list -> thm list -> int -> context_tactic
  end
### theory "HOL-Nominal.Nominal"
### 5.938s elapsed time, 20.504s cpu time, 5.983s GC time
Loading theory "Draft.SingleSuccedent" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility")
Proofs for inductive predicate(s) "leftPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rightPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "derivablep"
  Proving monotonicity ...
consts
  antec :: "'a sequent => 'a form multiset"
consts
  succ :: "'a sequent => 'a form multiset"
consts
  mset :: "'a sequent => 'a form multiset"
Proofs for inductive predicate(s) "derivable'p"
consts
  seq_size :: "'a sequent => nat"
  Proving monotonicity ...
consts
  max_list :: "nat list => nat"
overloading
  invertible \<equiv> invertible ::
    'a sequent list * 'a sequent
    => ('a sequent list * 'a sequent) set => bool
  invertible_set \<equiv> invertible_set ::
    ('a sequent list * 'a sequent) set => bool
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "Axp"
  Proving monotonicity ...
### Ambiguous input (line 187 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 25 parse trees (10 displayed):
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("\<^const>SRCTransforms.extRules"
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SRCTransforms.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>SRCTransforms.extRules"
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SRCTransforms.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SRCTransforms.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member" ("_position" r)
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>HOL.conj" ("_position" R)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("_applC" ("_position" snd)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r))))
###                 ("_tuple_arg" ("_position" n)))
###               ("_applC" ("_position" derivable) ("_position" R))))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SRCTransforms.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>SRCTransforms.extRules" ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SRCTransforms.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("\<^const>SRCTransforms.extRules"
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SRCTransforms.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>SRCTransforms.extRules"
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SRCTransforms.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SRCTransforms.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member" ("_position" r)
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>HOL.conj" ("_position" R)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("_applC" ("_position" snd)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r))))
###                 ("_tuple_arg" ("_position" n)))
###               ("_applC" ("_position" derivable) ("_position" R))))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SRCTransforms.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>SRCTransforms.extRules" ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SRCTransforms.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "upRulesp"
### Ambiguous input (line 258 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SRCTransforms.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
### Ambiguous input (line 276 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SRCTransforms.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "g3cpp"
  Proving monotonicity ...
### Ambiguous input (line 420 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 5 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" p)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r)))))
###               ("_Ex_less_eq" ("_position" m) ("_position" n)
###                 ("\<^const>Set.member"
###                   ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                   ("\<^const>SRCTransforms.extRules"
###                     ("_applC" ("_position" derivable)
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" p)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r)))))
###               ("\<^const>SRCTransforms.extRules"
###                 ("_Ex_less_eq" ("_position" m) ("_position" n)
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" p)
###                       ("_tuple_arg" ("_position" m)))
###                     ("_applC" ("_position" derivable)
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>SRCTransforms.extRules"
###               ("_Ball" ("_position" p)
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst)
###                     ("_applC" ("_position" extendRule)
###                       ("_cargs" ("_position" S) ("_position" r)))))
###                 ("_Ex_less_eq" ("_position" m) ("_position" n)
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" p)
###                       ("_tuple_arg" ("_position" m)))
###                     ("_applC" ("_position" derivable)
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" p)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r)))))
###               ("_Ex_less_eq" ("_position" m) ("_position" n)
###                 ("\<^const>SRCTransforms.extRules"
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" p)
###                       ("_tuple_arg" ("_position" m)))
###                     ("_applC" ("_position" derivable)
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" p)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r)))))
###               ("_Ex_less_eq" ("_position" m) ("_position" n)
###                 ("\<^const>Set.member"
###                   ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                   ("_applC" ("_position" derivable)
###                     ("\<^const>SRCTransforms.extRules"
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "lastRule"
  Proving monotonicity ...
### Ambiguous input (line 430 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" p)
###           ("_applC" ("_position" set) ("_position" Ps))
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("\<^const>SRCTransforms.extRules"
###                 ("_applC" ("_position" derivable) ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" p)
###           ("_applC" ("_position" set) ("_position" Ps))
###           ("\<^const>SRCTransforms.extRules"
###             ("_Ex_less_eq" ("_position" m) ("_position" n)
###               ("\<^const>Set.member"
###                 ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                 ("_applC" ("_position" derivable) ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>SRCTransforms.extRules"
###           ("_Ball" ("_position" p)
###             ("_applC" ("_position" set) ("_position" Ps))
###             ("_Ex_less_eq" ("_position" m) ("_position" n)
###               ("\<^const>Set.member"
###                 ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                 ("_applC" ("_position" derivable) ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" p)
###           ("_applC" ("_position" set) ("_position" Ps))
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>SRCTransforms.extRules"
###               ("\<^const>Set.member"
###                 ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                 ("_applC" ("_position" derivable) ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" p)
###           ("_applC" ("_position" set) ("_position" Ps))
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable)
###                 ("\<^const>SRCTransforms.extRules" ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 463 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###     ("\<^const>SRCTransforms.extRules" ("_position" R))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###       ("_position" R))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 474 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SRCTransforms.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 477 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SRCTransforms.sequent.Sequent"
###         ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###           ("_position" \<Gamma>'))
###         ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###           ("_position" \<Delta>')))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SRCTransforms.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SRCTransforms.sequent.Sequent"
###         ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###           ("_position" \<Gamma>'))
###         ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###           ("_position" \<Delta>')))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SRCTransforms.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 567 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SRCTransforms.extRules"
###         ("\<^const>Set.union"
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r1)))
###           ("_Finset" ("_position" r2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union"
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r1)))
###           ("_Finset" ("_position" r2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union"
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r1)))
###           ("_Finset" ("_position" r2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 568 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" T) ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" T) ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r2))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>SRCTransforms.extRules"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" T) ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r2))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" T) ("_tuple_arg" ("_position" m)))
###       ("\<^const>SRCTransforms.extRules"
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r2))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 667 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SRCTransforms.extRules"
###         ("\<^const>Set.union" ("_position" R)
###           ("_Finset" ("_position" r1)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" R)
###           ("_Finset" ("_position" r1)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" R)
###           ("_Finset" ("_position" r1)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
overloading
  extend \<equiv> extend :: 'a sequent => 'a sequent => 'a sequent
  extendRule \<equiv> extendRule ::
    'a sequent
    => 'a sequent list * 'a sequent => 'a sequent list * 'a sequent
### Ambiguous input (line 192 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" seq)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" seq) ("_position" r))
###           ("_position" R))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" seq) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" seq) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "extRulesp"
  Proving monotonicity ...
overloading
  uniqueConclusion \<equiv> uniqueConclusion ::
    ('a sequent list * 'a sequent) set => bool
### Ambiguous input (line 668 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 75 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.implies"
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###                 ("_position" A)))
###             ("_applC" ("_position" derivable') ("_position" R))))
###         ("\<^const>Set.member"
###           ("\<^const>SRCTransforms.sequent.Sequent"
###             ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Gamma>)
###               ("_position" A))
###             ("_position" \<Delta>))
###           ("\<^const>SRCTransforms.extRules"
###             ("_applC" ("_position" derivable') ("_position" R)))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###               ("_position" A)))
###           ("\<^const>SRCTransforms.extRules"
###             ("_applC" ("_position" derivable') ("_position" R))))
###         ("\<^const>Set.member"
###           ("\<^const>SRCTransforms.sequent.Sequent"
###             ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Gamma>)
###               ("_position" A))
###             ("_position" \<Delta>))
###           ("\<^const>SRCTransforms.extRules"
###             ("_applC" ("_position" derivable') ("_position" R)))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###               ("_position" A)))
###           ("_applC" ("_position" derivable')
###             ("\<^const>SRCTransforms.extRules" ("_position" R))))
###         ("\<^const>Set.member"
###           ("\<^const>SRCTransforms.sequent.Sequent"
###             ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Gamma>)
###               ("_position" A))
###             ("_position" \<Delta>))
###           ("\<^const>SRCTransforms.extRules"
###             ("_applC" ("_position" derivable') ("_position" R)))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>SRCTransforms.extRules"
###         ("\<^const>HOL.implies"
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###                 ("_position" A)))
###             ("_applC" ("_position" derivable')
###               ("\<^const>SRCTransforms.extRules" ("_position" R))))
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent"
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Gamma>)
###                 ("_position" A))
###               ("_position" \<Delta>))
###             ("_applC" ("_position" derivable') ("_position" R)))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.implies"
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###                 ("_position" A)))
###             ("_applC" ("_position" derivable') ("_position" R))))
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent"
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Gamma>)
###                 ("_position" A))
###               ("_position" \<Delta>))
###             ("_applC" ("_position" derivable') ("_position" R)))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###               ("_position" A)))
###           ("\<^const>SRCTransforms.extRules"
###             ("_applC" ("_position" derivable') ("_position" R))))
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent"
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Gamma>)
###                 ("_position" A))
###               ("_position" \<Delta>))
###             ("_applC" ("_position" derivable') ("_position" R)))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###             ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###               ("_position" A)))
###           ("_applC" ("_position" derivable')
###             ("\<^const>SRCTransforms.extRules" ("_position" R))))
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent"
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Gamma>)
###                 ("_position" A))
###               ("_position" \<Delta>))
###             ("_applC" ("_position" derivable') ("_position" R)))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###             ("_position" A)))
###         ("\<^const>SRCTransforms.extRules"
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" derivable')
###               ("\<^const>SRCTransforms.extRules" ("_position" R)))
###             ("\<^const>Set.member"
###               ("\<^const>SRCTransforms.sequent.Sequent"
###                 ("\<^const>SRCTransforms.multiset_plus"
###                   ("_position" \<Gamma>) ("_position" A))
###                 ("_position" \<Delta>))
###               ("_applC" ("_position" derivable') ("_position" R))))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###             ("_position" A)))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules"
###             ("\<^const>HOL.implies"
###               ("\<^const>SRCTransforms.extRules" ("_position" R))
###               ("\<^const>Set.member"
###                 ("\<^const>SRCTransforms.sequent.Sequent"
###                   ("\<^const>SRCTransforms.multiset_plus"
###                     ("_position" \<Gamma>) ("_position" A))
###                   ("_position" \<Delta>))
###                 ("_applC" ("_position" derivable') ("_position" R)))))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder"
###     ("_idts" ("_position" \<Gamma>)
###       ("_idts" ("_position" \<Delta>) ("_position" A)))
###     ("\<^const>HOL.implies"
###       ("\<^const>SRCTransforms.extRules"
###         ("\<^const>HOL.implies"
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Delta>)
###                 ("_position" A)))
###             ("\<^const>SRCTransforms.extRules"
###               ("_applC" ("_position" derivable') ("_position" R))))
###           ("\<^const>Set.member"
###             ("\<^const>SRCTransforms.sequent.Sequent"
###               ("\<^const>SRCTransforms.multiset_plus" ("_position" \<Gamma>)
###                 ("_position" A))
###               ("_position" \<Delta>))
###             ("_applC" ("_position" derivable') ("_position" R)))))
###       ("\<^const>Set.member"
###         ("\<^const>SRCTransforms.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_applC" ("_position" derivable')
###           ("\<^const>SRCTransforms.extRules" ("_position" R)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 671 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" T)
###     ("_applC" ("_position" derivable')
###       ("\<^const>SRCTransforms.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" T)
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable') ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member" ("_position" T)
###       ("_applC" ("_position" derivable') ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "leftPrincipal"
  Proving monotonicity ...
### Ambiguous input (line 743 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SRCTransforms.extRules"
###         ("\<^const>Set.union"
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r1)))
###           ("_Finset" ("_position" r2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union"
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r1)))
###           ("_Finset" ("_position" r2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union"
###           ("\<^const>Set.union" ("_position" R)
###             ("_Finset" ("_position" r1)))
###           ("_Finset" ("_position" r2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 744 of "$AFP/SequentInvertibility/SRCTransforms.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SRCTransforms.extRules"
###         ("\<^const>Set.union" ("_position" R)
###           ("_Finset" ("_position" r3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###     ("\<^const>SRCTransforms.extRules"
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" R)
###           ("_Finset" ("_position" r3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SRCTransforms.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" T) ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" R)
###           ("_Finset" ("_position" r3)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "rightPrincipal"
  Proving monotonicity ...
### theory "Draft.SRCTransforms"
### 2.346s elapsed time, 9.106s cpu time, 2.321s GC time
Loading theory "Draft.NominalSequents" (required by "Draft.SequentInvertibilityMoreTemplates" via "Draft.SequentInvertibility")
Proofs for inductive predicate(s) "derivablep"
  Proving monotonicity ...
Proofs for inductive predicate(s) "derivable'p"
  Proving monotonicity ...
### Ambiguous input (line 418 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>MultiSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>MultiSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 435 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>MultiSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>MultiSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 579 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 5 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" p)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r)))))
###               ("_Ex_less_eq" ("_position" m) ("_position" n)
###                 ("\<^const>Set.member"
###                   ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                   ("\<^const>MultiSequents.extRules"
###                     ("_applC" ("_position" derivable)
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" p)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r)))))
###               ("\<^const>MultiSequents.extRules"
###                 ("_Ex_less_eq" ("_position" m) ("_position" n)
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" p)
###                       ("_tuple_arg" ("_position" m)))
###                     ("_applC" ("_position" derivable)
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>MultiSequents.extRules"
###               ("_Ball" ("_position" p)
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst)
###                     ("_applC" ("_position" extendRule)
###                       ("_cargs" ("_position" S) ("_position" r)))))
###                 ("_Ex_less_eq" ("_position" m) ("_position" n)
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" p)
###                       ("_tuple_arg" ("_position" m)))
###                     ("_applC" ("_position" derivable)
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" p)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r)))))
###               ("_Ex_less_eq" ("_position" m) ("_position" n)
###                 ("\<^const>MultiSequents.extRules"
###                   ("\<^const>Set.member"
###                     ("_tuple" ("_position" p)
###                       ("_tuple_arg" ("_position" m)))
###                     ("_applC" ("_position" derivable)
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("_Ball" ("_position" p)
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r)))))
###               ("_Ex_less_eq" ("_position" m) ("_position" n)
###                 ("\<^const>Set.member"
###                   ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                   ("_applC" ("_position" derivable)
###                     ("\<^const>MultiSequents.extRules"
###                       ("_position" R)))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lastRule)
###       ("_cargs"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###             ("_position" \<Delta>))
###           ("_tuple_arg"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("\<^const>Groups.one_class.one"))))
###         ("_cargs" ("_position" r) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "lastRule"
  Proving monotonicity ...
### Ambiguous input (line 589 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" p)
###           ("_applC" ("_position" set) ("_position" Ps))
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("\<^const>MultiSequents.extRules"
###                 ("_applC" ("_position" derivable) ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" p)
###           ("_applC" ("_position" set) ("_position" Ps))
###           ("\<^const>MultiSequents.extRules"
###             ("_Ex_less_eq" ("_position" m) ("_position" n)
###               ("\<^const>Set.member"
###                 ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                 ("_applC" ("_position" derivable) ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>MultiSequents.extRules"
###           ("_Ball" ("_position" p)
###             ("_applC" ("_position" set) ("_position" Ps))
###             ("_Ex_less_eq" ("_position" m) ("_position" n)
###               ("\<^const>Set.member"
###                 ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                 ("_applC" ("_position" derivable) ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" p)
###           ("_applC" ("_position" set) ("_position" Ps))
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>MultiSequents.extRules"
###               ("\<^const>Set.member"
###                 ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###                 ("_applC" ("_position" derivable) ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder" ("_idts" ("_position" S) ("_position" Ps))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_tuple" ("_position" Ps)
###           ("_tuple_arg"
###             ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###               ("_position" \<Delta>)))))
###       ("\<^const>HOL.conj"
###         ("_Ball" ("_position" p)
###           ("_applC" ("_position" set) ("_position" Ps))
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable)
###                 ("\<^const>MultiSequents.extRules" ("_position" R))))))
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.not_member" ("_position" r) ("_position" Ax)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 625 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###     ("\<^const>MultiSequents.extRules" ("_position" R))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###       ("_position" R))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  antec :: "'a sequent => 'a form multiset"
consts
  succ :: "'a sequent => 'a form"
### Ambiguous input (line 644 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###           ("_applC" ("_position" Compound)
###             ("_cargs" ("_position" F) ("_position" Fs)))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>MultiSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###           ("_applC" ("_position" Compound)
###             ("_cargs" ("_position" F) ("_position" Fs)))))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>MultiSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###             ("_applC" ("_position" Compound)
###               ("_cargs" ("_position" F) ("_position" Fs)))))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  mset :: "'a sequent => 'a form multiset"
### Ambiguous input (line 647 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>MultiSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>MultiSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>MultiSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  seq_size :: "'a sequent => nat"
overloading
  extend \<equiv> extend :: 'a sequent => 'a sequent => 'a sequent
  extendRule \<equiv> extendRule ::
    'a sequent
    => 'a sequent list * 'a sequent => 'a sequent list * 'a sequent
Proofs for inductive predicate(s) "Axp"
  Proving monotonicity ...
### Ambiguous input (line 953 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>MultiSequents.con_form" ("_position" A)
###             ("_position" B))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>MultiSequents.extRules"
###         ("\<^const>Set.union" ("_position" g3cp) ("_position" Ax))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>MultiSequents.con_form" ("_position" A)
###             ("_position" B))))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>MultiSequents.extRules"
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" g3cp) ("_position" Ax))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###             ("\<^const>MultiSequents.con_form" ("_position" A)
###               ("_position" B))))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" g3cp) ("_position" Ax))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 954 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###             ("_position" A)))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>MultiSequents.extRules"
###           ("\<^const>Set.union" ("_position" g3cp) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###             ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###               ("_position" A)))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" g3cp) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>MultiSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###             ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###               ("_position" A)))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" g3cp) ("_position" Ax)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>MultiSequents.multiset_plus" ("_position" \<Delta>)
###             ("_position" A)))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>MultiSequents.extRules"
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" g3cp) ("_position" Ax)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 974 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent"
###         ("\<^const>MultiSequents.multiset_plus" ("_position" \<Gamma>)
###           ("_applC" ("_position" Compound)
###             ("_cargs" ("_position" F) ("_position" Fs))))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>MultiSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>MultiSequents.sequent.Sequent"
###         ("\<^const>MultiSequents.multiset_plus" ("_position" \<Gamma>)
###           ("_applC" ("_position" Compound)
###             ("_cargs" ("_position" F) ("_position" Fs))))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>MultiSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent"
###           ("\<^const>MultiSequents.multiset_plus" ("_position" \<Gamma>)
###             ("_applC" ("_position" Compound)
###               ("_cargs" ("_position" F) ("_position" Fs))))
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 976 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>MultiSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>MultiSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>MultiSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>MultiSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>MultiSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "upRulesp"
  Proving monotonicity ...
### Ambiguous input (line 1256 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###     ("\<^const>MultiSequents.extRules" ("_position" R))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###       ("_position" R))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1257 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" C) ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>MultiSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" C) ("_tuple_arg" ("_position" n)))
###     ("\<^const>MultiSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" C) ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1258 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>MultiSequents.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>MultiSequents.extRules"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>MultiSequents.extRules"
###     ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###       ("_Ex_less_eq" ("_position" m) ("_position" n)
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("\<^const>MultiSequents.extRules"
###       ("_Ex_less_eq" ("_position" m) ("_position" n)
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###         ("\<^const>MultiSequents.extRules"
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
overloading
  invertible \<equiv> invertible ::
    'a sequent list * 'a sequent
    => ('a sequent list * 'a sequent) set => bool
  invertible_set \<equiv> invertible_set ::
    ('a sequent list * 'a sequent) set => bool
### Ambiguous input (line 105 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" seq)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" seq) ("_position" r))
###           ("_position" R))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" seq) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" seq) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "extRulesp"
  Proving monotonicity ...
### Ambiguous input (line 1405 of "$AFP/SequentInvertibility/MultiSequents.thy") produces 25 parse trees (10 displayed):
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("\<^const>MultiSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>MultiSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>MultiSequents.extRules"
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>MultiSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>MultiSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>MultiSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member" ("_position" r)
###         ("\<^const>MultiSequents.extRules"
###           ("\<^const>HOL.conj" ("_position" R)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("_applC" ("_position" snd)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r))))
###                 ("_tuple_arg" ("_position" n)))
###               ("_applC" ("_position" derivable) ("_position" R))))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>MultiSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>MultiSequents.extRules" ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>MultiSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("\<^const>MultiSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>MultiSequents.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>MultiSequents.extRules"
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>MultiSequents.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>MultiSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>MultiSequents.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member" ("_position" r)
###         ("\<^const>MultiSequents.extRules"
###           ("\<^const>HOL.conj" ("_position" R)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("_applC" ("_position" snd)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r))))
###                 ("_tuple_arg" ("_position" n)))
###               ("_applC" ("_position" derivable) ("_position" R))))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>MultiSequents.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>MultiSequents.extRules" ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>MultiSequents.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.MultiSequents"
### 2.971s elapsed time, 11.567s cpu time, 2.745s GC time
Proofs for inductive predicate(s) "leftPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rightPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "derivablep"
  Proving monotonicity ...
Proofs for inductive predicate(s) "derivable'p"
  Proving monotonicity ...
overloading
  invertible \<equiv> invertible ::
    'a sequent list * 'a sequent
    => ('a sequent list * 'a sequent) set => bool
  invertible_set \<equiv> invertible_set ::
    ('a sequent list * 'a sequent) set => bool
### Ambiguous input (line 189 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 25 parse trees (10 displayed):
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("\<^const>SingleSuccedent.extRules"
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SingleSuccedent.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>SingleSuccedent.extRules"
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SingleSuccedent.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>SingleSuccedent.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SingleSuccedent.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member" ("_position" r)
###         ("\<^const>SingleSuccedent.extRules"
###           ("\<^const>HOL.conj" ("_position" R)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("_applC" ("_position" snd)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r))))
###                 ("_tuple_arg" ("_position" n)))
###               ("_applC" ("_position" derivable) ("_position" R))))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SingleSuccedent.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("_Ex_less_eq" ("_position" m) ("_position" n)
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###             ("\<^const>SingleSuccedent.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("\<^const>SingleSuccedent.extRules"
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SingleSuccedent.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>SingleSuccedent.extRules"
###         ("\<^const>HOL.conj"
###           ("\<^const>Set.member" ("_position" r) ("_position" R))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SingleSuccedent.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>SingleSuccedent.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("_applC" ("_position" snd)
###                 ("_applC" ("_position" extendRule)
###                   ("_cargs" ("_position" S) ("_position" r))))
###               ("_tuple_arg" ("_position" n)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SingleSuccedent.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member" ("_position" r)
###         ("\<^const>SingleSuccedent.extRules"
###           ("\<^const>HOL.conj" ("_position" R)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("_applC" ("_position" snd)
###                   ("_applC" ("_position" extendRule)
###                     ("_cargs" ("_position" S) ("_position" r))))
###                 ("_tuple_arg" ("_position" n)))
###               ("_applC" ("_position" derivable) ("_position" R))))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SingleSuccedent.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" invertible)
###     ("_cargs" ("_position" r) ("_position" R)))
###   ("\<^const>HOL.All_binder" ("_idts" ("_position" n) ("_position" S))
###     ("\<^const>HOL.implies"
###       ("\<^const>HOL.conj"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" extendRule)
###                 ("_cargs" ("_position" S) ("_position" r))))
###             ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
###       ("_Ball" ("_position" p)
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst)
###             ("_applC" ("_position" extendRule)
###               ("_cargs" ("_position" S) ("_position" r)))))
###         ("\<^const>SingleSuccedent.extRules"
###           ("_Ex_less_eq" ("_position" m) ("_position" n)
###             ("\<^const>Set.member"
###               ("_tuple" ("_position" p) ("_tuple_arg" ("_position" m)))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 259 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_applC" ("_position" At) ("_position" i)))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_applC" ("_position" At) ("_position" i)))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###           ("_applC" ("_position" At) ("_position" i)))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 276 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" C))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" C))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" C))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 371 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###     ("\<^const>SingleSuccedent.extRules" ("_position" R))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###       ("_position" R))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 382 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" E))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" E))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" E))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 385 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent"
###         ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###           ("_position" \<Gamma>'))
###         ("_position" E))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent"
###         ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###           ("_position" \<Gamma>'))
###         ("_position" E))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("_position" E))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 486 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" Em))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" Em))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" Em))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 489 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" C))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" C))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" C))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 609 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_applC" ("_position" Compound)
###           ("_cargs" ("_position" F) ("_position" Fs))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("_applC" ("_position" Compound)
###           ("_cargs" ("_position" F) ("_position" Fs))))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###           ("_applC" ("_position" Compound)
###             ("_cargs" ("_position" F) ("_position" Fs))))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 612 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("_position" E))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>SingleSuccedent.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("_position" E))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>SingleSuccedent.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("_position" E))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("_position" E))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>SingleSuccedent.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 782 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent"
###         ("\<^const>SingleSuccedent.multiset_plus" ("_position" \<Gamma>)
###           ("_applC" ("_position" Compound)
###             ("_cargs" ("_position" F) ("_position" Fs))))
###         ("_position" \<delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent"
###         ("\<^const>SingleSuccedent.multiset_plus" ("_position" \<Gamma>)
###           ("_applC" ("_position" Compound)
###             ("_cargs" ("_position" F) ("_position" Fs))))
###         ("_position" \<delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_plus" ("_position" \<Gamma>)
###             ("_applC" ("_position" Compound)
###               ("_cargs" ("_position" F) ("_position" Fs))))
###           ("_position" \<delta>))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 784 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("_position" \<delta>))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>SingleSuccedent.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("_position" \<delta>))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>SingleSuccedent.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("_position" \<delta>))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("_position" \<delta>))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>SingleSuccedent.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  antec :: "('a, 'b) sequent => ('a, 'b) form multiset"
consts
  succ :: "('a, 'b) sequent => ('a, 'b) form multiset"
consts
  mset :: "('a, 'b) sequent => ('a, 'b) form multiset"
consts
  seq_size :: "('a, 'b) sequent => nat"
overloading
  extend \<equiv> extend ::
    ('a, 'b) sequent => ('a, 'b) sequent => ('a, 'b) sequent
  extendRule \<equiv> extendRule ::
    ('a, 'b) sequent
    => ('a, 'b) sequent list * ('a, 'b) sequent
       => ('a, 'b) sequent list * ('a, 'b) sequent
  extendRule2 \<equiv> extendRule2 ::
    ('a, 'b) sequent
    => ('a, 'b) sequent
       => ('a, 'b) sequent list * ('a, 'b) sequent
          => ('a, 'b) sequent list * ('a, 'b) sequent
overloading
  uniqueConclusion \<equiv> uniqueConclusion ::
    (('a, 'b) sequent list * ('a, 'b) sequent) set => bool
  modaliseMultiset \<equiv> modaliseMultiset ::
    'a => ('b, 'a) form multiset => ('b, 'a) form multiset
Proofs for inductive predicate(s) "Axp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "upRulesp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "modRules2p"
  Proving monotonicity ...
Proofs for inductive predicate(s) "p_ep"
  Proving monotonicity ...
### Ambiguous input (line 1047 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 2 parse trees:
### ("\<^const>Pure.eq" ("\<^const>Set.supset" ("_position" p) ("_position" q))
###   ("_applC" ("_position" Compound)
###     ("_cargs" ("_position" imp)
###       ("_list" ("_args" ("_position" p) ("_position" q))))))
### ("\<^const>Pure.eq" ("\<^fixed>imp_form" ("_position" p) ("_position" q))
###   ("_applC" ("_position" Compound)
###     ("_cargs" ("_position" imp)
###       ("_list" ("_args" ("_position" p) ("_position" q))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1059 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("_args"
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>SingleSuccedent.multiset_abbrev"
###               ("\<^const>SingleSuccedent.imp_form" ("_position" A)
###                 ("_position" B)))
###             ("_position" A))
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>SingleSuccedent.multiset_abbrev" ("_position" B))
###             ("_position" Em))))
###       ("_tuple_arg"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_abbrev"
###             ("\<^const>SingleSuccedent.imp_form" ("_position" A)
###               ("_position" B)))
###           ("_position" Em))))
###     ("_position" g3ip)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("_args"
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>SingleSuccedent.multiset_abbrev"
###               ("\<^const>SingleSuccedent.imp_form" ("_position" A)
###                 ("_position" B)))
###             ("_position" A))
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>SingleSuccedent.multiset_abbrev" ("_position" B))
###             ("_position" Em))))
###       ("_tuple_arg"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_abbrev"
###             ("\<^const>Set.supset" ("_position" A) ("_position" B)))
###           ("_position" Em))))
###     ("_position" g3ip)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1060 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_abbrev" ("_position" A))
###           ("_position" B)))
###       ("_tuple_arg"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_empty")
###           ("\<^const>Set.supset" ("_position" A) ("_position" B)))))
###     ("_position" g3ip)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_abbrev" ("_position" A))
###           ("_position" B)))
###       ("_tuple_arg"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_empty")
###           ("\<^const>SingleSuccedent.imp_form" ("_position" A)
###             ("_position" B)))))
###     ("_position" g3ip)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "g3ipp"
overloading
  extendConc \<equiv> extendConc ::
    ('a, 'b) sequent
    => ('a, 'b) sequent list * ('a, 'b) sequent
       => ('a, 'b) sequent list * ('a, 'b) sequent
  Proving monotonicity ...
Proofs for inductive predicate(s) "extp"
  Proving monotonicity ...
### Ambiguous input (line 1077 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 6 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>Set.supset" ("_position" A) ("_position" B)))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules"
###         ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>SingleSuccedent.imp_form" ("_position" A)
###           ("_position" B)))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>SingleSuccedent.extRules"
###         ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>SingleSuccedent.imp_form" ("_position" A)
###             ("_position" B)))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>Set.supset" ("_position" A) ("_position" B)))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>SingleSuccedent.imp_form" ("_position" A)
###           ("_position" B)))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>SingleSuccedent.extRules"
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>Set.supset" ("_position" A) ("_position" B)))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1078 of "$AFP/SequentInvertibility/SingleSuccedent.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_plus" ("_position" \<Gamma>)
###             ("_position" A))
###           ("_position" B))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>SingleSuccedent.extRules"
###           ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>SingleSuccedent.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>SingleSuccedent.multiset_plus" ("_position" \<Gamma>)
###               ("_position" A))
###             ("_position" B))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>SingleSuccedent.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>SingleSuccedent.sequent.Sequent"
###             ("\<^const>SingleSuccedent.multiset_plus" ("_position" \<Gamma>)
###               ("_position" A))
###             ("_position" B))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>SingleSuccedent.sequent.Sequent"
###           ("\<^const>SingleSuccedent.multiset_plus" ("_position" \<Gamma>)
###             ("_position" A))
###           ("_position" B))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>SingleSuccedent.extRules"
###         ("_applC" ("_position" derivable)
###           ("\<^const>Set.union" ("_position" Ax) ("_position" g3ip)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.SingleSuccedent"
### 2.290s elapsed time, 8.250s cpu time, 1.225s GC time
Proofs for inductive predicate(s) "leftPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rightPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "derivablep"
  Proving monotonicity ...
### Ambiguous input (line 2263 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("\<^fixed>BOX_form"
###     ("_constrain" ("_position" p) ("_type_name" CDBD_form)))
###   ("_applC" ("_position" Modal)
###     ("_cargs" ("\<^const>ModalSequents.BD.BOX") ("_list" ("_position" p)))))
### ("\<^const>Pure.eq"
###   ("_applC" ("\<^const>ModalSequents.BD.BOX")
###     ("_constrain" ("_position" p) ("_type_name" CDBD_form)))
###   ("_applC" ("_position" Modal)
###     ("_cargs" ("\<^const>ModalSequents.BD.BOX") ("_list" ("_position" p)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2266 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("\<^fixed>DIAMOND_form"
###     ("_constrain" ("_position" p) ("_type_name" CDBD_form)))
###   ("_applC" ("_position" Modal)
###     ("_cargs" ("\<^const>ModalSequents.BD.DIAMOND")
###       ("_list" ("_position" p)))))
### ("\<^const>Pure.eq"
###   ("_applC" ("\<^const>ModalSequents.BD.DIAMOND")
###     ("_constrain" ("_position" p) ("_type_name" CDBD_form)))
###   ("_applC" ("_position" Modal)
###     ("_cargs" ("\<^const>ModalSequents.BD.DIAMOND")
###       ("_list" ("_position" p)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "g3upp"
  Proving monotonicity ...
### Ambiguous input (line 2296 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A))))
###       ("_tuple_arg"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev"
###             ("\<^const>ModalSequents.DIAMOND_form" ("_position" A))))))
###     ("_position" g3mod2)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A))))
###       ("_tuple_arg"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev"
###             ("_applC" ("\<^const>ModalSequents.BD.DIAMOND")
###               ("_position" A))))))
###     ("_position" g3mod2)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2297 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A))
###           ("\<^const>ModalSequents.multiset_empty")))
###       ("_tuple_arg"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_abbrev"
###             ("\<^const>ModalSequents.BOX_form" ("_position" A)))
###           ("\<^const>ModalSequents.multiset_empty"))))
###     ("_position" g3mod2)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A))
###           ("\<^const>ModalSequents.multiset_empty")))
###       ("_tuple_arg"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_abbrev"
###             ("_applC" ("\<^const>ModalSequents.BD.BOX") ("_position" A)))
###           ("\<^const>ModalSequents.multiset_empty"))))
###     ("_position" g3mod2)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "g3mod2p"
  Proving monotonicity ...
### Ambiguous input (line 2301 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A))))
###       ("_tuple_arg"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev"
###             ("\<^const>ModalSequents.BOX_form" ("_position" A))))))
###     ("_position" g3mod1)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A))))
###       ("_tuple_arg"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev"
###             ("_applC" ("\<^const>ModalSequents.BD.BOX") ("_position" A))))))
###     ("_position" g3mod1)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2302 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A))
###           ("\<^const>ModalSequents.multiset_empty")))
###       ("_tuple_arg"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_abbrev"
###             ("\<^const>ModalSequents.DIAMOND_form" ("_position" A)))
###           ("\<^const>ModalSequents.multiset_empty"))))
###     ("_position" g3mod1)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("_list"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A))
###           ("\<^const>ModalSequents.multiset_empty")))
###       ("_tuple_arg"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_abbrev"
###             ("_applC" ("\<^const>ModalSequents.BD.DIAMOND")
###               ("_position" A)))
###           ("\<^const>ModalSequents.multiset_empty"))))
###     ("_position" g3mod1)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "g3mod1p"
  Proving monotonicity ...
### Ambiguous input (line 2346 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" Ax)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rightPrincipal)
###           ("_cargs" ("_position" r)
###             ("_cargs"
###               ("_applC" ("\<^const>ModalSequents.BD.BOX") ("_position" A))
###               ("_position" R)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("\<^const>ModalSequents.sequent.Sequent"
###         ("\<^const>ModalSequents.multiset_empty")
###         ("\<^const>ModalSequents.multiset_abbrev" ("_position" A)))
###       ("_applC" ("_position" set)
###         ("_applC" ("_position" fst) ("_position" r))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" Ax)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rightPrincipal)
###           ("_cargs" ("_position" r)
###             ("_cargs" ("\<^const>ModalSequents.BOX_form" ("_position" A))
###               ("_position" R)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("\<^const>ModalSequents.sequent.Sequent"
###         ("\<^const>ModalSequents.multiset_empty")
###         ("\<^const>ModalSequents.multiset_abbrev" ("_position" A)))
###       ("_applC" ("_position" set)
###         ("_applC" ("_position" fst) ("_position" r))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2350 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" g3up)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rightPrincipal)
###           ("_cargs" ("_position" r)
###             ("_cargs"
###               ("_applC" ("\<^const>ModalSequents.BD.BOX") ("_position" A))
###               ("_position" R)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("\<^const>ModalSequents.sequent.Sequent"
###         ("\<^const>ModalSequents.multiset_empty")
###         ("\<^const>ModalSequents.multiset_abbrev" ("_position" A)))
###       ("_applC" ("_position" set)
###         ("_applC" ("_position" fst) ("_position" r))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" g3up)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rightPrincipal)
###           ("_cargs" ("_position" r)
###             ("_cargs" ("\<^const>ModalSequents.BOX_form" ("_position" A))
###               ("_position" R)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("\<^const>ModalSequents.sequent.Sequent"
###         ("\<^const>ModalSequents.multiset_empty")
###         ("\<^const>ModalSequents.multiset_abbrev" ("_position" A)))
###       ("_applC" ("_position" set)
###         ("_applC" ("_position" fst) ("_position" r))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2358 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rightPrincipal)
###     ("_cargs" ("_position" r)
###       ("_cargs" ("\<^const>ModalSequents.BOX_form" ("_position" A))
###         ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rightPrincipal)
###     ("_cargs" ("_position" r)
###       ("_cargs" ("_applC" ("\<^const>ModalSequents.BD.BOX") ("_position" A))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2375 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rightPrincipal)
###     ("_cargs" ("_position" r)
###       ("_cargs" ("\<^const>ModalSequents.BOX_form" ("_position" A))
###         ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" rightPrincipal)
###     ("_cargs" ("_position" r)
###       ("_cargs" ("_applC" ("\<^const>ModalSequents.BD.BOX") ("_position" A))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### length descr: 3
### length new_type_names: 2
### perm_empty_thms
### perm_append_thms
### perm_eq_thms
### Ambiguous input (line 2402 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" r) ("_position" R')
###     ("\<^const>HOL.implies"
###       ("_applC" ("_position" rightPrincipal)
###         ("_cargs" ("_position" r)
###           ("_cargs" ("\<^const>ModalSequents.BOX_form" ("_position" A))
###             ("_position" R'))))
###       ("\<^const>Set.member"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A)))
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst) ("_position" r)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" r) ("_position" R')
###     ("\<^const>HOL.implies"
###       ("_applC" ("_position" rightPrincipal)
###         ("_cargs" ("_position" r)
###           ("_cargs"
###             ("_applC" ("\<^const>ModalSequents.BD.BOX") ("_position" A))
###             ("_position" R'))))
###       ("\<^const>Set.member"
###         ("\<^const>ModalSequents.sequent.Sequent"
###           ("\<^const>ModalSequents.multiset_empty")
###           ("\<^const>ModalSequents.multiset_abbrev" ("_position" A)))
###         ("_applC" ("_position" set)
###           ("_applC" ("_position" fst) ("_position" r)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2419 of "$AFP/SequentInvertibility/ModalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>ModalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>ModalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>ModalSequents.BOX_form" ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("_applC" ("_position" ext)
###         ("_cargs" ("_position" R)
###           ("_cargs" ("_position" g3mod1)
###             ("_cargs" ("\<^const>ModalSequents.BD.BOX")
###               ("\<^const>ModalSequents.BD.DIAMOND"))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>ModalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>ModalSequents.multiset_plus" ("_position" \<Delta>)
###           ("_applC" ("\<^const>ModalSequents.BD.BOX") ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("_applC" ("_position" ext)
###         ("_cargs" ("_position" R)
###           ("_cargs" ("_position" g3mod1)
###             ("_cargs" ("\<^const>ModalSequents.BD.BOX")
###               ("\<^const>ModalSequents.BD.DIAMOND"))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### representing sets
### big_rep_name: form_Rep_form_list_Rep_set
Proofs for inductive predicate(s) "form_Rep_set", "form_list_Rep_set"
### theory "Draft.ModalSequents"
### 4.786s elapsed time, 15.986s cpu time, 2.467s GC time
### proving closure under permutation...
### defining type...
### prove that new types are in class pt_<name> ...
### prove that new types are in class cp_<name1>_<name2> ...
### proving finite support for the new datatype
### proving strong induction theorem ...
### defining recursion combinator ...
Proofs for inductive predicate(s) "form_form_list_rec_set_1", "form_form_list_rec_set_2"
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 == ?a1 ~= ?b1
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) == True
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 == ?a1 ~= ?b1
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) == True
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
consts
  antec :: "sequent => form multiset"
consts
  succ :: "sequent => form multiset"
consts
  mset :: "sequent => form multiset"
consts
  seq_size :: "sequent => nat"
consts
  set_of_seq :: "sequent => form set"
consts
  set_of_prem :: "sequent list => form set"
overloading
  extend \<equiv> extend :: sequent => sequent => sequent
  extendRule \<equiv> extendRule ::
    sequent => sequent list * sequent => sequent list * sequent
  uniqueConclusion \<equiv> uniqueConclusion ::
    (sequent list * sequent) set => bool
### Ambiguous input (line 90 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_position" A))
###     ("\<^const>NominalSequents.sequent.Sequent"
###       ("\<^const>NominalSequents.multiset_minus" ("_position" \<Gamma>)
###         ("_position" A))
###       ("\<^const>NominalSequents.multiset_minus" ("_position" \<Delta>)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>sequentMinus"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_position" A))
###     ("\<^const>NominalSequents.sequent.Sequent"
###       ("\<^const>NominalSequents.multiset_minus" ("_position" \<Gamma>)
###         ("_position" A))
###       ("\<^const>NominalSequents.multiset_minus" ("_position" \<Delta>)
###         ("_position" A)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  sequentMinus :: "sequent => form => sequent"
### Ambiguous input (line 93 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus" ("\<^const>List.list.Nil")
###       ("_position" A))
###     ("\<^const>List.list.Nil")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>NominalSequents.sequentMinus" ("\<^const>List.list.Nil")
###       ("_position" A))
###     ("\<^const>List.list.Nil")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>listMinus" ("\<^const>List.list.Nil") ("_position" A))
###     ("\<^const>List.list.Nil")))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 94 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 27 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>Groups.minus_class.minus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>NominalSequents.sequentMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>Groups.minus_class.minus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>listMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>Groups.minus_class.minus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^fixed>listMinus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>NominalSequents.sequentMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^fixed>listMinus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>listMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^fixed>listMinus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>NominalSequents.sequentMinus" ("_position" P)
###         ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>NominalSequents.sequentMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>NominalSequents.sequentMinus" ("_position" P)
###         ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>listMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>NominalSequents.sequentMinus" ("_position" P)
###         ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>Groups.minus_class.minus" ("_position" P) ("_position" A))
###       ("\<^fixed>listMinus" ("_position" Ps) ("_position" A)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  listMinus :: "sequent list => form => sequent list"
Proofs for inductive predicate(s) "Axp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "upRulesp"
  Proving monotonicity ...
### Ambiguous input (line 119 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###         ("\<^const>NominalSequents.multiset_abbrev"
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" ps)
###           ("\<^const>List.list.Nil")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Nominal.fresh" ("_position" x)
###             ("_applC" ("_position" set_of_prem)
###               ("\<^const>NominalSequents.sequentMinus" ("_position" ps)
###                 ("_position" A))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###       ("_position" provRules))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###         ("\<^const>NominalSequents.multiset_abbrev"
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" ps)
###           ("\<^const>List.list.Nil")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Nominal.fresh" ("_position" x)
###             ("_applC" ("_position" set_of_prem)
###               ("\<^const>NominalSequents.listMinus" ("_position" ps)
###                 ("_position" A))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###       ("_position" provRules))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###         ("\<^const>NominalSequents.multiset_abbrev"
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" ps)
###           ("\<^const>List.list.Nil")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Nominal.fresh" ("_position" x)
###             ("_applC" ("_position" set_of_prem)
###               ("\<^const>Groups.minus_class.minus" ("_position" ps)
###                 ("_position" A))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###       ("_position" provRules))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "provRulesp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "nprovRulesp"
  Proving monotonicity ...
consts
  subst ::
    "NominalSequents.var
     => NominalSequents.var
        => NominalSequents.var list => NominalSequents.var list"
### Ambiguous input (line 157 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" At)
###         ("_cargs" ("_position" P) ("_position" xs))))
###     ("_applC" ("_position" At)
###       ("_cargs" ("_position" P)
###         ("\<^const>NominalSequents.subst" ("_position" z) ("_position" y)
###           ("_position" xs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" At)
###         ("_cargs" ("_position" P) ("_position" xs))))
###     ("_applC" ("_position" At)
###       ("_cargs" ("_position" P)
###         ("\<^const>NominalSequents.subst" ("_position" z) ("_position" y)
###           ("_position" xs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" At)
###         ("_cargs" ("_position" P) ("_position" xs))))
###     ("_applC" ("_position" At)
###       ("_cargs" ("_position" P)
###         ("\<^const>NominalSequents.subst" ("_position" z) ("_position" y)
###           ("_position" xs))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 158 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 9 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" A))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 159 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 9 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 160 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y) ("_position" ff))
###     ("_position" ff)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_position" ff))
###     ("_position" ff)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_position" ff))
###     ("_position" ff)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 161 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_position" FNil))
###     ("_position" FNil)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_position" FNil))
###     ("_position" FNil)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_position" FNil))
###     ("_position" FNil)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 162 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 27 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 177 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" multSubst) ("_position" \<Gamma>))
###   ("_Bex" ("_position" A)
###     ("_applC" ("_position" set_mset) ("_position" \<Gamma>))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" x) ("_idts" ("_position" y) ("_position" B)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_list" ("_args" ("_position" y) ("_position" x)))
###             ("_position" B))
###           ("_position" A))
###         ("\<^const>HOL.not_equal" ("_position" y) ("_position" x))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" multSubst) ("_position" \<Gamma>))
###   ("_Bex" ("_position" A)
###     ("_applC" ("_position" set_mset) ("_position" \<Gamma>))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" x) ("_idts" ("_position" y) ("_position" B)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("\<^const>NominalSequents.subst_form" ("_position" y)
###             ("_position" x) ("_position" B))
###           ("_position" A))
###         ("\<^const>HOL.not_equal" ("_position" y) ("_position" x))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" multSubst) ("_position" \<Gamma>))
###   ("_Bex" ("_position" A)
###     ("_applC" ("_position" set_mset) ("_position" \<Gamma>))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" x) ("_idts" ("_position" y) ("_position" B)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("\<^const>NominalSequents.subst_forms" ("_position" y)
###             ("_position" x) ("_position" B))
###           ("_position" A))
###         ("\<^const>HOL.not_equal" ("_position" y) ("_position" x))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 189 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" Ax)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" Ax)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" S) ("_position" r))
###           ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" Ax)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" Ax)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 190 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" upRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" upRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" S) ("_position" r))
###           ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" upRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" upRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 191 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" nprovRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" nprovRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" S) ("_position" r))
###           ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" nprovRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" nprovRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 192 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###         ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###           ("_position" provRules)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Nominal.fresh" ("_position" x)
###               ("_applC" ("_position" set_of_seq) ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###             ("_position" R)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###         ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###           ("_position" provRules)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Nominal.fresh" ("_position" x)
###               ("_applC" ("_position" set_of_seq) ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member"
###           ("_applC" ("_position" S)
###             ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c))))
###           ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###         ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###           ("_position" provRules)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Nominal.fresh" ("_position" x)
###               ("_applC" ("_position" set_of_seq) ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S)
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###         ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###           ("_position" provRules)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Nominal.fresh" ("_position" x)
###               ("_applC" ("_position" set_of_seq) ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S)
###             ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "extRulesp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "leftPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rightPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "derivablep"
  Proving monotonicity ...
### Ambiguous input (line 265 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 282 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 344 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder"
###     ("_idts" ("_position" F) ("_idts" ("_position" x) ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.disj"
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_empty")
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))
###             ("\<^const>NominalSequents.multiset_empty"))))
###       ("\<^const>Nominal.fresh" ("_position" x)
###         ("_applC" ("_position" set_of_prem)
###           ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###             ("_position" A)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder"
###     ("_idts" ("_position" F) ("_idts" ("_position" x) ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.disj"
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_empty")
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))
###             ("\<^const>NominalSequents.multiset_empty"))))
###       ("\<^const>Nominal.fresh" ("_position" x)
###         ("_applC" ("_position" set_of_prem)
###           ("\<^const>NominalSequents.listMinus" ("_position" Ps)
###             ("_position" A)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder"
###     ("_idts" ("_position" F) ("_idts" ("_position" x) ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.disj"
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_empty")
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))
###             ("\<^const>NominalSequents.multiset_empty"))))
###       ("\<^const>Nominal.fresh" ("_position" x)
###         ("_applC" ("_position" set_of_prem)
###           ("\<^const>NominalSequents.sequentMinus" ("_position" Ps)
###             ("_position" A)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 477 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.subst_forms" ("_position" y)
###         ("_position" x) ("_position" A))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" A)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.subst_form" ("_position" y) ("_position" x)
###         ("_position" A))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" A)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" y) ("_position" x)))
###         ("_position" A))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" A)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 477 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" As)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.subst_forms" ("_position" y)
###         ("_position" x) ("_position" As))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" As)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" As)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.subst_form" ("_position" y) ("_position" x)
###         ("_position" As))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" As)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" As)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" y) ("_position" x)))
###         ("_position" As))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" As)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 515 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" x))
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_position" A))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" y)
###         ("_applC" ("_list" ("_args" ("_position" y) ("_position" x)))
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" x))
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_position" A))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" y)
###         ("\<^const>NominalSequents.subst_form" ("_position" y)
###           ("_position" x) ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" x))
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_position" A))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" y)
###         ("\<^const>NominalSequents.subst_forms" ("_position" y)
###           ("_position" x) ("_position" A))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 534 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" extendRule)
###     ("_cargs" ("_position" S)
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" extendRule)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member" ("_applC" ("_position" S) ("_position" r))
###         ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S) ("_position" r)))
###     ("\<^const>NominalSequents.extRules" ("_position" R))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S) ("_position" r)))
###       ("_position" R))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 590 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###     ("\<^const>NominalSequents.extRules" ("_position" R))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###       ("_position" R))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 604 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 20 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>)
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Delta>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>NominalSequents.extRules" ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>NominalSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>NominalSequents.extRules"
###       ("_All_less" ("_position" m) ("_position" n)
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))))
###     ("\<^const>HOL.implies"
###       ("_Ball" ("_position" r') ("_position" R)
###         ("\<^const>HOL.implies"
###           ("_applC" ("_position" rightPrincipal)
###             ("_cargs" ("_position" r')
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A))))
###           ("\<^const>Set.member"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>') ("_position" \<Delta>'))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" fst) ("_position" r'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###         ("_Ex_less_eq" ("_position" m') ("_position" m)
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                   ("_position" \<Gamma>'))
###                 ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                   ("_position" \<Delta>')))
###               ("_tuple_arg" ("_position" m')))
###             ("\<^const>NominalSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.implies"
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("\<^const>HOL.implies"
###         ("_Ball" ("_position" r') ("_position" R)
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" rightPrincipal)
###               ("_cargs" ("_position" r')
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("\<^const>Set.member"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>') ("_position" \<Delta>'))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst) ("_position" r'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###           ("_Ex_less_eq" ("_position" m') ("_position" m)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                     ("_position" \<Gamma>'))
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                     ("_position" \<Delta>')))
###                 ("_tuple_arg" ("_position" m')))
###               ("\<^const>NominalSequents.extRules"
###                 ("_applC" ("_position" derivable) ("_position" R))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>)
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Delta>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("_tuple_arg" ("_position" m)))
###           ("\<^const>NominalSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>)
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Delta>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>NominalSequents.extRules" ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>NominalSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>NominalSequents.extRules"
###       ("_All_less" ("_position" m) ("_position" n)
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))))
###     ("\<^const>HOL.implies"
###       ("_Ball" ("_position" r') ("_position" R)
###         ("\<^const>HOL.implies"
###           ("_applC" ("_position" rightPrincipal)
###             ("_cargs" ("_position" r')
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A))))
###           ("\<^const>Set.member"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>') ("_position" \<Delta>'))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" fst) ("_position" r'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###         ("_Ex_less_eq" ("_position" m') ("_position" m)
###           ("\<^const>NominalSequents.extRules"
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                     ("_position" \<Gamma>'))
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                     ("_position" \<Delta>')))
###                 ("_tuple_arg" ("_position" m')))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.implies"
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("\<^const>HOL.implies"
###         ("_Ball" ("_position" r') ("_position" R)
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" rightPrincipal)
###               ("_cargs" ("_position" r')
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("\<^const>Set.member"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>') ("_position" \<Delta>'))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst) ("_position" r'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###           ("_Ex_less_eq" ("_position" m') ("_position" m)
###             ("\<^const>NominalSequents.extRules"
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("_applC" ("_position" derivable) ("_position" R))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>)
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Delta>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("_tuple_arg" ("_position" m)))
###           ("\<^const>NominalSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 608 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###             ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###               ("_position" x) ("_position" A))))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 614 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>NominalSequents.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###       ("_Ex_less_eq" ("_position" n) ("_position" n')
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("\<^const>NominalSequents.extRules"
###       ("_Ex_less_eq" ("_position" n) ("_position" n')
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###         ("\<^const>NominalSequents.extRules"
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 616 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>NominalSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>NominalSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 802 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 20 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A)))
###               ("_position" \<Delta>))
###             ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>NominalSequents.extRules" ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>NominalSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>NominalSequents.extRules"
###       ("_All_less" ("_position" m) ("_position" n)
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))))
###     ("\<^const>HOL.implies"
###       ("_Ball" ("_position" r') ("_position" R)
###         ("\<^const>HOL.implies"
###           ("_applC" ("_position" leftPrincipal)
###             ("_cargs" ("_position" r')
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A))))
###           ("\<^const>Set.member"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>') ("_position" \<Delta>'))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" fst) ("_position" r'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###         ("_Ex_less_eq" ("_position" m') ("_position" m)
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                   ("_position" \<Gamma>'))
###                 ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                   ("_position" \<Delta>')))
###               ("_tuple_arg" ("_position" m')))
###             ("\<^const>NominalSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.implies"
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("\<^const>HOL.implies"
###         ("_Ball" ("_position" r') ("_position" R)
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" leftPrincipal)
###               ("_cargs" ("_position" r')
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("\<^const>Set.member"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>') ("_position" \<Delta>'))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst) ("_position" r'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###           ("_Ex_less_eq" ("_position" m') ("_position" m)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                     ("_position" \<Gamma>'))
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                     ("_position" \<Delta>')))
###                 ("_tuple_arg" ("_position" m')))
###               ("\<^const>NominalSequents.extRules"
###                 ("_applC" ("_position" derivable) ("_position" R))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A)))
###               ("_position" \<Delta>))
###             ("_tuple_arg" ("_position" m)))
###           ("\<^const>NominalSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A)))
###               ("_position" \<Delta>))
###             ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>NominalSequents.extRules" ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>NominalSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>NominalSequents.extRules"
###       ("_All_less" ("_position" m) ("_position" n)
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))))
###     ("\<^const>HOL.implies"
###       ("_Ball" ("_position" r') ("_position" R)
###         ("\<^const>HOL.implies"
###           ("_applC" ("_position" leftPrincipal)
###             ("_cargs" ("_position" r')
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A))))
###           ("\<^const>Set.member"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>') ("_position" \<Delta>'))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" fst) ("_position" r'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###         ("_Ex_less_eq" ("_position" m') ("_position" m)
###           ("\<^const>NominalSequents.extRules"
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                     ("_position" \<Gamma>'))
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                     ("_position" \<Delta>')))
###                 ("_tuple_arg" ("_position" m')))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.implies"
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("\<^const>HOL.implies"
###         ("_Ball" ("_position" r') ("_position" R)
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" leftPrincipal)
###               ("_cargs" ("_position" r')
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("\<^const>Set.member"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>') ("_position" \<Delta>'))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst) ("_position" r'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###           ("_Ex_less_eq" ("_position" m') ("_position" m)
###             ("\<^const>NominalSequents.extRules"
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("_applC" ("_position" derivable) ("_position" R))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A)))
###               ("_position" \<Delta>))
###             ("_tuple_arg" ("_position" m)))
###           ("\<^const>NominalSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 806 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent"
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent"
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###             ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###               ("_position" x) ("_position" A)))
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 812 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>NominalSequents.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###       ("_Ex_less_eq" ("_position" n) ("_position" n')
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("\<^const>NominalSequents.extRules"
###       ("_Ex_less_eq" ("_position" n) ("_position" n')
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###         ("\<^const>NominalSequents.extRules"
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 814 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>NominalSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>NominalSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1002 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###             ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###               ("_position" x) ("_position" A))))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1005 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>NominalSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>NominalSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1212 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent"
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent"
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###             ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###               ("_position" x) ("_position" A)))
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1215 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>NominalSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>NominalSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.NominalSequents"
### 3.902s elapsed time, 9.451s cpu time, 1.530s GC time
Loading theory "Draft.SequentInvertibility" (required by "Draft.SequentInvertibilityMoreTemplates")
### theory "Draft.SequentInvertibility"
### 0.694s elapsed time, 0.860s cpu time, 0.197s GC time
Loading theory "Draft.SequentInvertibilityMoreTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.SequentInvertibilityMoreTemplates"
### 0.647s elapsed time, 0.920s cpu time, 0.159s GC time
val it = (): unit
