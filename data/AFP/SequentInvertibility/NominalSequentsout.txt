Loading theory "HOL-Library.Infinite_Set" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.NominalSequents" via "HOL-Nominal.Nominal")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Cancellation" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.NominalSequents" via "HOL-Library.Multiset")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "HOL-Library.Function_Algebras"
### 0.127s elapsed time, 0.530s cpu time, 0.050s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.NominalSequents" via "HOL-Nominal.Nominal")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  enumerate :: "'a set => nat => 'a"
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Infinite_Set"
### 0.311s elapsed time, 1.247s cpu time, 0.124s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
### theory "HOL-Library.Nat_Bijection"
### 0.338s elapsed time, 1.355s cpu time, 0.124s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.ExtrEqs")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.422s elapsed time, 1.698s cpu time, 0.124s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.NominalSequents")
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.395s elapsed time, 1.548s cpu time, 0.163s GC time
Loading theory "HOL-Nominal.Nominal" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.NominalSequents")
### theory "HOL-Library.Set_Algebras"
### 0.233s elapsed time, 0.922s cpu time, 0.088s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  flat :: "'a list stream => 'a stream"
consts
  right :: "'a tree => 'a tree"
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Stream"
### 1.165s elapsed time, 4.392s cpu time, 0.997s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
overloading
  perm_fun \<equiv> perm :: ('x * 'x) list => ('a => 'b) => 'a => 'b
  perm_bool \<equiv> perm :: ('x * 'x) list => bool => bool
  perm_set \<equiv> perm :: ('x * 'x) list => 'a set => 'a set
  perm_unit \<equiv> perm :: ('x * 'x) list => unit => unit
  perm_prod \<equiv> perm :: ('x * 'x) list => 'a * 'b => 'a * 'b
  perm_list \<equiv> perm :: ('x * 'x) list => 'a list => 'a list
  perm_option \<equiv> perm :: ('x * 'x) list => 'a option => 'a option
  perm_char \<equiv> perm :: ('x * 'x) list => char => char
  perm_nat \<equiv> perm :: ('x * 'x) list => nat => nat
  perm_int \<equiv> perm :: ('x * 'x) list => int => int
  perm_noption \<equiv> perm :: ('x * 'x) list => 'a noption => 'a noption
  perm_nprod \<equiv> perm ::
    ('x * 'x) list => ('a, 'b) nprod => ('a, 'b) nprod
consts
  perm_unit :: "('x * 'x) list => unit => unit"
consts
  perm_prod :: "('x * 'x) list => 'a * 'b => 'a * 'b"
consts
  perm_list :: "('x * 'x) list => 'a list => 'a list"
consts
  perm_option :: "('x * 'x) list => 'a option => 'a option"
consts
  perm_noption :: "('x * 'x) list => 'a noption => 'a noption"
consts
  perm_nprod :: "('x * 'x) list => ('a, 'b) nprod => ('a, 'b) nprod"
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
Found termination order: "size <*mlex*> {}"
val mksimps_pairs =
   [("Nominal.fresh",
     ["?a \<sharp> (?x, ?y) ==> ?a \<sharp> ?x",
      "?a \<sharp> (?x, ?y) ==> ?a \<sharp> ?y"]),
    ("Set.Ball", ["[| ALL x:?A. ?P x; ?x : ?A |] ==> ?P ?x"]),
    ("HOL.implies", ["[| ?P --> ?Q; ?P |] ==> ?Q"]),
    ("HOL.conj", ["?P & ?Q ==> ?P", "?P & ?Q ==> ?Q"]),
    ("HOL.All", ["ALL x. ?P x ==> ?P ?x"]), ("HOL.True", []),
    ("HOL.False", []),
    ("HOL.If",
     ["if ?P1 then ?Q1 else ?R1 ==> (?P1 --> ?Q1) & (~ ?P1 --> ?R1)"])]:
   (string * thm list) list
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  mset :: "'a list => 'a multiset"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.BigO"
### 1.184s elapsed time, 4.470s cpu time, 1.421s GC time
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
Found termination order: "size <*mlex*> {}"
overloading
  fresh_star_set \<equiv> fresh_star :: 'b set => 'a => bool
overloading
  frsh_star_list \<equiv> fresh_star :: 'b list => 'a => bool
### theory "HOL-Library.Tree"
### 2.584s elapsed time, 9.399s cpu time, 2.484s GC time
Loading theory "Draft.Templates" (required by "Draft.NominalSequentsMoreTemplates" via "Draft.ExtrEqs")
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.087s elapsed time, 0.277s cpu time, 0.092s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.NominalSequentsMoreTemplates")
Proofs for inductive predicate(s) "ABS_setp"
  Proving monotonicity ...
### ML warning (line 73 of "~~/src/HOL/Nominal/nominal_thmdecls.ML"):
### Pattern is not exhaustive.
### ML warning (line 104 of "~~/src/HOL/Nominal/nominal_thmdecls.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 102 of "~~/src/HOL/Nominal/nominal_thmdecls.ML"):
### Value identifier (typrm) has not been referenced.
### ML warning (line 149 of "~~/src/HOL/Nominal/nominal_thmdecls.ML"):
### Value identifier (typrm) has not been referenced.
signature NOMINAL_THMDECLS =
  sig
    val eqvt_add: attribute
    val eqvt_del: attribute
    val eqvt_force_add: attribute
    val eqvt_force_del: attribute
    val get_eqvt_thms: Proof.context -> thm list
    val nominal_eqvt_debug: bool Config.T
    val setup: theory -> theory
  end
structure NominalThmDecls: NOMINAL_THMDECLS
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.934s elapsed time, 2.951s cpu time, 1.219s GC time
### ML warning (line 132 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (prems) has not been referenced.
### ML warning (line 171 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (swap_eqs) has not been referenced.
### ML warning (line 205 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (prm_eqs) has not been referenced.
### ML warning (line 241 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (perm_defs) has not been referenced.
### ML warning (line 263 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 322 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 369 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 368 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (fs_inst_thms) has not been referenced.
### ML warning (line 416 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 417 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 453 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 454 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 636 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (cp_bool_inst) has not been referenced.
### ML warning (line 751 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (supp_def) has not been referenced.
### ML warning (line 893 of "~~/src/HOL/Nominal/nominal_atoms.ML"):
### Value identifier (inst_pt_pt_at_cp) has not been referenced.
signature NOMINAL_ATOMS =
  sig
    val at_inst_of: theory -> string -> thm
    type atom_info
    val atoms_of: theory -> string list
    val cp_class_of: theory -> string -> string -> string
    val cp_inst_of: theory -> string -> string -> thm
    val create_nom_typedecls: string list -> theory -> theory
    val dj_thm_of: theory -> string -> string -> thm
    val fs_class_of: theory -> string -> string
    val get_atom_info: theory -> string -> atom_info option
    val get_atom_infos: theory -> atom_info Symtab.table
    val mk_permT: typ -> typ
    val pt_class_of: theory -> string -> string
    val pt_inst_of: theory -> string -> thm
    val the_atom_info: theory -> string -> atom_info
  end
structure NominalAtoms: NOMINAL_ATOMS
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
### ML warning (line 104 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 104 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (pi) has not been referenced.
### ML warning (line 120 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 132 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (pi) has not been referenced.
### ML warning (line 291 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 290 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 289 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 312 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Pattern is not exhaustive.
### ML warning (line 356 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Pattern is not exhaustive.
### ML warning (line 376 of "~~/src/HOL/Nominal/nominal_permeq.ML"):
### Value identifier (eqvt_simp_tac) has not been referenced.
signature NOMINAL_PERMEQ =
  sig
    val finite_guess_meth: (Proof.context -> Proof.method) context_parser
    val finite_guess_meth_debug:
       (Proof.context -> Proof.method) context_parser
    val finite_guess_tac: Proof.context -> int -> tactic
    val fresh_guess_meth: (Proof.context -> Proof.method) context_parser
    val fresh_guess_meth_debug:
       (Proof.context -> Proof.method) context_parser
    val fresh_guess_tac: Proof.context -> int -> tactic
    val perm_extend_simp_meth:
       (Proof.context -> Proof.method) context_parser
    val perm_extend_simp_meth_debug:
       (Proof.context -> Proof.method) context_parser
    val perm_extend_simp_tac: Proof.context -> int -> tactic
    val perm_simp_meth: (Proof.context -> Proof.method) context_parser
    val perm_simp_meth_debug: (Proof.context -> Proof.method) context_parser
    val perm_simp_tac: Proof.context -> int -> tactic
    val perm_simproc_app: simproc
    val perm_simproc_fun: simproc
    val supports_meth: (Proof.context -> Proof.method) context_parser
    val supports_meth_debug: (Proof.context -> Proof.method) context_parser
    val supports_tac: Proof.context -> int -> tactic
  end
structure NominalPermeq: NOMINAL_PERMEQ
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
### ML warning (line 94 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 89 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 88 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (j) has not been referenced.
### ML warning (line 137 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 139 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 150 of "~~/src/HOL/Nominal/nominal_fresh_fun.ML"):
### Value identifier (i) has not been referenced.
val gen_res_inst_tac_term = fn:
   Proof.context ->
     ((typ * ctyp) list -> (term * cterm) list -> thm -> thm) ->
       (typ * typ) list ->
         (term * term) list -> bool -> thm -> int -> thm -> thm Seq.seq
val res_inst_tac_term = fn:
   Proof.context ->
     (typ * typ) list ->
       (term * term) list -> bool -> thm -> int -> thm -> thm Seq.seq
val res_inst_tac_term' = fn:
   Proof.context ->
     (term * term) list -> bool -> thm -> int -> thm -> thm Seq.seq
val cut_inst_tac_term' = fn:
   Proof.context -> (term * term) list -> thm -> int -> thm -> thm Seq.seq
val get_dyn_thm = fn: theory -> xstring -> string -> thm
val at_exists_fresh' =
   "[| at TYPE(?'x); finite (supp ?x) |] ==> EX c. c \<sharp> ?x": thm
val fresh_fun_app' =
   "[| pt TYPE(?'a) TYPE(?'x); at TYPE(?'x); finite (supp ?h);
       ?a \<sharp> ?h; ?a \<sharp> ?h ?a |]
    ==> fresh_fun ?h = ?h ?a":
   thm
val fresh_prod = "?a \<sharp> (?x, ?y) = (?a \<sharp> ?x & ?a \<sharp> ?y)":
   thm
val generate_fresh_tac = fn: Proof.context -> string -> tactic
val get_inner_fresh_fun = fn: term -> string option
val generate_fresh_fun_tac = fn: Proof.context -> tactic
val search_fun = fn: EqSubst.searchinfo -> term -> EqSubst.match Seq.seq
val search_fun_asm = fn:
   EqSubst.searchinfo -> int -> term -> EqSubst.match EqSubst.skipseq
val subst_inner_tac = fn: Proof.context -> thm -> int -> thm -> thm Seq.seq
val subst_inner_asm_tac_aux = fn:
   int -> Proof.context -> thm -> int -> tactic
val subst_inner_asm_tac = fn: Proof.context -> thm -> int -> tactic
val fresh_fun_tac = fn: Proof.context -> bool -> int -> tactic
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
### theory "HOL-Library.Multiset"
### 4.335s elapsed time, 14.369s cpu time, 4.075s GC time
### ML warning (line 62 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (put_nominal_datatypes) has not been referenced.
### ML warning (line 89 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 93 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 101 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 183 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (constrs) has not been referenced.
### ML warning (line 183 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (tvs) has not been referenced.
### ML warning (line 185 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (cargs) has not been referenced.
### ML warning (line 189 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (rps) has not been referenced.
### ML warning (line 197 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (mx) has not been referenced.
### ML warning (line 199 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (mx) has not been referenced.
### ML warning (line 202 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (new_type_names') has not been referenced.
### ML warning (line 257 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (perm_simps) has not been referenced.
### ML warning (line 277 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 278 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 278 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (T1) has not been referenced.
### ML warning (line 316 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (at_pt_inst) has not been referenced.
### ML warning (line 441 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (perm_thmss) has not been referenced.
### ML warning (line 474 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 553 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 692 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 708 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 711 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 744 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (full_new_type_names) has not been referenced.
### ML warning (line 780 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 829 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 830 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 850 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (dist_rewrites) has not been referenced.
### ML warning (line 1137 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1156 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 1162 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (xss) has not been referenced.
### ML warning (line 1213 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (induct) has not been referenced.
### ML warning (line 1216 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1228 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (induct') has not been referenced.
### ML warning (line 1245 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1247 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1269 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1280 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1312 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (prems2) has not been referenced.
### ML warning (line 1334 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1366 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1400 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1439 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1465 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 1464 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (rs) has not been referenced.
### ML warning (line 1645 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1649 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1662 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1699 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1717 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1773 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (asms) has not been referenced.
### ML warning (line 1775 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1777 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1778 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1780 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1786 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1874 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1875 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1881 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1909 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1926 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 1932 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1949 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1963 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 1988 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 2055 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 2057 of "~~/src/HOL/Nominal/nominal_datatype.ML"):
### Matches are not exhaustive.
signature NOMINAL_DATATYPE =
  sig
    type descr
    val fresh_const: typ -> typ -> term
    val fresh_star_const: typ -> typ -> term
    val get_nominal_datatype:
       theory -> string -> nominal_datatype_info option
    val get_nominal_datatypes: theory -> nominal_datatype_info Symtab.table
    val mk_not_sym: thm list -> thm list
    val mk_perm: typ list -> term -> term -> term
    val nominal_datatype:
       Old_Datatype_Aux.config -> Old_Datatype.spec list -> theory -> theory
    val nominal_datatype_cmd:
       Old_Datatype_Aux.config ->
         Old_Datatype.spec_cmd list -> theory -> theory
    type nominal_datatype_info
    val perm_of_pair: term * term -> term
    val perm_simproc: simproc
  end
structure NominalDatatype: NOMINAL_DATATYPE
### ML warning (line 144 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Matches are not exhaustive.
### ML warning (line 155 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (rs) has not been referenced.
### ML warning (line 155 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (ls) has not been referenced.
### ML warning (line 173 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 204 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (tname) has not been referenced.
### ML warning (line 213 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 223 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (dt_info) has not been referenced.
### ML warning (line 233 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 232 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 248 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 287 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 289 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 290 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 291 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
### ML warning (line 292 of "~~/src/HOL/Nominal/nominal_primrec.ML"):
### Pattern is not exhaustive.
signature NOMINAL_PRIMREC =
  sig
    val primrec:
       term list option ->
         term option ->
           (binding * typ option * mixfix) list ->
             (binding * typ option * mixfix) list ->
               Specification.multi_specs -> local_theory -> Proof.state
    val primrec_cmd:
       string list option ->
         string option ->
           (binding * string option * mixfix) list ->
             (binding * string option * mixfix) list ->
               Specification.multi_specs_cmd -> local_theory -> Proof.state
  end
structure NominalPrimrec: NOMINAL_PRIMREC
### ML warning (line 74 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 74 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 63 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 64 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 83 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 83 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 82 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (names) has not been referenced.
### ML warning (line 94 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 107 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern 3 is redundant.
### ML warning (line 121 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 121 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (s') has not been referenced.
### ML warning (line 207 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 213 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 306 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 371 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 420 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (name) has not been referenced.
### ML warning (line 422 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 423 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 437 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 451 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Value identifier (prem) has not been referenced.
### ML warning (line 478 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 574 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 623 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 635 of "~~/src/HOL/Nominal/nominal_inductive.ML"):
### Pattern is not exhaustive.
signature NOMINAL_INDUCTIVE =
  sig
    val prove_eqvt: string -> string list -> local_theory -> local_theory
    val prove_strong_ind:
       string -> (string * string list) list -> local_theory -> Proof.state
  end
structure NominalInductive: NOMINAL_INDUCTIVE
### ML warning (line 56 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (transp) has not been referenced.
### ML warning (line 79 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 79 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 67 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 68 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 88 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 88 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 87 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Matches are not exhaustive.
### ML warning (line 107 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (names) has not been referenced.
### ML warning (line 99 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 112 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern 3 is redundant.
### ML warning (line 126 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 126 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (s') has not been referenced.
### ML warning (line 161 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (ind_params) has not been referenced.
### ML warning (line 163 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (elims) has not been referenced.
### ML warning (line 194 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Matches are not exhaustive.
### ML warning (line 233 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 239 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Matches are not exhaustive.
### ML warning (line 329 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 337 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 341 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
### ML warning (line 370 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (pi_sets) has not been referenced.
### ML warning (line 462 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (induct_cases') has not been referenced.
### ML warning (line 465 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Value identifier (thsss) has not been referenced.
### ML warning (line 479 of "~~/src/HOL/Nominal/nominal_inductive2.ML"):
### Pattern is not exhaustive.
signature NOMINAL_INDUCTIVE2 =
  sig
    val prove_strong_ind:
       string ->
         string option ->
           (string * string list) list -> local_theory -> Proof.state
  end
structure NominalInductive2: NOMINAL_INDUCTIVE2
### ML warning (line 17 of "~~/src/HOL/Nominal/nominal_induct.ML"):
### Value identifier (tupleT) has not been referenced.
### ML warning (line 48 of "~~/src/HOL/Nominal/nominal_induct.ML"):
### Pattern is not exhaustive.
structure NominalInduct:
  sig
    val nominal_induct_method:
       (Proof.context -> Proof.method) context_parser
    val nominal_induct_tac:
       bool ->
         (binding option * (term * bool)) option list list ->
           (string * typ) list ->
             (string * typ) list list ->
               thm list -> thm list -> int -> context_tactic
  end
### theory "HOL-Nominal.Nominal"
### 5.074s elapsed time, 15.083s cpu time, 4.229s GC time
Loading theory "Draft.NominalSequents" (required by "Draft.NominalSequentsMoreTemplates")
### length descr: 3
### length new_type_names: 2
### perm_empty_thms
### perm_append_thms
### perm_eq_thms
### representing sets
### big_rep_name: form_Rep_form_list_Rep_set
Proofs for inductive predicate(s) "form_Rep_set", "form_list_Rep_set"
### proving closure under permutation...
### defining type...
### prove that new types are in class pt_<name> ...
### prove that new types are in class cp_<name1>_<name2> ...
### proving finite support for the new datatype
### proving strong induction theorem ...
### defining recursion combinator ...
Proofs for inductive predicate(s) "form_form_list_rec_set_1", "form_form_list_rec_set_2"
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 == ?a1 ~= ?b1
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) == True
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### ?a1 \<sharp> ?b1 == ?a1 ~= ?b1
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### finite (supp ?x1) == True
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
### step 1: obtaining fresh names
### step 2: as, bs, cs # K as ts, K bs us
### step 3: pi1 o (K as ts) = pi2 o (K bs us)
### step 4: pi1 o ts = pi2 o us
### step 5: pi1^-1 o pi2 o us = ts
### step 6: (ts, pi1^-1 o pi2 o vs) in rec_set
### step 7: pi1 o rs = pi2 o vs , rs = pi1^-1 o pi2 o vs
### step 8: as # rs
### step 9: as # fK as ts rs , bs # fK bs us vs
### step 10: cs # fK as ts rs , cs # fK bs us vs
### step 11: pi1 o (fK as ts rs) = pi2 o (fK bs us vs)
### final result
### finished!
consts
  antec :: "sequent => form multiset"
consts
  succ :: "sequent => form multiset"
consts
  mset :: "sequent => form multiset"
consts
  seq_size :: "sequent => nat"
consts
  set_of_seq :: "sequent => form set"
consts
  set_of_prem :: "sequent list => form set"
overloading
  extend \<equiv> extend :: sequent => sequent => sequent
  extendRule \<equiv> extendRule ::
    sequent => sequent list * sequent => sequent list * sequent
  uniqueConclusion \<equiv> uniqueConclusion ::
    (sequent list * sequent) set => bool
### Ambiguous input (line 90 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_position" A))
###     ("\<^const>NominalSequents.sequent.Sequent"
###       ("\<^const>NominalSequents.multiset_minus" ("_position" \<Gamma>)
###         ("_position" A))
###       ("\<^const>NominalSequents.multiset_minus" ("_position" \<Delta>)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>sequentMinus"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_position" A))
###     ("\<^const>NominalSequents.sequent.Sequent"
###       ("\<^const>NominalSequents.multiset_minus" ("_position" \<Gamma>)
###         ("_position" A))
###       ("\<^const>NominalSequents.multiset_minus" ("_position" \<Delta>)
###         ("_position" A)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  sequentMinus :: "sequent => form => sequent"
### Ambiguous input (line 93 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus" ("\<^const>List.list.Nil")
###       ("_position" A))
###     ("\<^const>List.list.Nil")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>NominalSequents.sequentMinus" ("\<^const>List.list.Nil")
###       ("_position" A))
###     ("\<^const>List.list.Nil")))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>listMinus" ("\<^const>List.list.Nil") ("_position" A))
###     ("\<^const>List.list.Nil")))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 94 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 27 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>Groups.minus_class.minus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>NominalSequents.sequentMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>Groups.minus_class.minus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>listMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>Groups.minus_class.minus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^fixed>listMinus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>NominalSequents.sequentMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^fixed>listMinus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>listMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^fixed>listMinus" ("_position" P) ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>NominalSequents.sequentMinus" ("_position" P)
###         ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>NominalSequents.sequentMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>NominalSequents.sequentMinus" ("_position" P)
###         ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>listMinus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>NominalSequents.sequentMinus" ("_position" P)
###         ("_position" A))
###       ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###         ("_position" A)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Groups.minus_class.minus"
###       ("\<^const>List.list.Cons" ("_position" P) ("_position" Ps))
###       ("_position" A))
###     ("\<^const>List.list.Cons"
###       ("\<^const>Groups.minus_class.minus" ("_position" P) ("_position" A))
###       ("\<^fixed>listMinus" ("_position" Ps) ("_position" A)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  listMinus :: "sequent list => form => sequent list"
Proofs for inductive predicate(s) "Axp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "upRulesp"
  Proving monotonicity ...
### Ambiguous input (line 119 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###         ("\<^const>NominalSequents.multiset_abbrev"
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" ps)
###           ("\<^const>List.list.Nil")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Nominal.fresh" ("_position" x)
###             ("_applC" ("_position" set_of_prem)
###               ("\<^const>NominalSequents.sequentMinus" ("_position" ps)
###                 ("_position" A))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###       ("_position" provRules))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###         ("\<^const>NominalSequents.multiset_abbrev"
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" ps)
###           ("\<^const>List.list.Nil")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Nominal.fresh" ("_position" x)
###             ("_applC" ("_position" set_of_prem)
###               ("\<^const>NominalSequents.listMinus" ("_position" ps)
###                 ("_position" A))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###       ("_position" provRules))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###         ("\<^const>NominalSequents.multiset_abbrev"
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" ps)
###           ("\<^const>List.list.Nil")))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Nominal.fresh" ("_position" x)
###             ("_applC" ("_position" set_of_prem)
###               ("\<^const>Groups.minus_class.minus" ("_position" ps)
###                 ("_position" A))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###       ("_position" provRules))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "provRulesp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "nprovRulesp"
  Proving monotonicity ...
consts
  subst ::
    "NominalSequents.var
     => NominalSequents.var
        => NominalSequents.var list => NominalSequents.var list"
### Ambiguous input (line 157 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" At)
###         ("_cargs" ("_position" P) ("_position" xs))))
###     ("_applC" ("_position" At)
###       ("_cargs" ("_position" P)
###         ("\<^const>NominalSequents.subst" ("_position" z) ("_position" y)
###           ("_position" xs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" At)
###         ("_cargs" ("_position" P) ("_position" xs))))
###     ("_applC" ("_position" At)
###       ("_cargs" ("_position" P)
###         ("\<^const>NominalSequents.subst" ("_position" z) ("_position" y)
###           ("_position" xs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" At)
###         ("_cargs" ("_position" P) ("_position" xs))))
###     ("_applC" ("_position" At)
###       ("_cargs" ("_position" P)
###         ("\<^const>NominalSequents.subst" ("_position" z) ("_position" y)
###           ("_position" xs))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 158 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 9 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" x)
###       ("_tuple" ("_position" z) ("_tuple_arg" ("_position" y)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###         ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###           ("_position" x) ("_position" A)))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" A))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 159 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 9 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" Cpd0)
###         ("_cargs" ("_position" F) ("_position" Fs))))
###     ("_applC" ("_position" Cpd0)
###       ("_cargs" ("_position" F)
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 160 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y) ("_position" ff))
###     ("_position" ff)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_position" ff))
###     ("_position" ff)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_position" ff))
###     ("_position" ff)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 161 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_position" FNil))
###     ("_position" FNil)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_position" FNil))
###     ("_position" FNil)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_position" FNil))
###     ("_position" FNil)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 162 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 27 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" f))
###         ("_applC" ("_list" ("_args" ("_position" z) ("_position" y)))
###           ("_position" Fs))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###       ("_applC" ("_position" FCons)
###         ("_cargs" ("_position" f) ("_position" Fs))))
###     ("_applC" ("_position" FCons)
###       ("_cargs"
###         ("\<^fixed>subst_form" ("_position" z) ("_position" y)
###           ("_position" f))
###         ("\<^fixed>subst_forms" ("_position" z) ("_position" y)
###           ("_position" Fs))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 177 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" multSubst) ("_position" \<Gamma>))
###   ("_Bex" ("_position" A)
###     ("_applC" ("_position" set_mset) ("_position" \<Gamma>))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" x) ("_idts" ("_position" y) ("_position" B)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_list" ("_args" ("_position" y) ("_position" x)))
###             ("_position" B))
###           ("_position" A))
###         ("\<^const>HOL.not_equal" ("_position" y) ("_position" x))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" multSubst) ("_position" \<Gamma>))
###   ("_Bex" ("_position" A)
###     ("_applC" ("_position" set_mset) ("_position" \<Gamma>))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" x) ("_idts" ("_position" y) ("_position" B)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("\<^const>NominalSequents.subst_form" ("_position" y)
###             ("_position" x) ("_position" B))
###           ("_position" A))
###         ("\<^const>HOL.not_equal" ("_position" y) ("_position" x))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" multSubst) ("_position" \<Gamma>))
###   ("_Bex" ("_position" A)
###     ("_applC" ("_position" set_mset) ("_position" \<Gamma>))
###     ("\<^const>HOL.Ex_binder"
###       ("_idts" ("_position" x) ("_idts" ("_position" y) ("_position" B)))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.eq"
###           ("\<^const>NominalSequents.subst_forms" ("_position" y)
###             ("_position" x) ("_position" B))
###           ("_position" A))
###         ("\<^const>HOL.not_equal" ("_position" y) ("_position" x))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 189 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" Ax)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" Ax)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" S) ("_position" r))
###           ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" Ax)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" Ax)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 190 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" upRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" upRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" S) ("_position" r))
###           ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" upRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" upRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 191 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" nprovRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member" ("_position" r) ("_position" R)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" nprovRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member" ("_applC" ("_position" S) ("_position" r))
###           ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" nprovRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S) ("_position" r)))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member" ("_position" r) ("_position" R)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member" ("_position" r) ("_position" nprovRules)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S) ("_position" r)))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 192 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###         ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###           ("_position" provRules)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Nominal.fresh" ("_position" x)
###               ("_applC" ("_position" set_of_seq) ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S)
###         ("\<^fixed>extRules"
###           ("\<^const>Set.member"
###             ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###             ("_position" R)))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###         ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###           ("_position" provRules)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Nominal.fresh" ("_position" x)
###               ("_applC" ("_position" set_of_seq) ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" extendRule)
###       ("\<^fixed>extRules"
###         ("\<^const>Set.member"
###           ("_applC" ("_position" S)
###             ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c))))
###           ("_position" R))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###         ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###           ("_position" provRules)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Nominal.fresh" ("_position" x)
###               ("_applC" ("_position" set_of_seq) ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S)
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))))
###       ("\<^fixed>extRules" ("_position" R)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###         ("_position" R)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))
###           ("_position" provRules)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq" ("_applC" ("_position" mset) ("_position" c))
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>Nominal.fresh" ("_position" x)
###               ("_applC" ("_position" set_of_seq) ("_position" S))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^fixed>extRules"
###       ("\<^const>Set.member"
###         ("_applC" ("_position" extendRule)
###           ("_cargs" ("_position" S)
###             ("_tuple" ("_position" ps) ("_tuple_arg" ("_position" c)))))
###         ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "extRulesp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "leftPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rightPrincipal"
  Proving monotonicity ...
Proofs for inductive predicate(s) "derivablep"
  Proving monotonicity ...
### Ambiguous input (line 265 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 282 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 344 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder"
###     ("_idts" ("_position" F) ("_idts" ("_position" x) ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.disj"
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_empty")
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))
###             ("\<^const>NominalSequents.multiset_empty"))))
###       ("\<^const>Nominal.fresh" ("_position" x)
###         ("_applC" ("_position" set_of_prem)
###           ("\<^const>Groups.minus_class.minus" ("_position" Ps)
###             ("_position" A)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder"
###     ("_idts" ("_position" F) ("_idts" ("_position" x) ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.disj"
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_empty")
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))
###             ("\<^const>NominalSequents.multiset_empty"))))
###       ("\<^const>Nominal.fresh" ("_position" x)
###         ("_applC" ("_position" set_of_prem)
###           ("\<^const>NominalSequents.listMinus" ("_position" Ps)
###             ("_position" A)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.Ex_binder"
###     ("_idts" ("_position" F) ("_idts" ("_position" x) ("_position" A)))
###     ("\<^const>HOL.conj"
###       ("\<^const>HOL.disj"
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_empty")
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))))
###         ("\<^const>HOL.eq" ("_position" C)
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>NominalSequents.multiset_abbrev"
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A)))
###             ("\<^const>NominalSequents.multiset_empty"))))
###       ("\<^const>Nominal.fresh" ("_position" x)
###         ("_applC" ("_position" set_of_prem)
###           ("\<^const>NominalSequents.sequentMinus" ("_position" Ps)
###             ("_position" A)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 477 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.subst_forms" ("_position" y)
###         ("_position" x) ("_position" A))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" A)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.subst_form" ("_position" y) ("_position" x)
###         ("_position" A))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" A)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" A)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" y) ("_position" x)))
###         ("_position" A))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" A)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 477 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" As)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.subst_forms" ("_position" y)
###         ("_position" x) ("_position" As))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" As)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" As)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.subst_form" ("_position" y) ("_position" x)
###         ("_position" As))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" As)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Nominal.fresh" ("_position" y) ("_position" As)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_list" ("_args" ("_position" y) ("_position" x)))
###         ("_position" As))
###       ("\<^const>Nominal.perm"
###         ("_list" ("_tuple" ("_position" y) ("_tuple_arg" ("_position" x))))
###         ("_position" As)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 515 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" x))
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_position" A))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" y)
###         ("_applC" ("_list" ("_args" ("_position" y) ("_position" x)))
###           ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" x))
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_position" A))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" y)
###         ("\<^const>NominalSequents.subst_form" ("_position" y)
###           ("_position" x) ("_position" A))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.conj"
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" x))
###       ("\<^const>Nominal.fresh" ("_position" y) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" x)
###         ("_position" A))
###       ("\<^const>NominalSequents.form.Cpd1" ("_position" F) ("_position" y)
###         ("\<^const>NominalSequents.subst_forms" ("_position" y)
###           ("_position" x) ("_position" A))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 534 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" extendRule)
###     ("_cargs" ("_position" S)
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>Set.member" ("_position" r) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_position" extendRule)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member" ("_applC" ("_position" S) ("_position" r))
###         ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_applC" ("_position" extendRule)
###       ("_cargs" ("_position" S) ("_position" r)))
###     ("\<^const>NominalSequents.extRules" ("_position" R))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_applC" ("_position" extendRule)
###         ("_cargs" ("_position" S) ("_position" r)))
###       ("_position" R))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 590 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###     ("\<^const>NominalSequents.extRules" ("_position" R))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple" ("_position" Ps) ("_tuple_arg" ("_position" C)))
###       ("_position" R))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 604 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 20 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>)
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Delta>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>NominalSequents.extRules" ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>NominalSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>NominalSequents.extRules"
###       ("_All_less" ("_position" m) ("_position" n)
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))))
###     ("\<^const>HOL.implies"
###       ("_Ball" ("_position" r') ("_position" R)
###         ("\<^const>HOL.implies"
###           ("_applC" ("_position" rightPrincipal)
###             ("_cargs" ("_position" r')
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A))))
###           ("\<^const>Set.member"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>') ("_position" \<Delta>'))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" fst) ("_position" r'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###         ("_Ex_less_eq" ("_position" m') ("_position" m)
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                   ("_position" \<Gamma>'))
###                 ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                   ("_position" \<Delta>')))
###               ("_tuple_arg" ("_position" m')))
###             ("\<^const>NominalSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.implies"
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("\<^const>HOL.implies"
###         ("_Ball" ("_position" r') ("_position" R)
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" rightPrincipal)
###               ("_cargs" ("_position" r')
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("\<^const>Set.member"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>') ("_position" \<Delta>'))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst) ("_position" r'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###           ("_Ex_less_eq" ("_position" m') ("_position" m)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                     ("_position" \<Gamma>'))
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                     ("_position" \<Delta>')))
###                 ("_tuple_arg" ("_position" m')))
###               ("\<^const>NominalSequents.extRules"
###                 ("_applC" ("_position" derivable) ("_position" R))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>)
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Delta>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("_tuple_arg" ("_position" m)))
###           ("\<^const>NominalSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>)
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Delta>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>NominalSequents.extRules" ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>NominalSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>NominalSequents.extRules"
###       ("_All_less" ("_position" m) ("_position" n)
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))))
###     ("\<^const>HOL.implies"
###       ("_Ball" ("_position" r') ("_position" R)
###         ("\<^const>HOL.implies"
###           ("_applC" ("_position" rightPrincipal)
###             ("_cargs" ("_position" r')
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A))))
###           ("\<^const>Set.member"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>') ("_position" \<Delta>'))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" fst) ("_position" r'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###         ("_Ex_less_eq" ("_position" m') ("_position" m)
###           ("\<^const>NominalSequents.extRules"
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                     ("_position" \<Gamma>'))
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                     ("_position" \<Delta>')))
###                 ("_tuple_arg" ("_position" m')))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.implies"
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Delta>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("\<^const>HOL.implies"
###         ("_Ball" ("_position" r') ("_position" R)
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" rightPrincipal)
###               ("_cargs" ("_position" r')
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("\<^const>Set.member"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>') ("_position" \<Delta>'))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst) ("_position" r'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###           ("_Ex_less_eq" ("_position" m') ("_position" m)
###             ("\<^const>NominalSequents.extRules"
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("_applC" ("_position" derivable) ("_position" R))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>)
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Delta>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("_tuple_arg" ("_position" m)))
###           ("\<^const>NominalSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" rightPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 608 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###             ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###               ("_position" x) ("_position" A))))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 614 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>NominalSequents.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###       ("_Ex_less_eq" ("_position" n) ("_position" n')
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("\<^const>NominalSequents.extRules"
###       ("_Ex_less_eq" ("_position" n) ("_position" n')
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###         ("\<^const>NominalSequents.extRules"
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 616 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>NominalSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>NominalSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 802 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 20 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A)))
###               ("_position" \<Delta>))
###             ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>NominalSequents.extRules" ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>NominalSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>NominalSequents.extRules"
###       ("_All_less" ("_position" m) ("_position" n)
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))))
###     ("\<^const>HOL.implies"
###       ("_Ball" ("_position" r') ("_position" R)
###         ("\<^const>HOL.implies"
###           ("_applC" ("_position" leftPrincipal)
###             ("_cargs" ("_position" r')
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A))))
###           ("\<^const>Set.member"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>') ("_position" \<Delta>'))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" fst) ("_position" r'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###         ("_Ex_less_eq" ("_position" m') ("_position" m)
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                   ("_position" \<Gamma>'))
###                 ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                   ("_position" \<Delta>')))
###               ("_tuple_arg" ("_position" m')))
###             ("\<^const>NominalSequents.extRules"
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.implies"
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("\<^const>HOL.implies"
###         ("_Ball" ("_position" r') ("_position" R)
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" leftPrincipal)
###               ("_cargs" ("_position" r')
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("\<^const>Set.member"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>') ("_position" \<Delta>'))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst) ("_position" r'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###           ("_Ex_less_eq" ("_position" m') ("_position" m)
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                     ("_position" \<Gamma>'))
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                     ("_position" \<Delta>')))
###                 ("_tuple_arg" ("_position" m')))
###               ("\<^const>NominalSequents.extRules"
###                 ("_applC" ("_position" derivable) ("_position" R))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A)))
###               ("_position" \<Delta>))
###             ("_tuple_arg" ("_position" m)))
###           ("\<^const>NominalSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("\<^const>NominalSequents.extRules"
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A)))
###               ("_position" \<Delta>))
###             ("_tuple_arg" ("_position" m)))
###           ("_applC" ("_position" derivable)
###             ("\<^const>NominalSequents.extRules" ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>NominalSequents.extRules"
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>NominalSequents.extRules"
###       ("_All_less" ("_position" m) ("_position" n)
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R))))))
###     ("\<^const>HOL.implies"
###       ("_Ball" ("_position" r') ("_position" R)
###         ("\<^const>HOL.implies"
###           ("_applC" ("_position" leftPrincipal)
###             ("_cargs" ("_position" r')
###               ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                 ("_position" x) ("_position" A))))
###           ("\<^const>Set.member"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("_position" \<Gamma>') ("_position" \<Delta>'))
###             ("_applC" ("_position" set)
###               ("_applC" ("_position" fst) ("_position" r'))))))
###       ("\<^const>HOL.implies"
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###         ("_Ex_less_eq" ("_position" m') ("_position" m)
###           ("\<^const>NominalSequents.extRules"
###             ("\<^const>Set.member"
###               ("_tuple"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###                     ("_position" \<Gamma>'))
###                   ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###                     ("_position" \<Delta>')))
###                 ("_tuple_arg" ("_position" m')))
###               ("_applC" ("_position" derivable) ("_position" R)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.implies"
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###           ("\<^const>Set.member"
###             ("_tuple"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("\<^const>NominalSequents.multiset_plus"
###                   ("_position" \<Gamma>)
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A)))
###                 ("_position" \<Delta>))
###               ("_tuple_arg" ("_position" m)))
###             ("_applC" ("_position" derivable) ("_position" R)))))
###       ("\<^const>HOL.implies"
###         ("_Ball" ("_position" r') ("_position" R)
###           ("\<^const>HOL.implies"
###             ("_applC" ("_position" leftPrincipal)
###               ("_cargs" ("_position" r')
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A))))
###             ("\<^const>Set.member"
###               ("\<^const>NominalSequents.sequent.Sequent"
###                 ("_position" \<Gamma>') ("_position" \<Delta>'))
###               ("_applC" ("_position" set)
###                 ("_applC" ("_position" fst) ("_position" r'))))))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.conj"
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###             ("\<^const>HOL.Not"
###               ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###           ("_Ex_less_eq" ("_position" m') ("_position" m)
###             ("\<^const>NominalSequents.extRules"
###               ("\<^const>Set.member"
###                 ("_tuple"
###                   ("\<^const>NominalSequents.sequent.Sequent"
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_position" \<Delta>) ("_position" \<Delta>')))
###                   ("_tuple_arg" ("_position" m')))
###                 ("_applC" ("_position" derivable) ("_position" R))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" m) ("_position" n)
###     ("\<^const>HOL.All_binder"
###       ("_idts" ("_position" \<Gamma>) ("_position" \<Delta>))
###       ("\<^const>HOL.implies"
###         ("\<^const>Set.member"
###           ("_tuple"
###             ("\<^const>NominalSequents.sequent.Sequent"
###               ("\<^const>NominalSequents.multiset_plus"
###                 ("_position" \<Gamma>)
###                 ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                   ("_position" x) ("_position" A)))
###               ("_position" \<Delta>))
###             ("_tuple_arg" ("_position" m)))
###           ("\<^const>NominalSequents.extRules"
###             ("_applC" ("_position" derivable) ("_position" R))))
###         ("\<^const>HOL.implies"
###           ("_Ball" ("_position" r') ("_position" R)
###             ("\<^const>HOL.implies"
###               ("_applC" ("_position" leftPrincipal)
###                 ("_cargs" ("_position" r')
###                   ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###                     ("_position" x) ("_position" A))))
###               ("\<^const>Set.member"
###                 ("\<^const>NominalSequents.sequent.Sequent"
###                   ("_position" \<Gamma>') ("_position" \<Delta>'))
###                 ("_applC" ("_position" set)
###                   ("_applC" ("_position" fst) ("_position" r'))))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.conj"
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Gamma>')))
###               ("\<^const>HOL.Not"
###                 ("_applC" ("_position" multSubst) ("_position" \<Delta>'))))
###             ("_Ex_less_eq" ("_position" m') ("_position" m)
###               ("\<^const>NominalSequents.extRules"
###                 ("\<^const>Set.member"
###                   ("_tuple"
###                     ("\<^const>NominalSequents.sequent.Sequent"
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Gamma>) ("_position" \<Gamma>'))
###                       ("\<^const>Groups.plus_class.plus"
###                         ("_position" \<Delta>) ("_position" \<Delta>')))
###                     ("_tuple_arg" ("_position" m')))
###                   ("_applC" ("_position" derivable)
###                     ("_position" R)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 806 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent"
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent"
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###             ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###               ("_position" x) ("_position" A)))
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 812 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 5 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###         ("_applC" ("_position" derivable)
###           ("\<^const>NominalSequents.extRules" ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>NominalSequents.extRules"
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###       ("_Ex_less_eq" ("_position" n) ("_position" n')
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("\<^const>NominalSequents.extRules"
###       ("_Ex_less_eq" ("_position" n) ("_position" n')
###         ("\<^const>Set.member"
###           ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" p) ("_applC" ("_position" set) ("_position" Ps))
###     ("_Ex_less_eq" ("_position" n) ("_position" n')
###       ("\<^const>Set.member"
###         ("_tuple" ("_position" p) ("_tuple_arg" ("_position" n)))
###         ("\<^const>NominalSequents.extRules"
###           ("_applC" ("_position" derivable) ("_position" R)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 814 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>NominalSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>NominalSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1002 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A))))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.multiset_plus" ("_position" \<Delta>)
###             ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###               ("_position" x) ("_position" A))))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1005 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>NominalSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>NominalSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1212 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent"
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("_applC" ("_position" derivable)
###       ("\<^const>NominalSequents.extRules" ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member"
###     ("_tuple"
###       ("\<^const>NominalSequents.sequent.Sequent"
###         ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###           ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###             ("_position" x) ("_position" A)))
###         ("_position" \<Delta>))
###       ("_tuple_arg" ("_position" n)))
###     ("\<^const>NominalSequents.extRules"
###       ("_applC" ("_position" derivable) ("_position" R)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>NominalSequents.multiset_plus" ("_position" \<Gamma>)
###             ("\<^const>NominalSequents.form.Cpd1" ("_position" F)
###               ("_position" x) ("_position" A)))
###           ("_position" \<Delta>))
###         ("_tuple_arg" ("_position" n)))
###       ("_applC" ("_position" derivable) ("_position" R)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1215 of "$AFP/SequentInvertibility/NominalSequents.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("_applC" ("_position" derivable)
###         ("\<^const>NominalSequents.extRules" ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>NominalSequents.extRules"
###     ("_Ex_less_eq" ("_position" m) ("_position" n)
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>NominalSequents.extRules"
###       ("\<^const>Set.member"
###         ("_tuple"
###           ("\<^const>NominalSequents.sequent.Sequent"
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###               ("_position" \<Gamma>'))
###             ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###               ("_position" \<Delta>')))
###           ("_tuple_arg" ("_position" m)))
###         ("_applC" ("_position" derivable) ("_position" R))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ex_less_eq" ("_position" m) ("_position" n)
###     ("\<^const>Set.member"
###       ("_tuple"
###         ("\<^const>NominalSequents.sequent.Sequent"
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Gamma>)
###             ("_position" \<Gamma>'))
###           ("\<^const>Groups.plus_class.plus" ("_position" \<Delta>)
###             ("_position" \<Delta>')))
###         ("_tuple_arg" ("_position" m)))
###       ("\<^const>NominalSequents.extRules"
###         ("_applC" ("_position" derivable) ("_position" R))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.NominalSequents"
### 3.031s elapsed time, 3.390s cpu time, 0.459s GC time
Loading theory "Draft.NominalSequentsMoreTemplates"
val templateLemmas =
   [("NominalSequents.fin_supp", "finite (supp ?x)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("NominalSequents.finSupp", "finite (supp ?A)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("NominalSequents.finSupp", "finite (supp ?As)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("NominalSequents.finPremSet", "finite (set_of_prem ?Ps)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("NominalSequents.finSeqSet", "finite (NominalSequents.set_of_seq ?S)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("NominalSequents.calc_atm", "[] \<bullet> ?x = ?x",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("NominalSequents.form_form_list_perm_empty",
     "[] \<bullet> ?form_Rep = ?form_Rep",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("NominalSequents.form_form_list_perm_empty",
     "[] \<bullet> ?form_list_Rep = ?form_list_Rep",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_var 0)),
    ("NominalSequents.var_injection", "EX x. ?y = var x",
     template_predicate (template_app (template_hole 2, t_empty))),
    ("NominalSequents.supp_atm", "supp ?x = {?x}",
     template_equation
      (template_app (template_hole 2, template_var 0),
       template_app
        (template_app (template_hole 1, template_var 0), template_hole 0))),
    ("NominalSequents.form_form_list_unfolded_perm_eq",
     "perm_form_Rep_noption ?pi ?noption = ?pi \<bullet> ?noption",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 1), template_var 0),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("NominalSequents.extendEmpty",
     "extend ( \<Empt> \<Rightarrow>* \<Empt>) ?C = ?C",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_hole 0),
             template_hole 0)),
         template_var 0),
       template_var 0)),
    ("NominalSequents.perm_pi_simp",
     "?pi \<bullet> rev ?pi \<bullet> ?x = ?x",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 1),
         template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 1)),
           template_var 0)),
       template_var 0)),
    ("NominalSequents.perm_pi_simp",
     "rev ?pi \<bullet> ?pi \<bullet> ?x = ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_var 0)),
    ("NominalSequents.fresh_atm", "?a \<sharp> ?b = (?a ~= ?b)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 0)
            )],
       template_negation
        (template_equation (template_var 1, template_var 0)))),
    ("NominalSequents.characteriseSeq",
     "EX A B. ?C = ( A \<Rightarrow>* B)",
     template_predicate (template_app (template_hole 2, t_empty))),
    ("NominalSequents.supp_eqvt",
     "?pi \<bullet> supp ?x = supp (?pi \<bullet> ?x)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("NominalSequents.swap_simps", "[(?a, ?b)] \<bullet> ?a = ?b",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0)),
             template_hole 0)),
         template_var 1),
       template_var 0)),
    ("NominalSequents.swap_simps", "[(?a, ?b)] \<bullet> ?b = ?a",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0)),
             template_hole 0)),
         template_var 0),
       template_var 1)),
    ("NominalSequents.exists_fresh'",
     "finite (supp ?x) ==> EX c. c \<sharp> ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 3,
              template_app (template_hole 2, template_var 0))
            )],
       template_predicate (template_app (template_hole 1, t_empty)))),
    ("NominalSequents.perm_app",
     "?pi \<bullet> ?f ?x = (?pi \<bullet> ?f) (?pi \<bullet> ?x)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 2),
         template_app (template_var 1, template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 1, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("NominalSequents.extRulesp_extRules_eq",
     "extRulesp (%x. x : ?R) = (%x. x :  ?R*)",
     template_equation (template_app (template_hole 2, t_empty), t_empty)),
    ("NominalSequents.abs_supp", "supp ([?a].?x) = supp ?x - {?a}",
     template_equation
      (template_app
        (template_hole 5,
         template_app
          (template_app (template_hole 4, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 0)),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_hole 0)))),
    ("NominalSequents.perm_bij",
     "(?pi \<bullet> ?x = ?pi \<bullet> ?y) = (?x = ?y)",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 0, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 0, template_var 2), template_var 0)),
       template_equation (template_var 1, template_var 0))),
    ("NominalSequents.fresh_bij",
     "?pi \<bullet> ?a \<sharp> ?pi \<bullet> ?x = ?a \<sharp> ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2), template_var 0)),
       template_app
        (template_app (template_hole 2, template_var 1), template_var 0))),
    ("NominalSequents.fresh_star_bij",
     "(?pi \<bullet> ?a) \<sharp>* (?pi \<bullet> ?x) = ?a \<sharp>* ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2), template_var 0)),
       template_app
        (template_app (template_hole 2, template_var 1), template_var 0))),
    ("NominalSequents.fresh_star_bij",
     "(?pi \<bullet> ?b) \<sharp>* (?pi \<bullet> ?x) = ?b \<sharp>* ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2), template_var 0)),
       template_app
        (template_app (template_hole 2, template_var 1), template_var 0))),
    ("NominalSequents.form_form_list_perm_append",
     "(?pi1.0 @ ?pi2.0) \<bullet> ?form_Rep =
      ?pi1.0 \<bullet> ?pi2.0 \<bullet> ?form_Rep",
     template_equation
      (template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 1, template_var 2),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("NominalSequents.form_form_list_perm_append",
     "(?pi1.0 @ ?pi2.0) \<bullet> ?form_list_Rep =
      ?pi1.0 \<bullet> ?pi2.0 \<bullet> ?form_list_Rep",
     template_equation
      (template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 1, template_var 2),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("NominalSequents.nonEmptySet", "?A ~= [] --> (EX a. a : set ?A)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 6,
             template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_var 0),
                 template_hole 3))),
           template_app (template_hole 2, t_empty))
         )),
    ("NominalSequents.fresh_left",
     "?a \<sharp> ?pi \<bullet> ?x = rev ?pi \<bullet> ?a \<sharp> ?x",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 1)),
             template_var 2)),
         template_var 0))),
    ("NominalSequents.fresh_right",
     "?pi \<bullet> ?a \<sharp> ?x = ?a \<sharp> rev ?pi \<bullet> ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 3, template_var 1),
         template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 2)),
           template_var 0)))),
    ("NominalSequents.form_form_list_perm_eq",
     " ?pi1.0 \<triangleq> ?pi2.0  ==>
      ?pi1.0 \<bullet> ?form_Rep = ?pi2.0 \<bullet> ?form_Rep",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 2),
              template_var 1)
            )],
       template_equation
        (template_app
          (template_app (template_hole 0, template_var 2), template_var 0),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("NominalSequents.form_form_list_perm_eq",
     " ?pi1.0 \<triangleq> ?pi2.0  ==>
      ?pi1.0 \<bullet> ?form_list_Rep = ?pi2.0 \<bullet> ?form_list_Rep",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 2),
              template_var 1)
            )],
       template_equation
        (template_app
          (template_app (template_hole 0, template_var 2), template_var 0),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("NominalSequents.perm_compose",
     "?pi2.0 \<bullet> ?pi1.0 \<bullet> ?x =
      (?pi2.0 \<bullet> ?pi1.0) \<bullet> ?pi2.0 \<bullet> ?x",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 2),
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 2),
           template_var 0)))),
    ("NominalSequents.abs_perm",
     "?pi \<bullet> [?a].?x = [(?pi \<bullet> ?a)].(?pi \<bullet> ?x)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("NominalSequents.set_diff_eqvt",
     "?pi \<bullet> (?X - ?Y) = ?pi \<bullet> ?X - ?pi \<bullet> ?Y",
     template_equation
      (template_app
        (template_app (template_hole 1, template_var 2),
         template_app
          (template_app (template_hole 0, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 1, template_var 2),
           template_var 0)))),
    ("NominalSequents.abs_fresh",
     "?b \<sharp> [?a].?x = (?b = ?a | ?b \<sharp> ?x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 1)),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0))
           ))),
    ("NominalSequents.eq_eqvt",
     "?pi \<bullet> (?x = ?y) = (?pi \<bullet> ?x = ?pi \<bullet> ?y)",
     template_bimplication
      (template_predicate
        (
           template_app
            (template_app (template_hole 2, template_var 2),
             template_app
              (template_app (template_hole 1, template_var 1),
               template_var 0))
           ),
       template_equation
        (template_app
          (template_app (template_hole 0, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("NominalSequents.fresh_eqvt",
     "?pi \<bullet> ?a \<sharp> ?x =
      ?pi \<bullet> ?a \<sharp> ?pi \<bullet> ?x",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("NominalSequents.fresh_star_eqvt",
     "?pi \<bullet> ?a \<sharp>* ?x =
      (?pi \<bullet> ?a) \<sharp>* (?pi \<bullet> ?x)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("NominalSequents.fresh_star_eqvt",
     "?pi \<bullet> ?b \<sharp>* ?x =
      (?pi \<bullet> ?b) \<sharp>* (?pi \<bullet> ?x)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("NominalSequents.subseteq_eqvt",
     "?pi \<bullet> (?X <= ?Y) = (?pi \<bullet> ?X <= ?pi \<bullet> ?Y)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 2),
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("NominalSequents.in_eqvt",
     "?pi \<bullet> (?x : ?X) = (?pi \<bullet> ?x : ?pi \<bullet> ?X)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("NominalSequents.perm_compose'",
     "(?pi2.0 \<bullet> ?pi1.0) \<bullet> ?x =
      ?pi2.0 \<bullet> ?pi1.0 \<bullet> rev ?pi2.0 \<bullet> ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 2, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 0, template_var 2)),
             template_var 0))))),
    ("NominalSequents.derivablep_derivable_eq",
     "derivablep (%x. x : ?R) = (%x xa. (x, xa) : derivable ?R)",
     template_equation (template_app (template_hole 4, t_empty), t_empty)),
    ("NominalSequents.all_eqvt",
     "?pi \<bullet> HOL.induct_forall ?P =
      HOL.induct_forall (%x. ?pi \<bullet> ?P (rev ?pi \<bullet> x))",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 2, template_var 0)),
       template_app (template_hole 2, t_empty))),
    ("NominalSequents.perm_swap",
     "[(?a, ?b)] \<bullet> [(?a, ?b)] \<bullet> ?x = ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 1)),
             template_hole 0)),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 1)),
               template_hole 0)),
           template_var 0)),
       template_var 0)),
    ("NominalSequents.perm_swap",
     "[(?a, ?b)] \<bullet> [(?b, ?a)] \<bullet> ?x = ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 1)),
             template_hole 0)),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 1),
                   template_var 2)),
               template_hole 0)),
           template_var 0)),
       template_var 0)),
    ("NominalSequents.calc_atm",
     "((?a, ?b) # ?pi) \<bullet> ?x = swap (?a, ?b) (?pi \<bullet> ?x)",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 3),
                 template_var 2)),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 1, template_var 3),
             template_var 2)),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_var 0)))),
    ("NominalSequents.fresh_perm_app",
     "[| ?a \<sharp> ?pi; ?a \<sharp> ?x |]
      ==> ?a \<sharp> ?pi \<bullet> ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 1, template_var 2),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 1, template_var 2),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("NominalSequents.all_eqvt",
     "?pi \<bullet> (ALL x. ?P x) =
      (ALL x. ?pi \<bullet> ?P (rev ?pi \<bullet> x))",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 2, t_empty)),
       template_app (template_hole 2, t_empty))),
    ("NominalSequents.ex_eqvt",
     "?pi \<bullet> (EX x. ?P x) =
      (EX x. ?pi \<bullet> ?P (rev ?pi \<bullet> x))",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 2, t_empty)),
       template_app (template_hole 2, t_empty))),
    ("NominalSequents.ex1_eqvt",
     "?pi \<bullet> (EX! x. ?P x) =
      (EX! x. ?pi \<bullet> ?P (rev ?pi \<bullet> x))",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 2, t_empty)),
       template_app (template_hole 2, t_empty))),
    ("NominalSequents.abs_supp",
     "finite (supp ?x) ==> supp ([?a].?x) = supp ?x - {?a}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 7,
              template_app (template_hole 6, template_var 1))
            )],
       template_equation
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 0),
             template_var 1)),
         template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 6, template_var 1)),
           template_app
            (template_app (template_hole 1, template_var 0),
             template_hole 0))))),
    ("NominalSequents.exists_fresh",
     "[| finite (supp ?x); !!c. c \<sharp> ?x ==> ?thesis |] ==> ?thesis",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 3,
              template_app (template_hole 2, template_var 1))
            ),
        template_predicate (template_app (template_hole 1, t_empty))],
       template_predicate (template_var 0))),
    ("NominalSequents.subst_var_list_eqvt",
     "?pi \<bullet> [?z;?x]?y =
      [(?pi \<bullet> ?z);(?pi \<bullet> ?x)](?pi \<bullet> ?y)",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 3),
         template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2)),
           template_app
            (template_app (template_hole 0, template_var 3),
             template_var 1)),
         template_app
          (template_app (template_hole 2, template_var 3),
           template_var 0)))),
    ("NominalSequents.calc_atm",
     "swap (?a, ?b) ?c =
      (if ?a = ?c then ?b else if ?b = ?c then ?a else ?c)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 2),
                  template_var 1)),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_hole 0,
                 template_app
                  (template_app (template_hole 3, template_var 2),
                   template_var 0)),
               template_var 1),
             template_app
              (template_app
                (template_app
                  (template_hole 0,
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_var 0)),
                 template_var 2),
               template_var 0))
           ))),
    ("NominalSequents.switchAux",
     "?y \<sharp> ?Xs ==> [?y;?x]?Xs = [(?y, ?x)] \<bullet> ?Xs",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 2),
              template_var 1)
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 4, template_var 2),
             template_var 0),
           template_var 1),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 0)),
               template_hole 0)),
           template_var 1)))),
    ("NominalSequents.switch",
     "?y \<sharp> ?A ==> [?y,?x]?A = [(?y, ?x)] \<bullet> ?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 2),
              template_var 1)
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 4, template_var 2),
             template_var 0),
           template_var 1),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 0)),
               template_hole 0)),
           template_var 1)))),
    ("NominalSequents.switch",
     "?y \<sharp> ?As ==> [?y,?x]?As = [(?y, ?x)] \<bullet> ?As",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 2),
              template_var 1)
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 4, template_var 2),
             template_var 0),
           template_var 1),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 0)),
               template_hole 0)),
           template_var 1)))),
    ("NominalSequents.extendFalsum",
     "extend ?S ( \<LM> ff  \<RM> \<Rightarrow>* \<Empt>) =
      ( ?\<Gamma> \<Rightarrow>* ?\<Delta>) ==>
      ff :# ?\<Gamma>",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 6, template_var 2),
            template_app
             (template_app
               (template_hole 5,
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_hole 2)),
              template_hole 2)),
          template_app
           (template_app (template_hole 5, template_var 1),
            template_var 0))],
       template_predicate
        (
           template_app
            (template_app (template_hole 1, template_hole 3),
             template_app (template_hole 0, template_var 1))
           ))),
    ("NominalSequents.abs_fresh",
     "finite (supp ?x) ==>
      ?b \<sharp> [?a].?x = (?b = ?a | ?b \<sharp> ?x)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 7,
              template_app (template_hole 6, template_var 2))
            )],
       template_implication
        ([template_predicate
           (
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_var 0),
                  template_var 2))
              )],
         template_predicate
          (
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 1),
                   template_var 0)),
               template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 2))
             )))),
    ("NominalSequents.getFresh",
     "EX y. y \<sharp> ?x &
            y \<sharp> ?A &
            y \<sharp> NominalSequents.set_of_seq ?S &
            y \<sharp> set_of_prem ?Ps",
     template_predicate (template_app (template_hole 6, t_empty))),
    ("NominalSequents.perm_fresh_fresh",
     "[| ?a \<sharp> ?x; ?b \<sharp> ?x |]
      ==> [(?a, ?b)] \<bullet> ?x = ?x",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 0),
              template_var 1)
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 0)),
               template_hole 0)),
           template_var 1),
         template_var 1))),
    ("NominalSequents.containFalsum",
     "[| ff :# ?\<Gamma>; Ax <= ?R |]
      ==> ( ?\<Gamma> \<Rightarrow>* ?\<Delta>, 0) : derivable  ?R*",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 10, template_hole 9),
              template_app (template_hole 8, template_var 2))
            ),
        template_inequation (less_equals, template_hole 6, template_var 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 2),
                     template_var 0)),
                 template_hole 2)),
             template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 1)))
           ))),
    ("NominalSequents.formSubst",
     "?y \<sharp> ?x & ?y \<sharp> ?A ==>
      ?F \<nabla> [?x].?A = ?F \<nabla> [?y].[?y,?x]?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 5,
                template_app
                 (template_app (template_hole 4, template_var 3),
                  template_var 2)),
              template_app
               (template_app (template_hole 3, template_var 3),
                template_var 1))
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 0),
             template_var 2),
           template_var 1),
         template_app
          (template_app
            (template_app (template_hole 1, template_var 0),
             template_var 3),
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_var 1))))),
    ("NominalSequents.swap_simps",
     "[| ?a ~= ?c; ?b ~= ?c |] ==> [(?a, ?b)] \<bullet> ?c = ?c",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_var 1)),
        template_negation
         (template_equation (template_var 0, template_var 1))],
       template_equation
        (template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 0)),
               template_hole 0)),
           template_var 1),
         template_var 1))),
    ("NominalSequents.the_eqvt",
     "EX! x. ?P x ==>
      ?pi \<bullet> (THE x. ?P x) =
      (THE x. ?pi \<bullet> ?P (rev ?pi \<bullet> x))",
     template_implication
      ([template_predicate (template_app (template_hole 5, t_empty))],
       template_equation
        (template_app
          (template_app (template_hole 3, template_var 0),
           template_app (template_hole 2, t_empty)),
         template_app (template_hole 2, t_empty)))),
    ("NominalSequents.fresh_aux",
     "[| ?c ~= ?a; ?a \<sharp> ?x; ?c \<sharp> ?x |]
      ==> ?c \<sharp> [(?a, ?b)] \<bullet> ?x",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_var 2)),
        template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 2),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 3),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 4, template_var 3),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app
                    (template_hole 2,
                     template_app
                      (template_app (template_hole 1, template_var 2),
                       template_var 0)),
                   template_hole 0)),
               template_var 1))
           ))),
    ("NominalSequents.extendContain",
     "[| ?r = (?ps, ?c); (?Ps, ?C) = extendRule ?S ?r; ?p : set ?ps |]
      ==> extend ?S ?p : set ?Ps",
     template_implication
      ([template_equation
         (template_var 6,
          template_app
           (template_app (template_hole 4, template_var 5),
            template_var 4)),
        template_equation
         (template_app
           (template_app (template_hole 4, template_var 3), template_var 2),
          template_app
           (template_app (template_hole 3, template_var 1),
            template_var 6)),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 0),
              template_app (template_hole 1, template_var 5))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 0)),
             template_app (template_hole 1, template_var 3))
           ))),
    ("NominalSequents.containID",
     "[| At ?i ?xs :# ?\<Gamma> & At ?i ?xs :# ?\<Delta>; Ax <= ?R |]
      ==> ( ?\<Gamma> \<Rightarrow>* ?\<Delta>, 0) : derivable  ?R*",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_app
                   (template_hole 10,
                    template_app
                     (template_app (template_hole 9, template_var 4),
                      template_var 3)),
                  template_app (template_hole 8, template_var 2))),
              template_app
               (template_app
                 (template_hole 10,
                  template_app
                   (template_app (template_hole 9, template_var 4),
                    template_var 3)),
                template_app (template_hole 8, template_var 1)))
            ),
        template_inequation (less_equals, template_hole 6, template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 2),
                     template_var 1)),
                 template_hole 2)),
             template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 0)))
           ))),
    ("NominalSequents.propRuleCharacterise",
     "(?Ps, ?C) : upRules ==>
      EX F Fs.
         ?C = ( \<Empt> \<Rightarrow>* \<LM> Cpd0 F Fs  \<RM>) |
         ?C = ( \<LM> Cpd0 F Fs  \<RM> \<Rightarrow>* \<Empt>)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 10,
                template_app
                 (template_app (template_hole 9, template_var 1),
                  template_var 0)),
              template_hole 8)
            )],
       template_predicate (template_app (template_hole 7, t_empty)))),
    ("NominalSequents.extendID",
     "extend ?S
       ( \<LM> At ?i ?xs  \<RM> \<Rightarrow>* \<LM> At ?i ?xs  \<RM>) =
      ( ?\<Gamma> \<Rightarrow>* ?\<Delta>) ==>
      At ?i ?xs :# ?\<Gamma> & At ?i ?xs :# ?\<Delta>",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 7, template_var 4),
            template_app
             (template_app
               (template_hole 6,
                template_app
                 (template_app
                   (template_hole 5,
                    template_app
                     (template_app (template_hole 4, template_var 3),
                      template_var 2)),
                  template_hole 3)),
              template_app
               (template_app
                 (template_hole 5,
                  template_app
                   (template_app (template_hole 4, template_var 3),
                    template_var 2)),
                template_hole 3))),
          template_app
           (template_app (template_hole 6, template_var 1),
            template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_hole 1,
                   template_app
                    (template_app (template_hole 4, template_var 3),
                     template_var 2)),
                 template_app (template_hole 0, template_var 1))),
             template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app (template_hole 4, template_var 3),
                   template_var 2)),
               template_app (template_hole 0, template_var 0)))
           ))),
    ("NominalSequents.alpha",
     "([?a].?x = [?b].?y) =
      (?a = ?b & ?x = ?y |
       ?a ~= ?b & ?x = [(?a, ?b)] \<bullet> ?y & ?a \<sharp> ?y)",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 10, template_var 1),
           template_var 0)),
       template_predicate
        (
           template_app
            (template_app
              (template_hole 9,
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app (template_hole 7, template_var 3),
                     template_var 1)),
                 template_app
                  (template_app (template_hole 6, template_var 2),
                   template_var 0))),
             template_app
              (template_app
                (template_hole 8,
                 template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 7, template_var 3),
                     template_var 1))),
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app (template_hole 6, template_var 2),
                     template_app
                      (template_app
                        (template_hole 4,
                         template_app
                          (template_app
                            (template_hole 3,
                             template_app
                              (template_app
                                (template_hole 2, template_var 3),
                               template_var 1)),
                           template_hole 1)),
                       template_var 0))),
                 template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 0))))
           ))),
    ("NominalSequents.alpha'",
     "([?a].?x = [?b].?y) =
      (?a = ?b & ?x = ?y |
       ?a ~= ?b & [(?b, ?a)] \<bullet> ?x = ?y & ?b \<sharp> ?x)",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 10, template_var 1),
           template_var 0)),
       template_predicate
        (
           template_app
            (template_app
              (template_hole 9,
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app (template_hole 7, template_var 3),
                     template_var 1)),
                 template_app
                  (template_app (template_hole 6, template_var 2),
                   template_var 0))),
             template_app
              (template_app
                (template_hole 8,
                 template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 7, template_var 3),
                     template_var 1))),
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app
                      (template_hole 6,
                       template_app
                        (template_app
                          (template_hole 4,
                           template_app
                            (template_app
                              (template_hole 3,
                               template_app
                                (template_app
                                  (template_hole 2, template_var 1),
                                 template_var 3)),
                             template_hole 1)),
                         template_var 2)),
                     template_var 0)),
                 template_app
                  (template_app (template_hole 0, template_var 1),
                   template_var 2))))
           ))),
    ("NominalSequents.characteriseAx",
     "?r : Ax ==>
      ?r = ([],  \<LM> ff  \<RM> \<Rightarrow>* \<Empt>) |
      (EX i xs.
          ?r =
          ([],  \<LM> At i xs  \<RM> \<Rightarrow>* \<LM> At i xs  \<RM>))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 12, template_var 0),
              template_hole 11)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app (template_hole 9, template_var 0),
                 template_app
                  (template_app (template_hole 8, template_hole 7),
                   template_app
                    (template_app
                      (template_hole 6,
                       template_app
                        (template_app (template_hole 5, template_hole 4),
                         template_hole 3)),
                     template_hole 3)))),
             template_app (template_hole 2, t_empty))
           ))),
    ("NominalSequents.nprovRuleCharacterise",
     "(?Ps, ?C) : nprovRules ==>
      EX F x A.
         ?C = ( \<Empt> \<Rightarrow>* \<LM> F \<nabla> [x].A  \<RM>) |
         ?C = ( \<LM> F \<nabla> [x].A  \<RM> \<Rightarrow>* \<Empt>)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_app (template_hole 10, template_var 1),
                  template_var 0)),
              template_hole 9)
            )],
       template_predicate (template_app (template_hole 8, t_empty)))),
    ("NominalSequents.extend_for_any_seq",
     "[| ?R1.0 <= upRules & ?R2.0 <= nprovRules & ?R3.0 <= provRules;
         ?R = Ax Un ?R1.0 Un ?R2.0 Un ?R3.0; ?r : ?R |]
      ==> extendRule ?S ?r :  ?R*",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 10,
                template_app
                 (template_app (template_hole 9, template_var 5),
                  template_hole 8)),
              template_app
               (template_app
                 (template_hole 10,
                  template_app
                   (template_app (template_hole 9, template_var 4),
                    template_hole 7)),
                template_app
                 (template_app (template_hole 9, template_var 3),
                  template_hole 6)))
            ),
        template_equation
         (template_var 2,
          template_app
           (template_app
             (template_hole 4,
              template_app
               (template_app
                 (template_hole 4,
                  template_app
                   (template_app (template_hole 4, template_hole 3),
                    template_var 5)),
                template_var 4)),
            template_var 3)),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 2)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 0),
                 template_var 1)),
             template_app (template_hole 0, template_var 2))
           ))),
    ("NominalSequents.characteriseLast",
     "(?C, ?m + 1) : derivable ?R ==>
      EX Ps.
         Ps ~= [] &
         (Ps, ?C) : ?R & (ALL p:set Ps. EX n<=?m. (p, n) : derivable ?R)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 15,
                template_app
                 (template_app (template_hole 14, template_var 2),
                  template_app
                   (template_app (template_hole 13, template_var 1),
                    template_hole 12))),
              template_app (template_hole 11, template_var 0))
            )],
       template_predicate (template_app (template_hole 10, t_empty)))),
    ("NominalSequents.provRuleCharacterise",
     "(?Ps, ?C) : provRules ==>
      EX F x A.
         (?C = ( \<Empt> \<Rightarrow>* \<LM> F \<nabla> [x].A  \<RM>) |
          ?C = ( \<LM> F \<nabla> [x].A  \<RM> \<Rightarrow>* \<Empt>)) &
         x \<sharp> set_of_prem ( ?Ps - A )",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 15,
                template_app
                 (template_app (template_hole 14, template_var 1),
                  template_var 0)),
              template_hole 13)
            )],
       template_predicate (template_app (template_hole 12, t_empty)))),
    ("NominalSequents.alpha_fresh",
     "[| ?c ~= ?a; ?c ~= ?b; ?c \<sharp> ?x; ?c \<sharp> ?y |]
      ==> ([?a].?x = [?b].?y) =
          ([(?a, ?c)] \<bullet> ?x = [(?b, ?c)] \<bullet> ?y)",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_negation
         (template_equation (template_var 4, template_var 2)),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 4),
              template_var 1)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 4),
              template_var 0)
            )],
       template_bimplication
        (template_equation
          (template_app
            (template_app (template_hole 5, template_var 3),
             template_var 1),
           template_app
            (template_app (template_hole 5, template_var 2),
             template_var 0)),
         template_equation
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_var 3),
                     template_var 4)),
                 template_hole 0)),
             template_var 1),
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_var 2),
                     template_var 4)),
                 template_hole 0)),
             template_var 0))))),
    ("NominalSequents.alpha_fresh'",
     "[| [?a].?x = [?b].?y; ?c ~= ?a; ?c ~= ?b; ?c \<sharp> ?x;
         ?c \<sharp> ?y |]
      ==> ?x = [(?a, ?c)] \<bullet> [(?b, ?c)] \<bullet> ?y",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 8, template_var 4), template_var 3),
          template_app
           (template_app (template_hole 8, template_var 2),
            template_var 1)),
        template_negation
         (template_equation (template_var 0, template_var 4)),
        template_negation
         (template_equation (template_var 0, template_var 2)),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 0),
              template_var 3)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 0),
              template_var 1)
            )],
       template_equation
        (template_var 3,
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 4),
                   template_var 0)),
               template_hole 0)),
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_var 2),
                     template_var 0)),
                 template_hole 0)),
             template_var 1))))),
    ("NominalSequents.ruleSet",
     "[| ?R1.0 <= upRules; ?R2.0 <= nprovRules; ?R3.0 <= provRules;
         ?R = Ax Un ?R1.0 Un ?R2.0 Un ?R3.0; (?Ps, ?C) :  ?R* |]
      ==> EX S r.
             extendRule S r = (?Ps, ?C) &
             (r : ?R1.0 | r : ?R2.0 | r : ?R3.0 | r : Ax)",
     template_implication
      ([template_inequation (less_equals, template_var 5, template_hole 14),
        template_inequation (less_equals, template_var 4, template_hole 13),
        template_inequation (less_equals, template_var 3, template_hole 12),
        template_equation
         (template_var 2,
          template_app
           (template_app
             (template_hole 10,
              template_app
               (template_app
                 (template_hole 10,
                  template_app
                   (template_app (template_hole 10, template_hole 9),
                    template_var 5)),
                template_var 4)),
            template_var 3)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app (template_hole 7, template_var 1),
                  template_var 0)),
              template_app (template_hole 6, template_var 2))
            )],
       template_predicate (template_app (template_hole 5, t_empty)))),
    ("NominalSequents.rightInvert",
     "[| ?R1.0 <= upRules &
         ?R2.0 <= nprovRules &
         ?R3.0 <= provRules & ?R = Ax Un ?R1.0 Un ?R2.0 Un ?R3.0;
         ( ?\<Gamma> \<Rightarrow>* ?\<Delta> \<oplus> ?F \<nabla> [?x].?A,
          ?n)
         : derivable  ?R*;
         ALL r':?R.
            rightPrincipal r' (?F \<nabla> [?x].?A) -->
            ( ?\<Gamma>' \<Rightarrow>* ?\<Delta>') : set (fst r');
         ~ multSubst ?\<Gamma>' & ~ multSubst ?\<Delta>' |]
      ==> EX m<=?n.
             ( ?\<Gamma> + ?\<Gamma>' \<Rightarrow>* ?\<Delta> + ?\<Delta>',
              m)
             : derivable  ?R*",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 26,
                template_app
                 (template_app (template_hole 25, template_var 11),
                  template_hole 24)),
              template_app
               (template_app
                 (template_hole 26,
                  template_app
                   (template_app (template_hole 25, template_var 10),
                    template_hole 23)),
                template_app
                 (template_app
                   (template_hole 26,
                    template_app
                     (template_app (template_hole 25, template_var 9),
                      template_hole 22)),
                  template_app
                   (template_app (template_hole 21, template_var 8),
                    template_app
                     (template_app
                       (template_hole 20,
                        template_app
                         (template_app
                           (template_hole 20,
                            template_app
                             (template_app
                               (template_hole 20, template_hole 19),
                              template_var 11)),
                          template_var 10)),
                      template_var 9)))))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 18,
                template_app
                 (template_app
                   (template_hole 17,
                    template_app
                     (template_app (template_hole 16, template_var 7),
                      template_app
                       (template_app (template_hole 15, template_var 6),
                        template_app
                         (template_app
                           (template_hole 14,
                            template_app
                             (template_app
                               (template_app
                                 (template_hole 13, template_var 5),
                                template_var 4),
                              template_var 3)),
                          template_hole 12)))),
                  template_var 2)),
              template_app
               (template_hole 11,
                template_app (template_hole 10, template_var 8)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 8), t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 26,
                template_app
                 (template_hole 3,
                  template_app (template_hole 2, template_var 1))),
              template_app
               (template_hole 3,
                template_app (template_hole 2, template_var 0)))
            )],
       template_predicate (template_app (template_hole 1, t_empty)))),
    ("NominalSequents.leftInvert",
     "[| ?R1.0 <= upRules &
         ?R2.0 <= nprovRules &
         ?R3.0 <= provRules & ?R = Ax Un ?R1.0 Un ?R2.0 Un ?R3.0;
         ( ?\<Gamma> \<oplus> ?F \<nabla> [?x].?A \<Rightarrow>* ?\<Delta>,
          ?n)
         : derivable  ?R*;
         ALL r':?R.
            leftPrincipal r' (?F \<nabla> [?x].?A) -->
            ( ?\<Gamma>' \<Rightarrow>* ?\<Delta>') : set (fst r');
         ~ multSubst ?\<Gamma>' & ~ multSubst ?\<Delta>' |]
      ==> EX m<=?n.
             ( ?\<Gamma> + ?\<Gamma>' \<Rightarrow>* ?\<Delta> + ?\<Delta>',
              m)
             : derivable  ?R*",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 26,
                template_app
                 (template_app (template_hole 25, template_var 11),
                  template_hole 24)),
              template_app
               (template_app
                 (template_hole 26,
                  template_app
                   (template_app (template_hole 25, template_var 10),
                    template_hole 23)),
                template_app
                 (template_app
                   (template_hole 26,
                    template_app
                     (template_app (template_hole 25, template_var 9),
                      template_hole 22)),
                  template_app
                   (template_app (template_hole 21, template_var 8),
                    template_app
                     (template_app
                       (template_hole 20,
                        template_app
                         (template_app
                           (template_hole 20,
                            template_app
                             (template_app
                               (template_hole 20, template_hole 19),
                              template_var 11)),
                          template_var 10)),
                      template_var 9)))))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 18,
                template_app
                 (template_app
                   (template_hole 17,
                    template_app
                     (template_app
                       (template_hole 16,
                        template_app
                         (template_app (template_hole 15, template_var 7),
                          template_app
                           (template_app
                             (template_hole 14,
                              template_app
                               (template_app
                                 (template_app
                                   (template_hole 13, template_var 6),
                                  template_var 5),
                                template_var 4)),
                            template_hole 12))),
                      template_var 3)),
                  template_var 2)),
              template_app
               (template_hole 11,
                template_app (template_hole 10, template_var 8)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 8), t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 26,
                template_app
                 (template_hole 3,
                  template_app (template_hole 2, template_var 1))),
              template_app
               (template_hole 3,
                template_app (template_hole 2, template_var 0)))
            )],
       template_predicate (template_app (template_hole 1, t_empty)))),
    ("NominalSequents.nonPrincipalInvertRight",
     "[| ?R1.0 <= upRules; ?R2.0 <= nprovRules; ?R3.0 <= provRules;
         ?R = Ax Un ?R1.0 Un ?R2.0 Un ?R3.0;
         ?r : ?R1.0 | ?r : ?R2.0 | ?r : ?R3.0; ?r = (?ps, ?c);
         ALL m<?n.
            ALL \<Gamma> \<Delta>.
               ( \<Gamma> \<Rightarrow>* \<Delta> \<oplus>
   ?F \<nabla> [?x].?A,
                m)
               : derivable  ?R* -->
               (ALL r':?R.
                   rightPrincipal r' (?F \<nabla> [?x].?A) -->
                   ( ?\<Gamma>' \<Rightarrow>* ?\<Delta>')
                   : set (fst r')) -->
               ~ multSubst ?\<Gamma>' & ~ multSubst ?\<Delta>' -->
               (EX m'<=m.
                   ( \<Gamma> +
                     ?\<Gamma>' \<Rightarrow>* \<Delta> + ?\<Delta>',
                    m')
                   : derivable  ?R*);
         ( ?\<Gamma> \<Rightarrow>* ?\<Delta> \<oplus> ?F \<nabla> [?x].?A,
          ?n)
         : derivable  ?R*;
         ALL r':?R.
            rightPrincipal r' (?F \<nabla> [?x].?A) -->
            ( ?\<Gamma>' \<Rightarrow>* ?\<Delta>') : set (fst r');
         ~ multSubst ?\<Gamma>' & ~ multSubst ?\<Delta>';
         ~ rightPrincipal ?r (?F \<nabla> [?x].?A);
         extendRule ?S ?r =
         (?Ps,
           ?\<Gamma> \<Rightarrow>* ?\<Delta> \<oplus> ?F \<nabla> [?x].?A);
         ?n = ?n' + 1; ALL p:set ?Ps. EX n<=?n'. (p, n) : derivable  ?R*;
         ?Ps ~= [] |]
      ==> EX m<=?n.
             ( ?\<Gamma> + ?\<Gamma>' \<Rightarrow>* ?\<Delta> + ?\<Delta>',
              m)
             : derivable  ?R*",
     template_implication
      ([template_inequation
         (less_equals, template_var 17, template_hole 39),
        template_inequation
         (less_equals, template_var 16, template_hole 38),
        template_inequation
         (less_equals, template_var 15, template_hole 37),
        template_equation
         (template_var 14,
          template_app
           (template_app
             (template_hole 35,
              template_app
               (template_app
                 (template_hole 35,
                  template_app
                   (template_app (template_hole 35, template_hole 34),
                    template_var 17)),
                template_var 16)),
            template_var 15)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 33,
                template_app
                 (template_app (template_hole 32, template_var 13),
                  template_var 17)),
              template_app
               (template_app
                 (template_hole 33,
                  template_app
                   (template_app (template_hole 32, template_var 13),
                    template_var 16)),
                template_app
                 (template_app (template_hole 32, template_var 13),
                  template_var 15)))
            ),
        template_equation
         (template_var 13,
          template_app
           (template_app (template_hole 30, template_var 12),
            template_var 11)),
        template_predicate (template_app (template_hole 29, t_empty)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 25,
                template_app
                 (template_app
                   (template_hole 24,
                    template_app
                     (template_app (template_hole 23, template_var 4),
                      template_app
                       (template_app (template_hole 22, template_var 3),
                        template_app
                         (template_app
                           (template_hole 21,
                            template_app
                             (template_app
                               (template_app
                                 (template_hole 20, template_var 9),
                                template_var 8),
                              template_var 7)),
                          template_hole 19)))),
                  template_var 10)),
              template_app
               (template_hole 18,
                template_app (template_hole 17, template_var 14)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 16, template_var 14), t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_hole 10,
                  template_app (template_hole 9, template_var 6))),
              template_app
               (template_hole 10,
                template_app (template_hole 9, template_var 5)))
            ),
        template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 15, template_var 13),
                  template_app
                   (template_app
                     (template_app (template_hole 20, template_var 9),
                      template_var 8),
                    template_var 7))
                )
            ),
        template_equation
         (template_app
           (template_app (template_hole 6, template_var 2),
            template_var 13),
          template_app
           (template_app (template_hole 30, template_var 1),
            template_app
             (template_app (template_hole 23, template_var 4),
              template_app
               (template_app (template_hole 22, template_var 3),
                template_app
                 (template_app
                   (template_hole 21,
                    template_app
                     (template_app
                       (template_app (template_hole 20, template_var 9),
                        template_var 8),
                      template_var 7)),
                  template_hole 19))))),
        template_equation
         (template_var 10,
          template_app
           (template_app (template_hole 4, template_var 0),
            template_hole 3)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app (template_hole 13, template_var 1)),
              t_empty)
            ),
        template_negation
         (template_equation (template_var 1, template_hole 0))],
       template_predicate (template_app (template_hole 8, t_empty)))),
    ("NominalSequents.nonPrincipalInvertLeft",
     "[| ?R1.0 <= upRules; ?R2.0 <= nprovRules; ?R3.0 <= provRules;
         ?R = Ax Un ?R1.0 Un ?R2.0 Un ?R3.0;
         ?r : ?R1.0 | ?r : ?R2.0 | ?r : ?R3.0; ?r = (?ps, ?c);
         ALL m<?n.
            ALL \<Gamma> \<Delta>.
               ( \<Gamma> \<oplus>
                 ?F \<nabla> [?x].?A \<Rightarrow>* \<Delta>,
                m)
               : derivable  ?R* -->
               (ALL r':?R.
                   leftPrincipal r' (?F \<nabla> [?x].?A) -->
                   ( ?\<Gamma>' \<Rightarrow>* ?\<Delta>')
                   : set (fst r')) -->
               ~ multSubst ?\<Gamma>' & ~ multSubst ?\<Delta>' -->
               (EX m'<=m.
                   ( \<Gamma> +
                     ?\<Gamma>' \<Rightarrow>* \<Delta> + ?\<Delta>',
                    m')
                   : derivable  ?R*);
         ( ?\<Gamma> \<oplus> ?F \<nabla> [?x].?A \<Rightarrow>* ?\<Delta>,
          ?n)
         : derivable  ?R*;
         ALL r':?R.
            leftPrincipal r' (?F \<nabla> [?x].?A) -->
            ( ?\<Gamma>' \<Rightarrow>* ?\<Delta>') : set (fst r');
         ~ multSubst ?\<Gamma>' & ~ multSubst ?\<Delta>';
         ~ leftPrincipal ?r (?F \<nabla> [?x].?A);
         extendRule ?S ?r =
         (?Ps,
           ?\<Gamma> \<oplus> ?F \<nabla> [?x].?A \<Rightarrow>* ?\<Delta>);
         ?n = ?n' + 1; ALL p:set ?Ps. EX n<=?n'. (p, n) : derivable  ?R*;
         ?Ps ~= [] |]
      ==> EX m<=?n.
             ( ?\<Gamma> + ?\<Gamma>' \<Rightarrow>* ?\<Delta> + ?\<Delta>',
              m)
             : derivable  ?R*",
     template_implication
      ([template_inequation
         (less_equals, template_var 17, template_hole 39),
        template_inequation
         (less_equals, template_var 16, template_hole 38),
        template_inequation
         (less_equals, template_var 15, template_hole 37),
        template_equation
         (template_var 14,
          template_app
           (template_app
             (template_hole 35,
              template_app
               (template_app
                 (template_hole 35,
                  template_app
                   (template_app (template_hole 35, template_hole 34),
                    template_var 17)),
                template_var 16)),
            template_var 15)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 33,
                template_app
                 (template_app (template_hole 32, template_var 13),
                  template_var 17)),
              template_app
               (template_app
                 (template_hole 33,
                  template_app
                   (template_app (template_hole 32, template_var 13),
                    template_var 16)),
                template_app
                 (template_app (template_hole 32, template_var 13),
                  template_var 15)))
            ),
        template_equation
         (template_var 13,
          template_app
           (template_app (template_hole 30, template_var 12),
            template_var 11)),
        template_predicate (template_app (template_hole 29, t_empty)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 25,
                template_app
                 (template_app
                   (template_hole 24,
                    template_app
                     (template_app
                       (template_hole 23,
                        template_app
                         (template_app (template_hole 22, template_var 4),
                          template_app
                           (template_app
                             (template_hole 21,
                              template_app
                               (template_app
                                 (template_app
                                   (template_hole 20, template_var 9),
                                  template_var 8),
                                template_var 7)),
                            template_hole 19))),
                      template_var 3)),
                  template_var 10)),
              template_app
               (template_hole 18,
                template_app (template_hole 17, template_var 14)))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 16, template_var 14), t_empty)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_hole 10,
                  template_app (template_hole 9, template_var 6))),
              template_app
               (template_hole 10,
                template_app (template_hole 9, template_var 5)))
            ),
        template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 15, template_var 13),
                  template_app
                   (template_app
                     (template_app (template_hole 20, template_var 9),
                      template_var 8),
                    template_var 7))
                )
            ),
        template_equation
         (template_app
           (template_app (template_hole 6, template_var 2),
            template_var 13),
          template_app
           (template_app (template_hole 30, template_var 1),
            template_app
             (template_app
               (template_hole 23,
                template_app
                 (template_app (template_hole 22, template_var 4),
                  template_app
                   (template_app
                     (template_hole 21,
                      template_app
                       (template_app
                         (template_app (template_hole 20, template_var 9),
                          template_var 8),
                        template_var 7)),
                    template_hole 19))),
              template_var 3))),
        template_equation
         (template_var 10,
          template_app
           (template_app (template_hole 4, template_var 0),
            template_hole 3)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app (template_hole 13, template_var 1)),
              t_empty)
            ),
        template_negation
         (template_equation (template_var 1, template_hole 0))],
       template_predicate (template_app (template_hole 8, t_empty))))]:
   (string * thm * template) list
### theory "Draft.NominalSequentsMoreTemplates"
### 0.455s elapsed time, 0.631s cpu time, 0.000s GC time
val it = (): unit
