Loading theory "Draft.Rec_Def" (required by "Draft.RecursiveMoreTemplates" via "Draft.Recursive")
Loading theory "Draft.Turing" (required by "Draft.RecursiveMoreTemplates" via "Draft.Recursive" via "Draft.Abacus" via "Draft.Turing_Hoare")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.RecursiveMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.RecursiveMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "HOL-Library.Function_Algebras"
### 0.137s elapsed time, 0.555s cpu time, 0.063s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.RecursiveMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.229s elapsed time, 0.888s cpu time, 0.105s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.RecursiveMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Nat_Bijection"
### 0.448s elapsed time, 1.780s cpu time, 0.168s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.RecursiveMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
Proofs for inductive predicate(s) "terminate"
  Proving monotonicity ...
Found termination order: "{}"
### theory "Draft.Rec_Def"
### 0.775s elapsed time, 3.065s cpu time, 0.302s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.RecursiveMoreTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "{}"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  snth :: "'a stream => nat => 'a"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
Found termination order: "{}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
class tape = type +
  fixes tape_of :: "'a => cell list"
instantiation
  nat :: tape
  tape_of_nat == tape_of :: nat => cell list
instantiation
  list :: (tape) tape
  tape_of_list == tape_of :: 'a list => cell list
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "length <*mlex*> {}"
### theory "HOL-Library.Stream"
### 1.075s elapsed time, 4.087s cpu time, 0.834s GC time
Found termination order: "size <*mlex*> {}"
instantiation
  prod :: (tape, tape) tape
  tape_of_prod == tape_of :: 'a * 'b => cell list
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.999s elapsed time, 3.565s cpu time, 0.724s GC time
### theory "Draft.Turing"
### 1.806s elapsed time, 6.732s cpu time, 1.088s GC time
Loading theory "Draft.Turing_Hoare" (required by "Draft.RecursiveMoreTemplates" via "Draft.Recursive" via "Draft.Abacus")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
### Ambiguous input (line 41 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" p) ("_Finset" ("_position" Q))))
###   ("\<^const>HOL.All_binder" ("_position" tp)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" tp))
###       ("\<^const>HOL.Ex_binder" ("_position" n)
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" is_final)
###             ("_applC" ("_position" steps0)
###               ("_cargs"
###                 ("_tuple" ("\<^const>Groups.one_class.one")
###                   ("_tuple_arg" ("_position" tp)))
###                 ("_cargs" ("_position" p) ("_position" n)))))
###           ("\<^const>Turing_Hoare.holds_for" ("_position" Q)
###             ("_applC" ("_position" steps0)
###               ("_cargs"
###                 ("_tuple" ("\<^const>Groups.one_class.one")
###                   ("_tuple_arg" ("_position" tp)))
###                 ("_cargs" ("_position" p) ("_position" n))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>Hoare_halt" ("_position" P) ("_position" p) ("_position" Q))
###   ("\<^const>HOL.All_binder" ("_position" tp)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" tp))
###       ("\<^const>HOL.Ex_binder" ("_position" n)
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" is_final)
###             ("_applC" ("_position" steps0)
###               ("_cargs"
###                 ("_tuple" ("\<^const>Groups.one_class.one")
###                   ("_tuple_arg" ("_position" tp)))
###                 ("_cargs" ("_position" p) ("_position" n)))))
###           ("\<^const>Turing_Hoare.holds_for" ("_position" Q)
###             ("_applC" ("_position" steps0)
###               ("_cargs"
###                 ("_tuple" ("\<^const>Groups.one_class.one")
###                   ("_tuple_arg" ("_position" tp)))
###                 ("_cargs" ("_position" p) ("_position" n))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 52 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" p) ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P) ("_position" p)
###     ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 73 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" A) ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P) ("_position" A)
###     ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 74 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" Q))
###     ("_cargs" ("_position" B) ("_Finset" ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" Q) ("_position" B)
###     ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 76 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing.tm_comp"
###     ("_applC" ("_Finset" ("_position" P)) ("_position" A))
###     ("_applC" ("_position" B) ("_Finset" ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("\<^const>Turing.tm_comp" ("_position" A) ("_position" B))
###     ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 111 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" A) ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P) ("_position" A)
###     ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 154 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" p) ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P) ("_position" p)
###     ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 155 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P'))
###     ("_cargs" ("_position" p) ("_Finset" ("_position" Q')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P') ("_position" p)
###     ("_position" Q')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "size <*mlex*> {}"
### theory "Draft.Turing_Hoare"
### 0.150s elapsed time, 0.349s cpu time, 0.083s GC time
Loading theory "Draft.Uncomputable" (required by "Draft.RecursiveMoreTemplates" via "Draft.Recursive" via "Draft.Abacus" via "Draft.Abacus_Mopup")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
### Ambiguous input (line 117 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("\<^const>Groups.zero_class.zero")
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_applC" ("_position" inv_begin1) ("_position" n))
###       ("_position" tcopy_begin)
###       ("_applC" ("_position" inv_begin0) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("\<^const>Groups.zero_class.zero")
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset" ("_applC" ("_position" inv_begin1) ("_position" n)))
###       ("_cargs" ("_position" tcopy_begin)
###         ("_Finset" ("_applC" ("_position" inv_begin0) ("_position" n)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
### theory "HOL-Library.Tree"
### 2.029s elapsed time, 6.553s cpu time, 1.085s GC time
Loading theory "Draft.Templates" (required by "Draft.RecursiveMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
### Ambiguous input (line 181 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("\<^const>Groups.zero_class.zero")
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_applC" ("_position" inv_begin1) ("_position" n))
###       ("_position" tcopy_begin)
###       ("_applC" ("_position" inv_begin0) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("\<^const>Groups.zero_class.zero")
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset" ("_applC" ("_position" inv_begin1) ("_position" n)))
###       ("_cargs" ("_position" tcopy_begin)
###         ("_Finset" ("_applC" ("_position" inv_begin0) ("_position" n)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.057s elapsed time, 0.113s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.RecursiveMoreTemplates")
Found termination order: "{}"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.847s elapsed time, 2.258s cpu time, 1.004s GC time
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 548 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" inv_loop1) ("_position" n))
###     ("_position" tcopy_loop)
###     ("_applC" ("_position" inv_loop0) ("_position" n))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_applC" ("_position" inv_loop1) ("_position" n)))
###     ("_cargs" ("_position" tcopy_loop)
###       ("_Finset" ("_applC" ("_position" inv_loop0) ("_position" n))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 784 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater" ("_position" n)
###       ("\<^const>Groups.zero_class.zero")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_applC" ("_position" inv_end1) ("_position" n))
###       ("_position" tcopy_end)
###       ("_applC" ("_position" inv_end0) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater" ("_position" n)
###       ("\<^const>Groups.zero_class.zero")))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_Finset" ("_applC" ("_position" inv_end1) ("_position" n)))
###       ("_cargs" ("_position" tcopy_end)
###         ("_Finset" ("_applC" ("_position" inv_end0) ("_position" n)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 815 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" inv_begin1) ("_position" x)) ("_position" tcopy)
###     ("_applC" ("_position" inv_end0) ("_position" x))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_applC" ("_position" inv_begin1) ("_position" x)))
###     ("_cargs" ("_position" tcopy)
###       ("_Finset" ("_applC" ("_position" inv_end0) ("_position" x))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 852 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" pre_tcopy) ("_position" n)) ("_position" tcopy)
###     ("_applC" ("_position" post_tcopy) ("_position" n))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_applC" ("_position" pre_tcopy) ("_position" n)))
###     ("_cargs" ("_position" tcopy)
###       ("_Finset" ("_applC" ("_position" post_tcopy) ("_position" n))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 907 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" dither_halt_inv))
###     ("_cargs" ("_position" dither)
###       ("_Finset" ("_position" dither_halt_inv)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" dither_halt_inv)
###     ("_position" dither) ("_position" dither_halt_inv)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 923 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" halts) ("_cargs" ("_position" p) ("_position" ns)))
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" tp)
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple" ("\<^const>List.list.Nil")
###             ("_tuple_arg"
###               ("\<^const>Turing.tape_class.tape_of" ("_position" ns)))))))
###     ("_cargs" ("_position" p)
###       ("_Finset"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" k)
###               ("_idts" ("_position" n) ("_position" l)))
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))
###                 ("_tuple_arg"
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.tape_class.tape_of"
###                       ("_constrain" ("_position" n) ("_type_name" nat)))
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" l))))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" halts) ("_cargs" ("_position" p) ("_position" ns)))
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" ns))))))
###     ("_position" p)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" k) ("_idts" ("_position" n) ("_position" l)))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" k))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_constrain" ("_position" n) ("_type_name" nat)))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" l))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 951 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" M) ("_position" ns))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" halts)
###         ("_cargs" ("_position" M) ("_position" ns))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" tp)
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple" ("_list" ("_position" Bk))
###                 ("_tuple_arg"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_tuple" ("_applC" ("_position" code) ("_position" M))
###                       ("_tuple_arg" ("_position" ns)))))))))
###         ("_cargs" ("_position" H)
###           ("_Finset"
###             ("_lambda" ("_position" tp)
###               ("\<^const>HOL.Ex_binder" ("_position" k)
###                 ("\<^const>HOL.eq" ("_position" tp)
###                   ("_tuple"
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" k))
###                     ("_tuple_arg"
###                       ("\<^const>Turing.tape_class.tape_of"
###                         ("_constrain" ("\<^const>Groups.zero_class.zero")
###                           ("_type_name" nat))))))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" M) ("_position" ns))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" halts)
###         ("_cargs" ("_position" M) ("_position" ns))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.eq" ("_position" tp)
###             ("_tuple" ("_list" ("_position" Bk))
###               ("_tuple_arg"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_tuple" ("_applC" ("_position" code) ("_position" M))
###                     ("_tuple_arg" ("_position" ns))))))))
###         ("_position" H)
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder" ("_position" k)
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))
###                 ("_tuple_arg"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_constrain" ("\<^const>Groups.zero_class.zero")
###                       ("_type_name" nat))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 953 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" M) ("_position" ns))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Not"
###         ("_applC" ("_position" halts)
###           ("_cargs" ("_position" M) ("_position" ns)))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" tp)
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple" ("_list" ("_position" Bk))
###                 ("_tuple_arg"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_tuple" ("_applC" ("_position" code) ("_position" M))
###                       ("_tuple_arg" ("_position" ns)))))))))
###         ("_cargs" ("_position" H)
###           ("_Finset"
###             ("_lambda" ("_position" tp)
###               ("\<^const>HOL.Ex_binder" ("_position" k)
###                 ("\<^const>HOL.eq" ("_position" tp)
###                   ("_tuple"
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" k))
###                     ("_tuple_arg"
###                       ("\<^const>Turing.tape_class.tape_of"
###                         ("_constrain" ("\<^const>Groups.one_class.one")
###                           ("_type_name" nat))))))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" M) ("_position" ns))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Not"
###         ("_applC" ("_position" halts)
###           ("_cargs" ("_position" M) ("_position" ns)))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.eq" ("_position" tp)
###             ("_tuple" ("_list" ("_position" Bk))
###               ("_tuple_arg"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_tuple" ("_applC" ("_position" code) ("_position" M))
###                     ("_tuple_arg" ("_position" ns))))))))
###         ("_position" H)
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder" ("_position" k)
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))
###                 ("_tuple_arg"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_constrain" ("\<^const>Groups.one_class.one")
###                       ("_type_name" nat))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale uncomputable
  fixes code :: "(action * nat) list => nat"
    and H :: "(action * nat) list"
  assumes "uncomputable code H"
### Ambiguous input (line 969 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_applC" ("_position" pre_H_inv)
###         ("_cargs" ("_position" M) ("_position" ns))))
###     ("_cargs" ("_position" H) ("_Finset" ("_position" post_H_halt_inv)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" pre_H_inv)
###       ("_cargs" ("_position" M) ("_position" ns)))
###     ("_position" H) ("_position" post_H_halt_inv)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 974 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_applC" ("_position" pre_H_inv)
###         ("_cargs" ("_position" M) ("_position" ns))))
###     ("_cargs" ("_position" H) ("_Finset" ("_position" post_H_unhalt_inv)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" pre_H_inv)
###       ("_cargs" ("_position" M) ("_position" ns)))
###     ("_position" H) ("_position" post_H_unhalt_inv)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Uncomputable"
### 2.589s elapsed time, 4.678s cpu time, 1.237s GC time
Loading theory "Draft.Abacus_Mopup" (required by "Draft.RecursiveMoreTemplates" via "Draft.Recursive" via "Draft.Abacus")
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### mopup_inv (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1 ==
### if ?s1 = 0 then mopup_stop (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
### else if ?s1 <= 2 * ?n1
###      then if ?s1 mod 2 = 1
###           then mopup_bef_erase_a (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###           else mopup_bef_erase_b (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###      else if ?s1 = 2 * ?n1 + 1
###           then mopup_jump_over1 (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###           else if ?s1 = 2 * ?n1 + 2
###                then mopup_aft_erase_a (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###                else if ?s1 = 2 * ?n1 + 3
###                     then mopup_aft_erase_b (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###                     else if ?s1 = 2 * ?n1 + 4
###                          then mopup_aft_erase_c (?s1, ?l1, ?r1) ?lm1 ?n1
###                                ?ires1
###                          else if ?s1 = 2 * ?n1 + 5
###                               then mopup_left_moving (?s1, ?l1, ?r1) ?lm1
###                                     ?n1 ?ires1
###                               else if ?s1 = 2 * ?n1 + 6
###                                    then mopup_jump_over2 (?s1, ?l1, ?r1)
###    ?lm1 ?n1 ?ires1
###                                    else False
### theory "Draft.Abacus_Mopup"
### 1.402s elapsed time, 2.129s cpu time, 1.015s GC time
Loading theory "Draft.Abacus" (required by "Draft.RecursiveMoreTemplates" via "Draft.Recursive")
### Ignoring duplicate rewrite rule:
### ?x1 \<up> Suc ?n1 == ?x1 # ?x1 \<up> ?n1
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### layout_of ?ap1 == map length_of ?ap1
### Rewrite rule not in simpset:
### step (?s1, ?l1, ?r1) (?p1, ?off1) ==
### let (a, s') = fetch ?p1 (?s1 - ?off1) (read ?r1)
### in (s', update a (?l1, ?r1))
### Rewrite rule not in simpset:
### steps ?y ?p1 0 == ?y
### Rewrite rule not in simpset:
### steps ?c1 ?p1 (Suc ?n1) == steps (step ?c1 ?p1) ?p1 ?n1
### Rewrite rule not in simpset:
### shift ?p1 ?n1 == map (%(a, s). (a, if s = 0 then 0 else s + ?n1)) ?p1
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### ci ?ly1 ?ss1 (Inc ?n1) == tinc ?ss1 ?n1
### Rewrite rule not in simpset:
### ci ?ly1 ?ss1 (Dec ?n1 ?e1) == tdec ?ss1 ?n1 (start_of ?ly1 ?e1)
### Rewrite rule not in simpset:
### ci ?ly1 ?ss1 (Goto ?n1) == tgoto (start_of ?ly1 ?n1)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### dec_inv_1 ?ly1 ?n1 ?e1 (?as1, ?am1) (?s1, ?l1, ?r1) ?ires1 ==
### let ss = start_of ?ly1 ?as1;
###     am' = abc_lm_s ?am1 ?n1 (abc_lm_v ?am1 ?n1 - Suc 0);
###     am'' = abc_lm_s ?am1 ?n1 (abc_lm_v ?am1 ?n1)
### in if ?s1 = start_of ?ly1 ?e1
###    then inv_stop (?as1, am'') (?s1, ?l1, ?r1) ?ires1
###    else if ?s1 = ss then False
###         else if ?s1 = ss + 2 * ?n1 + 1
###              then inv_locate_b (?as1, ?am1) (?n1, ?l1, ?r1) ?ires1
###              else if ?s1 = ss + 2 * ?n1 + 13
###                   then inv_on_left_moving (?as1, am'') (?s1, ?l1, ?r1)
###                         ?ires1
###                   else if ?s1 = ss + 2 * ?n1 + 14
###                        then inv_check_left_moving (?as1, am'')
###                              (?s1, ?l1, ?r1) ?ires1
###                        else if ?s1 = ss + 2 * ?n1 + 15
###                             then inv_after_left_moving (?as1, am'')
###                                   (?s1, ?l1, ?r1) ?ires1
###                             else False
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Draft.Abacus"
### 5.462s elapsed time, 5.996s cpu time, 0.707s GC time
Loading theory "Draft.Abacus_Hoare" (required by "Draft.RecursiveMoreTemplates" via "Draft.Recursive")
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 40 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_constrain" ("_position" p) ("_type_name" abc_prog))
###       ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" p) ("_type_name" abc_prog)) ("_position" Q)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" p) ("_type_name" abc_prog)) ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 57 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###     ("_constrain" ("_position" p) ("_type_name" abc_prog))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###     ("_constrain" ("_position" p) ("_type_name" abc_prog))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 287 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_constrain" ("_position" A) ("_type_name" abc_prog))
###       ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog)) ("_position" Q)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog)) ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 288 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" Q))
###     ("_cargs" ("_constrain" ("_position" B) ("_type_name" abc_prog))
###       ("_Finset" ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" Q)
###     ("_constrain" ("_position" B) ("_type_name" abc_prog)) ("_position" S)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" Q)
###     ("_constrain" ("_position" B) ("_type_name" abc_prog)) ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 289 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs"
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B))
###       ("_Finset" ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B))
###     ("_position" S)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###     ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B))
###     ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 322 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 345 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("_constrain" ("_position" A) ("_type_name" abc_prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("_constrain" ("_position" A) ("_type_name" abc_prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("_constrain" ("_position" A) ("_type_name" abc_prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("_constrain" ("_position" A) ("_type_name" abc_prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 360 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###     ("_constrain" ("_position" B) ("_type_name" abc_prog))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###     ("_constrain" ("_position" B) ("_type_name" abc_prog))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 361 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_constrain" ("_position" A) ("_type_name" abc_prog))
###       ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog)) ("_position" Q)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog)) ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 436 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 12 parse trees (10 displayed):
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_Finset" ("_position" P))
###           ("_cargs" ("_constrain" ("_position" A) ("_type_name" abc_prog))
###             ("_Finset" ("_position" Q)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_Finset" ("_position" P))
###           ("_cargs" ("_constrain" ("_position" A) ("_type_name" abc_prog))
###             ("_Finset" ("_position" Q)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Abacus_Hoare"
### 0.322s elapsed time, 0.416s cpu time, 0.087s GC time
Loading theory "Draft.Recursive" (required by "Draft.RecursiveMoreTemplates")
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order:
  "(%p. size_list (%p. size (snd (snd p))) (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### Rewrite rule not in simpset:
### rec_ci_s == addition 0 1 2 [+] [Inc 1]
### Rewrite rule not in simpset:
### rec_ci_z == [Goto 1]
### Rewrite rule not in simpset:
### abc_steps_l (?s1, ?lm1) ?p1 0 == (?s1, ?lm1)
### Rewrite rule not in simpset:
### abc_steps_l (?s1, ?lm1) ?p1 (Suc ?n1) ==
### abc_steps_l (abc_step_l (?s1, ?lm1) (abc_fetch ?s1 ?p1)) ?p1 ?n1
### Rewrite rule not in simpset:
### abc_fetch ?s1 ?p1 == if ?s1 < length ?p1 then Some (?p1 ! ?s1) else None
### Rewrite rule not in simpset:
### abc_step_l (?s1, ?lm1) ?a1 ==
### case ?a1 of None => (?s1, ?lm1)
### | Some (Inc n) =>
###     let nv = abc_lm_v ?lm1 n in (?s1 + 1, abc_lm_s ?lm1 n (nv + 1))
### | Some (Dec n e) =>
###     let nv = abc_lm_v ?lm1 n
###     in if nv = 0 then (e, abc_lm_s ?lm1 n 0)
###        else (?s1 + 1, abc_lm_s ?lm1 n (nv - 1))
### | Some (Goto n) => (n, ?lm1)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 328 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" a)
###       ("\<^const>HOL.eq" ("_position" a) ("_position" lm)))
###     ("_applC" ("_position" addition)
###       ("_cargs" ("_position" m) ("_cargs" ("_position" n) ("_position" p))))
###     ("_lambda" ("_position" nl)
###       ("_applC" ("_position" addition_inv)
###         ("_cargs"
###           ("_tuple" ("_Numeral" ("_constify" ("_position" 7)))
###             ("_tuple_arg" ("_position" nl)))
###           ("_cargs" ("_position" m)
###             ("_cargs" ("_position" n)
###               ("_cargs" ("_position" p) ("_position" lm)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" a)
###       ("\<^const>HOL.eq" ("_position" a) ("_position" lm)))
###     ("_applC" ("_position" addition)
###       ("_cargs" ("_position" m) ("_cargs" ("_position" n) ("_position" p))))
###     ("_lambda" ("_position" nl)
###       ("_applC" ("_position" addition_inv)
###         ("_cargs"
###           ("_tuple" ("_Numeral" ("_constify" ("_position" 7)))
###             ("_tuple_arg" ("_position" nl)))
###           ("_cargs" ("_position" m)
###             ("_cargs" ("_position" n)
###               ("_cargs" ("_position" p) ("_position" lm)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" a)
###         ("\<^const>HOL.eq" ("_position" a) ("_position" lm))))
###     ("_cargs"
###       ("_applC" ("_position" addition)
###         ("_cargs" ("_position" m)
###           ("_cargs" ("_position" n) ("_position" p))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("_applC" ("_position" addition_inv)
###             ("_cargs"
###               ("_tuple" ("_Numeral" ("_constify" ("_position" 7)))
###                 ("_tuple_arg" ("_position" nl)))
###               ("_cargs" ("_position" m)
###                 ("_cargs" ("_position" n)
###                   ("_cargs" ("_position" p) ("_position" lm)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 345 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("_position" n)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_Numeral" ("_constify" ("_position" 2))))
###             ("_position" anything)))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" addition)
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_cargs"
###             ("_applC" ("_position" Suc) ("\<^const>Groups.zero_class.zero"))
###             ("_Numeral" ("_constify" ("_position" 2))))))
###       ("_list"
###         ("_applC" ("_position" Inc)
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.zero_class.zero")))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("_position" n)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" Suc) ("_position" n))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("_position" n)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_Numeral" ("_constify" ("_position" 2))))
###             ("_position" anything)))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" addition)
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_cargs"
###             ("_applC" ("_position" Suc) ("\<^const>Groups.zero_class.zero"))
###             ("_Numeral" ("_constify" ("_position" 2))))))
###       ("_list"
###         ("_applC" ("_position" Inc)
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.zero_class.zero")))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("_position" n)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" Suc) ("_position" n))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_comp"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("_position" n)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_Numeral" ("_constify" ("_position" 2))))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" addition)
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_cargs"
###             ("_applC" ("_position" Suc) ("\<^const>Groups.zero_class.zero"))
###             ("_Numeral" ("_constify" ("_position" 2)))))))
###     ("_applC"
###       ("_list"
###         ("_applC" ("_position" Inc)
###           ("_applC" ("_position" Suc) ("\<^const>Groups.zero_class.zero"))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("_position" n)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" Suc) ("_position" n))
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 366 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" z))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" z) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" z))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" z) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" z))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" z) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("_position" n)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" ap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.list.Cons" ("_position" n)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 375 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" s))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" s) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" s))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" s) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" s))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" s) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("_position" n)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" ap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.list.Cons" ("_position" n)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 382 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_Numeral" ("_constify" ("_position" 2))))
###             ("_position" anything)))))
###     ("_applC" ("_position" addition)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_applC" ("_position" length) ("_position" args))
###           ("_applC" ("_position" Suc)
###             ("_applC" ("_position" length) ("_position" args))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" recf.id)
###                   ("_cargs"
###                     ("_applC" ("_position" length) ("_position" args))
###                     ("_position" n)))
###                 ("_position" args)))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_Numeral" ("_constify" ("_position" 2))))
###             ("_position" anything)))))
###     ("_applC" ("_position" addition)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_applC" ("_position" length) ("_position" args))
###           ("_applC" ("_position" Suc)
###             ("_applC" ("_position" length) ("_position" args))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" recf.id)
###                   ("_cargs"
###                     ("_applC" ("_position" length) ("_position" args))
###                     ("_position" n)))
###                 ("_position" args)))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_Numeral" ("_constify" ("_position" 2))))
###               ("_position" anything))))))
###     ("_cargs" ("_position" addition)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_applC" ("_position" length) ("_position" args))
###           ("_cargs"
###             ("_applC" ("_position" Suc)
###               ("_applC" ("_position" length) ("_position" args)))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" args)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" recf.id)
###                             ("_cargs"
###                               ("_applC" ("_position" length)
###                                 ("_position" args))
###                               ("_position" n)))
###                           ("_position" args)))
###                       ("\<^const>List.list.Cons"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 396 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" n) ("_position" m)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" m)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("_applC" ("_position" recf.id)
###                 ("_cargs" ("_position" m) ("_position" n))))
###             ("_tuple" ("_position" ap)
###               ("_tuple_args" ("_position" arity)
###                 ("_tuple_arg" ("_position" fp))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" recf.id)
###                     ("_cargs" ("_position" m) ("_position" n)))
###                   ("_position" xs)))
###               ("_position" r)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" n) ("_position" m)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" m)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("_applC" ("_position" recf.id)
###                 ("_cargs" ("_position" m) ("_position" n))))
###             ("_tuple" ("_position" ap)
###               ("_tuple_args" ("_position" arity)
###                 ("_tuple_arg" ("_position" fp))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" recf.id)
###                     ("_cargs" ("_position" m) ("_position" n)))
###                   ("_position" xs)))
###               ("_position" r)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" n) ("_position" m)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" m)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("_applC" ("_position" recf.id)
###                 ("_cargs" ("_position" m) ("_position" n))))
###             ("_tuple" ("_position" ap)
###               ("_tuple_args" ("_position" arity)
###                 ("_tuple_arg" ("_position" fp))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" recf.id)
###                     ("_cargs" ("_position" m) ("_position" n)))
###                   ("_position" xs)))
###               ("_position" r)))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" ap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 593 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.greater"
###         ("_applC" ("_position" length) ("_position" lm))
###         ("_applC" ("_position" max)
###           ("_cargs" ("_position" m) ("_position" n)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" m) ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm)))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" m) ("_position" n)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("_LUpdate" ("_position" lm)
###             ("_lupdbinds"
###               ("_lupdbind" ("_position" n)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("\<^const>List.nth" ("_position" lm) ("_position" m))
###                   ("\<^const>List.nth" ("_position" lm) ("_position" n))))
###               ("_lupdbind" ("_position" m)
###                 ("\<^const>Groups.zero_class.zero")))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.greater"
###         ("_applC" ("_position" length) ("_position" lm))
###         ("_applC" ("_position" max)
###           ("_cargs" ("_position" m) ("_position" n)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" m) ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm)))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" m) ("_position" n)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("_LUpdate" ("_position" lm)
###             ("_lupdbinds"
###               ("_lupdbind" ("_position" n)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("\<^const>List.nth" ("_position" lm) ("_position" m))
###                   ("\<^const>List.nth" ("_position" lm) ("_position" n))))
###               ("_lupdbind" ("_position" m)
###                 ("\<^const>Groups.zero_class.zero")))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.greater"
###         ("_applC" ("_position" length) ("_position" lm))
###         ("_applC" ("_position" max)
###           ("_cargs" ("_position" m) ("_position" n)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" m) ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl) ("_position" lm))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" m)
###           ("_cargs" ("_position" n)
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("_LUpdate" ("_position" lm)
###                     ("_lupdbinds"
###                       ("_lupdbind" ("_position" n)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("\<^const>List.nth" ("_position" lm)
###                             ("_position" m))
###                           ("\<^const>List.nth" ("_position" lm)
###                             ("_position" n))))
###                       ("_lupdbind" ("_position" m)
###                         ("\<^const>Groups.zero_class.zero")))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 615 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g)
###     ("_applC" ("_position" set)
###       ("_applC" ("_position" take)
###         ("_cargs" ("_position" n) ("_position" gs))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g)
###     ("_applC" ("_position" set)
###       ("_applC" ("_position" take)
###         ("_cargs" ("_position" n) ("_position" gs))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g)
###     ("_applC" ("_position" set)
###       ("_applC" ("_position" take)
###         ("_cargs" ("_position" n) ("_position" gs))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb) ("_position" xa)))
###                         ("_position" xc))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs)))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 619 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("_applC" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci)
###             ("_applC" ("_position" take)
###               ("_cargs" ("_position" n) ("_position" gs)))))
###         ("_position" ft)))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_applC" ("_position" take)
###                     ("_cargs" ("_position" n) ("_position" gs)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" length) ("_position" gs))
###                     ("_position" n)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_position" anything))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("_applC" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci)
###             ("_applC" ("_position" take)
###               ("_cargs" ("_position" n) ("_position" gs)))))
###         ("_position" ft)))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_applC" ("_position" take)
###                     ("_cargs" ("_position" n) ("_position" gs)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" length) ("_position" gs))
###                     ("_position" n)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_position" anything))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                     ("_applC" ("_position" length) ("_position" gs))))
###                 ("_position" anything)))))))
###     ("_cargs" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci)
###             ("_applC" ("_position" take)
###               ("_cargs" ("_position" n) ("_position" gs)))))
###         ("_cargs" ("_position" ft)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                         ("_applC" ("_position" length) ("_position" xs))))
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs"
###                           ("_lambda" ("_position" i)
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs" ("_position" i) ("_position" xs))))
###                           ("_applC" ("_position" take)
###                             ("_cargs" ("_position" n) ("_position" gs)))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_applC" ("_position" length) ("_position" gs))
###                             ("_position" n)))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("_applC" ("_position" Suc)
###                               ("_applC" ("_position" length)
###                                 ("_position" xs))))
###                           ("_position" anything))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 775 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb) ("_position" xa)))
###                         ("_position" xc))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs)))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 779 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("_applC" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci) ("_position" gs)))
###         ("_position" ft)))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("_applC" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci) ("_position" gs)))
###         ("_position" ft)))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                     ("_applC" ("_position" length) ("_position" gs))))
###                 ("_position" anything)))))))
###     ("_cargs" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci) ("_position" gs)))
###         ("_cargs" ("_position" ft)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                         ("_applC" ("_position" length) ("_position" xs))))
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs"
###                           ("_lambda" ("_position" i)
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs" ("_position" i) ("_position" xs))))
###                           ("_position" gs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs))))
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 853 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq"
###         ("\<^const>Groups.plus_class.plus" ("_position" aa) ("_position" n))
###         ("_position" ba)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length) ("_position" lm1))
###             ("_position" aa)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length) ("_position" lm2))
###               ("_position" n)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length) ("_position" lm3))
###                 ("\<^const>Groups.minus_class.minus"
###                   ("\<^const>Groups.minus_class.minus" ("_position" ba)
###                     ("_position" aa))
###                   ("_position" n)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append" ("_position" lm2)
###               ("\<^const>List.append" ("_position" lm3)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_position" lm4)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs" ("_position" aa)
###           ("_cargs" ("_position" ba) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" n))
###               ("\<^const>List.append" ("_position" lm3)
###                 ("\<^const>List.append" ("_position" lm2)
###                   ("_position" lm4))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq"
###         ("\<^const>Groups.plus_class.plus" ("_position" aa) ("_position" n))
###         ("_position" ba)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length) ("_position" lm1))
###             ("_position" aa)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length) ("_position" lm2))
###               ("_position" n)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length) ("_position" lm3))
###                 ("\<^const>Groups.minus_class.minus"
###                   ("\<^const>Groups.minus_class.minus" ("_position" ba)
###                     ("_position" aa))
###                   ("_position" n)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append" ("_position" lm2)
###               ("\<^const>List.append" ("_position" lm3)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_position" lm4)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs" ("_position" aa)
###           ("_cargs" ("_position" ba) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" n))
###               ("\<^const>List.append" ("_position" lm3)
###                 ("\<^const>List.append" ("_position" lm2)
###                   ("_position" lm4))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq"
###         ("\<^const>Groups.plus_class.plus" ("_position" aa) ("_position" n))
###         ("_position" ba)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length) ("_position" lm1))
###             ("_position" aa)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length) ("_position" lm2))
###               ("_position" n)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length) ("_position" lm3))
###                 ("\<^const>Groups.minus_class.minus"
###                   ("\<^const>Groups.minus_class.minus" ("_position" ba)
###                     ("_position" aa))
###                   ("_position" n)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" lm1)
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append" ("_position" lm3)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero") ("_position" n))
###                     ("_position" lm4))))))))
###       ("_cargs"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("_position" aa)
###             ("_cargs" ("_position" ba) ("_position" n))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" lm1)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("\<^const>List.append" ("_position" lm3)
###                     ("\<^const>List.append" ("_position" lm2)
###                       ("_position" lm4))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 920 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq" ("_position" n)
###         ("\<^const>Groups.minus_class.minus" ("_position" aa)
###           ("_position" ba))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length)
###               ("_constrain" ("_position" lm1)
###                 ("_tapp" ("_type_name" nat) ("_type_name" list))))
###             ("_position" ba)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length)
###                 ("_constrain" ("_position" lm2)
###                   ("_tapp" ("_type_name" nat) ("_type_name" list))))
###               ("\<^const>Groups.minus_class.minus"
###                 ("\<^const>Groups.minus_class.minus" ("_position" aa)
###                   ("_position" ba))
###                 ("_position" n))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length)
###                   ("_constrain" ("_position" lm3)
###                     ("_tapp" ("_type_name" nat) ("_type_name" list))))
###                 ("_position" n))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" n))
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append" ("_position" lm3)
###                   ("_position" lm4)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs" ("_position" aa)
###           ("_cargs" ("_position" ba) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append" ("_position" lm3)
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_position" lm4))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq" ("_position" n)
###         ("\<^const>Groups.minus_class.minus" ("_position" aa)
###           ("_position" ba))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length)
###               ("_constrain" ("_position" lm1)
###                 ("_tapp" ("_type_name" nat) ("_type_name" list))))
###             ("_position" ba)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length)
###                 ("_constrain" ("_position" lm2)
###                   ("_tapp" ("_type_name" nat) ("_type_name" list))))
###               ("\<^const>Groups.minus_class.minus"
###                 ("\<^const>Groups.minus_class.minus" ("_position" aa)
###                   ("_position" ba))
###                 ("_position" n))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length)
###                   ("_constrain" ("_position" lm3)
###                     ("_tapp" ("_type_name" nat) ("_type_name" list))))
###                 ("_position" n))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" n))
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append" ("_position" lm3)
###                   ("_position" lm4)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs" ("_position" aa)
###           ("_cargs" ("_position" ba) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append" ("_position" lm3)
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_position" lm4))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq" ("_position" n)
###         ("\<^const>Groups.minus_class.minus" ("_position" aa)
###           ("_position" ba))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length)
###               ("_constrain" ("_position" lm1)
###                 ("_tapp" ("_type_name" nat) ("_type_name" list))))
###             ("_position" ba)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length)
###                 ("_constrain" ("_position" lm2)
###                   ("_tapp" ("_type_name" nat) ("_type_name" list))))
###               ("\<^const>Groups.minus_class.minus"
###                 ("\<^const>Groups.minus_class.minus" ("_position" aa)
###                   ("_position" ba))
###                 ("_position" n))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length)
###                   ("_constrain" ("_position" lm3)
###                     ("_tapp" ("_type_name" nat) ("_type_name" list))))
###                 ("_position" n))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" lm1)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero") ("_position" n))
###                 ("\<^const>List.append" ("_position" lm2)
###                   ("\<^const>List.append" ("_position" lm3)
###                     ("_position" lm4))))))))
###       ("_cargs"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("_position" aa)
###             ("_cargs" ("_position" ba) ("_position" n))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" lm1)
###                 ("\<^const>List.append" ("_position" lm3)
###                   ("\<^const>List.append" ("_position" lm2)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero") ("_position" n))
###                       ("_position" lm4))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| max ?m ?n < length ?lm; ?m ~= ?n |]
==> {%nl. nl = ?lm} mv_box ?m ?n
    {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}
### Ambiguous input (line 979 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs)))))))))
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("_position" anything)))))))
###     ("_applC" ("_position" mv_boxes)
###       ("_cargs" ("\<^const>Groups.zero_class.zero")
###         ("_cargs"
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_applC" ("_position" length) ("_position" gs))))
###           ("_applC" ("_position" length) ("_position" xs)))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs))))))))))
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append" ("_position" xs)
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs)))))))))
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("_position" anything)))))))
###     ("_applC" ("_position" mv_boxes)
###       ("_cargs" ("\<^const>Groups.zero_class.zero")
###         ("_cargs"
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_applC" ("_position" length) ("_position" gs))))
###           ("_applC" ("_position" length) ("_position" xs)))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs))))))))))
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append" ("_position" xs)
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" i)
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" i) ("_position" xs))))
###                     ("_position" gs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_position" anything))))))))
###     ("_cargs" ("_position" mv_boxes)
###       ("_cargs" ("\<^const>Groups.zero_class.zero")
###         ("_cargs"
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_applC" ("_position" length) ("_position" gs))))
###           ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs))))))))))
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs"
###                           ("_lambda" ("_position" i)
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs" ("_position" i) ("_position" xs))))
###                           ("_position" gs)))
###                       ("\<^const>List.list.Cons"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_position" anything))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1000 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs"
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set) ("_position" gs)))))))))
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" gs)))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs))))))))))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs"
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set) ("_position" gs)))))))))
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" gs)))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs))))))))))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs))))))))))
###               ("\<^const>List.append"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" i)
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" i) ("_position" xs))))
###                     ("_position" gs)))
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything))))))))
###       ("_cargs" ("_position" mv_boxes)
###         ("_cargs"
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set) ("_position" gs)))))))))
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_cargs" ("_applC" ("_position" length) ("_position" gs))
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs"
###                           ("_lambda" ("_position" i)
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs" ("_position" i) ("_position" xs))))
###                           ("_position" gs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs))))))))))
###                         ("\<^const>List.list.Cons"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_position" anything)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1025 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" far)
###         ("_applC" ("_position" length) ("_position" gs))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less_eq" ("_position" ffp)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Orderings.ord_class.less" ("_position" far)
###             ("_position" ffp))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs))))))))))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" far)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything)))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" far)
###         ("_applC" ("_position" length) ("_position" gs))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less_eq" ("_position" ffp)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Orderings.ord_class.less" ("_position" far)
###             ("_position" ffp))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs))))))))))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" far)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything)))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" far)
###         ("_applC" ("_position" length) ("_position" gs))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less_eq" ("_position" ffp)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Orderings.ord_class.less" ("_position" far)
###             ("_position" ffp))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" length) ("_position" xs)))
###                         ("_applC" ("_position" Max)
###                           ("_applC" ("_position" insert)
###                             ("_cargs" ("_position" ffp)
###                               ("\<^const>Set.image"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" aprog)
###                                     ("_patterns" ("_position" p)
### ("_position" n)))
###                                   ("_position" n))
###                                 ("\<^const>Set.image" ("_position" rec_ci)
###                                   ("_applC" ("_position" set)
###                                     ("_position" gs))))))))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything))))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" far)
###           ("_cargs"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs)))))))))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append"
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" i)
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" i) ("_position" xs))))
###                         ("_position" gs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" gs))))
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Cn)
###                               ("_cargs"
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs))
###                                 ("_cargs" ("_position" f)
###                                   ("_position" gs))))
###                             ("_position" xs)))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("_applC" ("_position" length)
###                               ("_position" gs)))
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_position" anything)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| max ?m ?n < length ?lm; ?m ~= ?n |]
==> {%nl. nl = ?lm} mv_box ?m ?n
    {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}
### Ambiguous input (line 1062 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_position" n))
###           ("\<^const>List.list.Cons" ("_position" x) ("_position" lm)))))
###     ("_list"
###       ("_args"
###         ("_applC" ("_position" Dec)
###           ("_cargs" ("_position" n)
###             ("_Numeral" ("_constify" ("_position" 2)))))
###         ("_applC" ("_position" Goto) ("\<^const>Groups.zero_class.zero"))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("_position" lm)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_position" n))
###           ("\<^const>List.list.Cons" ("_position" x) ("_position" lm)))))
###     ("_list"
###       ("_args"
###         ("_applC" ("_position" Dec)
###           ("_cargs" ("_position" n)
###             ("_Numeral" ("_constify" ("_position" 2)))))
###         ("_applC" ("_position" Goto) ("\<^const>Groups.zero_class.zero"))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("_position" lm)))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("\<^const>List.list.Cons" ("_position" x) ("_position" lm))))))
###     ("_cargs"
###       ("_list"
###         ("_args"
###           ("_applC" ("_position" Dec)
###             ("_cargs" ("_position" n)
###               ("_Numeral" ("_constify" ("_position" 2)))))
###           ("_applC" ("_position" Goto)
###             ("\<^const>Groups.zero_class.zero"))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero") ("_position" n))
###                 ("_position" lm)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1092 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq"
###       ("_applC" ("_position" length) ("_position" lm)) ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm)))
###       ("_applC" ("_position" empty_boxes) ("_position" n))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("_applC" ("_position" drop)
###               ("_cargs" ("_position" n) ("_position" lm)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq"
###       ("_applC" ("_position" length) ("_position" lm)) ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm)))
###       ("_applC" ("_position" empty_boxes) ("_position" n))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("_applC" ("_position" drop)
###               ("_cargs" ("_position" n) ("_position" lm)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq"
###       ("_applC" ("_position" length) ("_position" lm)) ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl) ("_position" lm))))
###       ("_cargs" ("_position" empty_boxes)
###         ("_cargs" ("_position" n)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_applC" ("_position" drop)
###                     ("_cargs" ("_position" n) ("_position" lm))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1128 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything))))))))
###       ("_applC" ("_position" empty_boxes)
###         ("_applC" ("_position" length) ("_position" gs)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything))))))))
###       ("_applC" ("_position" empty_boxes)
###         ("_applC" ("_position" length) ("_position" gs)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" length) ("_position" xs)))
###                         ("_applC" ("_position" Max)
###                           ("_applC" ("_position" insert)
###                             ("_cargs" ("_position" ffp)
###                               ("\<^const>Set.image"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" aprog)
###                                     ("_patterns" ("_position" p)
### ("_position" n)))
###                                   ("_position" n))
###                                 ("\<^const>Set.image" ("_position" rec_ci)
###                                   ("_applC" ("_position" set)
###                                     ("_position" gs)))))))))
###                     ("_applC" ("_position" length) ("_position" gs))))
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Cn)
###                         ("_cargs"
###                           ("_applC" ("_position" length) ("_position" xs))
###                           ("_cargs" ("_position" f) ("_position" gs))))
###                       ("_position" xs)))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("_applC" ("_position" length) ("_position" gs)))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_position" anything)))))))))
###       ("_cargs" ("_position" empty_boxes)
###         ("_cargs" ("_applC" ("_position" length) ("_position" gs))
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" length) ("_position" xs)))
###                         ("_applC" ("_position" Max)
###                           ("_applC" ("_position" insert)
###                             ("_cargs" ("_position" ffp)
###                               ("\<^const>Set.image"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" aprog)
###                                     ("_patterns" ("_position" p)
### ("_position" n)))
###                                   ("_position" n))
###                                 ("\<^const>Set.image" ("_position" rec_ci)
###                                   ("_applC" ("_position" set)
###                                     ("_position" gs))))))))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Cn)
###                           ("_cargs"
###                             ("_applC" ("_position" length) ("_position" xs))
###                             ("_cargs" ("_position" f) ("_position" gs))))
###                         ("_position" xs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("_applC" ("_position" length) ("_position" gs)))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1152 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs))))))))))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))
###               ("\<^const>List.append" ("_position" xs)
###                 ("_position" anything)))))))
###     ("_applC" ("_position" mv_box)
###       ("_cargs"
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("_applC" ("_position" Suc)
###               ("_applC" ("_position" length) ("_position" xs)))
###             ("_applC" ("_position" Max)
###               ("_applC" ("_position" insert)
###                 ("_cargs" ("_position" ffp)
###                   ("\<^const>Set.image"
###                     ("_lambda"
###                       ("_pattern" ("_position" aprog)
###                         ("_patterns" ("_position" p) ("_position" n)))
###                       ("_position" n))
###                     ("\<^const>Set.image" ("_position" rec_ci)
###                       ("_applC" ("_position" set) ("_position" gs)))))))))
###         ("_applC" ("_position" length) ("_position" xs))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" xs)))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs))))))))))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))
###               ("\<^const>List.append" ("_position" xs)
###                 ("_position" anything)))))))
###     ("_applC" ("_position" mv_box)
###       ("_cargs"
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("_applC" ("_position" Suc)
###               ("_applC" ("_position" length) ("_position" xs)))
###             ("_applC" ("_position" Max)
###               ("_applC" ("_position" insert)
###                 ("_cargs" ("_position" ffp)
###                   ("\<^const>Set.image"
###                     ("_lambda"
###                       ("_pattern" ("_position" aprog)
###                         ("_patterns" ("_position" p) ("_position" n)))
###                       ("_position" n))
###                     ("\<^const>Set.image" ("_position" rec_ci)
###                       ("_applC" ("_position" set) ("_position" gs)))))))))
###         ("_applC" ("_position" length) ("_position" xs))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" xs)))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))
###     ("_cargs" ("_position" mv_box)
###       ("_cargs"
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("_applC" ("_position" Suc)
###               ("_applC" ("_position" length) ("_position" xs)))
###             ("_applC" ("_position" Max)
###               ("_applC" ("_position" insert)
###                 ("_cargs" ("_position" ffp)
###                   ("\<^const>Set.image"
###                     ("_lambda"
###                       ("_pattern" ("_position" aprog)
###                         ("_patterns" ("_position" p) ("_position" n)))
###                       ("_position" n))
###                     ("\<^const>Set.image" ("_position" rec_ci)
###                       ("_applC" ("_position" set) ("_position" gs)))))))))
###         ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Cn)
###                           ("_cargs"
###                             ("_applC" ("_position" length) ("_position" xs))
###                             ("_cargs" ("_position" f) ("_position" gs))))
###                         ("_position" xs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" xs))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("_applC" ("_position" length) ("_position" gs)))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_position" anything))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| max ?m ?n < length ?lm; ?m ~= ?n |]
==> {%nl. nl = ?lm} mv_box ?m ?n
    {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}
### Ambiguous input (line 1176 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" xs)))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))
###     ("_applC" ("_position" mv_boxes)
###       ("_cargs"
###         ("_applC" ("_position" Suc)
###           ("\<^const>Groups.plus_class.plus"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs)))))))))
###             ("_applC" ("_position" length) ("_position" gs))))
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" length) ("_position" xs)))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" xs)))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))
###     ("_applC" ("_position" mv_boxes)
###       ("_cargs"
###         ("_applC" ("_position" Suc)
###           ("\<^const>Groups.plus_class.plus"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs)))))))))
###             ("_applC" ("_position" length) ("_position" gs))))
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" length) ("_position" xs)))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" length) ("_position" xs)))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" length) ("_position" xs)))
###                         ("_applC" ("_position" Max)
###                           ("_applC" ("_position" insert)
###                             ("_cargs" ("_position" ffp)
###                               ("\<^const>Set.image"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" aprog)
###                                     ("_patterns" ("_position" p)
### ("_position" n)))
###                                   ("_position" n))
###                                 ("\<^const>Set.image" ("_position" rec_ci)
###                                   ("_applC" ("_position" set)
###                                     ("_position" gs)))))))))
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything)))))))))
###     ("_cargs" ("_position" mv_boxes)
###       ("_cargs"
###         ("_applC" ("_position" Suc)
###           ("\<^const>Groups.plus_class.plus"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs)))))))))
###             ("_applC" ("_position" length) ("_position" gs))))
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" Cn)
###                             ("_cargs"
###                               ("_applC" ("_position" length)
###                                 ("_position" xs))
###                               ("_cargs" ("_position" f) ("_position" gs))))
###                           ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.plus_class.plus"
###                             ("_applC" ("_position" max)
###                               ("_cargs"
###                                 ("_applC" ("_position" Suc)
###                                   ("_applC" ("_position" length)
###                                     ("_position" xs)))
###                                 ("_applC" ("_position" Max)
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs" ("_position" ffp)
### ("\<^const>Set.image"
###   ("_lambda"
###     ("_pattern" ("_position" aprog)
###       ("_patterns" ("_position" p) ("_position" n)))
###     ("_position" n))
###   ("\<^const>Set.image" ("_position" rec_ci)
###     ("_applC" ("_position" set) ("_position" gs)))))))))
###                             ("_applC" ("_position" length)
###                               ("_position" gs))))
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| ?n <= ?aa - ?ba; ?ba < ?aa; length ?lm1.0 = ?ba;
   length ?lm2.0 = ?aa - ?ba - ?n; length ?lm3.0 = ?n |]
==> {%nl. nl = ?lm1.0 @ 0 \<up> ?n @ ?lm2.0 @ ?lm3.0 @ ?lm4.0}
    mv_boxes ?aa ?ba ?n
    {%nl. nl = ?lm1.0 @ ?lm3.0 @ ?lm2.0 @ 0 \<up> ?n @ ?lm4.0}
### Ambiguous input (line 1195 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" anything) ("_position" r))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" rec_exec)
###           ("_cargs" ("_position" f)
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" g)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" g) ("_position" xs))))
###                 ("_position" gs)))))
###         ("_applC" ("_position" rec_exec)
###           ("_cargs"
###             ("_applC" ("_position" Cn)
###               ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                 ("_cargs" ("_position" f) ("_position" gs))))
###             ("_position" xs)))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                     ("_position" far)))
###                 ("_position" anything)))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" anything) ("_position" r))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" rec_exec)
###           ("_cargs" ("_position" f)
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" g)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" g) ("_position" xs))))
###                 ("_position" gs)))))
###         ("_applC" ("_position" rec_exec)
###           ("_cargs"
###             ("_applC" ("_position" Cn)
###               ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                 ("_cargs" ("_position" f) ("_position" gs))))
###             ("_position" xs)))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                     ("_position" far)))
###                 ("_position" anything)))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" anything) ("_position" r))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" rec_exec)
###           ("_cargs" ("_position" f)
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" g)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" g) ("_position" xs))))
###                 ("_position" gs)))))
###         ("_applC" ("_position" rec_exec)
###           ("_cargs"
###             ("_applC" ("_position" Cn)
###               ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                 ("_cargs" ("_position" f) ("_position" gs))))
###             ("_position" xs)))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" g)
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs))))
###                     ("_position" gs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                       ("_position" far)))
###                   ("_position" anything))))))
###         ("_cargs" ("_position" fap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs"
###                       ("_lambda" ("_position" g)
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g) ("_position" xs))))
###                       ("_position" gs)))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Cn)
###                           ("_cargs"
###                             ("_applC" ("_position" length) ("_position" xs))
###                             ("_cargs" ("_position" f) ("_position" gs))))
###                         ("_position" xs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" ffp)
###                           ("_applC" ("_position" Suc) ("_position" far))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1200 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb) ("_position" xa)))
###                         ("_position" xc))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs)))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1204 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" cn_merge_gs)
###         ("_cargs"
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" rec_ci) ("_position" gs)))
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_applC" ("_position" length) ("_position" xs)))))
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_boxes)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_cargs" ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))))
###           ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_applC" ("_position" mv_box)
###                 ("_cargs" ("_position" far)
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))))
###               ("\<^const>Abacus_Hoare.abc_comp"
###                 ("_applC" ("_position" empty_boxes)
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>Abacus_Hoare.abc_comp"
###                   ("_applC" ("_position" mv_box)
###                     ("_cargs"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_applC" ("_position" mv_boxes)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" gs))))
###                       ("_cargs" ("\<^const>Groups.zero_class.zero")
###                         ("_applC" ("_position" length)
###                           ("_position" xs))))))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" cn_merge_gs)
###         ("_cargs"
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" rec_ci) ("_position" gs)))
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_applC" ("_position" length) ("_position" xs)))))
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_boxes)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_cargs" ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))))
###           ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_applC" ("_position" mv_box)
###                 ("_cargs" ("_position" far)
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))))
###               ("\<^const>Abacus_Hoare.abc_comp"
###                 ("_applC" ("_position" empty_boxes)
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>Abacus_Hoare.abc_comp"
###                   ("_applC" ("_position" mv_box)
###                     ("_cargs"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_applC" ("_position" mv_boxes)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" gs))))
###                       ("_cargs" ("\<^const>Groups.zero_class.zero")
###                         ("_applC" ("_position" length)
###                           ("_position" xs))))))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_comp"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" gs))))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" cn_merge_gs)
###         ("_cargs"
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" rec_ci) ("_position" gs)))
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs))))))))))))
###     ("_applC"
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_applC" ("_position" length) ("_position" xs)))))
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_boxes)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_cargs" ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))))
###           ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_applC" ("_position" mv_box)
###                 ("_cargs" ("_position" far)
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))))
###               ("\<^const>Abacus_Hoare.abc_comp"
###                 ("_applC" ("_position" empty_boxes)
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>Abacus_Hoare.abc_comp"
###                   ("_applC" ("_position" mv_box)
###                     ("_cargs"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_applC" ("_position" mv_boxes)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" gs))))
###                       ("_cargs" ("\<^const>Groups.zero_class.zero")
###                         ("_applC" ("_position" length)
###                           ("_position" xs)))))))))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" gs))))
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1305 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f)
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" g)
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs))))
###                         ("_position" gs)))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f)
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" g)
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs))))
###                         ("_position" gs)))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" g)
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs))))
###                     ("_position" gs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_position" arity)))
###                   ("_position" anything))))))
###         ("_cargs" ("_position" ap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs"
###                       ("_lambda" ("_position" g)
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g) ("_position" xs))))
###                       ("_position" gs)))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" f)
###                         ("_applC" ("_position" map)
###                           ("_cargs"
###                             ("_lambda" ("_position" g)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs" ("_position" g)
###                                   ("_position" xs))))
###                             ("_position" gs)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" fp)
###                           ("_applC" ("_position" Suc) ("_position" arity))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1310 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb) ("_position" xa)))
###                         ("_position" xc))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs)))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1314 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_position" n)
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_position" n)
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything))))))
###     ("_cargs" ("_position" ap)
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1329 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n) ("_position" ft)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n) ("_position" ft)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_position" n)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_position" ft)
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" ft) ("_position" n)))
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1339 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" Suc) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc) ("_position" n))))
###                   ("_position" anything))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" Suc) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc) ("_position" n))))
###                   ("_position" anything))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_position" n)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" f) ("_position" xs)))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" ft)
###                               ("_applC" ("_position" Suc) ("_position" n))))
###                           ("_position" anything))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1354 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_constrain"
###                             ("_Numeral" ("_constify" ("_position" 3)))
###                             ("_type_name" nat)))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("\<^const>Groups.plus_class.plus" ("_position" n)
###                         ("_Numeral" ("_constify" ("_position" 3))))
###                       ("_applC" ("_position" max)
###                         ("_cargs" ("_position" fft) ("_position" gft)))))
###                   ("_position" n)))
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_constrain"
###                             ("_Numeral" ("_constify" ("_position" 3)))
###                             ("_type_name" nat)))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("\<^const>Groups.plus_class.plus" ("_position" n)
###                         ("_Numeral" ("_constify" ("_position" 3))))
###                       ("_applC" ("_position" max)
###                         ("_cargs" ("_position" fft) ("_position" gft)))))
###                   ("_position" n)))
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_constrain"
###                               ("_Numeral" ("_constify" ("_position" 3)))
###                               ("_type_name" nat)))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_position" n)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_cargs"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("\<^const>Groups.plus_class.plus" ("_position" n)
###                   ("_Numeral" ("_constify" ("_position" 3))))
###                 ("_applC" ("_position" max)
###                   ("_cargs" ("_position" fft) ("_position" gft)))))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("\<^const>Groups.plus_class.plus"
###                                 ("_position" n)
###                                 ("_Numeral" ("_constify" ("_position" 3))))
###                               ("_applC" ("_position" max)
###                                 ("_cargs" ("_position" fft)
###                                   ("_position" gft)))))
###                           ("_position" n)))
###                       ("\<^const>List.list.Cons" ("_position" x)
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| max ?m ?n < length ?lm; ?m ~= ?n |]
==> {%nl. nl = ?lm} mv_box ?m ?n
    {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}
### Ambiguous input (line 1391 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("\<^const>List.list.Cons" ("_position" x)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" Suc) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_Numeral" ("_constify" ("_position" 3))))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons" ("_position" x)
###                     ("_position" anything)))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("\<^const>List.list.Cons" ("_position" x)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" Suc) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_Numeral" ("_constify" ("_position" 3))))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons" ("_position" x)
###                     ("_position" anything)))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_Numeral" ("_constify" ("_position" 3))))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_applC" ("_position" Suc) ("_position" n))))
###                   ("\<^const>List.list.Cons" ("_position" x)
###                     ("_position" anything))))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" f) ("_position" xs)))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_applC" ("_position" max)
###                                 ("_cargs"
###                                   ("\<^const>Groups.plus_class.plus"
###                                     ("_position" n)
###                                     ("_Numeral"
### ("_constify" ("_position" 3))))
###                                   ("_applC" ("_position" max)
###                                     ("_cargs" ("_position" fft)
### ("_position" gft)))))
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" n)))))
###                           ("\<^const>List.list.Cons" ("_position" x)
###                             ("_position" anything)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1477 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" ft)
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("_Numeral" ("_constify" ("_position" 3))))
###             ("_applC" ("_position" max)
###               ("_cargs" ("_position" fft) ("_position" gft)))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("_applC" ("_position" Suc) ("_position" y)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list"
###                         ("\<^const>Groups.minus_class.minus" ("_position" x)
###                           ("_applC" ("_position" Suc) ("_position" y)))))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" Suc) ("_position" y))
###                     ("_position" anything))))))))
###       ("_list"
###         ("_applC" ("_position" Dec)
###           ("_cargs" ("_position" ft)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" length) ("_position" gap))
###               ("_Numeral" ("_constify" ("_position" 7)))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("_applC" ("_position" Suc) ("_position" y)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list"
###                         ("\<^const>Groups.minus_class.minus" ("_position" x)
###                           ("_applC" ("_position" Suc) ("_position" y)))))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("_position" anything)))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" ft)
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("_Numeral" ("_constify" ("_position" 3))))
###             ("_applC" ("_position" max)
###               ("_cargs" ("_position" fft) ("_position" gft)))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("_applC" ("_position" Suc) ("_position" y)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list"
###                         ("\<^const>Groups.minus_class.minus" ("_position" x)
###                           ("_applC" ("_position" Suc) ("_position" y)))))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" Suc) ("_position" y))
###                     ("_position" anything))))))))
###       ("_list"
###         ("_applC" ("_position" Dec)
###           ("_cargs" ("_position" ft)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" length) ("_position" gap))
###               ("_Numeral" ("_constify" ("_position" 7)))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("_applC" ("_position" Suc) ("_position" y)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list"
###                         ("\<^const>Groups.minus_class.minus" ("_position" x)
###                           ("_applC" ("_position" Suc) ("_position" y)))))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("_position" anything)))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" ft)
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("_Numeral" ("_constify" ("_position" 3))))
###             ("_applC" ("_position" max)
###               ("_cargs" ("_position" fft) ("_position" gft)))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("\<^const>Groups.minus_class.minus" ("_position" x)
###                   ("_applC" ("_position" Suc) ("_position" y)))
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list"
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" x)
###                             ("_applC" ("_position" Suc)
###                               ("_position" y)))))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" Suc) ("_position" n)))))
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" Suc) ("_position" y))
###                       ("_position" anything)))))))))
###       ("_cargs"
###         ("_list"
###           ("_applC" ("_position" Dec)
###             ("_cargs" ("_position" ft)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 7)))))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.minus_class.minus" ("_position" x)
###                     ("_applC" ("_position" Suc) ("_position" y)))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Pr)
###                           ("_cargs" ("_position" n)
###                             ("_cargs" ("_position" f) ("_position" g))))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" x)
###                               ("_applC" ("_position" Suc)
###                                 ("_position" y)))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" ft)
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" Suc) ("_position" n)))))
###                       ("\<^const>List.list.Cons" ("_position" y)
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1495 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("_position" anything))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list" ("_applC" ("_position" Inc) ("_position" n)))
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 2)))))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Suc) ("_position" x))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("_position" anything))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list" ("_applC" ("_position" Inc) ("_position" n)))
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 2)))))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Suc) ("_position" x))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" x)
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("_position" anything)))))))
###         ("_list" ("_applC" ("_position" Inc) ("_position" n))))
###       ("_applC"
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 2)))))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.zero_class.zero"))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" Suc) ("_position" x))
###                   ("\<^const>List.list.Cons"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1537 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("_position" anything))))))
###       ("_list"
###         ("_args" ("_applC" ("_position" Inc) ("_position" n))
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 3)))))
###             ("_applC" ("_position" Goto)
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.zero_class.zero"))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Suc) ("_position" x))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("_position" anything))))))
###       ("_list"
###         ("_args" ("_applC" ("_position" Inc) ("_position" n))
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 3)))))
###             ("_applC" ("_position" Goto)
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.zero_class.zero"))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Suc) ("_position" x))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("_position" anything)))))))
###       ("_cargs"
###         ("_list"
###           ("_args" ("_applC" ("_position" Inc) ("_position" n))
###             ("_args"
###               ("_applC" ("_position" Dec)
###                 ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                   ("_Numeral" ("_constify" ("_position" 3)))))
###               ("_applC" ("_position" Goto)
###                 ("_applC" ("_position" Suc)
###                   ("\<^const>Groups.zero_class.zero"))))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" Suc) ("_position" x))
###                   ("\<^const>List.list.Cons"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1604 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Pr)
###                           ("_cargs" ("_position" n)
###                             ("_cargs" ("_position" f) ("_position" g))))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list" ("_position" y)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft) ("_position" gar)))
###                       ("_position" anything))))))))
###         ("_cargs" ("_position" gap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" Pr)
###                             ("_cargs" ("_position" n)
###                               ("_cargs" ("_position" f) ("_position" g))))
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" y)))))
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g)
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list"
###                                 ("_args" ("_position" y)
###                                   ("_applC" ("_position" rec_exec)
###                                     ("_cargs"
### ("_applC" ("_position" Pr)
###   ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
### ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" gft)
###                               ("_applC" ("_position" Suc)
###                                 ("_position" gar))))
###                           ("_position" anything))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1735 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Pr)
###                           ("_cargs" ("_position" n)
###                             ("_cargs" ("_position" f) ("_position" g))))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list" ("_position" y)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft) ("_position" gar)))
###                       ("_position" anything))))))))
###         ("_cargs" ("_position" gap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" Pr)
###                             ("_cargs" ("_position" n)
###                               ("_cargs" ("_position" f) ("_position" g))))
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" y)))))
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g)
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list"
###                                 ("_args" ("_position" y)
###                                   ("_applC" ("_position" rec_exec)
###                                     ("_cargs"
### ("_applC" ("_position" Pr)
###   ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
### ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" gft)
###                               ("_applC" ("_position" Suc)
###                                 ("_position" gar))))
###                           ("_position" anything))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1737 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("\<^const>Groups.minus_class.minus" ("_position" x)
###               ("_position" y))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list"
###                       ("\<^const>Groups.minus_class.minus" ("_position" x)
###                         ("_position" y))))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))))
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("_position" anything))))))))
###     ("\<^const>List.append"
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("\<^const>Groups.plus_class.plus" ("_position" n)
###                     ("_Numeral" ("_constify" ("_position" 3))))
###                   ("_applC" ("_position" max)
###                     ("_cargs" ("_position" fft) ("_position" gft)))))
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 7)))))))
###         ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###           ("_list"
###             ("_args" ("_applC" ("_position" Inc) ("_position" n))
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                     ("_Numeral" ("_constify" ("_position" 3)))))
###                 ("_applC" ("_position" Goto)
###                   ("_applC" ("_position" Suc)
###                     ("\<^const>Groups.zero_class.zero"))))))))
###       ("_list"
###         ("_args"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" Suc) ("_position" n)))
###               ("\<^const>Groups.zero_class.zero")))
###           ("_args"
###             ("_applC" ("_position" Inc)
###               ("_applC" ("_position" Suc) ("_position" n)))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 4)))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("\<^const>Groups.minus_class.minus" ("_position" x)
###               ("_position" y))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list"
###                       ("\<^const>Groups.minus_class.minus" ("_position" x)
###                         ("_position" y))))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))))
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("_position" anything))))))))
###     ("\<^const>List.append"
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("\<^const>Groups.plus_class.plus" ("_position" n)
###                     ("_Numeral" ("_constify" ("_position" 3))))
###                   ("_applC" ("_position" max)
###                     ("_cargs" ("_position" fft) ("_position" gft)))))
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 7)))))))
###         ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###           ("_list"
###             ("_args" ("_applC" ("_position" Inc) ("_position" n))
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                     ("_Numeral" ("_constify" ("_position" 3)))))
###                 ("_applC" ("_position" Goto)
###                   ("_applC" ("_position" Suc)
###                     ("\<^const>Groups.zero_class.zero"))))))))
###       ("_list"
###         ("_args"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" Suc) ("_position" n)))
###               ("\<^const>Groups.zero_class.zero")))
###           ("_args"
###             ("_applC" ("_position" Inc)
###               ("_applC" ("_position" Suc) ("_position" n)))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 4)))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.append"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("\<^const>Groups.minus_class.minus" ("_position" x)
###                   ("_position" y))
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list"
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" x) ("_position" y))))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus"
###                         ("_applC" ("_position" max)
###                           ("_cargs"
###                             ("\<^const>Groups.plus_class.plus"
###                               ("_position" n)
###                               ("_Numeral" ("_constify" ("_position" 3))))
###                             ("_applC" ("_position" max)
###                               ("_cargs" ("_position" fft)
###                                 ("_position" gft)))))
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" Suc) ("_position" n)))))
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("_position" anything)))))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("\<^const>Groups.plus_class.plus" ("_position" n)
###                     ("_Numeral" ("_constify" ("_position" 3))))
###                   ("_applC" ("_position" max)
###                     ("_cargs" ("_position" fft) ("_position" gft)))))
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 7)))))))
###         ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###           ("_list"
###             ("_args" ("_applC" ("_position" Inc) ("_position" n))
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                     ("_Numeral" ("_constify" ("_position" 3)))))
###                 ("_applC" ("_position" Goto)
###                   ("_applC" ("_position" Suc)
###                     ("\<^const>Groups.zero_class.zero")))))))))
###     ("_applC"
###       ("_list"
###         ("_args"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" Suc) ("_position" n)))
###               ("\<^const>Groups.zero_class.zero")))
###           ("_args"
###             ("_applC" ("_position" Inc)
###               ("_applC" ("_position" Suc) ("_position" n)))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 4))))))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" x)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus"
###                         ("_applC" ("_position" max)
###                           ("_cargs"
###                             ("\<^const>Groups.plus_class.plus"
###                               ("_position" n)
###                               ("_Numeral" ("_constify" ("_position" 3))))
###                             ("_applC" ("_position" max)
###                               ("_cargs" ("_position" fft)
###                                 ("_position" gft)))))
###                         ("_applC" ("_position" Suc) ("_position" n))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1785 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Pr)
###                           ("_cargs" ("_position" n)
###                             ("_cargs" ("_position" f) ("_position" g))))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list" ("_position" y)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft) ("_position" gar)))
###                       ("_position" anything))))))))
###         ("_cargs" ("_position" gap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" Pr)
###                             ("_cargs" ("_position" n)
###                               ("_cargs" ("_position" f) ("_position" g))))
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" y)))))
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g)
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list"
###                                 ("_args" ("_position" y)
###                                   ("_applC" ("_position" rec_exec)
###                                     ("_cargs"
### ("_applC" ("_position" Pr)
###   ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
### ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" gft)
###                               ("_applC" ("_position" Suc)
###                                 ("_position" gar))))
###                           ("_position" anything))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1788 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                   ("_position" far)))
###               ("_position" anything)))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_applC" ("_position" Suc) ("_position" far))))
###                 ("_position" anything)))))))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                   ("_position" far)))
###               ("_position" anything)))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_applC" ("_position" Suc) ("_position" far))))
###                 ("_position" anything)))))))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" fap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f) ("_position" xs)))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1793 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("\<^const>Groups.plus_class.plus" ("_position" n)
###                         ("_Numeral" ("_constify" ("_position" 3))))
###                       ("_applC" ("_position" max)
###                         ("_cargs" ("_position" fft) ("_position" gft)))))
###                   ("_position" n)))
###               ("_position" anything))))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_box)
###             ("_cargs" ("_position" n)
###               ("_applC" ("_position" Suc) ("_position" n))))
###           ("\<^const>List.append"
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_list"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 7)))))))
###               ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###                 ("_list"
###                   ("_args" ("_applC" ("_position" Inc) ("_position" n))
###                     ("_args"
###                       ("_applC" ("_position" Dec)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc) ("_position" n))
###                           ("_Numeral" ("_constify" ("_position" 3)))))
###                       ("_applC" ("_position" Goto)
###                         ("_applC" ("_position" Suc)
###                           ("\<^const>Groups.zero_class.zero"))))))))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))
###                     ("\<^const>Groups.zero_class.zero")))
###                 ("_args"
###                   ("_applC" ("_position" Inc)
###                     ("_applC" ("_position" Suc) ("_position" n)))
###                   ("_applC" ("_position" Goto)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 4))))))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("\<^const>Groups.plus_class.plus" ("_position" n)
###                         ("_Numeral" ("_constify" ("_position" 3))))
###                       ("_applC" ("_position" max)
###                         ("_cargs" ("_position" fft) ("_position" gft)))))
###                   ("_position" n)))
###               ("_position" anything))))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_box)
###             ("_cargs" ("_position" n)
###               ("_applC" ("_position" Suc) ("_position" n))))
###           ("\<^const>List.append"
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_list"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 7)))))))
###               ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###                 ("_list"
###                   ("_args" ("_applC" ("_position" Inc) ("_position" n))
###                     ("_args"
###                       ("_applC" ("_position" Dec)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc) ("_position" n))
###                           ("_Numeral" ("_constify" ("_position" 3)))))
###                       ("_applC" ("_position" Goto)
###                         ("_applC" ("_position" Suc)
###                           ("\<^const>Groups.zero_class.zero"))))))))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))
###                     ("\<^const>Groups.zero_class.zero")))
###                 ("_args"
###                   ("_applC" ("_position" Inc)
###                     ("_applC" ("_position" Suc) ("_position" n)))
###                   ("_applC" ("_position" Goto)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 4))))))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_comp"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_Numeral" ("_constify" ("_position" 3))))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_position" n)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft))))))))
###     ("_applC"
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_box)
###             ("_cargs" ("_position" n)
###               ("_applC" ("_position" Suc) ("_position" n))))
###           ("\<^const>List.append"
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_list"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 7)))))))
###               ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###                 ("_list"
###                   ("_args" ("_applC" ("_position" Inc) ("_position" n))
###                     ("_args"
###                       ("_applC" ("_position" Dec)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc) ("_position" n))
###                           ("_Numeral" ("_constify" ("_position" 3)))))
###                       ("_applC" ("_position" Goto)
###                         ("_applC" ("_position" Suc)
###                           ("\<^const>Groups.zero_class.zero"))))))))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))
###                     ("\<^const>Groups.zero_class.zero")))
###                 ("_args"
###                   ("_applC" ("_position" Inc)
###                     ("_applC" ("_position" Suc) ("_position" n)))
###                   ("_applC" ("_position" Goto)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 4)))))))))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" x)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus"
###                         ("_applC" ("_position" max)
###                           ("_cargs"
###                             ("\<^const>Groups.plus_class.plus"
###                               ("_position" n)
###                               ("_Numeral" ("_constify" ("_position" 3))))
###                             ("_applC" ("_position" max)
###                               ("_cargs" ("_position" fft)
###                                 ("_position" gft)))))
###                         ("_applC" ("_position" Suc) ("_position" n))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1854 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list"
###               ("_args" ("_position" y)
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" y))))))))))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Pr)
###                               ("_cargs" ("_position" n)
###                                 ("_cargs" ("_position" f) ("_position" g))))
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list" ("_position" y)))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" xb) ("_position" xa)))
###                           ("_position" xc)))))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Pr)
###                               ("_cargs" ("_position" n)
###                                 ("_cargs" ("_position" f) ("_position" g))))
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list" ("_position" y)))))
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g)
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list"
###                                   ("_args" ("_position" y)
###                                     ("_applC" ("_position" rec_exec)
### ("_cargs"
###   ("_applC" ("_position" Pr)
###     ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list"
###               ("_args" ("_position" y)
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" y))))))))))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Pr)
###                               ("_cargs" ("_position" n)
###                                 ("_cargs" ("_position" f) ("_position" g))))
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list" ("_position" y)))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" xb) ("_position" xa)))
###                           ("_position" xc)))))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Pr)
###                               ("_cargs" ("_position" n)
###                                 ("_cargs" ("_position" f) ("_position" g))))
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list" ("_position" y)))))
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g)
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list"
###                                   ("_args" ("_position" y)
###                                     ("_applC" ("_position" rec_exec)
### ("_cargs"
###   ("_applC" ("_position" Pr)
###     ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list"
###               ("_args" ("_position" y)
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" y))))))))))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" y)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs"
###                               ("_applC" ("_position" Pr)
###                                 ("_cargs" ("_position" n)
###                                   ("_cargs" ("_position" f)
###                                     ("_position" g))))
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list" ("_position" y)))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb) ("_position" xa)))
###                             ("_position" xc))))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons" ("_position" y)
###                           ("\<^const>List.list.Cons"
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs"
###                                 ("_applC" ("_position" Pr)
###                                   ("_cargs" ("_position" n)
###                                     ("_cargs" ("_position" f)
### ("_position" g))))
###                                 ("\<^const>List.append" ("_position" xs)
###                                   ("_list" ("_position" y)))))
###                             ("\<^const>List.list.Cons"
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs" ("_position" g)
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list"
### ("_args" ("_position" y)
###   ("_applC" ("_position" rec_exec)
###     ("_cargs"
###       ("_applC" ("_position" Pr)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_position" f) ("_position" g))))
###       ("\<^const>List.append" ("_position" xs)
###         ("_list" ("_position" y))))))))))
###                               ("\<^const>List.append"
###                                 ("\<^const>Turing.exponent"
###                                   ("\<^const>Groups.zero_class.zero")
###                                   ("\<^const>Groups.minus_class.minus"
###                                     ("_position" xb)
###                                     ("_applC" ("_position" Suc)
### ("_position" xa))))
###                                 ("_position" xc)))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1860 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_position" arity)))
###                   ("_position" anything))))))
###         ("_cargs" ("_position" ap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" f) ("_position" xs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" fp)
###                           ("_applC" ("_position" Suc) ("_position" arity))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1864 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything))))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything))))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))))
###     ("_cargs" ("_position" ap)
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" x)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 2014 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm1)))
###       ("_position" p)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_position" stp)
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" abc_steps_l)
###           ("_cargs"
###             ("_tuple" ("\<^const>Groups.zero_class.zero")
###               ("_tuple_arg" ("_position" lm1)))
###             ("_cargs" ("_position" p) ("_position" stp))))
###         ("_tuple" ("_applC" ("_position" length) ("_position" p))
###           ("_tuple_arg" ("_position" lm2)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm1)))
###       ("_position" p)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_position" stp)
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" abc_steps_l)
###           ("_cargs"
###             ("_tuple" ("\<^const>Groups.zero_class.zero")
###               ("_tuple_arg" ("_position" lm1)))
###             ("_cargs" ("_position" p) ("_position" stp))))
###         ("_tuple" ("_applC" ("_position" length) ("_position" p))
###           ("_tuple_arg" ("_position" lm2)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl) ("_position" lm1))))
###       ("_cargs" ("_position" p)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl) ("_position" lm2)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_position" stp)
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" abc_steps_l)
###           ("_cargs"
###             ("_tuple" ("\<^const>Groups.zero_class.zero")
###               ("_tuple_arg" ("_position" lm1)))
###             ("_cargs" ("_position" p) ("_position" stp))))
###         ("_tuple" ("_applC" ("_position" length) ("_position" p))
###           ("_tuple_arg" ("_position" lm2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2023 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_position" xc)
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" xc))))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" x)))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" xc))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_position" xc)
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" xc))))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" x)))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" xc))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_position" xc)
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc)))))))
###       ("_cargs" ("_position" fap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" x)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" f)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list" ("_position" x)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" fft)
###                           ("_applC" ("_position" Suc) ("_position" far))))
###                       ("_position" xc))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2078 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" i)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_position" far)))
###                     ("_position" xc)))))))
###         ("_cargs" ("_position" fap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" i)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" f)
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" i)))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" fft)
###                             ("_applC" ("_position" Suc) ("_position" far))))
###                         ("_position" xc)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2115 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" i)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_position" far)))
###                     ("_position" xc)))))))
###         ("_cargs" ("_position" fap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" i)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" f)
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" i)))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" fft)
###                             ("_applC" ("_position" Suc) ("_position" far))))
###                         ("_position" xc)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2135 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" anything))))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" anything))))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" fap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.list.Cons"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" fft)
###                           ("_applC" ("_position" Suc) ("_position" far))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2137 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" i)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_position" far)))
###                     ("_position" xc)))))))
###         ("_cargs" ("_position" fap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" i)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" f)
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" i)))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" fft)
###                             ("_applC" ("_position" Suc) ("_position" far))))
###                         ("_position" xc)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2142 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" arity))
###                     ("_position" fft)))
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("\<^const>List.append" ("_position" fap) ("_position" B))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Mn)
###                   ("_cargs" ("_position" arity) ("_position" f)))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc) ("_position" arity))
###                       ("_position" fft)))
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" arity))
###                     ("_position" fft)))
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("\<^const>List.append" ("_position" fap) ("_position" B))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Mn)
###                   ("_cargs" ("_position" arity) ("_position" f)))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc) ("_position" arity))
###                       ("_position" fft)))
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.append"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc) ("_position" arity))
###                         ("_position" fft)))
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_position" fap))
###     ("_applC" ("_position" B)
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Mn)
###                       ("_cargs" ("_position" arity) ("_position" f)))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc) ("_position" arity))
###                           ("_position" fft)))
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| ?P ?a; !!x. ?P x ==> x = ?a |] ==> (THE x. ?P x) = ?a
### Ambiguous input (line 2202 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_position" arity)))
###                   ("_position" anything))))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_position" arity)))
###                   ("_position" anything))))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_position" arity)))
###                     ("_position" anything)))))))
###         ("_cargs" ("_position" ap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" r)
###                     ("\<^const>List.list.Cons"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" fp)
###                             ("_applC" ("_position" Suc)
###                               ("_position" arity))))
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2206 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" f)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list" ("_position" i)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" x)
###             ("_idts" ("_position" xa) ("_position" xb)))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_ci) ("_position" f))
###               ("_tuple" ("_position" x)
###                 ("_tuple_args" ("_position" xa)
###                   ("_tuple_arg" ("_position" xb)))))
###             ("\<^const>HOL.All_binder" ("_position" xc)
###               ("\<^const>Turing_Hoare.Hoare_halt"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" i)
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" xb) ("_position" xa)))
###                           ("_position" xc))))))
###                 ("_position" x)
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" i)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" f)
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list" ("_position" i)))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))
###         ("\<^const>Orderings.ord_class.less"
###           ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" f)
###               ("\<^const>List.append" ("_position" xs)
###                 ("_list" ("_position" i))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" f)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list" ("_position" i)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" x)
###             ("_idts" ("_position" xa) ("_position" xb)))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_ci) ("_position" f))
###               ("_tuple" ("_position" x)
###                 ("_tuple_args" ("_position" xa)
###                   ("_tuple_arg" ("_position" xb)))))
###             ("\<^const>HOL.All_binder" ("_position" xc)
###               ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" i)
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" xb) ("_position" xa)))
###                           ("_position" xc))))))
###                 ("_position" x)
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" i)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" f)
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list" ("_position" i)))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))
###         ("\<^const>Orderings.ord_class.less"
###           ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" f)
###               ("\<^const>List.append" ("_position" xs)
###                 ("_list" ("_position" i))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" f)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list" ("_position" i)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" x)
###             ("_idts" ("_position" xa) ("_position" xb)))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_ci) ("_position" f))
###               ("_tuple" ("_position" x)
###                 ("_tuple_args" ("_position" xa)
###                   ("_tuple_arg" ("_position" xb)))))
###             ("\<^const>HOL.All_binder" ("_position" xc)
###               ("_applC"
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons" ("_position" i)
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb) ("_position" xa)))
###                             ("_position" xc)))))))
###                 ("_cargs" ("_position" x)
###                   ("_Finset"
###                     ("_lambda" ("_position" nl)
###                       ("\<^const>HOL.eq" ("_position" nl)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("\<^const>List.list.Cons" ("_position" i)
###                             ("\<^const>List.list.Cons"
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs" ("_position" f)
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" i)))))
###                               ("\<^const>List.append"
###                                 ("\<^const>Turing.exponent"
###                                   ("\<^const>Groups.zero_class.zero")
###                                   ("\<^const>Groups.minus_class.minus"
###                                     ("_position" xb)
###                                     ("_applC" ("_position" Suc)
### ("_position" xa))))
###                                 ("_position" xc)))))))))))))
###         ("\<^const>Orderings.ord_class.less"
###           ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" f)
###               ("\<^const>List.append" ("_position" xs)
###                 ("_list" ("_position" i))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2211 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Mn)
###                   ("_cargs" ("_position" n) ("_position" f)))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Mn)
###                   ("_cargs" ("_position" n) ("_position" f)))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything))))))
###     ("_cargs" ("_position" ap)
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Mn)
###                       ("_cargs" ("_position" n) ("_position" f)))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2234 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" recf) ("_position" args))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_ci) ("_position" recf))
###           ("_tuple" ("_position" ap)
###             ("_tuple_args" ("_position" arity)
###               ("_tuple_arg" ("_position" fp))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" recf) ("_position" args)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" recf) ("_position" args))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_ci) ("_position" recf))
###           ("_tuple" ("_position" ap)
###             ("_tuple_args" ("_position" arity)
###               ("_tuple_arg" ("_position" fp))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" recf) ("_position" args)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" recf) ("_position" args))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_ci) ("_position" recf))
###           ("_tuple" ("_position" ap)
###             ("_tuple_args" ("_position" arity)
###               ("_tuple_arg" ("_position" fp))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" ap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" args)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" recf) ("_position" args)))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2402 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl) ("_position" args)))
###     ("\<^const>Abacus_Hoare.abc_comp" ("_position" ap)
###       ("_applC" ("_position" dummy_abc)
###         ("_applC" ("_position" length) ("_position" args))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.Ex_binder" ("_position" m)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" args)))
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" m)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl) ("_position" args)))
###     ("\<^const>Abacus_Hoare.abc_comp" ("_position" ap)
###       ("_applC" ("_position" dummy_abc)
###         ("_applC" ("_position" length) ("_position" args))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.Ex_binder" ("_position" m)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" args)))
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" m)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" args))))
###     ("_cargs"
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" ap)
###         ("_applC" ("_position" dummy_abc)
###           ("_applC" ("_position" length) ("_position" args))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.Ex_binder" ("_position" m)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" args)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f) ("_position" args)))
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_position" m)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2435 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                   ("_position" gar)))
###               ("_position" anything)))))
###       ("_position" gap))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                   ("_position" gar)))
###               ("_position" anything)))))
###       ("_position" gap))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2436 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" apj)
###     ("_idts" ("_position" arj)
###       ("_idts" ("_position" ftj)
###         ("_idts" ("_position" j) ("_position" anything)))))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_position" i)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("\<^const>List.nth" ("_position" gs) ("_position" j)))
###             ("_tuple" ("_position" apj)
###               ("_tuple_args" ("_position" arj)
###                 ("_tuple_arg" ("_position" ftj))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                     ("_position" arj)))
###                 ("_position" anything)))))
###         ("_position" apj)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("\<^const>List.nth" ("_position" gs) ("_position" j))
###                     ("_position" args)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                       ("_applC" ("_position" Suc) ("_position" arj))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" apj)
###     ("_idts" ("_position" arj)
###       ("_idts" ("_position" ftj)
###         ("_idts" ("_position" j) ("_position" anything)))))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_position" i)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("\<^const>List.nth" ("_position" gs) ("_position" j)))
###             ("_tuple" ("_position" apj)
###               ("_tuple_args" ("_position" arj)
###                 ("_tuple_arg" ("_position" ftj))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                     ("_position" arj)))
###                 ("_position" anything)))))
###         ("_position" apj)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("\<^const>List.nth" ("_position" gs) ("_position" j))
###                     ("_position" args)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                       ("_applC" ("_position" Suc) ("_position" arj))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" apj)
###     ("_idts" ("_position" arj)
###       ("_idts" ("_position" ftj)
###         ("_idts" ("_position" j) ("_position" anything)))))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_position" i)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("\<^const>List.nth" ("_position" gs) ("_position" j)))
###             ("_tuple" ("_position" apj)
###               ("_tuple_args" ("_position" arj)
###                 ("_tuple_arg" ("_position" ftj))))))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" args)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                       ("_position" arj)))
###                   ("_position" anything))))))
###         ("_cargs" ("_position" apj)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" args)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("\<^const>List.nth" ("_position" gs)
###                           ("_position" j))
###                         ("_position" args)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" ftj)
###                           ("_applC" ("_position" Suc) ("_position" arj))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2439 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_position" ar)))
###             ("_position" anything)))))
###     ("_position" ap)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_position" ar)))
###             ("_position" anything)))))
###     ("_position" ap)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2488 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" args)))
###                     ("_position" c)))
###                 ("_applC" ("_position" length) ("_position" args))))
###             ("_position" anything)))))
###     ("\<^const>List.append" ("_position" a) ("_position" B))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" args)))
###                     ("_position" c)))
###                 ("_applC" ("_position" length) ("_position" args))))
###             ("_position" anything)))))
###     ("\<^const>List.append" ("_position" a) ("_position" B))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2528 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_position" ar)))
###             ("_position" anything)))))
###     ("_position" ap)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_position" ar)))
###             ("_position" anything)))))
###     ("_position" ap)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
### Ambiguous input (line 2576 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("_list" ("_args" ("_position" Bk) ("_position" Bk)))
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_applC" ("_position" tm_of_rec) ("_position" recf))
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" k) ("_position" l))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" k))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" recf) ("_position" args))))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" l))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("_list" ("_args" ("_position" Bk) ("_position" Bk)))
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_applC" ("_position" tm_of_rec) ("_position" recf))
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" k) ("_position" l))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" k))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" recf) ("_position" args))))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" l))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" tp)
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple" ("_list" ("_args" ("_position" Bk) ("_position" Bk)))
###             ("_tuple_arg"
###               ("\<^const>Turing.tape_class.tape_of" ("_position" args)))))))
###     ("_cargs" ("_applC" ("_position" tm_of_rec) ("_position" recf))
###       ("_Finset"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" k) ("_position" l))
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))
###                 ("_tuple_arg"
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.tape_class.tape_of"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" recf) ("_position" args))))
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" l))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Recursive"
### 7.250s elapsed time, 13.733s cpu time, 0.562s GC time
Loading theory "Draft.RecursiveMoreTemplates"
val templateLemmas =
   [("Recursive.abc_steps_zero", "abc_steps_l ?asm ?ap 0 = ?asm",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_var 1), template_var 0),
         template_hole 0),
       template_var 1)),
    ("Recursive.abc_list_crsp_simp1",
     "abc_list_crsp (?lm @ 0 \<up> ?m) ?lm",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_var 1),
               template_app
                (template_app (template_hole 1, template_var 0),
                 template_hole 0))),
           template_var 1)
         )),
    ("Recursive.length_mvbox", "length (mv_box ?m ?n) = 3",
     template_equation
      (template_app
        (template_hole 4,
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_hole 2,
         template_app (template_hole 1, template_hole 0)))),
    ("Recursive.rec_ci_not_null", "rec_ci ?f ~= ([], ?a, ?b)",
     template_negation
      (
         template_equation
          (template_app (template_hole 3, template_var 2),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0)))
         )),
    ("Recursive.length_empty_boxes", "length (empty_boxes ?n) = 2 * ?n",
     template_equation
      (template_app
        (template_hole 5, template_app (template_hole 4, template_var 0)),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app (template_hole 1, template_hole 0))),
         template_var 0))),
    ("Recursive.length_tm_even", "is_even (length (tm_of ?ap))",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_hole 5,
             template_app (template_hole 4, template_var 0))),
         template_app
          (template_hole 3,
           template_app (template_hole 2, template_hole 1))),
       template_hole 0)),
    ("Recursive.abc_fetch", "abc_fetch 3 (mv_box ?m ?n) = None",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_hole 4,
             template_app (template_hole 3, template_hole 2))),
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_hole 0)),
    ("Recursive.less_then_max_plus3", "?n < max (?n + 3) ?x",
     template_inequation
      (less_than, template_var 1,
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 1),
             template_app
              (template_hole 2,
               template_app (template_hole 1, template_hole 0)))),
         template_var 0))),
    ("Recursive.mopup_ge2", "2 <= ?x + length (mopup ?n)",
     template_inequation
      (less_equals,
       template_app
        (template_hole 5, template_app (template_hole 4, template_hole 3)),
       template_app
        (template_app (template_hole 2, template_var 1),
         template_app
          (template_hole 1,
           template_app (template_hole 0, template_var 0))))),
    ("Recursive.length_addition", "length (addition ?a ?b ?c) = 7",
     template_equation
      (template_app
        (template_hole 4,
         template_app
          (template_app
            (template_app (template_hole 3, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_hole 1,
           template_app (template_hole 1, template_hole 0))))),
    ("Recursive.abc_fetch",
     "abc_fetch (Suc 0) (mv_box ?m ?n) = Some (Inc ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app (template_hole 4, template_hole 3)),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Recursive.suc_less_plus_3", "Suc ?n < max (?n + 3) ?x",
     template_inequation
      (less_than, template_app (template_hole 5, template_var 1),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 1),
             template_app
              (template_hole 2,
               template_app (template_hole 1, template_hole 0)))),
         template_var 0))),
    ("Recursive.start_of_all_le",
     "start_of (layout_of ?ap) ?as
      <= start_of (layout_of ?ap) (length ?ap)",
     template_inequation
      (less_equals,
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         template_app (template_hole 0, template_var 1)))),
    ("Recursive.wf_tm_from_recf", "?tp = tm_of_rec ?recf ==> tm_wf0 ?tp",
     template_implication
      ([template_equation
         (template_var 1, template_app (template_hole 3, template_var 0))],
       template_predicate
        (
           template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 1),
               template_hole 0))
           ))),
    ("Recursive.length_mvboxes", "length (mv_boxes ?aa ?ba ?n) = 3 * ?n",
     template_equation
      (template_app
        (template_hole 5,
         template_app
          (template_app
            (template_app (template_hole 4, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app (template_hole 1, template_hole 0))),
         template_var 0))),
    ("Recursive.ci_even", "is_even (length (ci ?ly ?y ?i))",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_hole 5,
             template_app
              (template_app
                (template_app (template_hole 4, template_var 2),
                 template_var 1),
               template_var 0))),
         template_app
          (template_hole 3,
           template_app (template_hole 2, template_hole 1))),
       template_hole 0)),
    ("Recursive.abc_comp_commute", "?A [+] ?B [+] ?C = ?A [+] (?B [+] ?C)",
     template_equation
      (template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 0, template_var 2),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Recursive.abs_fetch",
     "abc_fetch (Suc 0) (addition ?m ?n ?p) = Some (Inc ?n)",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app (template_hole 4, template_hole 3)),
         template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 1)))),
    ("Recursive.abc_fetch", "abc_fetch 2 (mv_box ?m ?n) = Some (Goto 0)",
     template_equation
      (template_app
        (template_app
          (template_hole 7,
           template_app
            (template_hole 6,
             template_app (template_hole 5, template_hole 4))),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_hole 2,
         template_app (template_hole 1, template_hole 0)))),
    ("Recursive.length_under_max", "length ?xs < max (length ?xs + 3) ?fft",
     template_inequation
      (less_than, template_app (template_hole 5, template_var 1),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app
              (template_hole 3,
               template_app (template_hole 5, template_var 1)),
             template_app
              (template_hole 2,
               template_app (template_hole 1, template_hole 0)))),
         template_var 0))),
    ("Recursive.exp_suc", "?a \<up> Suc ?b = ?a \<up> ?b @ [?a]",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 4, template_var 1),
             template_var 0)),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_hole 0)))),
    ("Recursive.abc_fetch", "abc_fetch 0 (mv_box ?m ?n) = Some (Dec ?m 3)",
     template_equation
      (template_app
        (template_app (template_hole 7, template_hole 6),
         template_app
          (template_app (template_hole 5, template_var 1), template_var 0)),
       template_app
        (template_hole 4,
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_hole 2,
             template_app (template_hole 1, template_hole 0)))))),
    ("Recursive.abs_fetch",
     "abc_fetch 2 (addition ?m ?n ?p) = Some (Inc ?p)",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_hole 5,
             template_app (template_hole 4, template_hole 3))),
         template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("Recursive.abs_fetch",
     "abc_fetch 3 (addition ?m ?n ?p) = Some (Goto 0)",
     template_equation
      (template_app
        (template_app
          (template_hole 7,
           template_app
            (template_hole 6,
             template_app (template_hole 5, template_hole 4))),
         template_app
          (template_app
            (template_app (template_hole 3, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_hole 2,
         template_app (template_hole 1, template_hole 0)))),
    ("Recursive.abc_list_crsp_lm_v",
     "abc_list_crsp ?lma ?lmb ==> abc_lm_v ?lma ?n = abc_lm_v ?lmb ?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 2),
              template_var 1)
            )],
       template_equation
        (template_app
          (template_app (template_hole 0, template_var 2), template_var 0),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Recursive.list_crsp_simp2",
     "abc_list_crsp (?lm1.0 @ 0 \<up> ?n) ?lm2.0 ==>
      abc_list_crsp ?lm1.0 ?lm2.0",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 3,
                template_app
                 (template_app (template_hole 2, template_var 2),
                  template_app
                   (template_app (template_hole 1, template_var 1),
                    template_hole 0))),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 3, template_var 2), template_var 0)
           ))),
    ("Recursive.abc_comp_null", "(?A [+] ?B = []) = (?A = [] & ?B = [])",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 2, template_var 1), template_var 0),
         template_hole 1),
       template_predicate
        (
           template_app
            (template_app
              (template_hole 0,
               template_app
                (template_app (template_hole 3, template_var 1),
                 template_hole 1)),
             template_app
              (template_app (template_hole 3, template_var 0),
               template_hole 1))
           ))),
    ("Recursive.shift_append",
     "Turing.shift (?xs @ ?ys) ?n =
      Turing.shift ?xs ?n @ Turing.shift ?ys ?n",
     template_equation
      (template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_var 0)))),
    ("Recursive.abs_fetch",
     "abc_fetch 5 (addition ?m ?n ?p) = Some (Inc ?m)",
     template_equation
      (template_app
        (template_app
          (template_hole 7,
           template_app
            (template_hole 6,
             template_app
              (template_hole 5,
               template_app (template_hole 4, template_hole 3)))),
         template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 2)))),
    ("Recursive.all_le_start_of",
     "list_all (%(acn, s). s <= start_of (layout_of ?ap) (length ?ap))
       (tm_of ?ap)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 6, template_app (template_hole 5, t_empty)),
           template_app (template_hole 0, template_var 0))
         )),
    ("Recursive.less_then_max_plus2", "?n + 2 < max (?n + 3) ?x",
     template_inequation
      (less_than,
       template_app
        (template_app (template_hole 5, template_var 1),
         template_app
          (template_hole 4,
           template_app (template_hole 3, template_hole 2))),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 5, template_var 1),
             template_app
              (template_hole 4,
               template_app (template_hole 0, template_hole 2)))),
         template_var 0))),
    ("Recursive.le_max_insert",
     "?ffp <= max ?x0.0 (Max (insert ?ffp (?x1.0 ` ?x2.0 ` set ?gs)))",
     template_inequation
      (less_equals, template_var 4,
       template_app
        (template_app (template_hole 5, template_var 3),
         template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 4),
             template_app
              (template_app (template_hole 2, template_var 2),
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_app (template_hole 0, template_var 0)))))))),
    ("Recursive.footprint_ge",
     "rec_ci ?a = (?p, ?arity, ?fp) ==> ?arity < ?fp",
     template_implication
      ([template_equation
         (template_app (template_hole 3, template_var 3),
          template_app
           (template_app (template_hole 2, template_var 2),
            template_app
             (template_app (template_hole 1, template_var 1),
              template_var 0)))],
       template_inequation (less_than, template_var 1, template_var 0))),
    ("Recursive.length_start_of_tm",
     "start_of (layout_of ?ap) (length ?ap) =
      Suc (length (tm_of ?ap) div 2)",
     template_equation
      (template_app
        (template_app
          (template_hole 9, template_app (template_hole 8, template_var 0)),
         template_app (template_hole 7, template_var 0)),
       template_app
        (template_hole 6,
         template_app
          (template_app
            (template_hole 5,
             template_app
              (template_hole 4,
               template_app (template_hole 3, template_var 0))),
           template_app
            (template_hole 2,
             template_app (template_hole 1, template_hole 0)))))),
    ("Recursive.rec_exec_pr_0_simps",
     "rec_exec (Pr ?n ?f ?g) (?xs @ [0]) = rec_exec ?f ?xs",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 3, template_var 0),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_hole 0))),
       template_app
        (template_app (template_hole 5, template_var 2), template_var 0))),
    ("Recursive.replicate_Suc_iff_anywhere",
     "?x # ?x \<up> ?b @ ?ys = ?x \<up> Suc ?b @ ?ys",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 1),
               template_var 2)),
           template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 1)),
             template_var 2)),
         template_var 0))),
    ("Recursive.abs_fetch",
     "abc_fetch 0 (addition ?m ?n ?p) = Some (Dec ?m 4)",
     template_equation
      (template_app
        (template_app (template_hole 7, template_hole 6),
         template_app
          (template_app
            (template_app (template_hole 5, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_hole 4,
         template_app
          (template_app (template_hole 3, template_var 2),
           template_app
            (template_hole 2,
             template_app
              (template_hole 1,
               template_app (template_hole 1, template_hole 0))))))),
    ("Recursive.abc_list_crsp_lm_s",
     "abc_list_crsp ?lma ?lmb ==>
      abc_list_crsp (abc_lm_s ?lma ?m ?n) (abc_lm_s ?lmb ?m ?n)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 1, template_var 3),
              template_var 2)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 1),
                 template_var 0)),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0))
           ))),
    ("Recursive.mopup_even", "is_even (2 * ?x + length (mopup ?n))",
     template_equation
      (template_app
        (template_app
          (template_hole 8,
           template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app
                  (template_hole 6,
                   template_app
                    (template_hole 5,
                     template_app (template_hole 4, template_hole 3))),
                 template_var 1)),
             template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 0)))),
         template_app
          (template_hole 5,
           template_app (template_hole 4, template_hole 3))),
       template_hole 0)),
    ("Recursive.abs_fetch",
     "abc_fetch 6 (addition ?m ?n ?p) = Some (Goto 4)",
     template_equation
      (template_app
        (template_app
          (template_hole 7,
           template_app
            (template_hole 6,
             template_app
              (template_hole 5,
               template_app (template_hole 4, template_hole 3)))),
         template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_hole 0,
           template_app
            (template_hole 6,
             template_app
              (template_hole 5,
               template_app (template_hole 5, template_hole 3))))))),
    ("Recursive.start_of_eq",
     "length ?ap < ?as ==>
      start_of (layout_of ?ap) ?as = start_of (layout_of ?ap) (length ?ap)",
     template_implication
      ([template_inequation
         (less_than, template_app (template_hole 3, template_var 1),
          template_var 0)],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 1)),
           template_var 0),
         template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 1)),
           template_app (template_hole 3, template_var 1))))),
    ("Recursive.replicate_merge_anywhere",
     "?x \<up> ?a @ ?x \<up> ?b @ ?ys = ?x \<up> (?a + ?b) @ ?ys",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 3),
             template_var 2)),
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 1),
               template_var 2)),
           template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 3),
                 template_var 1)),
             template_var 2)),
         template_var 0))),
    ("Recursive.abs_fetch",
     "abc_fetch 4 (addition ?m ?n ?p) = Some (Dec ?p 7)",
     template_equation
      (template_app
        (template_app
          (template_hole 7,
           template_app
            (template_hole 6,
             template_app
              (template_hole 5,
               template_app (template_hole 5, template_hole 4)))),
         template_app
          (template_app
            (template_app (template_hole 3, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 0),
           template_app
            (template_hole 6,
             template_app
              (template_hole 0,
               template_app (template_hole 0, template_hole 4))))))),
    ("Recursive.zip_pre",
     "length ?ys <= length ?ap ==>
      zip ?ys ?ap = zip ?ys (take (length ?ys) ?ap)",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 4, template_var 1),
          template_app (template_hole 3, template_var 0))],
       template_equation
        (template_app
          (template_app (template_hole 1, template_var 1), template_var 0),
         template_app
          (template_app (template_hole 1, template_var 1),
           template_app
            (template_app
              (template_hole 0,
               template_app (template_hole 4, template_var 1)),
             template_var 0))))),
    ("Recursive.length_shift_mopup",
     "length (Turing.shift (mopup ?n) ?ss) = 4 * ?n + 12",
     template_equation
      (template_app
        (template_hole 8,
         template_app
          (template_app
            (template_hole 7,
             template_app (template_hole 6, template_var 1)),
           template_var 0)),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_hole 3,
                 template_app
                  (template_hole 2,
                   template_app (template_hole 2, template_hole 1)))),
             template_var 1)),
         template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app
              (template_hole 2,
               template_app (template_hole 0, template_hole 1))))))),
    ("Recursive.sum_list_ci_even",
     "is_even (sum_list (map (length o (%(x, y). ci ?ly x y)) ?zs))",
     template_equation
      (template_app
        (template_app
          (template_hole 10,
           template_app
            (template_hole 9,
             template_app
              (template_app
                (template_hole 8,
                 template_app
                  (template_app (template_hole 7, template_hole 6),
                   template_app (template_hole 5, t_empty))),
               template_var 0))),
         template_app
          (template_hole 3,
           template_app (template_hole 2, template_hole 1))),
       template_hole 0)),
    ("Recursive.list_double_update_2",
     "?lm[?a := ?x, ?b := ?y, ?a := z] = ?lm[?b := ?y, ?a := z]",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app
                (template_app
                  (template_hole 1,
                   template_app
                    (template_app
                      (template_app (template_hole 1, template_var 4),
                       template_var 3),
                     template_var 2)),
                 template_var 1),
               template_var 0)),
           template_var 3),
         template_hole 0),
       template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 1),
               template_var 0)),
           template_var 3),
         template_hole 0))),
    ("Recursive.terminate_s_reverse",
     "[| terminate s ?xs; !!n. ?xs = [n] ==> ?P |] ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_hole 4),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 3, t_empty))],
       template_predicate (template_var 0))),
    ("Recursive.terminate_z_reverse",
     "[| terminate z ?xs; !!n. ?xs = [n] ==> ?P |] ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_hole 4),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 3, t_empty))],
       template_predicate (template_var 0))),
    ("Recursive.max_less_suc_suc",
     "max ?n (Suc ?n) < Suc (Suc (max (?n + 3) ?x + ?anything - Suc 0))",
     template_inequation
      (less_than,
       template_app
        (template_app (template_hole 7, template_var 2),
         template_app (template_hole 6, template_var 2)),
       template_app
        (template_hole 6,
         template_app
          (template_hole 6,
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 4, template_var 2),
                         template_app
                          (template_hole 3,
                           template_app
                            (template_hole 2, template_hole 1)))),
                     template_var 1)),
                 template_var 0)),
             template_app (template_hole 6, template_hole 0)))))),
    ("Recursive.param_pattern",
     "[| terminate ?f ?xs; rec_ci ?f = (?p, ?arity, ?fp) |]
      ==> length ?xs = ?arity",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 4),
              template_var 3)
            ),
        template_equation
         (template_app (template_hole 4, template_var 4),
          template_app
           (template_app (template_hole 3, template_var 2),
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 0)))],
       template_equation
        (template_app (template_hole 0, template_var 3), template_var 1))),
    ("Recursive.update_zero_to_zero",
     "[| ?am ! ?n = 0; ?n < length ?am |] ==> ?am[?n := 0] = ?am",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 5, template_var 1), template_var 0),
          template_hole 4),
        template_inequation
         (less_than, template_var 0,
          template_app (template_hole 2, template_var 1))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0),
           template_hole 4),
         template_var 1))),
    ("Recursive.cn_merge_gs_tl_app",
     "cn_merge_gs (?gs @ [?g]) ?pstr =
      cn_merge_gs ?gs ?pstr [+] cn_merge_gs [?g] (?pstr + length ?gs)",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_var 2),
             template_app
              (template_app (template_hole 4, template_var 1),
               template_hole 3))),
         template_var 0),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 6, template_var 2),
             template_var 0)),
         template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 4, template_var 1),
               template_hole 3)),
           template_app
            (template_app (template_hole 1, template_var 0),
             template_app (template_hole 0, template_var 2)))))),
    ("Recursive.wf_tm_from_abacus",
     "?tp = tm_of ?ap ==>
      tm_wf0 (?tp @ Turing.shift (mopup ?n) (length ?tp div 2))",
     template_implication
      ([template_equation
         (template_var 2, template_app (template_hole 11, template_var 1))],
       template_predicate
        (
           template_app
            (template_hole 10,
             template_app
              (template_app
                (template_hole 9,
                 template_app
                  (template_app (template_hole 8, template_var 2),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app (template_hole 6, template_var 0)),
                     template_app
                      (template_app
                        (template_hole 5,
                         template_app (template_hole 4, template_var 2)),
                       template_app
                        (template_hole 3,
                         template_app
                          (template_hole 2, template_hole 1)))))),
               template_hole 0))
           ))),
    ("Recursive.length_le_max_insert_rec_ci",
     "length ?gs <= ?ffp ==>
      length ?gs
      <= max ?x1.0 (Max (insert ?ffp (?x2.0 ` ?x3.0 ` set ?gs)))",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 6, template_var 4),
          template_var 3)],
       template_inequation
        (less_equals, template_app (template_hole 6, template_var 4),
         template_app
          (template_app (template_hole 5, template_var 2),
           template_app
            (template_hole 4,
             template_app
              (template_app (template_hole 3, template_var 3),
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_app
                  (template_app (template_hole 1, template_var 0),
                   template_app (template_hole 0, template_var 4))))))))),
    ("Recursive.tms_of_at_index",
     "?k < length ?ap ==>
      tms_of ?ap ! ?k =
      ci (layout_of ?ap) (start_of (layout_of ?ap) ?k) (?ap ! ?k)",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app (template_hole 7, template_var 0))],
       template_equation
        (template_app
          (template_app
            (template_hole 5,
             template_app (template_hole 4, template_var 0)),
           template_var 1),
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app (template_hole 2, template_var 0)),
             template_app
              (template_app
                (template_hole 1,
                 template_app (template_hole 2, template_var 0)),
               template_var 1)),
           template_app
            (template_app (template_hole 0, template_var 0),
             template_var 1))))),
    ("Recursive.mopup_div_2",
     "?b <= Suc ?x ==> ?b <= (2 * ?x + length (mopup ?n)) div 2",
     template_implication
      ([template_inequation
         (less_equals, template_var 2,
          template_app (template_hole 8, template_var 1))],
       template_inequation
        (less_equals, template_var 2,
         template_app
          (template_app
            (template_hole 7,
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app
                      (template_hole 4,
                       template_app (template_hole 3, template_hole 2))),
                   template_var 1)),
               template_app
                (template_hole 1,
                 template_app (template_hole 0, template_var 0)))),
           template_app
            (template_hole 4,
             template_app (template_hole 3, template_hole 2)))))),
    ("Recursive.mopup_le6",
     "(?a, ?b) : set (mopup_a ?n) ==> ?b <= 2 * ?n + 6",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 10,
                template_app
                 (template_app (template_hole 9, template_var 2),
                  template_var 1)),
              template_app
               (template_hole 8,
                template_app (template_hole 7, template_var 0)))
            )],
       template_inequation
        (less_equals, template_var 1,
         template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_hole 3,
                   template_app (template_hole 2, template_hole 1))),
               template_var 0)),
           template_app
            (template_hole 3,
             template_app
              (template_hole 2,
               template_app (template_hole 0, template_hole 1))))))),
    ("Recursive.terminate_id_reverse",
     "[| terminate (recf.id ?m ?n) ?xs;
         [| ?n < ?m; length ?xs = ?m |] ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app
                 (template_app (template_hole 3, template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_inequation (less_than, template_var 2, template_var 3)],
          template_implication
           ([template_equation
              (template_app (template_hole 0, template_var 1),
               template_var 3)],
            template_predicate (template_var 0)))],
       template_predicate (template_var 0))),
    ("Recursive.suc_suc_max_simp",
     "Suc (Suc (max (?xs + 3) ?fft - Suc (Suc ?xs))) =
      max (?xs + 3) ?fft - ?xs",
     template_equation
      (template_app
        (template_hole 6,
         template_app
          (template_hole 6,
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_app
                      (template_hole 2,
                       template_app (template_hole 1, template_hole 0)))),
                 template_var 0)),
             template_app
              (template_hole 6,
               template_app (template_hole 6, template_var 1))))),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 3, template_var 1),
                 template_app
                  (template_hole 2,
                   template_app (template_hole 1, template_hole 0)))),
             template_var 0)),
         template_var 1))),
    ("Recursive.abc_append_first_step_eq_pre",
     "?st < length ?A ==>
      abc_step_l (?st, ?lm) (abc_fetch ?st (?A @ ?B)) =
      abc_step_l (?st, ?lm) (abc_fetch ?st ?A)",
     template_implication
      ([template_inequation
         (less_than, template_var 3,
          template_app (template_hole 5, template_var 2))],
       template_equation
        (template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_var 3),
               template_var 1)),
           template_app
            (template_app (template_hole 1, template_var 3),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0))),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_var 3),
               template_var 1)),
           template_app
            (template_app (template_hole 1, template_var 3),
             template_var 2))))),
    ("Recursive.empty_boxes_correct",
     "?n <= length ?lm ==>
      {%nl. nl = ?lm} empty_boxes ?n {%nl. nl = 0 \<up> ?n @ drop ?n ?lm}",
     template_implication
      ([template_inequation
         (less_equals, template_var 1,
          template_app (template_hole 7, template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, t_empty),
               template_app (template_hole 4, template_var 1)),
             t_empty)
           ))),
    ("Recursive.concat_in",
     "?i < length (concat ?xs) ==>
      EX k<length ?xs. concat ?xs ! ?i : set (?xs ! k)",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app
           (template_hole 8,
            template_app (template_hole 7, template_var 0)))],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("Recursive.in_tms",
     "?i < length (tm_of ?ap) ==>
      EX k<length ?ap. tm_of ?ap ! ?i : set (tms_of ?ap ! k)",
     template_implication
      ([template_inequation
         (less_than, template_var 1,
          template_app
           (template_hole 9,
            template_app (template_hole 8, template_var 0)))],
       template_predicate (template_app (template_hole 7, t_empty)))),
    ("Recursive.tms_any_less",
     "[| ?k < length ?ap; (?a, ?b) : set (tms_of ?ap ! ?k) |]
      ==> ?b <= start_of (layout_of ?ap) (length ?ap)",
     template_implication
      ([template_inequation
         (less_than, template_var 3,
          template_app (template_hole 8, template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 1),
                  template_var 0)),
              template_app
               (template_hole 5,
                template_app
                 (template_app
                   (template_hole 4,
                    template_app (template_hole 3, template_var 2)),
                  template_var 3)))
            )],
       template_inequation
        (less_equals, template_var 0,
         template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 2)),
           template_app (template_hole 8, template_var 2))))),
    ("Recursive.suc_max_simp",
     "Suc (max (?n + 3) ?fft - Suc (Suc (Suc ?n))) =
      max (?n + 3) ?fft - Suc (Suc ?n)",
     template_equation
      (template_app
        (template_hole 6,
         template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 3, template_var 1),
                   template_app
                    (template_hole 2,
                     template_app (template_hole 1, template_hole 0)))),
               template_var 0)),
           template_app
            (template_hole 6,
             template_app
              (template_hole 6,
               template_app (template_hole 6, template_var 1))))),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 3, template_var 1),
                 template_app
                  (template_hole 2,
                   template_app (template_hole 1, template_hole 0)))),
             template_var 0)),
         template_app
          (template_hole 6,
           template_app (template_hole 6, template_var 1))))),
    ("Recursive.abc_Hoare_haltE",
     "{%nl. nl = ?lm1.0} ?p {%nl. nl = ?lm2.0} ==>
      EX stp. abc_steps_l (0, ?lm1.0) ?p stp = (length ?p, ?lm2.0)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, t_empty), template_var 1),
              t_empty)
            )],
       template_predicate (template_app (template_hole 5, t_empty)))),
    ("Recursive.mv_box_inv_init",
     "[| ?m < length ?initlm; ?n < length ?initlm; ?m ~= ?n |]
      ==> mv_box_inv (0, ?initlm) ?m ?n ?initlm",
     template_implication
      ([template_inequation
         (less_than, template_var 2,
          template_app (template_hole 5, template_var 1)),
        template_inequation
         (less_than, template_var 0,
          template_app (template_hole 5, template_var 1)),
        template_negation
         (template_equation (template_var 2, template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_hole 0),
                     template_var 1)),
                 template_var 2),
               template_var 0),
             template_var 1)
           ))),
    ("Recursive.shift_le2",
     "(?a, ?b) : set (Turing.shift (mopup ?n) ?x) ==>
      ?b <= (2 * ?x + length (mopup ?n)) div 2",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 12,
                template_app
                 (template_app (template_hole 11, template_var 3),
                  template_var 2)),
              template_app
               (template_hole 10,
                template_app
                 (template_app
                   (template_hole 9,
                    template_app (template_hole 8, template_var 1)),
                  template_var 0)))
            )],
       template_inequation
        (less_equals, template_var 2,
         template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app
                    (template_hole 4,
                     template_app
                      (template_hole 3,
                       template_app (template_hole 2, template_hole 1))),
                   template_var 0)),
               template_app
                (template_hole 0,
                 template_app (template_hole 8, template_var 1)))),
           template_app
            (template_hole 3,
             template_app (template_hole 2, template_hole 1)))))),
    ("Recursive.abc_list_crsp_simp",
     "[| abc_list_crsp ?lma ?lmb; ?m < length ?lma; ?m < length ?lmb |]
      ==> abc_list_crsp (?lma[?m := ?n]) (?lmb[?m := ?n])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 3),
              template_var 2)
            ),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 1, template_var 3)),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 1, template_var 2))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 1),
                 template_var 0)),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0))
           ))),
    ("Recursive.length_ci",
     "[| ?k < length ?ap; length (ci ?ly ?y (?ap ! ?k)) = 2 * ?qa |]
      ==> layout_of ?ap ! ?k = ?qa",
     template_implication
      ([template_inequation
         (less_than, template_var 4,
          template_app (template_hole 10, template_var 3)),
        template_equation
         (template_app
           (template_hole 8,
            template_app
             (template_app
               (template_app (template_hole 7, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 6, template_var 3),
                template_var 4))),
          template_app
           (template_app
             (template_hole 5,
              template_app
               (template_hole 4,
                template_app (template_hole 3, template_hole 2))),
            template_var 0))],
       template_equation
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 3)),
           template_var 4),
         template_var 0))),
    ("Recursive.abc_append_frist_steps_halt_eq",
     "abc_steps_l (0, ?lm) ?A ?n = (length ?A, ?lm') ==>
      EX n'. abc_steps_l (0, ?lm) (?A @ ?B) n' = (length ?A, ?lm')",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 5,
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 4)),
              template_var 3),
            template_var 2),
          template_app
           (template_app
             (template_hole 4,
              template_app (template_hole 2, template_var 3)),
            template_var 1))],
       template_predicate (template_app (template_hole 1, t_empty)))),
    ("Recursive.abc_list_crsp_elim",
     "[| abc_list_crsp ?lma ?lmb;
         EX n. ?lma = ?lmb @ 0 \<up> n | ?lmb = ?lma @ 0 \<up> n ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 2),
              template_var 1)
            ),
        template_implication
         ([template_predicate (template_app (template_hole 5, t_empty))],
          template_predicate (template_var 0))],
       template_predicate (template_var 0))),
    ("Recursive.arith_as_simp",
     "[| Suc ?n <= ?ba - ?aa; ?aa < ?ba |]
      ==> (?ba < Suc (?aa + (?ba - Suc (?aa + ?n) + ?n))) = False",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 5, template_var 2),
          template_app
           (template_app (template_hole 4, template_var 1),
            template_var 0)),
        template_inequation (less_than, template_var 0, template_var 1)],
       template_equation
        (template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 1, template_var 0),
               template_app
                (template_app
                  (template_hole 1,
                   template_app
                    (template_app (template_hole 4, template_var 1),
                     template_app
                      (template_hole 5,
                       template_app
                        (template_app (template_hole 1, template_var 0),
                         template_var 2)))),
                 template_var 2)))),
         template_hole 0))),
    ("Recursive.rec_exec_pr_Suc_simps",
     "rec_exec (Pr ?n ?f ?g) (?xs @ [Suc ?y]) =
      rec_exec ?g (?xs @ [?y, rec_exec (Pr ?n ?f ?g) (?xs @ [?y])])",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_app (template_hole 4, template_var 4),
               template_var 3),
             template_var 2)),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 0)),
             template_hole 0))),
       template_app
        (template_app (template_hole 5, template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_var 0),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app
                      (template_app
                        (template_app (template_hole 4, template_var 4),
                         template_var 3),
                       template_var 2)),
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_app
                      (template_app (template_hole 2, template_var 0),
                       template_hole 0)))),
               template_hole 0)))))),
    ("Recursive.butlast_last",
     "length ?lm1.0 = ?aa ==>
      (?lm1.0 @
       (0::?'a) \<up> ?n @
       last ?lm2.0 # ?lm3.0 @ butlast ?lm2.0 @ (0::?'a) # ?lm4.0) !
      (?aa + ?n) =
      last ?lm2.0",
     template_implication
      ([template_equation
         (template_app (template_hole 9, template_var 5), template_var 4)],
       template_equation
        (template_app
          (template_app
            (template_hole 7,
             template_app
              (template_app (template_hole 6, template_var 5),
               template_app
                (template_app
                  (template_hole 6,
                   template_app
                    (template_app (template_hole 5, template_var 3),
                     template_hole 4)),
                 template_app
                  (template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_var 2)),
                   template_app
                    (template_app (template_hole 6, template_var 1),
                     template_app
                      (template_app
                        (template_hole 6,
                         template_app (template_hole 1, template_var 2)),
                       template_app
                        (template_app (template_hole 3, template_hole 4),
                         template_var 0))))))),
           template_app
            (template_app (template_hole 0, template_var 4),
             template_var 3)),
         template_app (template_hole 2, template_var 2)))),
    ("Recursive.list_all_add_6E",
     "list_all (%(acn, s). s <= Suc ?q) ?xs ==>
      list_all (%(acn, s). s <= ?q + (2 * ?n + 6)) ?xs",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 9, template_app (template_hole 8, t_empty)),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 9, template_app (template_hole 8, t_empty)),
             template_var 1)
           ))),
    ("Recursive.findnth_le",
     "(?a, ?b)
      : set (Turing.shift (findnth ?n)
              (start_of (layout_of ?ap) ?k - Suc 0)) ==>
      ?b <= Suc (start_of (layout_of ?ap) ?k + 2 * ?n)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 15,
                template_app
                 (template_app (template_hole 14, template_var 4),
                  template_var 3)),
              template_app
               (template_hole 13,
                template_app
                 (template_app
                   (template_hole 12,
                    template_app (template_hole 11, template_var 2)),
                  template_app
                   (template_app
                     (template_hole 10,
                      template_app
                       (template_app
                         (template_hole 9,
                          template_app (template_hole 8, template_var 1)),
                        template_var 0)),
                    template_app (template_hole 7, template_hole 6)))))
            )],
       template_inequation
        (less_equals, template_var 3,
         template_app
          (template_hole 7,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 9,
                   template_app (template_hole 8, template_var 1)),
                 template_var 0)),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_hole 2,
                   template_app (template_hole 1, template_hole 0))),
               template_var 2)))))),
    ("Recursive.empty_one_box_correct",
     "{%nl. nl = 0 \<up> ?n @ ?x # ?lm} [Dec ?n 2, Goto 0]
      {%nl. nl = 0 # 0 \<up> ?n @ ?lm}",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 12, t_empty),
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_app (template_hole 5, template_var 2),
                   template_app
                    (template_hole 4,
                     template_app (template_hole 3, template_hole 2)))),
               template_app
                (template_app
                  (template_hole 6,
                   template_app (template_hole 1, template_hole 8)),
                 template_hole 0))),
           t_empty)
         )),
    ("Recursive.abc_append_frist_steps_eq_pre",
     "[| abc_notfinal (abc_steps_l (0, ?lm) ?A ?n) ?A; ?A ~= [] |]
      ==> abc_steps_l (0, ?lm) (?A @ ?B) ?n = abc_steps_l (0, ?lm) ?A ?n",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app
                   (template_app
                     (template_hole 7,
                      template_app
                       (template_app (template_hole 6, template_hole 5),
                        template_var 3)),
                    template_var 2),
                  template_var 1)),
              template_var 2)
            ),
        template_negation
         (template_equation (template_var 2, template_hole 2))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 6, template_hole 5),
                 template_var 3)),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0)),
           template_var 1),
         template_app
          (template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 6, template_hole 5),
                 template_var 3)),
             template_var 2),
           template_var 1)))),
    ("Recursive.put_in_tape_small_enough0",
     "0 < ?rsx ==>
      EX y. (?xs @ ?x # ?rsx # ?anything)
            [Suc (length ?xs) := ?rsx - Suc 0] = ?xs @ ?x # y # ?anything &
            y <= ?rsx",
     template_implication
      ([template_inequation (less_than, template_hole 10, template_var 3)],
       template_predicate (template_app (template_hole 9, t_empty)))),
    ("Recursive.abc_append_frist_steps_halt_eq'",
     "[| abc_steps_l (0, ?lm) ?A ?n = (length ?A, ?lm'); ?A ~= [] |]
      ==> EX n'. abc_steps_l (0, ?lm) (?A @ ?B) n' = (length ?A, ?lm')",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 8,
                template_app
                 (template_app (template_hole 7, template_hole 6),
                  template_var 4)),
              template_var 3),
            template_var 2),
          template_app
           (template_app
             (template_hole 7,
              template_app (template_hole 5, template_var 3)),
            template_var 1)),
        template_negation
         (template_equation (template_var 3, template_hole 2))],
       template_predicate (template_app (template_hole 1, t_empty)))),
    ("Recursive.abc_list_crsp_step",
     "[| abc_list_crsp ?lma ?lmb; abc_step_l (?aa, ?lma) ?i = (?a, ?lma');
         abc_step_l (?aa, ?lmb) ?i = (?a', ?lmb') |]
      ==> ?a' = ?a & abc_list_crsp ?lma' ?lmb'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 7),
              template_var 6)
            ),
        template_equation
         (template_app
           (template_app
             (template_hole 3,
              template_app
               (template_app (template_hole 2, template_var 5),
                template_var 7)),
            template_var 4),
          template_app
           (template_app (template_hole 2, template_var 3),
            template_var 2)),
        template_equation
         (template_app
           (template_app
             (template_hole 3,
              template_app
               (template_app (template_hole 2, template_var 5),
                template_var 6)),
            template_var 4),
          template_app
           (template_app (template_hole 2, template_var 1),
            template_var 0))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 3)),
             template_app
              (template_app (template_hole 5, template_var 2),
               template_var 0))
           ))),
    ("Recursive.addition_inv_init",
     "[| ?m ~= ?n; max ?m ?n < ?p; ?p < length ?lm; ?lm ! ?p = 0 |]
      ==> addition_inv (0, ?lm) ?m ?n ?p ?lm",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_var 2)),
        template_inequation
         (less_than,
          template_app
           (template_app (template_hole 5, template_var 3), template_var 2),
          template_var 1),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 4, template_var 0)),
        template_equation
         (template_app
           (template_app (template_hole 3, template_var 0), template_var 1),
          template_hole 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_hole 1,
                     template_app
                      (template_app (template_hole 0, template_hole 2),
                       template_var 0)),
                   template_var 3),
                 template_var 2),
               template_var 1),
             template_var 0)
           ))),
    ("Recursive.insert_dominated",
     "length ?gs <= ?ffp ==>
      length ?gs +
      (max ?xs (Max (insert ?ffp (?x1.0 ` ?x2.0 ` set ?gs))) - length ?gs) =
      max ?xs (Max (insert ?ffp (?x1.0 ` ?x2.0 ` set ?gs)))",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 9, template_var 4),
          template_var 3)],
       template_equation
        (template_app
          (template_app
            (template_hole 7,
             template_app (template_hole 9, template_var 4)),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_var 2),
                 template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 3),
                     template_app
                      (template_app (template_hole 2, template_var 1),
                       template_app
                        (template_app (template_hole 1, template_var 0),
                         template_app
                          (template_hole 0, template_var 4))))))),
             template_app (template_hole 9, template_var 4))),
         template_app
          (template_app (template_hole 5, template_var 2),
           template_app
            (template_hole 4,
             template_app
              (template_app (template_hole 3, template_var 3),
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_app
                  (template_app (template_hole 1, template_var 0),
                   template_app (template_hole 0, template_var 4))))))))),
    ("Recursive.find_exponent_rec_exec",
     "[| ?args @ [rec_exec ?f ?args] = ?lm @ 0 \<up> ?n;
         length ?args < length ?lm |]
      ==> EX m. ?lm = ?args @ rec_exec ?f ?args # 0 \<up> m",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 8, template_var 3),
            template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 2),
                  template_var 3)),
              template_hole 5)),
          template_app
           (template_app (template_hole 8, template_var 1),
            template_app
             (template_app (template_hole 4, template_var 0),
              template_hole 3))),
        template_inequation
         (less_than, template_app (template_hole 1, template_var 3),
          template_app (template_hole 1, template_var 1))],
       template_predicate (template_app (template_hole 0, t_empty)))),
    ("Recursive.abc_list_crsp_simp2",
     "[| abc_list_crsp ?lma ?lmb; ?m < length ?lma; ~ ?m < length ?lmb |]
      ==> abc_list_crsp (?lma[?m := ?n])
           (?lmb @ 0 \<up> (?m - length ?lmb) @ [?n])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 3),
              template_var 2)
            ),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 8, template_var 3)),
        template_negation
         (
            template_inequation
             (less_than, template_var 1,
              template_app (template_hole 8, template_var 2))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app
                  (template_app (template_hole 6, template_var 3),
                   template_var 1),
                 template_var 0)),
             template_app
              (template_app (template_hole 5, template_var 2),
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, template_var 1),
                         template_app (template_hole 8, template_var 2))),
                     template_hole 2)),
                 template_app
                  (template_app (template_hole 1, template_var 0),
                   template_hole 0))))
           ))),
    ("Recursive.abc_list_crsp_simp3",
     "[| abc_list_crsp ?lma ?lmb; ~ ?m < length ?lma; ?m < length ?lmb |]
      ==> abc_list_crsp (?lma @ 0 \<up> (?m - length ?lma) @ [?n])
           (?lmb[?m := ?n])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 3),
              template_var 2)
            ),
        template_negation
         (
            template_inequation
             (less_than, template_var 1,
              template_app (template_hole 7, template_var 3))
            ),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 7, template_var 2))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app (template_hole 6, template_var 3),
                 template_app
                  (template_app
                    (template_hole 6,
                     template_app
                      (template_app
                        (template_hole 5,
                         template_app
                          (template_app (template_hole 4, template_var 1),
                           template_app (template_hole 7, template_var 3))),
                       template_hole 3)),
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     template_hole 1)))),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0))
           ))),
    ("Recursive.start_of_suc_inc",
     "[| ?k < length ?ap; ?ap ! ?k = Inc ?n |]
      ==> start_of (layout_of ?ap) (Suc ?k) =
          start_of (layout_of ?ap) ?k + 2 * ?n + 9",
     template_implication
      ([template_inequation
         (less_than, template_var 2,
          template_app (template_hole 13, template_var 1)),
        template_equation
         (template_app
           (template_app (template_hole 11, template_var 1),
            template_var 2),
          template_app (template_hole 10, template_var 0))],
       template_equation
        (template_app
          (template_app
            (template_hole 8,
             template_app (template_hole 7, template_var 1)),
           template_app (template_hole 6, template_var 2)),
         template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app
                    (template_hole 8,
                     template_app (template_hole 7, template_var 1)),
                   template_var 2)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_hole 1))),
                 template_var 0))),
           template_app
            (template_hole 3,
             template_app
              (template_hole 0,
               template_app
                (template_hole 2,
                 template_app (template_hole 2, template_hole 1)))))))),
    ("Recursive.compile_s_correct'",
     "{%nl. nl = ?n # 0 \<up> 2 @ ?anything}
      addition 0 (Suc 0) 2 [+] [Inc (Suc 0)]
      {%nl. nl = ?n # Suc ?n # 0 # ?anything}",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 14, t_empty),
             template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app
                    (template_app (template_hole 4, template_hole 6),
                     template_app (template_hole 3, template_hole 6)),
                   template_app
                    (template_hole 9,
                     template_app (template_hole 8, template_hole 7)))),
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_hole 1,
                     template_app (template_hole 3, template_hole 6))),
                 template_hole 0))),
           t_empty)
         )),
    ("Recursive.terminate_cn_reverse",
     "[| terminate (Cn ?n ?f ?gs) ?xs;
         [| terminate ?f (map (%g. rec_exec g ?xs) ?gs);
            ALL g:set ?gs. terminate g ?xs; length ?xs = ?n |]
         ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app
                   (template_app (template_hole 6, template_var 4),
                    template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app (template_hole 7, template_var 3),
                 template_app
                  (template_app (template_hole 5, t_empty), template_var 2))
               )],
          template_implication
           ([template_predicate
              (
                 template_app
                  (template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_var 2)),
                   t_empty)
                 )],
            template_implication
             ([template_equation
                (template_app (template_hole 0, template_var 1),
                 template_var 4)],
              template_predicate (template_var 0))))],
       template_predicate (template_var 0))),
    ("Recursive.mv_box_halt_cond",
     "[| ?m ~= ?n; mv_box_inv (?a, ?b) ?m ?n ?lm; ?a = 3 |]
      ==> ?b = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_hole 9,
                    template_app
                     (template_app (template_hole 8, template_var 2),
                      template_var 1)),
                  template_var 4),
                template_var 3),
              template_var 0)
            ),
        template_equation
         (template_var 2,
          template_app
           (template_hole 7,
            template_app (template_hole 6, template_hole 5)))],
       template_equation
        (template_var 1,
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_app (template_hole 3, template_var 0),
                   template_var 3),
                 template_app
                  (template_app
                    (template_hole 2,
                     template_app
                      (template_app (template_hole 1, template_var 0),
                       template_var 4)),
                   template_app
                    (template_app (template_hole 1, template_var 0),
                     template_var 3)))),
             template_var 4),
           template_hole 0)))),
    ("Recursive.recursive_compile_to_tm_correct3",
     "terminate ?recf ?args ==>
      {%tp. tp = ([Bk, Bk], <?args>)} tm_of_rec ?recf
      {%tp. EX k l.
               tp = (Bk \<up> k, <rec_exec ?recf ?args> @ Bk \<up> l)}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 13, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 12, t_empty),
               template_app (template_hole 5, template_var 1)),
             t_empty)
           ))),
    ("Recursive.start_of_suc_dec",
     "[| ?k < length ?ap; ?ap ! ?k = Dec ?n ?e |]
      ==> start_of (layout_of ?ap) (Suc ?k) =
          start_of (layout_of ?ap) ?k + 2 * ?n + 16",
     template_implication
      ([template_inequation
         (less_than, template_var 3,
          template_app (template_hole 12, template_var 2)),
        template_equation
         (template_app
           (template_app (template_hole 10, template_var 2),
            template_var 3),
          template_app
           (template_app (template_hole 9, template_var 1),
            template_var 0))],
       template_equation
        (template_app
          (template_app
            (template_hole 7,
             template_app (template_hole 6, template_var 2)),
           template_app (template_hole 5, template_var 3)),
         template_app
          (template_app
            (template_hole 4,
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app (template_hole 6, template_var 2)),
                   template_var 3)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_hole 2,
                     template_app (template_hole 1, template_hole 0))),
                 template_var 1))),
           template_app
            (template_hole 2,
             template_app
              (template_hole 1,
               template_app
                (template_hole 1,
                 template_app
                  (template_hole 1,
                   template_app (template_hole 1, template_hole 0))))))))),
    ("Recursive.mv_box_correct",
     "[| max ?m ?n < length ?lm; ?m ~= ?n |]
      ==> {%nl. nl = ?lm} mv_box ?m ?n
          {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_app (template_hole 10, template_var 2),
            template_var 1),
          template_app (template_hole 9, template_var 0)),
        template_negation
         (template_equation (template_var 2, template_var 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, t_empty),
               template_app
                (template_app (template_hole 4, template_var 2),
                 template_var 1)),
             t_empty)
           ))),
    ("Recursive.abc_list_crsp_steps",
     "[| abc_steps_l (0, ?lm @ 0 \<up> ?m) ?aprog ?stp = (?a, ?lm');
         ?aprog ~= [] |]
      ==> EX lma.
             abc_steps_l (0, ?lm) ?aprog ?stp = (?a, lma) &
             abc_list_crsp ?lm' lma",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 10,
                template_app
                 (template_app (template_hole 9, template_hole 8),
                  template_app
                   (template_app (template_hole 7, template_var 5),
                    template_app
                     (template_app (template_hole 6, template_var 4),
                      template_hole 8)))),
              template_var 3),
            template_var 2),
          template_app
           (template_app (template_hole 9, template_var 1),
            template_var 0)),
        template_negation
         (template_equation (template_var 3, template_hole 3))],
       template_predicate (template_app (template_hole 2, t_empty)))),
    ("Recursive.findnth_state_all_le1",
     "[| ?k < length ?ap; ?ap ! ?k = Inc ?n;
         (?a, ?b)
         : set (Turing.shift (findnth ?n)
                 (start_of (layout_of ?ap) ?k - Suc 0)) |]
      ==> ?b <= start_of (layout_of ?ap) (length ?ap)",
     template_implication
      ([template_inequation
         (less_than, template_var 4,
          template_app (template_hole 14, template_var 3)),
        template_equation
         (template_app
           (template_app (template_hole 12, template_var 3),
            template_var 4),
          template_app (template_hole 11, template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 10,
                template_app
                 (template_app (template_hole 9, template_var 1),
                  template_var 0)),
              template_app
               (template_hole 8,
                template_app
                 (template_app
                   (template_hole 7,
                    template_app (template_hole 6, template_var 2)),
                  template_app
                   (template_app
                     (template_hole 5,
                      template_app
                       (template_app
                         (template_hole 4,
                          template_app (template_hole 3, template_var 3)),
                        template_var 4)),
                    template_app (template_hole 2, template_hole 1)))))
            )],
       template_inequation
        (less_equals, template_var 0,
         template_app
          (template_app
            (template_hole 4,
             template_app (template_hole 3, template_var 3)),
           template_app (template_hole 14, template_var 3))))),
    ("Recursive.put_in_tape_small_enough1",
     "[| ?y <= ?rsx; 0 < ?y |]
      ==> EX ya.
             (?xs @ ?x # ?y # ?anything)[Suc (length ?xs) := ?y - Suc 0] =
             ?xs @ ?x # ya # ?anything &
             ya <= ?rsx",
     template_implication
      ([template_inequation (less_equals, template_var 4, template_var 3),
        template_inequation (less_than, template_hole 9, template_var 4)],
       template_predicate (template_app (template_hole 8, t_empty)))),
    ("Recursive.compile_append_dummy_correct",
     "[| rec_ci ?f = (?ap, ?ary, ?fp); terminate ?f ?args |]
      ==> {%nl. nl = ?args} ?ap [+] dummy_abc (length ?args)
          {%nl. EX m. nl = ?args @ rec_exec ?f ?args # 0 \<up> m}",
     template_implication
      ([template_equation
         (template_app (template_hole 14, template_var 4),
          template_app
           (template_app (template_hole 13, template_var 3),
            template_app
             (template_app (template_hole 12, template_var 2),
              template_var 1))),
        template_predicate
         (
            template_app
             (template_app (template_hole 11, template_var 4),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 10, t_empty),
               template_app
                (template_app (template_hole 8, template_var 3),
                 template_app
                  (template_hole 7,
                   template_app (template_hole 6, template_var 0)))),
             t_empty)
           ))),
    ("Recursive.findnth_state_all_le2",
     "[| ?k < length ?ap; ?ap ! ?k = Dec ?n ?e;
         (?a, ?b)
         : set (Turing.shift (findnth ?n)
                 (start_of (layout_of ?ap) ?k - Suc 0)) |]
      ==> ?b <= start_of (layout_of ?ap) (length ?ap)",
     template_implication
      ([template_inequation
         (less_than, template_var 5,
          template_app (template_hole 14, template_var 4)),
        template_equation
         (template_app
           (template_app (template_hole 12, template_var 4),
            template_var 5),
          template_app
           (template_app (template_hole 11, template_var 3),
            template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 10,
                template_app
                 (template_app (template_hole 9, template_var 1),
                  template_var 0)),
              template_app
               (template_hole 8,
                template_app
                 (template_app
                   (template_hole 7,
                    template_app (template_hole 6, template_var 3)),
                  template_app
                   (template_app
                     (template_hole 5,
                      template_app
                       (template_app
                         (template_hole 4,
                          template_app (template_hole 3, template_var 4)),
                        template_var 5)),
                    template_app (template_hole 2, template_hole 1)))))
            )],
       template_inequation
        (less_equals, template_var 0,
         template_app
          (template_app
            (template_hole 4,
             template_app (template_hole 3, template_var 4)),
           template_app (template_hole 14, template_var 4))))),
    ("Recursive.index_at_zero_elem",
     "(?xs @
       ?x #
       ?re #
       (0::?'a) \<up> (max (length ?xs + 3) (max ?fft ?gft) -
                       Suc (Suc (length ?xs))) @
       (0::?'a) # ?anything) !
      max (length ?xs + 3) (max ?fft ?gft) =
      (0::?'a)",
     template_equation
      (template_app
        (template_app
          (template_hole 12,
           template_app
            (template_app (template_hole 11, template_var 5),
             template_app
              (template_app (template_hole 10, template_var 4),
               template_app
                (template_app (template_hole 10, template_var 3),
                 template_app
                  (template_app
                    (template_hole 11,
                     template_app
                      (template_app
                        (template_hole 9,
                         template_app
                          (template_app
                            (template_hole 8,
                             template_app
                              (template_app
                                (template_hole 7,
                                 template_app
                                  (template_app
                                    (template_hole 6,
                                     template_app
(template_hole 5, template_var 5)),
                                   template_app
                                    (template_hole 4,
                                     template_app
(template_hole 3, template_hole 2)))),
                               template_app
                                (template_app
                                  (template_hole 7, template_var 2),
                                 template_var 1))),
                           template_app
                            (template_hole 1,
                             template_app
                              (template_hole 1,
                               template_app
                                (template_hole 5, template_var 5))))),
                       template_hole 0)),
                   template_app
                    (template_app (template_hole 10, template_hole 0),
                     template_var 0)))))),
         template_app
          (template_app
            (template_hole 7,
             template_app
              (template_app
                (template_hole 6,
                 template_app (template_hole 5, template_var 5)),
               template_app
                (template_hole 4,
                 template_app (template_hole 3, template_hole 2)))),
           template_app
            (template_app (template_hole 7, template_var 2),
             template_var 1))),
       template_hole 0)),
    ("Recursive.list_all_suc_many",
     "list_all (%(acn, s). s <= Suc (Suc (Suc (Suc (Suc (Suc (2 * ?n)))))))
       ?xs ==>
      list_all
       (%(acn, s).
           s <= Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc (2 * ?n)))))))))
       ?xs",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 7, template_app (template_hole 6, t_empty)),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 7, template_app (template_hole 6, t_empty)),
             template_var 0)
           ))),
    ("Recursive.mv_box_inv_halt",
     "[| max ?m ?n < length ?initlm; ?m ~= ?n |]
      ==> EX stp.
             case abc_steps_l (0, ?initlm) (mv_box ?m ?n) stp of
             (as, lm) => as = 3 & mv_box_inv (as, lm) ?m ?n ?initlm",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_app (template_hole 14, template_var 2),
            template_var 1),
          template_app (template_hole 13, template_var 0)),
        template_negation
         (template_equation (template_var 2, template_var 1))],
       template_predicate (template_app (template_hole 10, t_empty)))),
    ("Recursive.recursive_compile_correct_norm'",
     "[| rec_ci ?f = (?ap, ?arity, ?ft); terminate ?f ?args |]
      ==> EX stp rl.
             abc_steps_l (0, ?args) ?ap stp = (length ?ap, rl) &
             abc_list_crsp (?args @ [rec_exec ?f ?args]) rl",
     template_implication
      ([template_equation
         (template_app (template_hole 16, template_var 4),
          template_app
           (template_app (template_hole 15, template_var 3),
            template_app
             (template_app (template_hole 14, template_var 2),
              template_var 1))),
        template_predicate
         (
            template_app
             (template_app (template_hole 13, template_var 4),
              template_var 0)
            )],
       template_predicate (template_app (template_hole 12, t_empty)))),
    ("Recursive.compile_id_correct'",
     "?n < length ?args ==>
      {%nl. nl = ?args @ 0 \<up> 2 @ ?anything}
      addition ?n (length ?args) (Suc (length ?args))
      {%nl. nl =
            ?args @
            rec_exec (recf.id (length ?args) ?n) ?args # 0 # ?anything}",
     template_implication
      ([template_inequation
         (less_than, template_var 2,
          template_app (template_hole 13, template_var 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 12, t_empty),
               template_app
                (template_app
                  (template_app (template_hole 4, template_var 2),
                   template_app (template_hole 13, template_var 1)),
                 template_app
                  (template_hole 3,
                   template_app (template_hole 13, template_var 1)))),
             t_empty)
           ))),
    ("Recursive.mv_box_correct'",
     "[| max ?m ?n < length ?lm; ?m ~= ?n |]
      ==> EX stp.
             abc_steps_l (0, ?lm) (mv_box ?m ?n) stp =
             (3, ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0])",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_app (template_hole 15, template_var 2),
            template_var 1),
          template_app (template_hole 14, template_var 0)),
        template_negation
         (template_equation (template_var 2, template_var 1))],
       template_predicate (template_app (template_hole 11, t_empty)))),
    ("Recursive.adjust_paras",
     "length ?xs = ?n ==>
      {%nl. nl = ?xs @ ?x # ?y # ?anything}
      [Inc ?n, Dec (Suc ?n) 3, Goto (Suc 0)]
      {%nl. nl = ?xs @ Suc ?x # 0 # ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 14, template_var 4), template_var 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 13, t_empty),
               template_app
                (template_app
                  (template_hole 9,
                   template_app (template_hole 8, template_var 3)),
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app
                        (template_hole 7,
                         template_app (template_hole 6, template_var 3)),
                       template_app
                        (template_hole 5,
                         template_app (template_hole 4, template_hole 3)))),
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app
                        (template_hole 2,
                         template_app (template_hole 6, template_hole 1))),
                     template_hole 0)))),
             t_empty)
           ))),
    ("Recursive.inc_state_all_le",
     "[| ?k < length ?ap; ?ap ! ?k = Inc ?n;
         (?a, ?b)
         : set (Turing.shift (Turing.shift tinc_b (2 * ?n))
                 (start_of (layout_of ?ap) ?k - Suc 0)) |]
      ==> ?b <= start_of (layout_of ?ap) (length ?ap)",
     template_implication
      ([template_inequation
         (less_than, template_var 4,
          template_app (template_hole 18, template_var 3)),
        template_equation
         (template_app
           (template_app (template_hole 16, template_var 3),
            template_var 4),
          template_app (template_hole 15, template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 14,
                template_app
                 (template_app (template_hole 13, template_var 1),
                  template_var 0)),
              template_app
               (template_hole 12,
                template_app
                 (template_app
                   (template_hole 11,
                    template_app
                     (template_app (template_hole 11, template_hole 10),
                      template_app
                       (template_app
                         (template_hole 9,
                          template_app
                           (template_hole 8,
                            template_app
                             (template_hole 7, template_hole 6))),
                        template_var 2))),
                  template_app
                   (template_app
                     (template_hole 5,
                      template_app
                       (template_app
                         (template_hole 4,
                          template_app (template_hole 3, template_var 3)),
                        template_var 4)),
                    template_app (template_hole 2, template_hole 1)))))
            )],
       template_inequation
        (less_equals, template_var 0,
         template_app
          (template_app
            (template_hole 4,
             template_app (template_hole 3, template_var 3)),
           template_app (template_hole 18, template_var 3))))),
    ("Recursive.last_0",
     "[| Suc ?n <= ?ba - ?aa; length ?lm2.0 = Suc ?n;
         length ?lm3.0 = ?ba - Suc (?aa + ?n) |]
      ==> (last ?lm2.0 # ?lm3.0 @ butlast ?lm2.0 @ 0 # ?lm4.0) !
          (?ba - ?aa) =
          0",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 10, template_var 5),
          template_app
           (template_app (template_hole 9, template_var 4),
            template_var 3)),
        template_equation
         (template_app (template_hole 7, template_var 2),
          template_app (template_hole 10, template_var 5)),
        template_equation
         (template_app (template_hole 7, template_var 1),
          template_app
           (template_app (template_hole 9, template_var 4),
            template_app
             (template_hole 10,
              template_app
               (template_app (template_hole 6, template_var 3),
                template_var 5))))],
       template_equation
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 3, template_var 2)),
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_app
                  (template_app
                    (template_hole 2,
                     template_app (template_hole 1, template_var 2)),
                   template_app
                    (template_app (template_hole 4, template_hole 0),
                     template_var 0))))),
           template_app
            (template_app (template_hole 9, template_var 4),
             template_var 3)),
         template_hole 0))),
    ("Recursive.adjust_paras'",
     "length ?xs = ?n ==>
      {%nl. nl = ?xs @ ?x # ?y # ?anything}
      [Inc ?n] [+] [Dec (Suc ?n) 2, Goto 0]
      {%nl. nl = ?xs @ Suc ?x # 0 # ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 15, template_var 4), template_var 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 14, t_empty),
               template_app
                (template_app
                  (template_hole 10,
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app (template_hole 8, template_var 3)),
                     template_hole 7)),
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app
                        (template_hole 6,
                         template_app (template_hole 5, template_var 3)),
                       template_app
                        (template_hole 4,
                         template_app (template_hole 3, template_hole 2)))),
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app (template_hole 1, template_hole 0)),
                     template_hole 7)))),
             t_empty)
           ))),
    ("Recursive.abc_list_crsp_simp4",
     "[| abc_list_crsp ?lma ?lmb; ~ ?m < length ?lma; ~ ?m < length ?lmb |]
      ==> abc_list_crsp (?lma @ 0 \<up> (?m - length ?lma) @ [?n])
           (?lmb @ 0 \<up> (?m - length ?lmb) @ [?n])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 3),
              template_var 2)
            ),
        template_negation
         (
            template_inequation
             (less_than, template_var 1,
              template_app (template_hole 6, template_var 3))
            ),
        template_negation
         (
            template_inequation
             (less_than, template_var 1,
              template_app (template_hole 6, template_var 2))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 9,
               template_app
                (template_app (template_hole 5, template_var 3),
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app
                      (template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, template_var 1),
                           template_app (template_hole 6, template_var 3))),
                       template_hole 2)),
                   template_app
                    (template_app (template_hole 1, template_var 0),
                     template_hole 0)))),
             template_app
              (template_app (template_hole 5, template_var 2),
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, template_var 1),
                         template_app (template_hole 6, template_var 2))),
                     template_hole 2)),
                 template_app
                  (template_app (template_hole 1, template_var 0),
                   template_hole 0))))
           ))),
    ("Recursive.dec_state_all_le",
     "[| ?k < length ?ap; ?ap ! ?k = Dec ?n ?e;
         (?a, ?b)
         : set (Turing.shift (Turing.shift tdec_b (2 * ?n))
                 (start_of (layout_of ?ap) ?k - Suc 0)) |]
      ==> ?b <= start_of (layout_of ?ap) (length ?ap)",
     template_implication
      ([template_inequation
         (less_than, template_var 5,
          template_app (template_hole 18, template_var 4)),
        template_equation
         (template_app
           (template_app (template_hole 16, template_var 4),
            template_var 5),
          template_app
           (template_app (template_hole 15, template_var 3),
            template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 14,
                template_app
                 (template_app (template_hole 13, template_var 1),
                  template_var 0)),
              template_app
               (template_hole 12,
                template_app
                 (template_app
                   (template_hole 11,
                    template_app
                     (template_app (template_hole 11, template_hole 10),
                      template_app
                       (template_app
                         (template_hole 9,
                          template_app
                           (template_hole 8,
                            template_app
                             (template_hole 7, template_hole 6))),
                        template_var 3))),
                  template_app
                   (template_app
                     (template_hole 5,
                      template_app
                       (template_app
                         (template_hole 4,
                          template_app (template_hole 3, template_var 4)),
                        template_var 5)),
                    template_app (template_hole 2, template_hole 1)))))
            )],
       template_inequation
        (less_equals, template_var 0,
         template_app
          (template_app
            (template_hole 4,
             template_app (template_hole 3, template_var 4)),
           template_app (template_hole 18, template_var 4))))),
    ("Recursive.recursive_compile_correct",
     "[| terminate ?recf ?args; rec_ci ?recf = (?ap, ?arity, ?fp) |]
      ==> {%nl. nl = ?args @ 0 \<up> (?fp - ?arity) @ ?anything} ?ap
          {%nl. nl =
                ?args @
                rec_exec ?recf ?args #
                0 \<up> (?fp - Suc ?arity) @ ?anything}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 13, template_var 5),
              template_var 4)
            ),
        template_equation
         (template_app (template_hole 11, template_var 5),
          template_app
           (template_app (template_hole 10, template_var 3),
            template_app
             (template_app (template_hole 9, template_var 2),
              template_var 1)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 8, t_empty), template_var 3),
             t_empty)
           ))),
    ("Recursive.recursive_compile_to_tm_correct2",
     "terminate ?recf ?args ==>
      EX stp m l.
         steps0 (Suc 0, [Bk, Bk], <?args>) (tm_of_rec ?recf) stp =
         (0, Bk \<up> Suc (Suc m),
          Oc \<up> Suc (rec_exec ?recf ?args) @ Bk \<up> l)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 17, template_var 1),
              template_var 0)
            )],
       template_predicate (template_app (template_hole 16, t_empty)))),
    ("Recursive.addition_correct",
     "[| ?m ~= ?n; max ?m ?n < ?p; ?p < length ?lm; ?lm ! ?p = 0 |]
      ==> {%a. a = ?lm} addition ?m ?n ?p
          {%nl. addition_inv (7, nl) ?m ?n ?p ?lm}",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_var 2)),
        template_inequation
         (less_than,
          template_app
           (template_app (template_hole 11, template_var 3),
            template_var 2),
          template_var 1),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 10, template_var 0)),
        template_equation
         (template_app
           (template_app (template_hole 9, template_var 0), template_var 1),
          template_hole 8)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 7, t_empty),
               template_app
                (template_app
                  (template_app (template_hole 5, template_var 3),
                   template_var 2),
                 template_var 1)),
             t_empty)
           ))),
    ("Recursive.compile_s_correct",
     "[| rec_ci s = (?ap, ?arity, ?fp); rec_exec s [?n] = ?r |]
      ==> {%nl. nl = ?n # 0 \<up> (?fp - ?arity) @ ?anything} ?ap
          {%nl. nl = ?n # ?r # 0 \<up> (?fp - Suc ?arity) @ ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 14, template_hole 13),
          template_app
           (template_app (template_hole 12, template_var 5),
            template_app
             (template_app (template_hole 11, template_var 4),
              template_var 3))),
        template_equation
         (template_app
           (template_app (template_hole 9, template_hole 13),
            template_app
             (template_app (template_hole 8, template_var 2),
              template_hole 7)),
          template_var 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, t_empty), template_var 5),
             t_empty)
           ))),
    ("Recursive.compile_z_correct",
     "[| rec_ci z = (?ap, ?arity, ?fp); rec_exec z [?n] = ?r |]
      ==> {%nl. nl = ?n # 0 \<up> (?fp - ?arity) @ ?anything} ?ap
          {%nl. nl = ?n # ?r # 0 \<up> (?fp - Suc ?arity) @ ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 14, template_hole 13),
          template_app
           (template_app (template_hole 12, template_var 5),
            template_app
             (template_app (template_hole 11, template_var 4),
              template_var 3))),
        template_equation
         (template_app
           (template_app (template_hole 9, template_hole 13),
            template_app
             (template_app (template_hole 8, template_var 2),
              template_hole 7)),
          template_var 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, t_empty), template_var 5),
             t_empty)
           ))),
    ("Recursive.mv_box_correct_simp",
     "[| length ?xs = ?n; ?ft = max (?n + 3) (max ?fft ?gft) |]
      ==> {%nl. nl = ?xs @ 0 # 0 \<up> (?ft - ?n) @ ?anything} mv_box ?n ?ft
          {%nl. nl = ?xs @ 0 # 0 \<up> (?ft - ?n) @ ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 13, template_var 5), template_var 4),
        template_equation
         (template_var 3,
          template_app
           (template_app
             (template_hole 12,
              template_app
               (template_app (template_hole 11, template_var 4),
                template_app
                 (template_hole 10,
                  template_app (template_hole 9, template_hole 8)))),
            template_app
             (template_app (template_hole 12, template_var 2),
              template_var 1)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 7, t_empty),
               template_app
                (template_app (template_hole 0, template_var 4),
                 template_var 3)),
             t_empty)
           ))),
    ("Recursive.cn_merge_gs_split",
     "[| ?i < length ?gs; rec_ci (?gs ! ?i) = (?ga, ?gb, ?gc) |]
      ==> cn_merge_gs (map rec_ci ?gs) ?p =
          cn_merge_gs (map rec_ci (take ?i ?gs)) ?p [+]
          (?ga [+] mv_box ?gb (?p + ?i)) [+]
          cn_merge_gs (map rec_ci (drop (Suc ?i) ?gs)) (?p + Suc ?i)",
     template_implication
      ([template_inequation
         (less_than, template_var 5,
          template_app (template_hole 14, template_var 4)),
        template_equation
         (template_app
           (template_hole 12,
            template_app
             (template_app (template_hole 11, template_var 4),
              template_var 5)),
          template_app
           (template_app (template_hole 10, template_var 3),
            template_app
             (template_app (template_hole 9, template_var 2),
              template_var 1)))],
       template_equation
        (template_app
          (template_app
            (template_hole 7,
             template_app
              (template_app (template_hole 6, template_hole 12),
               template_var 4)),
           template_var 0),
         template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, template_hole 12),
                       template_app
                        (template_app (template_hole 4, template_var 5),
                         template_var 4))),
                   template_var 0)),
               template_app
                (template_app (template_hole 5, template_var 3),
                 template_app
                  (template_app (template_hole 3, template_var 2),
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     template_var 5))))),
           template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 6, template_hole 12),
                 template_app
                  (template_app
                    (template_hole 1,
                     template_app (template_hole 0, template_var 5)),
                   template_var 4))),
             template_app
              (template_app (template_hole 2, template_var 0),
               template_app (template_hole 0, template_var 5))))))),
    ("Recursive.mn_unhalt_case",
     "[| rec_ci (Mn ?n ?f) = (?ap, ?ar, ?ft) & length ?args = ?ar;
         ALL i.
            terminate ?f (?args @ [i]) & 0 < rec_exec ?f (?args @ [i]) |]
      ==> {%nl. nl = ?args @ 0 \<up> (?ft - ?ar) @ ?anything} ?ap \<up>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 19,
                template_app
                 (template_app
                   (template_hole 18,
                    template_app
                     (template_hole 17,
                      template_app
                       (template_app (template_hole 16, template_var 6),
                        template_var 5))),
                  template_app
                   (template_app (template_hole 15, template_var 4),
                    template_app
                     (template_app (template_hole 14, template_var 3),
                      template_var 2)))),
              template_app
               (template_app
                 (template_hole 13,
                  template_app (template_hole 12, template_var 1)),
                template_var 3))
            ),
        template_predicate (template_app (template_hole 11, t_empty))],
       template_predicate
        (
           template_app
            (template_app (template_hole 3, t_empty), template_var 4)
           ))),
    ("Recursive.find_exponent_complex",
     "[| ?args @ [rec_exec ?f ?args] = ?lm @ 0 \<up> ?n;
         ~ length ?args < length ?lm |]
      ==> EX m. (?lm @ 0 \<up> (length ?args - length ?lm) @ [Suc 0])
                [length ?args := 0] =
                ?args @ rec_exec ?f ?args # 0 \<up> m",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 12, template_var 3),
            template_app
             (template_app
               (template_hole 11,
                template_app
                 (template_app (template_hole 10, template_var 2),
                  template_var 3)),
              template_hole 9)),
          template_app
           (template_app (template_hole 12, template_var 1),
            template_app
             (template_app (template_hole 8, template_var 0),
              template_hole 7))),
        template_negation
         (
            template_inequation
             (less_than, template_app (template_hole 4, template_var 3),
              template_app (template_hole 4, template_var 1))
            )],
       template_predicate (template_app (template_hole 3, t_empty)))),
    ("Recursive.rec_ci_SucSuc_n",
     "[| rec_ci ?g = (?gap, ?gar, ?gft);
         ALL y<?x.
            terminate ?g (?xs @ [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]);
         length ?xs = ?n; Suc ?y <= ?x |]
      ==> ?gar = Suc (Suc ?n)",
     template_implication
      ([template_equation
         (template_app (template_hole 15, template_var 8),
          template_app
           (template_app (template_hole 14, template_var 7),
            template_app
             (template_app (template_hole 13, template_var 6),
              template_var 5))),
        template_predicate (template_app (template_hole 12, t_empty)),
        template_equation
         (template_app (template_hole 2, template_var 3), template_var 2),
        template_inequation
         (less_equals, template_app (template_hole 0, template_var 0),
          template_var 4)],
       template_equation
        (template_var 6,
         template_app
          (template_hole 0,
           template_app (template_hole 0, template_var 2))))),
    ("Recursive.addition_correct'",
     "[| ?m ~= ?n; max ?m ?n < ?p; ?p < length ?lm; ?lm ! ?p = 0 |]
      ==> EX stp.
             case abc_steps_l (0, ?lm) (addition ?m ?n ?p) stp of
             (as, lm') => as = 7 & addition_inv (as, lm') ?m ?n ?p ?lm",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_var 2)),
        template_inequation
         (less_than,
          template_app
           (template_app (template_hole 13, template_var 3),
            template_var 2),
          template_var 1),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 12, template_var 0)),
        template_equation
         (template_app
           (template_app (template_hole 11, template_var 0),
            template_var 1),
          template_hole 10)],
       template_predicate (template_app (template_hole 9, t_empty)))),
    ("Recursive.save_init_rs",
     "[| length ?xs = ?n; ?ft = max (?n + 3) (max ?fft ?gft) |]
      ==> {%nl. nl = ?xs @ rec_exec ?f ?xs # 0 \<up> (?ft - ?n) @ ?anything}
          mv_box ?n (Suc ?n)
          {%nl. nl =
                ?xs @
                0 # rec_exec ?f ?xs # 0 \<up> (?ft - Suc ?n) @ ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 15, template_var 6), template_var 5),
        template_equation
         (template_var 4,
          template_app
           (template_app
             (template_hole 14,
              template_app
               (template_app (template_hole 13, template_var 5),
                template_app
                 (template_hole 12,
                  template_app (template_hole 11, template_hole 10)))),
            template_app
             (template_app (template_hole 14, template_var 3),
              template_var 2)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 9, t_empty),
               template_app
                (template_app (template_hole 1, template_var 5),
                 template_app (template_hole 0, template_var 5))),
             t_empty)
           ))),
    ("Recursive.butlast_elem",
     "[| Suc ?n <= ?ba - ?aa; ?aa < ?ba; length ?lm1.0 = ?aa;
         length ?lm2.0 = Suc ?n; length ?lm3.0 = ?ba - Suc (?aa + ?n) |]
      ==> (?lm1.0 @
           (0::?'a) \<up> ?n @
           last ?lm2.0 # ?lm3.0 @ butlast ?lm2.0 @ (0::?'a) # ?lm4.0) !
          (?ba + ?n) =
          (0::?'a)",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 13, template_var 6),
          template_app
           (template_app (template_hole 12, template_var 5),
            template_var 4)),
        template_inequation (less_than, template_var 4, template_var 5),
        template_equation
         (template_app (template_hole 9, template_var 3), template_var 4),
        template_equation
         (template_app (template_hole 9, template_var 2),
          template_app (template_hole 13, template_var 6)),
        template_equation
         (template_app (template_hole 9, template_var 1),
          template_app
           (template_app (template_hole 12, template_var 5),
            template_app
             (template_hole 13,
              template_app
               (template_app (template_hole 8, template_var 4),
                template_var 6))))],
       template_equation
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 5, template_var 3),
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 4, template_var 6),
                     template_hole 3)),
                 template_app
                  (template_app
                    (template_hole 2,
                     template_app (template_hole 1, template_var 2)),
                   template_app
                    (template_app (template_hole 5, template_var 1),
                     template_app
                      (template_app
                        (template_hole 5,
                         template_app (template_hole 0, template_var 2)),
                       template_app
                        (template_app (template_hole 2, template_hole 3),
                         template_var 0))))))),
           template_app
            (template_app (template_hole 8, template_var 5),
             template_var 6)),
         template_hole 3))),
    ("Recursive.compile_id_correct",
     "[| ?n < ?m; length ?xs = ?m;
         rec_ci (recf.id ?m ?n) = (?ap, ?arity, ?fp);
         rec_exec (recf.id ?m ?n) ?xs = ?r |]
      ==> {%nl. nl = ?xs @ 0 \<up> (?fp - ?arity) @ ?anything} ?ap
          {%nl. nl = ?xs @ ?r # 0 \<up> (?fp - Suc ?arity) @ ?anything}",
     template_implication
      ([template_inequation (less_than, template_var 7, template_var 6),
        template_equation
         (template_app (template_hole 14, template_var 5), template_var 6),
        template_equation
         (template_app
           (template_hole 12,
            template_app
             (template_app (template_hole 11, template_var 6),
              template_var 7)),
          template_app
           (template_app (template_hole 10, template_var 4),
            template_app
             (template_app (template_hole 9, template_var 3),
              template_var 2))),
        template_equation
         (template_app
           (template_app
             (template_hole 8,
              template_app
               (template_app (template_hole 11, template_var 6),
                template_var 7)),
            template_var 5),
          template_var 1)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 7, t_empty), template_var 4),
             t_empty)
           ))),
    ("Recursive.mv_box_max_plus_3_correct",
     "length ?xs = ?n ==>
      {%nl. nl =
            ?xs @
            ?x # 0 \<up> (max (?n + 3) (max ?fft ?gft) - ?n) @ ?anything}
      mv_box ?n (max (?n + 3) (max ?fft ?gft))
      {%nl. nl =
            ?xs @
            0 \<up> (max (?n + 3) (max ?fft ?gft) - ?n) @ ?x # ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 13, template_var 5), template_var 4)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 12, t_empty),
               template_app
                (template_app (template_hole 0, template_var 4),
                 template_app
                  (template_app
                    (template_hole 6,
                     template_app
                      (template_app (template_hole 5, template_var 4),
                       template_app
                        (template_hole 4,
                         template_app (template_hole 3, template_hole 2)))),
                   template_app
                    (template_app (template_hole 6, template_var 2),
                     template_var 1)))),
             t_empty)
           ))),
    ("Recursive.terminate_mn_reverse",
     "[| terminate (Mn ?n ?f) ?xs;
         !!r. [| length ?xs = ?n; terminate ?f (?xs @ [r]);
                 rec_exec ?f (?xs @ [r]) = 0;
                 ALL i<r.
                    terminate ?f (?xs @ [i]) &
                    0 < rec_exec ?f (?xs @ [i]) |]
              ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 13,
                template_app
                 (template_app (template_hole 12, template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 11, t_empty))],
       template_predicate (template_var 0))),
    ("Recursive.mv_boxes_correct2",
     "[| ?n <= ?aa - ?ba; ?ba < ?aa; length ?lm1.0 = ?ba;
         length ?lm2.0 = ?aa - ?ba - ?n; length ?lm3.0 = ?n |]
      ==> {%nl. nl = ?lm1.0 @ 0 \<up> ?n @ ?lm2.0 @ ?lm3.0 @ ?lm4.0}
          mv_boxes ?aa ?ba ?n
          {%nl. nl = ?lm1.0 @ ?lm3.0 @ ?lm2.0 @ 0 \<up> ?n @ ?lm4.0}",
     template_implication
      ([template_inequation
         (less_equals, template_var 6,
          template_app
           (template_app (template_hole 9, template_var 5),
            template_var 4)),
        template_inequation (less_than, template_var 4, template_var 5),
        template_equation
         (template_app (template_hole 6, template_var 3), template_var 4),
        template_equation
         (template_app (template_hole 6, template_var 2),
          template_app
           (template_app
             (template_hole 9,
              template_app
               (template_app (template_hole 9, template_var 5),
                template_var 4)),
            template_var 6)),
        template_equation
         (template_app (template_hole 6, template_var 1), template_var 6)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, t_empty),
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 5),
                   template_var 4),
                 template_var 6)),
             t_empty)
           ))),
    ("Recursive.mv_boxes_correct",
     "[| ?aa + ?n <= ?ba; ?aa < ?ba; length ?lm1.0 = ?aa;
         length ?lm2.0 = ?n; length ?lm3.0 = ?ba - ?aa - ?n |]
      ==> {%nl. nl = ?lm1.0 @ ?lm2.0 @ ?lm3.0 @ 0 \<up> ?n @ ?lm4.0}
          mv_boxes ?aa ?ba ?n
          {%nl. nl = ?lm1.0 @ 0 \<up> ?n @ ?lm3.0 @ ?lm2.0 @ ?lm4.0}",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_app (template_hole 10, template_var 6),
            template_var 5),
          template_var 4),
        template_inequation (less_than, template_var 6, template_var 4),
        template_equation
         (template_app (template_hole 7, template_var 3), template_var 6),
        template_equation
         (template_app (template_hole 7, template_var 2), template_var 5),
        template_equation
         (template_app (template_hole 7, template_var 1),
          template_app
           (template_app
             (template_hole 6,
              template_app
               (template_app (template_hole 6, template_var 4),
                template_var 6)),
            template_var 5))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, t_empty),
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 6),
                   template_var 4),
                 template_var 5)),
             t_empty)
           ))),
    ("Recursive.mv_box_ok_suc_simp",
     "length ?xs = ?n ==>
      {%nl. nl =
            ?xs @
            rec_exec ?f ?xs #
            0 \<up> (max (?n + 3) (max ?fft ?gft) - Suc ?n) @
            ?x # ?anything}
      mv_box ?n (Suc ?n)
      {%nl. nl =
            ?xs @
            0 #
            rec_exec ?f ?xs #
            0 \<up> (max (?n + 3) (max ?fft ?gft) - Suc (Suc ?n)) @
            ?x # ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 15, template_var 6), template_var 5)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 14, t_empty),
               template_app
                (template_app (template_hole 0, template_var 5),
                 template_app (template_hole 2, template_var 5))),
             t_empty)
           ))),
    ("Recursive.loop_back",
     "[| length ?A = length ?gap + 4; length ?xs = ?n |]
      ==> EX stp.
             abc_steps_l (length ?A, ?xs @ ?m # 0 # ?x # ?anything)
              (?A @
               [Dec (Suc (Suc ?n)) 0, Inc (Suc ?n), Goto (length ?gap + 4)])
              stp =
             (0, ?xs @ ?m # ?x # 0 # ?anything)",
     template_implication
      ([template_equation
         (template_app (template_hole 20, template_var 6),
          template_app
           (template_app
             (template_hole 19,
              template_app (template_hole 18, template_var 5)),
            template_app
             (template_hole 17,
              template_app
               (template_hole 16,
                template_app (template_hole 16, template_hole 15))))),
        template_equation
         (template_app (template_hole 14, template_var 4), template_var 3)],
       template_predicate (template_app (template_hole 13, t_empty)))),
    ("Recursive.loop_back'",
     "[| length ?A = length ?gap + 4; length ?xs = ?n; ?x <= ?y |]
      ==> EX stp.
             abc_steps_l (length ?A, ?xs @ ?m # (?y - ?x) # ?x # ?anything)
              (?A @
               [Dec (Suc (Suc ?n)) 0, Inc (Suc ?n), Goto (length ?gap + 4)])
              stp =
             (length ?A, ?xs @ ?m # ?y # 0 # ?anything)",
     template_implication
      ([template_equation
         (template_app (template_hole 22, template_var 7),
          template_app
           (template_app
             (template_hole 21,
              template_app (template_hole 20, template_var 6)),
            template_app
             (template_hole 19,
              template_app
               (template_hole 18,
                template_app (template_hole 18, template_hole 17))))),
        template_equation
         (template_app (template_hole 16, template_var 5), template_var 4),
        template_inequation (less_equals, template_var 3, template_var 2)],
       template_predicate (template_app (template_hole 14, t_empty)))),
    ("Recursive.update_butlast_eq0",
     "[| Suc ?n <= ?ba - ?aa; ?aa < ?ba; length ?lm1.0 = ?aa;
         length ?lm2.0 = Suc ?n; length ?lm3.0 = ?ba - Suc (?aa + ?n) |]
      ==> (?lm1.0 @
           0 \<up> ?n @ last ?lm2.0 # ?lm3.0 @ butlast ?lm2.0 @ 0 # ?lm4.0)
          [?ba + ?n := last ?lm2.0, ?aa + ?n := 0] =
          ?lm1.0 @ 0 # 0 \<up> ?n @ ?lm3.0 @ ?lm2.0 @ ?lm4.0",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 13, template_var 6),
          template_app
           (template_app (template_hole 12, template_var 5),
            template_var 4)),
        template_inequation (less_than, template_var 4, template_var 5),
        template_equation
         (template_app (template_hole 9, template_var 3), template_var 4),
        template_equation
         (template_app (template_hole 9, template_var 2),
          template_app (template_hole 13, template_var 6)),
        template_equation
         (template_app (template_hole 9, template_var 1),
          template_app
           (template_app (template_hole 12, template_var 5),
            template_app
             (template_hole 13,
              template_app
               (template_app (template_hole 8, template_var 4),
                template_var 6))))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app
                  (template_app
                    (template_hole 6,
                     template_app
                      (template_app (template_hole 5, template_var 3),
                       template_app
                        (template_app
                          (template_hole 5,
                           template_app
                            (template_app (template_hole 4, template_var 6),
                             template_hole 3)),
                         template_app
                          (template_app
                            (template_hole 2,
                             template_app
                              (template_hole 1, template_var 2)),
                           template_app
                            (template_app (template_hole 5, template_var 1),
                             template_app
                              (template_app
                                (template_hole 5,
                                 template_app
                                  (template_hole 0, template_var 2)),
                               template_app
                                (template_app
                                  (template_hole 2, template_hole 3),
                                 template_var 0))))))),
                   template_app
                    (template_app (template_hole 8, template_var 5),
                     template_var 6)),
                 template_app (template_hole 1, template_var 2))),
             template_app
              (template_app (template_hole 8, template_var 4),
               template_var 6)),
           template_hole 3),
         template_app
          (template_app (template_hole 5, template_var 3),
           template_app
            (template_app (template_hole 2, template_hole 3),
             template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app (template_hole 4, template_var 6),
                   template_hole 3)),
               template_app
                (template_app (template_hole 5, template_var 1),
                 template_app
                  (template_app (template_hole 5, template_var 2),
                   template_var 0)))))))),
    ("Recursive.exists_smaller_in_list1",
     "[| ?m ~= ?n; ?m < length ?initlm; ?n < length ?initlm;
         Suc (?k + ?l) = ?initlm ! ?m + ?initlm ! ?n; ?k < ?initlm ! ?m |]
      ==> EX ka la.
             ?initlm[?m := ?k, ?n := ?l, ?n := Suc ?l] = ?initlm
             [?m := ka, ?n := la] &
             ka + la = ?initlm ! ?m + ?initlm ! ?n & ka <= ?initlm ! ?m",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 4,
          template_app (template_hole 8, template_var 2)),
        template_inequation
         (less_than, template_var 3,
          template_app (template_hole 8, template_var 2)),
        template_equation
         (template_app
           (template_hole 7,
            template_app
             (template_app (template_hole 6, template_var 1),
              template_var 0)),
          template_app
           (template_app
             (template_hole 6,
              template_app
               (template_app (template_hole 5, template_var 2),
                template_var 4)),
            template_app
             (template_app (template_hole 5, template_var 2),
              template_var 3))),
        template_inequation
         (less_than, template_var 1,
          template_app
           (template_app (template_hole 5, template_var 2),
            template_var 4))],
       template_predicate (template_app (template_hole 4, t_empty)))),
    ("Recursive.abc_lm_s_simp0",
     "length ?xs = ?n ==>
      abc_lm_s
       (?xs @
        ?x #
        rec_exec (Pr ?n ?f ?g) (?xs @ [?x]) #
        0 \<up> (max (?n + 3) (max ?fft ?gft) - Suc (Suc ?n)) @
        0 # ?anything)
       (max (?n + 3) (max ?fft ?gft)) 0 =
      ?xs @
      ?x #
      rec_exec (Pr ?n ?f ?g) (?xs @ [?x]) #
      0 \<up> (max (?n + 3) (max ?fft ?gft) - Suc ?n) @ ?anything",
     template_implication
      ([template_equation
         (template_app (template_hole 16, template_var 7), template_var 6)],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 14,
               template_app
                (template_app (template_hole 13, template_var 7),
                 template_app
                  (template_app (template_hole 12, template_var 5),
                   template_app
                    (template_app
                      (template_hole 12,
                       template_app
                        (template_app
                          (template_hole 11,
                           template_app
                            (template_app
                              (template_app
                                (template_hole 10, template_var 6),
                               template_var 4),
                             template_var 3)),
                         template_app
                          (template_app (template_hole 13, template_var 7),
                           template_app
                            (template_app
                              (template_hole 12, template_var 5),
                             template_hole 9)))),
                     template_app
                      (template_app
                        (template_hole 13,
                         template_app
                          (template_app
                            (template_hole 8,
                             template_app
                              (template_app
                                (template_hole 7,
                                 template_app
                                  (template_app
                                    (template_hole 6,
                                     template_app
(template_app (template_hole 5, template_var 6),
 template_app
  (template_hole 4, template_app (template_hole 3, template_hole 2)))),
                                   template_app
                                    (template_app
(template_hole 6, template_var 2),
                                     template_var 1))),
                               template_app
                                (template_hole 1,
                                 template_app
                                  (template_hole 1, template_var 6)))),
                           template_hole 0)),
                       template_app
                        (template_app (template_hole 12, template_hole 0),
                         template_var 0)))))),
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_app (template_hole 5, template_var 6),
                   template_app
                    (template_hole 4,
                     template_app (template_hole 3, template_hole 2)))),
               template_app
                (template_app (template_hole 6, template_var 2),
                 template_var 1))),
           template_hole 0),
         template_app
          (template_app (template_hole 13, template_var 7),
           template_app
            (template_app (template_hole 12, template_var 5),
             template_app
              (template_app
                (template_hole 12,
                 template_app
                  (template_app
                    (template_hole 11,
                     template_app
                      (template_app
                        (template_app (template_hole 10, template_var 6),
                         template_var 4),
                       template_var 3)),
                   template_app
                    (template_app (template_hole 13, template_var 7),
                     template_app
                      (template_app (template_hole 12, template_var 5),
                       template_hole 9)))),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_app
                          (template_hole 7,
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_app
                                  (template_hole 5, template_var 6),
                                 template_app
                                  (template_hole 4,
                                   template_app
                                    (template_hole 3, template_hole 2)))),
                             template_app
                              (template_app
                                (template_hole 6, template_var 2),
                               template_var 1))),
                         template_app (template_hole 1, template_var 6))),
                     template_hole 0)),
                 template_var 0))))))),
    ("Recursive.abc_steps_prop",
     "[| max ?m ?n < length ?initlm; ?m ~= ?n |]
      ==> ~ (case abc_steps_l (0, ?initlm) (mv_box ?m ?n) ?na of
             (as, lm) => %m. as = 3)
             ?m &
          mv_box_inv (abc_steps_l (0, ?initlm) (mv_box ?m ?n) ?na) ?m ?n
           ?initlm -->
          mv_box_inv (abc_steps_l (0, ?initlm) (mv_box ?m ?n) (Suc ?na)) ?m
           ?n ?initlm &
          ((abc_steps_l (0, ?initlm) (mv_box ?m ?n) (Suc ?na), ?m),
           abc_steps_l (0, ?initlm) (mv_box ?m ?n) ?na, ?m)
          : mv_box_LE",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_app (template_hole 19, template_var 3),
            template_var 2),
          template_app (template_hole 18, template_var 1)),
        template_negation
         (template_equation (template_var 3, template_var 2))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 15,
               template_app
                (template_app
                  (template_hole 14,
                   template_app
                    (template_hole 17,
                     template_app
                      (template_app
                        (template_app (template_hole 13, t_empty),
                         template_app
                          (template_app
                            (template_app
                              (template_hole 9,
                               template_app
                                (template_app
                                  (template_hole 8, template_hole 7),
                                 template_var 1)),
                             template_app
                              (template_app
                                (template_hole 6, template_var 3),
                               template_var 2)),
                           template_var 0)),
                       template_var 3))),
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_hole 5,
                         template_app
                          (template_app
                            (template_app
                              (template_hole 9,
                               template_app
                                (template_app
                                  (template_hole 8, template_hole 7),
                                 template_var 1)),
                             template_app
                              (template_app
                                (template_hole 6, template_var 3),
                               template_var 2)),
                           template_var 0)),
                       template_var 3),
                     template_var 2),
                   template_var 1))),
             template_app
              (template_app
                (template_hole 14,
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_hole 5,
                         template_app
                          (template_app
                            (template_app
                              (template_hole 9,
                               template_app
                                (template_app
                                  (template_hole 8, template_hole 7),
                                 template_var 1)),
                             template_app
                              (template_app
                                (template_hole 6, template_var 3),
                               template_var 2)),
                           template_app (template_hole 4, template_var 0))),
                       template_var 3),
                     template_var 2),
                   template_var 1)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app
                      (template_hole 2,
                       template_app
                        (template_app
                          (template_hole 1,
                           template_app
                            (template_app
                              (template_app
                                (template_hole 9,
                                 template_app
                                  (template_app
                                    (template_hole 8, template_hole 7),
                                   template_var 1)),
                               template_app
                                (template_app
                                  (template_hole 6, template_var 3),
                                 template_var 2)),
                             template_app
                              (template_hole 4, template_var 0))),
                         template_var 3)),
                     template_app
                      (template_app
                        (template_hole 1,
                         template_app
                          (template_app
                            (template_app
                              (template_hole 9,
                               template_app
                                (template_app
                                  (template_hole 8, template_hole 7),
                                 template_var 1)),
                             template_app
                              (template_app
                                (template_hole 6, template_var 3),
                               template_var 2)),
                           template_var 0)),
                       template_var 3))),
                 template_hole 0)))
           ))),
    ("Recursive.recursive_compile_to_tm_correct1",
     "[| rec_ci ?recf = (?ap, ?ary, ?fp); terminate ?recf ?args;
         ?tp = tm_of (?ap [+] dummy_abc (length ?args)) |]
      ==> EX stp m l.
             steps0 (Suc 0, Bk # Bk # ?ires, <?args> @ Bk \<up> ?rn)
              (?tp @ Turing.shift (mopup (length ?args)) (length ?tp div 2))
              stp =
             (0, Bk \<up> m @ Bk # Bk # ?ires,
              Oc \<up> Suc (rec_exec ?recf ?args) @ Bk \<up> l)",
     template_implication
      ([template_equation
         (template_app (template_hole 31, template_var 7),
          template_app
           (template_app (template_hole 30, template_var 6),
            template_app
             (template_app (template_hole 29, template_var 5),
              template_var 4))),
        template_predicate
         (
            template_app
             (template_app (template_hole 28, template_var 7),
              template_var 3)
            ),
        template_equation
         (template_var 2,
          template_app
           (template_hole 26,
            template_app
             (template_app (template_hole 25, template_var 6),
              template_app
               (template_hole 24,
                template_app (template_hole 23, template_var 3)))))],
       template_predicate (template_app (template_hole 22, t_empty)))),
    ("Recursive.exists_smaller_in_list0",
     "[| ?m ~= ?n; ?m < length ?initlm; ?n < length ?initlm;
         ?k + ?l = ?initlm ! ?m + ?initlm ! ?n; ?k <= ?initlm ! ?m;
         0 < ?k |]
      ==> EX ka la.
             ?initlm[?m := ?k, ?n := ?l, ?m := ?k - Suc 0] = ?initlm
             [?m := ka, ?n := la] &
             Suc (ka + la) = ?initlm ! ?m + ?initlm ! ?n &
             ka < ?initlm ! ?m",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 4,
          template_app (template_hole 10, template_var 2)),
        template_inequation
         (less_than, template_var 3,
          template_app (template_hole 10, template_var 2)),
        template_equation
         (template_app
           (template_app (template_hole 9, template_var 1), template_var 0),
          template_app
           (template_app
             (template_hole 9,
              template_app
               (template_app (template_hole 8, template_var 2),
                template_var 4)),
            template_app
             (template_app (template_hole 8, template_var 2),
              template_var 3))),
        template_inequation
         (less_equals, template_var 1,
          template_app
           (template_app (template_hole 8, template_var 2),
            template_var 4)),
        template_inequation (less_than, template_hole 6, template_var 1)],
       template_predicate (template_app (template_hole 5, t_empty)))),
    ("Recursive.exists_small_list_elem7",
     "[| ?m ~= ?n; ?p < length ?lm; ?lm ! ?p = 0; ?m < ?p; ?n < ?p;
         ?x < ?lm ! ?m |]
      ==> EX xa<=?lm ! ?m.
             ?lm[?m := Suc ?x, ?n := ?lm ! ?n + ?lm ! ?m,
                 ?p := ?lm ! ?m - Suc ?x] =
             ?lm[?m := xa, ?n := ?lm ! ?n + ?lm ! ?m, ?p := ?lm ! ?m - xa]",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 10, template_var 1)),
        template_equation
         (template_app
           (template_app (template_hole 9, template_var 1), template_var 2),
          template_hole 8),
        template_inequation (less_than, template_var 4, template_var 2),
        template_inequation (less_than, template_var 3, template_var 2),
        template_inequation
         (less_than, template_var 0,
          template_app
           (template_app (template_hole 9, template_var 1),
            template_var 4))],
       template_predicate (template_app (template_hole 7, t_empty)))),
    ("Recursive.exists_small_list_elem4",
     "[| ?m ~= ?n; ?p < length ?lm; ?lm ! ?p = 0; ?m < ?p; ?n < ?p;
         ?x < ?lm ! ?m |]
      ==> EX xa<=?lm ! ?m.
             ?lm[?m := ?x, ?n := ?lm ! ?n + ?lm ! ?m - ?x,
                 ?p := ?lm ! ?m - ?x] =
             ?lm[?m := xa, ?n := ?lm ! ?n + ?lm ! ?m - xa,
                 ?p := ?lm ! ?m - xa]",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 9, template_var 1)),
        template_equation
         (template_app
           (template_app (template_hole 8, template_var 1), template_var 2),
          template_hole 7),
        template_inequation (less_than, template_var 4, template_var 2),
        template_inequation (less_than, template_var 3, template_var 2),
        template_inequation
         (less_than, template_var 0,
          template_app
           (template_app (template_hole 8, template_var 1),
            template_var 4))],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("Recursive.mn_unhalt_case'",
     "[| rec_ci ?f = (?a, ?b, ?c);
         ALL i. terminate ?f (?args @ [i]) & 0 < rec_exec ?f (?args @ [i]);
         ?B =
         [Dec (Suc (length ?args)) (length ?a + 5),
          Dec (Suc (length ?args)) (length ?a + 3), Goto (Suc (length ?a)),
          Inc (length ?args), Goto 0] |]
      ==> {%nl. nl =
                ?args @
                0 \<up> (max (Suc (length ?args)) ?c - length ?args) @
                ?anything}
          ?a @ ?B \<up>",
     template_implication
      ([template_equation
         (template_app (template_hole 31, template_var 6),
          template_app
           (template_app (template_hole 30, template_var 5),
            template_app
             (template_app (template_hole 29, template_var 4),
              template_var 3))),
        template_predicate (template_app (template_hole 28, t_empty)),
        template_equation
         (template_var 1,
          template_app
           (template_app
             (template_hole 18,
              template_app
               (template_app
                 (template_hole 17,
                  template_app
                   (template_hole 16,
                    template_app (template_hole 15, template_var 2))),
                template_app
                 (template_app
                   (template_hole 14,
                    template_app (template_hole 13, template_var 5)),
                  template_app
                   (template_hole 12,
                    template_app
                     (template_hole 11,
                      template_app (template_hole 10, template_hole 9)))))),
            template_app
             (template_app
               (template_hole 18,
                template_app
                 (template_app
                   (template_hole 17,
                    template_app
                     (template_hole 16,
                      template_app (template_hole 15, template_var 2))),
                  template_app
                   (template_app
                     (template_hole 14,
                      template_app (template_hole 13, template_var 5)),
                    template_app
                     (template_hole 12,
                      template_app (template_hole 11, template_hole 9))))),
              template_app
               (template_app
                 (template_hole 18,
                  template_app
                   (template_hole 8,
                    template_app
                     (template_hole 16,
                      template_app (template_hole 13, template_var 5)))),
                template_app
                 (template_app
                   (template_hole 18,
                    template_app
                     (template_hole 7,
                      template_app (template_hole 15, template_var 2))),
                  template_app
                   (template_app
                     (template_hole 18,
                      template_app (template_hole 8, template_hole 21)),
                    template_hole 6))))))],
       template_predicate
        (
           template_app
            (template_app (template_hole 5, t_empty),
             template_app
              (template_app (template_hole 0, template_var 5),
               template_var 1))
           ))),
    ("Recursive.update_butlast_eq1",
     "[| Suc (length ?lm1.0 + ?n) <= ?ba; length ?lm2.0 = Suc ?n;
         length ?lm3.0 = ?ba - Suc (length ?lm1.0 + ?n);
         ~ ?ba - Suc (length ?lm1.0) < ?ba - Suc (length ?lm1.0 + ?n);
         ~ ?ba + ?n - length ?lm1.0 < ?n |]
      ==> 0 \<up> ?n @ (last ?lm2.0 # ?lm3.0 @ butlast ?lm2.0 @ 0 # ?lm4.0)
          [?ba - length ?lm1.0 := last ?lm2.0, 0 := 0] =
          0 # 0 \<up> ?n @ ?lm3.0 @ ?lm2.0 @ ?lm4.0",
     template_implication
      ([template_inequation
         (less_equals,
          template_app
           (template_hole 15,
            template_app
             (template_app
               (template_hole 14,
                template_app (template_hole 13, template_var 5)),
              template_var 4)),
          template_var 3),
        template_equation
         (template_app (template_hole 11, template_var 2),
          template_app (template_hole 15, template_var 4)),
        template_equation
         (template_app (template_hole 11, template_var 1),
          template_app
           (template_app (template_hole 10, template_var 3),
            template_app
             (template_hole 15,
              template_app
               (template_app
                 (template_hole 14,
                  template_app (template_hole 13, template_var 5)),
                template_var 4)))),
        template_negation
         (
            template_inequation
             (less_than,
              template_app
               (template_app (template_hole 10, template_var 3),
                template_app
                 (template_hole 15,
                  template_app (template_hole 13, template_var 5))),
              template_app
               (template_app (template_hole 10, template_var 3),
                template_app
                 (template_hole 15,
                  template_app
                   (template_app
                     (template_hole 14,
                      template_app (template_hole 13, template_var 5)),
                    template_var 4))))
            ),
        template_negation
         (
            template_inequation
             (less_than,
              template_app
               (template_app
                 (template_hole 10,
                  template_app
                   (template_app (template_hole 14, template_var 3),
                    template_var 4)),
                template_app (template_hole 13, template_var 5)),
              template_var 4)
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app (template_hole 5, template_var 4),
               template_hole 4)),
           template_app
            (template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app
                    (template_app
                      (template_hole 3,
                       template_app
                        (template_app
                          (template_hole 2,
                           template_app (template_hole 1, template_var 2)),
                         template_app
                          (template_app (template_hole 6, template_var 1),
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_hole 0, template_var 2)),
                             template_app
                              (template_app
                                (template_hole 2, template_hole 4),
                               template_var 0))))),
                     template_app
                      (template_app (template_hole 10, template_var 3),
                       template_app (template_hole 13, template_var 5))),
                   template_app (template_hole 1, template_var 2))),
               template_hole 4),
             template_hole 4)),
         template_app
          (template_app (template_hole 2, template_hole 4),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_var 4),
                 template_hole 4)),
             template_app
              (template_app (template_hole 6, template_var 1),
               template_app
                (template_app (template_hole 6, template_var 2),
                 template_var 0))))))),
    ("Recursive.exists_small_list_elem6",
     "[| ?m ~= ?n; ?p < length ?lm; ?lm ! ?p = 0; ?m < ?p; ?n < ?p;
         ?x < ?lm ! ?m |]
      ==> EX xa<?lm ! ?m.
             ?lm[?m := ?x, ?n := ?lm ! ?n + ?lm ! ?m,
                 ?p := ?lm ! ?m - Suc ?x, ?m := Suc ?x] =
             ?lm[?m := Suc xa, ?n := ?lm ! ?n + ?lm ! ?m,
                 ?p := ?lm ! ?m - Suc xa]",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 9, template_var 1)),
        template_equation
         (template_app
           (template_app (template_hole 8, template_var 1), template_var 2),
          template_hole 7),
        template_inequation (less_than, template_var 4, template_var 2),
        template_inequation (less_than, template_var 3, template_var 2),
        template_inequation
         (less_than, template_var 0,
          template_app
           (template_app (template_hole 8, template_var 1),
            template_var 4))],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("Recursive.exists_small_list_elem3",
     "[| ?m ~= ?n; ?p < length ?lm; ?lm ! ?p = 0; ?m < ?p; ?n < ?p;
         ?x < ?lm ! ?m |]
      ==> EX xa<?lm ! ?m.
             ?lm[?m := ?x, ?n := ?lm ! ?n + ?lm ! ?m - ?x,
                 ?p := ?lm ! ?m - Suc ?x, ?p := ?lm ! ?m - ?x] =
             ?lm[?m := xa, ?n := ?lm ! ?n + ?lm ! ?m - xa,
                 ?p := ?lm ! ?m - xa]",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 9, template_var 1)),
        template_equation
         (template_app
           (template_app (template_hole 8, template_var 1), template_var 2),
          template_hole 7),
        template_inequation (less_than, template_var 4, template_var 2),
        template_inequation (less_than, template_var 3, template_var 2),
        template_inequation
         (less_than, template_var 0,
          template_app
           (template_app (template_hole 8, template_var 1),
            template_var 4))],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("Recursive.update_butlast_eq2",
     "[| Suc ?n <= ?aa - length ?lm1.0; length ?lm1.0 < ?aa;
         length ?lm2.0 = ?aa - Suc (length ?lm1.0 + ?n);
         length ?lm3.0 = Suc ?n;
         ~ ?aa - Suc (length ?lm1.0) < ?aa - Suc (length ?lm1.0 + ?n);
         ~ ?aa + ?n - length ?lm1.0 < ?n |]
      ==> butlast ?lm3.0 @ (0 # ?lm2.0 @ 0 \<up> ?n @ last ?lm3.0 # ?lm4.0)
          [0 := last ?lm3.0, ?aa - length ?lm1.0 := 0] =
          ?lm3.0 @ ?lm2.0 @ 0 # 0 \<up> ?n @ ?lm4.0",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 15, template_var 5),
          template_app
           (template_app (template_hole 14, template_var 4),
            template_app (template_hole 13, template_var 3))),
        template_inequation
         (less_than, template_app (template_hole 13, template_var 3),
          template_var 4),
        template_equation
         (template_app (template_hole 10, template_var 2),
          template_app
           (template_app (template_hole 14, template_var 4),
            template_app
             (template_hole 15,
              template_app
               (template_app
                 (template_hole 9,
                  template_app (template_hole 13, template_var 3)),
                template_var 5)))),
        template_equation
         (template_app (template_hole 10, template_var 1),
          template_app (template_hole 15, template_var 5)),
        template_negation
         (
            template_inequation
             (less_than,
              template_app
               (template_app (template_hole 14, template_var 4),
                template_app
                 (template_hole 15,
                  template_app (template_hole 13, template_var 3))),
              template_app
               (template_app (template_hole 14, template_var 4),
                template_app
                 (template_hole 15,
                  template_app
                   (template_app
                     (template_hole 9,
                      template_app (template_hole 13, template_var 3)),
                    template_var 5))))
            ),
        template_negation
         (
            template_inequation
             (less_than,
              template_app
               (template_app
                 (template_hole 14,
                  template_app
                   (template_app (template_hole 9, template_var 4),
                    template_var 5)),
                template_app (template_hole 13, template_var 3)),
              template_var 5)
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 6,
             template_app (template_hole 5, template_var 1)),
           template_app
            (template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, template_hole 2),
                         template_app
                          (template_app (template_hole 6, template_var 2),
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_app
                                  (template_hole 1, template_var 5),
                                 template_hole 2)),
                             template_app
                              (template_app
                                (template_hole 3,
                                 template_app
                                  (template_hole 0, template_var 1)),
                               template_var 0))))),
                     template_hole 2),
                   template_app (template_hole 0, template_var 1))),
               template_app
                (template_app (template_hole 14, template_var 4),
                 template_app (template_hole 13, template_var 3))),
             template_hole 2)),
         template_app
          (template_app (template_hole 6, template_var 1),
           template_app
            (template_app (template_hole 6, template_var 2),
             template_app
              (template_app (template_hole 3, template_hole 2),
               template_app
                (template_app
                  (template_hole 6,
                   template_app
                    (template_app (template_hole 1, template_var 5),
                     template_hole 2)),
                 template_var 0))))))),
    ("Recursive.clean_paras",
     "length ?gs <= ?ffp ==>
      {%nl. nl =
            map (%i. rec_exec i ?xs) ?gs @
            0 \<up> (max (Suc (length ?xs))
                      (Max (insert ?ffp
                             ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) -
                     length ?gs) @
            rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
            0 \<up> length ?gs @ ?xs @ ?anything}
      empty_boxes (length ?gs)
      {%nl. nl =
            0 \<up> max (Suc (length ?xs))
                     (Max (insert ?ffp
                            ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) @
            rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
            0 \<up> length ?gs @ ?xs @ ?anything}",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 22, template_var 4),
          template_var 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 21, t_empty),
               template_app
                (template_hole 0,
                 template_app (template_hole 22, template_var 4))),
             t_empty)
           ))),
    ("Recursive.restore_new_paras",
     "length ?gs <= ?ffp ==>
      {%nl. nl =
            0 \<up> max (Suc (length ?xs))
                     (Max (insert ?ffp
                            ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) @
            map (%i. rec_exec i ?xs) ?gs @ 0 # ?xs @ ?anything}
      mv_boxes
       (max (Suc (length ?xs))
         (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs))))
       0 (length ?gs)
      {%nl. nl =
            map (%i. rec_exec i ?xs) ?gs @
            0 \<up> max (Suc (length ?xs))
                     (Max (insert ?ffp
                            ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) @
            0 # ?xs @ ?anything}",
     template_implication
      ([template_inequation
         (less_equals, template_app (template_hole 20, template_var 3),
          template_var 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 19, t_empty),
               template_app
                (template_app
                  (template_app
                    (template_hole 0,
                     template_app
                      (template_app
                        (template_hole 15,
                         template_app
                          (template_hole 14,
                           template_app
                            (template_hole 13, template_var 1))),
                       template_app
                        (template_hole 12,
                         template_app
                          (template_app (template_hole 11, template_var 2),
                           template_app
                            (template_app
                              (template_hole 10,
                               template_app (template_hole 9, t_empty)),
                             template_app
                              (template_app
                                (template_hole 7, template_hole 6),
                               template_app
                                (template_hole 5, template_var 3))))))),
                   template_hole 4),
                 template_app (template_hole 20, template_var 3))),
             t_empty)
           ))),
    ("Recursive.contract_dec_ft_length_plus_7",
     "[| ?ft = max (?n + 3) (max ?fft ?gft); length ?xs = ?n |]
      ==> {%nl. nl =
                ?xs @
                (?x - Suc ?y) #
                rec_exec (Pr ?n ?f ?g) (?xs @ [?x - Suc ?y]) #
                0 \<up> (?ft - Suc (Suc ?n)) @ Suc ?y # ?anything}
          [Dec ?ft (length ?gap + 7)]
          {%nl. nl =
                ?xs @
                (?x - Suc ?y) #
                rec_exec (Pr ?n ?f ?g) (?xs @ [?x - Suc ?y]) #
                0 \<up> (?ft - Suc (Suc ?n)) @ ?y # ?anything}",
     template_implication
      ([template_equation
         (template_var 10,
          template_app
           (template_app
             (template_hole 20,
              template_app
               (template_app (template_hole 19, template_var 9),
                template_app
                 (template_hole 18,
                  template_app (template_hole 17, template_hole 16)))),
            template_app
             (template_app (template_hole 20, template_var 8),
              template_var 7))),
        template_equation
         (template_app (template_hole 15, template_var 6), template_var 9)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 14, t_empty),
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 2, template_var 10),
                     template_app
                      (template_app
                        (template_hole 19,
                         template_app (template_hole 1, template_var 0)),
                       template_app
                        (template_hole 18,
                         template_app
                          (template_hole 17,
                           template_app
                            (template_hole 17, template_hole 16)))))),
                 template_hole 0)),
             t_empty)
           ))),
    ("Recursive.exists_small_list_elem1",
     "[| ?m ~= ?n; ?p < length ?lm; ?lm ! ?p = 0; ?m < ?p; ?n < ?p;
         ?x <= ?lm ! ?m; 0 < ?x |]
      ==> EX xa<?lm ! ?m.
             ?lm[?m := ?x, ?n := ?lm ! ?n + ?lm ! ?m - ?x,
                 ?p := ?lm ! ?m - ?x, ?m := ?x - Suc 0] =
             ?lm[?m := xa, ?n := ?lm ! ?n + ?lm ! ?m - Suc xa,
                 ?p := ?lm ! ?m - Suc xa]",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 10, template_var 1)),
        template_equation
         (template_app
           (template_app (template_hole 9, template_var 1), template_var 2),
          template_hole 8),
        template_inequation (less_than, template_var 4, template_var 2),
        template_inequation (less_than, template_var 3, template_var 2),
        template_inequation
         (less_equals, template_var 0,
          template_app
           (template_app (template_hole 9, template_var 1),
            template_var 4)),
        template_inequation (less_than, template_hole 8, template_var 0)],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("Recursive.exists_small_list_elem5",
     "[| ?m ~= ?n; ?p < length ?lm; ?lm ! ?p = 0; ?m < ?p; ?n < ?p;
         ?x <= ?lm ! ?m; ?lm ! ?m ~= ?x |]
      ==> EX xa<?lm ! ?m.
             ?lm[?m := ?x, ?n := ?lm ! ?n + ?lm ! ?m, ?p := ?lm ! ?m - ?x,
                 ?p := ?lm ! ?m - Suc ?x] =
             ?lm[?m := xa, ?n := ?lm ! ?n + ?lm ! ?m,
                 ?p := ?lm ! ?m - Suc xa]",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 10, template_var 1)),
        template_equation
         (template_app
           (template_app (template_hole 9, template_var 1), template_var 2),
          template_hole 8),
        template_inequation (less_than, template_var 4, template_var 2),
        template_inequation (less_than, template_var 3, template_var 2),
        template_inequation
         (less_equals, template_var 0,
          template_app
           (template_app (template_hole 9, template_var 1),
            template_var 4)),
        template_negation
         (
            template_equation
             (template_app
               (template_app (template_hole 9, template_var 1),
                template_var 4),
              template_var 0)
            )],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("Recursive.exists_small_list_elem2",
     "[| ?m ~= ?n; ?p < length ?lm; ?lm ! ?p = 0; ?m < ?p; ?n < ?p;
         ?x < ?lm ! ?m |]
      ==> EX xa<?lm ! ?m.
             ?lm[?m := ?x, ?n := ?lm ! ?n + ?lm ! ?m - Suc ?x,
                 ?p := ?lm ! ?m - Suc ?x, ?n := ?lm ! ?n + ?lm ! ?m - ?x] =
             ?lm[?m := xa, ?n := ?lm ! ?n + ?lm ! ?m - xa,
                 ?p := ?lm ! ?m - Suc xa]",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_var 3)),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 9, template_var 1)),
        template_equation
         (template_app
           (template_app (template_hole 8, template_var 1), template_var 2),
          template_hole 7),
        template_inequation (less_than, template_var 4, template_var 2),
        template_inequation (less_than, template_var 3, template_var 2),
        template_inequation
         (less_than, template_var 0,
          template_app
           (template_app (template_hole 8, template_var 1),
            template_var 4))],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("Recursive.save_paras",
     "{%nl. nl =
            ?xs @
            0 \<up> (max (Suc (length ?xs))
                      (Max (insert ?ffp
                             ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) -
                     length ?xs) @
            map (%i. rec_exec i ?xs) ?gs @
            0 \<up> Suc (length ?xs) @ ?anything}
      mv_boxes 0
       (Suc (max (Suc (length ?xs))
              (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) +
             length ?gs))
       (length ?xs)
      {%nl. nl =
            0 \<up> max (Suc (length ?xs))
                     (Max (insert ?ffp
                            ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) @
            map (%i. rec_exec i ?xs) ?gs @ 0 # ?xs @ ?anything}",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 22, t_empty),
             template_app
              (template_app
                (template_app (template_hole 3, template_hole 6),
                 template_app
                  (template_hole 16,
                   template_app
                    (template_app
                      (template_hole 2,
                       template_app
                        (template_app
                          (template_hole 17,
                           template_app
                            (template_hole 16,
                             template_app
                              (template_hole 15, template_var 3))),
                         template_app
                          (template_hole 14,
                           template_app
                            (template_app
                              (template_hole 13, template_var 2),
                             template_app
                              (template_app
                                (template_hole 12,
                                 template_app (template_hole 11, t_empty)),
                               template_app
                                (template_app
                                  (template_hole 9, template_hole 8),
                                 template_app
                                  (template_hole 7, template_var 1))))))),
                     template_app (template_hole 1, template_var 1)))),
               template_app (template_hole 15, template_var 3))),
           t_empty)
         )),
    ("Recursive.terminate_pr_reverse",
     "[| terminate (Pr ?n ?f ?g) ?xs;
         !!x xs.
            [| ?xs = xs @ [x];
               ALL y<x.
                  terminate ?g
                   (xs @
                    [y, if y = 0 then rec_exec ?f (butlast (xs @ [y]))
                        else rec_exec ?g
                              (butlast (xs @ [y]) @
                               [last (xs @ [y]) - 1,
                                rec_exec (Pr ?n ?f ?g)
                                 (butlast (xs @ [y]) @
                                  [last (xs @ [y]) - 1])])]);
               terminate ?f xs; length xs = ?n |]
            ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 19,
                template_app
                 (template_app
                   (template_app (template_hole 18, template_var 4),
                    template_var 3),
                  template_var 2)),
              template_var 1)
            ),
        template_predicate (template_app (template_hole 17, t_empty))],
       template_predicate (template_var 0))),
    ("Recursive.addition_halt_lemma",
     "[| ?m ~= ?n; max ?m ?n < ?p; ?p < length ?lm |]
      ==> ALL na.
             ~ (case abc_steps_l (0, ?lm) (addition ?m ?n ?p) na of
                (as, lm') => %(m, p). as = 7)
                (?m, ?p) &
             addition_inv (abc_steps_l (0, ?lm) (addition ?m ?n ?p) na) ?m
              ?n ?p ?lm -->
             addition_inv
              (abc_steps_l (0, ?lm) (addition ?m ?n ?p) (Suc na)) ?m ?n ?p
              ?lm &
             ((abc_steps_l (0, ?lm) (addition ?m ?n ?p) (Suc na), ?m, ?p),
              abc_steps_l (0, ?lm) (addition ?m ?n ?p) na, ?m, ?p)
             : addition_LE",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_var 2)),
        template_inequation
         (less_than,
          template_app
           (template_app (template_hole 20, template_var 3),
            template_var 2),
          template_var 1),
        template_inequation
         (less_than, template_var 1,
          template_app (template_hole 19, template_var 0))],
       template_predicate (template_app (template_hole 18, t_empty)))),
    ("Recursive.zero_case_rec_exec",
     "[| length ?xs < ?gf; ?gf <= ?ft; ?n < length ?gs |]
      ==> (rec_exec (?gs ! ?n) ?xs #
           0 \<up> (?ft - Suc (length ?xs)) @
           map (%i. rec_exec i ?xs) (take ?n ?gs) @
           0 \<up> (length ?gs - ?n) @ 0 # 0 \<up> length ?xs @ ?anything)
          [?ft + ?n - length ?xs := rec_exec (?gs ! ?n) ?xs, 0 := 0] =
          0 \<up> (?ft - length ?xs) @
          map (%i. rec_exec i ?xs) (take ?n ?gs) @
          rec_exec (?gs ! ?n) ?xs #
          0 \<up> (length ?gs - Suc ?n) @
          0 # 0 \<up> length ?xs @ ?anything",
     template_implication
      ([template_inequation
         (less_than, template_app (template_hole 15, template_var 5),
          template_var 4),
        template_inequation (less_equals, template_var 4, template_var 3),
        template_inequation
         (less_than, template_var 2,
          template_app (template_hole 13, template_var 1))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 11,
               template_app
                (template_app
                  (template_app
                    (template_hole 11,
                     template_app
                      (template_app
                        (template_hole 10,
                         template_app
                          (template_app
                            (template_hole 9,
                             template_app
                              (template_app
                                (template_hole 8, template_var 1),
                               template_var 2)),
                           template_var 5)),
                       template_app
                        (template_app
                          (template_hole 7,
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_app
                                  (template_hole 5, template_var 3),
                                 template_app
                                  (template_hole 4,
                                   template_app
                                    (template_hole 15, template_var 5)))),
                             template_hole 3)),
                         template_app
                          (template_app
                            (template_hole 7,
                             template_app
                              (template_app (template_hole 2, t_empty),
                               template_app
                                (template_app
                                  (template_hole 1, template_var 2),
                                 template_var 1))),
                           template_app
                            (template_app
                              (template_hole 7,
                               template_app
                                (template_app
                                  (template_hole 6,
                                   template_app
                                    (template_app
(template_hole 5, template_app (template_hole 13, template_var 1)),
                                     template_var 2)),
                                 template_hole 3)),
                             template_app
                              (template_app
                                (template_hole 10, template_hole 3),
                               template_app
                                (template_app
                                  (template_hole 7,
                                   template_app
                                    (template_app
(template_hole 6, template_app (template_hole 15, template_var 5)),
                                     template_hole 3)),
                                 template_var 0))))))),
                   template_app
                    (template_app
                      (template_hole 5,
                       template_app
                        (template_app (template_hole 0, template_var 3),
                         template_var 2)),
                     template_app (template_hole 15, template_var 5))),
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app (template_hole 8, template_var 1),
                       template_var 2)),
                   template_var 5))),
             template_hole 3),
           template_hole 3),
         template_app
          (template_app
            (template_hole 7,
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_app (template_hole 5, template_var 3),
                   template_app (template_hole 15, template_var 5))),
               template_hole 3)),
           template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 2, t_empty),
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 1))),
             template_app
              (template_app
                (template_hole 10,
                 template_app
                  (template_app
                    (template_hole 9,
                     template_app
                      (template_app (template_hole 8, template_var 1),
                       template_var 2)),
                   template_var 5)),
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app
                      (template_hole 6,
                       template_app
                        (template_app
                          (template_hole 5,
                           template_app (template_hole 13, template_var 1)),
                         template_app (template_hole 4, template_var 2))),
                     template_hole 3)),
                 template_app
                  (template_app (template_hole 10, template_hole 3),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_hole 6,
                           template_app (template_hole 15, template_var 5)),
                         template_hole 3)),
                     template_var 0))))))))),
    ("Recursive.restore_rs",
     "{%nl. nl =
            0 \<up> max (Suc (length ?xs))
                     (Max (insert ?ffp
                            ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) @
            rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
            0 \<up> length ?gs @ ?xs @ ?anything}
      mv_box
       (max (Suc (length ?xs))
         (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs))))
       (length ?xs)
      {%nl. nl =
            0 \<up> length ?xs @
            rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
            0 \<up> (max (Suc (length ?xs))
                      (Max (insert ?ffp
                             ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) -
                     length ?xs) @
            0 \<up> length ?gs @ ?xs @ ?anything}",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 21, t_empty),
             template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app
                    (template_hole 17,
                     template_app
                      (template_hole 16,
                       template_app (template_hole 15, template_var 4))),
                   template_app
                    (template_hole 14,
                     template_app
                      (template_app (template_hole 13, template_var 3),
                       template_app
                        (template_app
                          (template_hole 12,
                           template_app (template_hole 11, t_empty)),
                         template_app
                          (template_app (template_hole 9, template_hole 8),
                           template_app
                            (template_hole 7, template_var 2))))))),
               template_app (template_hole 15, template_var 4))),
           t_empty)
         )),
    ("Recursive.restore_orgin_paras",
     "{%nl. nl =
            0 \<up> length ?xs @
            rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
            0 \<up> (max (Suc (length ?xs))
                      (Max (insert ?ffp
                             ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) -
                     length ?xs) @
            0 \<up> length ?gs @ ?xs @ ?anything}
      mv_boxes
       (Suc (max (Suc (length ?xs))
              (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) +
             length ?gs))
       0 (length ?xs)
      {%nl. nl =
            ?xs @
            rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
            0 \<up> (max (Suc (length ?xs))
                      (Max (insert ?ffp
                             ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) +
                     length ?gs) @
            ?anything}",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 22, t_empty),
             template_app
              (template_app
                (template_app
                  (template_hole 1,
                   template_app
                    (template_hole 11,
                     template_app
                      (template_app
                        (template_hole 0,
                         template_app
                          (template_app
                            (template_hole 12,
                             template_app
                              (template_hole 11,
                               template_app
                                (template_hole 18, template_var 4))),
                           template_app
                            (template_hole 10,
                             template_app
                              (template_app
                                (template_hole 9, template_var 1),
                               template_app
                                (template_app
                                  (template_hole 8,
                                   template_app (template_hole 7, t_empty)),
                                 template_app
                                  (template_app
                                    (template_hole 5, template_hole 4),
                                   template_app
                                    (template_hole 3, template_var 2))))))),
                       template_app (template_hole 2, template_var 2)))),
                 template_hole 17),
               template_app (template_hole 18, template_var 4))),
           t_empty)
         )),
    ("Recursive.compile_cn_gs_correct",
     "[| ALL g:set ?gs.
            terminate g ?xs &
            (ALL x xa xb.
                rec_ci g = (x, xa, xb) -->
                (ALL xc.
                    {%nl. nl = ?xs @ 0 \<up> (xb - xa) @ xc} x
                    {%nl. nl =
                          ?xs @
                          rec_exec g ?xs # 0 \<up> (xb - Suc xa) @ xc}));
         ?ft =
         max (Suc (length ?xs))
          (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) |]
      ==> {%nl. nl = ?xs @ 0 # 0 \<up> (?ft + length ?gs) @ ?anything}
          cn_merge_gs (map rec_ci ?gs) ?ft
          {%nl. nl =
                ?xs @
                0 \<up> (?ft - length ?xs) @
                map (%i. rec_exec i ?xs) ?gs @
                0 \<up> Suc (length ?xs) @ ?anything}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 34,
                template_app (template_hole 33, template_var 4)),
              t_empty)
            ),
        template_equation
         (template_var 2,
          template_app
           (template_app
             (template_hole 12,
              template_app
               (template_hole 14,
                template_app (template_hole 11, template_var 3))),
            template_app
             (template_hole 10,
              template_app
               (template_app (template_hole 9, template_var 1),
                template_app
                 (template_app
                   (template_hole 8,
                    template_app (template_hole 7, t_empty)),
                  template_app
                   (template_app (template_hole 5, template_hole 26),
                    template_app (template_hole 33, template_var 4)))))))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 22, t_empty),
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_hole 26),
                     template_var 4)),
                 template_var 2)),
             t_empty)
           ))),
    ("Recursive.mn_correct",
     "[| rec_ci ?rf = (?fap, ?far, ?fft); 0 < ?rsx; length ?xs = ?arity;
         ?B =
         [Dec (Suc ?arity) (length ?fap + 5),
          Dec (Suc ?arity) (length ?fap + 3), Goto (Suc (length ?fap)),
          Inc ?arity, Goto 0];
         ?f =
         (%stp. (abc_steps_l (length ?fap, ?xs @ ?x # ?rsx # ?anything)
                  (?fap @ ?B) stp,
                 length ?fap, ?arity));
         ?P = (%((as, lm), ss, arity). as = 0);
         ?Q =
         (%((as, lm), ss, arity).
             mn_ind_inv (as, lm) (length ?fap) ?x ?rsx ?anything ?xs) |]
      ==> EX stp. ?P (?f stp) & ?Q (?f stp)",
     template_implication
      ([template_equation
         (template_app (template_hole 33, template_var 12),
          template_app
           (template_app (template_hole 32, template_var 11),
            template_app
             (template_app (template_hole 31, template_var 10),
              template_var 9))),
        template_inequation (less_than, template_hole 29, template_var 8),
        template_equation
         (template_app (template_hole 27, template_var 7), template_var 6),
        template_equation
         (template_var 5,
          template_app
           (template_app
             (template_hole 25,
              template_app
               (template_app
                 (template_hole 24,
                  template_app (template_hole 23, template_var 6)),
                template_app
                 (template_app
                   (template_hole 22,
                    template_app (template_hole 21, template_var 11)),
                  template_app
                   (template_hole 20,
                    template_app
                     (template_hole 19,
                      template_app
                       (template_hole 18, template_hole 17)))))),
            template_app
             (template_app
               (template_hole 25,
                template_app
                 (template_app
                   (template_hole 24,
                    template_app (template_hole 23, template_var 6)),
                  template_app
                   (template_app
                     (template_hole 22,
                      template_app (template_hole 21, template_var 11)),
                    template_app
                     (template_hole 20,
                      template_app (template_hole 19, template_hole 17))))),
              template_app
               (template_app
                 (template_hole 25,
                  template_app
                   (template_hole 16,
                    template_app
                     (template_hole 23,
                      template_app (template_hole 21, template_var 11)))),
                template_app
                 (template_app
                   (template_hole 25,
                    template_app (template_hole 15, template_var 6)),
                  template_app
                   (template_app
                     (template_hole 25,
                      template_app (template_hole 16, template_hole 29)),
                    template_hole 14)))))),
        template_equation (template_var 4, t_empty),
        template_equation
         (template_var 1,
          template_app
           (template_hole 5, template_app (template_hole 4, t_empty))),
        template_equation
         (template_var 0,
          template_app
           (template_hole 5, template_app (template_hole 4, t_empty)))],
       template_predicate (template_app (template_hole 1, t_empty)))),
    ("Recursive.compile_cn_gs_correct'",
     "[| ALL g:set (take ?n ?gs).
            terminate g ?xs &
            (ALL x xa xb.
                rec_ci g = (x, xa, xb) -->
                (ALL xc.
                    {%nl. nl = ?xs @ 0 \<up> (xb - xa) @ xc} x
                    {%nl. nl =
                          ?xs @
                          rec_exec g ?xs # 0 \<up> (xb - Suc xa) @ xc}));
         ?ft =
         max (Suc (length ?xs))
          (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) |]
      ==> {%nl. nl = ?xs @ 0 # 0 \<up> (?ft + length ?gs) @ ?anything}
          cn_merge_gs (map rec_ci (take ?n ?gs)) ?ft
          {%nl. nl =
                ?xs @
                0 \<up> (?ft - length ?xs) @
                map (%i. rec_exec i ?xs) (take ?n ?gs) @
                0 \<up> (length ?gs - ?n) @
                0 \<up> Suc (length ?xs) @ ?anything}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 35,
                template_app
                 (template_hole 34,
                  template_app
                   (template_app (template_hole 33, template_var 5),
                    template_var 4))),
              t_empty)
            ),
        template_equation
         (template_var 2,
          template_app
           (template_app
             (template_hole 12,
              template_app
               (template_hole 14,
                template_app (template_hole 11, template_var 3))),
            template_app
             (template_hole 10,
              template_app
               (template_app (template_hole 9, template_var 1),
                template_app
                 (template_app
                   (template_hole 8,
                    template_app (template_hole 7, t_empty)),
                  template_app
                   (template_app (template_hole 5, template_hole 26),
                    template_app (template_hole 34, template_var 4)))))))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 22, t_empty),
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 1, template_hole 26),
                     template_app
                      (template_app (template_hole 33, template_var 5),
                       template_var 4))),
                 template_var 2)),
             t_empty)
           ))),
    ("Recursive.save_rs",
     "[| ?far = length ?gs;
         ?ffp
         <= max (Suc (length ?xs))
             (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs)));
         ?far < ?ffp |]
      ==> {%nl. nl =
                map (%i. rec_exec i ?xs) ?gs @
                rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
                0 \<up> max (Suc (length ?xs))
                         (Max (insert ?ffp
                                ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) @
                ?xs @ ?anything}
          mv_box ?far
           (max (Suc (length ?xs))
             (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs))))
          {%nl. nl =
                map (%i. rec_exec i ?xs) ?gs @
                0 \<up> (max (Suc (length ?xs))
                          (Max (insert ?ffp
                                 ((%(aprog, p, n). n) `
                                  rec_ci ` set ?gs))) -
                         length ?gs) @
                rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
                0 \<up> length ?gs @ ?xs @ ?anything}",
     template_implication
      ([template_equation
         (template_var 5, template_app (template_hole 24, template_var 4)),
        template_inequation
         (less_equals, template_var 3,
          template_app
           (template_app
             (template_hole 22,
              template_app
               (template_hole 21,
                template_app (template_hole 20, template_var 2))),
            template_app
             (template_hole 19,
              template_app
               (template_app (template_hole 18, template_var 3),
                template_app
                 (template_app
                   (template_hole 17,
                    template_app (template_hole 16, t_empty)),
                  template_app
                   (template_app (template_hole 14, template_hole 13),
                    template_app (template_hole 12, template_var 4))))))),
        template_inequation (less_than, template_var 5, template_var 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 10, t_empty),
               template_app
                (template_app (template_hole 1, template_var 5),
                 template_app
                  (template_app
                    (template_hole 22,
                     template_app
                      (template_hole 21,
                       template_app (template_hole 20, template_var 2))),
                   template_app
                    (template_hole 19,
                     template_app
                      (template_app (template_hole 18, template_var 3),
                       template_app
                        (template_app
                          (template_hole 17,
                           template_app (template_hole 16, t_empty)),
                         template_app
                          (template_app
                            (template_hole 14, template_hole 13),
                           template_app
                            (template_hole 12, template_var 4)))))))),
             t_empty)
           ))),
    ("Recursive.cn_unhalt_case",
     "[| rec_ci (Cn ?n ?f ?gs) = (?ap, ?ar, ?ft) & length ?args = ?ar;
         ?i < length ?gs;
         rec_ci (?gs ! ?i) = (?gap, ?gar, ?gft) & ?gar = length ?args;
         !!anything.
            {%nl. nl = ?args @ 0 \<up> (?gft - ?gar) @ anything} ?gap \<up>;
         !!apj arj ftj j anything.
            [| j < ?i; rec_ci (?gs ! j) = (apj, arj, ftj) |]
            ==> {%nl. nl = ?args @ 0 \<up> (ftj - arj) @ anything} apj
                {%nl. nl =
                      ?args @
                      rec_exec (?gs ! j) ?args #
                      0 \<up> (ftj - Suc arj) @ anything};
         ALL j<?i. terminate (?gs ! j) ?args |]
      ==> {%nl. nl = ?args @ 0 \<up> (?ft - ?ar) @ ?anything} ?ap \<up>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 26,
                template_app
                 (template_app
                   (template_hole 25,
                    template_app
                     (template_hole 24,
                      template_app
                       (template_app
                         (template_app (template_hole 23, template_var 11),
                          template_var 10),
                        template_var 9))),
                  template_app
                   (template_app (template_hole 22, template_var 8),
                    template_app
                     (template_app (template_hole 21, template_var 7),
                      template_var 6)))),
              template_app
               (template_app
                 (template_hole 20,
                  template_app (template_hole 19, template_var 5)),
                template_var 7))
            ),
        template_inequation
         (less_than, template_var 4,
          template_app (template_hole 17, template_var 9)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 26,
                template_app
                 (template_app
                   (template_hole 25,
                    template_app
                     (template_hole 24,
                      template_app
                       (template_app (template_hole 16, template_var 9),
                        template_var 4))),
                  template_app
                   (template_app (template_hole 22, template_var 3),
                    template_app
                     (template_app (template_hole 21, template_var 2),
                      template_var 1)))),
              template_app
               (template_app (template_hole 20, template_var 2),
                template_app (template_hole 19, template_var 5)))
            ),
        template_predicate (template_app (template_hole 15, t_empty)),
        template_predicate (template_app (template_hole 8, t_empty)),
        template_predicate (template_app (template_hole 2, t_empty))],
       template_predicate
        (
           template_app
            (template_app (template_hole 14, t_empty), template_var 8)
           ))),
    ("Recursive.mn_loop",
     "[| ?B =
         [Dec (Suc ?arity) (length ?fap + 5),
          Dec (Suc ?arity) (length ?fap + 3), Goto (Suc (length ?fap)),
          Inc ?arity, Goto 0];
         ?ft = max (Suc ?arity) ?fft; length ?xs = ?arity;
         ?far = Suc ?arity;
         ALL xc.
            {%nl. nl = ?xs @ ?x # 0 \<up> (?fft - ?far) @ xc} ?fap
            {%nl. nl =
                  ?xs @
                  ?x #
                  rec_exec ?f (?xs @ [?x]) #
                  0 \<up> (?fft - Suc ?far) @ xc};
         0 < rec_exec ?f (?xs @ [?x]); rec_ci ?f = (?fap, ?far, ?fft) |]
      ==> EX stp>0.
             abc_steps_l
              (0, ?xs @ ?x # 0 \<up> (?ft - Suc ?arity) @ ?anything)
              (?fap @ ?B) stp =
             (0, ?xs @ Suc ?x # 0 \<up> (?ft - Suc ?arity) @ ?anything)",
     template_implication
      ([template_equation
         (template_var 9,
          template_app
           (template_app
             (template_hole 35,
              template_app
               (template_app
                 (template_hole 34,
                  template_app (template_hole 33, template_var 8)),
                template_app
                 (template_app
                   (template_hole 32,
                    template_app (template_hole 31, template_var 7)),
                  template_app
                   (template_hole 30,
                    template_app
                     (template_hole 29,
                      template_app
                       (template_hole 28, template_hole 27)))))),
            template_app
             (template_app
               (template_hole 35,
                template_app
                 (template_app
                   (template_hole 34,
                    template_app (template_hole 33, template_var 8)),
                  template_app
                   (template_app
                     (template_hole 32,
                      template_app (template_hole 31, template_var 7)),
                    template_app
                     (template_hole 30,
                      template_app (template_hole 29, template_hole 27))))),
              template_app
               (template_app
                 (template_hole 35,
                  template_app
                   (template_hole 26,
                    template_app
                     (template_hole 33,
                      template_app (template_hole 31, template_var 7)))),
                template_app
                 (template_app
                   (template_hole 35,
                    template_app (template_hole 25, template_var 8)),
                  template_app
                   (template_app
                     (template_hole 35,
                      template_app (template_hole 26, template_hole 24)),
                    template_hole 23)))))),
        template_equation
         (template_var 6,
          template_app
           (template_app
             (template_hole 21,
              template_app (template_hole 33, template_var 8)),
            template_var 5)),
        template_equation
         (template_app (template_hole 20, template_var 4), template_var 8),
        template_equation
         (template_var 3, template_app (template_hole 33, template_var 8)),
        template_predicate (template_app (template_hole 19, t_empty)),
        template_inequation
         (less_than, template_hole 24,
          template_app
           (template_app (template_hole 12, template_var 1),
            template_app
             (template_app (template_hole 16, template_var 4),
              template_app
               (template_app (template_hole 15, template_var 2),
                template_hole 11)))),
        template_equation
         (template_app (template_hole 8, template_var 1),
          template_app
           (template_app (template_hole 7, template_var 7),
            template_app
             (template_app (template_hole 6, template_var 3),
              template_var 5)))],
       template_predicate (template_app (template_hole 5, t_empty)))),
    ("Recursive.mn_loop_correct",
     "[| ?B =
         [Dec (Suc ?arity) (length ?fap + 5),
          Dec (Suc ?arity) (length ?fap + 3), Goto (Suc (length ?fap)),
          Inc ?arity, Goto 0];
         ?ft = max (Suc ?arity) ?fft; length ?xs = ?arity;
         ALL i<=?x.
            ALL xc.
               {%nl. nl = ?xs @ i # 0 \<up> (?fft - ?far) @ xc} ?fap
               {%nl. nl =
                     ?xs @
                     i #
                     rec_exec ?f (?xs @ [i]) #
                     0 \<up> (?fft - Suc ?far) @ xc};
         ALL i<=?x. 0 < rec_exec ?f (?xs @ [i]);
         rec_ci ?f = (?fap, ?far, ?fft); ?far = Suc ?arity |]
      ==> EX stp.
             abc_steps_l
              (0, ?xs @ 0 # 0 \<up> (?ft - Suc ?arity) @ ?anything)
              (?fap @ ?B) stp =
             (0, ?xs @ Suc ?x # 0 \<up> (?ft - Suc ?arity) @ ?anything)",
     template_implication
      ([template_equation
         (template_var 9,
          template_app
           (template_app
             (template_hole 37,
              template_app
               (template_app
                 (template_hole 36,
                  template_app (template_hole 35, template_var 8)),
                template_app
                 (template_app
                   (template_hole 34,
                    template_app (template_hole 33, template_var 7)),
                  template_app
                   (template_hole 32,
                    template_app
                     (template_hole 31,
                      template_app
                       (template_hole 30, template_hole 29)))))),
            template_app
             (template_app
               (template_hole 37,
                template_app
                 (template_app
                   (template_hole 36,
                    template_app (template_hole 35, template_var 8)),
                  template_app
                   (template_app
                     (template_hole 34,
                      template_app (template_hole 33, template_var 7)),
                    template_app
                     (template_hole 32,
                      template_app (template_hole 31, template_hole 29))))),
              template_app
               (template_app
                 (template_hole 37,
                  template_app
                   (template_hole 28,
                    template_app
                     (template_hole 35,
                      template_app (template_hole 33, template_var 7)))),
                template_app
                 (template_app
                   (template_hole 37,
                    template_app (template_hole 27, template_var 8)),
                  template_app
                   (template_app
                     (template_hole 37,
                      template_app (template_hole 28, template_hole 26)),
                    template_hole 25)))))),
        template_equation
         (template_var 6,
          template_app
           (template_app
             (template_hole 23,
              template_app (template_hole 35, template_var 8)),
            template_var 5)),
        template_equation
         (template_app (template_hole 22, template_var 4), template_var 8),
        template_predicate (template_app (template_hole 21, t_empty)),
        template_predicate (template_app (template_hole 21, t_empty)),
        template_equation
         (template_app (template_hole 7, template_var 1),
          template_app
           (template_app (template_hole 6, template_var 7),
            template_app
             (template_app (template_hole 5, template_var 2),
              template_var 5))),
        template_equation
         (template_var 2, template_app (template_hole 35, template_var 8))],
       template_predicate (template_app (template_hole 4, t_empty)))),
    ("Recursive.mp_up_all_le",
     "list_all (%(acn, s). s <= ?q + (2 * ?n + 6))
       [(R, Suc (Suc (2 * ?n + ?q))), (R, Suc (2 * ?n + ?q)),
        (L, 5 + 2 * ?n + ?q), (W0, Suc (Suc (Suc (2 * ?n + ?q)))),
        (R, 4 + 2 * ?n + ?q), (W0, Suc (Suc (Suc (2 * ?n + ?q)))),
        (R, Suc (Suc (2 * ?n + ?q))), (W0, Suc (Suc (Suc (2 * ?n + ?q)))),
        (L, 5 + 2 * ?n + ?q), (L, 6 + 2 * ?n + ?q), (R, 0),
        (L, 6 + 2 * ?n + ?q)]",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 16, template_app (template_hole 15, t_empty)),
           template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 6, template_hole 5),
                 template_app
                  (template_hole 4,
                   template_app
                    (template_hole 4,
                     template_app
                      (template_app
                        (template_hole 13,
                         template_app
                          (template_app
                            (template_hole 12,
                             template_app
                              (template_hole 11,
                               template_app
                                (template_hole 10, template_hole 9))),
                           template_var 0)),
                       template_var 1))))),
             template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_app (template_hole 6, template_hole 5),
                   template_app
                    (template_hole 4,
                     template_app
                      (template_app
                        (template_hole 13,
                         template_app
                          (template_app
                            (template_hole 12,
                             template_app
                              (template_hole 11,
                               template_app
                                (template_hole 10, template_hole 9))),
                           template_var 0)),
                       template_var 1)))),
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app (template_hole 6, template_hole 3),
                     template_app
                      (template_app
                        (template_hole 13,
                         template_app
                          (template_app
                            (template_hole 13,
                             template_app
                              (template_hole 11,
                               template_app
                                (template_hole 8,
                                 template_app
                                  (template_hole 10, template_hole 9)))),
                           template_app
                            (template_app
                              (template_hole 12,
                               template_app
                                (template_hole 11,
                                 template_app
                                  (template_hole 10, template_hole 9))),
                             template_var 0))),
                       template_var 1))),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, template_hole 2),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_hole 4,
                           template_app
                            (template_hole 4,
                             template_app
                              (template_app
                                (template_hole 13,
                                 template_app
                                  (template_app
                                    (template_hole 12,
                                     template_app
(template_hole 11, template_app (template_hole 10, template_hole 9))),
                                   template_var 0)),
                               template_var 1)))))),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 6, template_hole 5),
                         template_app
                          (template_app
                            (template_hole 13,
                             template_app
                              (template_app
                                (template_hole 13,
                                 template_app
                                  (template_hole 11,
                                   template_app
                                    (template_hole 10,
                                     template_app
(template_hole 10, template_hole 9)))),
                               template_app
                                (template_app
                                  (template_hole 12,
                                   template_app
                                    (template_hole 11,
                                     template_app
(template_hole 10, template_hole 9))),
                                 template_var 0))),
                           template_var 1))),
                     template_app
                      (template_app
                        (template_hole 7,
                         template_app
                          (template_app (template_hole 6, template_hole 2),
                           template_app
                            (template_hole 4,
                             template_app
                              (template_hole 4,
                               template_app
                                (template_hole 4,
                                 template_app
                                  (template_app
                                    (template_hole 13,
                                     template_app
(template_app
  (template_hole 12,
   template_app
    (template_hole 11, template_app (template_hole 10, template_hole 9))),
 template_var 0)),
                                   template_var 1)))))),
                       template_app
                        (template_app
                          (template_hole 7,
                           template_app
                            (template_app
                              (template_hole 6, template_hole 5),
                             template_app
                              (template_hole 4,
                               template_app
                                (template_hole 4,
                                 template_app
                                  (template_app
                                    (template_hole 13,
                                     template_app
(template_app
  (template_hole 12,
   template_app
    (template_hole 11, template_app (template_hole 10, template_hole 9))),
 template_var 0)),
                                   template_var 1))))),
                         template_app
                          (template_app
                            (template_hole 7,
                             template_app
                              (template_app
                                (template_hole 6, template_hole 2),
                               template_app
                                (template_hole 4,
                                 template_app
                                  (template_hole 4,
                                   template_app
                                    (template_hole 4,
                                     template_app
(template_app
  (template_hole 13,
   template_app
    (template_app
      (template_hole 12,
       template_app
        (template_hole 11,
         template_app (template_hole 10, template_hole 9))),
     template_var 0)),
 template_var 1)))))),
                           template_app
                            (template_app
                              (template_hole 7,
                               template_app
                                (template_app
                                  (template_hole 6, template_hole 3),
                                 template_app
                                  (template_app
                                    (template_hole 13,
                                     template_app
(template_app
  (template_hole 13,
   template_app
    (template_hole 11,
     template_app
      (template_hole 8, template_app (template_hole 10, template_hole 9)))),
 template_app
  (template_app
    (template_hole 12,
     template_app
      (template_hole 11, template_app (template_hole 10, template_hole 9))),
   template_var 0))),
                                   template_var 1))),
                             template_app
                              (template_app
                                (template_hole 7,
                                 template_app
                                  (template_app
                                    (template_hole 6, template_hole 3),
                                   template_app
                                    (template_app
(template_hole 13,
 template_app
  (template_app
    (template_hole 13,
     template_app
      (template_hole 11,
       template_app
        (template_hole 10,
         template_app (template_hole 8, template_hole 9)))),
   template_app
    (template_app
      (template_hole 12,
       template_app
        (template_hole 11,
         template_app (template_hole 10, template_hole 9))),
     template_var 0))),
                                     template_var 1))),
                               template_app
                                (template_app
                                  (template_hole 7,
                                   template_app
                                    (template_app
(template_hole 6, template_hole 5),
                                     template_hole 1)),
                                 template_app
                                  (template_app
                                    (template_hole 7,
                                     template_app
(template_app (template_hole 6, template_hole 3),
 template_app
  (template_app
    (template_hole 13,
     template_app
      (template_app
        (template_hole 13,
         template_app
          (template_hole 11,
           template_app
            (template_hole 10,
             template_app (template_hole 8, template_hole 9)))),
       template_app
        (template_app
          (template_hole 12,
           template_app
            (template_hole 11,
             template_app (template_hole 10, template_hole 9))),
         template_var 0))),
   template_var 1))),
                                   template_hole 0)))))))))))))
         )),
    ("Recursive.mn_loop_correct'",
     "[| ?B =
         [Dec (Suc ?arity) (length ?fap + 5),
          Dec (Suc ?arity) (length ?fap + 3), Goto (Suc (length ?fap)),
          Inc ?arity, Goto 0];
         ?ft = max (Suc ?arity) ?fft; length ?xs = ?arity;
         ALL i<=?x.
            ALL xc.
               {%nl. nl = ?xs @ i # 0 \<up> (?fft - ?far) @ xc} ?fap
               {%nl. nl =
                     ?xs @
                     i #
                     rec_exec ?f (?xs @ [i]) #
                     0 \<up> (?fft - Suc ?far) @ xc};
         ALL i<=?x. 0 < rec_exec ?f (?xs @ [i]);
         rec_ci ?f = (?fap, ?far, ?fft); ?far = Suc ?arity |]
      ==> EX stp>?x.
             abc_steps_l
              (0, ?xs @ 0 # 0 \<up> (?ft - Suc ?arity) @ ?anything)
              (?fap @ ?B) stp =
             (0, ?xs @ Suc ?x # 0 \<up> (?ft - Suc ?arity) @ ?anything)",
     template_implication
      ([template_equation
         (template_var 9,
          template_app
           (template_app
             (template_hole 38,
              template_app
               (template_app
                 (template_hole 37,
                  template_app (template_hole 36, template_var 8)),
                template_app
                 (template_app
                   (template_hole 35,
                    template_app (template_hole 34, template_var 7)),
                  template_app
                   (template_hole 33,
                    template_app
                     (template_hole 32,
                      template_app
                       (template_hole 31, template_hole 30)))))),
            template_app
             (template_app
               (template_hole 38,
                template_app
                 (template_app
                   (template_hole 37,
                    template_app (template_hole 36, template_var 8)),
                  template_app
                   (template_app
                     (template_hole 35,
                      template_app (template_hole 34, template_var 7)),
                    template_app
                     (template_hole 33,
                      template_app (template_hole 32, template_hole 30))))),
              template_app
               (template_app
                 (template_hole 38,
                  template_app
                   (template_hole 29,
                    template_app
                     (template_hole 36,
                      template_app (template_hole 34, template_var 7)))),
                template_app
                 (template_app
                   (template_hole 38,
                    template_app (template_hole 28, template_var 8)),
                  template_app
                   (template_app
                     (template_hole 38,
                      template_app (template_hole 29, template_hole 27)),
                    template_hole 26)))))),
        template_equation
         (template_var 6,
          template_app
           (template_app
             (template_hole 24,
              template_app (template_hole 36, template_var 8)),
            template_var 5)),
        template_equation
         (template_app (template_hole 23, template_var 4), template_var 8),
        template_predicate (template_app (template_hole 22, t_empty)),
        template_predicate (template_app (template_hole 22, t_empty)),
        template_equation
         (template_app (template_hole 8, template_var 1),
          template_app
           (template_app (template_hole 7, template_var 7),
            template_app
             (template_app (template_hole 6, template_var 2),
              template_var 5))),
        template_equation
         (template_var 2, template_app (template_hole 36, template_var 8))],
       template_predicate (template_app (template_hole 5, t_empty)))),
    ("Recursive.compile_cn_correct",
     "[| terminate ?f (map (%g. rec_exec g ?xs) ?gs);
         !!ap arity fp anything.
            rec_ci ?f = (ap, arity, fp) ==>
            {%nl. nl =
                  map (%g. rec_exec g ?xs) ?gs @
                  0 \<up> (fp - arity) @ anything}
            ap {%nl. nl =
                     map (%g. rec_exec g ?xs) ?gs @
                     rec_exec ?f (map (%g. rec_exec g ?xs) ?gs) #
                     0 \<up> (fp - Suc arity) @ anything};
         ALL g:set ?gs.
            terminate g ?xs &
            (ALL x xa xb.
                rec_ci g = (x, xa, xb) -->
                (ALL xc.
                    {%nl. nl = ?xs @ 0 \<up> (xb - xa) @ xc} x
                    {%nl. nl =
                          ?xs @
                          rec_exec g ?xs # 0 \<up> (xb - Suc xa) @ xc}));
         rec_ci (Cn ?n ?f ?gs) = (?ap, ?arity, ?fp); length ?xs = ?n |]
      ==> {%nl. nl = ?xs @ 0 \<up> (?fp - ?arity) @ ?anything} ?ap
          {%nl. nl =
                ?xs @
                rec_exec (Cn ?n ?f ?gs) ?xs #
                0 \<up> (?fp - Suc ?arity) @ ?anything}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 27, template_var 7),
              template_app
               (template_app (template_hole 26, t_empty), template_var 5))
            ),
        template_predicate (template_app (template_hole 24, t_empty)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 9,
                template_app (template_hole 8, template_var 5)),
              t_empty)
            ),
        template_equation
         (template_app
           (template_hole 20,
            template_app
             (template_app
               (template_app (template_hole 2, template_var 4),
                template_var 7),
              template_var 5)),
          template_app
           (template_app (template_hole 19, template_var 3),
            template_app
             (template_app (template_hole 18, template_var 2),
              template_var 1))),
        template_equation
         (template_app (template_hole 0, template_var 6), template_var 4)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 17, t_empty), template_var 3),
             t_empty)
           ))),
    ("Recursive.compile_mn_correct",
     "[| length ?xs = ?n; terminate ?f (?xs @ [?r]);
         !!ap arity fp anything.
            rec_ci ?f = (ap, arity, fp) ==>
            {%nl. nl = ?xs @ ?r # 0 \<up> (fp - arity) @ anything} ap
            {%nl. nl = ?xs @ ?r # 0 # 0 \<up> (fp - Suc arity) @ anything};
         rec_exec ?f (?xs @ [?r]) = 0;
         ALL i<?r.
            terminate ?f (?xs @ [i]) &
            (ALL x xa xb.
                rec_ci ?f = (x, xa, xb) -->
                (ALL xc.
                    {%nl. nl = ?xs @ i # 0 \<up> (xb - xa) @ xc} x
                    {%nl. nl =
                          ?xs @
                          i #
                          rec_exec ?f (?xs @ [i]) #
                          0 \<up> (xb - Suc xa) @ xc})) &
            0 < rec_exec ?f (?xs @ [i]);
         rec_ci (Mn ?n ?f) = (?ap, ?arity, ?fp) |]
      ==> {%nl. nl = ?xs @ 0 \<up> (?fp - ?arity) @ ?anything} ?ap
          {%nl. nl =
                ?xs @
                rec_exec (Mn ?n ?f) ?xs #
                0 \<up> (?fp - Suc ?arity) @ ?anything}",
     template_implication
      ([template_equation
         (template_app (template_hole 25, template_var 7), template_var 6),
        template_predicate
         (
            template_app
             (template_app (template_hole 24, template_var 5),
              template_app
               (template_app (template_hole 23, template_var 7),
                template_app
                 (template_app (template_hole 22, template_var 4),
                  template_hole 21)))
            ),
        template_predicate (template_app (template_hole 20, t_empty)),
        template_equation
         (template_app
           (template_app (template_hole 7, template_var 5),
            template_app
             (template_app (template_hole 23, template_var 7),
              template_app
               (template_app (template_hole 22, template_var 4),
                template_hole 21))),
          template_hole 9),
        template_predicate (template_app (template_hole 6, t_empty)),
        template_equation
         (template_app
           (template_hole 16,
            template_app
             (template_app (template_hole 0, template_var 6),
              template_var 5)),
          template_app
           (template_app (template_hole 15, template_var 3),
            template_app
             (template_app (template_hole 14, template_var 2),
              template_var 1)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 13, t_empty), template_var 3),
             t_empty)
           ))),
    ("Recursive.compile_mn_correct'",
     "[| ?B =
         [Dec (Suc ?arity) (length ?fap + 5),
          Dec (Suc ?arity) (length ?fap + 3), Goto (Suc (length ?fap)),
          Inc ?arity, Goto 0];
         ?ft = max (Suc ?arity) ?fft; length ?xs = ?arity;
         terminate ?f (?xs @ [?r]);
         !!anything.
            {%nl. nl = ?xs @ ?r # 0 \<up> (?fft - ?far) @ anything} ?fap
            {%nl. nl = ?xs @ ?r # 0 # 0 \<up> (?fft - Suc ?far) @ anything};
         ALL i<?r.
            ALL xc.
               {%nl. nl = ?xs @ i # 0 \<up> (?fft - ?far) @ xc} ?fap
               {%nl. nl =
                     ?xs @
                     i #
                     rec_exec ?f (?xs @ [i]) #
                     0 \<up> (?fft - Suc ?far) @ xc};
         ALL i<?r. 0 < rec_exec ?f (?xs @ [i]);
         rec_exec ?f (?xs @ [?r]) = 0; rec_ci ?f = (?fap, ?far, ?fft) |]
      ==> {%nl. nl =
                ?xs @ 0 \<up> (max (Suc ?arity) ?fft - ?arity) @ ?anything}
          ?fap @ ?B
          {%nl. nl =
                ?xs @
                rec_exec (Mn ?arity ?f) ?xs #
                0 \<up> (max (Suc ?arity) ?fft - Suc ?arity) @ ?anything}",
     template_implication
      ([template_equation
         (template_var 9,
          template_app
           (template_app
             (template_hole 35,
              template_app
               (template_app
                 (template_hole 34,
                  template_app (template_hole 33, template_var 8)),
                template_app
                 (template_app
                   (template_hole 32,
                    template_app (template_hole 31, template_var 7)),
                  template_app
                   (template_hole 30,
                    template_app
                     (template_hole 29,
                      template_app
                       (template_hole 28, template_hole 27)))))),
            template_app
             (template_app
               (template_hole 35,
                template_app
                 (template_app
                   (template_hole 34,
                    template_app (template_hole 33, template_var 8)),
                  template_app
                   (template_app
                     (template_hole 32,
                      template_app (template_hole 31, template_var 7)),
                    template_app
                     (template_hole 30,
                      template_app (template_hole 29, template_hole 27))))),
              template_app
               (template_app
                 (template_hole 35,
                  template_app
                   (template_hole 26,
                    template_app
                     (template_hole 33,
                      template_app (template_hole 31, template_var 7)))),
                template_app
                 (template_app
                   (template_hole 35,
                    template_app (template_hole 25, template_var 8)),
                  template_app
                   (template_app
                     (template_hole 35,
                      template_app (template_hole 26, template_hole 24)),
                    template_hole 23)))))),
        template_equation
         (template_var 6,
          template_app
           (template_app
             (template_hole 21,
              template_app (template_hole 33, template_var 8)),
            template_var 5)),
        template_equation
         (template_app (template_hole 20, template_var 4), template_var 8),
        template_predicate
         (
            template_app
             (template_app (template_hole 19, template_var 3),
              template_app
               (template_app (template_hole 18, template_var 4),
                template_app
                 (template_app (template_hole 17, template_var 2),
                  template_hole 16)))
            ),
        template_predicate (template_app (template_hole 15, t_empty)),
        template_predicate (template_app (template_hole 10, t_empty)),
        template_predicate (template_app (template_hole 10, t_empty)),
        template_equation
         (template_app
           (template_app (template_hole 6, template_var 3),
            template_app
             (template_app (template_hole 18, template_var 4),
              template_app
               (template_app (template_hole 17, template_var 2),
                template_hole 16))),
          template_hole 24),
        template_equation
         (template_app (template_hole 4, template_var 3),
          template_app
           (template_app (template_hole 3, template_var 7),
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 5)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 14, t_empty),
               template_app
                (template_app (template_hole 1, template_var 7),
                 template_var 9)),
             t_empty)
           ))),
    ("Recursive.compile_pr_correct",
     "[| ALL y<?x.
            terminate ?g (?xs @ [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]) &
            (ALL x xa xb.
                rec_ci ?g = (x, xa, xb) -->
                (ALL xc.
                    {%nl. nl =
                          ?xs @
                          y #
                          rec_exec (Pr ?n ?f ?g) (?xs @ [y]) #
                          0 \<up> (xb - xa) @ xc}
                    x {%nl. nl =
                            ?xs @
                            y #
                            rec_exec (Pr ?n ?f ?g) (?xs @ [y]) #
                            rec_exec ?g
                             (?xs @
                              [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]) #
                            0 \<up> (xb - Suc xa) @ xc}));
         terminate ?f ?xs;
         !!ap arity fp anything.
            rec_ci ?f = (ap, arity, fp) ==>
            {%nl. nl = ?xs @ 0 \<up> (fp - arity) @ anything} ap
            {%nl. nl =
                  ?xs @
                  rec_exec ?f ?xs # 0 \<up> (fp - Suc arity) @ anything};
         length ?xs = ?n; rec_ci (Pr ?n ?f ?g) = (?ap, ?arity, ?fp) |]
      ==> {%nl. nl = ?xs @ ?x # 0 \<up> (?fp - ?arity) @ ?anything} ?ap
          {%nl. nl =
                ?xs @
                ?x #
                rec_exec (Pr ?n ?f ?g) (?xs @ [?x]) #
                0 \<up> (?fp - Suc ?arity) @ ?anything}",
     template_implication
      ([template_predicate (template_app (template_hole 26, t_empty)),
        template_predicate
         (
            template_app
             (template_app (template_hole 22, template_var 4),
              template_var 6)
            ),
        template_predicate (template_app (template_hole 4, t_empty)),
        template_equation
         (template_app (template_hole 0, template_var 6), template_var 5),
        template_equation
         (template_app
           (template_hole 14,
            template_app
             (template_app
               (template_app (template_hole 18, template_var 5),
                template_var 4),
              template_var 7)),
          template_app
           (template_app (template_hole 13, template_var 3),
            template_app
             (template_app (template_hole 12, template_var 2),
              template_var 1)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 10, t_empty), template_var 3),
             t_empty)
           ))),
    ("Recursive.pr_loop_correct",
     "[| ?y <= ?x; length ?xs = ?n; rec_ci ?g = (?gap, ?gar, ?gft);
         ALL y<?x.
            terminate ?g (?xs @ [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]);
         ALL y<?x.
            ALL anything.
               {%nl. nl =
                     ?xs @
                     y #
                     rec_exec (Pr ?n ?f ?g) (?xs @ [y]) #
                     0 \<up> (?gft - ?gar) @ anything}
               ?gap
               {%nl. nl =
                     ?xs @
                     y #
                     rec_exec (Pr ?n ?f ?g) (?xs @ [y]) #
                     rec_exec ?g
                      (?xs @ [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]) #
                     0 \<up> (?gft - Suc ?gar) @ anything} |]
      ==> {%nl. nl =
                ?xs @
                (?x - ?y) #
                rec_exec (Pr ?n ?f ?g) (?xs @ [?x - ?y]) #
                0 \<up> (max (?n + 3) (max ?fft ?gft) - Suc (Suc ?n)) @
                ?y # ?anything}
          [Dec (max (?n + 3) (max ?fft ?gft)) (length ?gap + 7)] [+]
          (?gap [+] [Inc ?n, Dec (Suc ?n) 3, Goto (Suc 0)]) @
          [Dec (Suc (Suc ?n)) 0, Inc (Suc ?n), Goto (length ?gap + 4)]
          {%nl. nl =
                ?xs @
                ?x #
                rec_exec (Pr ?n ?f ?g) (?xs @ [?x]) #
                0 \<up> (max (?n + 3) (max ?fft ?gft) - Suc ?n) @
                ?anything}",
     template_implication
      ([template_inequation (less_equals, template_var 10, template_var 9),
        template_equation
         (template_app (template_hole 34, template_var 8), template_var 7),
        template_equation
         (template_app (template_hole 32, template_var 6),
          template_app
           (template_app (template_hole 31, template_var 5),
            template_app
             (template_app (template_hole 30, template_var 4),
              template_var 3))),
        template_predicate (template_app (template_hole 29, t_empty)),
        template_predicate (template_app (template_hole 29, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 19, t_empty),
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_hole 6,
                           template_app
                            (template_app
                              (template_hole 5,
                               template_app
                                (template_app
                                  (template_hole 13,
                                   template_app
                                    (template_app
(template_hole 12, template_var 7),
                                     template_app
(template_hole 11, template_app (template_hole 10, template_hole 9)))),
                                 template_app
                                  (template_app
                                    (template_hole 13, template_var 1),
                                   template_var 3))),
                             template_app
                              (template_app
                                (template_hole 12,
                                 template_app
                                  (template_hole 4, template_var 5)),
                               template_app
                                (template_hole 11,
                                 template_app
                                  (template_hole 10,
                                   template_app
                                    (template_hole 10,
                                     template_hole 9)))))),
                         template_hole 3)),
                     template_app
                      (template_app (template_hole 7, template_var 5),
                       template_app
                        (template_app
                          (template_hole 6,
                           template_app (template_hole 2, template_var 7)),
                         template_app
                          (template_app
                            (template_hole 6,
                             template_app
                              (template_app
                                (template_hole 5,
                                 template_app
                                  (template_hole 14, template_var 7)),
                               template_app
                                (template_hole 11,
                                 template_app
                                  (template_hole 10, template_hole 9)))),
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_hole 1,
                                 template_app
                                  (template_hole 14, template_hole 15))),
                             template_hole 3)))))),
                 template_app
                  (template_app
                    (template_hole 6,
                     template_app
                      (template_app
                        (template_hole 5,
                         template_app
                          (template_hole 14,
                           template_app
                            (template_hole 14, template_var 7))),
                       template_hole 15)),
                   template_app
                    (template_app
                      (template_hole 6,
                       template_app
                        (template_hole 2,
                         template_app (template_hole 14, template_var 7))),
                     template_app
                      (template_app
                        (template_hole 6,
                         template_app
                          (template_hole 1,
                           template_app
                            (template_app
                              (template_hole 12,
                               template_app
                                (template_hole 4, template_var 5)),
                             template_app
                              (template_hole 11,
                               template_app
                                (template_hole 0,
                                 template_app
                                  (template_hole 0, template_hole 9)))))),
                       template_hole 3))))),
             t_empty)
           ))),
    ("Recursive.pr_loop",
     "[| ?code =
         [Dec (max (?n + 3) (max ?fft ?gft)) (length ?gap + 7)] [+]
         (?gap [+] [Inc ?n, Dec (Suc ?n) 3, Goto (Suc 0)]) @
         [Dec (Suc (Suc ?n)) 0, Inc (Suc ?n), Goto (length ?gap + 4)];
         length ?xs = ?n;
         ALL y<?x.
            ALL anything.
               {%nl. nl =
                     ?xs @
                     y #
                     rec_exec (Pr ?n ?f ?g) (?xs @ [y]) #
                     0 \<up> (?gft - ?gar) @ anything}
               ?gap
               {%nl. nl =
                     ?xs @
                     y #
                     rec_exec (Pr ?n ?f ?g) (?xs @ [y]) #
                     rec_exec ?g
                      (?xs @ [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]) #
                     0 \<up> (?gft - Suc ?gar) @ anything};
         rec_ci ?g = (?gap, ?gar, ?gft);
         ALL y<?x.
            terminate ?g (?xs @ [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]);
         ?ft = max (?n + 3) (max ?fft ?gft); Suc ?y <= ?x |]
      ==> EX stp.
             abc_steps_l
              (0, ?xs @
                  (?x - Suc ?y) #
                  rec_exec (Pr ?n ?f ?g) (?xs @ [?x - Suc ?y]) #
                  0 \<up> (?ft - Suc (Suc ?n)) @ Suc ?y # ?anything)
              ?code stp =
             (0, ?xs @
                 (?x - ?y) #
                 rec_exec (Pr ?n ?f ?g) (?xs @ [?x - ?y]) #
                 0 \<up> (?ft - Suc (Suc ?n)) @ ?y # ?anything)",
     template_implication
      ([template_equation
         (template_var 12,
          template_app
           (template_app
             (template_hole 40,
              template_app
               (template_app
                 (template_hole 39,
                  template_app
                   (template_app
                     (template_hole 38,
                      template_app
                       (template_app
                         (template_hole 37,
                          template_app
                           (template_app
                             (template_hole 36,
                              template_app
                               (template_app
                                 (template_hole 35, template_var 11),
                                template_app
                                 (template_hole 34,
                                  template_app
                                   (template_hole 33, template_hole 32)))),
                            template_app
                             (template_app
                               (template_hole 36, template_var 10),
                              template_var 9))),
                        template_app
                         (template_app
                           (template_hole 35,
                            template_app
                             (template_hole 31, template_var 8)),
                          template_app
                           (template_hole 34,
                            template_app
                             (template_hole 33,
                              template_app
                               (template_hole 33, template_hole 32)))))),
                    template_hole 30)),
                template_app
                 (template_app (template_hole 39, template_var 8),
                  template_app
                   (template_app
                     (template_hole 38,
                      template_app (template_hole 29, template_var 11)),
                    template_app
                     (template_app
                       (template_hole 38,
                        template_app
                         (template_app
                           (template_hole 37,
                            template_app
                             (template_hole 28, template_var 11)),
                          template_app
                           (template_hole 34,
                            template_app
                             (template_hole 33, template_hole 32)))),
                      template_app
                       (template_app
                         (template_hole 38,
                          template_app
                           (template_hole 27,
                            template_app
                             (template_hole 28, template_hole 26))),
                        template_hole 30)))))),
            template_app
             (template_app
               (template_hole 38,
                template_app
                 (template_app
                   (template_hole 37,
                    template_app
                     (template_hole 28,
                      template_app (template_hole 28, template_var 11))),
                  template_hole 26)),
              template_app
               (template_app
                 (template_hole 38,
                  template_app
                   (template_hole 29,
                    template_app (template_hole 28, template_var 11))),
                template_app
                 (template_app
                   (template_hole 38,
                    template_app
                     (template_hole 27,
                      template_app
                       (template_app
                         (template_hole 35,
                          template_app (template_hole 31, template_var 8)),
                        template_app
                         (template_hole 34,
                          template_app
                           (template_hole 25,
                            template_app
                             (template_hole 25, template_hole 32)))))),
                  template_hole 30))))),
        template_equation
         (template_app (template_hole 23, template_var 7), template_var 11),
        template_predicate (template_app (template_hole 22, t_empty)),
        template_equation
         (template_app (template_hole 8, template_var 4),
          template_app
           (template_app (template_hole 7, template_var 8),
            template_app
             (template_app (template_hole 6, template_var 3),
              template_var 9))),
        template_predicate (template_app (template_hole 22, t_empty)),
        template_equation
         (template_var 2,
          template_app
           (template_app
             (template_hole 36,
              template_app
               (template_app (template_hole 35, template_var 11),
                template_app
                 (template_hole 34,
                  template_app (template_hole 33, template_hole 32)))),
            template_app
             (template_app (template_hole 36, template_var 10),
              template_var 9))),
        template_inequation
         (less_equals, template_app (template_hole 28, template_var 1),
          template_var 6)],
       template_predicate (template_app (template_hole 3, t_empty)))),
    ("Recursive.compile_pr_correct'",
     "[| ALL y<?x.
            terminate ?g (?xs @ [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]);
         ALL y<?x.
            ALL anything.
               {%nl. nl =
                     ?xs @
                     y #
                     rec_exec (Pr ?n ?f ?g) (?xs @ [y]) #
                     0 \<up> (?gft - ?gar) @ anything}
               ?gap
               {%nl. nl =
                     ?xs @
                     y #
                     rec_exec (Pr ?n ?f ?g) (?xs @ [y]) #
                     rec_exec ?g
                      (?xs @ [y, rec_exec (Pr ?n ?f ?g) (?xs @ [y])]) #
                     0 \<up> (?gft - Suc ?gar) @ anything};
         terminate ?f ?xs;
         !!anything.
            {%nl. nl = ?xs @ 0 \<up> (?fft - ?far) @ anything} ?fap
            {%nl. nl =
                  ?xs @
                  rec_exec ?f ?xs # 0 \<up> (?fft - Suc ?far) @ anything};
         length ?xs = ?n; rec_ci ?f = (?fap, ?far, ?fft);
         rec_ci ?g = (?gap, ?gar, ?gft) |]
      ==> {%nl. nl =
                ?xs @
                ?x #
                0 \<up> (max (?n + 3) (max ?fft ?gft) - ?n) @ ?anything}
          mv_box ?n (max (?n + 3) (max ?fft ?gft)) [+]
          (?fap [+]
           (mv_box ?n (Suc ?n) [+]
            ([Dec (max (?n + 3) (max ?fft ?gft)) (length ?gap + 7)] [+]
             (?gap [+] [Inc ?n, Dec (Suc ?n) 3, Goto (Suc 0)]) @
             [Dec (Suc (Suc ?n)) 0, Inc (Suc ?n), Goto (length ?gap + 4)])))
          {%nl. nl =
                ?xs @
                ?x #
                rec_exec (Pr ?n ?f ?g) (?xs @ [?x]) #
                0 \<up> (max (?n + 3) (max ?fft ?gft) - Suc ?n) @
                ?anything}",
     template_implication
      ([template_predicate (template_app (template_hole 37, t_empty)),
        template_predicate (template_app (template_hole 37, t_empty)),
        template_predicate
         (
            template_app
             (template_app (template_hole 34, template_var 7),
              template_var 9)
            ),
        template_predicate (template_app (template_hole 21, t_empty)),
        template_equation
         (template_app (template_hole 19, template_var 9), template_var 8),
        template_equation
         (template_app (template_hole 17, template_var 7),
          template_app
           (template_app (template_hole 16, template_var 1),
            template_app
             (template_app (template_hole 15, template_var 2),
              template_var 3))),
        template_equation
         (template_app (template_hole 17, template_var 10),
          template_app
           (template_app (template_hole 16, template_var 4),
            template_app
             (template_app (template_hole 15, template_var 5),
              template_var 6)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 27, t_empty),
               template_app
                (template_app
                  (template_hole 9,
                   template_app
                    (template_app (template_hole 8, template_var 8),
                     template_app
                      (template_app
                        (template_hole 14,
                         template_app
                          (template_app (template_hole 13, template_var 8),
                           template_app
                            (template_hole 12,
                             template_app
                              (template_hole 11, template_hole 10)))),
                       template_app
                        (template_app (template_hole 14, template_var 3),
                         template_var 6)))),
                 template_app
                  (template_app (template_hole 9, template_var 1),
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app
                        (template_app (template_hole 8, template_var 8),
                         template_app (template_hole 22, template_var 8))),
                     template_app
                      (template_app
                        (template_hole 7,
                         template_app
                          (template_app
                            (template_hole 9,
                             template_app
                              (template_app
                                (template_hole 6,
                                 template_app
                                  (template_app
                                    (template_hole 5,
                                     template_app
(template_app
  (template_hole 14,
   template_app
    (template_app (template_hole 13, template_var 8),
     template_app
      (template_hole 12,
       template_app (template_hole 11, template_hole 10)))),
 template_app
  (template_app (template_hole 14, template_var 3), template_var 6))),
                                   template_app
                                    (template_app
(template_hole 13, template_app (template_hole 4, template_var 4)),
                                     template_app
(template_hole 12,
 template_app
  (template_hole 11, template_app (template_hole 11, template_hole 10)))))),
                               template_hole 3)),
                           template_app
                            (template_app (template_hole 9, template_var 4),
                             template_app
                              (template_app
                                (template_hole 6,
                                 template_app
                                  (template_hole 2, template_var 8)),
                               template_app
                                (template_app
                                  (template_hole 6,
                                   template_app
                                    (template_app
(template_hole 5, template_app (template_hole 22, template_var 8)),
                                     template_app
(template_hole 12, template_app (template_hole 11, template_hole 10)))),
                                 template_app
                                  (template_app
                                    (template_hole 6,
                                     template_app
(template_hole 1, template_app (template_hole 22, template_hole 23))),
                                   template_hole 3)))))),
                       template_app
                        (template_app
                          (template_hole 6,
                           template_app
                            (template_app
                              (template_hole 5,
                               template_app
                                (template_hole 22,
                                 template_app
                                  (template_hole 22, template_var 8))),
                             template_hole 23)),
                         template_app
                          (template_app
                            (template_hole 6,
                             template_app
                              (template_hole 2,
                               template_app
                                (template_hole 22, template_var 8))),
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_hole 1,
                                 template_app
                                  (template_app
                                    (template_hole 13,
                                     template_app
(template_hole 4, template_var 4)),
                                   template_app
                                    (template_hole 12,
                                     template_app
(template_hole 0, template_app (template_hole 0, template_hole 10)))))),
                             template_hole 3)))))))),
             t_empty)
           ))),
    ("Recursive.compile_cn_correct'",
     "[| !!anything r.
            rec_exec ?f (map (%g. rec_exec g ?xs) ?gs) =
            rec_exec (Cn (length ?xs) ?f ?gs) ?xs ==>
            {%nl. nl =
                  map (%g. rec_exec g ?xs) ?gs @
                  0 \<up> (?ffp - ?far) @ anything}
            ?fap
            {%nl. nl =
                  map (%g. rec_exec g ?xs) ?gs @
                  rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
                  0 \<up> (?ffp - Suc ?far) @ anything};
         rec_ci ?f = (?fap, ?far, ?ffp);
         terminate ?f (map (%g. rec_exec g ?xs) ?gs);
         ALL g:set ?gs.
            terminate g ?xs &
            (ALL x xa xb.
                rec_ci g = (x, xa, xb) -->
                (ALL xc.
                    {%nl. nl = ?xs @ 0 \<up> (xb - xa) @ xc} x
                    {%nl. nl =
                          ?xs @
                          rec_exec g ?xs # 0 \<up> (xb - Suc xa) @ xc})) |]
      ==> {%nl. nl =
                ?xs @
                0 #
                0 \<up> (max (Suc (length ?xs))
                          (Max (insert ?ffp
                                 ((%(aprog, p, n). n) `
                                  rec_ci ` set ?gs))) +
                         length ?gs) @
                ?anything}
          cn_merge_gs (map rec_ci ?gs)
           (max (Suc (length ?xs))
             (Max (insert ?ffp
                    ((%(aprog, p, n). n) ` rec_ci ` set ?gs)))) [+]
          (mv_boxes 0
            (Suc (max (Suc (length ?xs))
                   (Max (insert ?ffp
                          ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) +
                  length ?gs))
            (length ?xs) [+]
           (mv_boxes
             (max (Suc (length ?xs))
               (Max (insert ?ffp ((%(aprog, p, n). n) ` rec_ci ` set ?gs))))
             0 (length ?gs) [+]
            (?fap [+]
             (mv_box ?far
               (max (Suc (length ?xs))
                 (Max (insert ?ffp
                        ((%(aprog, p, n). n) ` rec_ci ` set ?gs)))) [+]
              (empty_boxes (length ?gs) [+]
               (mv_box
                 (max (Suc (length ?xs))
                   (Max (insert ?ffp
                          ((%(aprog, p, n). n) ` rec_ci ` set ?gs))))
                 (length ?xs) [+]
                mv_boxes
                 (Suc (max (Suc (length ?xs))
                        (Max (insert ?ffp
                               ((%(aprog, p, n). n) ` rec_ci ` set ?gs))) +
                       length ?gs))
                 0 (length ?xs)))))))
          {%nl. nl =
                ?xs @
                rec_exec (Cn (length ?xs) ?f ?gs) ?xs #
                0 \<up> (max (Suc (length ?xs))
                          (Max (insert ?ffp
                                 ((%(aprog, p, n). n) `
                                  rec_ci ` set ?gs))) +
                         length ?gs) @
                ?anything}",
     template_implication
      ([template_predicate (template_app (template_hole 42, t_empty)),
        template_equation
         (template_app (template_hole 25, template_var 6),
          template_app
           (template_app (template_hole 24, template_var 1),
            template_app
             (template_app (template_hole 23, template_var 2),
              template_var 3))),
        template_predicate
         (
            template_app
             (template_app (template_hole 22, template_var 6),
              template_app
               (template_app (template_hole 37, t_empty), template_var 4))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 21,
                template_app (template_hole 20, template_var 4)),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 34, t_empty),
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, template_hole 25),
                         template_var 4)),
                     template_app
                      (template_app
                        (template_hole 13,
                         template_app
                          (template_hole 27,
                           template_app
                            (template_hole 35, template_var 5))),
                       template_app
                        (template_hole 12,
                         template_app
                          (template_app (template_hole 11, template_var 3),
                           template_app
                            (template_app
                              (template_hole 10,
                               template_app (template_hole 9, t_empty)),
                             template_app
                              (template_app
                                (template_hole 7, template_hole 25),
                               template_app
                                (template_hole 20, template_var 4)))))))),
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app
                      (template_app
                        (template_app (template_hole 2, template_hole 29),
                         template_app
                          (template_hole 27,
                           template_app
                            (template_app
                              (template_hole 14,
                               template_app
                                (template_app
                                  (template_hole 13,
                                   template_app
                                    (template_hole 27,
                                     template_app
(template_hole 35, template_var 5))),
                                 template_app
                                  (template_hole 12,
                                   template_app
                                    (template_app
(template_hole 11, template_var 3),
                                     template_app
(template_app (template_hole 10, template_app (template_hole 9, t_empty)),
 template_app
  (template_app (template_hole 7, template_hole 25),
   template_app (template_hole 20, template_var 4))))))),
                             template_app
                              (template_hole 6, template_var 4)))),
                       template_app (template_hole 35, template_var 5))),
                   template_app
                    (template_app
                      (template_hole 5,
                       template_app
                        (template_app
                          (template_app
                            (template_hole 2,
                             template_app
                              (template_app
                                (template_hole 13,
                                 template_app
                                  (template_hole 27,
                                   template_app
                                    (template_hole 35, template_var 5))),
                               template_app
                                (template_hole 12,
                                 template_app
                                  (template_app
                                    (template_hole 11, template_var 3),
                                   template_app
                                    (template_app
(template_hole 10, template_app (template_hole 9, t_empty)),
                                     template_app
(template_app (template_hole 7, template_hole 25),
 template_app (template_hole 20, template_var 4))))))),
                           template_hole 29),
                         template_app (template_hole 6, template_var 4))),
                     template_app
                      (template_app (template_hole 5, template_var 1),
                       template_app
                        (template_app
                          (template_hole 5,
                           template_app
                            (template_app (template_hole 1, template_var 2),
                             template_app
                              (template_app
                                (template_hole 13,
                                 template_app
                                  (template_hole 27,
                                   template_app
                                    (template_hole 35, template_var 5))),
                               template_app
                                (template_hole 12,
                                 template_app
                                  (template_app
                                    (template_hole 11, template_var 3),
                                   template_app
                                    (template_app
(template_hole 10, template_app (template_hole 9, t_empty)),
                                     template_app
(template_app (template_hole 7, template_hole 25),
 template_app (template_hole 20, template_var 4)))))))),
                         template_app
                          (template_app
                            (template_hole 5,
                             template_app
                              (template_hole 0,
                               template_app
                                (template_hole 6, template_var 4))),
                           template_app
                            (template_app
                              (template_hole 5,
                               template_app
                                (template_app
                                  (template_hole 1,
                                   template_app
                                    (template_app
(template_hole 13,
 template_app
  (template_hole 27, template_app (template_hole 35, template_var 5))),
                                     template_app
(template_hole 12,
 template_app
  (template_app (template_hole 11, template_var 3),
   template_app
    (template_app
      (template_hole 10, template_app (template_hole 9, t_empty)),
     template_app
      (template_app (template_hole 7, template_hole 25),
       template_app (template_hole 20, template_var 4))))))),
                                 template_app
                                  (template_hole 35, template_var 5))),
                             template_app
                              (template_app
                                (template_app
                                  (template_hole 2,
                                   template_app
                                    (template_hole 27,
                                     template_app
(template_app
  (template_hole 14,
   template_app
    (template_app
      (template_hole 13,
       template_app
        (template_hole 27,
         template_app (template_hole 35, template_var 5))),
     template_app
      (template_hole 12,
       template_app
        (template_app (template_hole 11, template_var 3),
         template_app
          (template_app
            (template_hole 10, template_app (template_hole 9, t_empty)),
           template_app
            (template_app (template_hole 7, template_hole 25),
             template_app (template_hole 20, template_var 4))))))),
 template_app (template_hole 6, template_var 4)))),
                                 template_hole 29),
                               template_app
                                (template_hole 35, template_var 5)))))))))),
             t_empty)
           )))]:
   (string * thm * template) list
### theory "Draft.RecursiveMoreTemplates"
### 0.564s elapsed time, 0.687s cpu time, 0.000s GC time
val it = (): unit
