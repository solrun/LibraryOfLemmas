Loading theory "Draft.Rec_Def" (required by "Draft.UTMMoreTemplates" via "Draft.UTM" via "Draft.Recursive")
Loading theory "Draft.Turing" (required by "Draft.UTMMoreTemplates" via "Draft.UTM" via "Draft.Recursive" via "Draft.Abacus" via "Draft.Turing_Hoare")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.UTMMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.UTMMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.124s elapsed time, 0.509s cpu time, 0.043s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.UTMMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Nat_Bijection"
### 0.317s elapsed time, 1.266s cpu time, 0.120s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.UTMMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.Set_Algebras"
### 0.202s elapsed time, 0.800s cpu time, 0.077s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.UTMMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
Proofs for inductive predicate(s) "terminate"
  Proving monotonicity ...
### theory "Draft.Rec_Def"
### 0.667s elapsed time, 2.643s cpu time, 0.267s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.UTMMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "{}"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  left :: "'a tree => 'a tree"
Found termination order: "{}"
consts
  right :: "'a tree => 'a tree"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
Found termination order: "{}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "{}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Stream"
### 1.067s elapsed time, 4.057s cpu time, 0.834s GC time
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
class tape = type +
  fixes tape_of :: "'a => cell list"
instantiation
  nat :: tape
  tape_of_nat == tape_of :: nat => cell list
instantiation
  list :: (tape) tape
  tape_of_list == tape_of :: 'a list => cell list
Found termination order: "size <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
instantiation
  prod :: (tape, tape) tape
  tape_of_prod == tape_of :: 'a * 'b => cell list
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.994s elapsed time, 3.552s cpu time, 0.772s GC time
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### theory "Draft.Turing"
### 1.789s elapsed time, 6.456s cpu time, 1.039s GC time
Loading theory "Draft.Turing_Hoare" (required by "Draft.UTMMoreTemplates" via "Draft.UTM" via "Draft.Recursive" via "Draft.Abacus")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### Ambiguous input (line 41 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" p) ("_Finset" ("_position" Q))))
###   ("\<^const>HOL.All_binder" ("_position" tp)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" tp))
###       ("\<^const>HOL.Ex_binder" ("_position" n)
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" is_final)
###             ("_applC" ("_position" steps0)
###               ("_cargs"
###                 ("_tuple" ("\<^const>Groups.one_class.one")
###                   ("_tuple_arg" ("_position" tp)))
###                 ("_cargs" ("_position" p) ("_position" n)))))
###           ("\<^const>Turing_Hoare.holds_for" ("_position" Q)
###             ("_applC" ("_position" steps0)
###               ("_cargs"
###                 ("_tuple" ("\<^const>Groups.one_class.one")
###                   ("_tuple_arg" ("_position" tp)))
###                 ("_cargs" ("_position" p) ("_position" n))))))))))
### ("\<^const>Pure.eq"
###   ("\<^fixed>Hoare_halt" ("_position" P) ("_position" p) ("_position" Q))
###   ("\<^const>HOL.All_binder" ("_position" tp)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" tp))
###       ("\<^const>HOL.Ex_binder" ("_position" n)
###         ("\<^const>HOL.conj"
###           ("_applC" ("_position" is_final)
###             ("_applC" ("_position" steps0)
###               ("_cargs"
###                 ("_tuple" ("\<^const>Groups.one_class.one")
###                   ("_tuple_arg" ("_position" tp)))
###                 ("_cargs" ("_position" p) ("_position" n)))))
###           ("\<^const>Turing_Hoare.holds_for" ("_position" Q)
###             ("_applC" ("_position" steps0)
###               ("_cargs"
###                 ("_tuple" ("\<^const>Groups.one_class.one")
###                   ("_tuple_arg" ("_position" tp)))
###                 ("_cargs" ("_position" p) ("_position" n))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 52 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" p) ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P) ("_position" p)
###     ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 73 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" A) ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P) ("_position" A)
###     ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 74 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" Q))
###     ("_cargs" ("_position" B) ("_Finset" ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" Q) ("_position" B)
###     ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 76 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing.tm_comp"
###     ("_applC" ("_Finset" ("_position" P)) ("_position" A))
###     ("_applC" ("_position" B) ("_Finset" ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("\<^const>Turing.tm_comp" ("_position" A) ("_position" B))
###     ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 111 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" A) ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P) ("_position" A)
###     ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 154 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_position" p) ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P) ("_position" p)
###     ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 155 of "$AFP/Universal_Turing_Machine/Turing_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P'))
###     ("_cargs" ("_position" p) ("_Finset" ("_position" Q')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P') ("_position" p)
###     ("_position" Q')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Turing_Hoare"
### 0.143s elapsed time, 0.330s cpu time, 0.079s GC time
Loading theory "Draft.Uncomputable" (required by "Draft.UTMMoreTemplates" via "Draft.UTM" via "Draft.Recursive" via "Draft.Abacus" via "Draft.Abacus_Mopup")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 117 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("\<^const>Groups.zero_class.zero")
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_applC" ("_position" inv_begin1) ("_position" n))
###       ("_position" tcopy_begin)
###       ("_applC" ("_position" inv_begin0) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("\<^const>Groups.zero_class.zero")
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset" ("_applC" ("_position" inv_begin1) ("_position" n)))
###       ("_cargs" ("_position" tcopy_begin)
###         ("_Finset" ("_applC" ("_position" inv_begin0) ("_position" n)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "HOL-Library.Tree"
### 2.000s elapsed time, 6.320s cpu time, 1.095s GC time
Loading theory "Draft.Templates" (required by "Draft.UTMMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.053s elapsed time, 0.105s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.UTMMoreTemplates")
Found termination order: "{}"
### Ambiguous input (line 181 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("\<^const>Groups.zero_class.zero")
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_applC" ("_position" inv_begin1) ("_position" n))
###       ("_position" tcopy_begin)
###       ("_applC" ("_position" inv_begin0) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less" ("\<^const>Groups.zero_class.zero")
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset" ("_applC" ("_position" inv_begin1) ("_position" n)))
###       ("_cargs" ("_position" tcopy_begin)
###         ("_Finset" ("_applC" ("_position" inv_begin0) ("_position" n)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.541s elapsed time, 1.183s cpu time, 0.131s GC time
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 548 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" inv_loop1) ("_position" n))
###     ("_position" tcopy_loop)
###     ("_applC" ("_position" inv_loop0) ("_position" n))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_applC" ("_position" inv_loop1) ("_position" n)))
###     ("_cargs" ("_position" tcopy_loop)
###       ("_Finset" ("_applC" ("_position" inv_loop0) ("_position" n))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 784 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater" ("_position" n)
###       ("\<^const>Groups.zero_class.zero")))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_applC" ("_position" inv_end1) ("_position" n))
###       ("_position" tcopy_end)
###       ("_applC" ("_position" inv_end0) ("_position" n)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater" ("_position" n)
###       ("\<^const>Groups.zero_class.zero")))
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_Finset" ("_applC" ("_position" inv_end1) ("_position" n)))
###       ("_cargs" ("_position" tcopy_end)
###         ("_Finset" ("_applC" ("_position" inv_end0) ("_position" n)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 815 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" inv_begin1) ("_position" x)) ("_position" tcopy)
###     ("_applC" ("_position" inv_end0) ("_position" x))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_applC" ("_position" inv_begin1) ("_position" x)))
###     ("_cargs" ("_position" tcopy)
###       ("_Finset" ("_applC" ("_position" inv_end0) ("_position" x))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 852 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" pre_tcopy) ("_position" n)) ("_position" tcopy)
###     ("_applC" ("_position" post_tcopy) ("_position" n))))
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_applC" ("_position" pre_tcopy) ("_position" n)))
###     ("_cargs" ("_position" tcopy)
###       ("_Finset" ("_applC" ("_position" post_tcopy) ("_position" n))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 907 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" dither_halt_inv))
###     ("_cargs" ("_position" dither)
###       ("_Finset" ("_position" dither_halt_inv)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" dither_halt_inv)
###     ("_position" dither) ("_position" dither_halt_inv)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 923 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" halts) ("_cargs" ("_position" p) ("_position" ns)))
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" tp)
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple" ("\<^const>List.list.Nil")
###             ("_tuple_arg"
###               ("\<^const>Turing.tape_class.tape_of" ("_position" ns)))))))
###     ("_cargs" ("_position" p)
###       ("_Finset"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" k)
###               ("_idts" ("_position" n) ("_position" l)))
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))
###                 ("_tuple_arg"
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.tape_class.tape_of"
###                       ("_constrain" ("_position" n) ("_type_name" nat)))
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" l))))))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" halts) ("_cargs" ("_position" p) ("_position" ns)))
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" ns))))))
###     ("_position" p)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" k) ("_idts" ("_position" n) ("_position" l)))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" k))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_constrain" ("_position" n) ("_type_name" nat)))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" l))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 951 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" M) ("_position" ns))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" halts)
###         ("_cargs" ("_position" M) ("_position" ns))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" tp)
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple" ("_list" ("_position" Bk))
###                 ("_tuple_arg"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_tuple" ("_applC" ("_position" code) ("_position" M))
###                       ("_tuple_arg" ("_position" ns)))))))))
###         ("_cargs" ("_position" H)
###           ("_Finset"
###             ("_lambda" ("_position" tp)
###               ("\<^const>HOL.Ex_binder" ("_position" k)
###                 ("\<^const>HOL.eq" ("_position" tp)
###                   ("_tuple"
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" k))
###                     ("_tuple_arg"
###                       ("\<^const>Turing.tape_class.tape_of"
###                         ("_constrain" ("\<^const>Groups.zero_class.zero")
###                           ("_type_name" nat))))))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" M) ("_position" ns))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" halts)
###         ("_cargs" ("_position" M) ("_position" ns))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.eq" ("_position" tp)
###             ("_tuple" ("_list" ("_position" Bk))
###               ("_tuple_arg"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_tuple" ("_applC" ("_position" code) ("_position" M))
###                     ("_tuple_arg" ("_position" ns))))))))
###         ("_position" H)
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder" ("_position" k)
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))
###                 ("_tuple_arg"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_constrain" ("\<^const>Groups.zero_class.zero")
###                       ("_type_name" nat))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 953 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" M) ("_position" ns))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Not"
###         ("_applC" ("_position" halts)
###           ("_cargs" ("_position" M) ("_position" ns)))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" tp)
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple" ("_list" ("_position" Bk))
###                 ("_tuple_arg"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_tuple" ("_applC" ("_position" code) ("_position" M))
###                       ("_tuple_arg" ("_position" ns)))))))))
###         ("_cargs" ("_position" H)
###           ("_Finset"
###             ("_lambda" ("_position" tp)
###               ("\<^const>HOL.Ex_binder" ("_position" k)
###                 ("\<^const>HOL.eq" ("_position" tp)
###                   ("_tuple"
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" k))
###                     ("_tuple_arg"
###                       ("\<^const>Turing.tape_class.tape_of"
###                         ("_constrain" ("\<^const>Groups.one_class.one")
###                           ("_type_name" nat))))))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" M) ("_position" ns))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.Not"
###         ("_applC" ("_position" halts)
###           ("_cargs" ("_position" M) ("_position" ns)))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.eq" ("_position" tp)
###             ("_tuple" ("_list" ("_position" Bk))
###               ("_tuple_arg"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_tuple" ("_applC" ("_position" code) ("_position" M))
###                     ("_tuple_arg" ("_position" ns))))))))
###         ("_position" H)
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder" ("_position" k)
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))
###                 ("_tuple_arg"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_constrain" ("\<^const>Groups.one_class.one")
###                       ("_type_name" nat))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale uncomputable
  fixes code :: "(action * nat) list => nat"
    and H :: "(action * nat) list"
  assumes "uncomputable code H"
### Ambiguous input (line 969 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_applC" ("_position" pre_H_inv)
###         ("_cargs" ("_position" M) ("_position" ns))))
###     ("_cargs" ("_position" H) ("_Finset" ("_position" post_H_halt_inv)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" pre_H_inv)
###       ("_cargs" ("_position" M) ("_position" ns)))
###     ("_position" H) ("_position" post_H_halt_inv)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 974 of "$AFP/Universal_Turing_Machine/Uncomputable.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_applC" ("_position" pre_H_inv)
###         ("_cargs" ("_position" M) ("_position" ns))))
###     ("_cargs" ("_position" H) ("_Finset" ("_position" post_H_unhalt_inv)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_applC" ("_position" pre_H_inv)
###       ("_cargs" ("_position" M) ("_position" ns)))
###     ("_position" H) ("_position" post_H_unhalt_inv)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Uncomputable"
### 2.653s elapsed time, 4.772s cpu time, 1.419s GC time
Loading theory "Draft.Abacus_Mopup" (required by "Draft.UTMMoreTemplates" via "Draft.UTM" via "Draft.Recursive" via "Draft.Abacus")
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### mopup_inv (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1 ==
### if ?s1 = 0 then mopup_stop (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
### else if ?s1 <= 2 * ?n1
###      then if ?s1 mod 2 = 1
###           then mopup_bef_erase_a (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###           else mopup_bef_erase_b (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###      else if ?s1 = 2 * ?n1 + 1
###           then mopup_jump_over1 (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###           else if ?s1 = 2 * ?n1 + 2
###                then mopup_aft_erase_a (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###                else if ?s1 = 2 * ?n1 + 3
###                     then mopup_aft_erase_b (?s1, ?l1, ?r1) ?lm1 ?n1 ?ires1
###                     else if ?s1 = 2 * ?n1 + 4
###                          then mopup_aft_erase_c (?s1, ?l1, ?r1) ?lm1 ?n1
###                                ?ires1
###                          else if ?s1 = 2 * ?n1 + 5
###                               then mopup_left_moving (?s1, ?l1, ?r1) ?lm1
###                                     ?n1 ?ires1
###                               else if ?s1 = 2 * ?n1 + 6
###                                    then mopup_jump_over2 (?s1, ?l1, ?r1)
###    ?lm1 ?n1 ?ires1
###                                    else False
### theory "Draft.Abacus_Mopup"
### 1.115s elapsed time, 1.230s cpu time, 0.157s GC time
Loading theory "Draft.Abacus" (required by "Draft.UTMMoreTemplates" via "Draft.UTM" via "Draft.Recursive")
### Ignoring duplicate rewrite rule:
### ?x1 \<up> Suc ?n1 == ?x1 # ?x1 \<up> ?n1
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### layout_of ?ap1 == map length_of ?ap1
### Rewrite rule not in simpset:
### step (?s1, ?l1, ?r1) (?p1, ?off1) ==
### let (a, s') = fetch ?p1 (?s1 - ?off1) (read ?r1)
### in (s', update a (?l1, ?r1))
### Rewrite rule not in simpset:
### steps ?y ?p1 0 == ?y
### Rewrite rule not in simpset:
### steps ?c1 ?p1 (Suc ?n1) == steps (step ?c1 ?p1) ?p1 ?n1
### Rewrite rule not in simpset:
### shift ?p1 ?n1 == map (%(a, s). (a, if s = 0 then 0 else s + ?n1)) ?p1
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### ci ?ly1 ?ss1 (Inc ?n1) == tinc ?ss1 ?n1
### Rewrite rule not in simpset:
### ci ?ly1 ?ss1 (Dec ?n1 ?e1) == tdec ?ss1 ?n1 (start_of ?ly1 ?e1)
### Rewrite rule not in simpset:
### ci ?ly1 ?ss1 (Goto ?n1) == tgoto (start_of ?ly1 ?n1)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### dec_inv_1 ?ly1 ?n1 ?e1 (?as1, ?am1) (?s1, ?l1, ?r1) ?ires1 ==
### let ss = start_of ?ly1 ?as1;
###     am' = abc_lm_s ?am1 ?n1 (abc_lm_v ?am1 ?n1 - Suc 0);
###     am'' = abc_lm_s ?am1 ?n1 (abc_lm_v ?am1 ?n1)
### in if ?s1 = start_of ?ly1 ?e1
###    then inv_stop (?as1, am'') (?s1, ?l1, ?r1) ?ires1
###    else if ?s1 = ss then False
###         else if ?s1 = ss + 2 * ?n1 + 1
###              then inv_locate_b (?as1, ?am1) (?n1, ?l1, ?r1) ?ires1
###              else if ?s1 = ss + 2 * ?n1 + 13
###                   then inv_on_left_moving (?as1, am'') (?s1, ?l1, ?r1)
###                         ?ires1
###                   else if ?s1 = ss + 2 * ?n1 + 14
###                        then inv_check_left_moving (?as1, am'')
###                              (?s1, ?l1, ?r1) ?ires1
###                        else if ?s1 = ss + 2 * ?n1 + 15
###                             then inv_after_left_moving (?as1, am'')
###                                   (?s1, ?l1, ?r1) ?ires1
###                             else False
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Draft.Abacus"
### 5.806s elapsed time, 6.879s cpu time, 1.485s GC time
Loading theory "Draft.Abacus_Hoare" (required by "Draft.UTMMoreTemplates" via "Draft.UTM" via "Draft.Recursive")
Loading theory "Draft.UF" (required by "Draft.UTMMoreTemplates" via "Draft.UTM")
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 40 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_constrain" ("_position" p) ("_type_name" abc_prog))
###       ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" p) ("_type_name" abc_prog)) ("_position" Q)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" p) ("_type_name" abc_prog)) ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 57 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###     ("_constrain" ("_position" p) ("_type_name" abc_prog))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###     ("_constrain" ("_position" p) ("_type_name" abc_prog))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### Ambiguous input (line 287 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_constrain" ("_position" A) ("_type_name" abc_prog))
###       ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog)) ("_position" Q)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog)) ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 288 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" Q))
###     ("_cargs" ("_constrain" ("_position" B) ("_type_name" abc_prog))
###       ("_Finset" ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" Q)
###     ("_constrain" ("_position" B) ("_type_name" abc_prog)) ("_position" S)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" Q)
###     ("_constrain" ("_position" B) ("_type_name" abc_prog)) ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 289 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs"
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B))
###       ("_Finset" ("_position" S)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B))
###     ("_position" S)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###     ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B))
###     ("_position" S)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 322 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 345 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("_constrain" ("_position" A) ("_type_name" abc_prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("_constrain" ("_position" A) ("_type_name" abc_prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("_constrain" ("_position" A) ("_type_name" abc_prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("_constrain" ("_position" A) ("_type_name" abc_prog))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 360 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###     ("_constrain" ("_position" B) ("_type_name" abc_prog))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###     ("_constrain" ("_position" B) ("_type_name" abc_prog))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 361 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC" ("_Finset" ("_position" P))
###     ("_cargs" ("_constrain" ("_position" A) ("_type_name" abc_prog))
###       ("_Finset" ("_position" Q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog)) ("_position" Q)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###     ("_constrain" ("_position" A) ("_type_name" abc_prog)) ("_position" Q)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 436 of "$AFP/Universal_Turing_Machine/Abacus_Hoare.thy") produces 12 parse trees (10 displayed):
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_Finset" ("_position" P))
###           ("_cargs" ("_constrain" ("_position" A) ("_type_name" abc_prog))
###             ("_Finset" ("_position" Q)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_Finset" ("_position" P))
###           ("_cargs" ("_constrain" ("_position" A) ("_type_name" abc_prog))
###             ("_Finset" ("_position" Q)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Abacus_Hoare.abc_Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_unhalt" ("_position" Q)
###         ("_constrain" ("_position" B) ("_type_name" abc_prog))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Turing_Hoare.Hoare_halt" ("_position" P)
###           ("_constrain" ("_position" A) ("_type_name" abc_prog))
###           ("_position" Q)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt" ("_position" P)
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" A) ("_position" B)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Abacus_Hoare"
### 0.355s elapsed time, 0.783s cpu time, 0.100s GC time
Loading theory "Draft.Recursive" (required by "Draft.UTMMoreTemplates" via "Draft.UTM")
Found termination order: "{}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Proofs for inductive predicate(s) "primerec"
  Proving monotonicity ...
Found termination order: "{}"
### Rewrite rule not in simpset:
### rec_exec z ?xs1 == 0
### Rewrite rule not in simpset:
### rec_exec s ?xs1 == Suc (?xs1 ! 0)
### Rewrite rule not in simpset:
### rec_exec (recf.id ?m1 ?n1) ?xs1 == ?xs1 ! ?n1
### Rewrite rule not in simpset:
### rec_exec (Cn ?n1 ?f1 ?gs1) ?xs1 ==
### rec_exec ?f1 (map (%a. rec_exec a ?xs1) ?gs1)
### Rewrite rule not in simpset:
### rec_exec (Pr ?n1 ?f1 ?g1) ?xs1 ==
### if last ?xs1 = 0 then rec_exec ?f1 (butlast ?xs1)
### else rec_exec ?g1
###       (butlast ?xs1 @
###        [last ?xs1 - 1,
###         rec_exec (Pr ?n1 ?f1 ?g1) (butlast ?xs1 @ [last ?xs1 - 1])])
### Rewrite rule not in simpset:
### rec_exec (Mn ?n1 ?f1) ?xs1 == LEAST x. rec_exec ?f1 (?xs1 @ [x]) = 0
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order:
  "(%p. size_list (%p. size (snd (snd p))) (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Missing patterns in function definition:
### quo [] = undefined
### !!v. quo [v] = undefined
### !!v vb vd ve. quo (v # vb # vd # ve) = undefined
Found termination order: "{}"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (fst p)) <*mlex*> {}"
### Missing patterns in function definition:
### rec_embranch [] = undefined
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
### Missing patterns in function definition:
### loR [] = undefined
### !!v. loR [v] = undefined
### !!v vb. loR [v, vb] = undefined
### (1 more)
Found termination order: "{}"
Found termination order: "{}"
### Missing patterns in function definition:
### lgR [] = undefined
### !!v. lgR [v] = undefined
### !!v vb. lgR [v, vb] = undefined
### (1 more)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Missing patterns in function definition:
### newleft0 [] = undefined
### !!v. newleft0 [v] = undefined
### !!v vb vd ve. newleft0 (v # vb # vd # ve) = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### newrgt0 [] = undefined
### !!v. newrgt0 [v] = undefined
### !!v vb vd ve. newrgt0 (v # vb # vd # ve) = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### newleft1 [] = undefined
### !!v. newleft1 [v] = undefined
### !!v vb vd ve. newleft1 (v # vb # vd # ve) = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### newrgt1 [] = undefined
### !!v. newrgt1 [v] = undefined
### !!v vb vd ve. newrgt1 (v # vb # vd # ve) = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### newleft2 [] = undefined
### !!v. newleft2 [v] = undefined
### !!v vb vd ve. newleft2 (v # vb # vd # ve) = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### newrgt2 [] = undefined
### !!v. newrgt2 [v] = undefined
### !!v vb vd ve. newrgt2 (v # vb # vd # ve) = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### newleft3 [] = undefined
### !!v. newleft3 [v] = undefined
### !!v vb vd ve. newleft3 (v # vb # vd # ve) = undefined
Found termination order: "{}"
### Missing patterns in function definition:
### newrgt3 [] = undefined
### !!v. newrgt3 [v] = undefined
### !!v vb vd ve. newrgt3 (v # vb # vd # ve) = undefined
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size_list (%p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### fetch ?p1 0 ?b1 == (Nop, 0)
### Rewrite rule not in simpset:
### fetch ?p1 (Suc ?s1) Bk ==
### case nth_of ?p1 (2 * ?s1) of None => (Nop, 0) | Some i => i
### Rewrite rule not in simpset:
### fetch ?p1 (Suc ?s1) Oc ==
### case nth_of ?p1 (2 * ?s1 + 1) of None => (Nop, 0) | Some i => i
### Rewrite rule not in simpset:
### tm_wf (?p1, ?off1) ==
### 2 <= length ?p1 &
### is_even (length ?p1) &
### (ALL (a, s):set ?p1. s <= length ?p1 div 2 + ?off1 & ?off1 <= s)
### theory "Draft.UF"
### 4.796s elapsed time, 15.225s cpu time, 0.760s GC time
Found termination order: "size <*mlex*> {}"
### Rewrite rule not in simpset:
### rec_ci_s == addition 0 1 2 [+] [Inc 1]
### Rewrite rule not in simpset:
### rec_ci_z == [Goto 1]
### Rewrite rule not in simpset:
### abc_steps_l (?s1, ?lm1) ?p1 0 == (?s1, ?lm1)
### Rewrite rule not in simpset:
### abc_steps_l (?s1, ?lm1) ?p1 (Suc ?n1) ==
### abc_steps_l (abc_step_l (?s1, ?lm1) (abc_fetch ?s1 ?p1)) ?p1 ?n1
### Rewrite rule not in simpset:
### abc_fetch ?s1 ?p1 == if ?s1 < length ?p1 then Some (?p1 ! ?s1) else None
### Rewrite rule not in simpset:
### abc_step_l (?s1, ?lm1) ?a1 ==
### case ?a1 of None => (?s1, ?lm1)
### | Some (Inc n) =>
###     let nv = abc_lm_v ?lm1 n in (?s1 + 1, abc_lm_s ?lm1 n (nv + 1))
### | Some (Dec n e) =>
###     let nv = abc_lm_v ?lm1 n
###     in if nv = 0 then (e, abc_lm_s ?lm1 n 0)
###        else (?s1 + 1, abc_lm_s ?lm1 n (nv - 1))
### | Some (Goto n) => (n, ?lm1)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 328 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" a)
###       ("\<^const>HOL.eq" ("_position" a) ("_position" lm)))
###     ("_applC" ("_position" addition)
###       ("_cargs" ("_position" m) ("_cargs" ("_position" n) ("_position" p))))
###     ("_lambda" ("_position" nl)
###       ("_applC" ("_position" addition_inv)
###         ("_cargs"
###           ("_tuple" ("_Numeral" ("_constify" ("_position" 7)))
###             ("_tuple_arg" ("_position" nl)))
###           ("_cargs" ("_position" m)
###             ("_cargs" ("_position" n)
###               ("_cargs" ("_position" p) ("_position" lm)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" a)
###       ("\<^const>HOL.eq" ("_position" a) ("_position" lm)))
###     ("_applC" ("_position" addition)
###       ("_cargs" ("_position" m) ("_cargs" ("_position" n) ("_position" p))))
###     ("_lambda" ("_position" nl)
###       ("_applC" ("_position" addition_inv)
###         ("_cargs"
###           ("_tuple" ("_Numeral" ("_constify" ("_position" 7)))
###             ("_tuple_arg" ("_position" nl)))
###           ("_cargs" ("_position" m)
###             ("_cargs" ("_position" n)
###               ("_cargs" ("_position" p) ("_position" lm)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" a)
###         ("\<^const>HOL.eq" ("_position" a) ("_position" lm))))
###     ("_cargs"
###       ("_applC" ("_position" addition)
###         ("_cargs" ("_position" m)
###           ("_cargs" ("_position" n) ("_position" p))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("_applC" ("_position" addition_inv)
###             ("_cargs"
###               ("_tuple" ("_Numeral" ("_constify" ("_position" 7)))
###                 ("_tuple_arg" ("_position" nl)))
###               ("_cargs" ("_position" m)
###                 ("_cargs" ("_position" n)
###                   ("_cargs" ("_position" p) ("_position" lm)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 345 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("_position" n)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_Numeral" ("_constify" ("_position" 2))))
###             ("_position" anything)))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" addition)
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_cargs"
###             ("_applC" ("_position" Suc) ("\<^const>Groups.zero_class.zero"))
###             ("_Numeral" ("_constify" ("_position" 2))))))
###       ("_list"
###         ("_applC" ("_position" Inc)
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.zero_class.zero")))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("_position" n)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" Suc) ("_position" n))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("_position" n)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_Numeral" ("_constify" ("_position" 2))))
###             ("_position" anything)))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" addition)
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_cargs"
###             ("_applC" ("_position" Suc) ("\<^const>Groups.zero_class.zero"))
###             ("_Numeral" ("_constify" ("_position" 2))))))
###       ("_list"
###         ("_applC" ("_position" Inc)
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.zero_class.zero")))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("_position" n)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" Suc) ("_position" n))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_comp"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("_position" n)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_Numeral" ("_constify" ("_position" 2))))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" addition)
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_cargs"
###             ("_applC" ("_position" Suc) ("\<^const>Groups.zero_class.zero"))
###             ("_Numeral" ("_constify" ("_position" 2)))))))
###     ("_applC"
###       ("_list"
###         ("_applC" ("_position" Inc)
###           ("_applC" ("_position" Suc) ("\<^const>Groups.zero_class.zero"))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("_position" n)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" Suc) ("_position" n))
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 366 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" z))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" z) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" z))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" z) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" z))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" z) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("_position" n)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" ap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.list.Cons" ("_position" n)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 375 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" s))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" s) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" s))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" s) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.list.Cons" ("_position" n)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" s))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" s) ("_list" ("_position" n))))
###           ("_position" r)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("_position" n)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" ap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.list.Cons" ("_position" n)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 382 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_Numeral" ("_constify" ("_position" 2))))
###             ("_position" anything)))))
###     ("_applC" ("_position" addition)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_applC" ("_position" length) ("_position" args))
###           ("_applC" ("_position" Suc)
###             ("_applC" ("_position" length) ("_position" args))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" recf.id)
###                   ("_cargs"
###                     ("_applC" ("_position" length) ("_position" args))
###                     ("_position" n)))
###                 ("_position" args)))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_Numeral" ("_constify" ("_position" 2))))
###             ("_position" anything)))))
###     ("_applC" ("_position" addition)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_applC" ("_position" length) ("_position" args))
###           ("_applC" ("_position" Suc)
###             ("_applC" ("_position" length) ("_position" args))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" recf.id)
###                   ("_cargs"
###                     ("_applC" ("_position" length) ("_position" args))
###                     ("_position" n)))
###                 ("_position" args)))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_Numeral" ("_constify" ("_position" 2))))
###               ("_position" anything))))))
###     ("_cargs" ("_position" addition)
###       ("_cargs" ("_position" n)
###         ("_cargs" ("_applC" ("_position" length) ("_position" args))
###           ("_cargs"
###             ("_applC" ("_position" Suc)
###               ("_applC" ("_position" length) ("_position" args)))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" args)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" recf.id)
###                             ("_cargs"
###                               ("_applC" ("_position" length)
###                                 ("_position" args))
###                               ("_position" n)))
###                           ("_position" args)))
###                       ("\<^const>List.list.Cons"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 396 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" n) ("_position" m)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" m)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("_applC" ("_position" recf.id)
###                 ("_cargs" ("_position" m) ("_position" n))))
###             ("_tuple" ("_position" ap)
###               ("_tuple_args" ("_position" arity)
###                 ("_tuple_arg" ("_position" fp))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" recf.id)
###                     ("_cargs" ("_position" m) ("_position" n)))
###                   ("_position" xs)))
###               ("_position" r)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" n) ("_position" m)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" m)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("_applC" ("_position" recf.id)
###                 ("_cargs" ("_position" m) ("_position" n))))
###             ("_tuple" ("_position" ap)
###               ("_tuple_args" ("_position" arity)
###                 ("_tuple_arg" ("_position" fp))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" recf.id)
###                     ("_cargs" ("_position" m) ("_position" n)))
###                   ("_position" xs)))
###               ("_position" r)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" n) ("_position" m)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" m)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("_applC" ("_position" recf.id)
###                 ("_cargs" ("_position" m) ("_position" n))))
###             ("_tuple" ("_position" ap)
###               ("_tuple_args" ("_position" arity)
###                 ("_tuple_arg" ("_position" fp))))))
###         ("_asm"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" recf.id)
###                     ("_cargs" ("_position" m) ("_position" n)))
###                   ("_position" xs)))
###               ("_position" r)))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" ap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 593 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.greater"
###         ("_applC" ("_position" length) ("_position" lm))
###         ("_applC" ("_position" max)
###           ("_cargs" ("_position" m) ("_position" n)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" m) ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm)))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" m) ("_position" n)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("_LUpdate" ("_position" lm)
###             ("_lupdbinds"
###               ("_lupdbind" ("_position" n)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("\<^const>List.nth" ("_position" lm) ("_position" m))
###                   ("\<^const>List.nth" ("_position" lm) ("_position" n))))
###               ("_lupdbind" ("_position" m)
###                 ("\<^const>Groups.zero_class.zero")))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.greater"
###         ("_applC" ("_position" length) ("_position" lm))
###         ("_applC" ("_position" max)
###           ("_cargs" ("_position" m) ("_position" n)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" m) ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm)))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" m) ("_position" n)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("_LUpdate" ("_position" lm)
###             ("_lupdbinds"
###               ("_lupdbind" ("_position" n)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("\<^const>List.nth" ("_position" lm) ("_position" m))
###                   ("\<^const>List.nth" ("_position" lm) ("_position" n))))
###               ("_lupdbind" ("_position" m)
###                 ("\<^const>Groups.zero_class.zero")))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.greater"
###         ("_applC" ("_position" length) ("_position" lm))
###         ("_applC" ("_position" max)
###           ("_cargs" ("_position" m) ("_position" n)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.not_equal" ("_position" m) ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl) ("_position" lm))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" m)
###           ("_cargs" ("_position" n)
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("_LUpdate" ("_position" lm)
###                     ("_lupdbinds"
###                       ("_lupdbind" ("_position" n)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("\<^const>List.nth" ("_position" lm)
###                             ("_position" m))
###                           ("\<^const>List.nth" ("_position" lm)
###                             ("_position" n))))
###                       ("_lupdbind" ("_position" m)
###                         ("\<^const>Groups.zero_class.zero")))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 615 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g)
###     ("_applC" ("_position" set)
###       ("_applC" ("_position" take)
###         ("_cargs" ("_position" n) ("_position" gs))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g)
###     ("_applC" ("_position" set)
###       ("_applC" ("_position" take)
###         ("_cargs" ("_position" n) ("_position" gs))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g)
###     ("_applC" ("_position" set)
###       ("_applC" ("_position" take)
###         ("_cargs" ("_position" n) ("_position" gs))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb) ("_position" xa)))
###                         ("_position" xc))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs)))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 619 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("_applC" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci)
###             ("_applC" ("_position" take)
###               ("_cargs" ("_position" n) ("_position" gs)))))
###         ("_position" ft)))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_applC" ("_position" take)
###                     ("_cargs" ("_position" n) ("_position" gs)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" length) ("_position" gs))
###                     ("_position" n)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_position" anything))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("_applC" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci)
###             ("_applC" ("_position" take)
###               ("_cargs" ("_position" n) ("_position" gs)))))
###         ("_position" ft)))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_applC" ("_position" take)
###                     ("_cargs" ("_position" n) ("_position" gs)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" length) ("_position" gs))
###                     ("_position" n)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_position" anything))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                     ("_applC" ("_position" length) ("_position" gs))))
###                 ("_position" anything)))))))
###     ("_cargs" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci)
###             ("_applC" ("_position" take)
###               ("_cargs" ("_position" n) ("_position" gs)))))
###         ("_cargs" ("_position" ft)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                         ("_applC" ("_position" length) ("_position" xs))))
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs"
###                           ("_lambda" ("_position" i)
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs" ("_position" i) ("_position" xs))))
###                           ("_applC" ("_position" take)
###                             ("_cargs" ("_position" n) ("_position" gs)))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_applC" ("_position" length) ("_position" gs))
###                             ("_position" n)))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("_applC" ("_position" Suc)
###                               ("_applC" ("_position" length)
###                                 ("_position" xs))))
###                           ("_position" anything))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 775 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb) ("_position" xa)))
###                         ("_position" xc))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs)))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 779 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("_applC" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci) ("_position" gs)))
###         ("_position" ft)))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("_applC" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci) ("_position" gs)))
###         ("_position" ft)))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.plus_class.plus" ("_position" ft)
###                     ("_applC" ("_position" length) ("_position" gs))))
###                 ("_position" anything)))))))
###     ("_cargs" ("_position" cn_merge_gs)
###       ("_cargs"
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" rec_ci) ("_position" gs)))
###         ("_cargs" ("_position" ft)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                         ("_applC" ("_position" length) ("_position" xs))))
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs"
###                           ("_lambda" ("_position" i)
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs" ("_position" i) ("_position" xs))))
###                           ("_position" gs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs))))
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 853 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq"
###         ("\<^const>Groups.plus_class.plus" ("_position" aa) ("_position" n))
###         ("_position" ba)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length) ("_position" lm1))
###             ("_position" aa)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length) ("_position" lm2))
###               ("_position" n)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length) ("_position" lm3))
###                 ("\<^const>Groups.minus_class.minus"
###                   ("\<^const>Groups.minus_class.minus" ("_position" ba)
###                     ("_position" aa))
###                   ("_position" n)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append" ("_position" lm2)
###               ("\<^const>List.append" ("_position" lm3)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_position" lm4)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs" ("_position" aa)
###           ("_cargs" ("_position" ba) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" n))
###               ("\<^const>List.append" ("_position" lm3)
###                 ("\<^const>List.append" ("_position" lm2)
###                   ("_position" lm4))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq"
###         ("\<^const>Groups.plus_class.plus" ("_position" aa) ("_position" n))
###         ("_position" ba)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length) ("_position" lm1))
###             ("_position" aa)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length) ("_position" lm2))
###               ("_position" n)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length) ("_position" lm3))
###                 ("\<^const>Groups.minus_class.minus"
###                   ("\<^const>Groups.minus_class.minus" ("_position" ba)
###                     ("_position" aa))
###                   ("_position" n)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append" ("_position" lm2)
###               ("\<^const>List.append" ("_position" lm3)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_position" lm4)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs" ("_position" aa)
###           ("_cargs" ("_position" ba) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" n))
###               ("\<^const>List.append" ("_position" lm3)
###                 ("\<^const>List.append" ("_position" lm2)
###                   ("_position" lm4))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq"
###         ("\<^const>Groups.plus_class.plus" ("_position" aa) ("_position" n))
###         ("_position" ba)))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.greater" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length) ("_position" lm1))
###             ("_position" aa)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length) ("_position" lm2))
###               ("_position" n)))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length) ("_position" lm3))
###                 ("\<^const>Groups.minus_class.minus"
###                   ("\<^const>Groups.minus_class.minus" ("_position" ba)
###                     ("_position" aa))
###                   ("_position" n)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" lm1)
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append" ("_position" lm3)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero") ("_position" n))
###                     ("_position" lm4))))))))
###       ("_cargs"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("_position" aa)
###             ("_cargs" ("_position" ba) ("_position" n))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" lm1)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("\<^const>List.append" ("_position" lm3)
###                     ("\<^const>List.append" ("_position" lm2)
###                       ("_position" lm4))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 920 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq" ("_position" n)
###         ("\<^const>Groups.minus_class.minus" ("_position" aa)
###           ("_position" ba))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length)
###               ("_constrain" ("_position" lm1)
###                 ("_tapp" ("_type_name" nat) ("_type_name" list))))
###             ("_position" ba)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length)
###                 ("_constrain" ("_position" lm2)
###                   ("_tapp" ("_type_name" nat) ("_type_name" list))))
###               ("\<^const>Groups.minus_class.minus"
###                 ("\<^const>Groups.minus_class.minus" ("_position" aa)
###                   ("_position" ba))
###                 ("_position" n))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length)
###                   ("_constrain" ("_position" lm3)
###                     ("_tapp" ("_type_name" nat) ("_type_name" list))))
###                 ("_position" n))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" n))
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append" ("_position" lm3)
###                   ("_position" lm4)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs" ("_position" aa)
###           ("_cargs" ("_position" ba) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append" ("_position" lm3)
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_position" lm4))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq" ("_position" n)
###         ("\<^const>Groups.minus_class.minus" ("_position" aa)
###           ("_position" ba))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length)
###               ("_constrain" ("_position" lm1)
###                 ("_tapp" ("_type_name" nat) ("_type_name" list))))
###             ("_position" ba)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length)
###                 ("_constrain" ("_position" lm2)
###                   ("_tapp" ("_type_name" nat) ("_type_name" list))))
###               ("\<^const>Groups.minus_class.minus"
###                 ("\<^const>Groups.minus_class.minus" ("_position" aa)
###                   ("_position" ba))
###                 ("_position" n))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length)
###                   ("_constrain" ("_position" lm3)
###                     ("_tapp" ("_type_name" nat) ("_type_name" list))))
###                 ("_position" n))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" n))
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append" ("_position" lm3)
###                   ("_position" lm4)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs" ("_position" aa)
###           ("_cargs" ("_position" ba) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" lm1)
###             ("\<^const>List.append" ("_position" lm3)
###               ("\<^const>List.append" ("_position" lm2)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_position" lm4))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less_eq" ("_position" n)
###         ("\<^const>Groups.minus_class.minus" ("_position" aa)
###           ("_position" ba))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" ba)
###           ("_position" aa)))
###       ("_asms"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" length)
###               ("_constrain" ("_position" lm1)
###                 ("_tapp" ("_type_name" nat) ("_type_name" list))))
###             ("_position" ba)))
###         ("_asms"
###           ("\<^const>HOL.Trueprop"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" length)
###                 ("_constrain" ("_position" lm2)
###                   ("_tapp" ("_type_name" nat) ("_type_name" list))))
###               ("\<^const>Groups.minus_class.minus"
###                 ("\<^const>Groups.minus_class.minus" ("_position" aa)
###                   ("_position" ba))
###                 ("_position" n))))
###           ("_asm"
###             ("\<^const>HOL.Trueprop"
###               ("\<^const>HOL.eq"
###                 ("_applC" ("_position" length)
###                   ("_constrain" ("_position" lm3)
###                     ("_tapp" ("_type_name" nat) ("_type_name" list))))
###                 ("_position" n))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" lm1)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero") ("_position" n))
###                 ("\<^const>List.append" ("_position" lm2)
###                   ("\<^const>List.append" ("_position" lm3)
###                     ("_position" lm4))))))))
###       ("_cargs"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("_position" aa)
###             ("_cargs" ("_position" ba) ("_position" n))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" lm1)
###                 ("\<^const>List.append" ("_position" lm3)
###                   ("\<^const>List.append" ("_position" lm2)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero") ("_position" n))
###                       ("_position" lm4))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| max ?m ?n < length ?lm; ?m ~= ?n |]
==> {%nl. nl = ?lm} mv_box ?m ?n
    {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}
### Ambiguous input (line 979 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs)))))))))
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("_position" anything)))))))
###     ("_applC" ("_position" mv_boxes)
###       ("_cargs" ("\<^const>Groups.zero_class.zero")
###         ("_cargs"
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_applC" ("_position" length) ("_position" gs))))
###           ("_applC" ("_position" length) ("_position" xs)))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs))))))))))
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append" ("_position" xs)
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs)))))))))
###                 ("_applC" ("_position" length) ("_position" xs))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("_position" anything)))))))
###     ("_applC" ("_position" mv_boxes)
###       ("_cargs" ("\<^const>Groups.zero_class.zero")
###         ("_cargs"
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_applC" ("_position" length) ("_position" gs))))
###           ("_applC" ("_position" length) ("_position" xs)))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs))))))))))
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append" ("_position" xs)
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" i)
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" i) ("_position" xs))))
###                     ("_position" gs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_position" anything))))))))
###     ("_cargs" ("_position" mv_boxes)
###       ("_cargs" ("\<^const>Groups.zero_class.zero")
###         ("_cargs"
###           ("_applC" ("_position" Suc)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_applC" ("_position" length) ("_position" gs))))
###           ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs))))))))))
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs"
###                           ("_lambda" ("_position" i)
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs" ("_position" i) ("_position" xs))))
###                           ("_position" gs)))
###                       ("\<^const>List.list.Cons"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_position" anything))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1000 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs"
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set) ("_position" gs)))))))))
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" gs)))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs))))))))))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_boxes)
###         ("_cargs"
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set) ("_position" gs)))))))))
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" gs)))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs))))))))))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" xs)))
###                     ("_applC" ("_position" Max)
###                       ("_applC" ("_position" insert)
###                         ("_cargs" ("_position" ffp)
###                           ("\<^const>Set.image"
###                             ("_lambda"
###                               ("_pattern" ("_position" aprog)
###                                 ("_patterns" ("_position" p)
###                                   ("_position" n)))
###                               ("_position" n))
###                             ("\<^const>Set.image" ("_position" rec_ci)
###                               ("_applC" ("_position" set)
###                                 ("_position" gs))))))))))
###               ("\<^const>List.append"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" i)
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" i) ("_position" xs))))
###                     ("_position" gs)))
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything))))))))
###       ("_cargs" ("_position" mv_boxes)
###         ("_cargs"
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set) ("_position" gs)))))))))
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_cargs" ("_applC" ("_position" length) ("_position" gs))
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs"
###                           ("_lambda" ("_position" i)
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs" ("_position" i) ("_position" xs))))
###                           ("_position" gs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs))))))))))
###                         ("\<^const>List.list.Cons"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_position" anything)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1025 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" far)
###         ("_applC" ("_position" length) ("_position" gs))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less_eq" ("_position" ffp)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Orderings.ord_class.less" ("_position" far)
###             ("_position" ffp))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs))))))))))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" far)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything)))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" far)
###         ("_applC" ("_position" length) ("_position" gs))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less_eq" ("_position" ffp)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Orderings.ord_class.less" ("_position" far)
###             ("_position" ffp))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs))))))))))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" far)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything)))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" far)
###         ("_applC" ("_position" length) ("_position" gs))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less_eq" ("_position" ffp)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>Orderings.ord_class.less" ("_position" far)
###             ("_position" ffp))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" length) ("_position" xs)))
###                         ("_applC" ("_position" Max)
###                           ("_applC" ("_position" insert)
###                             ("_cargs" ("_position" ffp)
###                               ("\<^const>Set.image"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" aprog)
###                                     ("_patterns" ("_position" p)
### ("_position" n)))
###                                   ("_position" n))
###                                 ("\<^const>Set.image" ("_position" rec_ci)
###                                   ("_applC" ("_position" set)
###                                     ("_position" gs))))))))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything))))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" far)
###           ("_cargs"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs)))))))))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append"
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" i)
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" i) ("_position" xs))))
###                         ("_position" gs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" gs))))
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Cn)
###                               ("_cargs"
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs))
###                                 ("_cargs" ("_position" f)
###                                   ("_position" gs))))
###                             ("_position" xs)))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("_applC" ("_position" length)
###                               ("_position" gs)))
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_position" anything)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| max ?m ?n < length ?lm; ?m ~= ?n |]
==> {%nl. nl = ?lm} mv_box ?m ?n
    {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}
### Ambiguous input (line 1062 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_position" n))
###           ("\<^const>List.list.Cons" ("_position" x) ("_position" lm)))))
###     ("_list"
###       ("_args"
###         ("_applC" ("_position" Dec)
###           ("_cargs" ("_position" n)
###             ("_Numeral" ("_constify" ("_position" 2)))))
###         ("_applC" ("_position" Goto) ("\<^const>Groups.zero_class.zero"))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("_position" lm)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_position" n))
###           ("\<^const>List.list.Cons" ("_position" x) ("_position" lm)))))
###     ("_list"
###       ("_args"
###         ("_applC" ("_position" Dec)
###           ("_cargs" ("_position" n)
###             ("_Numeral" ("_constify" ("_position" 2)))))
###         ("_applC" ("_position" Goto) ("\<^const>Groups.zero_class.zero"))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("_position" lm)))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("\<^const>List.list.Cons" ("_position" x) ("_position" lm))))))
###     ("_cargs"
###       ("_list"
###         ("_args"
###           ("_applC" ("_position" Dec)
###             ("_cargs" ("_position" n)
###               ("_Numeral" ("_constify" ("_position" 2)))))
###           ("_applC" ("_position" Goto)
###             ("\<^const>Groups.zero_class.zero"))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero") ("_position" n))
###                 ("_position" lm)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1092 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq"
###       ("_applC" ("_position" length) ("_position" lm)) ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm)))
###       ("_applC" ("_position" empty_boxes) ("_position" n))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("_applC" ("_position" drop)
###               ("_cargs" ("_position" n) ("_position" lm)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq"
###       ("_applC" ("_position" length) ("_position" lm)) ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm)))
###       ("_applC" ("_position" empty_boxes) ("_position" n))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_position" n))
###             ("_applC" ("_position" drop)
###               ("_cargs" ("_position" n) ("_position" lm)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq"
###       ("_applC" ("_position" length) ("_position" lm)) ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl) ("_position" lm))))
###       ("_cargs" ("_position" empty_boxes)
###         ("_cargs" ("_position" n)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero") ("_position" n))
###                   ("_applC" ("_position" drop)
###                     ("_cargs" ("_position" n) ("_position" lm))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1128 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything))))))))
###       ("_applC" ("_position" empty_boxes)
###         ("_applC" ("_position" length) ("_position" gs)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" i)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" i) ("_position" xs))))
###                 ("_position" gs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything))))))))
###       ("_applC" ("_position" empty_boxes)
###         ("_applC" ("_position" length) ("_position" gs)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.greater_eq" ("_position" ffp)
###       ("_applC" ("_position" length) ("_position" gs))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" i)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" i) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" length) ("_position" xs)))
###                         ("_applC" ("_position" Max)
###                           ("_applC" ("_position" insert)
###                             ("_cargs" ("_position" ffp)
###                               ("\<^const>Set.image"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" aprog)
###                                     ("_patterns" ("_position" p)
### ("_position" n)))
###                                   ("_position" n))
###                                 ("\<^const>Set.image" ("_position" rec_ci)
###                                   ("_applC" ("_position" set)
###                                     ("_position" gs)))))))))
###                     ("_applC" ("_position" length) ("_position" gs))))
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Cn)
###                         ("_cargs"
###                           ("_applC" ("_position" length) ("_position" xs))
###                           ("_cargs" ("_position" f) ("_position" gs))))
###                       ("_position" xs)))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("_applC" ("_position" length) ("_position" gs)))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_position" anything)))))))))
###       ("_cargs" ("_position" empty_boxes)
###         ("_cargs" ("_applC" ("_position" length) ("_position" gs))
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" length) ("_position" xs)))
###                         ("_applC" ("_position" Max)
###                           ("_applC" ("_position" insert)
###                             ("_cargs" ("_position" ffp)
###                               ("\<^const>Set.image"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" aprog)
###                                     ("_patterns" ("_position" p)
### ("_position" n)))
###                                   ("_position" n))
###                                 ("\<^const>Set.image" ("_position" rec_ci)
###                                   ("_applC" ("_position" set)
###                                     ("_position" gs))))))))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Cn)
###                           ("_cargs"
###                             ("_applC" ("_position" length) ("_position" xs))
###                             ("_cargs" ("_position" f) ("_position" gs))))
###                         ("_position" xs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("_applC" ("_position" length) ("_position" gs)))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1152 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs))))))))))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))
###               ("\<^const>List.append" ("_position" xs)
###                 ("_position" anything)))))))
###     ("_applC" ("_position" mv_box)
###       ("_cargs"
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("_applC" ("_position" Suc)
###               ("_applC" ("_position" length) ("_position" xs)))
###             ("_applC" ("_position" Max)
###               ("_applC" ("_position" insert)
###                 ("_cargs" ("_position" ffp)
###                   ("\<^const>Set.image"
###                     ("_lambda"
###                       ("_pattern" ("_position" aprog)
###                         ("_patterns" ("_position" p) ("_position" n)))
###                       ("_position" n))
###                     ("\<^const>Set.image" ("_position" rec_ci)
###                       ("_applC" ("_position" set) ("_position" gs)))))))))
###         ("_applC" ("_position" length) ("_position" xs))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" xs)))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs))))))))))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))
###               ("\<^const>List.append" ("_position" xs)
###                 ("_position" anything)))))))
###     ("_applC" ("_position" mv_box)
###       ("_cargs"
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("_applC" ("_position" Suc)
###               ("_applC" ("_position" length) ("_position" xs)))
###             ("_applC" ("_position" Max)
###               ("_applC" ("_position" insert)
###                 ("_cargs" ("_position" ffp)
###                   ("\<^const>Set.image"
###                     ("_lambda"
###                       ("_pattern" ("_position" aprog)
###                         ("_patterns" ("_position" p) ("_position" n)))
###                       ("_position" n))
###                     ("\<^const>Set.image" ("_position" rec_ci)
###                       ("_applC" ("_position" set) ("_position" gs)))))))))
###         ("_applC" ("_position" length) ("_position" xs))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" xs)))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs))))))))))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))
###     ("_cargs" ("_position" mv_box)
###       ("_cargs"
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("_applC" ("_position" Suc)
###               ("_applC" ("_position" length) ("_position" xs)))
###             ("_applC" ("_position" Max)
###               ("_applC" ("_position" insert)
###                 ("_cargs" ("_position" ffp)
###                   ("\<^const>Set.image"
###                     ("_lambda"
###                       ("_pattern" ("_position" aprog)
###                         ("_patterns" ("_position" p) ("_position" n)))
###                       ("_position" n))
###                     ("\<^const>Set.image" ("_position" rec_ci)
###                       ("_applC" ("_position" set) ("_position" gs)))))))))
###         ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Cn)
###                           ("_cargs"
###                             ("_applC" ("_position" length) ("_position" xs))
###                             ("_cargs" ("_position" f) ("_position" gs))))
###                         ("_position" xs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" xs))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("_applC" ("_position" length) ("_position" gs)))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_position" anything))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| max ?m ?n < length ?lm; ?m ~= ?n |]
==> {%nl. nl = ?lm} mv_box ?m ?n
    {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}
### Ambiguous input (line 1176 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" xs)))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))
###     ("_applC" ("_position" mv_boxes)
###       ("_cargs"
###         ("_applC" ("_position" Suc)
###           ("\<^const>Groups.plus_class.plus"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs)))))))))
###             ("_applC" ("_position" length) ("_position" gs))))
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" length) ("_position" xs)))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###             ("_applC" ("_position" length) ("_position" xs)))
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" xs))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>List.append" ("_position" xs)
###                   ("_position" anything))))))))
###     ("_applC" ("_position" mv_boxes)
###       ("_cargs"
###         ("_applC" ("_position" Suc)
###           ("\<^const>Groups.plus_class.plus"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs)))))))))
###             ("_applC" ("_position" length) ("_position" gs))))
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" length) ("_position" xs)))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("_applC" ("_position" length) ("_position" xs)))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Cn)
###                     ("_cargs"
###                       ("_applC" ("_position" length) ("_position" xs))
###                       ("_cargs" ("_position" f) ("_position" gs))))
###                   ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" length) ("_position" xs)))
###                         ("_applC" ("_position" Max)
###                           ("_applC" ("_position" insert)
###                             ("_cargs" ("_position" ffp)
###                               ("\<^const>Set.image"
###                                 ("_lambda"
###                                   ("_pattern" ("_position" aprog)
###                                     ("_patterns" ("_position" p)
### ("_position" n)))
###                                   ("_position" n))
###                                 ("\<^const>Set.image" ("_position" rec_ci)
###                                   ("_applC" ("_position" set)
###                                     ("_position" gs)))))))))
###                     ("_applC" ("_position" length) ("_position" xs))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_applC" ("_position" length) ("_position" gs)))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_position" anything)))))))))
###     ("_cargs" ("_position" mv_boxes)
###       ("_cargs"
###         ("_applC" ("_position" Suc)
###           ("\<^const>Groups.plus_class.plus"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("_applC" ("_position" Suc)
###                   ("_applC" ("_position" length) ("_position" xs)))
###                 ("_applC" ("_position" Max)
###                   ("_applC" ("_position" insert)
###                     ("_cargs" ("_position" ffp)
###                       ("\<^const>Set.image"
###                         ("_lambda"
###                           ("_pattern" ("_position" aprog)
###                             ("_patterns" ("_position" p) ("_position" n)))
###                           ("_position" n))
###                         ("\<^const>Set.image" ("_position" rec_ci)
###                           ("_applC" ("_position" set)
###                             ("_position" gs)))))))))
###             ("_applC" ("_position" length) ("_position" gs))))
###         ("_cargs" ("\<^const>Groups.zero_class.zero")
###           ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" Cn)
###                             ("_cargs"
###                               ("_applC" ("_position" length)
###                                 ("_position" xs))
###                               ("_cargs" ("_position" f) ("_position" gs))))
###                           ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.plus_class.plus"
###                             ("_applC" ("_position" max)
###                               ("_cargs"
###                                 ("_applC" ("_position" Suc)
###                                   ("_applC" ("_position" length)
###                                     ("_position" xs)))
###                                 ("_applC" ("_position" Max)
###                                   ("_applC" ("_position" insert)
###                                     ("_cargs" ("_position" ffp)
### ("\<^const>Set.image"
###   ("_lambda"
###     ("_pattern" ("_position" aprog)
###       ("_patterns" ("_position" p) ("_position" n)))
###     ("_position" n))
###   ("\<^const>Set.image" ("_position" rec_ci)
###     ("_applC" ("_position" set) ("_position" gs)))))))))
###                             ("_applC" ("_position" length)
###                               ("_position" gs))))
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| ?n <= ?aa - ?ba; ?ba < ?aa; length ?lm1.0 = ?ba;
   length ?lm2.0 = ?aa - ?ba - ?n; length ?lm3.0 = ?n |]
==> {%nl. nl = ?lm1.0 @ 0 \<up> ?n @ ?lm2.0 @ ?lm3.0 @ ?lm4.0}
    mv_boxes ?aa ?ba ?n
    {%nl. nl = ?lm1.0 @ ?lm3.0 @ ?lm2.0 @ 0 \<up> ?n @ ?lm4.0}
### Ambiguous input (line 1195 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" anything) ("_position" r))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" rec_exec)
###           ("_cargs" ("_position" f)
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" g)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" g) ("_position" xs))))
###                 ("_position" gs)))))
###         ("_applC" ("_position" rec_exec)
###           ("_cargs"
###             ("_applC" ("_position" Cn)
###               ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                 ("_cargs" ("_position" f) ("_position" gs))))
###             ("_position" xs)))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                     ("_position" far)))
###                 ("_position" anything)))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" anything) ("_position" r))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" rec_exec)
###           ("_cargs" ("_position" f)
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" g)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" g) ("_position" xs))))
###                 ("_position" gs)))))
###         ("_applC" ("_position" rec_exec)
###           ("_cargs"
###             ("_applC" ("_position" Cn)
###               ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                 ("_cargs" ("_position" f) ("_position" gs))))
###             ("_position" xs)))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                     ("_position" far)))
###                 ("_position" anything)))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" anything) ("_position" r))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" rec_exec)
###           ("_cargs" ("_position" f)
###             ("_applC" ("_position" map)
###               ("_cargs"
###                 ("_lambda" ("_position" g)
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" g) ("_position" xs))))
###                 ("_position" gs)))))
###         ("_applC" ("_position" rec_exec)
###           ("_cargs"
###             ("_applC" ("_position" Cn)
###               ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                 ("_cargs" ("_position" f) ("_position" gs))))
###             ("_position" xs)))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" g)
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs))))
###                     ("_position" gs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ffp)
###                       ("_position" far)))
###                   ("_position" anything))))))
###         ("_cargs" ("_position" fap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs"
###                       ("_lambda" ("_position" g)
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g) ("_position" xs))))
###                       ("_position" gs)))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Cn)
###                           ("_cargs"
###                             ("_applC" ("_position" length) ("_position" xs))
###                             ("_cargs" ("_position" f) ("_position" gs))))
###                         ("_position" xs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" ffp)
###                           ("_applC" ("_position" Suc) ("_position" far))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1200 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb) ("_position" xa)))
###                         ("_position" xc))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs)))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1204 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" cn_merge_gs)
###         ("_cargs"
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" rec_ci) ("_position" gs)))
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_applC" ("_position" length) ("_position" xs)))))
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_boxes)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_cargs" ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))))
###           ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_applC" ("_position" mv_box)
###                 ("_cargs" ("_position" far)
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))))
###               ("\<^const>Abacus_Hoare.abc_comp"
###                 ("_applC" ("_position" empty_boxes)
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>Abacus_Hoare.abc_comp"
###                   ("_applC" ("_position" mv_box)
###                     ("_cargs"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_applC" ("_position" mv_boxes)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" gs))))
###                       ("_cargs" ("\<^const>Groups.zero_class.zero")
###                         ("_applC" ("_position" length)
###                           ("_position" xs))))))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" cn_merge_gs)
###         ("_cargs"
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" rec_ci) ("_position" gs)))
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs)))))))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_applC" ("_position" length) ("_position" xs)))))
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_boxes)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_cargs" ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))))
###           ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_applC" ("_position" mv_box)
###                 ("_cargs" ("_position" far)
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))))
###               ("\<^const>Abacus_Hoare.abc_comp"
###                 ("_applC" ("_position" empty_boxes)
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>Abacus_Hoare.abc_comp"
###                   ("_applC" ("_position" mv_box)
###                     ("_cargs"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_applC" ("_position" mv_boxes)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" gs))))
###                       ("_cargs" ("\<^const>Groups.zero_class.zero")
###                         ("_applC" ("_position" length)
###                           ("_position" xs))))))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_applC" ("_position" length) ("_position" xs))
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_comp"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" gs))))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" cn_merge_gs)
###         ("_cargs"
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" rec_ci) ("_position" gs)))
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" length) ("_position" xs)))
###               ("_applC" ("_position" Max)
###                 ("_applC" ("_position" insert)
###                   ("_cargs" ("_position" ffp)
###                     ("\<^const>Set.image"
###                       ("_lambda"
###                         ("_pattern" ("_position" aprog)
###                           ("_patterns" ("_position" p) ("_position" n)))
###                         ("_position" n))
###                       ("\<^const>Set.image" ("_position" rec_ci)
###                         ("_applC" ("_position" set)
###                           ("_position" gs))))))))))))
###     ("_applC"
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_applC" ("_position" mv_boxes)
###           ("_cargs" ("\<^const>Groups.zero_class.zero")
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.plus_class.plus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))
###                   ("_applC" ("_position" length) ("_position" gs))))
###               ("_applC" ("_position" length) ("_position" xs)))))
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_boxes)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("_applC" ("_position" Suc)
###                     ("_applC" ("_position" length) ("_position" xs)))
###                   ("_applC" ("_position" Max)
###                     ("_applC" ("_position" insert)
###                       ("_cargs" ("_position" ffp)
###                         ("\<^const>Set.image"
###                           ("_lambda"
###                             ("_pattern" ("_position" aprog)
###                               ("_patterns" ("_position" p) ("_position" n)))
###                             ("_position" n))
###                           ("\<^const>Set.image" ("_position" rec_ci)
###                             ("_applC" ("_position" set)
###                               ("_position" gs)))))))))
###               ("_cargs" ("\<^const>Groups.zero_class.zero")
###                 ("_applC" ("_position" length) ("_position" gs)))))
###           ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_applC" ("_position" mv_box)
###                 ("_cargs" ("_position" far)
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" length) ("_position" xs)))
###                       ("_applC" ("_position" Max)
###                         ("_applC" ("_position" insert)
###                           ("_cargs" ("_position" ffp)
###                             ("\<^const>Set.image"
###                               ("_lambda"
###                                 ("_pattern" ("_position" aprog)
###                                   ("_patterns" ("_position" p)
###                                     ("_position" n)))
###                                 ("_position" n))
###                               ("\<^const>Set.image" ("_position" rec_ci)
###                                 ("_applC" ("_position" set)
###                                   ("_position" gs)))))))))))
###               ("\<^const>Abacus_Hoare.abc_comp"
###                 ("_applC" ("_position" empty_boxes)
###                   ("_applC" ("_position" length) ("_position" gs)))
###                 ("\<^const>Abacus_Hoare.abc_comp"
###                   ("_applC" ("_position" mv_box)
###                     ("_cargs"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" xs))))
###                   ("_applC" ("_position" mv_boxes)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc)
###                         ("\<^const>Groups.plus_class.plus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" length)
###                                   ("_position" xs)))
###                               ("_applC" ("_position" Max)
###                                 ("_applC" ("_position" insert)
###                                   ("_cargs" ("_position" ffp)
###                                     ("\<^const>Set.image"
### ("_lambda"
###   ("_pattern" ("_position" aprog)
###     ("_patterns" ("_position" p) ("_position" n)))
###   ("_position" n))
### ("\<^const>Set.image" ("_position" rec_ci)
###   ("_applC" ("_position" set) ("_position" gs)))))))))
###                           ("_applC" ("_position" length) ("_position" gs))))
###                       ("_cargs" ("\<^const>Groups.zero_class.zero")
###                         ("_applC" ("_position" length)
###                           ("_position" xs)))))))))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" xs))
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" length)
###                               ("_position" xs)))
###                           ("_applC" ("_position" Max)
###                             ("_applC" ("_position" insert)
###                               ("_cargs" ("_position" ffp)
###                                 ("\<^const>Set.image"
###                                   ("_lambda"
###                                     ("_pattern" ("_position" aprog)
### ("_patterns" ("_position" p) ("_position" n)))
###                                     ("_position" n))
###                                   ("\<^const>Set.image" ("_position" rec_ci)
###                                     ("_applC" ("_position" set)
### ("_position" gs)))))))))
###                       ("_applC" ("_position" length) ("_position" gs))))
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1305 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f)
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" g)
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs))))
###                         ("_position" gs)))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append"
###               ("_applC" ("_position" map)
###                 ("_cargs"
###                   ("_lambda" ("_position" g)
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g) ("_position" xs))))
###                   ("_position" gs)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f)
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" g)
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs))))
###                         ("_position" gs)))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" g)
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs))))
###                     ("_position" gs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_position" arity)))
###                   ("_position" anything))))))
###         ("_cargs" ("_position" ap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs"
###                       ("_lambda" ("_position" g)
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g) ("_position" xs))))
###                       ("_position" gs)))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" f)
###                         ("_applC" ("_position" map)
###                           ("_cargs"
###                             ("_lambda" ("_position" g)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs" ("_position" g)
###                                   ("_position" xs))))
###                             ("_position" gs)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" fp)
###                           ("_applC" ("_position" Suc) ("_position" arity))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1310 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" xb) ("_position" xa)))
###                       ("_position" xc)))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" g) ("_position" xs)))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb)
###                             ("_applC" ("_position" Suc) ("_position" xa))))
###                         ("_position" xc)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" g) ("_applC" ("_position" set) ("_position" gs))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g) ("_position" xs)))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" xb) ("_position" xa)))
###                         ("_position" xc))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g) ("_position" xs)))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1314 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_position" n)
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Cn)
###                   ("_cargs" ("_position" n)
###                     ("_cargs" ("_position" f) ("_position" gs))))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything))))))
###     ("_cargs" ("_position" ap)
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Cn)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" gs))))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1329 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n) ("_position" ft)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n) ("_position" ft)))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_position" n)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_position" ft)
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" ft) ("_position" n)))
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1339 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" Suc) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc) ("_position" n))))
###                   ("_position" anything))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" Suc) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc) ("_position" n))))
###                   ("_position" anything))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###         ("_position" n)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_position" ft)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_position" n)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" f) ("_position" xs)))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" ft)
###                               ("_applC" ("_position" Suc) ("_position" n))))
###                           ("_position" anything))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1354 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_constrain"
###                             ("_Numeral" ("_constify" ("_position" 3)))
###                             ("_type_name" nat)))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("\<^const>Groups.plus_class.plus" ("_position" n)
###                         ("_Numeral" ("_constify" ("_position" 3))))
###                       ("_applC" ("_position" max)
###                         ("_cargs" ("_position" fft) ("_position" gft)))))
###                   ("_position" n)))
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_constrain"
###                             ("_Numeral" ("_constify" ("_position" 3)))
###                             ("_type_name" nat)))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_position" n)))
###                 ("_position" anything))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("\<^const>Groups.plus_class.plus" ("_position" n)
###                         ("_Numeral" ("_constify" ("_position" 3))))
###                       ("_applC" ("_position" max)
###                         ("_cargs" ("_position" fft) ("_position" gft)))))
###                   ("_position" n)))
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_constrain"
###                               ("_Numeral" ("_constify" ("_position" 3)))
###                               ("_type_name" nat)))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_position" n)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_cargs"
###             ("_applC" ("_position" max)
###               ("_cargs"
###                 ("\<^const>Groups.plus_class.plus" ("_position" n)
###                   ("_Numeral" ("_constify" ("_position" 3))))
###                 ("_applC" ("_position" max)
###                   ("_cargs" ("_position" fft) ("_position" gft)))))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_applC" ("_position" max)
###                             ("_cargs"
###                               ("\<^const>Groups.plus_class.plus"
###                                 ("_position" n)
###                                 ("_Numeral" ("_constify" ("_position" 3))))
###                               ("_applC" ("_position" max)
###                                 ("_cargs" ("_position" fft)
###                                   ("_position" gft)))))
###                           ("_position" n)))
###                       ("\<^const>List.list.Cons" ("_position" x)
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| max ?m ?n < length ?lm; ?m ~= ?n |]
==> {%nl. nl = ?lm} mv_box ?m ?n
    {%nl. nl = ?lm[?n := ?lm ! ?m + ?lm ! ?n, ?m := 0]}
### Ambiguous input (line 1391 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("\<^const>List.list.Cons" ("_position" x)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" Suc) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_Numeral" ("_constify" ("_position" 3))))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons" ("_position" x)
###                     ("_position" anything)))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("\<^const>List.list.Cons" ("_position" x)
###                   ("_position" anything)))))))
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" Suc) ("_position" n))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_Numeral" ("_constify" ("_position" 3))))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons" ("_position" x)
###                     ("_position" anything)))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_Numeral" ("_constify" ("_position" 3))))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_applC" ("_position" Suc) ("_position" n))))
###                   ("\<^const>List.list.Cons" ("_position" x)
###                     ("_position" anything))))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###             ("_Finset"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" f) ("_position" xs)))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_applC" ("_position" max)
###                                 ("_cargs"
###                                   ("\<^const>Groups.plus_class.plus"
###                                     ("_position" n)
###                                     ("_Numeral"
### ("_constify" ("_position" 3))))
###                                   ("_applC" ("_position" max)
###                                     ("_cargs" ("_position" fft)
### ("_position" gft)))))
###                               ("_applC" ("_position" Suc)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" n)))))
###                           ("\<^const>List.list.Cons" ("_position" x)
###                             ("_position" anything)))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1477 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" ft)
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("_Numeral" ("_constify" ("_position" 3))))
###             ("_applC" ("_position" max)
###               ("_cargs" ("_position" fft) ("_position" gft)))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("_applC" ("_position" Suc) ("_position" y)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list"
###                         ("\<^const>Groups.minus_class.minus" ("_position" x)
###                           ("_applC" ("_position" Suc) ("_position" y)))))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" Suc) ("_position" y))
###                     ("_position" anything))))))))
###       ("_list"
###         ("_applC" ("_position" Dec)
###           ("_cargs" ("_position" ft)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" length) ("_position" gap))
###               ("_Numeral" ("_constify" ("_position" 7)))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("_applC" ("_position" Suc) ("_position" y)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list"
###                         ("\<^const>Groups.minus_class.minus" ("_position" x)
###                           ("_applC" ("_position" Suc) ("_position" y)))))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("_position" anything)))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" ft)
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("_Numeral" ("_constify" ("_position" 3))))
###             ("_applC" ("_position" max)
###               ("_cargs" ("_position" fft) ("_position" gft)))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("_applC" ("_position" Suc) ("_position" y)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list"
###                         ("\<^const>Groups.minus_class.minus" ("_position" x)
###                           ("_applC" ("_position" Suc) ("_position" y)))))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" Suc) ("_position" y))
###                     ("_position" anything))))))))
###       ("_list"
###         ("_applC" ("_position" Dec)
###           ("_cargs" ("_position" ft)
###             ("\<^const>Groups.plus_class.plus"
###               ("_applC" ("_position" length) ("_position" gap))
###               ("_Numeral" ("_constify" ("_position" 7)))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("\<^const>Groups.minus_class.minus" ("_position" x)
###                 ("_applC" ("_position" Suc) ("_position" y)))
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list"
###                         ("\<^const>Groups.minus_class.minus" ("_position" x)
###                           ("_applC" ("_position" Suc) ("_position" y)))))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                       ("_applC" ("_position" Suc)
###                         ("_applC" ("_position" Suc) ("_position" n)))))
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("_position" anything)))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_position" ft)
###         ("_applC" ("_position" max)
###           ("_cargs"
###             ("\<^const>Groups.plus_class.plus" ("_position" n)
###               ("_Numeral" ("_constify" ("_position" 3))))
###             ("_applC" ("_position" max)
###               ("_cargs" ("_position" fft) ("_position" gft)))))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###           ("_position" n)))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("\<^const>Groups.minus_class.minus" ("_position" x)
###                   ("_applC" ("_position" Suc) ("_position" y)))
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list"
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" x)
###                             ("_applC" ("_position" Suc)
###                               ("_position" y)))))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" Suc) ("_position" n)))))
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" Suc) ("_position" y))
###                       ("_position" anything)))))))))
###       ("_cargs"
###         ("_list"
###           ("_applC" ("_position" Dec)
###             ("_cargs" ("_position" ft)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 7)))))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.minus_class.minus" ("_position" x)
###                     ("_applC" ("_position" Suc) ("_position" y)))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Pr)
###                           ("_cargs" ("_position" n)
###                             ("_cargs" ("_position" f) ("_position" g))))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" x)
###                               ("_applC" ("_position" Suc)
###                                 ("_position" y)))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" ft)
###                           ("_applC" ("_position" Suc)
###                             ("_applC" ("_position" Suc) ("_position" n)))))
###                       ("\<^const>List.list.Cons" ("_position" y)
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1495 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("_position" anything))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list" ("_applC" ("_position" Inc) ("_position" n)))
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 2)))))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Suc) ("_position" x))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("_position" anything))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list" ("_applC" ("_position" Inc) ("_position" n)))
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 2)))))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Suc) ("_position" x))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" x)
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("_position" anything)))))))
###         ("_list" ("_applC" ("_position" Inc) ("_position" n))))
###       ("_applC"
###         ("_list"
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 2)))))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.zero_class.zero"))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" Suc) ("_position" x))
###                   ("\<^const>List.list.Cons"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1537 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("_position" anything))))))
###       ("_list"
###         ("_args" ("_applC" ("_position" Inc) ("_position" n))
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 3)))))
###             ("_applC" ("_position" Goto)
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.zero_class.zero"))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Suc) ("_position" x))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("_position" anything))))))
###       ("_list"
###         ("_args" ("_applC" ("_position" Inc) ("_position" n))
###           ("_args"
###             ("_applC" ("_position" Dec)
###               ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                 ("_Numeral" ("_constify" ("_position" 3)))))
###             ("_applC" ("_position" Goto)
###               ("_applC" ("_position" Suc)
###                 ("\<^const>Groups.zero_class.zero"))))))
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" Suc) ("_position" x))
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("_position" anything)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq" ("_applC" ("_position" length) ("_position" xs))
###       ("_position" n)))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("_position" anything)))))))
###       ("_cargs"
###         ("_list"
###           ("_args" ("_applC" ("_position" Inc) ("_position" n))
###             ("_args"
###               ("_applC" ("_position" Dec)
###                 ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                   ("_Numeral" ("_constify" ("_position" 3)))))
###               ("_applC" ("_position" Goto)
###                 ("_applC" ("_position" Suc)
###                   ("\<^const>Groups.zero_class.zero"))))))
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" Suc) ("_position" x))
###                   ("\<^const>List.list.Cons"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1604 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Pr)
###                           ("_cargs" ("_position" n)
###                             ("_cargs" ("_position" f) ("_position" g))))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list" ("_position" y)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft) ("_position" gar)))
###                       ("_position" anything))))))))
###         ("_cargs" ("_position" gap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" Pr)
###                             ("_cargs" ("_position" n)
###                               ("_cargs" ("_position" f) ("_position" g))))
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" y)))))
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g)
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list"
###                                 ("_args" ("_position" y)
###                                   ("_applC" ("_position" rec_exec)
###                                     ("_cargs"
### ("_applC" ("_position" Pr)
###   ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
### ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" gft)
###                               ("_applC" ("_position" Suc)
###                                 ("_position" gar))))
###                           ("_position" anything))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1735 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Pr)
###                           ("_cargs" ("_position" n)
###                             ("_cargs" ("_position" f) ("_position" g))))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list" ("_position" y)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft) ("_position" gar)))
###                       ("_position" anything))))))))
###         ("_cargs" ("_position" gap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" Pr)
###                             ("_cargs" ("_position" n)
###                               ("_cargs" ("_position" f) ("_position" g))))
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" y)))))
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g)
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list"
###                                 ("_args" ("_position" y)
###                                   ("_applC" ("_position" rec_exec)
###                                     ("_cargs"
### ("_applC" ("_position" Pr)
###   ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
### ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" gft)
###                               ("_applC" ("_position" Suc)
###                                 ("_position" gar))))
###                           ("_position" anything))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1737 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("\<^const>Groups.minus_class.minus" ("_position" x)
###               ("_position" y))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list"
###                       ("\<^const>Groups.minus_class.minus" ("_position" x)
###                         ("_position" y))))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))))
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("_position" anything))))))))
###     ("\<^const>List.append"
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("\<^const>Groups.plus_class.plus" ("_position" n)
###                     ("_Numeral" ("_constify" ("_position" 3))))
###                   ("_applC" ("_position" max)
###                     ("_cargs" ("_position" fft) ("_position" gft)))))
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 7)))))))
###         ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###           ("_list"
###             ("_args" ("_applC" ("_position" Inc) ("_position" n))
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                     ("_Numeral" ("_constify" ("_position" 3)))))
###                 ("_applC" ("_position" Goto)
###                   ("_applC" ("_position" Suc)
###                     ("\<^const>Groups.zero_class.zero"))))))))
###       ("_list"
###         ("_args"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" Suc) ("_position" n)))
###               ("\<^const>Groups.zero_class.zero")))
###           ("_args"
###             ("_applC" ("_position" Inc)
###               ("_applC" ("_position" Suc) ("_position" n)))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 4)))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("\<^const>Groups.minus_class.minus" ("_position" x)
###               ("_position" y))
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list"
###                       ("\<^const>Groups.minus_class.minus" ("_position" x)
###                         ("_position" y))))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))))
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("_position" anything))))))))
###     ("\<^const>List.append"
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("\<^const>Groups.plus_class.plus" ("_position" n)
###                     ("_Numeral" ("_constify" ("_position" 3))))
###                   ("_applC" ("_position" max)
###                     ("_cargs" ("_position" fft) ("_position" gft)))))
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 7)))))))
###         ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###           ("_list"
###             ("_args" ("_applC" ("_position" Inc) ("_position" n))
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                     ("_Numeral" ("_constify" ("_position" 3)))))
###                 ("_applC" ("_position" Goto)
###                   ("_applC" ("_position" Suc)
###                     ("\<^const>Groups.zero_class.zero"))))))))
###       ("_list"
###         ("_args"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" Suc) ("_position" n)))
###               ("\<^const>Groups.zero_class.zero")))
###           ("_args"
###             ("_applC" ("_position" Inc)
###               ("_applC" ("_position" Suc) ("_position" n)))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 4)))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.append"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("\<^const>Groups.minus_class.minus" ("_position" x)
###                   ("_position" y))
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list"
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" x) ("_position" y))))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus"
###                         ("_applC" ("_position" max)
###                           ("_cargs"
###                             ("\<^const>Groups.plus_class.plus"
###                               ("_position" n)
###                               ("_Numeral" ("_constify" ("_position" 3))))
###                             ("_applC" ("_position" max)
###                               ("_cargs" ("_position" fft)
###                                 ("_position" gft)))))
###                         ("_applC" ("_position" Suc)
###                           ("_applC" ("_position" Suc) ("_position" n)))))
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("_position" anything)))))))))
###       ("\<^const>Abacus_Hoare.abc_comp"
###         ("_list"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" max)
###                 ("_cargs"
###                   ("\<^const>Groups.plus_class.plus" ("_position" n)
###                     ("_Numeral" ("_constify" ("_position" 3))))
###                   ("_applC" ("_position" max)
###                     ("_cargs" ("_position" fft) ("_position" gft)))))
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 7)))))))
###         ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###           ("_list"
###             ("_args" ("_applC" ("_position" Inc) ("_position" n))
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" n))
###                     ("_Numeral" ("_constify" ("_position" 3)))))
###                 ("_applC" ("_position" Goto)
###                   ("_applC" ("_position" Suc)
###                     ("\<^const>Groups.zero_class.zero")))))))))
###     ("_applC"
###       ("_list"
###         ("_args"
###           ("_applC" ("_position" Dec)
###             ("_cargs"
###               ("_applC" ("_position" Suc)
###                 ("_applC" ("_position" Suc) ("_position" n)))
###               ("\<^const>Groups.zero_class.zero")))
###           ("_args"
###             ("_applC" ("_position" Inc)
###               ("_applC" ("_position" Suc) ("_position" n)))
###             ("_applC" ("_position" Goto)
###               ("\<^const>Groups.plus_class.plus"
###                 ("_applC" ("_position" length) ("_position" gap))
###                 ("_Numeral" ("_constify" ("_position" 4))))))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" x)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus"
###                         ("_applC" ("_position" max)
###                           ("_cargs"
###                             ("\<^const>Groups.plus_class.plus"
###                               ("_position" n)
###                               ("_Numeral" ("_constify" ("_position" 3))))
###                             ("_applC" ("_position" max)
###                               ("_cargs" ("_position" fft)
###                                 ("_position" gft)))))
###                         ("_applC" ("_position" Suc) ("_position" n))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1785 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" y)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("_applC" ("_position" Pr)
###                           ("_cargs" ("_position" n)
###                             ("_cargs" ("_position" f) ("_position" g))))
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list" ("_position" y)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft) ("_position" gar)))
###                       ("_position" anything))))))))
###         ("_cargs" ("_position" gap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" y)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs"
###                           ("_applC" ("_position" Pr)
###                             ("_cargs" ("_position" n)
###                               ("_cargs" ("_position" f) ("_position" g))))
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" y)))))
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs" ("_position" g)
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list"
###                                 ("_args" ("_position" y)
###                                   ("_applC" ("_position" rec_exec)
###                                     ("_cargs"
### ("_applC" ("_position" Pr)
###   ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
### ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" gft)
###                               ("_applC" ("_position" Suc)
###                                 ("_position" gar))))
###                           ("_position" anything))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" anything)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                         ("_position" gar)))
###                     ("_position" anything)))))))
###         ("_position" gap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" y)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" y)))))
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" g)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list"
###                             ("_args" ("_position" y)
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs"
###                                   ("_applC" ("_position" Pr)
###                                     ("_cargs" ("_position" n)
### ("_cargs" ("_position" f) ("_position" g))))
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" y))))))))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" gft)
###                           ("_applC" ("_position" Suc) ("_position" gar))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1788 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                   ("_position" far)))
###               ("_position" anything)))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_applC" ("_position" Suc) ("_position" far))))
###                 ("_position" anything)))))))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                   ("_position" far)))
###               ("_position" anything)))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" xs)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_applC" ("_position" Suc) ("_position" far))))
###                 ("_position" anything)))))))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" fap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f) ("_position" xs)))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1793 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("\<^const>Groups.plus_class.plus" ("_position" n)
###                         ("_Numeral" ("_constify" ("_position" 3))))
###                       ("_applC" ("_position" max)
###                         ("_cargs" ("_position" fft) ("_position" gft)))))
###                   ("_position" n)))
###               ("_position" anything))))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_box)
###             ("_cargs" ("_position" n)
###               ("_applC" ("_position" Suc) ("_position" n))))
###           ("\<^const>List.append"
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_list"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 7)))))))
###               ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###                 ("_list"
###                   ("_args" ("_applC" ("_position" Inc) ("_position" n))
###                     ("_args"
###                       ("_applC" ("_position" Dec)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc) ("_position" n))
###                           ("_Numeral" ("_constify" ("_position" 3)))))
###                       ("_applC" ("_position" Goto)
###                         ("_applC" ("_position" Suc)
###                           ("\<^const>Groups.zero_class.zero"))))))))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))
###                     ("\<^const>Groups.zero_class.zero")))
###                 ("_args"
###                   ("_applC" ("_position" Inc)
###                     ("_applC" ("_position" Suc) ("_position" n)))
###                   ("_applC" ("_position" Goto)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 4))))))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("\<^const>Groups.plus_class.plus" ("_position" n)
###                         ("_Numeral" ("_constify" ("_position" 3))))
###                       ("_applC" ("_position" max)
###                         ("_cargs" ("_position" fft) ("_position" gft)))))
###                   ("_position" n)))
###               ("_position" anything))))))
###     ("\<^const>Abacus_Hoare.abc_comp"
###       ("_applC" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft)))))))
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_box)
###             ("_cargs" ("_position" n)
###               ("_applC" ("_position" Suc) ("_position" n))))
###           ("\<^const>List.append"
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_list"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 7)))))))
###               ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###                 ("_list"
###                   ("_args" ("_applC" ("_position" Inc) ("_position" n))
###                     ("_args"
###                       ("_applC" ("_position" Dec)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc) ("_position" n))
###                           ("_Numeral" ("_constify" ("_position" 3)))))
###                       ("_applC" ("_position" Goto)
###                         ("_applC" ("_position" Suc)
###                           ("\<^const>Groups.zero_class.zero"))))))))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))
###                     ("\<^const>Groups.zero_class.zero")))
###                 ("_args"
###                   ("_applC" ("_position" Inc)
###                     ("_applC" ("_position" Suc) ("_position" n)))
###                   ("_applC" ("_position" Goto)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 4))))))))))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("_applC" ("_position" Suc) ("_position" n))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_comp"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("\<^const>Groups.plus_class.plus" ("_position" n)
###                             ("_Numeral" ("_constify" ("_position" 3))))
###                           ("_applC" ("_position" max)
###                             ("_cargs" ("_position" fft)
###                               ("_position" gft)))))
###                       ("_position" n)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" mv_box)
###         ("_cargs" ("_position" n)
###           ("_applC" ("_position" max)
###             ("_cargs"
###               ("\<^const>Groups.plus_class.plus" ("_position" n)
###                 ("_Numeral" ("_constify" ("_position" 3))))
###               ("_applC" ("_position" max)
###                 ("_cargs" ("_position" fft) ("_position" gft))))))))
###     ("_applC"
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" fap)
###         ("\<^const>Abacus_Hoare.abc_comp"
###           ("_applC" ("_position" mv_box)
###             ("_cargs" ("_position" n)
###               ("_applC" ("_position" Suc) ("_position" n))))
###           ("\<^const>List.append"
###             ("\<^const>Abacus_Hoare.abc_comp"
###               ("_list"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("\<^const>Groups.plus_class.plus" ("_position" n)
###                           ("_Numeral" ("_constify" ("_position" 3))))
###                         ("_applC" ("_position" max)
###                           ("_cargs" ("_position" fft) ("_position" gft)))))
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 7)))))))
###               ("\<^const>Abacus_Hoare.abc_comp" ("_position" gap)
###                 ("_list"
###                   ("_args" ("_applC" ("_position" Inc) ("_position" n))
###                     ("_args"
###                       ("_applC" ("_position" Dec)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc) ("_position" n))
###                           ("_Numeral" ("_constify" ("_position" 3)))))
###                       ("_applC" ("_position" Goto)
###                         ("_applC" ("_position" Suc)
###                           ("\<^const>Groups.zero_class.zero"))))))))
###             ("_list"
###               ("_args"
###                 ("_applC" ("_position" Dec)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" Suc) ("_position" n)))
###                     ("\<^const>Groups.zero_class.zero")))
###                 ("_args"
###                   ("_applC" ("_position" Inc)
###                     ("_applC" ("_position" Suc) ("_position" n)))
###                   ("_applC" ("_position" Goto)
###                     ("\<^const>Groups.plus_class.plus"
###                       ("_applC" ("_position" length) ("_position" gap))
###                       ("_Numeral" ("_constify" ("_position" 4)))))))))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" x)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus"
###                         ("_applC" ("_position" max)
###                           ("_cargs"
###                             ("\<^const>Groups.plus_class.plus"
###                               ("_position" n)
###                               ("_Numeral" ("_constify" ("_position" 3))))
###                             ("_applC" ("_position" max)
###                               ("_cargs" ("_position" fft)
###                                 ("_position" gft)))))
###                         ("_applC" ("_position" Suc) ("_position" n))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1854 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list"
###               ("_args" ("_position" y)
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" y))))))))))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Turing_Hoare.Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Pr)
###                               ("_cargs" ("_position" n)
###                                 ("_cargs" ("_position" f) ("_position" g))))
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list" ("_position" y)))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" xb) ("_position" xa)))
###                           ("_position" xc)))))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Pr)
###                               ("_cargs" ("_position" n)
###                                 ("_cargs" ("_position" f) ("_position" g))))
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list" ("_position" y)))))
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g)
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list"
###                                   ("_args" ("_position" y)
###                                     ("_applC" ("_position" rec_exec)
### ("_cargs"
###   ("_applC" ("_position" Pr)
###     ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list"
###               ("_args" ("_position" y)
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" y))))))))))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Pr)
###                               ("_cargs" ("_position" n)
###                                 ("_cargs" ("_position" f) ("_position" g))))
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list" ("_position" y)))))
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" xb) ("_position" xa)))
###                           ("_position" xc)))))))
###               ("_position" x)
###               ("_lambda" ("_position" nl)
###                 ("\<^const>HOL.eq" ("_position" nl)
###                   ("\<^const>List.append" ("_position" xs)
###                     ("\<^const>List.list.Cons" ("_position" y)
###                       ("\<^const>List.list.Cons"
###                         ("_applC" ("_position" rec_exec)
###                           ("_cargs"
###                             ("_applC" ("_position" Pr)
###                               ("_cargs" ("_position" n)
###                                 ("_cargs" ("_position" f) ("_position" g))))
###                             ("\<^const>List.append" ("_position" xs)
###                               ("_list" ("_position" y)))))
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" g)
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list"
###                                   ("_args" ("_position" y)
###                                     ("_applC" ("_position" rec_exec)
### ("_cargs"
###   ("_applC" ("_position" Pr)
###     ("_cargs" ("_position" n) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>List.append" ("_position" xs) ("_list" ("_position" y))))))))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" y) ("_position" x)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" g)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list"
###               ("_args" ("_position" y)
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Pr)
###                       ("_cargs" ("_position" n)
###                         ("_cargs" ("_position" f) ("_position" g))))
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" y))))))))))
###       ("\<^const>HOL.All_binder"
###         ("_idts" ("_position" x)
###           ("_idts" ("_position" xa) ("_position" xb)))
###         ("\<^const>HOL.implies"
###           ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" g))
###             ("_tuple" ("_position" x)
###               ("_tuple_args" ("_position" xa)
###                 ("_tuple_arg" ("_position" xb)))))
###           ("\<^const>HOL.All_binder" ("_position" xc)
###             ("_applC"
###               ("_Finset"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" y)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs"
###                               ("_applC" ("_position" Pr)
###                                 ("_cargs" ("_position" n)
###                                   ("_cargs" ("_position" f)
###                                     ("_position" g))))
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list" ("_position" y)))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb) ("_position" xa)))
###                             ("_position" xc))))))))
###               ("_cargs" ("_position" x)
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons" ("_position" y)
###                           ("\<^const>List.list.Cons"
###                             ("_applC" ("_position" rec_exec)
###                               ("_cargs"
###                                 ("_applC" ("_position" Pr)
###                                   ("_cargs" ("_position" n)
###                                     ("_cargs" ("_position" f)
### ("_position" g))))
###                                 ("\<^const>List.append" ("_position" xs)
###                                   ("_list" ("_position" y)))))
###                             ("\<^const>List.list.Cons"
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs" ("_position" g)
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list"
### ("_args" ("_position" y)
###   ("_applC" ("_position" rec_exec)
###     ("_cargs"
###       ("_applC" ("_position" Pr)
###         ("_cargs" ("_position" n)
###           ("_cargs" ("_position" f) ("_position" g))))
###       ("\<^const>List.append" ("_position" xs)
###         ("_list" ("_position" y))))))))))
###                               ("\<^const>List.append"
###                                 ("\<^const>Turing.exponent"
###                                   ("\<^const>Groups.zero_class.zero")
###                                   ("\<^const>Groups.minus_class.minus"
###                                     ("_position" xb)
###                                     ("_applC" ("_position" Suc)
### ("_position" xa))))
###                                 ("_position" xc)))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1860 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f) ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_position" arity)))
###                   ("_position" anything))))))
###         ("_cargs" ("_position" ap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" f) ("_position" xs)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" fp)
###                           ("_applC" ("_position" Suc) ("_position" arity))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1864 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything))))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything))))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons" ("_position" x)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs"
###                   ("_applC" ("_position" Pr)
###                     ("_cargs" ("_position" n)
###                       ("_cargs" ("_position" f) ("_position" g))))
###                   ("\<^const>List.append" ("_position" xs)
###                     ("_list" ("_position" x)))))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything)))))))
###     ("_cargs" ("_position" ap)
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs"
###                       ("_applC" ("_position" Pr)
###                         ("_cargs" ("_position" n)
###                           ("_cargs" ("_position" f) ("_position" g))))
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" x)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 2014 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm1)))
###       ("_position" p)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_position" stp)
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" abc_steps_l)
###           ("_cargs"
###             ("_tuple" ("\<^const>Groups.zero_class.zero")
###               ("_tuple_arg" ("_position" lm1)))
###             ("_cargs" ("_position" p) ("_position" stp))))
###         ("_tuple" ("_applC" ("_position" length) ("_position" p))
###           ("_tuple_arg" ("_position" lm2)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm1)))
###       ("_position" p)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" lm2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_position" stp)
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" abc_steps_l)
###           ("_cargs"
###             ("_tuple" ("\<^const>Groups.zero_class.zero")
###               ("_tuple_arg" ("_position" lm1)))
###             ("_cargs" ("_position" p) ("_position" stp))))
###         ("_tuple" ("_applC" ("_position" length) ("_position" p))
###           ("_tuple_arg" ("_position" lm2)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl) ("_position" lm1))))
###       ("_cargs" ("_position" p)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl) ("_position" lm2)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.Ex_binder" ("_position" stp)
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" abc_steps_l)
###           ("_cargs"
###             ("_tuple" ("\<^const>Groups.zero_class.zero")
###               ("_tuple_arg" ("_position" lm1)))
###             ("_cargs" ("_position" p) ("_position" stp))))
###         ("_tuple" ("_applC" ("_position" length) ("_position" p))
###           ("_tuple_arg" ("_position" lm2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2023 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_position" xc)
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" xc))))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" x)))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" xc))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_position" xc)
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" xc))))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" x)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs" ("_position" f)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("_list" ("_position" x)))))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" xc))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.All_binder" ("_position" xc)
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" x)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc)))))))
###       ("_cargs" ("_position" fap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" x)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs" ("_position" f)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("_list" ("_position" x)))))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" fft)
###                           ("_applC" ("_position" Suc) ("_position" far))))
###                       ("_position" xc))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2078 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" i)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_position" far)))
###                     ("_position" xc)))))))
###         ("_cargs" ("_position" fap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" i)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" f)
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" i)))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" fft)
###                             ("_applC" ("_position" Suc) ("_position" far))))
###                         ("_position" xc)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2115 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less_eq" ("_position" i) ("_position" x)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" i)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_position" far)))
###                     ("_position" xc)))))))
###         ("_cargs" ("_position" fap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" i)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" f)
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" i)))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" fft)
###                             ("_applC" ("_position" Suc) ("_position" far))))
###                         ("_position" xc)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2135 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" anything))))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                     ("_position" far)))
###                 ("_position" anything))))))
###       ("_position" fap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.list.Cons" ("_position" r)
###               ("\<^const>List.list.Cons" ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_applC" ("_position" Suc) ("_position" far))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" anything)))))))
###       ("_cargs" ("_position" fap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.list.Cons"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" fft)
###                           ("_applC" ("_position" Suc) ("_position" far))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2137 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                       ("_position" far)))
###                   ("_position" xc))))))
###         ("_position" fap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" i)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("_list" ("_position" i)))))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_applC" ("_position" Suc) ("_position" far))))
###                     ("_position" xc)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.All_binder" ("_position" xc)
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" i)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fft)
###                         ("_position" far)))
###                     ("_position" xc)))))))
###         ("_cargs" ("_position" fap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" i)
###                     ("\<^const>List.list.Cons"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" f)
###                           ("\<^const>List.append" ("_position" xs)
###                             ("_list" ("_position" i)))))
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" fft)
###                             ("_applC" ("_position" Suc) ("_position" far))))
###                         ("_position" xc)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2142 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" arity))
###                     ("_position" fft)))
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("\<^const>List.append" ("_position" fap) ("_position" B))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Mn)
###                   ("_cargs" ("_position" arity) ("_position" f)))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc) ("_position" arity))
###                       ("_position" fft)))
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs" ("_applC" ("_position" Suc) ("_position" arity))
###                     ("_position" fft)))
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("\<^const>List.append" ("_position" fap) ("_position" B))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Mn)
###                   ("_cargs" ("_position" arity) ("_position" f)))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus"
###                   ("_applC" ("_position" max)
###                     ("_cargs"
###                       ("_applC" ("_position" Suc) ("_position" arity))
###                       ("_position" fft)))
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>List.append"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus"
###                     ("_applC" ("_position" max)
###                       ("_cargs"
###                         ("_applC" ("_position" Suc) ("_position" arity))
###                         ("_position" fft)))
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_position" fap))
###     ("_applC" ("_position" B)
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Mn)
###                       ("_cargs" ("_position" arity) ("_position" f)))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus"
###                       ("_applC" ("_position" max)
###                         ("_cargs"
###                           ("_applC" ("_position" Suc) ("_position" arity))
###                           ("_position" fft)))
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
[| ?P ?a; !!x. ?P x ==> x = ?a |] ==> (THE x. ?P x) = ?a
### Ambiguous input (line 2202 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_position" arity)))
###                   ("_position" anything))))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_position" arity)))
###                   ("_position" anything))))))
###         ("_position" ap)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons" ("_position" r)
###                 ("\<^const>List.list.Cons"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" ap)
###     ("_idts" ("_position" arity)
###       ("_idts" ("_position" fp) ("_position" anything))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq" ("_applC" ("_position" rec_ci) ("_position" f))
###         ("_tuple" ("_position" ap)
###           ("_tuple_args" ("_position" arity)
###             ("_tuple_arg" ("_position" fp))))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" xs)
###                 ("\<^const>List.list.Cons" ("_position" r)
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_position" arity)))
###                     ("_position" anything)))))))
###         ("_cargs" ("_position" ap)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" xs)
###                   ("\<^const>List.list.Cons" ("_position" r)
###                     ("\<^const>List.list.Cons"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>List.append"
###                         ("\<^const>Turing.exponent"
###                           ("\<^const>Groups.zero_class.zero")
###                           ("\<^const>Groups.minus_class.minus"
###                             ("_position" fp)
###                             ("_applC" ("_position" Suc)
###                               ("_position" arity))))
###                         ("_position" anything)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2206 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" f)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list" ("_position" i)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" x)
###             ("_idts" ("_position" xa) ("_position" xb)))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_ci) ("_position" f))
###               ("_tuple" ("_position" x)
###                 ("_tuple_args" ("_position" xa)
###                   ("_tuple_arg" ("_position" xb)))))
###             ("\<^const>HOL.All_binder" ("_position" xc)
###               ("\<^const>Turing_Hoare.Hoare_halt"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" i)
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" xb) ("_position" xa)))
###                           ("_position" xc))))))
###                 ("_position" x)
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" i)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" f)
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list" ("_position" i)))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))
###         ("\<^const>Orderings.ord_class.less"
###           ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" f)
###               ("\<^const>List.append" ("_position" xs)
###                 ("_list" ("_position" i))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" f)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list" ("_position" i)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" x)
###             ("_idts" ("_position" xa) ("_position" xb)))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_ci) ("_position" f))
###               ("_tuple" ("_position" x)
###                 ("_tuple_args" ("_position" xa)
###                   ("_tuple_arg" ("_position" xb)))))
###             ("\<^const>HOL.All_binder" ("_position" xc)
###               ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" i)
###                         ("\<^const>List.append"
###                           ("\<^const>Turing.exponent"
###                             ("\<^const>Groups.zero_class.zero")
###                             ("\<^const>Groups.minus_class.minus"
###                               ("_position" xb) ("_position" xa)))
###                           ("_position" xc))))))
###                 ("_position" x)
###                 ("_lambda" ("_position" nl)
###                   ("\<^const>HOL.eq" ("_position" nl)
###                     ("\<^const>List.append" ("_position" xs)
###                       ("\<^const>List.list.Cons" ("_position" i)
###                         ("\<^const>List.list.Cons"
###                           ("_applC" ("_position" rec_exec)
###                             ("_cargs" ("_position" f)
###                               ("\<^const>List.append" ("_position" xs)
###                                 ("_list" ("_position" i)))))
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb)
###                                 ("_applC" ("_position" Suc)
###                                   ("_position" xa))))
###                             ("_position" xc)))))))))))
###         ("\<^const>Orderings.ord_class.less"
###           ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" f)
###               ("\<^const>List.append" ("_position" xs)
###                 ("_list" ("_position" i))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_All_less" ("_position" i) ("_position" r)
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" f)
###           ("\<^const>List.append" ("_position" xs)
###             ("_list" ("_position" i)))))
###       ("\<^const>HOL.conj"
###         ("\<^const>HOL.All_binder"
###           ("_idts" ("_position" x)
###             ("_idts" ("_position" xa) ("_position" xb)))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.eq"
###               ("_applC" ("_position" rec_ci) ("_position" f))
###               ("_tuple" ("_position" x)
###                 ("_tuple_args" ("_position" xa)
###                   ("_tuple_arg" ("_position" xb)))))
###             ("\<^const>HOL.All_binder" ("_position" xc)
###               ("_applC"
###                 ("_Finset"
###                   ("_lambda" ("_position" nl)
###                     ("\<^const>HOL.eq" ("_position" nl)
###                       ("\<^const>List.append" ("_position" xs)
###                         ("\<^const>List.list.Cons" ("_position" i)
###                           ("\<^const>List.append"
###                             ("\<^const>Turing.exponent"
###                               ("\<^const>Groups.zero_class.zero")
###                               ("\<^const>Groups.minus_class.minus"
###                                 ("_position" xb) ("_position" xa)))
###                             ("_position" xc)))))))
###                 ("_cargs" ("_position" x)
###                   ("_Finset"
###                     ("_lambda" ("_position" nl)
###                       ("\<^const>HOL.eq" ("_position" nl)
###                         ("\<^const>List.append" ("_position" xs)
###                           ("\<^const>List.list.Cons" ("_position" i)
###                             ("\<^const>List.list.Cons"
###                               ("_applC" ("_position" rec_exec)
###                                 ("_cargs" ("_position" f)
###                                   ("\<^const>List.append" ("_position" xs)
###                                     ("_list" ("_position" i)))))
###                               ("\<^const>List.append"
###                                 ("\<^const>Turing.exponent"
###                                   ("\<^const>Groups.zero_class.zero")
###                                   ("\<^const>Groups.minus_class.minus"
###                                     ("_position" xb)
###                                     ("_applC" ("_position" Suc)
### ("_position" xa))))
###                                 ("_position" xc)))))))))))))
###         ("\<^const>Orderings.ord_class.less"
###           ("\<^const>Groups.zero_class.zero")
###           ("_applC" ("_position" rec_exec)
###             ("_cargs" ("_position" f)
###               ("\<^const>List.append" ("_position" xs)
###                 ("_list" ("_position" i))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2211 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Mn)
###                   ("_cargs" ("_position" n) ("_position" f)))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                 ("_position" arity)))
###             ("_position" anything)))))
###     ("_position" ap)
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" xs)
###           ("\<^const>List.list.Cons"
###             ("_applC" ("_position" rec_exec)
###               ("_cargs"
###                 ("_applC" ("_position" Mn)
###                   ("_cargs" ("_position" n) ("_position" f)))
###                 ("_position" xs)))
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_applC" ("_position" Suc) ("_position" arity))))
###               ("_position" anything))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" xs)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything))))))
###     ("_cargs" ("_position" ap)
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" xs)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("_applC" ("_position" Mn)
###                       ("_cargs" ("_position" n) ("_position" f)))
###                     ("_position" xs)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                       ("_applC" ("_position" Suc) ("_position" arity))))
###                   ("_position" anything))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2234 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" recf) ("_position" args))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_ci) ("_position" recf))
###           ("_tuple" ("_position" ap)
###             ("_tuple_args" ("_position" arity)
###               ("_tuple_arg" ("_position" fp))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" recf) ("_position" args)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" recf) ("_position" args))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_ci) ("_position" recf))
###           ("_tuple" ("_position" ap)
###             ("_tuple_args" ("_position" arity)
###               ("_tuple_arg" ("_position" fp))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                   ("_position" arity)))
###               ("_position" anything)))))
###       ("_position" ap)
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" recf) ("_position" args)))
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_applC" ("_position" Suc) ("_position" arity))))
###                 ("_position" anything)))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" terminate)
###         ("_cargs" ("_position" recf) ("_position" args))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.eq"
###           ("_applC" ("_position" rec_ci) ("_position" recf))
###           ("_tuple" ("_position" ap)
###             ("_tuple_args" ("_position" arity)
###               ("_tuple_arg" ("_position" fp))))))))
###   ("\<^const>HOL.Trueprop"
###     ("_applC"
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                     ("_position" arity)))
###                 ("_position" anything))))))
###       ("_cargs" ("_position" ap)
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" args)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" recf) ("_position" args)))
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent"
###                       ("\<^const>Groups.zero_class.zero")
###                       ("\<^const>Groups.minus_class.minus" ("_position" fp)
###                         ("_applC" ("_position" Suc) ("_position" arity))))
###                     ("_position" anything)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2402 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl) ("_position" args)))
###     ("\<^const>Abacus_Hoare.abc_comp" ("_position" ap)
###       ("_applC" ("_position" dummy_abc)
###         ("_applC" ("_position" length) ("_position" args))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.Ex_binder" ("_position" m)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" args)))
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" m)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl) ("_position" args)))
###     ("\<^const>Abacus_Hoare.abc_comp" ("_position" ap)
###       ("_applC" ("_position" dummy_abc)
###         ("_applC" ("_position" length) ("_position" args))))
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.Ex_binder" ("_position" m)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.list.Cons"
###               ("_applC" ("_position" rec_exec)
###                 ("_cargs" ("_position" f) ("_position" args)))
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero") ("_position" m)))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl) ("_position" args))))
###     ("_cargs"
###       ("\<^const>Abacus_Hoare.abc_comp" ("_position" ap)
###         ("_applC" ("_position" dummy_abc)
###           ("_applC" ("_position" length) ("_position" args))))
###       ("_Finset"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.Ex_binder" ("_position" m)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" args)
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" f) ("_position" args)))
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("_position" m)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2435 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                   ("_position" gar)))
###               ("_position" anything)))))
###       ("_position" gap))))
### ("\<^const>Pure.all_binder" ("_position" anything)
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("\<^const>List.append" ("_position" args)
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent"
###                 ("\<^const>Groups.zero_class.zero")
###                 ("\<^const>Groups.minus_class.minus" ("_position" gft)
###                   ("_position" gar)))
###               ("_position" anything)))))
###       ("_position" gap))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2436 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" apj)
###     ("_idts" ("_position" arj)
###       ("_idts" ("_position" ftj)
###         ("_idts" ("_position" j) ("_position" anything)))))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_position" i)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("\<^const>List.nth" ("_position" gs) ("_position" j)))
###             ("_tuple" ("_position" apj)
###               ("_tuple_args" ("_position" arj)
###                 ("_tuple_arg" ("_position" ftj))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Turing_Hoare.Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                     ("_position" arj)))
###                 ("_position" anything)))))
###         ("_position" apj)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("\<^const>List.nth" ("_position" gs) ("_position" j))
###                     ("_position" args)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                       ("_applC" ("_position" Suc) ("_position" arj))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" apj)
###     ("_idts" ("_position" arj)
###       ("_idts" ("_position" ftj)
###         ("_idts" ("_position" j) ("_position" anything)))))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_position" i)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("\<^const>List.nth" ("_position" gs) ("_position" j)))
###             ("_tuple" ("_position" apj)
###               ("_tuple_args" ("_position" arj)
###                 ("_tuple_arg" ("_position" ftj))))))))
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent"
###                   ("\<^const>Groups.zero_class.zero")
###                   ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                     ("_position" arj)))
###                 ("_position" anything)))))
###         ("_position" apj)
###         ("_lambda" ("_position" nl)
###           ("\<^const>HOL.eq" ("_position" nl)
###             ("\<^const>List.append" ("_position" args)
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" rec_exec)
###                   ("_cargs"
###                     ("\<^const>List.nth" ("_position" gs) ("_position" j))
###                     ("_position" args)))
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                       ("_applC" ("_position" Suc) ("_position" arj))))
###                   ("_position" anything))))))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" apj)
###     ("_idts" ("_position" arj)
###       ("_idts" ("_position" ftj)
###         ("_idts" ("_position" j) ("_position" anything)))))
###   ("_bigimpl"
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_position" i)))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci)
###               ("\<^const>List.nth" ("_position" gs) ("_position" j)))
###             ("_tuple" ("_position" apj)
###               ("_tuple_args" ("_position" arj)
###                 ("_tuple_arg" ("_position" ftj))))))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC"
###         ("_Finset"
###           ("_lambda" ("_position" nl)
###             ("\<^const>HOL.eq" ("_position" nl)
###               ("\<^const>List.append" ("_position" args)
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent"
###                     ("\<^const>Groups.zero_class.zero")
###                     ("\<^const>Groups.minus_class.minus" ("_position" ftj)
###                       ("_position" arj)))
###                   ("_position" anything))))))
###         ("_cargs" ("_position" apj)
###           ("_Finset"
###             ("_lambda" ("_position" nl)
###               ("\<^const>HOL.eq" ("_position" nl)
###                 ("\<^const>List.append" ("_position" args)
###                   ("\<^const>List.list.Cons"
###                     ("_applC" ("_position" rec_exec)
###                       ("_cargs"
###                         ("\<^const>List.nth" ("_position" gs)
###                           ("_position" j))
###                         ("_position" args)))
###                     ("\<^const>List.append"
###                       ("\<^const>Turing.exponent"
###                         ("\<^const>Groups.zero_class.zero")
###                         ("\<^const>Groups.minus_class.minus"
###                           ("_position" ftj)
###                           ("_applC" ("_position" Suc) ("_position" arj))))
###                       ("_position" anything))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2439 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_position" ar)))
###             ("_position" anything)))))
###     ("_position" ap)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_position" ar)))
###             ("_position" anything)))))
###     ("_position" ap)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2488 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" args)))
###                     ("_position" c)))
###                 ("_applC" ("_position" length) ("_position" args))))
###             ("_position" anything)))))
###     ("\<^const>List.append" ("_position" a) ("_position" B))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus"
###                 ("_applC" ("_position" max)
###                   ("_cargs"
###                     ("_applC" ("_position" Suc)
###                       ("_applC" ("_position" length) ("_position" args)))
###                     ("_position" c)))
###                 ("_applC" ("_position" length) ("_position" args))))
###             ("_position" anything)))))
###     ("\<^const>List.append" ("_position" a) ("_position" B))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2528 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_position" ar)))
###             ("_position" anything)))))
###     ("_position" ap)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append" ("_position" args)
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" ft)
###                 ("_position" ar)))
###             ("_position" anything)))))
###     ("_position" ap)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
### Ambiguous input (line 2576 of "$AFP/Universal_Turing_Machine/Recursive.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("_list" ("_args" ("_position" Bk) ("_position" Bk)))
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_applC" ("_position" tm_of_rec) ("_position" recf))
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" k) ("_position" l))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" k))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" recf) ("_position" args))))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" l))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("_list" ("_args" ("_position" Bk) ("_position" Bk)))
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_applC" ("_position" tm_of_rec) ("_position" recf))
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" k) ("_position" l))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" k))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.tape_class.tape_of"
###                   ("_applC" ("_position" rec_exec)
###                     ("_cargs" ("_position" recf) ("_position" args))))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" l))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" tp)
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple" ("_list" ("_args" ("_position" Bk) ("_position" Bk)))
###             ("_tuple_arg"
###               ("\<^const>Turing.tape_class.tape_of" ("_position" args)))))))
###     ("_cargs" ("_applC" ("_position" tm_of_rec) ("_position" recf))
###       ("_Finset"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" k) ("_position" l))
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))
###                 ("_tuple_arg"
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.tape_class.tape_of"
###                       ("_applC" ("_position" rec_exec)
###                         ("_cargs" ("_position" recf) ("_position" args))))
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" l))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Recursive"
### 8.663s elapsed time, 18.862s cpu time, 0.910s GC time
Loading theory "Draft.UTM" (required by "Draft.UTMMoreTemplates")
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### wcode_on_right_moving_1 ?ires1 ?rs1 (?l1, ?r1) ==
### EX ml mr rn.
###    ?l1 = Bk \<up> ml @ Oc # ?ires1 &
###    ?r1 = Bk \<up> mr @ Oc \<up> Suc ?rs1 @ Bk \<up> rn & Suc 0 < ml + mr
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### fetch ?p1 0 ?b1 == (Nop, 0)
### Rewrite rule not in simpset:
### fetch ?p1 (Suc ?s1) Bk ==
### case nth_of ?p1 (2 * ?s1) of None => (Nop, 0) | Some i => i
### Rewrite rule not in simpset:
### fetch ?p1 (Suc ?s1) Oc ==
### case nth_of ?p1 (2 * ?s1 + 1) of None => (Nop, 0) | Some i => i
### Rewrite rule not in simpset:
### start_of ?ly1 ?x1 == Suc (sum_list (take ?x1 ?ly1))
[| rec_ci ?recf = (?ap, ?ary, ?fp); terminate ?recf ?args;
   ?tp = tm_of (?ap [+] dummy_abc (length ?args)) |]
==> EX stp m l.
       steps0 (Suc 0, Bk # Bk # ?ires, <?args> @ Bk \<up> ?rn)
        (?tp @ shift (mopup (length ?args)) (length ?tp div 2)) stp =
       (0, Bk \<up> m @ Bk # Bk # ?ires,
        Oc \<up> Suc (rec_exec ?recf ?args) @ Bk \<up> l)
### Rewrite rule not in simpset:
### adjust ?p1 ?e1 == map (%(a, s). (a, if s = 0 then ?e1 else s)) ?p1
### Rewrite rule not in simpset:
### tm_wf (?p1, ?off1) ==
### 2 <= length ?p1 &
### is_even (length ?p1) &
### (ALL (a, s):set ?p1. s <= length ?p1 div 2 + ?off1 & ?off1 <= s)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
[| rec_ci ?recf = (?ap, ?ary, ?fp); terminate ?recf ?args;
   ?tp = tm_of (?ap [+] dummy_abc (length ?args)) |]
==> EX stp m l.
       steps0 (Suc 0, Bk # Bk # ?ires, <?args> @ Bk \<up> ?rn)
        (?tp @ shift (mopup (length ?args)) (length ?tp div 2)) stp =
       (0, Bk \<up> m @ Bk # Bk # ?ires,
        Oc \<up> Suc (rec_exec ?recf ?args) @ Bk \<up> l)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### ?p1.1 |+| ?p2.1 == adjust0 ?p1.1 @ shift ?p2.1 (length ?p1.1 div 2)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Rewrite rule not in simpset:
### 2 == Suc (Suc 0)
### Ambiguous input (line 3995 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing.tm_comp"
###     ("\<^const>HOL.eq" ("_position" t_wcode)
###       ("\<^const>Turing.tm_comp" ("_position" t_wcode_prepare)
###         ("_position" t_wcode_main)))
###     ("_position" t_wcode_adjust)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" t_wcode)
###     ("\<^const>Turing.tm_comp"
###       ("\<^const>Turing.tm_comp" ("_position" t_wcode_prepare)
###         ("_position" t_wcode_main))
###       ("_position" t_wcode_adjust))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4046 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing.tm_comp"
###     ("\<^const>HOL.eq" ("_position" UTM_pre) ("_position" t_wcode))
###     ("_position" t_utm)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" UTM_pre)
###     ("\<^const>Turing.tm_comp" ("_position" t_wcode) ("_position" t_utm))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4359 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("_list"
###             ("_args" ("_applC" ("_position" code) ("_position" tp))
###               ("_applC" ("_position" bl2wc)
###                 ("\<^const>Turing.tape_class.tape_of" ("_position" lm)))))
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" a_md)
###                 ("_position" rs_pos)))
###             ("_position" suflm)))))
###     ("_position" F_ap)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" nl)
###       ("\<^const>HOL.eq" ("_position" nl)
###         ("\<^const>List.append"
###           ("_list"
###             ("_args" ("_applC" ("_position" code) ("_position" tp))
###               ("_applC" ("_position" bl2wc)
###                 ("\<^const>Turing.tape_class.tape_of" ("_position" lm)))))
###           ("\<^const>List.append"
###             ("\<^const>Turing.exponent" ("\<^const>Groups.zero_class.zero")
###               ("\<^const>Groups.minus_class.minus" ("_position" a_md)
###                 ("_position" rs_pos)))
###             ("_position" suflm)))))
###     ("_position" F_ap)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4441 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" tm_wf)
###         ("_tuple" ("_position" tp)
###           ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.All_binder" ("_position" stp)
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" TSTD)
###               ("_applC" ("_position" steps0)
###                 ("_cargs"
###                   ("_tuple"
###                     ("_applC" ("_position" Suc)
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("_tuple_args"
###                       ("\<^const>Turing.exponent" ("_position" Bk)
###                         ("_position" l))
###                       ("_tuple_arg"
###                         ("\<^const>Turing.tape_class.tape_of"
###                           ("_position" lm)))))
###                   ("_cargs" ("_position" tp) ("_position" stp))))))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci) ("_position" rec_F))
###             ("_tuple" ("_position" ap)
###               ("_tuple_args" ("_position" pos)
###                 ("_tuple_arg" ("_position" md)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("_list"
###             ("_args" ("_applC" ("_position" code) ("_position" tp))
###               ("_applC" ("_position" bl2wc)
###                 ("\<^const>Turing.tape_class.tape_of" ("_position" lm)))))))
###       ("_position" ap))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" tm_wf)
###         ("_tuple" ("_position" tp)
###           ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))))
###     ("_asms"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.All_binder" ("_position" stp)
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" TSTD)
###               ("_applC" ("_position" steps0)
###                 ("_cargs"
###                   ("_tuple"
###                     ("_applC" ("_position" Suc)
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("_tuple_args"
###                       ("\<^const>Turing.exponent" ("_position" Bk)
###                         ("_position" l))
###                       ("_tuple_arg"
###                         ("\<^const>Turing.tape_class.tape_of"
###                           ("_position" lm)))))
###                   ("_cargs" ("_position" tp) ("_position" stp))))))))
###       ("_asm"
###         ("\<^const>HOL.Trueprop"
###           ("\<^const>HOL.eq"
###             ("_applC" ("_position" rec_ci) ("_position" rec_F))
###             ("_tuple" ("_position" ap)
###               ("_tuple_args" ("_position" pos)
###                 ("_tuple_arg" ("_position" md)))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("_list"
###             ("_args" ("_applC" ("_position" code) ("_position" tp))
###               ("_applC" ("_position" bl2wc)
###                 ("\<^const>Turing.tape_class.tape_of" ("_position" lm)))))))
###       ("_position" ap))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4472 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" tm_wf)
###         ("_tuple" ("_position" tp)
###           ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.All_binder" ("_position" stp)
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" TSTD)
###               ("_applC" ("_position" steps0)
###                 ("_cargs"
###                   ("_tuple"
###                     ("_applC" ("_position" Suc)
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("_tuple_args"
###                       ("\<^const>Turing.exponent" ("_position" Bk)
###                         ("_position" l))
###                       ("_tuple_arg"
###                         ("\<^const>Turing.tape_class.tape_of"
###                           ("_position" lm)))))
###                   ("_cargs" ("_position" tp) ("_position" stp))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Turing_Hoare.Hoare_unhalt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("_list"
###             ("_args" ("_applC" ("_position" code) ("_position" tp))
###               ("_applC" ("_position" bl2wc)
###                 ("\<^const>Turing.tape_class.tape_of" ("_position" lm)))))))
###       ("_position" F_aprog))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" tm_wf)
###         ("_tuple" ("_position" tp)
###           ("_tuple_arg" ("\<^const>Groups.zero_class.zero")))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>HOL.All_binder" ("_position" stp)
###           ("\<^const>HOL.Not"
###             ("_applC" ("_position" TSTD)
###               ("_applC" ("_position" steps0)
###                 ("_cargs"
###                   ("_tuple"
###                     ("_applC" ("_position" Suc)
###                       ("\<^const>Groups.zero_class.zero"))
###                     ("_tuple_args"
###                       ("\<^const>Turing.exponent" ("_position" Bk)
###                         ("_position" l))
###                       ("_tuple_arg"
###                         ("\<^const>Turing.tape_class.tape_of"
###                           ("_position" lm)))))
###                   ("_cargs" ("_position" tp) ("_position" stp))))))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###       ("_lambda" ("_position" nl)
###         ("\<^const>HOL.eq" ("_position" nl)
###           ("_list"
###             ("_args" ("_applC" ("_position" code) ("_position" tp))
###               ("_applC" ("_position" bl2wc)
###                 ("\<^const>Turing.tape_class.tape_of" ("_position" lm)))))))
###       ("_position" F_aprog))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4615 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" tp)
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" i))
###             ("_tuple_arg"
###               ("\<^const>Turing.tape_class.tape_of" ("_position" args)))))))
###     ("_cargs" ("_position" p)
###       ("_Finset"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.eq" ("_position" tp)
###             ("_tuple"
###               ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###               ("_tuple_arg"
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.exponent" ("_position" Oc)
###                     ("_position" rs))
###                   ("\<^const>Turing.exponent" ("_position" Bk)
###                     ("_position" k)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple"
###           ("\<^const>Turing.exponent" ("_position" Bk) ("_position" i))
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_position" p)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple"
###           ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###           ("_tuple_arg"
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent" ("_position" Oc) ("_position" rs))
###               ("\<^const>Turing.exponent" ("_position" Bk)
###                 ("_position" k)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple"
###           ("\<^const>Turing.exponent" ("_position" Bk) ("_position" i))
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_position" p)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple"
###           ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###           ("_tuple_arg"
###             ("\<^const>List.append"
###               ("\<^const>Turing.exponent" ("_position" Oc) ("_position" rs))
###               ("\<^const>Turing.exponent" ("_position" Bk)
###                 ("_position" k)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4616 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" tp)
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple" ("\<^const>List.list.Nil")
###             ("_tuple_arg"
###               ("\<^const>Turing.tape_class.tape_of"
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" code) ("_position" p))
###                   ("_position" args))))))))
###     ("_cargs" ("_position" UTM)
###       ("_Finset"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" m) ("_position" n))
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" m))
###                 ("_tuple_arg"
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.exponent" ("_position" Oc)
###                       ("_position" rs))
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" n))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of"
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" code) ("_position" p))
###                 ("_position" args)))))))
###     ("_position" UTM)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" m) ("_position" n))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent" ("_position" Oc)
###                   ("_position" rs))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" n))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of"
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" code) ("_position" p))
###                 ("_position" args)))))))
###     ("_position" UTM)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" m) ("_position" n))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.exponent" ("_position" Oc)
###                   ("_position" rs))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" n))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4676 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" tp)
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple" ("\<^const>List.list.Nil")
###             ("_tuple_arg"
###               ("\<^const>Turing.tape_class.tape_of" ("_position" args)))))))
###     ("_cargs" ("_position" p)
###       ("_Finset"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.eq" ("_position" tp)
###             ("_tuple"
###               ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###               ("_tuple_arg"
###                 ("\<^const>List.append"
###                   ("\<^const>Turing.tape_class.tape_of"
###                     ("_constrain" ("_position" n) ("_type_name" nat)))
###                   ("\<^const>Turing.exponent" ("_position" Bk)
###                     ("_position" k)))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_position" p)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple"
###           ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###           ("_tuple_arg"
###             ("\<^const>List.append"
###               ("\<^const>Turing.tape_class.tape_of"
###                 ("_constrain" ("_position" n) ("_type_name" nat)))
###               ("\<^const>Turing.exponent" ("_position" Bk)
###                 ("_position" k)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_position" p)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple"
###           ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###           ("_tuple_arg"
###             ("\<^const>List.append"
###               ("\<^const>Turing.tape_class.tape_of"
###                 ("_constrain" ("_position" n) ("_type_name" nat)))
###               ("\<^const>Turing.exponent" ("_position" Bk)
###                 ("_position" k)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4677 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_applC"
###     ("_Finset"
###       ("_lambda" ("_position" tp)
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple" ("\<^const>List.list.Nil")
###             ("_tuple_arg"
###               ("\<^const>Turing.tape_class.tape_of"
###                 ("\<^const>List.list.Cons"
###                   ("_applC" ("_position" code) ("_position" p))
###                   ("_position" args))))))))
###     ("_cargs" ("_position" UTM)
###       ("_Finset"
###         ("_lambda" ("_position" tp)
###           ("\<^const>HOL.Ex_binder"
###             ("_idts" ("_position" m) ("_position" k))
###             ("\<^const>HOL.eq" ("_position" tp)
###               ("_tuple"
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" m))
###                 ("_tuple_arg"
###                   ("\<^const>List.append"
###                     ("\<^const>Turing.tape_class.tape_of" ("_position" n))
###                     ("\<^const>Turing.exponent" ("_position" Bk)
###                       ("_position" k))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of"
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" code) ("_position" p))
###                 ("_position" args)))))))
###     ("_position" UTM)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" m) ("_position" k))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.tape_class.tape_of" ("_position" n))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_halt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of"
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" code) ("_position" p))
###                 ("_position" args)))))))
###     ("_position" UTM)
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.Ex_binder" ("_idts" ("_position" m) ("_position" k))
###         ("\<^const>HOL.eq" ("_position" tp)
###           ("_tuple"
###             ("\<^const>Turing.exponent" ("_position" Bk) ("_position" m))
###             ("_tuple_arg"
###               ("\<^const>List.append"
###                 ("\<^const>Turing.tape_class.tape_of" ("_position" n))
###                 ("\<^const>Turing.exponent" ("_position" Bk)
###                   ("_position" k))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4684 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple"
###           ("\<^const>Turing.exponent" ("_position" Bk) ("_position" i))
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_position" p)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple"
###           ("\<^const>Turing.exponent" ("_position" Bk) ("_position" i))
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_position" p)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4686 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of"
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" code) ("_position" p))
###                 ("_position" args)))))))
###     ("_position" UTM)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of"
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" code) ("_position" p))
###                 ("_position" args)))))))
###     ("_position" UTM)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4699 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_position" p)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of" ("_position" args))))))
###     ("_position" p)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 4701 of "$AFP/Universal_Turing_Machine/UTM.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Turing_Hoare.Hoare_unhalt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of"
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" code) ("_position" p))
###                 ("_position" args)))))))
###     ("_position" UTM)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Abacus_Hoare.abc_Hoare_unhalt"
###     ("_lambda" ("_position" tp)
###       ("\<^const>HOL.eq" ("_position" tp)
###         ("_tuple" ("\<^const>List.list.Nil")
###           ("_tuple_arg"
###             ("\<^const>Turing.tape_class.tape_of"
###               ("\<^const>List.list.Cons"
###                 ("_applC" ("_position" code) ("_position" p))
###                 ("_position" args)))))))
###     ("_position" UTM)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.UTM"
### 6.211s elapsed time, 6.694s cpu time, 0.673s GC time
Loading theory "Draft.UTMMoreTemplates"
val templateLemmas =
   [("UTM.bin_wc_eq", "bl_bin ?xs = bl2wc ?xs",
     template_equation
      (template_app (template_hole 1, template_var 0),
       template_app (template_hole 0, template_var 0))),
    ("UTM.tape_of_nat", "<?a> = Oc \<up> Suc ?a",
     template_equation
      (template_app (template_hole 3, template_var 0),
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_hole 0))),
    ("UTM.tape_of_nl_rev", "rev (<?lm>) = <rev ?lm>",
     template_equation
      (template_app
        (template_hole 2, template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)))),
    ("UTM.wadjust_nonempty",
     "wadjust_backto_standard_pos ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_loop_on_left_moving_snd_nonempty",
     "wadjust_erase2 ?m ?rs ([], []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 1), template_var 0),
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_nonempty",
     "wadjust_goon_left_moving ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_loop_check_empty_false",
     "wadjust_loop_check ?m ?rs ([], ?b) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_var 0)),
       template_hole 0)),
    ("UTM.wadjust_loop_erase_nonempty_snd",
     "wadjust_loop_erase ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_loop_on_left_moving_snd_nonempty",
     "wadjust_loop_on_left_moving ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_loop_right_move_nonempty_snd",
     "wadjust_loop_right_move ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_loop_on_left_moving_snd_nonempty",
     "wadjust_loop_right_move2 ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_loop_start_snd_nonempty",
     "wadjust_loop_start ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_on_left_moving_nonempty",
     "wadjust_on_left_moving ?m ?rs ([], []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 1), template_var 0),
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_on_left_moving_nonempty",
     "wadjust_on_left_moving_O ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wadjust_start_snd_nonempty",
     "wadjust_start ?m ?rs (?c, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wcode_backto_standard_pos_nonempty_snd",
     "wcode_backto_standard_pos ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.nonempty_snd",
     "wcode_backto_standard_pos_2 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wcode_erase1_nonempty_snd",
     "wcode_erase1 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.nonempty_snd", "wcode_erase2 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.nonempty_snd", "wcode_goon_checking ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wcode_3_nonempty",
     "wcode_goon_checking_3 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wcode_on_checking_1_simp",
     "wcode_on_checking_1 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.nonempty_snd", "wcode_on_checking_2 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wcode_3_nonempty",
     "wcode_on_checking_3 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wcode_on_left_moving_1",
     "wcode_on_left_moving_1 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.nonempty_snd",
     "wcode_on_left_moving_2 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wcode_3_nonempty",
     "wcode_on_left_moving_3 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wcode_on_right_moving_1_nonempty_snd",
     "wcode_on_right_moving_1 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.nonempty_snd",
     "wcode_on_right_moving_2 ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.nonempty_snd", "wcode_right_move ?ires ?rs (?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_hole 1)),
       template_hole 0)),
    ("UTM.exp_1", "?a \<up> Suc 0 = [?a]",
     template_equation
      (template_app
        (template_app
          (template_hole 4,
           template_app (template_hole 3, template_hole 2)),
         template_var 0),
       template_app
        (template_app (template_hole 1, template_var 0), template_hole 0))),
    ("UTM.tinres_commute", "tinres ?r ?r' ==> tinres ?r' ?r",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 0, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 0), template_var 1)
           ))),
    ("UTM.mopup_mod2", "is_even (length (mopup ?k))",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_hole 5,
             template_app (template_hole 4, template_var 0))),
         template_app
          (template_hole 3,
           template_app (template_hole 2, template_hole 1))),
       template_hole 0)),
    ("UTM.tinres_empty", "tinres [] ?r' ==> tinres [] (tl ?r')",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_hole 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_app (template_hole 0, template_var 0))
           ))),
    ("UTM.wadjust_backto_standard_pos_B_no_Oc",
     "wadjust_backto_standard_pos_B ?m ?rs (?c, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_backto_standard_pos_O_no_Bk",
     "wadjust_backto_standard_pos_O ?m ?rs (?c, Bk # ?xs) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_goon_left_moving_B_no_Oc",
     "wadjust_goon_left_moving_B ?m ?rs (?c, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_goon_left_moving_O_no_Bk",
     "wadjust_goon_left_moving_O ?m ?rs (?c, Bk # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_loop_on_move_no_Oc",
     "wadjust_loop_on_left_moving_B ?m ?rs (?c, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_loop_erase_nonempty",
     "wadjust_loop_on_left_moving_O ?m ?rs (?c, Bk # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_loop_on_move_no_Oc",
     "wadjust_loop_right_move2 ?m ?rs (?c, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_loop_start_no_Bk",
     "wadjust_loop_start ?m ?rs (?c, Bk # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_loop_on_move_no_Oc",
     "wadjust_on_left_moving_B ?m ?rs (?c, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wadjust_loop_erase_nonempty",
     "wadjust_on_left_moving_O ?m ?rs (?c, Bk # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wcode_backto_standard_pos_no_Oc",
     "wcode_backto_standard_pos ?ires ?rs ([], Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 5, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 4, template_hole 3),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.nonempty_fst",
     "wcode_goon_checking ?ires ?rs (?b, Bk # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wcode_3_nonempty",
     "wcode_goon_checking_3 ?ires ?rs (?b, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wcode_on_checking_1_simp",
     "wcode_on_checking_1 ?ires ?rs (?b, Bk # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.nonempty_snd",
     "wcode_on_checking_2 ?ires ?rs (?b, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wcode_3_nonempty",
     "wcode_on_checking_3 ?ires ?rs (?b, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wcode_right_move_no_Oc",
     "wcode_right_move ?ires ?rs (?b, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wprepare_loop_goon_in_middle_Bk_False",
     "wprepare_loop_goon_in_middle ?m ?lm (Bk # ?b, []) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 5, template_var 2), template_var 1),
         template_app
          (template_app
            (template_hole 4,
             template_app
              (template_app (template_hole 3, template_hole 2),
               template_var 0)),
           template_hole 1)),
       template_hole 0)),
    ("UTM.wprepare_loop_goon_on_rightmost_Oc_False",
     "wprepare_loop_goon_on_rightmost ?m ?lm (?b, Oc # ?list) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_var 0))),
       template_hole 0)),
    ("UTM.wprepare_loop_start_in_middle_Bk_False",
     "wprepare_loop_start_in_middle ?m ?lm (?b, [Bk]) = False",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 5, template_var 2), template_var 1),
         template_app
          (template_app (template_hole 4, template_var 0),
           template_app
            (template_app (template_hole 3, template_hole 2),
             template_hole 1))),
       template_hole 0)),
    ("UTM.tinres_tails", "tinres ?r ?r' ==> tinres (tl ?r) (tl ?r')",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 1, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 1)),
             template_app (template_hole 0, template_var 0))
           ))),
    ("UTM.rev_eq", "rev ?xs = rev ?ys ==> ?xs = ?ys",
     template_implication
      ([template_equation
         (template_app (template_hole 0, template_var 1),
          template_app (template_hole 0, template_var 0))],
       template_equation (template_var 1, template_var 0))),
    ("UTM.twice_lemma", "rec_exec rec_twice [?rs] = 2 * ?rs",
     template_equation
      (template_app
        (template_app (template_hole 7, template_hole 6),
         template_app
          (template_app (template_hole 5, template_var 0),
           template_hole 4)),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app (template_hole 1, template_hole 0))),
         template_var 0))),
    ("UTM.bl_bin_nonzero", "?args ~= [] ==> 0 < bl_bin (<?args>)",
     template_implication
      ([template_negation
         (template_equation (template_var 0, template_hole 4))],
       template_inequation
        (less_than, template_hole 2,
         template_app
          (template_hole 1,
           template_app (template_hole 0, template_var 0))))),
    ("UTM.fourtimes_lemma", "rec_exec rec_fourtimes [?rs] = 4 * ?rs",
     template_equation
      (template_app
        (template_app (template_hole 7, template_hole 6),
         template_app
          (template_app (template_hole 5, template_var 0),
           template_hole 4)),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app
              (template_hole 1,
               template_app (template_hole 1, template_hole 0)))),
         template_var 0))),
    ("UTM.Bk_not_tape_start", "(Bk # ?list = <?m # ?lm> @ ?ys) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_hole 4),
             template_var 3)),
         template_app
          (template_app
            (template_hole 3,
             template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_var 1))),
           template_var 0)),
       template_hole 0)),
    ("UTM.nstd_case1", "0 < ?a ==> NSTD (trpl_code (?a, ?b, ?c))",
     template_implication
      ([template_inequation (less_than, template_hole 4, template_var 2)],
       template_predicate
        (
           template_app
            (template_hole 3,
             template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_app
                  (template_app (template_hole 0, template_var 1),
                   template_var 0))))
           ))),
    ("UTM.tinres_nonempty", "tinres ?r ?r' ==> tinres (?b # ?r) (?b # ?r')",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 1, template_var 2),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 0),
                 template_var 2)),
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 1))
           ))),
    ("UTM.wadjust_loop_erase_nonempty",
     "wadjust_goon_left_moving ?m ?rs (?c, ?b) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wadjust_loop_check_fst_nonempty",
     "wadjust_loop_check ?m ?rs (?c, []) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 3, template_var 0),
                template_hole 2))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 2)))),
    ("UTM.wadjust_loop_check_nonempty",
     "wadjust_loop_check ?m ?rs (?c, ?b) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wadjust_loop_erase_nonempty",
     "wadjust_loop_erase ?m ?rs (?c, ?b) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wadjust_loop_erase_nonempty",
     "wadjust_loop_on_left_moving ?m ?rs (?c, ?b) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wadjust_loop_right_move_fst_nonempty",
     "wadjust_loop_right_move ?m ?rs (?c, []) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 3, template_var 0),
                template_hole 2))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 2)))),
    ("UTM.wadjust_loop_erase_nonempty",
     "wadjust_loop_right_move2 ?m ?rs (?c, ?b) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wadjust_loop_erase_nonempty",
     "wadjust_on_left_moving ?m ?rs (?c, ?b) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_goon_right_moving_2 ?ires ?rs (?b, []) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 3, template_var 0),
                template_hole 2))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 2)))),
    ("UTM.wcode_on_left_moving_1",
     "wcode_on_left_moving_1 ?ires ?rs (?b, ?r) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_add_one2_nonempty_fst",
     "wprepare_add_one2 ?m ?lm (?b, []) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 3, template_var 0),
                template_hole 2))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 2)))),
    ("UTM.wprepare_loop_start_b_nonempty",
     "wprepare_loop_start ?m ?lm (?b, ?aa) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.leading_Oc", "EX xs. <rev ?list @ [?aa]> = Oc # xs",
     template_predicate (template_app (template_hole 8, t_empty))),
    ("UTM.bl2nat_zero_eq", "(bl2nat ?c 0 = 0) = (EX n. ?c = Bk \<up> n)",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_var 0),
             template_hole 4)),
         template_hole 4),
       template_app (template_hole 3, t_empty))),
    ("UTM.tinres_empty", "tinres ?r [] ==> tinres (Bk # tl ?r) [Bk]",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 0),
              template_hole 3)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 2, template_hole 1),
                 template_app (template_hole 0, template_var 0))),
             template_app
              (template_app (template_hole 2, template_hole 1),
               template_hole 3))
           ))),
    ("UTM.tinres_empty", "tinres ?r [] ==> tinres (Oc # tl ?r) [Oc]",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 0),
              template_hole 3)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 2, template_hole 1),
                 template_app (template_hole 0, template_var 0))),
             template_app
              (template_app (template_hole 2, template_hole 1),
               template_hole 3))
           ))),
    ("UTM.wprepare_add_one_nonempty_snd",
     "?lm ~= [] ==> wprepare_add_one ?m ?lm (?b, []) = False",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 5))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 3, template_var 1),
             template_var 2),
           template_app
            (template_app (template_hole 2, template_var 0),
             template_hole 1)),
         template_hole 0))),
    ("UTM.wprepare_erase_nonempty_snd",
     "?lm ~= [] ==> wprepare_erase ?m ?lm (?b, []) = False",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 5))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 3, template_var 1),
             template_var 2),
           template_app
            (template_app (template_hole 2, template_var 0),
             template_hole 1)),
         template_hole 0))),
    ("UTM.wprepare_goto_first_end_nonempty_snd",
     "?lm ~= [] ==> wprepare_goto_first_end ?m ?lm (?b, []) = False",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 5))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 3, template_var 1),
             template_var 2),
           template_app
            (template_app (template_hole 2, template_var 0),
             template_hole 1)),
         template_hole 0))),
    ("UTM.wprepare_goto_start_pos_nonempty_snd",
     "?lm ~= [] ==> wprepare_goto_start_pos ?m ?lm (?b, []) = False",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 5))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 3, template_var 1),
             template_var 2),
           template_app
            (template_app (template_hole 2, template_var 0),
             template_hole 1)),
         template_hole 0))),
    ("UTM.nonzero_bl2wc", "ALL m. ?b ~= Bk \<up> m ==> 0 < bl2wc ?b",
     template_implication
      ([template_predicate (template_app (template_hole 7, t_empty))],
       template_inequation
        (less_than, template_hole 1,
         template_app (template_hole 0, template_var 0)))),
    ("UTM.wadjust_loop_erase_nonempty",
     "wadjust_erase2 ?m ?rs (?c, Bk # ?list) ==> ?c ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_backto_standard_pos_2 ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_backto_standard_pos_2 ?ires ?rs (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_erase2 ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_erase2 ?ires ?rs (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_goon_right_moving_2 ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_goon_right_moving_2 ?ires ?rs (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_on_checking_2 ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wcode_3_nonempty",
     "wcode_on_checking_3 ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_on_left_moving_2 ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_on_left_moving_2 ?ires ?rs (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wcode_3_nonempty",
     "wcode_on_left_moving_3 ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wcode_3_nonempty",
     "wcode_on_left_moving_3 ?ires ?rs (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_on_right_moving_2 ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_on_right_moving_2 ?ires ?rs (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.nonempty_fst",
     "wcode_right_move ?ires ?rs (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_add_one_Bk_nonempty_snd",
     "wprepare_add_one ?m ?lm (?b, Bk # ?list) ==> ?list ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 0)))),
    ("UTM.wprepare_add_one2_nonempty",
     "wprepare_add_one2 ?m ?lm (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_add_one2_Oc_nonempty",
     "wprepare_add_one2 ?m ?lm (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_erase_Bk_nonempty_fst",
     "wprepare_erase ?m ?lm (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_erase_nonempty",
     "wprepare_erase ?m ?lm (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_goto_first_end_Bk_nonempty_fst",
     "wprepare_goto_first_end ?m ?lm (?b, Bk # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_goto_start_pos_Oc_nonempty",
     "wprepare_goto_start_pos ?m ?lm (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_loop_goon_Oc_nonempty",
     "wprepare_loop_goon ?m ?lm (?b, Oc # ?list) ==> ?b ~= []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.mn_arity", "rec_ci (Mn ?n ?f) = (?a, ?b, ?c) ==> ?b = ?n",
     template_implication
      ([template_equation
         (template_app
           (template_hole 4,
            template_app
             (template_app (template_hole 3, template_var 4),
              template_var 3)),
          template_app
           (template_app (template_hole 2, template_var 2),
            template_app
             (template_app (template_hole 1, template_var 1),
              template_var 0)))],
       template_equation (template_var 1, template_var 4))),
    ("UTM.even_not_odd", "Suc (2 * ?x) = 2 * ?y ==> ?RR",
     template_implication
      ([template_equation
         (template_app
           (template_hole 4,
            template_app
             (template_app
               (template_hole 3,
                template_app
                 (template_hole 2,
                  template_app (template_hole 1, template_hole 0))),
              template_var 2)),
          template_app
           (template_app
             (template_hole 3,
              template_app
               (template_hole 2,
                template_app (template_hole 1, template_hole 0))),
            template_var 1))],
       template_predicate (template_var 0))),
    ("UTM.tinres_nonempty",
     "[| tinres [] ?r'; ?r' ~= [] |] ==> hd ?r' = Bk",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_hole 5),
              template_var 0)
            ),
        template_negation
         (template_equation (template_var 0, template_hole 5))],
       template_equation
        (template_app (template_hole 1, template_var 0), template_hole 0))),
    ("UTM.tinres_nonempty", "[| tinres ?r []; ?r ~= [] |] ==> hd ?r = Bk",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 0),
              template_hole 5)
            ),
        template_negation
         (template_equation (template_var 0, template_hole 5))],
       template_equation
        (template_app (template_hole 1, template_var 0), template_hole 0))),
    ("UTM.tinres_nonempty",
     "[| tinres ?r []; ?r ~= [] |] ==> tinres (tl ?r) []",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 0),
              template_hole 3)
            ),
        template_negation
         (template_equation (template_var 0, template_hole 3))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app (template_hole 0, template_var 0)),
             template_hole 3)
           ))),
    ("UTM.wcode_backto_standard_pos_2_empty_via_right",
     "wcode_goon_right_moving_2 ?ires ?rs (?b, []) ==>
      wcode_backto_standard_pos_2 ?ires ?rs (?b, [Oc])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 4, template_var 0),
                template_hole 3))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 2),
               template_var 1),
             template_app
              (template_app (template_hole 4, template_var 0),
               template_app
                (template_app (template_hole 1, template_hole 0),
                 template_hole 3)))
           ))),
    ("UTM.wprepare_add_one2_Oc",
     "wprepare_add_one2 ?m ?lm (?b, []) ==>
      wprepare_add_one2 ?m ?lm (?b, [Oc])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 3, template_var 0),
                template_hole 2))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_var 2),
               template_var 1),
             template_app
              (template_app (template_hole 3, template_var 0),
               template_app
                (template_app (template_hole 1, template_hole 0),
                 template_hole 2)))
           ))),
    ("UTM.cn_arity", "rec_ci (Cn ?n ?f ?gs) = (?a, ?b, ?c) ==> ?b = ?n",
     template_implication
      ([template_equation
         (template_app
           (template_hole 4,
            template_app
             (template_app
               (template_app (template_hole 3, template_var 5),
                template_var 4),
              template_var 3)),
          template_app
           (template_app (template_hole 2, template_var 2),
            template_app
             (template_app (template_hole 1, template_var 1),
              template_var 0)))],
       template_equation (template_var 1, template_var 5))),
    ("UTM.length_2_elems",
     "length (<?aa # ?a # ?list>) = Suc (Suc ?aa) + length (<?a # ?list>)",
     template_equation
      (template_app
        (template_hole 4,
         template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_app
              (template_app (template_hole 2, template_var 1),
               template_var 0)))),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_hole 0,
             template_app (template_hole 0, template_var 2))),
         template_app
          (template_hole 4,
           template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 2, template_var 1),
               template_var 0)))))),
    ("UTM.dropWhile_exp1",
     "dropWhile (%a. a = Oc) (Oc \<up> ?n @ ?xs) =
      dropWhile (%a. a = Oc) ?xs",
     template_equation
      (template_app
        (template_app (template_hole 4, t_empty),
         template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 1),
               template_hole 2)),
           template_var 0)),
       template_app
        (template_app (template_hole 4, t_empty), template_var 0))),
    ("UTM.nstd_case2",
     "ALL m. ?b ~= Bk \<up> m ==> NSTD (trpl_code (?a, ?b, ?c))",
     template_implication
      ([template_predicate (template_app (template_hole 8, t_empty))],
       template_predicate
        (
           template_app
            (template_hole 3,
             template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_app
                  (template_app (template_hole 0, template_var 2),
                   template_var 0))))
           ))),
    ("UTM.tape_of_nl_app_Suc",
     "<?list @ [Suc ?ab]> = <?list @ [?ab]> @ [Oc]",
     template_equation
      (template_app
        (template_hole 8,
         template_app
          (template_app (template_hole 7, template_var 1),
           template_app
            (template_app
              (template_hole 6,
               template_app (template_hole 5, template_var 0)),
             template_hole 4))),
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_hole 8,
             template_app
              (template_app (template_hole 7, template_var 1),
               template_app
                (template_app (template_hole 6, template_var 0),
                 template_hole 4)))),
         template_app
          (template_app (template_hole 2, template_hole 1),
           template_hole 0)))),
    ("UTM.wadjust_erase2_singleton",
     "wadjust_loop_check ?m ?rs (?c, []) ==>
      wadjust_erase2 ?m ?rs (tl ?c, [hd ?c])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 5, template_var 0),
                template_hole 4))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 2),
               template_var 1),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 2, template_var 0)),
               template_app
                (template_app
                  (template_hole 1,
                   template_app (template_hole 0, template_var 0)),
                 template_hole 4)))
           ))),
    ("UTM.wadjust_stop_Bk",
     "wadjust_backto_standard_pos ?m ?rs (?c, Bk # ?list) ==>
      wadjust_stop ?m ?rs (Bk # ?c, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.erase2_Bk_if_Oc",
     "wadjust_erase2 ?m ?rs (?c, Oc # ?list) ==>
      wadjust_erase2 ?m ?rs (?c, Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_app
                (template_app (template_hole 2, template_hole 0),
                 template_var 0)))
           ))),
    ("UTM.wadjust_loop_on_move_no_Oc",
     "wadjust_loop_erase ?m ?rs (?c, Oc # ?list) ==>
      wadjust_loop_erase ?m ?rs (?c, Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_app
                (template_app (template_hole 2, template_hole 0),
                 template_var 0)))
           ))),
    ("UTM.wadjust_loop_on_move_no_Oc",
     "wadjust_loop_on_left_moving ?m ?rs (?c, Oc # ?list) ==>
      wadjust_loop_right_move2 ?m ?rs (Oc # ?c, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wadjust_loop_right_move_Bk",
     "wadjust_loop_right_move ?m ?rs (?c, Bk # ?list) ==>
      wadjust_loop_right_move ?m ?rs (Bk # ?c, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 2, template_var 1),
                template_app
                 (template_app (template_hole 1, template_hole 0),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wadjust_loop_check_Oc",
     "wadjust_loop_right_move ?m ?rs (?c, Oc # ?list) ==>
      wadjust_loop_check ?m ?rs (Oc # ?c, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wadjust_loop_start_Oc_via_Bk_move",
     "wadjust_loop_right_move2 ?m ?rs (?c, Bk # ?list) ==>
      wadjust_loop_start ?m ?rs (?c, Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 4, template_var 1),
               template_app
                (template_app (template_hole 3, template_hole 0),
                 template_var 0)))
           ))),
    ("UTM.wadjust_loop_right_move_Oc",
     "wadjust_loop_start ?m ?rs (?c, Oc # ?list) ==>
      wadjust_loop_right_move ?m ?rs (Oc # ?c, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wadjust_start_Oc",
     "wadjust_start ?m ?rs (?c, Bk # ?list) ==>
      wadjust_start ?m ?rs (?c, Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_app
                (template_app (template_hole 2, template_hole 0),
                 template_var 0)))
           ))),
    ("UTM.wadjust_loop_start_Oc",
     "wadjust_start ?m ?rs (?c, Oc # ?list) ==>
      wadjust_loop_start ?m ?rs (Oc # ?c, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wcode_on_right_moving_2_via_erase2",
     "wcode_erase2 ?ires ?rs (?b, Bk # ?list) ==>
      wcode_on_right_moving_2 ?ires ?rs (Bk # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wcode_erase2_Bk_via_Oc",
     "wcode_erase2 ?ires ?rs (?b, Oc # ?list) ==>
      wcode_erase2 ?ires ?rs (?b, Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_app
                (template_app (template_hole 2, template_hole 0),
                 template_var 0)))
           ))),
    ("UTM.wcode_backto_standard_pos_2_via_right",
     "wcode_goon_right_moving_2 ?ires ?rs (?b, Bk # ?list) ==>
      wcode_backto_standard_pos_2 ?ires ?rs (?b, Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 4, template_var 1),
               template_app
                (template_app (template_hole 3, template_hole 0),
                 template_var 0)))
           ))),
    ("UTM.wcode_goon_right_moving_2_move_Oc",
     "wcode_goon_right_moving_2 ?ires ?rs (?b, Oc # ?list) ==>
      wcode_goon_right_moving_2 ?ires ?rs (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 2, template_var 1),
                template_app
                 (template_app (template_hole 1, template_hole 0),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wcode_on_right_moving_2_move_Bk",
     "wcode_on_right_moving_2 ?ires ?rs (?b, Bk # ?list) ==>
      wcode_on_right_moving_2 ?ires ?rs (Bk # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 2, template_var 1),
                template_app
                 (template_app (template_hole 1, template_hole 0),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wcode_goon_right_moving_2_Oc_move",
     "wcode_on_right_moving_2 ?ires ?rs (?b, Oc # ?list) ==>
      wcode_goon_right_moving_2 ?ires ?rs (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wcode_erase2_via_move",
     "wcode_right_move ?ires ?rs (?b, Bk # ?list) ==>
      wcode_erase2 ?ires ?rs (Bk # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_goto_start_pos_Bk",
     "wprepare_erase ?m ?lm (?b, Bk # ?list) ==>
      wprepare_goto_start_pos ?m ?lm (Bk # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_erase_Bk",
     "wprepare_erase ?m ?lm (?b, Oc # ?list) ==>
      wprepare_erase ?m ?lm (?b, Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_app
                (template_app (template_hole 2, template_hole 0),
                 template_var 0)))
           ))),
    ("UTM.wprepare_add_one_b",
     "wprepare_loop_goon ?m ?lm (?b, Oc # ?list) ==>
      wprepare_loop_start ?m ?lm (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.start_2_start",
     "wprepare_loop_start ?m ?lm (?b, Oc # ?list) ==>
      wprepare_loop_start ?m ?lm (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 2, template_var 1),
                template_app
                 (template_app (template_hole 1, template_hole 0),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_loop_start_in_middle_Oc",
     "wprepare_loop_start_in_middle ?m ?lm (?b, Oc # ?list) ==>
      wprepare_loop_start_in_middle ?m ?lm (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 2, template_var 1),
                template_app
                 (template_app (template_hole 1, template_hole 0),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_loop_start_on_rightmost_Oc",
     "wprepare_loop_start_on_rightmost ?m ?lm (?b, Oc # ?list) ==>
      wprepare_loop_start_on_rightmost ?m ?lm (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 2, template_var 1),
                template_app
                 (template_app (template_hole 1, template_hole 0),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_loop_goon_nonempty_fst",
     "[| ?lm ~= []; wprepare_loop_goon ?m ?lm (?b, []) |] ==> ?b ~= []",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 4)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 1),
                template_var 2),
              template_app
               (template_app (template_hole 2, template_var 0),
                template_hole 1))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 1)))),
    ("UTM.wprepare_loop_start_empty_nonempty_fst",
     "[| ?lm ~= []; wprepare_loop_start ?m ?lm (?b, []) |] ==> ?b ~= []",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 4)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 1),
                template_var 2),
              template_app
               (template_app (template_hole 2, template_var 0),
                template_hole 1))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 1)))),
    ("UTM.twice_power", "2 * 2 ^ ?a = Suc (Suc (2 * bl_bin (Oc \<up> ?a)))",
     template_equation
      (template_app
        (template_app
          (template_hole 8,
           template_app
            (template_hole 7,
             template_app (template_hole 6, template_hole 5))),
         template_app
          (template_app
            (template_hole 4,
             template_app
              (template_hole 7,
               template_app (template_hole 6, template_hole 5))),
           template_var 0)),
       template_app
        (template_hole 3,
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_hole 7,
                 template_app (template_hole 6, template_hole 5))),
             template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 0),
                 template_hole 0))))))),
    ("UTM.wcode_double_case_inv_simps",
     "wcode_backto_standard_pos ?ires ?rs (?l, ?r) =
      (wcode_backto_standard_pos_B ?ires ?rs (?l, ?r) |
       wcode_backto_standard_pos_O ?ires ?rs (?l, ?r))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_backto_standard_pos_2 ?ires ?rs (?l, ?r) =
      (wcode_backto_standard_pos_2_O ?ires ?rs (?l, ?r) |
       wcode_backto_standard_pos_2_B ?ires ?rs (?l, ?r))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("UTM.wcode_double_case_inv_simps",
     "wcode_on_left_moving_1 ?ires ?rs (?l, ?r) =
      (wcode_on_left_moving_1_B ?ires ?rs (?l, ?r) |
       wcode_on_left_moving_1_O ?ires ?rs (?l, ?r))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_on_left_moving_2 ?ires ?rs (?l, ?r) =
      (wcode_on_left_moving_2_B ?ires ?rs (?l, ?r) |
       wcode_on_left_moving_2_O ?ires ?rs (?l, ?r))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("UTM.wcode_halt_invs",
     "wcode_on_left_moving_3 ?ires ?rs (?l, ?r) =
      (wcode_on_left_moving_3_B ?ires ?rs (?l, ?r) |
       wcode_on_left_moving_3_O ?ires ?rs (?l, ?r))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("UTM.wprepare_invs",
     "wprepare_goto_start_pos ?m ?lm (?l, ?r) =
      (wprepare_goto_start_pos_B ?m ?lm (?l, ?r) |
       wprepare_goto_start_pos_O ?m ?lm (?l, ?r))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("UTM.wprepare_invs",
     "wprepare_loop_goon ?m ?lm (?l, ?r) =
      (wprepare_loop_goon_in_middle ?m ?lm (?l, ?r) |
       wprepare_loop_goon_on_rightmost ?m ?lm (?l, ?r))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("UTM.wprepare_invs",
     "wprepare_loop_start ?m ?lm (?l, ?r) =
      (wprepare_loop_start_on_rightmost ?m ?lm (?l, ?r) |
       wprepare_loop_start_in_middle ?m ?lm (?l, ?r))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_var 0))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 2),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0))))),
    ("UTM.tape_of_nl_cons_app2",
     "<?c # ?xs @ [?b]> = <?c # ?xs> @ Bk # Oc \<up> Suc ?b",
     template_equation
      (template_app
        (template_hole 9,
         template_app
          (template_app (template_hole 8, template_var 2),
           template_app
            (template_app (template_hole 7, template_var 1),
             template_app
              (template_app (template_hole 8, template_var 0),
               template_hole 6)))),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_hole 9,
             template_app
              (template_app (template_hole 8, template_var 2),
               template_var 1))),
         template_app
          (template_app (template_hole 4, template_hole 3),
           template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 0)),
             template_hole 0))))),
    ("UTM.wadjust_backto_standard_pos_B_Bk_Oc",
     "wadjust_backto_standard_pos_O ?m ?rs ([], Oc # ?list) ==>
      wadjust_backto_standard_pos_B ?m ?rs ([], Bk # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 5, template_hole 4),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 2),
               template_var 1),
             template_app
              (template_app (template_hole 5, template_hole 4),
               template_app
                (template_app (template_hole 3, template_hole 0),
                 template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_var 0))))
           ))),
    ("UTM.exists_exp_of_Bk",
     "Bk # ?list = Oc \<up> ?mr @ Bk \<up> ?rn ==>
      EX rn. ?list = Bk \<up> rn",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 5, template_hole 4),
            template_var 2),
          template_app
           (template_app
             (template_hole 3,
              template_app
               (template_app (template_hole 2, template_var 1),
                template_hole 1)),
            template_app
             (template_app (template_hole 2, template_var 0),
              template_hole 4)))],
       template_predicate (template_app (template_hole 0, t_empty)))),
    ("UTM.tinres_some_exp",
     "tinres (Bk \<up> ?m @ [Bk, Bk]) ?la ==> EX m. ?la = Bk \<up> m",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app
                   (template_hole 6,
                    template_app
                     (template_app (template_hole 5, template_var 1),
                      template_hole 4)),
                  template_app
                   (template_app (template_hole 3, template_hole 4),
                    template_app
                     (template_app (template_hole 3, template_hole 4),
                      template_hole 2)))),
              template_var 0)
            )],
       template_predicate (template_app (template_hole 1, t_empty)))),
    ("UTM.wprepare_erase_Bk_nonempty_list",
     "[| ?lm ~= []; wprepare_erase ?m ?lm (?b, Bk # ?list) |]
      ==> ?list ~= []",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 6)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 0)))),
    ("UTM.wprepare_goto_first_end_nonempty_snd_tl",
     "[| ?lm ~= []; wprepare_goto_first_end ?m ?lm (?b, Bk # ?list) |]
      ==> ?list ~= []",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 6)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 0)))),
    ("UTM.wprepare_goto_start_pos_Bk_nonempty_fst",
     "[| ?lm ~= []; wprepare_goto_start_pos ?m ?lm (?b, Bk # ?list) |]
      ==> ?b ~= []",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 6)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.wprepare_goto_start_pos_Bk_nonempty",
     "[| ?lm ~= []; wprepare_goto_start_pos ?m ?lm (?b, Bk # ?list) |]
      ==> ?list ~= []",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 6)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 0, template_hole 0)))),
    ("UTM.wprepare_loop_goon_Bk_nonempty",
     "[| ?lm ~= []; wprepare_loop_goon ?m ?lm (?b, Bk # ?list) |]
      ==> ?b ~= []",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 6)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_negation
        (template_equation (template_var 1, template_hole 0)))),
    ("UTM.takeWhile_exp1",
     "takeWhile (%a. a = Oc) (Oc \<up> ?n @ ?xs) =
      Oc \<up> ?n @ takeWhile (%a. a = Oc) ?xs",
     template_equation
      (template_app
        (template_app (template_hole 4, t_empty),
         template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 1),
               template_hole 2)),
           template_var 0)),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_hole 2)),
         template_app
          (template_app (template_hole 4, t_empty), template_var 0)))),
    ("UTM.bl_bin_bk_oc",
     "bl_bin (?xs @ [Bk, Oc]) = bl_bin ?xs + 2 * 2 ^ length ?xs",
     template_equation
      (template_app
        (template_hole 12,
         template_app
          (template_app (template_hole 11, template_var 0),
           template_app
            (template_app (template_hole 10, template_hole 9),
             template_app
              (template_app (template_hole 10, template_hole 8),
               template_hole 7)))),
       template_app
        (template_app
          (template_hole 6,
           template_app (template_hole 12, template_var 0)),
         template_app
          (template_app
            (template_hole 5,
             template_app
              (template_hole 4,
               template_app (template_hole 3, template_hole 2))),
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_hole 4,
                 template_app (template_hole 3, template_hole 2))),
             template_app (template_hole 0, template_var 0)))))),
    ("UTM.tape_of_nl_cons_app1",
     "<?a # ?xs @ [?b]> = Oc \<up> Suc ?a @ Bk # <?xs @ [?b]>",
     template_equation
      (template_app
        (template_hole 9,
         template_app
          (template_app (template_hole 8, template_var 2),
           template_app
            (template_app (template_hole 7, template_var 1),
             template_app
              (template_app (template_hole 8, template_var 0),
               template_hole 6)))),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app (template_hole 3, template_var 2)),
             template_hole 2)),
         template_app
          (template_app (template_hole 1, template_hole 0),
           template_app
            (template_hole 9,
             template_app
              (template_app (template_hole 7, template_var 1),
               template_app
                (template_app (template_hole 8, template_var 0),
                 template_hole 6))))))),
    ("UTM.fetch_t_wcode_14",
     "fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) ?b =
      (L, Suc 0)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 14, template_hole 13),
           template_app
            (template_app
              (template_hole 12,
               template_app
                (template_app
                  (template_hole 12,
                   template_app
                    (template_hole 11,
                     template_app
                      (template_hole 10,
                       template_app
                        (template_hole 9,
                         template_app
                          (template_hole 9, template_hole 8))))),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app (template_hole 6, template_hole 5)),
                   template_app
                    (template_hole 11,
                     template_app (template_hole 10, template_hole 8))))),
             template_hole 4)),
         template_var 0),
       template_app
        (template_app (template_hole 3, template_hole 2),
         template_app (template_hole 1, template_hole 0)))),
    ("UTM.wadjust_on_left_moving_B_Bk1",
     "wadjust_on_left_moving_B ?m ?rs
       (Oc # Oc # Oc \<up> ?rs @ Bk # Oc # Oc \<up> ?m, [Bk])",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 7, template_var 1),
             template_var 0),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_hole 4),
                 template_app
                  (template_app (template_hole 5, template_hole 4),
                   template_app
                    (template_app
                      (template_hole 3,
                       template_app
                        (template_app (template_hole 2, template_var 0),
                         template_hole 4)),
                     template_app
                      (template_app (template_hole 5, template_hole 1),
                       template_app
                        (template_app (template_hole 5, template_hole 4),
                         template_app
                          (template_app (template_hole 2, template_var 1),
                           template_hole 4))))))),
             template_app
              (template_app (template_hole 5, template_hole 1),
               template_hole 0)))
         )),
    ("UTM.tape_of_nl_append_one",
     "?lm ~= [] ==> <?lm @ [?a]> = <?lm> @ Bk # Oc \<up> Suc ?a",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 10))],
       template_equation
        (template_app
          (template_hole 8,
           template_app
            (template_app (template_hole 7, template_var 1),
             template_app
              (template_app (template_hole 6, template_var 0),
               template_hole 10))),
         template_app
          (template_app
            (template_hole 5,
             template_app (template_hole 8, template_var 1)),
           template_app
            (template_app (template_hole 4, template_hole 3),
             template_app
              (template_app
                (template_hole 2,
                 template_app (template_hole 1, template_var 0)),
               template_hole 0)))))),
    ("UTM.NSTD_1",
     "~ TSTD (?a, ?b, ?c) ==>
      rec_exec rec_NSTD [trpl_code (?a, ?b, ?c)] = Suc 0",
     template_implication
      ([template_negation
         (
            template_predicate
             (
                template_app
                 (template_hole 10,
                  template_app
                   (template_app (template_hole 9, template_var 2),
                    template_app
                     (template_app (template_hole 8, template_var 1),
                      template_var 0)))
                )
            )],
       template_equation
        (template_app
          (template_app (template_hole 6, template_hole 5),
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 9, template_var 2),
                   template_app
                    (template_app (template_hole 8, template_var 1),
                     template_var 0)))),
             template_hole 2)),
         template_app (template_hole 1, template_hole 0)))),
    ("UTM.tm_wf_shift",
     "list_all (%(acn, st). st <= ?y) ?tp ==>
      list_all (%(acn, st). st <= ?y + ?off) (Turing.shift ?tp ?off)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 4, template_app (template_hole 3, t_empty)),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4, template_app (template_hole 3, t_empty)),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("UTM.wadjust_on_left_moving_Bk_via_erase",
     "wadjust_erase2 ?m ?rs (?c, Bk # ?list) ==>
      wadjust_on_left_moving ?m ?rs (tl ?c, hd ?c # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wadjust_backto_standard_pos_via_left_Bk",
     "wadjust_goon_left_moving ?m ?rs (?c, Bk # ?list) ==>
      wadjust_backto_standard_pos ?m ?rs (tl ?c, hd ?c # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wadjust_goon_left_moving_Oc_move",
     "wadjust_goon_left_moving ?m ?rs (?c, Oc # ?list) ==>
      wadjust_goon_left_moving ?m ?rs (tl ?c, hd ?c # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_var 0))))
           ))),
    ("UTM.wadjust_erase2_via_loop_check_Bk",
     "wadjust_loop_check ?m ?rs (?c, Bk # ?list) ==>
      wadjust_erase2 ?m ?rs (tl ?c, hd ?c # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wadjust_loop_erase_move_Oc",
     "wadjust_loop_check ?m ?rs (?c, Oc # ?list) ==>
      wadjust_loop_erase ?m ?rs (tl ?c, hd ?c # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wadjust_loop_on_left_moving_Bk_move",
     "wadjust_loop_on_left_moving ?m ?rs (?c, Bk # ?list) ==>
      wadjust_loop_on_left_moving ?m ?rs (tl ?c, hd ?c # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_var 0))))
           ))),
    ("UTM.wadjust_on_left_moving_B_drop",
     "wadjust_on_left_moving ?m ?rs (?c, Bk # ?list) ==>
      wadjust_on_left_moving ?m ?rs (tl ?c, hd ?c # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_var 0))))
           ))),
    ("UTM.wadjust_goon_left_moving_Oc",
     "wadjust_on_left_moving ?m ?rs (?c, Oc # ?list) ==>
      wadjust_goon_left_moving ?m ?rs (tl ?c, hd ?c # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wcode_backto_standard_pos_2_Oc_mv_hd",
     "wcode_backto_standard_pos_2 ?ires ?rs (?b, Oc # ?list) ==>
      wcode_backto_standard_pos_2 ?ires ?rs (tl ?b, hd ?b # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_var 0))))
           ))),
    ("UTM.wcode_goon_checking_via_2",
     "wcode_on_checking_2 ?ires ?rs (?b, Bk # ?list) ==>
      wcode_goon_checking ?ires ?rs (tl ?b, hd ?b # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wcode_goon_checking_3_mv_Bk",
     "wcode_on_checking_3 ?ires ?rs (?b, Bk # ?list) ==>
      wcode_goon_checking_3 ?ires ?rs (tl ?b, hd ?b # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wcode_on_left_moving_2",
     "wcode_on_left_moving_2 ?ires ?rs (?b, Bk # ?list) ==>
      wcode_on_left_moving_2 ?ires ?rs (tl ?b, hd ?b # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_var 0))))
           ))),
    ("UTM.wcode_on_checking_2_via_left",
     "wcode_on_left_moving_2 ?ires ?rs (?b, Oc # ?list) ==>
      wcode_on_checking_2 ?ires ?rs (tl ?b, hd ?b # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wcode_on_left_moving_3_mv_Bk",
     "wcode_on_left_moving_3 ?ires ?rs (?b, Bk # ?list) ==>
      wcode_on_left_moving_3 ?ires ?rs (tl ?b, hd ?b # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 1),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_var 0))))
           ))),
    ("UTM.wcode_on_checking_3_mv_Oc",
     "wcode_on_left_moving_3 ?ires ?rs (?b, Oc # ?list) ==>
      wcode_on_checking_3 ?ires ?rs (tl ?b, hd ?b # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.add_one_2_stop",
     "wprepare_add_one2 ?m ?lm (?b, Oc # ?list) ==>
      wprepare_stop ?m ?lm (tl ?b, hd ?b # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wprepare_erase_elem_Bk_rest",
     "wprepare_goto_first_end ?m ?lm (?b, Bk # ?list) ==>
      wprepare_erase ?m ?lm (tl ?b, hd ?b # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wprepare_loop_start_on_rightmost_Oc2",
     "wprepare_goto_start_pos ?m [?a] (?b, Oc # ?list) ==>
      wprepare_loop_start_on_rightmost ?m [?a] (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_app
                 (template_app (template_hole 5, template_var 2),
                  template_hole 4)),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_app
                (template_app (template_hole 5, template_var 2),
                 template_hole 4)),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_add_one2_Bk_empty",
     "[| ?lm ~= []; wprepare_loop_goon ?m ?lm (?b, []) |]
      ==> wprepare_add_one2 ?m ?lm (Bk # ?b, [])",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 6)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 1),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 0),
                template_hole 3))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 1),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 0)),
               template_hole 3))
           ))),
    ("UTM.wprepare_loop_goon_Bk_empty_snd",
     "[| ?lm ~= []; wprepare_loop_start ?m ?lm (?b, []) |]
      ==> wprepare_loop_goon ?m ?lm (Bk # ?b, [])",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 6)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 1),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 0),
                template_hole 3))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 1),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 0)),
               template_hole 3))
           ))),
    ("UTM.nonempty_hd_tinres",
     "[| tinres ?r ?r'; ?r ~= []; ?r' ~= [] |] ==> hd ?r = hd ?r'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0)
            ),
        template_negation
         (template_equation (template_var 1, template_hole 2)),
        template_negation
         (template_equation (template_var 0, template_hole 2))],
       template_equation
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("UTM.split_26_even", "(26 + ?l) div 2 = ?l div 2 + 13",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_hole 3,
                 template_app
                  (template_hole 2,
                   template_app
                    (template_hole 1,
                     template_app
                      (template_hole 2,
                       template_app (template_hole 1, template_hole 0)))))),
             template_var 0)),
         template_app
          (template_hole 3,
           template_app (template_hole 2, template_hole 0))),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 5, template_var 0),
             template_app
              (template_hole 3,
               template_app (template_hole 2, template_hole 0)))),
         template_app
          (template_hole 3,
           template_app
            (template_hole 1,
             template_app
              (template_hole 2,
               template_app (template_hole 1, template_hole 0))))))),
    ("UTM.wprepare_add_one_b",
     "wprepare_add_one ?m ?lm (?b, Oc # ?list) ==>
      ?b = [] --> wprepare_add_one ?m ?lm ([], Bk # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 6, template_var 1),
                template_app
                 (template_app (template_hole 5, template_hole 4),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_hole 1)),
             template_app
              (template_app
                (template_app (template_hole 7, template_var 3),
                 template_var 2),
               template_app
                (template_app (template_hole 6, template_hole 1),
                 template_app
                  (template_app (template_hole 5, template_hole 0),
                   template_app
                    (template_app (template_hole 5, template_hole 4),
                     template_var 0)))))
           ))),
    ("UTM.bl2wc_exp_ex",
     "Suc (bl2wc ?c) = 2 ^ ?m ==> EX rs n. ?c = Oc \<up> rs @ Bk \<up> n",
     template_implication
      ([template_equation
         (template_app
           (template_hole 11,
            template_app (template_hole 10, template_var 1)),
          template_app
           (template_app
             (template_hole 9,
              template_app
               (template_hole 8,
                template_app (template_hole 7, template_hole 6))),
            template_var 0))],
       template_predicate (template_app (template_hole 5, t_empty)))),
    ("UTM.wprepare_loop_goon_in_middle_Bk_False2",
     "wprepare_loop_start_on_rightmost ?m ?lm (?b, Bk # ?a # ?lista) ==>
      wprepare_loop_goon_in_middle ?m ?lm (Bk # ?b, ?a # ?lista) = False",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 4),
                template_var 3),
              template_app
               (template_app (template_hole 5, template_var 2),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_app
                   (template_app (template_hole 4, template_var 1),
                    template_var 0))))
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 4),
             template_var 3),
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_hole 3),
                 template_var 2)),
             template_app
              (template_app (template_hole 4, template_var 1),
               template_var 0))),
         template_hole 0))),
    ("UTM.nstd_case3",
     "ALL rs n. ?c ~= Oc \<up> Suc rs @ Bk \<up> n ==>
      NSTD (trpl_code (?a, ?b, ?c))",
     template_implication
      ([template_predicate (template_app (template_hole 11, t_empty))],
       template_predicate
        (
           template_app
            (template_hole 3,
             template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_app
                  (template_app (template_hole 0, template_var 0),
                   template_var 2))))
           ))),
    ("UTM.wprepare_goto_start_pos_Bk_move",
     "[| ?lm ~= []; wprepare_goto_start_pos ?m ?lm (?b, Bk # ?list) |]
      ==> wprepare_goto_start_pos ?m ?lm (Bk # ?b, ?list)",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 4)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 3, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 2, template_var 1),
                template_app
                 (template_app (template_hole 1, template_hole 0),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 2),
               template_var 3),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_hole 0),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_loop_start_Oc2",
     "[| ?lm ~= []; wprepare_goto_start_pos ?m ?lm (?b, Oc # ?list) |]
      ==> wprepare_loop_start ?m ?lm (Oc # ?b, ?list)",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 5)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 2),
               template_var 3),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_loop_goon_Bk",
     "[| ?lm ~= []; wprepare_loop_start ?m ?lm (?b, [Bk]) |]
      ==> wprepare_loop_goon ?m ?lm (Bk # ?b, [])",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 6)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 1),
                template_var 2),
              template_app
               (template_app (template_hole 4, template_var 0),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_hole 1)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 1),
               template_var 2),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 3, template_hole 2),
                   template_var 0)),
               template_hole 1))
           ))),
    ("UTM.wadjust_on_left_moving_singleton",
     "[| wadjust_erase2 ?m ?rs (?c, []); ?c ~= [] |]
      ==> wadjust_on_left_moving ?m ?rs (tl ?c, [hd ?c])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 7, template_var 0),
                template_hole 6))
            ),
        template_negation
         (template_equation (template_var 0, template_hole 6))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 3, template_var 2),
               template_var 1),
             template_app
              (template_app
                (template_hole 7,
                 template_app (template_hole 2, template_var 0)),
               template_app
                (template_app
                  (template_hole 1,
                   template_app (template_hole 0, template_var 0)),
                 template_hole 6)))
           ))),
    ("UTM.wadjust_on_left_moving_singleton2",
     "[| wadjust_on_left_moving ?m ?rs (?c, []); ?c ~= [] |]
      ==> wadjust_on_left_moving ?m ?rs (tl ?c, [hd ?c])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 6, template_var 0),
                template_hole 5))
            ),
        template_negation
         (template_equation (template_var 0, template_hole 5))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 7, template_var 2),
               template_var 1),
             template_app
              (template_app
                (template_hole 6,
                 template_app (template_hole 2, template_var 0)),
               template_app
                (template_app
                  (template_hole 1,
                   template_app (template_hole 0, template_var 0)),
                 template_hole 5)))
           ))),
    ("UTM.wcode_goon_right_moving_1_emptyE",
     "[| wcode_goon_right_moving_1 ?ires ?rs (?aa, []);
         ?b = ?aa & [Oc] = ?ba |]
      ==> wcode_backto_standard_pos ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 4),
                template_var 3),
              template_app
               (template_app (template_hole 6, template_var 2),
                template_hole 5))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app
                 (template_app (template_hole 3, template_var 1),
                  template_var 2)),
              template_app
               (template_app
                 (template_hole 3,
                  template_app
                   (template_app (template_hole 2, template_hole 1),
                    template_hole 5)),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 4),
               template_var 3),
             template_app
              (template_app (template_hole 6, template_var 2),
               template_var 0))
           ))),
    ("UTM.tinres_fetch_congr",
     "tinres ?r ?r' ==> fetch ?t ?ss (read ?r) = fetch ?t ?ss (read ?r')",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 7, template_var 3),
              template_var 2)
            )],
       template_bimplication
        (template_predicate
          (
             template_app
              (template_app
                (template_app (template_hole 5, template_var 1),
                 template_var 0),
               template_app
                (template_app
                  (template_app
                    (template_hole 4,
                     template_app
                      (template_app (template_hole 3, template_var 3),
                       template_hole 2)),
                   template_hole 1),
                 template_app (template_hole 0, template_var 3)))
             ),
         template_predicate
          (
             template_app
              (template_app
                (template_app (template_hole 5, template_var 1),
                 template_var 0),
               template_app
                (template_app
                  (template_app
                    (template_hole 4,
                     template_app
                      (template_app (template_hole 3, template_var 2),
                       template_hole 2)),
                   template_hole 1),
                 template_app (template_hole 0, template_var 2)))
             )))),
    ("UTM.b_le_28",
     "(?a, ?b) : set t_wcode_main_first_part ==>
      ?b <= (28 + (length t_twice_compile + length t_fourtimes_compile)) div
            2",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 13,
                template_app
                 (template_app (template_hole 12, template_var 1),
                  template_var 0)),
              template_app (template_hole 11, template_hole 10))
            )],
       template_inequation
        (less_equals, template_var 0,
         template_app
          (template_app
            (template_hole 8,
             template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_hole 6,
                   template_app
                    (template_hole 5,
                     template_app
                      (template_hole 5,
                       template_app
                        (template_hole 4,
                         template_app
                          (template_hole 4, template_hole 3)))))),
               template_app
                (template_app
                  (template_hole 7,
                   template_app (template_hole 2, template_hole 1)),
                 template_app (template_hole 2, template_hole 0)))),
           template_app
            (template_hole 6,
             template_app (template_hole 5, template_hole 3)))))),
    ("UTM.wprepare_loop_start_in_middle_2_Oc",
     "wprepare_goto_start_pos ?m (?a # ?aa # ?listaa) (?b, Oc # ?list) ==>
      wprepare_loop_start_in_middle ?m (?a # ?aa # ?listaa)
       (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 5),
                template_app
                 (template_app (template_hole 4, template_var 4),
                  template_app
                   (template_app (template_hole 4, template_var 3),
                    template_var 2))),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 5),
               template_app
                (template_app (template_hole 4, template_var 4),
                 template_app
                  (template_app (template_hole 4, template_var 3),
                   template_var 2))),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 1)),
               template_var 0))
           ))),
    ("UTM.wprepare_invs",
     "wprepare_erase ?m ?lm (?l, ?r) =
      (EX rn. ?l = Oc \<up> Suc ?m & tl ?r = Bk # <?lm> @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 12, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 11, template_var 1),
           template_var 0)),
       template_app (template_hole 10, t_empty))),
    ("UTM.wprepare_loop_goon_in_middle_cases",
     "wprepare_loop_goon_in_middle ?m ?lm (?b, Oc # ?list) ==>
      wprepare_loop_start_on_rightmost ?m ?lm (Oc # ?b, ?list) |
      wprepare_loop_start_in_middle ?m ?lm (Oc # ?b, ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 3),
                   template_var 2),
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app
                      (template_app (template_hole 4, template_hole 3),
                       template_var 1)),
                   template_var 0))),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 3),
                 template_var 2),
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 4, template_hole 3),
                     template_var 1)),
                 template_var 0)))
           ))),
    ("UTM.left_moving_Bk_Oc",
     "[| wadjust_goon_left_moving_O ?m ?rs (?c, Oc # ?list); hd ?c = Bk |]
      ==> wadjust_goon_left_moving_B ?m ?rs (tl ?c, Bk # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 7, template_var 1),
                template_app
                 (template_app (template_hole 6, template_hole 5),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 3, template_var 1), template_hole 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 7,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 6, template_hole 2),
                 template_app
                  (template_app (template_hole 6, template_hole 5),
                   template_var 0))))
           ))),
    ("UTM.left_moving_Oc_Oc",
     "[| wadjust_goon_left_moving_O ?m ?rs (?c, Oc # ?list); hd ?c = Oc |]
      ==> wadjust_goon_left_moving_O ?m ?rs (tl ?c, Oc # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 1, template_var 1), template_hole 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 4, template_hole 3),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wadjust_loop_on_left_moving_B_via_erase",
     "[| wadjust_loop_erase ?m ?rs (?c, Bk # ?list); hd ?c = Bk |]
      ==> wadjust_loop_on_left_moving_B ?m ?rs (tl ?c, Bk # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 6, template_var 1),
                template_app
                 (template_app (template_hole 5, template_hole 4),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 2, template_var 1), template_hole 4)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 6,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 5, template_hole 4),
                 template_app
                  (template_app (template_hole 5, template_hole 4),
                   template_var 0))))
           ))),
    ("UTM.wadjust_loop_on_left_moving_B_Bk_move",
     "[| wadjust_loop_on_left_moving_B ?m ?rs (?c, Bk # ?list);
         hd ?c = Bk |]
      ==> wadjust_loop_on_left_moving_B ?m ?rs (tl ?c, Bk # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 1, template_var 1), template_hole 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 4, template_hole 3),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wadjust_loop_on_left_moving_O_Oc_move",
     "[| wadjust_loop_on_left_moving_B ?m ?rs (?c, Bk # ?list);
         hd ?c = Oc |]
      ==> wadjust_loop_on_left_moving_O ?m ?rs (tl ?c, Oc # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 7, template_var 1),
                template_app
                 (template_app (template_hole 6, template_hole 5),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 3, template_var 1), template_hole 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 7,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 6, template_hole 2),
                 template_app
                  (template_app (template_hole 6, template_hole 5),
                   template_var 0))))
           ))),
    ("UTM.wadjust_on_left_moving_B_Bk_drop_one",
     "[| wadjust_on_left_moving_B ?m ?rs (?c, Bk # ?list); hd ?c = Bk |]
      ==> wadjust_on_left_moving_B ?m ?rs (tl ?c, Bk # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 5, template_var 1),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 1, template_var 1), template_hole 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 5,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 4, template_hole 3),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_var 0))))
           ))),
    ("UTM.wadjust_on_left_moving_B_Bk_drop_Oc",
     "[| wadjust_on_left_moving_B ?m ?rs (?c, Bk # ?list); hd ?c = Oc |]
      ==> wadjust_on_left_moving_O ?m ?rs (tl ?c, Oc # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 7, template_var 1),
                template_app
                 (template_app (template_hole 6, template_hole 5),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 3, template_var 1), template_hole 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 7,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 6, template_hole 2),
                 template_app
                  (template_app (template_hole 6, template_hole 5),
                   template_var 0))))
           ))),
    ("UTM.wadjust_goon_left_moving_B_Bk_Oc",
     "[| wadjust_on_left_moving_O ?m ?rs (?c, Oc # ?list); hd ?c = Bk |]
      ==> wadjust_goon_left_moving_B ?m ?rs (tl ?c, Bk # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 7, template_var 1),
                template_app
                 (template_app (template_hole 6, template_hole 5),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 3, template_var 1), template_hole 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 7,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 6, template_hole 2),
                 template_app
                  (template_app (template_hole 6, template_hole 5),
                   template_var 0))))
           ))),
    ("UTM.wadjust_goon_left_moving_O_Oc_Oc",
     "[| wadjust_on_left_moving_O ?m ?rs (?c, Oc # ?list); hd ?c = Oc |]
      ==> wadjust_goon_left_moving_O ?m ?rs (tl ?c, Oc # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 6, template_var 1),
                template_app
                 (template_app (template_hole 5, template_hole 4),
                  template_var 0)))
            ),
        template_equation
         (template_app (template_hole 2, template_var 1), template_hole 4)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 6,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 5, template_hole 4),
                 template_app
                  (template_app (template_hole 5, template_hole 4),
                   template_var 0))))
           ))),
    ("UTM.wcode_backto_standard_pos_BkE",
     "[| wcode_backto_standard_pos ?ires ?rs (?b, Bk # ?ba);
         Bk # ?b = ?aa & ?list = ?ba |]
      ==> wcode_before_double ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 5, template_var 3),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app
                   (template_hole 1,
                    template_app
                     (template_app (template_hole 4, template_hole 3),
                      template_var 3)),
                  template_var 1)),
              template_app
               (template_app (template_hole 1, template_var 0),
                template_var 2))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 5, template_var 1),
               template_var 2))
           ))),
    ("UTM.wcode_erase1_OcE",
     "[| wcode_erase1 ?ires ?rs (?aa, Oc # ?list);
         ?b = ?aa & Bk # ?list = ?ba |]
      ==> wcode_erase1 ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 5, template_var 3),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 1),
                  template_var 3)),
              template_app
               (template_app
                 (template_hole 1,
                  template_app
                   (template_app (template_hole 4, template_hole 0),
                    template_var 2)),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 5, template_var 3),
               template_var 0))
           ))),
    ("UTM.wcode_goon_right_moving_1_BkE",
     "[| wcode_goon_right_moving_1 ?ires ?rs (?aa, Bk # ?list);
         ?b = ?aa & Oc # ?list = ?ba |]
      ==> wcode_backto_standard_pos ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 6, template_var 3),
                template_app
                 (template_app (template_hole 5, template_hole 4),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 3,
                template_app
                 (template_app (template_hole 2, template_var 1),
                  template_var 3)),
              template_app
               (template_app
                 (template_hole 2,
                  template_app
                   (template_app (template_hole 5, template_hole 1),
                    template_var 2)),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 6, template_var 3),
               template_var 0))
           ))),
    ("UTM.wcode_goon_right_moving_1_OcE",
     "[| wcode_goon_right_moving_1 ?ires ?rs (?b, Oc # ?ba);
         Oc # ?b = ?aa & ?list = ?ba |]
      ==> wcode_goon_right_moving_1 ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 4, template_var 3),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 1,
                template_app
                 (template_app
                   (template_hole 0,
                    template_app
                     (template_app (template_hole 3, template_hole 2),
                      template_var 3)),
                  template_var 1)),
              template_app
               (template_app (template_hole 0, template_var 0),
                template_var 2))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 4, template_var 1),
               template_var 2))
           ))),
    ("UTM.wcode_on_checking_1_Elim",
     "[| wcode_on_checking_1 ?ires ?rs (?b, Oc # ?ba);
         Oc # ?b = ?aa & ?list = ?ba |]
      ==> wcode_erase1 ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 5, template_var 3),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app
                   (template_hole 1,
                    template_app
                     (template_app (template_hole 4, template_hole 3),
                      template_var 3)),
                  template_var 1)),
              template_app
               (template_app (template_hole 1, template_var 0),
                template_var 2))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 5, template_var 1),
               template_var 2))
           ))),
    ("UTM.wcode_on_right_moving_1_BkE",
     "[| wcode_on_right_moving_1 ?ires ?rs (?b, Bk # ?ba);
         Bk # ?b = ?aa & ?list = ?b |]
      ==> wcode_on_right_moving_1 ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 5, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 4, template_var 3),
                template_app
                 (template_app (template_hole 3, template_hole 2),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 1,
                template_app
                 (template_app
                   (template_hole 0,
                    template_app
                     (template_app (template_hole 3, template_hole 2),
                      template_var 3)),
                  template_var 1)),
              template_app
               (template_app (template_hole 0, template_var 0),
                template_var 3))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 5, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 4, template_var 1),
               template_var 2))
           ))),
    ("UTM.wcode_on_right_moving_1_OcE",
     "[| wcode_on_right_moving_1 ?ires ?rs (?b, Oc # ?ba);
         Oc # ?b = ?aa & ?list = ?ba |]
      ==> wcode_goon_right_moving_1 ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 5, template_var 3),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app
                   (template_hole 1,
                    template_app
                     (template_app (template_hole 4, template_hole 3),
                      template_var 3)),
                  template_var 1)),
              template_app
               (template_app (template_hole 1, template_var 0),
                template_var 2))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 5, template_var 1),
               template_var 2))
           ))),
    ("UTM.wadjust_on_left_moving_B_Bk2",
     "wadjust_on_left_moving_B ?m ?rs
       (Bk \<up> ?n @ Bk # Oc # Oc # Oc \<up> ?rs @ Bk # Oc # Oc \<up> ?m,
        [Bk])",
     template_predicate
      (
         template_app
          (template_app
            (template_app (template_hole 7, template_var 2),
             template_var 1),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app
                  (template_hole 5,
                   template_app
                    (template_app (template_hole 4, template_var 0),
                     template_hole 3)),
                 template_app
                  (template_app (template_hole 2, template_hole 3),
                   template_app
                    (template_app (template_hole 2, template_hole 1),
                     template_app
                      (template_app (template_hole 2, template_hole 1),
                       template_app
                        (template_app
                          (template_hole 5,
                           template_app
                            (template_app (template_hole 4, template_var 1),
                             template_hole 1)),
                         template_app
                          (template_app (template_hole 2, template_hole 3),
                           template_app
                            (template_app
                              (template_hole 2, template_hole 1),
                             template_app
                              (template_app
                                (template_hole 4, template_var 2),
                               template_hole 1))))))))),
             template_app
              (template_app (template_hole 2, template_hole 3),
               template_hole 0)))
         )),
    ("UTM.tm_wf_change_termi",
     "tm_wf0 ?tp ==>
      list_all (%(acn, st). st <= Suc (length ?tp div 2)) (adjust0 ?tp)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 12,
              template_app
               (template_app (template_hole 11, template_var 0),
                template_hole 10))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 9, template_app (template_hole 8, t_empty)),
             template_app
              (template_app (template_hole 0, template_var 0),
               template_app
                (template_hole 6,
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app (template_hole 4, template_var 0)),
                   template_app
                    (template_hole 3,
                     template_app (template_hole 2, template_hole 1))))))
           ))),
    ("UTM.wprepare_loop_goon_Bk2",
     "[| ?lm ~= []; wprepare_loop_start ?m ?lm (?b, Bk # ?a # ?lista) |]
      ==> wprepare_loop_goon ?m ?lm (Bk # ?b, ?a # ?lista)",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_hole 5)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 4),
              template_app
               (template_app (template_hole 3, template_var 2),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_app
                   (template_app (template_hole 2, template_var 1),
                    template_var 0))))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 4),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 2)),
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_var 0)))
           ))),
    ("UTM.wprepare_loop_goon_in_middle_Bk_False3",
     "[| ?lm ~= [];
         wprepare_loop_start_in_middle ?m ?lm (?b, Bk # ?a # ?lista) |]
      ==> wprepare_loop_goon_in_middle ?m ?lm (Bk # ?b, ?a # ?lista)",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_hole 5)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 4),
              template_app
               (template_app (template_hole 3, template_var 2),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_app
                   (template_app (template_hole 2, template_var 1),
                    template_var 0))))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 4),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 2)),
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_var 0)))
           ))),
    ("UTM.wprepare_loop_goon_on_rightbmost_Bk_False",
     "[| ?lm ~= [];
         wprepare_loop_start_on_rightmost ?m ?lm (?b, Bk # ?a # ?lista) |]
      ==> wprepare_loop_goon_on_rightmost ?m ?lm (Bk # ?b, ?a # ?lista)",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_hole 5)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 4, template_var 3),
                template_var 4),
              template_app
               (template_app (template_hole 3, template_var 2),
                template_app
                 (template_app (template_hole 2, template_hole 1),
                  template_app
                   (template_app (template_hole 2, template_var 1),
                    template_var 0))))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 3),
               template_var 4),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, template_hole 1),
                   template_var 2)),
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_var 0)))
           ))),
    ("UTM.wadjust_loop_on_left_moving_Bk_via_erase",
     "[| wadjust_loop_erase ?m ?rs (?c, Bk # ?list); ?c ~= [] |]
      ==> wadjust_loop_on_left_moving ?m ?rs (tl ?c, hd ?c # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 8, template_var 1),
                template_app
                 (template_app (template_hole 7, template_hole 6),
                  template_var 0)))
            ),
        template_negation
         (template_equation (template_var 1, template_hole 3))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 8,
                 template_app (template_hole 1, template_var 1)),
               template_app
                (template_app
                  (template_hole 7,
                   template_app (template_hole 0, template_var 1)),
                 template_app
                  (template_app (template_hole 7, template_hole 6),
                   template_var 0))))
           ))),
    ("UTM.ex_move_tl",
     "EX na.
         tl ?r = tl (?r @ Bk \<up> ?n) @ Bk \<up> na |
         tl (?r @ Bk \<up> ?n) = tl ?r @ Bk \<up> na",
     template_predicate (template_app (template_hole 6, t_empty))),
    ("UTM.wadjust_on_left_moving_B_singleton_Bk",
     "[| wadjust_on_left_moving_B ?m ?rs (?c, []); ?c ~= []; hd ?c = Bk |]
      ==> wadjust_on_left_moving_B ?m ?rs (tl ?c, [Bk])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 8, template_var 0),
                template_hole 7))
            ),
        template_negation
         (template_equation (template_var 0, template_hole 7)),
        template_equation
         (template_app (template_hole 3, template_var 0), template_hole 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 9, template_var 2),
               template_var 1),
             template_app
              (template_app
                (template_hole 8,
                 template_app (template_hole 1, template_var 0)),
               template_app
                (template_app (template_hole 0, template_hole 2),
                 template_hole 7)))
           ))),
    ("UTM.wadjust_on_left_moving_B_singleton_Oc",
     "[| wadjust_on_left_moving_B ?m ?rs (?c, []); ?c ~= []; hd ?c = Oc |]
      ==> wadjust_on_left_moving_O ?m ?rs (tl ?c, [Oc])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 10, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 9, template_var 0),
                template_hole 8))
            ),
        template_negation
         (template_equation (template_var 0, template_hole 8)),
        template_equation
         (template_app (template_hole 4, template_var 0), template_hole 3)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 2, template_var 2),
               template_var 1),
             template_app
              (template_app
                (template_hole 9,
                 template_app (template_hole 1, template_var 0)),
               template_app
                (template_app (template_hole 0, template_hole 3),
                 template_hole 8)))
           ))),
    ("UTM.wprepare_loop_goon_in_middle_Bk_False3",
     "[| ?lm ~= [];
         wprepare_loop_start_in_middle ?m ?lm (?b, Bk # ?a # ?lista) |]
      ==> wprepare_loop_goon_on_rightmost ?m ?lm (Bk # ?b, ?a # ?lista) =
          False",
     template_implication
      ([template_negation
         (template_equation (template_var 4, template_hole 7)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 3),
                template_var 4),
              template_app
               (template_app (template_hole 5, template_var 2),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_app
                   (template_app (template_hole 4, template_var 1),
                    template_var 0))))
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 3),
             template_var 4),
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_hole 3),
                 template_var 2)),
             template_app
              (template_app (template_hole 4, template_var 1),
               template_var 0))),
         template_hole 0))),
    ("UTM.wcode_on_left_moving_1E",
     "[| wcode_on_left_moving_1 ?ires ?rs (?b, Bk # ?list);
         tl ?b = ?aa & hd ?b # Bk # ?list = ?ba |]
      ==> wcode_on_left_moving_1 ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 7, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 6, template_var 3),
                template_app
                 (template_app (template_hole 5, template_hole 4),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 3,
                template_app
                 (template_app
                   (template_hole 2,
                    template_app (template_hole 1, template_var 3)),
                  template_var 1)),
              template_app
               (template_app
                 (template_hole 2,
                  template_app
                   (template_app
                     (template_hole 5,
                      template_app (template_hole 0, template_var 3)),
                    template_app
                     (template_app (template_hole 5, template_hole 4),
                      template_var 2))),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 7, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 6, template_var 1),
               template_var 0))
           ))),
    ("UTM.wcode_on_moving_1_Elim",
     "[| wcode_on_left_moving_1 ?ires ?rs (?b, Oc # ?list);
         tl ?b = ?aa & hd ?b # Oc # ?list = ?ba |]
      ==> wcode_on_checking_1 ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 7, template_var 3),
                template_app
                 (template_app (template_hole 6, template_hole 5),
                  template_var 2)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app
                 (template_app
                   (template_hole 3,
                    template_app (template_hole 2, template_var 3)),
                  template_var 1)),
              template_app
               (template_app
                 (template_hole 3,
                  template_app
                   (template_app
                     (template_hole 6,
                      template_app (template_hole 1, template_var 3)),
                    template_app
                     (template_app (template_hole 6, template_hole 5),
                      template_var 2))),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 7, template_var 1),
               template_var 0))
           ))),
    ("UTM.wcode_backto_standard_pos_OcE",
     "[| wcode_backto_standard_pos ?ires ?rs (?b, Oc # ?list); tl ?b = ?aa;
         hd ?b # Oc # ?list = ?ba |]
      ==> wcode_backto_standard_pos ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 5),
                template_var 4),
              template_app
               (template_app (template_hole 5, template_var 3),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 2)))
            ),
        template_equation
         (template_app (template_hole 1, template_var 3), template_var 1),
        template_equation
         (template_app
           (template_app
             (template_hole 4,
              template_app (template_hole 0, template_var 3)),
            template_app
             (template_app (template_hole 4, template_hole 3),
              template_var 2)),
          template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 6, template_var 5),
               template_var 4),
             template_app
              (template_app (template_hole 5, template_var 1),
               template_var 0))
           ))),
    ("UTM.wadjust_backto_standard_pos_B_Bk_Oc_via_O",
     "[| wadjust_backto_standard_pos_O ?m ?rs (?c, Oc # ?list); ?c ~= [];
         hd ?c = Bk |]
      ==> wadjust_backto_standard_pos_B ?m ?rs (tl ?c, Bk # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 11, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 10, template_var 1),
                template_app
                 (template_app (template_hole 9, template_hole 8),
                  template_var 0)))
            ),
        template_negation
         (template_equation (template_var 1, template_hole 5)),
        template_equation
         (template_app (template_hole 3, template_var 1), template_hole 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 10,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 9, template_hole 2),
                 template_app
                  (template_app (template_hole 9, template_hole 8),
                   template_var 0))))
           ))),
    ("UTM.wadjust_backto_standard_pos_B_Oc_Oc_via_O",
     "[| wadjust_backto_standard_pos_O ?m ?rs (?c, Oc # ?list); ?c ~= [];
         hd ?c = Oc |]
      ==> wadjust_backto_standard_pos_O ?m ?rs (tl ?c, Oc # Oc # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 8, template_var 1),
                template_app
                 (template_app (template_hole 7, template_hole 6),
                  template_var 0)))
            ),
        template_negation
         (template_equation (template_var 1, template_hole 3)),
        template_equation
         (template_app (template_hole 1, template_var 1), template_hole 6)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 9, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 8,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 7, template_hole 6),
                 template_app
                  (template_app (template_hole 7, template_hole 6),
                   template_var 0))))
           ))),
    ("UTM.wadjust_loop_on_left_moving_O_Bk_via_erase",
     "[| wadjust_loop_erase ?m ?rs (?c, Bk # ?list); ?c ~= []; hd ?c = Oc |]
      ==> wadjust_loop_on_left_moving_O ?m ?rs (tl ?c, Oc # Bk # ?list)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 11, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 10, template_var 1),
                template_app
                 (template_app (template_hole 9, template_hole 8),
                  template_var 0)))
            ),
        template_negation
         (template_equation (template_var 1, template_hole 5)),
        template_equation
         (template_app (template_hole 3, template_var 1), template_hole 2)],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 10,
                 template_app (template_hole 0, template_var 1)),
               template_app
                (template_app (template_hole 9, template_hole 2),
                 template_app
                  (template_app (template_hole 9, template_hole 8),
                   template_var 0))))
           ))),
    ("UTM.wcode_erase1_BkE",
     "[| wcode_erase1 ?ires ?rs (?b, Bk # ?ba); Bk # ?b = ?aa & ?list = ?ba;
         ?c = Bk # ?ba |]
      ==> wcode_on_right_moving_1 ?ires ?rs (?aa, ?ba)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 6, template_var 6),
                template_var 5),
              template_app
               (template_app (template_hole 5, template_var 4),
                template_app
                 (template_app (template_hole 4, template_hole 3),
                  template_var 3)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app
                   (template_hole 1,
                    template_app
                     (template_app (template_hole 4, template_hole 3),
                      template_var 4)),
                  template_var 2)),
              template_app
               (template_app (template_hole 1, template_var 1),
                template_var 3))
            ),
        template_equation
         (template_var 0,
          template_app
           (template_app (template_hole 4, template_hole 3),
            template_var 3))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 0, template_var 6),
               template_var 5),
             template_app
              (template_app (template_hole 5, template_var 2),
               template_var 3))
           ))),
    ("UTM.UTM_unhalt_lemma2",
     "[| tm_wf0 ?p; {%tp. tp = ([], <?args>)} ?p \<up>; ?args ~= [] |]
      ==> {%tp. tp = ([], <code ?p # ?args>)} UTM \<up>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 13,
              template_app
               (template_app (template_hole 12, template_var 1),
                template_hole 11))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 10, t_empty), template_var 1)
            ),
        template_negation
         (template_equation (template_var 0, template_hole 3))],
       template_predicate
        (
           template_app
            (template_app (template_hole 10, t_empty), template_hole 0)
           ))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_backto_standard_pos_2_B ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Bk # Bk \<up> ln @ Oc # ?ires &
          ?r = Bk # Oc \<up> Suc (Suc ?rs) @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_double_case_inv_simps",
     "wcode_erase1 ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Oc # ?ires &
          tl ?r = Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 11, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 10, template_var 1),
           template_var 0)),
       template_app (template_hole 9, t_empty))),
    ("UTM.wprepare_invs",
     "wprepare_add_one ?m ?lm (?l, ?r) =
      (EX rn.
          ?l = [] &
          (?r = <?m # ?lm> @ Bk \<up> rn |
           ?r = Bk # <?m # ?lm> @ Bk \<up> rn))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 12, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 11, template_var 1),
           template_var 0)),
       template_app (template_hole 10, t_empty))),
    ("UTM.wadjust_erase2_cases",
     "wadjust_erase2 ?m ?rs (?c, []) ==>
      (?c = [] --> wadjust_on_left_moving ?m ?rs ([], [Bk])) &
      (?c ~= [] --> wadjust_on_left_moving ?m ?rs (tl ?c, [hd ?c]))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 11, template_var 2),
                template_var 1),
              template_app
               (template_app (template_hole 10, template_var 0),
                template_hole 9))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app (template_hole 6, template_var 0),
                     template_hole 9)),
                 template_app
                  (template_app
                    (template_app (template_hole 5, template_var 2),
                     template_var 1),
                   template_app
                    (template_app (template_hole 10, template_hole 9),
                     template_app
                      (template_app (template_hole 4, template_hole 3),
                       template_hole 9))))),
             template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 6, template_var 0),
                     template_hole 9))),
               template_app
                (template_app
                  (template_app (template_hole 5, template_var 2),
                   template_var 1),
                 template_app
                  (template_app
                    (template_hole 10,
                     template_app (template_hole 1, template_var 0)),
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app (template_hole 0, template_var 0)),
                     template_hole 9)))))
           ))),
    ("UTM.wcode_goon_checking_cases",
     "wcode_goon_checking ?ires ?rs (?b, Oc # ?list) ==>
      (?b = [] --> wcode_right_move ?ires ?rs ([Oc], ?list)) &
      (?b ~= [] --> wcode_right_move ?ires ?rs (Oc # ?b, ?list))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 8, template_var 1),
                template_app
                 (template_app (template_hole 7, template_hole 6),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_hole 2)),
                 template_app
                  (template_app
                    (template_app (template_hole 1, template_var 3),
                     template_var 2),
                   template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_app (template_hole 7, template_hole 6),
                         template_hole 2)),
                     template_var 0)))),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_hole 0,
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_hole 2))),
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 3),
                   template_var 2),
                 template_app
                  (template_app
                    (template_hole 8,
                     template_app
                      (template_app (template_hole 7, template_hole 6),
                       template_var 1)),
                   template_var 0))))
           ))),
    ("UTM.wcode_goon_checking_3_cases",
     "wcode_goon_checking_3 ?ires ?rs (?b, Bk # ?list) ==>
      (?b = [] --> wcode_stop ?ires ?rs ([Bk], ?list)) &
      (?b ~= [] --> wcode_stop ?ires ?rs (Bk # ?b, ?list))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 8, template_var 1),
                template_app
                 (template_app (template_hole 7, template_hole 6),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_hole 2)),
                 template_app
                  (template_app
                    (template_app (template_hole 1, template_var 3),
                     template_var 2),
                   template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_app (template_hole 7, template_hole 6),
                         template_hole 2)),
                     template_var 0)))),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_hole 0,
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_hole 2))),
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 3),
                   template_var 2),
                 template_app
                  (template_app
                    (template_hole 8,
                     template_app
                      (template_app (template_hole 7, template_hole 6),
                       template_var 1)),
                   template_var 0))))
           ))),
    ("UTM.wprepare_add_one2_cases",
     "wprepare_add_one2 ?m ?lm (?b, Bk # ?list) ==>
      (?list = [] --> wprepare_add_one2 ?m ?lm (?b, [Oc])) &
      (?list ~= [] --> wprepare_add_one2 ?m ?lm (?b, Oc # ?list))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 8, template_var 1),
                template_app
                 (template_app (template_hole 7, template_hole 6),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 0),
                     template_hole 2)),
                 template_app
                  (template_app
                    (template_app (template_hole 9, template_var 3),
                     template_var 2),
                   template_app
                    (template_app (template_hole 8, template_var 1),
                     template_app
                      (template_app (template_hole 7, template_hole 1),
                       template_hole 2))))),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_hole 0,
                   template_app
                    (template_app (template_hole 3, template_var 0),
                     template_hole 2))),
               template_app
                (template_app
                  (template_app (template_hole 9, template_var 3),
                   template_var 2),
                 template_app
                  (template_app (template_hole 8, template_var 1),
                   template_app
                    (template_app (template_hole 7, template_hole 1),
                     template_var 0)))))
           ))),
    ("UTM.wprepare_goto_first_end_cases_Oc",
     "wprepare_goto_first_end ?m ?lm (?b, Oc # ?list) ==>
      (?b = [] --> wprepare_goto_first_end ?m ?lm ([Oc], ?list)) &
      (?b ~= [] --> wprepare_goto_first_end ?m ?lm (Oc # ?b, ?list))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 7, template_var 1),
                template_app
                 (template_app (template_hole 6, template_hole 5),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 2, template_var 1),
                     template_hole 1)),
                 template_app
                  (template_app
                    (template_app (template_hole 8, template_var 3),
                     template_var 2),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 6, template_hole 5),
                         template_hole 1)),
                     template_var 0)))),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_hole 0,
                   template_app
                    (template_app (template_hole 2, template_var 1),
                     template_hole 1))),
               template_app
                (template_app
                  (template_app (template_hole 8, template_var 3),
                   template_var 2),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, template_hole 5),
                       template_var 1)),
                   template_var 0))))
           ))),
    ("UTM.wcode_double_case_inv_simps",
     "wcode_on_checking_1 ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = ?ires &
          ?r =
          Oc #
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_double_case_inv_simps",
     "wcode_on_left_moving_1_O ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Oc # ?ires &
          ?r =
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_backto_standard_pos_2_exists",
     "wcode_backto_standard_pos_2 ?ires ?rs (?b, Bk # ?list) ==>
      (EX ln. ?b = Bk # Bk \<up> ln @ Oc # ?ires) &
      (EX rn. ?list = Oc \<up> Suc (Suc ?rs) @ Bk \<up> rn)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 10, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 9, template_var 1),
                template_app
                 (template_app (template_hole 8, template_hole 7),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 6, template_app (template_hole 5, t_empty)),
             template_app (template_hole 5, t_empty))
           ))),
    ("UTM.UTM_unhalt_lemma",
     "[| tm_wf0 ?p; {%tp. tp = (Bk \<up> ?i, <?args>)} ?p \<up>;
         ?args ~= [] |]
      ==> {%tp. tp = ([], <code ?p # ?args>)} UTM \<up>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 15,
              template_app
               (template_app (template_hole 14, template_var 2),
                template_hole 13))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 12, t_empty), template_var 2)
            ),
        template_negation
         (template_equation (template_var 0, template_hole 4))],
       template_predicate
        (
           template_app
            (template_app (template_hole 12, t_empty), template_hole 0)
           ))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_erase2 ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Bk # Oc # ?ires &
          tl ?r = Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 11, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 10, template_var 1),
           template_var 0)),
       template_app (template_hole 9, t_empty))),
    ("UTM.wprepare_invs",
     "wprepare_add_one2 ?m ?lm (?l, ?r) =
      (EX rn.
          ?l = Bk # Bk # <rev ?lm> @ Bk # Bk # Oc \<up> Suc ?m &
          (?r = [] | tl ?r = Bk \<up> rn))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 15, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 14, template_var 1),
           template_var 0)),
       template_app (template_hole 13, t_empty))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_goon_checking ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = ?ires &
          ?r =
          Oc #
          Bk #
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_halt_invs",
     "wcode_goon_checking_3 ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = ?ires &
          ?r =
          Bk #
          Bk #
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_on_checking_2 ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Oc # ?ires &
          ?r =
          Bk #
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_halt_invs",
     "wcode_on_checking_3 ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Bk # ?ires &
          ?r =
          Bk #
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_on_left_moving_2_O ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Bk # Oc # ?ires &
          ?r =
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_halt_invs",
     "wcode_on_left_moving_3_O ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Bk # Bk # ?ires &
          ?r =
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_right_move ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Oc # ?ires &
          ?r =
          Bk #
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.wcode_halt_invs",
     "wcode_stop ?ires ?rs (?l, ?r) =
      (EX ln rn.
          ?l = Bk # ?ires &
          ?r =
          Bk #
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 9, template_var 1), template_var 0)),
       template_app (template_hole 8, t_empty))),
    ("UTM.uabc_uhalt",
     "[| tm_wf0 ?tp;
         ALL stp. ~ TSTD (steps0 (Suc 0, Bk \<up> ?l, <?lm>) ?tp stp) |]
      ==> {%nl. nl = [code ?tp, bl2wc (<?lm>)]} F_aprog \<up>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 19,
              template_app
               (template_app (template_hole 18, template_var 2),
                template_hole 17))
            ),
        template_predicate (template_app (template_hole 16, t_empty))],
       template_predicate
        (
           template_app
            (template_app (template_hole 6, t_empty), template_hole 0)
           ))),
    ("UTM.twice_plus_28_elim",
     "(?a, ?b) : set (Turing.shift (adjust0 t_twice_compile) 12) ==>
      ?b <= (28 + (length t_twice_compile + length t_fourtimes_compile)) div
            2",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 15,
                template_app
                 (template_app (template_hole 14, template_var 1),
                  template_var 0)),
              template_app
               (template_hole 13,
                template_app
                 (template_app
                   (template_hole 12,
                    template_app
                     (template_app (template_hole 11, template_hole 10),
                      template_app
                       (template_hole 9,
                        template_app
                         (template_app
                           (template_hole 8,
                            template_app
                             (template_hole 7, template_hole 10)),
                          template_app
                           (template_hole 6,
                            template_app
                             (template_hole 5, template_hole 4)))))),
                  template_app
                   (template_hole 6,
                    template_app
                     (template_hole 5,
                      template_app
                       (template_hole 5,
                        template_app
                         (template_hole 3, template_hole 4)))))))
            )],
       template_inequation
        (less_equals, template_var 0,
         template_app
          (template_app
            (template_hole 8,
             template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_hole 6,
                   template_app
                    (template_hole 5,
                     template_app
                      (template_hole 5,
                       template_app
                        (template_hole 3,
                         template_app
                          (template_hole 3, template_hole 4)))))),
               template_app
                (template_app
                  (template_hole 1,
                   template_app (template_hole 7, template_hole 10)),
                 template_app (template_hole 7, template_hole 0)))),
           template_app
            (template_hole 6,
             template_app (template_hole 5, template_hole 4)))))),
    ("UTM.lg_bin",
     "[| ALL rs n. ?c ~= Oc \<up> Suc rs @ Bk \<up> n;
         bl2wc ?c = 2 ^ lg (Suc (bl2wc ?c)) 2 - Suc 0 |]
      ==> bl2wc ?c = 0",
     template_implication
      ([template_predicate (template_app (template_hole 16, t_empty)),
        template_equation
         (template_app (template_hole 7, template_var 0),
          template_app
           (template_app
             (template_hole 6,
              template_app
               (template_app
                 (template_hole 5,
                  template_app
                   (template_hole 4,
                    template_app (template_hole 3, template_hole 2))),
                template_app
                 (template_app
                   (template_hole 1,
                    template_app
                     (template_hole 11,
                      template_app (template_hole 7, template_var 0))),
                  template_app
                   (template_hole 4,
                    template_app (template_hole 3, template_hole 2))))),
            template_app (template_hole 11, template_hole 0)))],
       template_equation
        (template_app (template_hole 7, template_var 0), template_hole 0))),
    ("UTM.wprepare_invs",
     "wprepare_goto_first_end ?m ?lm (?l, ?r) =
      (EX ml mr rn.
          ?l = Oc \<up> ml &
          ?r = Oc \<up> mr @ Bk # <?lm> @ Bk \<up> rn &
          ml + mr = Suc (Suc ?m))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 13, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 12, template_var 1),
           template_var 0)),
       template_app (template_hole 11, t_empty))),
    ("UTM.wadjust_backto_standard_pos_cases",
     "wadjust_backto_standard_pos ?m ?rs (?c, Oc # ?list) ==>
      (?c = [] -->
       wadjust_backto_standard_pos ?m ?rs ([], Bk # Oc # ?list)) &
      (?c ~= [] -->
       wadjust_backto_standard_pos ?m ?rs (tl ?c, hd ?c # Oc # ?list))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 11, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 10, template_var 1),
                template_app
                 (template_app (template_hole 9, template_hole 8),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app
                  (template_hole 6,
                   template_app
                    (template_app (template_hole 5, template_var 1),
                     template_hole 4)),
                 template_app
                  (template_app
                    (template_app (template_hole 11, template_var 3),
                     template_var 2),
                   template_app
                    (template_app (template_hole 10, template_hole 4),
                     template_app
                      (template_app (template_hole 9, template_hole 3),
                       template_app
                        (template_app (template_hole 9, template_hole 8),
                         template_var 0)))))),
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_hole 2,
                   template_app
                    (template_app (template_hole 5, template_var 1),
                     template_hole 4))),
               template_app
                (template_app
                  (template_app (template_hole 11, template_var 3),
                   template_var 2),
                 template_app
                  (template_app
                    (template_hole 10,
                     template_app (template_hole 1, template_var 1)),
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app (template_hole 0, template_var 1)),
                     template_app
                      (template_app (template_hole 9, template_hole 8),
                       template_var 0))))))
           ))),
    ("UTM.length_plus_28_elim2",
     "(?a, ?b)
      : set (Turing.shift (adjust0 t_fourtimes_compile)
              (t_twice_len + 13)) ==>
      ?b <= (28 + (length t_twice_compile + length t_fourtimes_compile)) div
            2",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 16,
                template_app
                 (template_app (template_hole 15, template_var 1),
                  template_var 0)),
              template_app
               (template_hole 14,
                template_app
                 (template_app
                   (template_hole 13,
                    template_app
                     (template_app (template_hole 12, template_hole 11),
                      template_app
                       (template_hole 10,
                        template_app
                         (template_app
                           (template_hole 9,
                            template_app
                             (template_hole 8, template_hole 11)),
                          template_app
                           (template_hole 7,
                            template_app
                             (template_hole 6, template_hole 5)))))),
                  template_app
                   (template_app (template_hole 4, template_hole 3),
                    template_app
                     (template_hole 7,
                      template_app
                       (template_hole 2,
                        template_app
                         (template_hole 6,
                          template_app
                           (template_hole 2, template_hole 5))))))))
            )],
       template_inequation
        (less_equals, template_var 0,
         template_app
          (template_app
            (template_hole 9,
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_hole 7,
                   template_app
                    (template_hole 6,
                     template_app
                      (template_hole 6,
                       template_app
                        (template_hole 2,
                         template_app
                          (template_hole 2, template_hole 5)))))),
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 8, template_hole 0)),
                 template_app (template_hole 8, template_hole 11)))),
           template_app
            (template_hole 7,
             template_app (template_hole 6, template_hole 5)))))),
    ("UTM.wprepare_goto_first_end_cases",
     "[| ?lm ~= []; wprepare_add_one ?m ?lm (?b, Bk # ?list) |]
      ==> (?b = [] --> wprepare_goto_first_end ?m ?lm ([], Oc # ?list)) &
          (?b ~= [] --> wprepare_goto_first_end ?m ?lm (?b, Oc # ?list))",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 10)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 9, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 8, template_var 1),
                template_app
                 (template_app (template_hole 7, template_hole 6),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_hole 2)),
                 template_app
                  (template_app
                    (template_app (template_hole 1, template_var 2),
                     template_var 3),
                   template_app
                    (template_app (template_hole 8, template_hole 2),
                     template_app
                      (template_app (template_hole 7, template_hole 0),
                       template_var 0))))),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_hole 12,
                   template_app
                    (template_app (template_hole 3, template_var 1),
                     template_hole 2))),
               template_app
                (template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 3),
                 template_app
                  (template_app (template_hole 8, template_var 1),
                   template_app
                    (template_app (template_hole 7, template_hole 0),
                     template_var 0)))))
           ))),
    ("UTM.wprepare_loop_goon_wprepare_add_one2_cases",
     "[| ?lm ~= []; wprepare_loop_goon ?m ?lm (?b, Bk # ?list) |]
      ==> (?list = [] --> wprepare_add_one2 ?m ?lm (Bk # ?b, [])) &
          (?list ~= [] --> wprepare_add_one2 ?m ?lm (Bk # ?b, ?list))",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 9)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 7, template_var 1),
                template_app
                 (template_app (template_hole 6, template_hole 5),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     template_hole 1)),
                 template_app
                  (template_app
                    (template_app (template_hole 0, template_var 2),
                     template_var 3),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 6, template_hole 5),
                         template_var 1)),
                     template_hole 1)))),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_hole 11,
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     template_hole 1))),
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 2),
                   template_var 3),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, template_hole 5),
                       template_var 1)),
                   template_var 0))))
           ))),
    ("UTM.start_2_goon",
     "[| ?lm ~= []; wprepare_loop_start ?m ?lm (?b, Bk # ?list) |]
      ==> (?list = [] --> wprepare_loop_goon ?m ?lm (Bk # ?b, [])) &
          (?list ~= [] --> wprepare_loop_goon ?m ?lm (Bk # ?b, ?list))",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_hole 9)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 8, template_var 2),
                template_var 3),
              template_app
               (template_app (template_hole 7, template_var 1),
                template_app
                 (template_app (template_hole 6, template_hole 5),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     template_hole 1)),
                 template_app
                  (template_app
                    (template_app (template_hole 0, template_var 2),
                     template_var 3),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 6, template_hole 5),
                         template_var 1)),
                     template_hole 1)))),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_hole 11,
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     template_hole 1))),
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 2),
                   template_var 3),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, template_hole 5),
                       template_var 1)),
                   template_var 0))))
           ))),
    ("UTM.nonstop_true",
     "[| tm_wf0 ?tp;
         ALL stp. ~ TSTD (steps0 (Suc 0, Bk \<up> ?l, <?lm>) ?tp stp) |]
      ==> ALL y. rec_exec rec_nonstop [code ?tp, bl2wc (<?lm>), y] = Suc 0",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 19,
              template_app
               (template_app (template_hole 18, template_var 2),
                template_hole 17))
            ),
        template_predicate (template_app (template_hole 16, t_empty))],
       template_predicate (template_app (template_hole 16, t_empty)))),
    ("UTM.wcode_double_case_inv_simps",
     "wcode_on_right_moving_1 ?ires ?rs (?l, ?r) =
      (EX ml mr rn.
          ?l = Bk \<up> ml @ Oc # ?ires &
          ?r = Bk \<up> mr @ Oc \<up> Suc ?rs @ Bk \<up> rn &
          Suc 0 < ml + mr)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 13, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 12, template_var 1),
           template_var 0)),
       template_app (template_hole 11, t_empty))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_on_right_moving_2 ?ires ?rs (?l, ?r) =
      (EX ml mr rn.
          ?l = Bk \<up> ml @ Oc # ?ires &
          ?r = Bk \<up> mr @ Oc \<up> Suc ?rs @ Bk \<up> rn &
          Suc 0 < ml + mr)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 13, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 12, template_var 1),
           template_var 0)),
       template_app (template_hole 11, t_empty))),
    ("UTM.wcode_lemma",
     "?args ~= [] ==>
      EX stp ln rn.
         steps0 (Suc 0, [], <?m # ?args>) t_wcode stp =
         (0, [Bk], <[?m, bl_bin (<?args>)]> @ Bk \<up> rn)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 18))],
       template_predicate (template_app (template_hole 17, t_empty)))),
    ("UTM.adjust_fetch0",
     "[| 0 < ?a; ?a <= length ?ap div 2; fetch ?ap ?a ?b = (?aa, 0) |]
      ==> fetch (adjust0 ?ap) ?a ?b = (?aa, Suc (length ?ap div 2))",
     template_implication
      ([template_inequation (less_than, template_hole 11, template_var 3),
        template_inequation
         (less_equals, template_var 3,
          template_app
           (template_app
             (template_hole 9,
              template_app (template_hole 8, template_var 2)),
            template_app
             (template_hole 7,
              template_app (template_hole 6, template_hole 5)))),
        template_equation
         (template_app
           (template_app
             (template_app (template_hole 3, template_var 2),
              template_var 3),
            template_var 1),
          template_app
           (template_app (template_hole 2, template_var 0),
            template_hole 11))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 1, template_var 2),
                 template_app
                  (template_hole 0,
                   template_app
                    (template_app
                      (template_hole 9,
                       template_app (template_hole 8, template_var 2)),
                     template_app
                      (template_hole 7,
                       template_app (template_hole 6, template_hole 5)))))),
             template_var 3),
           template_var 1),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_app
            (template_hole 0,
             template_app
              (template_app
                (template_hole 9,
                 template_app (template_hole 8, template_var 2)),
               template_app
                (template_hole 7,
                 template_app (template_hole 6, template_hole 5)))))))),
    ("UTM.adjust_fetch_norm",
     "[| 0 < ?st; ?st <= length ?tp div 2; fetch ?ap ?st ?b = (?aa, ?ns);
         ?ns ~= 0 |]
      ==> fetch (adjust0 ?ap) ?st ?b = (?aa, ?ns)",
     template_implication
      ([template_inequation (less_than, template_hole 14, template_var 5),
        template_inequation
         (less_equals, template_var 5,
          template_app
           (template_app
             (template_hole 12,
              template_app (template_hole 11, template_var 4)),
            template_app
             (template_hole 10,
              template_app (template_hole 9, template_hole 8)))),
        template_equation
         (template_app
           (template_app
             (template_app (template_hole 6, template_var 3),
              template_var 5),
            template_var 2),
          template_app
           (template_app (template_hole 5, template_var 1),
            template_var 0)),
        template_negation
         (template_equation (template_var 0, template_hole 14))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 2, template_var 3),
                 template_app
                  (template_hole 1,
                   template_app
                    (template_app
                      (template_hole 12,
                       template_app (template_hole 0, template_var 3)),
                     template_app
                      (template_hole 10,
                       template_app (template_hole 9, template_hole 8)))))),
             template_var 5),
           template_var 2),
         template_app
          (template_app (template_hole 5, template_var 1),
           template_var 0)))),
    ("UTM.wcode_double_case_inv_simps",
     "wcode_goon_right_moving_1 ?ires ?rs (?l, ?r) =
      (EX ml mr ln rn.
          ?l = Oc \<up> ml @ Bk # Bk # Bk \<up> ln @ Oc # ?ires &
          ?r = Oc \<up> mr @ Bk \<up> rn & ml + mr = Suc ?rs)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 12, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 11, template_var 1),
           template_var 0)),
       template_app (template_hole 10, t_empty))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_goon_right_moving_2 ?ires ?rs (?l, ?r) =
      (EX ml mr ln rn.
          ?l = Oc \<up> ml @ Bk # Bk # Bk \<up> ln @ Oc # ?ires &
          ?r = Oc \<up> mr @ Bk \<up> rn & ml + mr = Suc ?rs)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 12, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 11, template_var 1),
           template_var 0)),
       template_app (template_hole 10, t_empty))),
    ("UTM.uabc_uhalt'",
     "[| tm_wf0 ?tp;
         ALL stp. ~ TSTD (steps0 (Suc 0, Bk \<up> ?l, <?lm>) ?tp stp);
         rec_ci rec_F = (?ap, ?pos, ?md) |]
      ==> {%nl. nl = [code ?tp, bl2wc (<?lm>)]} ?ap \<up>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 23,
              template_app
               (template_app (template_hole 22, template_var 5),
                template_hole 21))
            ),
        template_predicate (template_app (template_hole 20, t_empty)),
        template_equation
         (template_app (template_hole 9, template_hole 8),
          template_app
           (template_app (template_hole 7, template_var 2),
            template_app
             (template_app (template_hole 6, template_var 1),
              template_var 0)))],
       template_predicate
        (
           template_app
            (template_app (template_hole 5, t_empty), template_var 2)
           ))),
    ("UTM.wcode_double_case_inv_simps",
     "wcode_on_left_moving_1_B ?ires ?rs (?l, ?r) =
      (EX ml mr rn.
          ?l = Bk \<up> ml @ Oc # Oc # ?ires &
          ?r = Bk \<up> mr @ Oc \<up> Suc ?rs @ Bk \<up> rn &
          Suc 0 < ml + mr & 0 < mr)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 13, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 12, template_var 1),
           template_var 0)),
       template_app (template_hole 11, t_empty))),
    ("UTM.wcode_lemma_1",
     "?args ~= [] ==>
      EX stp ln rn.
         steps0 (Suc 0, [], <?m # ?args>) t_wcode stp =
         (0, [Bk],
          Oc \<up> Suc ?m @
          Bk # Oc \<up> Suc (bl_bin (<?args>)) @ Bk \<up> rn)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 19))],
       template_predicate (template_app (template_hole 18, t_empty)))),
    ("UTM.tinres_step1",
     "[| tinres ?l ?l'; step0 (?ss, ?l, ?r) ?t = (?sa, ?la, ?ra);
         step0 (?ss, ?l', ?r) ?t = (?sb, ?lb, ?rb) |]
      ==> tinres ?la ?lb & ?ra = ?rb & ?sa = ?sb",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 10),
              template_var 9)
            ),
        template_equation
         (template_app
           (template_app
             (template_hole 7,
              template_app
               (template_app (template_hole 6, template_var 8),
                template_app
                 (template_app (template_hole 5, template_var 10),
                  template_var 7))),
            template_app
             (template_app (template_hole 4, template_var 6),
              template_hole 3)),
          template_app
           (template_app (template_hole 6, template_var 5),
            template_app
             (template_app (template_hole 5, template_var 4),
              template_var 3))),
        template_equation
         (template_app
           (template_app
             (template_hole 7,
              template_app
               (template_app (template_hole 6, template_var 8),
                template_app
                 (template_app (template_hole 5, template_var 9),
                  template_var 7))),
            template_app
             (template_app (template_hole 4, template_var 6),
              template_hole 3)),
          template_app
           (template_app (template_hole 6, template_var 2),
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0)))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 9, template_var 4),
                 template_var 1)),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 3),
                   template_var 0)),
               template_app
                (template_app (template_hole 0, template_var 5),
                 template_var 2)))
           ))),
    ("UTM.tinres_step2",
     "[| tinres ?r ?r'; step0 (?ss, ?l, ?r) ?t = (?sa, ?la, ?ra);
         step0 (?ss, ?l, ?r') ?t = (?sb, ?lb, ?rb) |]
      ==> ?la = ?lb & tinres ?ra ?rb & ?sa = ?sb",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 10),
              template_var 9)
            ),
        template_equation
         (template_app
           (template_app
             (template_hole 7,
              template_app
               (template_app (template_hole 6, template_var 8),
                template_app
                 (template_app (template_hole 5, template_var 7),
                  template_var 10))),
            template_app
             (template_app (template_hole 4, template_var 6),
              template_hole 3)),
          template_app
           (template_app (template_hole 6, template_var 5),
            template_app
             (template_app (template_hole 5, template_var 4),
              template_var 3))),
        template_equation
         (template_app
           (template_app
             (template_hole 7,
              template_app
               (template_app (template_hole 6, template_var 8),
                template_app
                 (template_app (template_hole 5, template_var 7),
                  template_var 9))),
            template_app
             (template_app (template_hole 4, template_var 6),
              template_hole 3)),
          template_app
           (template_app (template_hole 6, template_var 2),
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0)))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 1)),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 9, template_var 3),
                   template_var 0)),
               template_app
                (template_app (template_hole 0, template_var 5),
                 template_var 2)))
           ))),
    ("UTM.tutm_uhalt'",
     "[| tm_wf0 ?tp;
         ALL stp. ~ TSTD (steps0 (1, Bk \<up> ?l, <?lm>) ?tp stp) |]
      ==> ALL stp.
             ~ is_final
                (steps0 (1, [Bk, Bk], <[code ?tp, bl2wc (<?lm>)]>) t_utm
                  stp)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 21,
              template_app
               (template_app (template_hole 20, template_var 2),
                template_hole 19))
            ),
        template_predicate (template_app (template_hole 18, t_empty))],
       template_predicate (template_app (template_hole 18, t_empty)))),
    ("UTM.UTM_uhalt_lemma'",
     "[| tm_wf0 ?tp;
         ALL stp. ~ TSTD (steps0 (Suc 0, Bk \<up> ?l, <?args>) ?tp stp);
         ?args ~= [] |]
      ==> ALL stp.
             ~ is_final (steps0 (Suc 0, [], <code ?tp # ?args>) UTM stp)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 19,
              template_app
               (template_app (template_hole 18, template_var 2),
                template_hole 17))
            ),
        template_predicate (template_app (template_hole 16, t_empty)),
        template_negation
         (template_equation (template_var 0, template_hole 5))],
       template_predicate (template_app (template_hole 16, t_empty)))),
    ("UTM.UTM_uhalt_lemma_pre",
     "[| tm_wf0 ?tp;
         ALL stp. ~ TSTD (steps0 (Suc 0, Bk \<up> ?l, <?args>) ?tp stp);
         ?args ~= [] |]
      ==> ALL stp.
             ~ is_final
                (steps0 (Suc 0, [], <code ?tp # ?args>) UTM_pre stp)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 19,
              template_app
               (template_app (template_hole 18, template_var 2),
                template_hole 17))
            ),
        template_predicate (template_app (template_hole 16, t_empty)),
        template_negation
         (template_equation (template_var 0, template_hole 5))],
       template_predicate (template_app (template_hole 16, t_empty)))),
    ("UTM.adjust_step_eq",
     "[| step0 (?st, ?l, ?r) ?ap = (?st', ?l', ?r'); tm_wf0 ?ap; 0 < ?st' |]
      ==> step0 (?st, ?l, ?r) (adjust0 ?ap) = (?st', ?l', ?r')",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_hole 13,
              template_app
               (template_app (template_hole 12, template_var 6),
                template_app
                 (template_app (template_hole 11, template_var 5),
                  template_var 4))),
            template_app
             (template_app (template_hole 10, template_var 3),
              template_hole 9)),
          template_app
           (template_app (template_hole 12, template_var 2),
            template_app
             (template_app (template_hole 11, template_var 1),
              template_var 0))),
        template_predicate
         (
            template_app
             (template_hole 8,
              template_app
               (template_app (template_hole 10, template_var 3),
                template_hole 9))
            ),
        template_inequation (less_than, template_hole 9, template_var 2)],
       template_equation
        (template_app
          (template_app
            (template_hole 13,
             template_app
              (template_app (template_hole 12, template_var 6),
               template_app
                (template_app (template_hole 11, template_var 5),
                 template_var 4))),
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app (template_hole 6, template_var 3),
                 template_app
                  (template_hole 5,
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app (template_hole 3, template_var 3)),
                     template_app
                      (template_hole 2,
                       template_app (template_hole 1, template_hole 0)))))),
             template_hole 9)),
         template_app
          (template_app (template_hole 12, template_var 2),
           template_app
            (template_app (template_hole 11, template_var 1),
             template_var 0))))),
    ("UTM.bl_bin_addition",
     "bl_bin
       (Oc \<up> Suc ?aa @ Bk # tape_of_nat_list (?a # ?lista) @ [Bk, Oc]) =
      bl_bin (Oc \<up> Suc ?aa @ Bk # tape_of_nat_list (?a # ?lista)) +
      2 *
      2 ^ length (Oc \<up> Suc ?aa @ Bk # tape_of_nat_list (?a # ?lista))",
     template_equation
      (template_app
        (template_hole 16,
         template_app
          (template_app
            (template_hole 15,
             template_app
              (template_app
                (template_hole 14,
                 template_app (template_hole 13, template_var 2)),
               template_hole 12)),
           template_app
            (template_app (template_hole 11, template_hole 10),
             template_app
              (template_app
                (template_hole 15,
                 template_app
                  (template_hole 9,
                   template_app
                    (template_app (template_hole 8, template_var 1),
                     template_var 0))),
               template_app
                (template_app (template_hole 11, template_hole 10),
                 template_app
                  (template_app (template_hole 11, template_hole 12),
                   template_hole 7)))))),
       template_app
        (template_app
          (template_hole 6,
           template_app
            (template_hole 16,
             template_app
              (template_app
                (template_hole 15,
                 template_app
                  (template_app
                    (template_hole 14,
                     template_app (template_hole 13, template_var 2)),
                   template_hole 12)),
               template_app
                (template_app (template_hole 11, template_hole 10),
                 template_app
                  (template_hole 9,
                   template_app
                    (template_app (template_hole 8, template_var 1),
                     template_var 0)))))),
         template_app
          (template_app
            (template_hole 5,
             template_app
              (template_hole 4,
               template_app (template_hole 3, template_hole 2))),
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_hole 4,
                 template_app (template_hole 3, template_hole 2))),
             template_app
              (template_hole 0,
               template_app
                (template_app
                  (template_hole 15,
                   template_app
                    (template_app
                      (template_hole 14,
                       template_app (template_hole 13, template_var 2)),
                     template_hole 12)),
                 template_app
                  (template_app (template_hole 11, template_hole 10),
                   template_app
                    (template_hole 9,
                     template_app
                      (template_app (template_hole 8, template_var 1),
                       template_var 0)))))))))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_on_left_moving_2_B ?ires ?rs (?l, ?r) =
      (EX ml mr rn.
          ?l = Bk \<up> ml @ Oc # Bk # Oc # ?ires &
          ?r = Bk \<up> mr @ Oc \<up> Suc ?rs @ Bk \<up> rn &
          Suc 0 < ml + mr & 0 < mr)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 13, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 12, template_var 1),
           template_var 0)),
       template_app (template_hole 11, t_empty))),
    ("UTM.wcode_halt_invs",
     "wcode_on_left_moving_3_B ?ires ?rs (?l, ?r) =
      (EX ml mr rn.
          ?l = Bk \<up> ml @ Oc # Bk # Bk # ?ires &
          ?r = Bk \<up> mr @ Oc \<up> Suc ?rs @ Bk \<up> rn &
          Suc 0 < ml + mr & 0 < mr)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 13, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 12, template_var 1),
           template_var 0)),
       template_app (template_hole 11, t_empty))),
    ("UTM.wcode_lemma_pre'",
     "?args ~= [] ==>
      EX stp rn.
         steps0 (Suc 0, [], <?m # ?args>)
          (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =
         (0, [Bk],
          Oc \<up> Suc ?m @
          Bk # Oc \<up> Suc (bl_bin (<?args>)) @ Bk \<up> rn)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 21))],
       template_predicate (template_app (template_hole 20, t_empty)))),
    ("UTM.tinres_steps1",
     "[| tinres ?l ?l'; steps0 (?ss, ?l, ?r) ?t ?stp = (?sa, ?la, ?ra);
         steps0 (?ss, ?l', ?r) ?t ?stp = (?sb, ?lb, ?rb) |]
      ==> tinres ?la ?lb & ?ra = ?rb & ?sa = ?sb",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 11),
              template_var 10)
            ),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 9),
                  template_app
                   (template_app (template_hole 5, template_var 11),
                    template_var 8))),
              template_app
               (template_app (template_hole 4, template_var 7),
                template_hole 3)),
            template_var 6),
          template_app
           (template_app (template_hole 6, template_var 5),
            template_app
             (template_app (template_hole 5, template_var 4),
              template_var 3))),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 9),
                  template_app
                   (template_app (template_hole 5, template_var 10),
                    template_var 8))),
              template_app
               (template_app (template_hole 4, template_var 7),
                template_hole 3)),
            template_var 6),
          template_app
           (template_app (template_hole 6, template_var 2),
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0)))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 9, template_var 4),
                 template_var 1)),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 3),
                   template_var 0)),
               template_app
                (template_app (template_hole 0, template_var 5),
                 template_var 2)))
           ))),
    ("UTM.tinres_steps2",
     "[| tinres ?r ?r'; steps0 (?ss, ?l, ?r) ?t ?stp = (?sa, ?la, ?ra);
         steps0 (?ss, ?l, ?r') ?t ?stp = (?sb, ?lb, ?rb) |]
      ==> ?la = ?lb & tinres ?ra ?rb & ?sa = ?sb",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 9, template_var 11),
              template_var 10)
            ),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 9),
                  template_app
                   (template_app (template_hole 5, template_var 8),
                    template_var 11))),
              template_app
               (template_app (template_hole 4, template_var 7),
                template_hole 3)),
            template_var 6),
          template_app
           (template_app (template_hole 6, template_var 5),
            template_app
             (template_app (template_hole 5, template_var 4),
              template_var 3))),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 9),
                  template_app
                   (template_app (template_hole 5, template_var 8),
                    template_var 10))),
              template_app
               (template_app (template_hole 4, template_var 7),
                template_hole 3)),
            template_var 6),
          template_app
           (template_app (template_hole 6, template_var 2),
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0)))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 1)),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 9, template_var 3),
                   template_var 0)),
               template_app
                (template_app (template_hole 0, template_var 5),
                 template_var 2)))
           ))),
    ("UTM.nonstop_t_uhalt_eq",
     "[| tm_wf0 ?tp;
         steps0 (Suc 0, Bk \<up> ?l, <?lm>) ?tp ?stp = (?a, ?b, ?c);
         ~ TSTD (?a, ?b, ?c) |]
      ==> rec_exec rec_nonstop [code ?tp, bl2wc (<?lm>), ?stp] = Suc 0",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 19,
              template_app
               (template_app (template_hole 18, template_var 6),
                template_hole 17))
            ),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 15,
                template_app
                 (template_app
                   (template_hole 14,
                    template_app (template_hole 13, template_hole 17)),
                  template_app
                   (template_app
                     (template_hole 12,
                      template_app
                       (template_app (template_hole 11, template_var 5),
                        template_hole 10)),
                    template_app (template_hole 9, template_var 4)))),
              template_app
               (template_app (template_hole 18, template_var 6),
                template_hole 17)),
            template_var 3),
          template_app
           (template_app (template_hole 14, template_var 2),
            template_app
             (template_app (template_hole 12, template_var 1),
              template_var 0))),
        template_negation
         (
            template_predicate
             (
                template_app
                 (template_hole 7,
                  template_app
                   (template_app (template_hole 14, template_var 2),
                    template_app
                     (template_app (template_hole 12, template_var 1),
                      template_var 0)))
                )
            )],
       template_equation
        (template_app
          (template_app (template_hole 5, template_hole 4),
           template_app
            (template_app
              (template_hole 3,
               template_app (template_hole 2, template_var 6)),
             template_app
              (template_app
                (template_hole 3,
                 template_app
                  (template_hole 1,
                   template_app (template_hole 9, template_var 4))),
               template_app
                (template_app (template_hole 3, template_var 3),
                 template_hole 0)))),
         template_app (template_hole 13, template_hole 17)))),
    ("UTM.wprepare_loop1",
     "[| rev ?b @ Oc \<up> ?mr = Oc \<up> Suc ?m @ Bk # Bk # <?lm>;
         ?b ~= []; 0 < ?mr; Oc # ?list = Oc \<up> ?mr @ Bk \<up> ?rn |]
      ==> wprepare_loop_start_on_rightmost ?m ?lm (Oc # ?b, ?list)",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_hole 13,
              template_app (template_hole 12, template_var 5)),
            template_app
             (template_app (template_hole 11, template_var 4),
              template_hole 10)),
          template_app
           (template_app
             (template_hole 13,
              template_app
               (template_app
                 (template_hole 11,
                  template_app (template_hole 9, template_var 3)),
                template_hole 10)),
            template_app
             (template_app (template_hole 8, template_hole 7),
              template_app
               (template_app (template_hole 8, template_hole 7),
                template_app (template_hole 6, template_var 2))))),
        template_negation
         (template_equation (template_var 5, template_hole 4)),
        template_inequation (less_than, template_hole 2, template_var 4),
        template_equation
         (template_app
           (template_app (template_hole 8, template_hole 10),
            template_var 1),
          template_app
           (template_app
             (template_hole 13,
              template_app
               (template_app (template_hole 11, template_var 4),
                template_hole 10)),
            template_app
             (template_app (template_hole 11, template_var 0),
              template_hole 7)))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 0,
                 template_app
                  (template_app (template_hole 8, template_hole 10),
                   template_var 5)),
               template_var 1))
           ))),
    ("UTM.adjust_steps_eq",
     "[| steps0 (?st, ?l, ?r) ?ap ?stp = (?st', ?l', ?r'); tm_wf0 ?ap;
         0 < ?st' |]
      ==> steps0 (?st, ?l, ?r) (adjust0 ?ap) ?stp = (?st', ?l', ?r')",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 13,
                template_app
                 (template_app (template_hole 12, template_var 7),
                  template_app
                   (template_app (template_hole 11, template_var 6),
                    template_var 5))),
              template_app
               (template_app (template_hole 10, template_var 4),
                template_hole 9)),
            template_var 3),
          template_app
           (template_app (template_hole 12, template_var 2),
            template_app
             (template_app (template_hole 11, template_var 1),
              template_var 0))),
        template_predicate
         (
            template_app
             (template_hole 8,
              template_app
               (template_app (template_hole 10, template_var 4),
                template_hole 9))
            ),
        template_inequation (less_than, template_hole 9, template_var 2)],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 13,
               template_app
                (template_app (template_hole 12, template_var 7),
                 template_app
                  (template_app (template_hole 11, template_var 6),
                   template_var 5))),
             template_app
              (template_app
                (template_hole 10,
                 template_app
                  (template_app (template_hole 6, template_var 4),
                   template_app
                    (template_hole 5,
                     template_app
                      (template_app
                        (template_hole 4,
                         template_app (template_hole 3, template_var 4)),
                       template_app
                        (template_hole 2,
                         template_app
                          (template_hole 1, template_hole 0)))))),
               template_hole 9)),
           template_var 3),
         template_app
          (template_app (template_hole 12, template_var 2),
           template_app
            (template_app (template_hole 11, template_var 1),
             template_var 0))))),
    ("UTM.t_twice_change_term_state",
     "EX stp ln rn.
         steps0 (Suc 0, Bk # Bk # ?ires, Oc \<up> Suc ?rs @ Bk \<up> ?n)
          t_twice stp =
         (Suc t_twice_len, Bk \<up> ln @ Bk # Bk # ?ires,
          Oc \<up> Suc (2 * ?rs) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 18, t_empty))),
    ("UTM.wcode_fourtimes_invs",
     "wcode_backto_standard_pos_2_O ?ires ?rs (?l, ?r) =
      (EX ml mr ln rn.
          ?l = Oc \<up> ml @ Bk # Bk # Bk \<up> ln @ Oc # ?ires &
          ?r = Oc \<up> mr @ Bk \<up> rn &
          ml + mr = Suc (Suc ?rs) & 0 < mr)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 14, template_var 3), template_var 2),
         template_app
          (template_app (template_hole 13, template_var 1),
           template_var 0)),
       template_app (template_hole 12, t_empty))),
    ("UTM.t_fourtimes_change_term_state",
     "EX stp ln rn.
         steps0 (Suc 0, Bk # Bk # ?ires, Oc \<up> Suc ?rs @ Bk \<up> ?n)
          t_fourtimes stp =
         (Suc t_fourtimes_len, Bk \<up> ln @ Bk # Bk # ?ires,
          Oc \<up> Suc (4 * ?rs) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 18, t_empty))),
    ("UTM.bl_bin_3",
     "bl_bin (Oc # Oc \<up> ?aa @ Bk # <?list @ [?ab]> @ [Oc]) =
      bl_bin (Oc # Oc \<up> ?aa @ Bk # <?list @ [?ab]>) +
      2 ^ length (Oc # Oc \<up> ?aa @ Bk # <?list @ [?ab]>)",
     template_equation
      (template_app
        (template_hole 16,
         template_app
          (template_app (template_hole 15, template_hole 14),
           template_app
            (template_app
              (template_hole 13,
               template_app
                (template_app (template_hole 12, template_var 2),
                 template_hole 14)),
             template_app
              (template_app (template_hole 15, template_hole 11),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_hole 10,
                     template_app
                      (template_app (template_hole 9, template_var 1),
                       template_app
                        (template_app (template_hole 8, template_var 0),
                         template_hole 7)))),
                 template_app
                  (template_app (template_hole 15, template_hole 14),
                   template_hole 6)))))),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_hole 16,
             template_app
              (template_app (template_hole 15, template_hole 14),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_app (template_hole 12, template_var 2),
                     template_hole 14)),
                 template_app
                  (template_app (template_hole 15, template_hole 11),
                   template_app
                    (template_hole 10,
                     template_app
                      (template_app (template_hole 9, template_var 1),
                       template_app
                        (template_app (template_hole 8, template_var 0),
                         template_hole 7)))))))),
         template_app
          (template_app
            (template_hole 4,
             template_app
              (template_hole 3,
               template_app (template_hole 2, template_hole 1))),
           template_app
            (template_hole 0,
             template_app
              (template_app (template_hole 15, template_hole 14),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_app (template_hole 12, template_var 2),
                     template_hole 14)),
                 template_app
                  (template_app (template_hole 15, template_hole 11),
                   template_app
                    (template_hole 10,
                     template_app
                      (template_app (template_hole 9, template_var 1),
                       template_app
                        (template_app (template_hole 8, template_var 0),
                         template_hole 7))))))))))),
    ("UTM.tutm_uhalt",
     "[| tm_wf0 ?tp;
         ALL stp. ~ TSTD (steps0 (Suc 0, Bk \<up> ?l, <?args>) ?tp stp) |]
      ==> ALL stp.
             ~ is_final
                (steps0
                  (Suc 0, Bk \<up> ?m,
                   <[code ?tp, bl2wc (<?args>)]> @ Bk \<up> ?n)
                  t_utm stp)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 20,
              template_app
               (template_app (template_hole 19, template_var 4),
                template_hole 18))
            ),
        template_predicate (template_app (template_hole 17, t_empty))],
       template_predicate (template_app (template_hole 17, t_empty)))),
    ("UTM.wprepare_correctness",
     "?lm ~= [] ==>
      let P = %(st, l, r). st = 0;
          Q = %(st, l, r). wprepare_inv st ?m ?lm (l, r);
          f = steps0 (Suc 0, [], <?m # ?lm>) t_wcode_prepare
      in EX n. P (f n) & Q (f n)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 18))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 17, template_app (template_hole 16, t_empty)),
             t_empty)
           ))),
    ("UTM.adjust_halt_eq",
     "[| steps0 (1, ?l, ?r) ?ap ?stp = (0, ?l', ?r'); tm_wf0 ?ap |]
      ==> EX stp.
             steps0 (Suc 0, ?l, ?r) (adjust0 ?ap) stp =
             (Suc (length ?ap div 2), ?l', ?r')",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 14,
                template_app
                 (template_app (template_hole 13, template_hole 12),
                  template_app
                   (template_app (template_hole 11, template_var 5),
                    template_var 4))),
              template_app
               (template_app (template_hole 10, template_var 3),
                template_hole 9)),
            template_var 2),
          template_app
           (template_app (template_hole 13, template_hole 9),
            template_app
             (template_app (template_hole 11, template_var 1),
              template_var 0))),
        template_predicate
         (
            template_app
             (template_hole 8,
              template_app
               (template_app (template_hole 10, template_var 3),
                template_hole 9))
            )],
       template_predicate (template_app (template_hole 7, t_empty)))),
    ("UTM.F_aprog_uhalt",
     "[| tm_wf0 ?tp;
         ALL stp. ~ TSTD (steps0 (Suc 0, Bk \<up> ?l, <?lm>) ?tp stp);
         rec_ci rec_F = (?F_ap, ?rs_pos, ?a_md) |]
      ==> {%nl. nl =
                [code ?tp, bl2wc (<?lm>)] @
                0 \<up> (?a_md - ?rs_pos) @ ?suflm}
          ?F_ap \<up>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 26,
              template_app
               (template_app (template_hole 25, template_var 6),
                template_hole 24))
            ),
        template_predicate (template_app (template_hole 23, t_empty)),
        template_equation
         (template_app (template_hole 12, template_hole 11),
          template_app
           (template_app (template_hole 10, template_var 3),
            template_app
             (template_app (template_hole 9, template_var 2),
              template_var 1)))],
       template_predicate
        (
           template_app
            (template_app (template_hole 8, t_empty), template_var 3)
           ))),
    ("UTM.inres_tape",
     "[| steps0 (?st, ?l, ?r) ?tp ?stp = (?a, ?b, ?c);
         steps0 (?st, ?l', ?r') ?tp ?stp = (?a', ?b', ?c'); tinres ?l ?l';
         tinres ?r ?r' |]
      ==> ?a = ?a' & tinres ?b ?b' & tinres ?c ?c'",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 12),
                  template_app
                   (template_app (template_hole 5, template_var 11),
                    template_var 10))),
              template_app
               (template_app (template_hole 4, template_var 9),
                template_hole 3)),
            template_var 8),
          template_app
           (template_app (template_hole 6, template_var 7),
            template_app
             (template_app (template_hole 5, template_var 6),
              template_var 5))),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 12),
                  template_app
                   (template_app (template_hole 5, template_var 4),
                    template_var 3))),
              template_app
               (template_app (template_hole 4, template_var 9),
                template_hole 3)),
            template_var 8),
          template_app
           (template_app (template_hole 6, template_var 2),
            template_app
             (template_app (template_hole 5, template_var 1),
              template_var 0))),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 11),
              template_var 4)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 10),
              template_var 3)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app (template_hole 0, template_var 7),
                 template_var 2)),
             template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app (template_hole 2, template_var 6),
                   template_var 1)),
               template_app
                (template_app (template_hole 2, template_var 5),
                 template_var 0)))
           ))),
    ("UTM.tape_normalize",
     "ALL stp.
         ~ is_final
            (steps0 (Suc 0, [Bk, Bk], <[code ?tp, bl2wc (<?lm>)]>) t_utm
              stp) ==>
      ALL stp.
         ~ is_final
            (steps0
              (Suc 0, Bk \<up> ?m,
               <[code ?tp, bl2wc (<?lm>)]> @ Bk \<up> ?n)
              t_utm stp)",
     template_implication
      ([template_predicate (template_app (template_hole 20, t_empty))],
       template_predicate (template_app (template_hole 20, t_empty)))),
    ("UTM.wadjust_correctness_helper_1",
     "[| Suc (Suc ?rs) = ?a;
         wadjust_loop_right_move2 ?m ?rs (?c, Bk # ?list) |]
      ==> ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc) (rev ?c @ Oc # ?list))))
          < ?a -
            length
             (takeWhile (%a. a = Oc)
               (tl (dropWhile (%a. a = Oc) (rev ?c @ Bk # ?list))))",
     template_implication
      ([template_equation
         (template_app
           (template_hole 14,
            template_app (template_hole 14, template_var 4)),
          template_var 3),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 13, template_var 2),
                template_var 4),
              template_app
               (template_app (template_hole 12, template_var 1),
                template_app
                 (template_app (template_hole 11, template_hole 10),
                  template_var 0)))
            )],
       template_inequation
        (less_than,
         template_app
          (template_app (template_hole 8, template_var 3),
           template_app
            (template_hole 7,
             template_app
              (template_app (template_hole 6, t_empty),
               template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, t_empty),
                   template_app
                    (template_app
                      (template_hole 1,
                       template_app (template_hole 0, template_var 1)),
                     template_app
                      (template_app (template_hole 11, template_hole 4),
                       template_var 0))))))),
         template_app
          (template_app (template_hole 8, template_var 3),
           template_app
            (template_hole 7,
             template_app
              (template_app (template_hole 6, t_empty),
               template_app
                (template_hole 3,
                 template_app
                  (template_app (template_hole 2, t_empty),
                   template_app
                    (template_app
                      (template_hole 1,
                       template_app (template_hole 0, template_var 1)),
                     template_app
                      (template_app (template_hole 11, template_hole 10),
                       template_var 0)))))))))),
    ("UTM.prepare_mainpart_lemma",
     "?args ~= [] ==>
      EX stp ln rn.
         steps0 (Suc 0, [], <?m # ?args>) (t_wcode_prepare |+| t_wcode_main)
          stp =
         (0, Bk # Oc \<up> Suc ?m,
          Bk #
          Oc #
          Bk \<up> ln @ Bk # Bk # Oc \<up> bl_bin (<?args>) @ Bk \<up> rn)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 20))],
       template_predicate (template_app (template_hole 19, t_empty)))),
    ("UTM.wprepare_loop2",
     "[| rev ?b @ Oc \<up> ?mr @ Bk # <?a # ?lista> =
         Oc \<up> Suc ?m @ Bk # Bk # <?lm>;
         ?b ~= [];
         Oc # ?list = Oc \<up> ?mr @ Bk # <?a # ?lista> @ Bk \<up> ?rn |]
      ==> wprepare_loop_start_in_middle ?m ?lm (Oc # ?b, ?list)",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_hole 12,
              template_app (template_hole 11, template_var 7)),
            template_app
             (template_app
               (template_hole 12,
                template_app
                 (template_app (template_hole 10, template_var 6),
                  template_hole 9)),
              template_app
               (template_app (template_hole 8, template_hole 7),
                template_app
                 (template_hole 6,
                  template_app
                   (template_app (template_hole 5, template_var 5),
                    template_var 4))))),
          template_app
           (template_app
             (template_hole 12,
              template_app
               (template_app
                 (template_hole 10,
                  template_app (template_hole 4, template_var 3)),
                template_hole 9)),
            template_app
             (template_app (template_hole 8, template_hole 7),
              template_app
               (template_app (template_hole 8, template_hole 7),
                template_app (template_hole 6, template_var 2))))),
        template_negation
         (template_equation (template_var 7, template_hole 2)),
        template_equation
         (template_app
           (template_app (template_hole 8, template_hole 9),
            template_var 1),
          template_app
           (template_app
             (template_hole 12,
              template_app
               (template_app (template_hole 10, template_var 6),
                template_hole 9)),
            template_app
             (template_app (template_hole 8, template_hole 7),
              template_app
               (template_app
                 (template_hole 12,
                  template_app
                   (template_hole 6,
                    template_app
                     (template_app (template_hole 5, template_var 5),
                      template_var 4))),
                template_app
                 (template_app (template_hole 10, template_var 0),
                  template_hole 7)))))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_app
              (template_app
                (template_hole 0,
                 template_app
                  (template_app (template_hole 8, template_hole 9),
                   template_var 7)),
               template_var 1))
           ))),
    ("UTM.wcode_halt_case",
     "EX stp ln rn.
         steps0
          (Suc 0, Bk # Bk \<up> ?m @ Oc # Bk # Bk # ?ires,
           Bk # Oc \<up> Suc ?rs @ Bk \<up> ?n)
          t_wcode_main stp =
         (0, Bk # ?ires,
          Bk #
          Oc # Bk \<up> ln @ Bk # Bk # Oc \<up> Suc ?rs @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 13, t_empty))),
    ("UTM.bl_bin_2",
     "bl_bin (<?aa # ?list>) +
      (4 * ?rs + 4) * 2 ^ (length (<?aa # ?list>) - Suc 0) =
      bl_bin (Oc \<up> Suc ?aa @ Bk # <?list @ [0]>) +
      ?rs * (2 * 2 ^ (?aa + length (<?list @ [0]>)))",
     template_equation
      (template_app
        (template_app
          (template_hole 19,
           template_app
            (template_hole 18,
             template_app
              (template_hole 17,
               template_app
                (template_app (template_hole 16, template_var 2),
                 template_var 1)))),
         template_app
          (template_app
            (template_hole 15,
             template_app
              (template_app
                (template_hole 19,
                 template_app
                  (template_app
                    (template_hole 15,
                     template_app
                      (template_hole 14,
                       template_app
                        (template_hole 13,
                         template_app
                          (template_hole 13, template_hole 12)))),
                   template_var 0)),
               template_app
                (template_hole 14,
                 template_app
                  (template_hole 13,
                   template_app (template_hole 13, template_hole 12))))),
           template_app
            (template_app
              (template_hole 11,
               template_app
                (template_hole 14,
                 template_app (template_hole 13, template_hole 12))),
             template_app
              (template_app
                (template_hole 10,
                 template_app
                  (template_hole 9,
                   template_app
                    (template_hole 17,
                     template_app
                      (template_app (template_hole 16, template_var 2),
                       template_var 1)))),
               template_app (template_hole 8, template_hole 7))))),
       template_app
        (template_app
          (template_hole 19,
           template_app
            (template_hole 18,
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app (template_hole 8, template_var 2)),
                   template_hole 4)),
               template_app
                (template_app (template_hole 3, template_hole 2),
                 template_app
                  (template_hole 17,
                   template_app
                    (template_app (template_hole 1, template_var 1),
                     template_app
                      (template_app (template_hole 16, template_hole 7),
                       template_hole 0))))))),
         template_app
          (template_app (template_hole 15, template_var 0),
           template_app
            (template_app
              (template_hole 15,
               template_app
                (template_hole 14,
                 template_app (template_hole 13, template_hole 12))),
             template_app
              (template_app
                (template_hole 11,
                 template_app
                  (template_hole 14,
                   template_app (template_hole 13, template_hole 12))),
               template_app
                (template_app (template_hole 19, template_var 2),
                 template_app
                  (template_hole 9,
                   template_app
                    (template_hole 17,
                     template_app
                      (template_app (template_hole 1, template_var 1),
                       template_app
                        (template_app (template_hole 16, template_hole 7),
                         template_hole 0))))))))))),
    ("UTM.UTM_halt_lemma2",
     "[| tm_wf0 ?p; ?args ~= [];
         {%tp. tp = ([], <?args>)} ?p
         {%tp. tp = (Bk \<up> ?m, <?n> @ Bk \<up> ?k)} |]
      ==> {%tp. tp = ([], <code ?p # ?args>)} UTM
          {%tp. EX m k. tp = (Bk \<up> m, <?n> @ Bk \<up> k)}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 18,
              template_app
               (template_app (template_hole 17, template_var 4),
                template_hole 16))
            ),
        template_negation
         (template_equation (template_var 3, template_hole 13)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 12, t_empty), template_var 4),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 12, t_empty), template_hole 1),
             t_empty)
           ))),
    ("UTM.t_fourtimes_correct",
     "EX stp ln rn.
         steps0 (Suc 0, Bk # Bk # ?ires, Oc \<up> Suc ?rs @ Bk \<up> ?n)
          (tm_of abc_fourtimes @
           Turing.shift (mopup 1) (length (tm_of abc_fourtimes) div 2))
          stp =
         (0, Bk \<up> ln @ Bk # Bk # ?ires,
          Oc \<up> Suc (4 * ?rs) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 24, t_empty))),
    ("UTM.t_twice_correct",
     "EX stp ln rn.
         steps0 (Suc 0, Bk # Bk # ?ires, Oc \<up> Suc ?rs @ Bk \<up> ?n)
          (tm_of abc_twice @
           Turing.shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))
          stp =
         (0, Bk \<up> ln @ Bk # Bk # ?ires,
          Oc \<up> Suc (2 * ?rs) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 23, t_empty))),
    ("UTM.wcode_double_case",
     "EX stp ln rn.
         steps0
          (Suc 0, Bk # Bk \<up> ?m @ Oc # Oc # ?ires,
           Bk # Oc \<up> Suc ?rs @ Bk \<up> ?n)
          t_wcode_main stp =
         (Suc 0, Bk # Bk \<up> ln @ Oc # ?ires,
          Bk # Oc \<up> Suc (2 * ?rs + 2) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 18, t_empty))),
    ("UTM.t_halt_case_correctness",
     "let P = %(st, l, r). st = 0;
          Q = %(st, l, r). wcode_halt_case_inv st ?ires ?rs (l, r);
          f = steps0
               (Suc 0, Bk # Bk \<up> ?m @ Oc # Bk # Bk # ?ires,
                Bk # Oc \<up> Suc ?rs @ Bk \<up> ?n)
               t_wcode_main
      in EX n. P (f n) & Q (f n)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 19, template_app (template_hole 18, t_empty)),
           t_empty)
         )),
    ("UTM.wcode_jump1",
     "EX stp ln rn.
         steps0
          (Suc t_twice_len + length t_wcode_main_first_part div 2,
           Bk \<up> ?m @ Bk # Bk # ?ires,
           Oc \<up> Suc (2 * ?rs) @ Bk \<up> ?n)
          t_wcode_main stp =
         (Suc 0, Bk \<up> ln @ Bk # ?ires,
          Bk # Oc \<up> Suc (2 * ?rs) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 22, t_empty))),
    ("UTM.wcode_double_case_first_correctness",
     "let P = %(st, l, r). st = 13;
          Q = %(st, l, r). wcode_double_case_inv st ?ires ?rs (l, r);
          f = steps0
               (Suc 0, Bk # Bk \<up> ?m @ Oc # Oc # ?ires,
                Bk # Oc \<up> Suc ?rs @ Bk \<up> ?n)
               t_wcode_main
      in EX n. P (f n) & Q (f n)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 23, template_app (template_hole 22, t_empty)),
           t_empty)
         )),
    ("UTM.wcode_fourtimes_case",
     "EX stp ln rn.
         steps0
          (Suc 0, Bk # Bk \<up> ?m @ Oc # Bk # Oc # ?ires,
           Bk # Oc \<up> Suc ?rs @ Bk \<up> ?n)
          t_wcode_main stp =
         (Suc 0, Bk # Bk \<up> ln @ Oc # ?ires,
          Bk # Oc \<up> Suc (4 * ?rs + 4) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 18, t_empty))),
    ("UTM.wcode_fourtimes_case_first_correctness",
     "let P = %(st, l, r). st = t_twice_len + 14;
          Q = %(st, l, r). wcode_fourtimes_case_inv st ?ires ?rs (l, r);
          f = steps0
               (Suc 0, Bk # Bk \<up> ?m @ Oc # Bk # Oc # ?ires,
                Bk # Oc \<up> Suc ?rs @ Bk \<up> ?n)
               t_wcode_main
      in EX n. P (f n) & Q (f n)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 25, template_app (template_hole 24, t_empty)),
           t_empty)
         )),
    ("UTM.tm_append_shift_append_steps",
     "[| steps0 (?st, ?l, ?r) ?tp ?stp = (?st', ?l', ?r'); 0 < ?st';
         is_even (length ?tp1.0) |]
      ==> steps0 (?st + length ?tp1.0 div 2, ?l, ?r)
           (?tp1.0 @ Turing.shift ?tp (length ?tp1.0 div 2) @ ?tp2.0) ?stp =
          (?st' + length ?tp1.0 div 2, ?l', ?r')",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 15,
                template_app
                 (template_app (template_hole 14, template_var 9),
                  template_app
                   (template_app (template_hole 13, template_var 8),
                    template_var 7))),
              template_app
               (template_app (template_hole 12, template_var 6),
                template_hole 11)),
            template_var 5),
          template_app
           (template_app (template_hole 14, template_var 4),
            template_app
             (template_app (template_hole 13, template_var 3),
              template_var 2))),
        template_inequation (less_than, template_hole 11, template_var 4),
        template_equation
         (template_app
           (template_app
             (template_hole 8,
              template_app (template_hole 7, template_var 1)),
            template_app
             (template_hole 6,
              template_app (template_hole 5, template_hole 4))),
          template_hole 11)],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 15,
               template_app
                (template_app
                  (template_hole 14,
                   template_app
                    (template_app (template_hole 3, template_var 9),
                     template_app
                      (template_app
                        (template_hole 2,
                         template_app (template_hole 7, template_var 1)),
                       template_app
                        (template_hole 6,
                         template_app
                          (template_hole 5, template_hole 4))))),
                 template_app
                  (template_app (template_hole 13, template_var 8),
                   template_var 7))),
             template_app
              (template_app
                (template_hole 12,
                 template_app
                  (template_app (template_hole 1, template_var 1),
                   template_app
                    (template_app
                      (template_hole 1,
                       template_app
                        (template_app (template_hole 0, template_var 6),
                         template_app
                          (template_app
                            (template_hole 2,
                             template_app
                              (template_hole 7, template_var 1)),
                           template_app
                            (template_hole 6,
                             template_app
                              (template_hole 5, template_hole 4))))),
                     template_var 0))),
               template_hole 11)),
           template_var 5),
         template_app
          (template_app
            (template_hole 14,
             template_app
              (template_app (template_hole 3, template_var 4),
               template_app
                (template_app
                  (template_hole 2,
                   template_app (template_hole 7, template_var 1)),
                 template_app
                  (template_hole 6,
                   template_app (template_hole 5, template_hole 4))))),
           template_app
            (template_app (template_hole 13, template_var 3),
             template_var 2))))),
    ("UTM.UTM_halt_lemma",
     "[| tm_wf0 ?p; 0 < ?rs; ?args ~= [];
         {%tp. tp = (Bk \<up> ?i, <?args>)} ?p
         {%tp. tp = (Bk \<up> ?m, Oc \<up> ?rs @ Bk \<up> ?k)} |]
      ==> {%tp. tp = ([], <code ?p # ?args>)} UTM
          {%tp. EX m n. tp = (Bk \<up> m, Oc \<up> ?rs @ Bk \<up> n)}",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 19,
              template_app
               (template_app (template_hole 18, template_var 5),
                template_hole 17))
            ),
        template_inequation (less_than, template_hole 17, template_var 4),
        template_negation
         (template_equation (template_var 3, template_hole 13)),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 12, t_empty), template_var 5),
              t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 12, t_empty), template_hole 1),
             t_empty)
           ))),
    ("UTM.wadjust_correctness",
     "let P = %(len, st, l, r). st = 0;
          Q = %(len, st, l, r). wadjust_inv st ?m ?rs (l, r);
          f = %stp. (Suc (Suc ?rs),
                     steps0
                      (Suc 0, Bk # Oc \<up> Suc ?m,
                       Bk #
                       Oc #
                       Bk \<up> ?ln @ Bk # Oc \<up> Suc ?rs @ Bk \<up> ?rn)
                      t_wcode_adjust stp)
      in EX n. P (f n) & Q (f n)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 21, template_app (template_hole 20, t_empty)),
           t_empty)
         )),
    ("UTM.UTM_halt_lemma'",
     "[| tm_wf0 ?tp; 0 < ?rs; ?args ~= [];
         steps0 (Suc 0, Bk \<up> ?i, <?args>) ?tp ?stp =
         (0, Bk \<up> ?m, Oc \<up> ?rs @ Bk \<up> ?k) |]
      ==> EX stp m n.
             steps0 (Suc 0, [], <code ?tp # ?args>) UTM stp =
             (0, Bk \<up> m, Oc \<up> ?rs @ Bk \<up> n)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 21,
              template_app
               (template_app (template_hole 20, template_var 6),
                template_hole 19))
            ),
        template_inequation (less_than, template_hole 19, template_var 5),
        template_negation
         (template_equation (template_var 4, template_hole 15)),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 13,
                template_app
                 (template_app
                   (template_hole 12,
                    template_app (template_hole 11, template_hole 19)),
                  template_app
                   (template_app
                     (template_hole 10,
                      template_app
                       (template_app (template_hole 9, template_var 3),
                        template_hole 8)),
                    template_app (template_hole 7, template_var 4)))),
              template_app
               (template_app (template_hole 20, template_var 6),
                template_hole 19)),
            template_var 2),
          template_app
           (template_app (template_hole 12, template_hole 19),
            template_app
             (template_app
               (template_hole 10,
                template_app
                 (template_app (template_hole 9, template_var 1),
                  template_hole 8)),
              template_app
               (template_app
                 (template_hole 6,
                  template_app
                   (template_app (template_hole 9, template_var 5),
                    template_hole 5)),
                template_app
                 (template_app (template_hole 9, template_var 0),
                  template_hole 8)))))],
       template_predicate (template_app (template_hole 4, t_empty)))),
    ("UTM.UTM_halt_lemma_pre",
     "[| tm_wf0 ?tp; 0 < ?rs; ?args ~= [];
         steps0 (Suc 0, Bk \<up> ?i, <?args>) ?tp ?stp =
         (0, Bk \<up> ?m, Oc \<up> ?rs @ Bk \<up> ?k) |]
      ==> EX stp m n.
             steps0 (Suc 0, [], <code ?tp # ?args>) UTM_pre stp =
             (0, Bk \<up> m, Oc \<up> ?rs @ Bk \<up> n)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 21,
              template_app
               (template_app (template_hole 20, template_var 6),
                template_hole 19))
            ),
        template_inequation (less_than, template_hole 19, template_var 5),
        template_negation
         (template_equation (template_var 4, template_hole 15)),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 13,
                template_app
                 (template_app
                   (template_hole 12,
                    template_app (template_hole 11, template_hole 19)),
                  template_app
                   (template_app
                     (template_hole 10,
                      template_app
                       (template_app (template_hole 9, template_var 3),
                        template_hole 8)),
                    template_app (template_hole 7, template_var 4)))),
              template_app
               (template_app (template_hole 20, template_var 6),
                template_hole 19)),
            template_var 2),
          template_app
           (template_app (template_hole 12, template_hole 19),
            template_app
             (template_app
               (template_hole 10,
                template_app
                 (template_app (template_hole 9, template_var 1),
                  template_hole 8)),
              template_app
               (template_app
                 (template_hole 6,
                  template_app
                   (template_app (template_hole 9, template_var 5),
                    template_hole 5)),
                template_app
                 (template_app (template_hole 9, template_var 0),
                  template_hole 8)))))],
       template_predicate (template_app (template_hole 4, t_empty)))),
    ("UTM.wcode_jump2",
     "EX stp ln rn.
         steps0
          (t_twice_len + 14 + t_fourtimes_len,
           Bk # Bk # Bk \<up> ?lnb @ Oc # ?ires,
           Oc \<up> Suc (4 * ?rs + 4) @ Bk \<up> ?rnb)
          t_wcode_main stp =
         (Suc 0, Bk # Bk \<up> ln @ Oc # ?ires,
          Bk # Oc \<up> Suc (4 * ?rs + 4) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 21, t_empty))),
    ("UTM.add_one_2_add_one",
     "wprepare_add_one ?m ?lm (?b, Oc # ?list) ==>
      (hd ?b = Oc -->
       (?b = [] --> wprepare_add_one ?m ?lm ([], Bk # Oc # ?list)) &
       (?b ~= [] --> wprepare_add_one ?m ?lm (tl ?b, Oc # Oc # ?list))) &
      (hd ?b ~= Oc -->
       (?b = [] --> wprepare_add_one ?m ?lm ([], Bk # Oc # ?list)) &
       (?b ~= [] --> wprepare_add_one ?m ?lm (tl ?b, hd ?b # Oc # ?list)))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 12, template_var 3),
                template_var 2),
              template_app
               (template_app (template_hole 11, template_var 1),
                template_app
                 (template_app (template_hole 10, template_hole 9),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app
                      (template_hole 6,
                       template_app (template_hole 5, template_var 1)),
                     template_hole 9)),
                 template_app
                  (template_app
                    (template_hole 8,
                     template_app
                      (template_app
                        (template_hole 7,
                         template_app
                          (template_app (template_hole 4, template_var 1),
                           template_hole 3)),
                       template_app
                        (template_app
                          (template_app (template_hole 12, template_var 3),
                           template_var 2),
                         template_app
                          (template_app (template_hole 11, template_hole 3),
                           template_app
                            (template_app
                              (template_hole 10, template_hole 2),
                             template_app
                              (template_app
                                (template_hole 10, template_hole 9),
                               template_var 0)))))),
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_hole 1,
                         template_app
                          (template_app (template_hole 4, template_var 1),
                           template_hole 3))),
                     template_app
                      (template_app
                        (template_app (template_hole 12, template_var 3),
                         template_var 2),
                       template_app
                        (template_app
                          (template_hole 11,
                           template_app (template_hole 0, template_var 1)),
                         template_app
                          (template_app (template_hole 10, template_hole 9),
                           template_app
                            (template_app
                              (template_hole 10, template_hole 9),
                             template_var 0)))))))),
             template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_hole 1,
                   template_app
                    (template_app
                      (template_hole 6,
                       template_app (template_hole 5, template_var 1)),
                     template_hole 9))),
               template_app
                (template_app
                  (template_hole 8,
                   template_app
                    (template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 4, template_var 1),
                         template_hole 3)),
                     template_app
                      (template_app
                        (template_app (template_hole 12, template_var 3),
                         template_var 2),
                       template_app
                        (template_app (template_hole 11, template_hole 3),
                         template_app
                          (template_app (template_hole 10, template_hole 2),
                           template_app
                            (template_app
                              (template_hole 10, template_hole 9),
                             template_var 0)))))),
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_hole 1,
                       template_app
                        (template_app (template_hole 4, template_var 1),
                         template_hole 3))),
                   template_app
                    (template_app
                      (template_app (template_hole 12, template_var 3),
                       template_var 2),
                     template_app
                      (template_app
                        (template_hole 11,
                         template_app (template_hole 0, template_var 1)),
                       template_app
                        (template_app
                          (template_hole 10,
                           template_app (template_hole 5, template_var 1)),
                         template_app
                          (template_app (template_hole 10, template_hole 9),
                           template_var 0))))))))
           ))),
    ("UTM.t_utm_halt_eq",
     "[| tm_wf0 ?tp;
         steps0 (Suc 0, Bk \<up> ?l, <?lm>) ?tp ?stp =
         (0, Bk \<up> ?m, Oc \<up> ?rs @ Bk \<up> ?n);
         0 < ?rs |]
      ==> EX stp m n.
             steps0 (Suc 0, [Bk], <[code ?tp, bl2wc (<?lm>)]> @ Bk \<up> ?i)
              t_utm stp =
             (0, Bk \<up> m, Oc \<up> ?rs @ Bk \<up> n)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 21,
              template_app
               (template_app (template_hole 20, template_var 7),
                template_hole 19))
            ),
        template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 17,
                template_app
                 (template_app
                   (template_hole 16,
                    template_app (template_hole 15, template_hole 19)),
                  template_app
                   (template_app
                     (template_hole 14,
                      template_app
                       (template_app (template_hole 13, template_var 6),
                        template_hole 12)),
                    template_app (template_hole 11, template_var 5)))),
              template_app
               (template_app (template_hole 20, template_var 7),
                template_hole 19)),
            template_var 4),
          template_app
           (template_app (template_hole 16, template_hole 19),
            template_app
             (template_app
               (template_hole 14,
                template_app
                 (template_app (template_hole 13, template_var 3),
                  template_hole 12)),
              template_app
               (template_app
                 (template_hole 10,
                  template_app
                   (template_app (template_hole 13, template_var 2),
                    template_hole 9)),
                template_app
                 (template_app (template_hole 13, template_var 1),
                  template_hole 12))))),
        template_inequation (less_than, template_hole 19, template_var 2)],
       template_predicate (template_app (template_hole 7, t_empty)))),
    ("UTM.t_wcode_main_lemma_pre",
     "[| ?args ~= []; ?lm = <?args> |]
      ==> EX stp ln rn.
             steps0
              (Suc 0, Bk # Bk \<up> ?m @ rev ?lm @ Bk # Bk # ?ires,
               Bk # Oc \<up> Suc ?rs @ Bk \<up> ?n)
              t_wcode_main stp =
             (0, Bk # ?ires,
              Bk #
              Oc #
              Bk \<up> ln @
              Bk #
              Bk #
              Oc \<up> (bl_bin ?lm + ?rs * 2 ^ (length ?lm - 1)) @
              Bk \<up> rn)",
     template_implication
      ([template_negation
         (template_equation (template_var 5, template_hole 27)),
        template_equation
         (template_var 4, template_app (template_hole 25, template_var 5))],
       template_predicate (template_app (template_hole 24, t_empty)))),
    ("UTM.bl_bin_4",
     "bl_bin (Oc # Oc \<up> ?aa @ Bk # <?list @ [?ab]>) +
      (4 * 2 ^ (?aa + length (<?list @ [?ab]>)) +
       4 * (?rs * 2 ^ (?aa + length (<?list @ [?ab]>)))) =
      bl_bin (Oc # Oc \<up> ?aa @ Bk # <?list @ [Suc ?ab]>) +
      ?rs * (2 * 2 ^ (?aa + length (<?list @ [Suc ?ab]>)))",
     template_equation
      (template_app
        (template_app
          (template_hole 17,
           template_app
            (template_hole 16,
             template_app
              (template_app (template_hole 15, template_hole 14),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_app (template_hole 12, template_var 3),
                     template_hole 14)),
                 template_app
                  (template_app (template_hole 15, template_hole 11),
                   template_app
                    (template_hole 10,
                     template_app
                      (template_app (template_hole 9, template_var 2),
                       template_app
                        (template_app (template_hole 8, template_var 1),
                         template_hole 7)))))))),
         template_app
          (template_app
            (template_hole 17,
             template_app
              (template_app
                (template_hole 6,
                 template_app
                  (template_hole 5,
                   template_app
                    (template_hole 4,
                     template_app (template_hole 4, template_hole 3)))),
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_hole 5,
                     template_app (template_hole 4, template_hole 3))),
                 template_app
                  (template_app (template_hole 17, template_var 3),
                   template_app
                    (template_hole 1,
                     template_app
                      (template_hole 10,
                       template_app
                        (template_app (template_hole 9, template_var 2),
                         template_app
                          (template_app (template_hole 8, template_var 1),
                           template_hole 7)))))))),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_hole 5,
                 template_app
                  (template_hole 4,
                   template_app (template_hole 4, template_hole 3)))),
             template_app
              (template_app (template_hole 6, template_var 0),
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_hole 5,
                     template_app (template_hole 4, template_hole 3))),
                 template_app
                  (template_app (template_hole 17, template_var 3),
                   template_app
                    (template_hole 1,
                     template_app
                      (template_hole 10,
                       template_app
                        (template_app (template_hole 9, template_var 2),
                         template_app
                          (template_app (template_hole 8, template_var 1),
                           template_hole 7)))))))))),
       template_app
        (template_app
          (template_hole 17,
           template_app
            (template_hole 16,
             template_app
              (template_app (template_hole 15, template_hole 14),
               template_app
                (template_app
                  (template_hole 13,
                   template_app
                    (template_app (template_hole 12, template_var 3),
                     template_hole 14)),
                 template_app
                  (template_app (template_hole 15, template_hole 11),
                   template_app
                    (template_hole 10,
                     template_app
                      (template_app (template_hole 9, template_var 2),
                       template_app
                        (template_app
                          (template_hole 8,
                           template_app (template_hole 0, template_var 1)),
                         template_hole 7)))))))),
         template_app
          (template_app (template_hole 6, template_var 0),
           template_app
            (template_app
              (template_hole 6,
               template_app
                (template_hole 5,
                 template_app (template_hole 4, template_hole 3))),
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_hole 5,
                   template_app (template_hole 4, template_hole 3))),
               template_app
                (template_app (template_hole 17, template_var 3),
                 template_app
                  (template_hole 1,
                   template_app
                    (template_hole 10,
                     template_app
                      (template_app (template_hole 9, template_var 2),
                       template_app
                        (template_app
                          (template_hole 8,
                           template_app (template_hole 0, template_var 1)),
                         template_hole 7))))))))))),
    ("UTM.wadjust_loop_erase_cases_or",
     "[| Suc (Suc ?rs) = ?a; wadjust_loop_erase ?m ?rs (?c, Oc # ?list) |]
      ==> ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc) (rev ?c @ Bk # ?list))))
          < ?a -
            length
             (takeWhile (%a. a = Oc)
               (tl (dropWhile (%a. a = Oc) (rev ?c @ Oc # ?list)))) |
          ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc) (rev ?c @ Bk # ?list)))) =
          ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc) (rev ?c @ Oc # ?list))))",
     template_implication
      ([template_equation
         (template_app
           (template_hole 15,
            template_app (template_hole 15, template_var 4)),
          template_var 3),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 14, template_var 2),
                template_var 4),
              template_app
               (template_app (template_hole 13, template_var 1),
                template_app
                 (template_app (template_hole 12, template_hole 11),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app
                  (template_hole 9,
                   template_app
                    (template_app (template_hole 8, template_var 3),
                     template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 6, t_empty),
                         template_app
                          (template_hole 4,
                           template_app
                            (template_app (template_hole 3, t_empty),
                             template_app
                              (template_app
                                (template_hole 2,
                                 template_app
                                  (template_hole 1, template_var 1)),
                               template_app
                                (template_app
                                  (template_hole 12, template_hole 0),
                                 template_var 0)))))))),
                 template_app
                  (template_app (template_hole 8, template_var 3),
                   template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, t_empty),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, t_empty),
                           template_app
                            (template_app
                              (template_hole 2,
                               template_app
                                (template_hole 1, template_var 1)),
                             template_app
                              (template_app
                                (template_hole 12, template_hole 11),
                               template_var 0))))))))),
             template_app
              (template_app
                (template_hole 16,
                 template_app
                  (template_app (template_hole 8, template_var 3),
                   template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, t_empty),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, t_empty),
                           template_app
                            (template_app
                              (template_hole 2,
                               template_app
                                (template_hole 1, template_var 1)),
                             template_app
                              (template_app
                                (template_hole 12, template_hole 0),
                               template_var 0)))))))),
               template_app
                (template_app (template_hole 8, template_var 3),
                 template_app
                  (template_hole 7,
                   template_app
                    (template_app (template_hole 6, t_empty),
                     template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, t_empty),
                         template_app
                          (template_app
                            (template_hole 2,
                             template_app
                              (template_hole 1, template_var 1)),
                           template_app
                            (template_app
                              (template_hole 12, template_hole 11),
                             template_var 0)))))))))
           ))),
    ("UTM.t_twice_append",
     "EX stp ln rn.
         steps0
          (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ?ires,
           Oc \<up> Suc ?rs @ Bk \<up> ?n)
          (t_wcode_main_first_part @
           Turing.shift t_twice (length t_wcode_main_first_part div 2) @
           [(L, 1), (L, 1)] @
           Turing.shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])
          stp =
         (Suc t_twice_len + length t_wcode_main_first_part div 2,
          Bk \<up> ln @ Bk # Bk # ?ires,
          Oc \<up> Suc (2 * ?rs) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 31, t_empty))),
    ("UTM.wadjust_loop_check_cases",
     "[| Suc (Suc ?rs) = ?a; wadjust_loop_check ?m ?rs (?c, Oc # ?list) |]
      ==> ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc)
                   (rev (tl ?c) @ hd ?c # Oc # ?list))))
          < ?a -
            length
             (takeWhile (%a. a = Oc)
               (tl (dropWhile (%a. a = Oc) (rev ?c @ Oc # ?list)))) |
          ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc)
                   (rev (tl ?c) @ hd ?c # Oc # ?list)))) =
          ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc) (rev ?c @ Oc # ?list))))",
     template_implication
      ([template_equation
         (template_app
           (template_hole 15,
            template_app (template_hole 15, template_var 4)),
          template_var 3),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 14, template_var 2),
                template_var 4),
              template_app
               (template_app (template_hole 13, template_var 1),
                template_app
                 (template_app (template_hole 12, template_hole 11),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 10,
               template_app
                (template_app
                  (template_hole 9,
                   template_app
                    (template_app (template_hole 8, template_var 3),
                     template_app
                      (template_hole 7,
                       template_app
                        (template_app (template_hole 6, t_empty),
                         template_app
                          (template_hole 4,
                           template_app
                            (template_app (template_hole 3, t_empty),
                             template_app
                              (template_app
                                (template_hole 2,
                                 template_app
                                  (template_hole 1,
                                   template_app
                                    (template_hole 4, template_var 1))),
                               template_app
                                (template_app
                                  (template_hole 12,
                                   template_app
                                    (template_hole 0, template_var 1)),
                                 template_app
                                  (template_app
                                    (template_hole 12, template_hole 11),
                                   template_var 0))))))))),
                 template_app
                  (template_app (template_hole 8, template_var 3),
                   template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, t_empty),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, t_empty),
                           template_app
                            (template_app
                              (template_hole 2,
                               template_app
                                (template_hole 1, template_var 1)),
                             template_app
                              (template_app
                                (template_hole 12, template_hole 11),
                               template_var 0))))))))),
             template_app
              (template_app
                (template_hole 16,
                 template_app
                  (template_app (template_hole 8, template_var 3),
                   template_app
                    (template_hole 7,
                     template_app
                      (template_app (template_hole 6, t_empty),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, t_empty),
                           template_app
                            (template_app
                              (template_hole 2,
                               template_app
                                (template_hole 1,
                                 template_app
                                  (template_hole 4, template_var 1))),
                             template_app
                              (template_app
                                (template_hole 12,
                                 template_app
                                  (template_hole 0, template_var 1)),
                               template_app
                                (template_app
                                  (template_hole 12, template_hole 11),
                                 template_var 0))))))))),
               template_app
                (template_app (template_hole 8, template_var 3),
                 template_app
                  (template_hole 7,
                   template_app
                    (template_app (template_hole 6, t_empty),
                     template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, t_empty),
                         template_app
                          (template_app
                            (template_hole 2,
                             template_app
                              (template_hole 1, template_var 1)),
                           template_app
                            (template_app
                              (template_hole 12, template_hole 11),
                             template_var 0)))))))))
           ))),
    ("UTM.wadjust_loop_erase_cases2",
     "[| Suc (Suc ?rs) = ?a; wadjust_loop_erase ?m ?rs (?c, Bk # ?list) |]
      ==> ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc)
                   (rev (tl ?c) @ hd ?c # Bk # ?list))))
          < ?a -
            length
             (takeWhile (%a. a = Oc)
               (tl (dropWhile (%a. a = Oc) (rev ?c @ Bk # ?list)))) |
          ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc)
                   (rev (tl ?c) @ hd ?c # Bk # ?list)))) =
          ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc) (rev ?c @ Bk # ?list))))",
     template_implication
      ([template_equation
         (template_app
           (template_hole 16,
            template_app (template_hole 16, template_var 4)),
          template_var 3),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 15, template_var 2),
                template_var 4),
              template_app
               (template_app (template_hole 14, template_var 1),
                template_app
                 (template_app (template_hole 13, template_hole 12),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 11,
               template_app
                (template_app
                  (template_hole 10,
                   template_app
                    (template_app (template_hole 9, template_var 3),
                     template_app
                      (template_hole 8,
                       template_app
                        (template_app (template_hole 7, t_empty),
                         template_app
                          (template_hole 4,
                           template_app
                            (template_app (template_hole 3, t_empty),
                             template_app
                              (template_app
                                (template_hole 2,
                                 template_app
                                  (template_hole 1,
                                   template_app
                                    (template_hole 4, template_var 1))),
                               template_app
                                (template_app
                                  (template_hole 13,
                                   template_app
                                    (template_hole 0, template_var 1)),
                                 template_app
                                  (template_app
                                    (template_hole 13, template_hole 12),
                                   template_var 0))))))))),
                 template_app
                  (template_app (template_hole 9, template_var 3),
                   template_app
                    (template_hole 8,
                     template_app
                      (template_app (template_hole 7, t_empty),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, t_empty),
                           template_app
                            (template_app
                              (template_hole 2,
                               template_app
                                (template_hole 1, template_var 1)),
                             template_app
                              (template_app
                                (template_hole 13, template_hole 12),
                               template_var 0))))))))),
             template_app
              (template_app
                (template_hole 17,
                 template_app
                  (template_app (template_hole 9, template_var 3),
                   template_app
                    (template_hole 8,
                     template_app
                      (template_app (template_hole 7, t_empty),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, t_empty),
                           template_app
                            (template_app
                              (template_hole 2,
                               template_app
                                (template_hole 1,
                                 template_app
                                  (template_hole 4, template_var 1))),
                             template_app
                              (template_app
                                (template_hole 13,
                                 template_app
                                  (template_hole 0, template_var 1)),
                               template_app
                                (template_app
                                  (template_hole 13, template_hole 12),
                                 template_var 0))))))))),
               template_app
                (template_app (template_hole 9, template_var 3),
                 template_app
                  (template_hole 8,
                   template_app
                    (template_app (template_hole 7, t_empty),
                     template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, t_empty),
                         template_app
                          (template_app
                            (template_hole 2,
                             template_app
                              (template_hole 1, template_var 1)),
                           template_app
                            (template_app
                              (template_hole 13, template_hole 12),
                             template_var 0)))))))))
           ))),
    ("UTM.wadjust_correctness_helper_2",
     "[| Suc (Suc ?rs) = ?a;
         wadjust_loop_on_left_moving ?m ?rs (?c, Bk # ?list) |]
      ==> ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc)
                   (rev (tl ?c) @ hd ?c # Bk # ?list))))
          < ?a -
            length
             (takeWhile (%a. a = Oc)
               (tl (dropWhile (%a. a = Oc) (rev ?c @ Bk # ?list)))) |
          ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc)
                   (rev (tl ?c) @ hd ?c # Bk # ?list)))) =
          ?a -
          length
           (takeWhile (%a. a = Oc)
             (tl (dropWhile (%a. a = Oc) (rev ?c @ Bk # ?list))))",
     template_implication
      ([template_equation
         (template_app
           (template_hole 16,
            template_app (template_hole 16, template_var 4)),
          template_var 3),
        template_predicate
         (
            template_app
             (template_app
               (template_app (template_hole 15, template_var 2),
                template_var 4),
              template_app
               (template_app (template_hole 14, template_var 1),
                template_app
                 (template_app (template_hole 13, template_hole 12),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 11,
               template_app
                (template_app
                  (template_hole 10,
                   template_app
                    (template_app (template_hole 9, template_var 3),
                     template_app
                      (template_hole 8,
                       template_app
                        (template_app (template_hole 7, t_empty),
                         template_app
                          (template_hole 4,
                           template_app
                            (template_app (template_hole 3, t_empty),
                             template_app
                              (template_app
                                (template_hole 2,
                                 template_app
                                  (template_hole 1,
                                   template_app
                                    (template_hole 4, template_var 1))),
                               template_app
                                (template_app
                                  (template_hole 13,
                                   template_app
                                    (template_hole 0, template_var 1)),
                                 template_app
                                  (template_app
                                    (template_hole 13, template_hole 12),
                                   template_var 0))))))))),
                 template_app
                  (template_app (template_hole 9, template_var 3),
                   template_app
                    (template_hole 8,
                     template_app
                      (template_app (template_hole 7, t_empty),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, t_empty),
                           template_app
                            (template_app
                              (template_hole 2,
                               template_app
                                (template_hole 1, template_var 1)),
                             template_app
                              (template_app
                                (template_hole 13, template_hole 12),
                               template_var 0))))))))),
             template_app
              (template_app
                (template_hole 17,
                 template_app
                  (template_app (template_hole 9, template_var 3),
                   template_app
                    (template_hole 8,
                     template_app
                      (template_app (template_hole 7, t_empty),
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, t_empty),
                           template_app
                            (template_app
                              (template_hole 2,
                               template_app
                                (template_hole 1,
                                 template_app
                                  (template_hole 4, template_var 1))),
                             template_app
                              (template_app
                                (template_hole 13,
                                 template_app
                                  (template_hole 0, template_var 1)),
                               template_app
                                (template_app
                                  (template_hole 13, template_hole 12),
                                 template_var 0))))))))),
               template_app
                (template_app (template_hole 9, template_var 3),
                 template_app
                  (template_hole 8,
                   template_app
                    (template_app (template_hole 7, t_empty),
                     template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, t_empty),
                         template_app
                          (template_app
                            (template_hole 2,
                             template_app
                              (template_hole 1, template_var 1)),
                           template_app
                            (template_app
                              (template_hole 13, template_hole 12),
                             template_var 0)))))))))
           ))),
    ("UTM.t_fourtimes_append",
     "EX stp ln rn.
         steps0
          (Suc 0 +
           length
            (t_wcode_main_first_part @
             Turing.shift t_twice (length t_wcode_main_first_part div 2) @
             [(L, 1), (L, 1)]) div
           2,
           Bk # Bk # ?ires, Oc \<up> Suc ?rs @ Bk \<up> ?n)
          ((t_wcode_main_first_part @
            Turing.shift t_twice (length t_wcode_main_first_part div 2) @
            [(L, 1), (L, 1)]) @
           Turing.shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])
          stp =
         (Suc t_fourtimes_len +
          length
           (t_wcode_main_first_part @
            Turing.shift t_twice (length t_wcode_main_first_part div 2) @
            [(L, 1), (L, 1)]) div
          2,
          Bk \<up> ln @ Bk # Bk # ?ires,
          Oc \<up> Suc (4 * ?rs) @ Bk \<up> rn)",
     template_predicate (template_app (template_hole 32, t_empty))),
    ("UTM.t_twice_append_pre",
     "steps0 (Suc 0, Bk # Bk # ?ires, Oc \<up> Suc ?rs @ Bk \<up> ?n)
       t_twice ?stp =
      (Suc t_twice_len, Bk \<up> ?ln @ Bk # Bk # ?ires,
       Oc \<up> Suc (2 * ?rs) @ Bk \<up> ?rn) ==>
      steps0
       (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ?ires,
        Oc \<up> Suc ?rs @ Bk \<up> ?n)
       (t_wcode_main_first_part @
        Turing.shift t_twice (length t_wcode_main_first_part div 2) @
        [(L, 1), (L, 1)] @
        Turing.shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])
       ?stp =
      (Suc t_twice_len + length t_wcode_main_first_part div 2,
       Bk \<up> ?ln @ Bk # Bk # ?ires,
       Oc \<up> Suc (2 * ?rs) @ Bk \<up> ?rn)",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 29,
                template_app
                 (template_app
                   (template_hole 28,
                    template_app (template_hole 27, template_hole 26)),
                  template_app
                   (template_app
                     (template_hole 25,
                      template_app
                       (template_app (template_hole 24, template_hole 23),
                        template_app
                         (template_app (template_hole 24, template_hole 23),
                          template_var 5))),
                    template_app
                     (template_app
                       (template_hole 22,
                        template_app
                         (template_app
                           (template_hole 21,
                            template_app
                             (template_hole 27, template_var 4)),
                          template_hole 20)),
                      template_app
                       (template_app (template_hole 21, template_var 3),
                        template_hole 23))))),
              template_app
               (template_app (template_hole 19, template_hole 18),
                template_hole 26)),
            template_var 2),
          template_app
           (template_app
             (template_hole 28,
              template_app (template_hole 27, template_hole 17)),
            template_app
             (template_app
               (template_hole 25,
                template_app
                 (template_app
                   (template_hole 22,
                    template_app
                     (template_app (template_hole 21, template_var 1),
                      template_hole 23)),
                  template_app
                   (template_app (template_hole 24, template_hole 23),
                    template_app
                     (template_app (template_hole 24, template_hole 23),
                      template_var 5)))),
              template_app
               (template_app
                 (template_hole 22,
                  template_app
                   (template_app
                     (template_hole 21,
                      template_app
                       (template_hole 27,
                        template_app
                         (template_app
                           (template_hole 16,
                            template_app
                             (template_hole 15,
                              template_app
                               (template_hole 14, template_hole 13))),
                          template_var 4))),
                    template_hole 20)),
                template_app
                 (template_app (template_hole 21, template_var 0),
                  template_hole 23)))))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 29,
               template_app
                (template_app
                  (template_hole 28,
                   template_app
                    (template_app
                      (template_hole 12,
                       template_app (template_hole 27, template_hole 26)),
                     template_app
                      (template_app
                        (template_hole 11,
                         template_app (template_hole 10, template_hole 9)),
                       template_app
                        (template_hole 15,
                         template_app
                          (template_hole 14, template_hole 13))))),
                 template_app
                  (template_app
                    (template_hole 25,
                     template_app
                      (template_app (template_hole 24, template_hole 23),
                       template_app
                        (template_app (template_hole 24, template_hole 23),
                         template_var 5))),
                   template_app
                    (template_app
                      (template_hole 22,
                       template_app
                        (template_app
                          (template_hole 21,
                           template_app (template_hole 27, template_var 4)),
                         template_hole 20)),
                     template_app
                      (template_app (template_hole 21, template_var 3),
                       template_hole 23))))),
             template_app
              (template_app
                (template_hole 19,
                 template_app
                  (template_app (template_hole 8, template_hole 9),
                   template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_app (template_hole 7, template_hole 18),
                         template_app
                          (template_app
                            (template_hole 11,
                             template_app
                              (template_hole 10, template_hole 9)),
                           template_app
                            (template_hole 15,
                             template_app
                              (template_hole 14, template_hole 13))))),
                     template_app
                      (template_app
                        (template_hole 8,
                         template_app
                          (template_app
                            (template_hole 6,
                             template_app
                              (template_app
                                (template_hole 5, template_hole 4),
                               template_hole 3)),
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_app
                                  (template_hole 5, template_hole 4),
                                 template_hole 3)),
                             template_hole 2))),
                       template_app
                        (template_app
                          (template_hole 8,
                           template_app
                            (template_app
                              (template_hole 7, template_hole 1),
                             template_app
                              (template_app
                                (template_hole 12, template_hole 17),
                               template_app
                                (template_hole 15,
                                 template_app
                                  (template_hole 0,
                                   template_app
                                    (template_hole 14,
                                     template_app
(template_hole 0, template_hole 13))))))),
                         template_app
                          (template_app
                            (template_hole 6,
                             template_app
                              (template_app
                                (template_hole 5, template_hole 4),
                               template_hole 3)),
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_app
                                  (template_hole 5, template_hole 4),
                                 template_hole 3)),
                             template_hole 2))))))),
               template_hole 26)),
           template_var 2),
         template_app
          (template_app
            (template_hole 28,
             template_app
              (template_app
                (template_hole 12,
                 template_app (template_hole 27, template_hole 17)),
               template_app
                (template_app
                  (template_hole 11,
                   template_app (template_hole 10, template_hole 9)),
                 template_app
                  (template_hole 15,
                   template_app (template_hole 14, template_hole 13))))),
           template_app
            (template_app
              (template_hole 25,
               template_app
                (template_app
                  (template_hole 22,
                   template_app
                    (template_app (template_hole 21, template_var 1),
                     template_hole 23)),
                 template_app
                  (template_app (template_hole 24, template_hole 23),
                   template_app
                    (template_app (template_hole 24, template_hole 23),
                     template_var 5)))),
             template_app
              (template_app
                (template_hole 22,
                 template_app
                  (template_app
                    (template_hole 21,
                     template_app
                      (template_hole 27,
                       template_app
                        (template_app
                          (template_hole 16,
                           template_app
                            (template_hole 15,
                             template_app
                              (template_hole 14, template_hole 13))),
                         template_var 4))),
                   template_hole 20)),
               template_app
                (template_app (template_hole 21, template_var 0),
                 template_hole 23))))))),
    ("UTM.t_fourtimes_append_pre",
     "steps0 (Suc 0, Bk # Bk # ?ires, Oc \<up> Suc ?rs @ Bk \<up> ?n)
       t_fourtimes ?stp =
      (Suc t_fourtimes_len, Bk \<up> ?ln @ Bk # Bk # ?ires,
       Oc \<up> Suc (4 * ?rs) @ Bk \<up> ?rn) ==>
      steps0
       (Suc 0 +
        length
         (t_wcode_main_first_part @
          Turing.shift t_twice (length t_wcode_main_first_part div 2) @
          [(L, 1), (L, 1)]) div
        2,
        Bk # Bk # ?ires, Oc \<up> Suc ?rs @ Bk \<up> ?n)
       ((t_wcode_main_first_part @
         Turing.shift t_twice (length t_wcode_main_first_part div 2) @
         [(L, 1), (L, 1)]) @
        Turing.shift t_fourtimes
         (length
           (t_wcode_main_first_part @
            Turing.shift t_twice (length t_wcode_main_first_part div 2) @
            [(L, 1), (L, 1)]) div
          2) @
        [(L, 1), (L, 1)])
       ?stp =
      (Suc t_fourtimes_len +
       length
        (t_wcode_main_first_part @
         Turing.shift t_twice (length t_wcode_main_first_part div 2) @
         [(L, 1), (L, 1)]) div
       2,
       Bk \<up> ?ln @ Bk # Bk # ?ires,
       Oc \<up> Suc (4 * ?rs) @ Bk \<up> ?rn)",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_app
               (template_hole 28,
                template_app
                 (template_app
                   (template_hole 27,
                    template_app (template_hole 26, template_hole 25)),
                  template_app
                   (template_app
                     (template_hole 24,
                      template_app
                       (template_app (template_hole 23, template_hole 22),
                        template_app
                         (template_app (template_hole 23, template_hole 22),
                          template_var 5))),
                    template_app
                     (template_app
                       (template_hole 21,
                        template_app
                         (template_app
                           (template_hole 20,
                            template_app
                             (template_hole 26, template_var 4)),
                          template_hole 19)),
                      template_app
                       (template_app (template_hole 20, template_var 3),
                        template_hole 22))))),
              template_app
               (template_app (template_hole 18, template_hole 17),
                template_hole 25)),
            template_var 2),
          template_app
           (template_app
             (template_hole 27,
              template_app (template_hole 26, template_hole 16)),
            template_app
             (template_app
               (template_hole 24,
                template_app
                 (template_app
                   (template_hole 21,
                    template_app
                     (template_app (template_hole 20, template_var 1),
                      template_hole 22)),
                  template_app
                   (template_app (template_hole 23, template_hole 22),
                    template_app
                     (template_app (template_hole 23, template_hole 22),
                      template_var 5)))),
              template_app
               (template_app
                 (template_hole 21,
                  template_app
                   (template_app
                     (template_hole 20,
                      template_app
                       (template_hole 26,
                        template_app
                         (template_app
                           (template_hole 15,
                            template_app
                             (template_hole 14,
                              template_app
                               (template_hole 13,
                                template_app
                                 (template_hole 13, template_hole 12)))),
                          template_var 4))),
                    template_hole 19)),
                template_app
                 (template_app (template_hole 20, template_var 0),
                  template_hole 22)))))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_hole 28,
               template_app
                (template_app
                  (template_hole 27,
                   template_app
                    (template_app
                      (template_hole 11,
                       template_app (template_hole 26, template_hole 25)),
                     template_app
                      (template_app
                        (template_hole 10,
                         template_app
                          (template_hole 9,
                           template_app
                            (template_app
                              (template_hole 8, template_hole 7),
                             template_app
                              (template_app
                                (template_hole 8,
                                 template_app
                                  (template_app
                                    (template_hole 6, template_hole 5),
                                   template_app
                                    (template_app
(template_hole 10, template_app (template_hole 9, template_hole 7)),
                                     template_app
(template_hole 14, template_app (template_hole 13, template_hole 12))))),
                               template_app
                                (template_app
                                  (template_hole 4,
                                   template_app
                                    (template_app
(template_hole 3, template_hole 2),
                                     template_hole 1)),
                                 template_app
                                  (template_app
                                    (template_hole 4,
                                     template_app
(template_app (template_hole 3, template_hole 2), template_hole 1)),
                                   template_hole 0)))))),
                       template_app
                        (template_hole 14,
                         template_app
                          (template_hole 13, template_hole 12))))),
                 template_app
                  (template_app
                    (template_hole 24,
                     template_app
                      (template_app (template_hole 23, template_hole 22),
                       template_app
                        (template_app (template_hole 23, template_hole 22),
                         template_var 5))),
                   template_app
                    (template_app
                      (template_hole 21,
                       template_app
                        (template_app
                          (template_hole 20,
                           template_app (template_hole 26, template_var 4)),
                         template_hole 19)),
                     template_app
                      (template_app (template_hole 20, template_var 3),
                       template_hole 22))))),
             template_app
              (template_app
                (template_hole 18,
                 template_app
                  (template_app
                    (template_hole 8,
                     template_app
                      (template_app (template_hole 8, template_hole 7),
                       template_app
                        (template_app
                          (template_hole 8,
                           template_app
                            (template_app
                              (template_hole 6, template_hole 5),
                             template_app
                              (template_app
                                (template_hole 10,
                                 template_app
                                  (template_hole 9, template_hole 7)),
                               template_app
                                (template_hole 14,
                                 template_app
                                  (template_hole 13, template_hole 12))))),
                         template_app
                          (template_app
                            (template_hole 4,
                             template_app
                              (template_app
                                (template_hole 3, template_hole 2),
                               template_hole 1)),
                           template_app
                            (template_app
                              (template_hole 4,
                               template_app
                                (template_app
                                  (template_hole 3, template_hole 2),
                                 template_hole 1)),
                             template_hole 0))))),
                   template_app
                    (template_app
                      (template_hole 8,
                       template_app
                        (template_app (template_hole 6, template_hole 17),
                         template_app
                          (template_app
                            (template_hole 10,
                             template_app
                              (template_hole 9,
                               template_app
                                (template_app
                                  (template_hole 8, template_hole 7),
                                 template_app
                                  (template_app
                                    (template_hole 8,
                                     template_app
(template_app (template_hole 6, template_hole 5),
 template_app
  (template_app
    (template_hole 10, template_app (template_hole 9, template_hole 7)),
   template_app
    (template_hole 14,
     template_app (template_hole 13, template_hole 12))))),
                                   template_app
                                    (template_app
(template_hole 4,
 template_app
  (template_app (template_hole 3, template_hole 2), template_hole 1)),
                                     template_app
(template_app
  (template_hole 4,
   template_app
    (template_app (template_hole 3, template_hole 2), template_hole 1)),
 template_hole 0)))))),
                           template_app
                            (template_hole 14,
                             template_app
                              (template_hole 13, template_hole 12))))),
                     template_app
                      (template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, template_hole 2),
                           template_hole 1)),
                       template_app
                        (template_app
                          (template_hole 4,
                           template_app
                            (template_app
                              (template_hole 3, template_hole 2),
                             template_hole 1)),
                         template_hole 0))))),
               template_hole 25)),
           template_var 2),
         template_app
          (template_app
            (template_hole 27,
             template_app
              (template_app
                (template_hole 11,
                 template_app (template_hole 26, template_hole 16)),
               template_app
                (template_app
                  (template_hole 10,
                   template_app
                    (template_hole 9,
                     template_app
                      (template_app (template_hole 8, template_hole 7),
                       template_app
                        (template_app
                          (template_hole 8,
                           template_app
                            (template_app
                              (template_hole 6, template_hole 5),
                             template_app
                              (template_app
                                (template_hole 10,
                                 template_app
                                  (template_hole 9, template_hole 7)),
                               template_app
                                (template_hole 14,
                                 template_app
                                  (template_hole 13, template_hole 12))))),
                         template_app
                          (template_app
                            (template_hole 4,
                             template_app
                              (template_app
                                (template_hole 3, template_hole 2),
                               template_hole 1)),
                           template_app
                            (template_app
                              (template_hole 4,
                               template_app
                                (template_app
                                  (template_hole 3, template_hole 2),
                                 template_hole 1)),
                             template_hole 0)))))),
                 template_app
                  (template_hole 14,
                   template_app (template_hole 13, template_hole 12))))),
           template_app
            (template_app
              (template_hole 24,
               template_app
                (template_app
                  (template_hole 21,
                   template_app
                    (template_app (template_hole 20, template_var 1),
                     template_hole 22)),
                 template_app
                  (template_app (template_hole 23, template_hole 22),
                   template_app
                    (template_app (template_hole 23, template_hole 22),
                     template_var 5)))),
             template_app
              (template_app
                (template_hole 21,
                 template_app
                  (template_app
                    (template_hole 20,
                     template_app
                      (template_hole 26,
                       template_app
                        (template_app
                          (template_hole 15,
                           template_app
                            (template_hole 14,
                             template_app
                              (template_hole 13,
                               template_app
                                (template_hole 13, template_hole 12)))),
                         template_var 4))),
                   template_hole 19)),
               template_app
                (template_app (template_hole 20, template_var 0),
                 template_hole 22)))))))]:
   (string * thm * template) list
### theory "Draft.UTMMoreTemplates"
### 0.649s elapsed time, 0.922s cpu time, 0.102s GC time
val it = (): unit
