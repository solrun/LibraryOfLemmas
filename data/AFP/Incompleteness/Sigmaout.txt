Loading theory "HOL-Library.Function_Algebras" (required by "Draft.SigmaMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Cancellation" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "HOL-Library.Multiset")
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.SigmaMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "HOL-Library.Function_Algebras"
### 0.114s elapsed time, 0.469s cpu time, 0.041s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "HOL-Library.FSet" via "HOL-Library.Countable")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  enumerate :: "'a set => nat => 'a"
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Infinite_Set"
### 0.292s elapsed time, 1.167s cpu time, 0.113s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "FinFun.FinFun" via "HOL-Library.Cardinality")
### theory "HOL-Library.Nat_Bijection"
### 0.330s elapsed time, 1.320s cpu time, 0.113s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.SigmaMoreTemplates" via "Draft.ExtrEqs")
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.482s elapsed time, 1.916s cpu time, 0.195s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.449s elapsed time, 1.765s cpu time, 0.154s GC time
Loading theory "HereditarilyFinite.HF" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "HereditarilyFinite.OrdArith" via "HereditarilyFinite.Rank" via "HereditarilyFinite.Ordinal")
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
instantiation
  hf :: zero
  zero_hf == zero_class.zero :: hf
instantiation
  hf :: sup
  sup_hf == sup :: hf => hf => hf
instantiation
  hf :: inf
  inf_hf == inf :: hf => hf => hf
instantiation
  hf :: minus
  minus_hf == minus :: hf => hf => hf
consts
  shift :: "'a list => 'a stream => 'a stream"
### theory "HOL-Library.Phantom_Type"
### 0.566s elapsed time, 2.227s cpu time, 0.251s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "FinFun.FinFun")
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
instantiation
  hf :: order
  less_eq_hf == less_eq :: hf => hf => bool
  less_hf == less :: hf => hf => bool
instantiation
  hf :: distrib_lattice
### Additional type variable(s) in locale specification "CARD_1": 'a
instantiation
  hf :: bounded_lattice_bot
  bot_hf == bot :: hf
consts
  snth :: "'a stream => nat => 'a"
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
### Additional type variable(s) in locale specification "card2": 'a
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
consts
  flat :: "'a list stream => 'a stream"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
instantiation
  hf :: times
  times_hf == times :: hf => hf => hf
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  hf :: mult_zero
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  hf :: zero_neq_one
  one_hf == one_class.one :: hf
instantiation
  hf :: plus
  plus_hf == plus :: hf => hf => hf
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
### theory "HOL-Library.Stream"
### 1.192s elapsed time, 4.534s cpu time, 0.900s GC time
Loading theory "HOL-Library.Quotient_Syntax" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs" via "HOL-Library.Quotient_List" via "HOL-Library.Quotient_Set")
### theory "HereditarilyFinite.HF"
### 0.955s elapsed time, 3.602s cpu time, 0.818s GC time
Loading theory "HereditarilyFinite.Ordinal" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "HereditarilyFinite.OrdArith" via "HereditarilyFinite.Rank")
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
### theory "HOL-Library.Quotient_Syntax"
### 0.029s elapsed time, 0.113s cpu time, 0.000s GC time
Loading theory "HOL-Library.Quotient_Option" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs" via "HOL-Library.Quotient_List")
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
### theory "HOL-Library.Quotient_Option"
### 0.078s elapsed time, 0.309s cpu time, 0.078s GC time
Loading theory "HOL-Library.Quotient_Product" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs" via "HOL-Library.Quotient_List")
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
### theory "HOL-Library.Quotient_Product"
### 0.088s elapsed time, 0.351s cpu time, 0.000s GC time
Loading theory "HOL-Library.Quotient_Set" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs" via "HOL-Library.Quotient_List")
Found termination order: "size <*mlex*> {}"
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
### theory "HOL-Library.Cardinality"
### 0.958s elapsed time, 3.614s cpu time, 0.816s GC time
Loading theory "FinFun.FinFun" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
### theory "HOL-Library.Quotient_Set"
### 0.097s elapsed time, 0.381s cpu time, 0.089s GC time
Loading theory "HOL-Library.Quotient_List" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Abs")
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
### theory "HereditarilyFinite.Ordinal"
### 0.346s elapsed time, 1.368s cpu time, 0.167s GC time
Loading theory "HereditarilyFinite.Rank" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "HereditarilyFinite.OrdArith")
bundle finfun
### theory "HereditarilyFinite.Rank"
### 0.160s elapsed time, 0.626s cpu time, 0.105s GC time
Loading theory "HereditarilyFinite.OrdArith" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN")
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
### theory "HOL-Library.Quotient_List"
### 0.383s elapsed time, 1.508s cpu time, 0.216s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.SigmaMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
consts
  mset :: "'a list => 'a multiset"
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
locale finfun_rec_wf_aux
  fixes cnst :: "'b => 'c"
    and upd :: "'a => 'b => 'c => 'c"
  assumes "finfun_rec_wf_aux cnst upd"
locale finfun_rec_wf
  fixes cnst :: "'b => 'c"
    and upd :: "'a => 'b => 'c => 'c"
  assumes "finfun_rec_wf cnst upd"
### theory "HereditarilyFinite.OrdArith"
### 0.615s elapsed time, 2.289s cpu time, 1.019s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.SigmaMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Set_Algebras"
### 0.485s elapsed time, 1.774s cpu time, 0.908s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base" via "HOL-Library.FSet")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
instantiation
  finfun :: ({card_UNIV,equal}, equal) equal
  equal_finfun == equal_class.equal ::
    'a \<Rightarrow>f 'b => 'a \<Rightarrow>f 'b => bool
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
instantiation
  finfun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_finfun == finite_UNIV :: ('a \<Rightarrow>f 'b, bool) phantom
instantiation
  finfun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_finfun == card_UNIV_class.card_UNIV ::
    ('a \<Rightarrow>f 'b, nat) phantom
bundle finfun_syntax
bundle no_finfun_syntax
### Additional type variable(s) in locale specification "countable": 'a
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
Found termination order: "size <*mlex*> {}"
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Countable"
### 1.581s elapsed time, 6.032s cpu time, 1.716s GC time
Loading theory "HOL-Library.FSet" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2" via "Nominal2.Nominal2_Base")
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (finite) finite
instantiation
  fset :: (type) {minus,bounded_lattice_bot,distrib_lattice}
  inf_fset == inf :: 'a fset => 'a fset => 'a fset
  bot_fset == bot :: 'a fset
  sup_fset == sup :: 'a fset => 'a fset => 'a fset
  less_eq_fset == less_eq :: 'a fset => 'a fset => bool
  less_fset == less :: 'a fset => 'a fset => bool
  minus_fset == minus :: 'a fset => 'a fset => 'a fset
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "FinFun.FinFun"
### 2.671s elapsed time, 10.175s cpu time, 2.977s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.SigmaMoreTemplates" via "Draft.ExtrEqs")
instantiation
  fset :: (equal) equal
  equal_fset == equal_class.equal :: 'a fset => 'a fset => bool
instantiation
  fset :: (type) conditionally_complete_lattice
  Inf_fset == Inf :: 'a fset set => 'a fset
  Sup_fset == Sup :: 'a fset set => 'a fset
Found termination order: "size <*mlex*> {}"
instantiation
  fset :: (finite) complete_lattice
  top_fset == top :: 'a fset
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
instantiation
  fset :: (finite) complete_boolean_algebra
  uminus_fset == uminus :: 'a fset => 'a fset
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
### theory "HOL-Library.Tree"
### 2.461s elapsed time, 9.489s cpu time, 2.117s GC time
Loading theory "Draft.Templates" (required by "Draft.SigmaMoreTemplates" via "Draft.ExtrEqs")
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.067s elapsed time, 0.267s cpu time, 0.000s GC time
### theory "HOL-Library.Multiset"
### 4.714s elapsed time, 18.039s cpu time, 4.226s GC time
### theory "HOL-Library.BigO"
### 0.859s elapsed time, 3.244s cpu time, 0.386s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.SigmaMoreTemplates")
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.547s elapsed time, 1.199s cpu time, 0.084s GC time
locale comp_fun_idem
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_idem f"
locale comm_monoid_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_fset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### Cannot skip proof of schematic goal statement
locale semilattice_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "semilattice_fset (\<^bold>*)"
locale semilattice_order_fset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes "semilattice_order_fset (\<^bold>*) (\<^bold>\<le>) (\<^bold><)"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  fset :: (type) size
  size_fset == size :: 'a fset => nat
instantiation
  fset :: (exhaustive) exhaustive
  exhaustive_fset == exhaustive_class.exhaustive ::
    ('a fset => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  fset :: (full_exhaustive) full_exhaustive
  full_exhaustive_fset == full_exhaustive_class.full_exhaustive ::
    ('a fset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  fset :: (random) random
  random_fset == random_class.random ::
    natural
    => natural * natural => ('a fset * (unit => term)) * natural * natural
### Additional type variable(s) in specification of "random_aux_fset_rel": 'a
### Additional type variable(s) in specification of "random_aux_fset_dom": 'a
Found termination order: "(%p. nat_of_natural (fst p)) <*mlex*> {}"
### theory "HOL-Library.FSet"
### 2.445s elapsed time, 6.253s cpu time, 0.753s GC time
Loading theory "Nominal2.Nominal2_Base" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2")
consts
  sort_of :: "atom => atom_sort"
consts
  nat_of :: "atom => nat"
instantiation
  perm :: group_add
  minus_perm == minus :: perm => perm => perm
  uminus_perm == uminus :: perm => perm
  zero_perm == zero_class.zero :: perm
  plus_perm == plus :: perm => perm => perm
class pt = type +
  fixes permute :: "perm => 'a => 'a"
  assumes "permute_zero": "!!x. 0 \<bullet> x = x"
  assumes
    "permute_plus":
      "!!p q x. (p + q) \<bullet> x = p \<bullet> q \<bullet> x"
instantiation
  atom :: pt
  permute_atom == permute :: perm => atom => atom
instantiation
  perm :: pt
  permute_perm == permute :: perm => perm => perm
instantiation
  fun :: (pt, pt) pt
  permute_fun == permute :: perm => ('a => 'b) => 'a => 'b
instantiation
  bool :: pt
  permute_bool == permute :: perm => bool => bool
instantiation
  set :: (pt) pt
  permute_set == permute :: perm => 'a set => 'a set
instantiation
  unit :: pt
  permute_unit == permute :: perm => unit => unit
instantiation
  prod :: (pt, pt) pt
  permute_prod == permute :: perm => 'a * 'b => 'a * 'b
consts
  permute_prod :: "perm => 'a * 'b => 'a * 'b"
instantiation
  sum :: (pt, pt) pt
  permute_sum == permute :: perm => 'a + 'b => 'a + 'b
consts
  permute_sum :: "perm => 'a + 'b => 'a + 'b"
instantiation
  list :: (pt) pt
  permute_list == permute :: perm => 'a list => 'a list
consts
  permute_list :: "perm => 'a list => 'a list"
instantiation
  option :: (pt) pt
  permute_option == permute :: perm => 'a option => 'a option
consts
  permute_option :: "perm => 'a option => 'a option"
instantiation
  multiset :: (pt) pt
  permute_multiset == permute :: perm => 'a multiset => 'a multiset
instantiation
  fset :: (pt) pt
  permute_fset == permute :: perm => 'a fset => 'a fset
instantiation
  finfun :: (pt, pt) pt
  permute_finfun == permute :: perm => ('a, 'b) finfun => ('a, 'b) finfun
instantiation
  char :: pt
  permute_char == permute :: perm => char => char
instantiation
  nat :: pt
  permute_nat == permute :: perm => nat => nat
instantiation
  int :: pt
  permute_int == permute :: perm => int => int
class pure = pt +
  assumes "permute_pure": "!!p x. p \<bullet> x = x"
### ML warning (line 75 of "$AFP/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 93 of "$AFP/Nominal2/nominal_basics.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 115 of "$AFP/Nominal2/nominal_basics.ML"):
### Matches are not exhaustive.
### ML warning (line 118 of "$AFP/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 130 of "$AFP/Nominal2/nominal_basics.ML"):
### Value identifier (z) has not been referenced.
### ML warning (line 130 of "$AFP/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 129 of "$AFP/Nominal2/nominal_basics.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 152 of "$AFP/Nominal2/nominal_basics.ML"):
### Pattern is not exhaustive.
infix 1 ||>>>
infix 1 |>>>
signature NOMINAL_BASIC =
  sig
    val dest_fsetT: typ -> typ
    val dest_listT: typ -> typ
    val dest_perm: term -> term * term
    val fixed_nonfixed_args: Proof.context -> term -> term * term list
    val fold_left: ('a * 'a -> 'a) -> 'a list -> 'a -> 'a
    val is_fixed: Proof.context -> term -> bool
    val is_true: term -> bool
    val last2: 'a list -> 'a * 'a
    val long_name: Proof.context -> string -> string
    val map4:
       ('a -> 'b -> 'c -> 'd -> 'e) ->
         'a list -> 'b list -> 'c list -> 'd list -> 'e list
    val mk_All: string * typ -> term -> term
    val mk_all: string * typ -> term -> term
    val mk_case_sum: term -> term -> term
    val mk_equiv: thm -> thm
    val mk_exists: string * typ -> term -> term
    val mk_id: term -> term
    val mk_minus: term -> term
    val mk_perm: term -> term -> term
    val mk_perm_ty: typ -> term -> term -> term
    val mk_plus: term -> term -> term
    val order: ('a * 'a -> bool) -> 'a list -> ('a * 'b) list -> 'b list
    val order_default:
       ('a * 'a -> bool) -> 'b -> 'a list -> ('a * 'b) list -> 'b list
    val perm_const: typ -> term
    val perm_ty: typ -> typ
    val remove_dups: ('a * 'a -> bool) -> 'a list -> 'a list
    val safe_mk_equiv: thm -> thm
    val split_filter: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_last2: 'a list -> 'a list * 'a * 'a
    val split_triples: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
    val trace: bool ref
    val trace_msg: (unit -> string) -> unit
    val |>>> : 'a * ('a -> 'b * 'c) -> 'b list * 'c
    val ||>>> : ('a list * 'b) * ('b -> 'a * 'b) -> 'a list * 'b
  end
structure Nominal_Basic: NOMINAL_BASIC
val order = fn: ('a * 'a -> bool) -> 'a list -> ('a * 'b) list -> 'b list
val dest_listT = fn: typ -> typ
val mk_perm = fn: term -> term -> term
val mk_plus = fn: term -> term -> term
val split_filter = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val fold_left = fn: ('a * 'a -> 'a) -> 'a list -> 'a -> 'a
val split_last2 = fn: 'a list -> 'a list * 'a * 'a
val order_default = fn:
   ('a * 'a -> bool) -> 'b -> 'a list -> ('a * 'b) list -> 'b list
val perm_const = fn: typ -> term
val last2 = fn: 'a list -> 'a * 'a
val mk_perm_ty = fn: typ -> term -> term -> term
val is_fixed = fn: Proof.context -> term -> bool
val mk_id = fn: term -> term
val mk_All = fn: string * typ -> term -> term
val map4 = fn:
   ('a -> 'b -> 'c -> 'd -> 'e) ->
     'a list -> 'b list -> 'c list -> 'd list -> 'e list
val is_true = fn: term -> bool
val safe_mk_equiv = fn: thm -> thm
val trace = ref false: bool ref
val mk_all = fn: string * typ -> term -> term
val mk_case_sum = fn: term -> term -> term
val dest_fsetT = fn: typ -> typ
val remove_dups = fn: ('a * 'a -> bool) -> 'a list -> 'a list
val fixed_nonfixed_args = fn: Proof.context -> term -> term * term list
val |>>> = fn: 'a * ('a -> 'b * 'c) -> 'b list * 'c
val dest_perm = fn: term -> term * term
val mk_equiv = fn: thm -> thm
val perm_ty = fn: typ -> typ
val mk_exists = fn: string * typ -> term -> term
val long_name = fn: Proof.context -> string -> string
val split_triples = fn: ('a * 'b * 'c) list -> 'a list * 'b list * 'c list
val mk_minus = fn: term -> term
val ||>>> = fn: ('a list * 'b) * ('b -> 'a * 'b) -> 'a list * 'b
val trace_msg = fn: (unit -> string) -> unit
### ML warning (line 200 of "$AFP/Nominal2/nominal_thmdecls.ML"):
### Pattern is not exhaustive.
### ML warning (line 200 of "$AFP/Nominal2/nominal_thmdecls.ML"):
### Value identifier (p') has not been referenced.
### ML warning (line 241 of "$AFP/Nominal2/nominal_thmdecls.ML"):
### Pattern is not exhaustive.
signature NOMINAL_THMDECLS =
  sig
    val eqvt_add: attribute
    val eqvt_del: attribute
    val eqvt_raw_add: attribute
    val eqvt_raw_del: attribute
    val eqvt_transform: Proof.context -> thm -> thm
    val get_eqvts_raw_thms: Proof.context -> thm list
    val get_eqvts_thms: Proof.context -> thm list
    val is_eqvt: Proof.context -> term -> bool
  end
structure Nominal_ThmDecls: NOMINAL_THMDECLS
### ML warning (line 72 of "$AFP/Nominal2/nominal_permeq.ML"):
### Value identifier (pre_thms) has not been referenced.
### ML warning (line 78 of "$AFP/Nominal2/nominal_permeq.ML"):
### Value identifier (post_thms) has not been referenced.
infix 4 addpres
infix 4 addposts
infix 4 addexcls
signature NOMINAL_PERMEQ =
  sig
    val addexcls: eqvt_config * string list -> eqvt_config
    val addposts: eqvt_config * thm list -> eqvt_config
    val addpres: eqvt_config * thm list -> eqvt_config
    val args_parser: (thm list * string list) context_parser
    val delposts: eqvt_config -> eqvt_config
    val delpres: eqvt_config -> eqvt_config
    datatype eqvt_config
    =
         Eqvt_Config of
             {excluded: string list,
              post_thms: thm list, pre_thms: thm list, strict_mode: bool}
    val eqvt_conv: Proof.context -> eqvt_config -> conv
    val eqvt_relaxed_config: eqvt_config
    val eqvt_rule: Proof.context -> eqvt_config -> thm -> thm
    val eqvt_strict_config: eqvt_config
    val eqvt_tac: Proof.context -> eqvt_config -> int -> tactic
    val perm_simp_meth:
       thm list * string list -> Proof.context -> Proof.method
    val perm_strict_simp_meth:
       thm list * string list -> Proof.context -> Proof.method
    val trace_eqvt: bool Config.T
  end
structure Nominal_Permeq: NOMINAL_PERMEQ
class le_eqvt = pt + order +
  assumes
    "le_eqvt":
      "!!p x y. p \<bullet> (x <= y) = (p \<bullet> x <= p \<bullet> y)"
class inf_eqvt = complete_lattice + pt +
  assumes "inf_eqvt": "!!p X. p \<bullet> Inf X = Inf (p \<bullet> X)"
instantiation
  bool :: le_eqvt
instantiation
  fun :: (pt, le_eqvt) le_eqvt
instantiation
  bool :: inf_eqvt
instantiation
  fun :: (pt, inf_eqvt) inf_eqvt
class pt = type +
  fixes permute :: "perm => 'a => 'a"
  assumes "permute_zero": "!!x. 0 \<bullet> x = x"
  assumes
    "permute_plus":
      "!!p q x. (p + q) \<bullet> x = p \<bullet> q \<bullet> x"
class fs = pt +
  assumes "finite_supp": "!!x. finite (supp x)"
class at_base = pt +
  fixes atom :: "'a => atom"
  assumes "atom_eq_iff": "!!a b. (atom a = atom b) = (a = b)"
  assumes "atom_eqvt": "!!p a. p \<bullet> atom a = atom (p \<bullet> a)"
class at = at_base +
  assumes "sort_of_atom_eq": "!!a b. sort_of (atom a) = sort_of (atom b)"
### ML warning (line 260 of "$AFP/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 259 of "$AFP/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 258 of "$AFP/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
### ML warning (line 257 of "$AFP/Nominal2/nominal_library.ML"):
### Value identifier (tys) has not been referenced.
type cns_info = (term * typ * typ list * bool list) list
signature NOMINAL_LIBRARY =
  sig
    val all_dtyp_constrs_types: Old_Datatype_Aux.descr -> cns_info list
    val atom_const: typ -> term
    val atom_ty: typ -> typ
    val atomify: Proof.context -> term -> term
    val atomify_ty: Proof.context -> typ -> term -> term
    val atomize: Proof.context -> thm -> thm
    val atomize_concl: Proof.context -> thm -> thm
    val atomize_rule: Proof.context -> int -> thm -> thm
    type cns_info = (term * typ * typ list * bool list) list
    val conj_tac: Proof.context -> (int -> tactic) -> int -> tactic
    val finite_const: typ -> term
    val fold_append: term list -> term
    val fold_conj: term list -> term
    val fold_conj_balanced: term list -> term
    val fold_union: term list -> term
    val fold_union_env: typ list -> term list -> term
    val fresh_args: Proof.context -> term -> term list
    val fresh_const: typ -> term
    val fresh_star_const: typ -> term
    val is_atom: Proof.context -> typ -> bool
    val is_atom_fset: Proof.context -> typ -> bool
    val is_atom_list: Proof.context -> typ -> bool
    val is_atom_set: Proof.context -> typ -> bool
    val listify: Proof.context -> term -> term
    val listify_ty: Proof.context -> typ -> term -> term
    val mk_append: term * term -> term
    val mk_atom: term -> term
    val mk_atom_fset: term -> term
    val mk_atom_fset_ty: typ -> term -> term
    val mk_atom_list: term -> term
    val mk_atom_list_ty: typ -> term -> term
    val mk_atom_set: term -> term
    val mk_atom_set_ty: typ -> term -> term
    val mk_atom_ty: typ -> term -> term
    val mk_binop_env: typ list -> string -> term * term -> term
    val mk_conj: term * term -> term
    val mk_diff: term * term -> term
    val mk_finite: term -> term
    val mk_finite_ty: typ -> term -> term
    val mk_fresh: term -> term -> term
    val mk_fresh_star: term -> term -> term
    val mk_fresh_star_ty: typ -> term -> term -> term
    val mk_fresh_ty: typ -> term -> term -> term
    val mk_full_horn: (string * typ) list -> term list -> term -> term
    val mk_sort_of: term -> term
    val mk_supp: term -> term
    val mk_supp_rel: term -> term -> term
    val mk_supp_rel_ty: typ -> term -> term -> term
    val mk_supp_ty: typ -> term -> term
    val mk_supports: term -> term -> term
    val mk_supports_ty: typ -> term -> term -> term
    val mk_union: term * term -> term
    val mk_union_env: typ list -> term * term -> term
    val pat_completeness_simp: thm list -> Proof.context -> tactic
    val prove_termination_fun:
       thm list -> Proof.context -> Function.info * local_theory
    val prove_termination_ind: Proof.context -> int -> tactic
    val setify: Proof.context -> term -> term
    val setify_ty: Proof.context -> typ -> term -> term
    val size_ss: simpset
    val strip_full_horn: term -> (string * typ) list * term list * term
    val supp_const: typ -> term
    val supp_rel_const: typ -> term
    val supports_const: typ -> term
    val to_set: term -> term
    val to_set_ty: typ -> term -> term
    val transform_prem1: Proof.context -> string list -> thm -> thm
    val transform_prem2: Proof.context -> string list -> thm -> thm
  end
structure Nominal_Library: NOMINAL_LIBRARY
val conj_tac = fn: Proof.context -> (int -> tactic) -> int -> tactic
val is_atom_fset = fn: Proof.context -> typ -> bool
val mk_union_env = fn: typ list -> term * term -> term
val size_ss =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb =
                        Net {atoms =
                             {("HOL.eq",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[{elhs = "... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Abs ("...", "?'d1", ...), name = "HOL.simp_thms_38",
  ...}]})},
                             comb = Leaf [], var = Leaf []},
                        var =
                        Leaf
                         [{elhs = "EX x. ?t1 = x & ?P1 x", extra = false,
                           fo = false, lhs =
                           Const ("HOL.Ex", "(... ... ...) => bool") $
                             Abs ("x", "?'d1",
                               Const ("...", ...) $ (... $ ... $ ...) $
                                 ...),
                           name = "HOL.simp_thms_40", perm = false, thm =
                           "EX x. ?t1 ... x & ?P1 x == ?P1 ?t1"},
                          {elhs = "EX x. x = ?t1 & ?P1 x", extra = false,
                           fo = false, lhs =
                           Const ("HOL.Ex", "(...) ... bool") $
                             Abs ("x", "?'d1",
                               Const ("...", "bool => bool => bool") $ ... $
                                 ...),
                           name = "HOL.simp_thms_39", perm = false, thm =
                           "EX x. ... ... ... ... ... ... == ?P1 ?t1"},
                          {elhs = "EX x. x = ?t1", extra = false, fo = true,
                           lhs =
                           Const ("HOL.Ex", "... ... ...") $
                             Abs ("x", "...", ... $ ... $ ...),
                           name = "HOL.simp_thms_37", perm = false, thm =
                           "... x... ... ... ... == True"},
                          {elhs = "EX x. ?y", extra = false, fo = true,
                           lhs =
                           Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                           name = "HOL.simp_thms_36", perm = false, thm =
                           "... ...... ... ... ?y"},
                          {elhs = "... x... ... ... ...", extra = false,
                           fo = false, lhs =
                           Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                           name = "HOL.ex_simps_6", perm = false, thm =
                           "... ... ..."},
                          {elhs = "... ...... ...", extra = false, fo =
                           false, lhs =
                           Const ("...", ...) $ Abs ("...", "?'e1", ...),
                           name = "HOL.ex_simps_5", ...},
                          {elhs = "...", extra = false, fo = false, lhs =
                           Const ("...", "(?'d1 => bool) => bool") $ ...,
                           ...},
                          {elhs = "...", extra = false, fo = false, ...},
                          {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "ALL x. ?t1 ~= x", extra = false, fo =
                            true, lhs =
                            Const ("HOL.All", "(...) ... bool") $
                              Abs ("x", "?'d1",
                                Const ("...", "bool => bool") $ ...),
                            name = "HOL.simp_thms_44", perm = false, thm =
                            "ALL x. ?t1 ... x == False"},
                           {elhs = "ALL x. x ~= ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "HOL.simp_thms_43", perm = false, thm =
                            "... x... ... ... ... == False"},
                           {elhs = "ALL x. ... ... ... ... ... ...", extra =
                            false, fo = false, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.simp_thms_42", perm = false, thm =
                            "... ...... ... ... ... ..."},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "HOL.simp_thms_41", perm = false, thm =
                            "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'b1", ...),
                            name = "HOL.simp_thms_35", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'f1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "~ True", extra = false, fo = true,
                               lhs =
                               Const ("HOL.Not", "...") $
                                 Const ("HOL.True", "..."),
                               name = "HOL.simp_thms_7", perm = false, thm =
                               "... True ... False"}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "~ False", extra = false, fo = true,
                                lhs =
                                Const ("HOL.Not", "...") $
                                  Const ("...", ...),
                                name = "HOL.simp_thms_8", perm = false,
                                thm = "... ... ... ..."}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = "...", extra = false, fo = true, ...}]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = ..., extra = false, ...}]}),
                                ("HOL.Not",
                                  Net {atoms = {}, comb = Leaf [...], var =
 Leaf [...]})},
                              comb =
                              Net {atoms =
                                   {("HOL.eq",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("HOL.conj",
 Net {atoms = {}, comb = ..., var = ...}),
                                     ("HOL.disj", Net {atoms = {}, ...}),
                                     ("HOL.implies", ...)},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "THE x. x ... ?y", extra = false, fo =
                            true, lhs =
                            Const ("HOL.The", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.the_eq_trivial", perm = false, thm =
                            "... ...... ... ... ?y"}]}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...x... ... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("Pure.all", "...") $ Abs ("x", ..., ...),
                            name = "HOL.subst_all_2", perm = false, thm =
                            "... ... ... ..."},
                           {elhs = "......... ...", extra = false, fo =
                            false, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.subst_all_1", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'a => prop) => prop") $ ...,
                            ...}]}),
                  ("Wellfounded.wf",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("Wellfounded.measure",
                                 Net {atoms = {}, comb = ..., var = ...})},
                              comb = Leaf [], var = Leaf []},
                         var = Leaf []})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]})},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}})},
                                  comb = Leaf [], var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]})},
 comb = Leaf [], var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?x1 ... ?x1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1"),
                                     name = "HOL.simp_thms_6", perm = false,
                                     thm = "... ... ..."}]}}),
                       ("HOL.conj",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("HOL.Not",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                   comb =
                                   Net {atoms =
  {("HOL.conj", Net {atoms = {}, comb = ..., var = ...}),
    ("HOL.implies", Net {atoms = {}, ...})},
  comb = Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                     ("HOL.False",
 Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                   comb =
                                   Net {atoms =
  {("HOL.Not", Net {atoms = {}, comb = ..., var = ...})}, comb =
  Net {atoms = {("HOL.conj", ...)}, comb = Leaf [...], var = Leaf [...]},
  var = Leaf []},
                                   var =
                                   Leaf
                                    [{elhs = "... ... ...", extra = false,
fo = true, lhs = Const ("...", ...) $ Var ((...), "bool") $ ..., name =
"HOL.simp_thms_25", ...}]}}),
                       ("HOL.disj",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = "...", extra = false, fo = true, ...}]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = ..., extra = false, ...}]})},
                              comb =
                              Net {atoms =
                                   {("HOL.Not",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb =
                                   Net {atoms =
  {("HOL.disj", Net {atoms = {}, ...}), ("HOL.implies", ...)}, comb =
  Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True",
Leaf [{elhs = "...", extra = false, fo = true, ...}]),
                                     ("HOL.False",
 Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("HOL.Not", Net {atoms = {}, ...})}, comb =
  Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
                                   var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {("HOL.Trueprop", ...)},
  comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.member",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var = Leaf []}),
                       ("HOL.implies",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.False", Net {atoms = {}, ...})},
                              comb =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("HOL.True", ...), ...}, comb =
                                   Net {atoms = {...}, ...}, var =
                                   Leaf [...]}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("Groups.times_class.times",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Orderings.ord_class.less",
                         Net {atoms = {...}, comb = ..., var = ...})},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Sum_Type.sum.case_sum",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}}),
                            ("Basic_BNF_LFPs.prod.size_prod",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var = Leaf []}},
     {congs =
      ({((true, "HOL.implies"),
          "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
           ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q == PROP ?Q' |]
            ==> (PROP ?P =simp=> PROP ?Q) == (PROP ?P' =simp=> PROP ?Q')")},
       []),
      loop_tacs =
      [("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)], mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("Pure.all", "...") $
                               Abs ("x", "...", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms = {}, comb = Leaf [], var =
                             Net {atoms = {}, comb = Leaf [], var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "HOL.neq", proc = fn,
stamp = Stamp 91400}]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {("HOL.False", ...)}, comb = Leaf [...], var = Leaf [...]})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Orderings.ord_class.less",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb =
                                   Net {atoms =
  {("Groups.plus_class.plus", ...), ...}, comb = Leaf [...], var =
  Leaf [...]},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {("Nat.Suc", ...)}, comb =
  Net {atoms = {...}, ...}, var = Leaf [...]},
                                   var = Leaf []}})},
                     comb = Leaf [], var = Leaf []},
                var = Leaf []},
           var = Leaf []},
      solvers =
      ([Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val mk_finite = fn: term -> term
val fresh_args = fn: Proof.context -> term -> term list
val atom_ty = fn: typ -> typ
val mk_atom_set = fn: term -> term
val mk_fresh_star_ty = fn: typ -> term -> term -> term
val mk_full_horn = fn: (string * typ) list -> term list -> term -> term
val atomize_rule = fn: Proof.context -> int -> thm -> thm
val prove_termination_ind = fn: Proof.context -> int -> tactic
val supp_const = fn: typ -> term
val mk_diff = fn: term * term -> term
val supp_rel_const = fn: typ -> term
val setify_ty = fn: Proof.context -> typ -> term -> term
val transform_prem2 = fn: Proof.context -> string list -> thm -> thm
val fold_append = fn: term list -> term
val atomize = fn: Proof.context -> thm -> thm
val atom_const = fn: typ -> term
val mk_supports = fn: term -> term -> term
val fresh_star_const = fn: typ -> term
val is_atom_list = fn: Proof.context -> typ -> bool
val strip_full_horn = fn: term -> (string * typ) list * term list * term
val fold_conj = fn: term list -> term
val listify = fn: Proof.context -> term -> term
val fold_union = fn: term list -> term
val mk_union = fn: term * term -> term
val mk_atom = fn: term -> term
val mk_append = fn: term * term -> term
val all_dtyp_constrs_types = fn: Old_Datatype_Aux.descr -> cns_info list
val fold_union_env = fn: typ list -> term list -> term
val mk_fresh = fn: term -> term -> term
val is_atom_set = fn: Proof.context -> typ -> bool
val mk_sort_of = fn: term -> term
val listify_ty = fn: Proof.context -> typ -> term -> term
val mk_atom_fset_ty = fn: typ -> term -> term
val mk_fresh_star = fn: term -> term -> term
val to_set_ty = fn: typ -> term -> term
val mk_atom_ty = fn: typ -> term -> term
val mk_supp_rel_ty = fn: typ -> term -> term -> term
val prove_termination_fun = fn:
   thm list -> Proof.context -> Function.info * local_theory
val atomify = fn: Proof.context -> term -> term
val mk_atom_set_ty = fn: typ -> term -> term
val atomify_ty = fn: Proof.context -> typ -> term -> term
val pat_completeness_simp = fn: thm list -> Proof.context -> tactic
val mk_conj = fn: term * term -> term
val finite_const = fn: typ -> term
val setify = fn: Proof.context -> term -> term
val is_atom = fn: Proof.context -> typ -> bool
val mk_atom_fset = fn: term -> term
val mk_atom_list_ty = fn: typ -> term -> term
val transform_prem1 = fn: Proof.context -> string list -> thm -> thm
val mk_finite_ty = fn: typ -> term -> term
val mk_fresh_ty = fn: typ -> term -> term -> term
val mk_binop_env = fn: typ list -> string -> term * term -> term
val atomize_concl = fn: Proof.context -> thm -> thm
val fresh_const = fn: typ -> term
val fold_conj_balanced = fn: term list -> term
val supports_const = fn: typ -> term
val to_set = fn: term -> term
val mk_supp = fn: term -> term
val mk_supports_ty = fn: typ -> term -> term -> term
val mk_supp_rel = fn: term -> term -> term
val mk_atom_list = fn: term -> term
val mk_supp_ty = fn: typ -> term -> term
### ML warning (line 28 of "$AFP/Nominal2/nominal_atoms.ML"):
### Value identifier (arg) has not been referenced.
signature ATOM_DECL =
  sig val add_atom_decl: binding * binding option -> theory -> theory end
structure Atom_Decl: ATOM_DECL
### ML warning (line 77 of "$AFP/Nominal2/nominal_eqvt.ML"):
### Matches are not exhaustive.
### ML warning (line 93 of "$AFP/Nominal2/nominal_eqvt.ML"):
### Pattern is not exhaustive.
### ML warning (line 125 of "$AFP/Nominal2/nominal_eqvt.ML"):
### Pattern is not exhaustive.
signature NOMINAL_EQVT =
  sig
    val equivariance_cmd: string -> Proof.context -> local_theory
    val raw_equivariance:
       Proof.context -> term list -> thm -> thm list -> thm list
  end
structure Nominal_Eqvt: NOMINAL_EQVT
### theory "Nominal2.Nominal2_Base"
### 2.510s elapsed time, 2.732s cpu time, 0.300s GC time
Loading theory "Nominal2.Nominal2_Abs" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2")
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_set_rel ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) ==>
### alpha_set (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) ==
### ?f1 ?x1 - ?bs1 = ?f1 ?y1 - ?cs1 &
### (?f1 ?x1 - ?bs1) \<sharp>* ?p1 &
### ?R1 (?p1 \<bullet> ?x1) ?y1 & ?p1 \<bullet> ?bs1 = ?cs1
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_res_rel ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) ==>
### alpha_res (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) ==
### ?f1 ?x1 - ?bs1 = ?f1 ?y1 - ?cs1 &
### (?f1 ?x1 - ?bs1) \<sharp>* ?p1 & ?R1 (?p1 \<bullet> ?x1) ?y1
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_lst_rel ((?bs1, ?x1), ?R1, ?f1, ?p1, ?cs1, ?y1) ==>
### alpha_lst (?bs1, ?x1) ?R1 ?f1 ?p1 (?cs1, ?y1) ==
### ?f1 ?x1 - set ?bs1 = ?f1 ?y1 - set ?cs1 &
### (?f1 ?x1 - set ?bs1) \<sharp>* ?p1 &
### ?R1 (?p1 \<bullet> ?x1) ?y1 & ?p1 \<bullet> ?bs1 = ?cs1
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_set_rel ((?bs1, ?x1), ?cs1, ?y1) ==>
### alpha_abs_set (?bs1, ?x1) (?cs1, ?y1) ==
### EX p. (?bs1, ?x1) \<approx>set (=) supp p (?cs1, ?y1)
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_lst_rel ((?bs1, ?x1), ?cs1, ?y1) ==>
### alpha_abs_lst (?bs1, ?x1) (?cs1, ?y1) ==
### EX p. (?bs1, ?x1) \<approx>lst (=) supp p (?cs1, ?y1)
Found termination order: "{}"
### Rewrite rule not in simpset:
### Wellfounded.accp alpha_abs_res_rel ((?bs1, ?x1), ?cs1, ?y1) ==>
### alpha_abs_res (?bs1, ?x1) (?cs1, ?y1) ==
### EX p. (?bs1, ?x1) \<approx>res (=) supp p (?cs1, ?y1)
Found termination order: "{}"
instantiation
  abs_set :: (pt) pt
  permute_abs_set == permute :: perm => 'a abs_set => 'a abs_set
instantiation
  abs_res :: (pt) pt
  permute_abs_res == permute :: perm => 'a abs_res => 'a abs_res
instantiation
  abs_lst :: (pt) pt
  permute_abs_lst == permute :: perm => 'a abs_lst => 'a abs_lst
### ML warning (line 927 of "$AFP/Nominal2/Nominal2_Abs.thy"):
### Pattern is not exhaustive.
val alpha_single_simproc = fn:
   thm -> 'a -> Proof.context -> cterm -> thm option
Found termination order: "{}"
### theory "Nominal2.Nominal2_Abs"
### 1.209s elapsed time, 1.345s cpu time, 0.184s GC time
Loading theory "Nominal2.Nominal2_FCB" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN" via "Nominal2.Nominal2")
val all_trivials = fn: (Proof.context -> Proof.method) context_parser
### theory "Nominal2.Nominal2_FCB"
### 0.104s elapsed time, 0.105s cpu time, 0.000s GC time
Loading theory "Nominal2.Nominal2" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates" via "Draft.SyntaxN")
signature NOMINAL_DT_DATA =
  sig
    datatype alpha_result
    =
         AlphaResult of
             {alpha_bn_names: string list,
              alpha_bn_trms: term list,
              alpha_bn_tys: typ list,
              alpha_cases: thm list,
              alpha_intros: thm list,
              alpha_names: string list,
              alpha_raw_induct: thm,
              alpha_trms: term list, alpha_tys: typ list}
    datatype bclause = BC of bmode * (term option * int) list * int list
    datatype bmode = Lst | Res | Set
    type bn_info = term * int * (int * term option) list list
    val get_all_info: Proof.context -> (string * info) list
    val get_info: Proof.context -> string -> info option
    type info =
       {distinct: thm list,
        inject: thm list,
        strong_exhaust: thm list, strong_inducts: thm list}
    val mk_infos:
       string list ->
         thm list ->
           thm list -> thm list -> thm list -> (string * info) list
    datatype raw_dt_info
    =
         RawDtInfo of
             {raw_all_cns: term list list,
              raw_cns_info: cns_info list,
              raw_distinct_thms: thm list,
              raw_dt_names: string list,
              raw_dts: Old_Datatype.spec list,
              raw_exhaust_thms: thm list,
              raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
              raw_induct_thm: thm,
              raw_induct_thms: thm list,
              raw_inject_thms: thm list,
              raw_size_thms: thm list,
              raw_size_trms: term list,
              raw_ty_args: (string * sort) list, raw_tys: typ list}
    val register_info: string * info -> Context.generic -> Context.generic
    val the_info: Proof.context -> string -> info
    datatype user_data
    =
         UserData of
             {bclauses: bclause list list list,
              bn_eqs: (Attrib.binding * term) list,
              bn_funs: (binding * typ * mixfix) list,
              cn_names: string list,
              cn_tys: (string * string) list, dts: Old_Datatype.spec list}
  end
structure Nominal_Dt_Data: NOMINAL_DT_DATA
type bn_info = term * int * (int * term option) list list
datatype raw_dt_info
=
     RawDtInfo of
         {raw_all_cns: term list list,
          raw_cns_info: cns_info list,
          raw_distinct_thms: thm list,
          raw_dt_names: string list,
          raw_dts: Old_Datatype.spec list,
          raw_exhaust_thms: thm list,
          raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
          raw_induct_thm: thm,
          raw_induct_thms: thm list,
          raw_inject_thms: thm list,
          raw_size_thms: thm list,
          raw_size_trms: term list,
          raw_ty_args: (string * sort) list, raw_tys: typ list}
datatype user_data
=
     UserData of
         {bclauses: Nominal_Dt_Data.bclause list list list,
          bn_eqs: (Attrib.binding * term) list,
          bn_funs: (binding * typ * mixfix) list,
          cn_names: string list,
          cn_tys: (string * string) list, dts: Old_Datatype.spec list}
datatype bmode = Lst | Res | Set
datatype bclause = BC of bmode * (term option * int) list * int list
type info =
   {distinct: thm list,
    inject: thm list, strong_exhaust: thm list, strong_inducts: thm list}
datatype alpha_result
=
     AlphaResult of
         {alpha_bn_names: string list,
          alpha_bn_trms: term list,
          alpha_bn_tys: typ list,
          alpha_cases: thm list,
          alpha_intros: thm list,
          alpha_names: string list,
          alpha_raw_induct: thm, alpha_trms: term list, alpha_tys: typ list}
constructor Lst: bmode
constructor UserData:
   {bclauses: bclause list list list,
    bn_eqs: (Attrib.binding * term) list,
    bn_funs: (binding * typ * mixfix) list,
    cn_names: string list,
    cn_tys: (string * string) list, dts: Old_Datatype.spec list}
     -> user_data
val the_info = fn: Proof.context -> string -> info
val register_info = fn: string * info -> Context.generic -> Context.generic
val get_all_info = fn: Proof.context -> (string * info) list
constructor BC: bmode * (term option * int) list * int list -> bclause
val get_info = fn: Proof.context -> string -> info option
constructor Res: bmode
constructor AlphaResult:
   {alpha_bn_names: string list,
    alpha_bn_trms: term list,
    alpha_bn_tys: typ list,
    alpha_cases: thm list,
    alpha_intros: thm list,
    alpha_names: string list,
    alpha_raw_induct: thm, alpha_trms: term list, alpha_tys: typ list}
     -> alpha_result
constructor RawDtInfo:
   {raw_all_cns: term list list,
    raw_cns_info: cns_info list,
    raw_distinct_thms: thm list,
    raw_dt_names: string list,
    raw_dts: Old_Datatype.spec list,
    raw_exhaust_thms: thm list,
    raw_fp_sugars: BNF_FP_Def_Sugar.fp_sugar list,
    raw_induct_thm: thm,
    raw_induct_thms: thm list,
    raw_inject_thms: thm list,
    raw_size_thms: thm list,
    raw_size_trms: term list,
    raw_ty_args: (string * sort) list, raw_tys: typ list}
     -> raw_dt_info
constructor Set: bmode
val mk_infos = fn:
   string list ->
     thm list -> thm list -> thm list -> thm list -> (string * info) list
### ML warning (line 82 of "$AFP/Nominal2/nominal_dt_rawfuns.ML"):
### Pattern is not exhaustive.
### ML warning (line 296 of "$AFP/Nominal2/nominal_dt_rawfuns.ML"):
### Value identifier (lthy) has not been referenced.
### ML warning (line 538 of "$AFP/Nominal2/nominal_dt_rawfuns.ML"):
### Pattern is not exhaustive.
signature NOMINAL_DT_RAWFUNS =
  sig
    val define_raw_bn_perms:
       raw_dt_info ->
         bn_info list -> local_theory -> term list * thm list * local_theory
    val define_raw_bns:
       raw_dt_info ->
         (binding * typ option * mixfix) list ->
           Specification.multi_specs ->
             local_theory ->
               term list * thm list * bn_info list * thm list * local_theory
    val define_raw_fvs:
       raw_dt_info ->
         bn_info list ->
           bclause list list list ->
             Proof.context ->
               term list * term list * thm list * thm list * local_theory
    val define_raw_perms:
       raw_dt_info ->
         local_theory -> (term list * thm list * thm list) * local_theory
    val get_all_binders: bclause list -> (term option * int) list
    val is_recursive_binder: bclause -> bool
    val raw_prove_eqvt:
       term list -> thm list -> thm list -> Proof.context -> thm list
  end
structure Nominal_Dt_RawFuns: NOMINAL_DT_RAWFUNS
val get_all_binders = fn: bclause list -> (term option * int) list
val raw_prove_eqvt = fn:
   term list -> thm list -> thm list -> Proof.context -> thm list
val define_raw_bns = fn:
   raw_dt_info ->
     (binding * typ option * mixfix) list ->
       Specification.multi_specs ->
         local_theory ->
           term list * thm list * bn_info list * thm list * local_theory
val define_raw_fvs = fn:
   raw_dt_info ->
     bn_info list ->
       bclause list list list ->
         Proof.context ->
           term list * term list * thm list * thm list * local_theory
val define_raw_bn_perms = fn:
   raw_dt_info ->
     bn_info list -> local_theory -> term list * thm list * local_theory
val is_recursive_binder = fn: bclause -> bool
val define_raw_perms = fn:
   raw_dt_info ->
     local_theory -> (term list * thm list * thm list) * local_theory
### ML warning (line 381 of "$AFP/Nominal2/nominal_dt_alpha.ML"):
### Pattern is not exhaustive.
### ML warning (line 826 of "$AFP/Nominal2/nominal_dt_alpha.ML"):
### Pattern is not exhaustive.
signature NOMINAL_DT_ALPHA =
  sig
    val alpha_prove:
       term list ->
         (term * (term * term -> term)) list ->
           thm ->
             (Proof.context -> int -> tactic) -> Proof.context -> thm list
    val comb_binders:
       Proof.context ->
         bmode -> term list -> (term option * int) list -> term
    val define_raw_alpha:
       raw_dt_info ->
         bn_info list ->
           bclause list list list ->
             term list -> Proof.context -> alpha_result * local_theory
    val induct_prove:
       typ list ->
         (typ * (term -> term)) list ->
           thm ->
             (Proof.context -> int -> tactic) -> Proof.context -> thm list
    val mk_alpha_permute_rsp: Proof.context -> thm -> thm
    val mk_funs_rsp: Proof.context -> thm -> thm
    val raw_alpha_bn_rsp: alpha_result -> thm list -> thm list -> thm list
    val raw_constrs_rsp:
       Proof.context ->
         alpha_result -> term list list -> thm list -> thm list list
    val raw_fv_bn_rsp_aux:
       Proof.context ->
         alpha_result ->
           term list -> term list -> term list -> thm list -> thm list
    val raw_perm_bn_rsp:
       Proof.context -> alpha_result -> term list -> thm list -> thm list
    val raw_prove_alpha_distincts:
       Proof.context -> alpha_result -> raw_dt_info -> thm list
    val raw_prove_alpha_eq_iff:
       Proof.context -> alpha_result -> raw_dt_info -> thm list
    val raw_prove_bn_imp: Proof.context -> alpha_result -> thm list
    val raw_prove_equivp:
       Proof.context ->
         alpha_result ->
           thm list -> thm list -> thm list -> thm list * thm list
    val raw_prove_refl: Proof.context -> alpha_result -> thm -> thm list
    val raw_prove_sym: Proof.context -> alpha_result -> thm list -> thm list
    val raw_prove_trans:
       Proof.context -> alpha_result -> thm list -> thm list -> thm list
    val raw_size_rsp_aux:
       Proof.context -> alpha_result -> thm list -> thm list
  end
structure Nominal_Dt_Alpha: NOMINAL_DT_ALPHA
val raw_size_rsp_aux = fn:
   Proof.context -> alpha_result -> thm list -> thm list
val induct_prove = fn:
   typ list ->
     (typ * (term -> term)) list ->
       thm -> (Proof.context -> int -> tactic) -> Proof.context -> thm list
val raw_prove_refl = fn: Proof.context -> alpha_result -> thm -> thm list
val raw_prove_trans = fn:
   Proof.context -> alpha_result -> thm list -> thm list -> thm list
val raw_fv_bn_rsp_aux = fn:
   Proof.context ->
     alpha_result ->
       term list -> term list -> term list -> thm list -> thm list
val raw_perm_bn_rsp = fn:
   Proof.context -> alpha_result -> term list -> thm list -> thm list
val alpha_prove = fn:
   term list ->
     (term * (term * term -> term)) list ->
       thm -> (Proof.context -> int -> tactic) -> Proof.context -> thm list
val raw_alpha_bn_rsp = fn: alpha_result -> thm list -> thm list -> thm list
val define_raw_alpha = fn:
   raw_dt_info ->
     bn_info list ->
       bclause list list list ->
         term list -> Proof.context -> alpha_result * local_theory
val raw_prove_alpha_distincts = fn:
   Proof.context -> alpha_result -> raw_dt_info -> thm list
val comb_binders = fn:
   Proof.context -> bmode -> term list -> (term option * int) list -> term
val raw_prove_equivp = fn:
   Proof.context ->
     alpha_result -> thm list -> thm list -> thm list -> thm list * thm list
val raw_constrs_rsp = fn:
   Proof.context ->
     alpha_result -> term list list -> thm list -> thm list list
val raw_prove_alpha_eq_iff = fn:
   Proof.context -> alpha_result -> raw_dt_info -> thm list
val mk_alpha_permute_rsp = fn: Proof.context -> thm -> thm
val mk_funs_rsp = fn: Proof.context -> thm -> thm
val raw_prove_bn_imp = fn: Proof.context -> alpha_result -> thm list
val raw_prove_sym = fn:
   Proof.context -> alpha_result -> thm list -> thm list
### ML warning (line 80 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Value identifier (lhs_ty) has not been referenced.
### ML warning (line 80 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Value identifier (lhs_str) has not been referenced.
### ML warning (line 249 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Value identifier (qtys) has not been referenced.
### ML warning (line 293 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 369 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Pattern is not exhaustive.
### ML warning (line 390 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Pattern is not exhaustive.
### ML warning (line 574 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Pattern is not exhaustive.
### ML warning (line 628 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Pattern is not exhaustive.
### ML warning (line 669 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 708 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Pattern is not exhaustive.
### ML warning (line 710 of "$AFP/Nominal2/nominal_dt_quot.ML"):
### Pattern is not exhaustive.
signature NOMINAL_DT_QUOT =
  sig
    val define_qconsts:
       typ list ->
         (string * term * mixfix * thm) list ->
           local_theory -> Quotient_Info.quotconsts list * local_theory
    val define_qperms:
       typ list ->
         string list ->
           (string * sort) list ->
             (string * term * mixfix * thm) list ->
               thm list -> local_theory -> local_theory
    val define_qsizes:
       typ list ->
         string list ->
           (string * sort) list ->
             (string * term * mixfix * thm) list ->
               local_theory -> local_theory
    val define_qtypes:
       (string list * binding * mixfix) list ->
         typ list ->
           term list ->
             thm list ->
               local_theory -> Quotient_Info.quotients list * local_theory
    val fs_instance:
       typ list ->
         string list ->
           (string * sort) list -> thm list -> local_theory -> local_theory
    val lift_thms:
       typ list ->
         thm list -> thm list -> Proof.context -> thm list * Proof.context
    val prove_bns_finite:
       typ list -> term list -> thm -> thm list -> Proof.context -> thm list
    val prove_fsupp:
       Proof.context -> typ list -> thm -> thm list -> thm list
    val prove_fv_supp:
       typ list ->
         term list ->
           term list ->
             term list ->
               term list ->
                 thm list ->
                   thm list ->
                     thm list ->
                       thm list ->
                         thm ->
                           bclause list list -> Proof.context -> thm list
    val prove_perm_bn_alpha_thms:
       typ list ->
         term list ->
           term list ->
             thm ->
               thm list -> thm list -> thm list -> Proof.context -> thm list
    val prove_permute_bn_thms:
       typ list ->
         term list ->
           term list ->
             thm ->
               thm list -> thm list -> thm list -> Proof.context -> thm list
    val prove_strong_exhausts:
       Proof.context ->
         thm list ->
           bclause list list list ->
             thm list ->
               thm list -> thm list -> thm list -> thm list -> thm list
    val prove_strong_induct:
       Proof.context ->
         thm -> thm list -> thm list -> bclause list list list -> thm list
    val prove_supports: Proof.context -> thm list -> term list -> thm list
  end
structure Nominal_Dt_Quot: NOMINAL_DT_QUOT
val prove_permute_bn_thms = fn:
   typ list ->
     term list ->
       term list ->
         thm ->
           thm list -> thm list -> thm list -> Proof.context -> thm list
val define_qsizes = fn:
   typ list ->
     string list ->
       (string * sort) list ->
         (string * term * mixfix * thm) list -> local_theory -> local_theory
val prove_strong_exhausts = fn:
   Proof.context ->
     thm list ->
       bclause list list list ->
         thm list ->
           thm list -> thm list -> thm list -> thm list -> thm list
val prove_bns_finite = fn:
   typ list -> term list -> thm -> thm list -> Proof.context -> thm list
val prove_fsupp = fn:
   Proof.context -> typ list -> thm -> thm list -> thm list
val prove_fv_supp = fn:
   typ list ->
     term list ->
       term list ->
         term list ->
           term list ->
             thm list ->
               thm list ->
                 thm list ->
                   thm list ->
                     thm -> bclause list list -> Proof.context -> thm list
val prove_supports = fn: Proof.context -> thm list -> term list -> thm list
val prove_perm_bn_alpha_thms = fn:
   typ list ->
     term list ->
       term list ->
         thm ->
           thm list -> thm list -> thm list -> Proof.context -> thm list
val define_qtypes = fn:
   (string list * binding * mixfix) list ->
     typ list ->
       term list ->
         thm list ->
           local_theory -> Quotient_Info.quotients list * local_theory
val lift_thms = fn:
   typ list ->
     thm list -> thm list -> Proof.context -> thm list * Proof.context
val define_qperms = fn:
   typ list ->
     string list ->
       (string * sort) list ->
         (string * term * mixfix * thm) list ->
           thm list -> local_theory -> local_theory
val prove_strong_induct = fn:
   Proof.context ->
     thm -> thm list -> thm list -> bclause list list list -> thm list
val fs_instance = fn:
   typ list ->
     string list ->
       (string * sort) list -> thm list -> local_theory -> local_theory
val define_qconsts = fn:
   typ list ->
     (string * term * mixfix * thm) list ->
       local_theory -> Quotient_Info.quotconsts list * local_theory
### ML warning (line 17 of "$AFP/Nominal2/nominal_induct.ML"):
### Value identifier (tupleT) has not been referenced.
### ML warning (line 50 of "$AFP/Nominal2/nominal_induct.ML"):
### Pattern is not exhaustive.
structure NominalInduct:
  sig
    val nominal_induct_method:
       (Proof.context -> Proof.method) context_parser
    val nominal_induct_tac:
       bool ->
         (binding option * (term * bool)) option list list ->
           (string * typ) list ->
             (string * typ) list list ->
               thm list -> thm list -> int -> context_tactic
  end
### ML warning (line 243 of "$AFP/Nominal2/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 308 of "$AFP/Nominal2/nominal_inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 338 of "$AFP/Nominal2/nominal_inductive.ML"):
### Pattern is not exhaustive.
signature NOMINAL_INDUCTIVE =
  sig
    val prove_strong_inductive:
       string list ->
         string list ->
           term list list -> thm -> thm list -> Proof.context -> Proof.state
    val prove_strong_inductive_cmd:
       xstring * (string * string list) list -> Proof.context -> Proof.state
  end
structure Nominal_Inductive: NOMINAL_INDUCTIVE
### ML warning (line 100 of "$AFP/Nominal2/nominal_function_common.ML"):
### Value identifier (data) has not been referenced.
### ML warning (line 102 of "$AFP/Nominal2/nominal_function_common.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "$AFP/Nominal2/nominal_function_common.ML"):
### Value identifier (inv) has not been referenced.
### ML warning (line 140 of "$AFP/Nominal2/nominal_function_common.ML"):
### Value identifier (partials) has not been referenced.
### ML warning (line 137 of "$AFP/Nominal2/nominal_function_common.ML"):
### Value identifier (domintros) has not been referenced.
### ML warning (line 134 of "$AFP/Nominal2/nominal_function_common.ML"):
### Value identifier (default) has not been referenced.
### ML warning (line 131 of "$AFP/Nominal2/nominal_function_common.ML"):
### Value identifier (sequential) has not been referenced.
signature NOMINAL_FUNCTION_DATA =
  sig
    type nominal_info =
       {R: term,
        add_simps:
        (binding -> binding) ->
          string ->
            (binding -> binding) ->
              Token.src list ->
                thm list -> local_theory -> thm list * local_theory
        ,
        case_names: string list,
        defname: string,
        eqvts: thm list,
        fs: term list,
        inducts: thm list option,
        is_partial: bool,
        pinducts: thm list,
        psimps: thm list, simps: thm list option, termination: thm}
  end
structure Nominal_Function_Common:
  sig
    structure NominalFunctionData: GENERIC_DATA
    val add_function_data:
       nominal_info -> Context.generic -> Context.generic
    val all_function_data: Proof.context -> (term * nominal_info) list
    val apply_opt:
       nominal_function_opt ->
         nominal_function_config -> nominal_function_config
    val get_function: Proof.context -> NominalFunctionData.T
    val import_function_data:
       term ->
         Proof.context ->
           {R: term,
            add_simps:
            (binding -> binding) ->
              string ->
                (binding -> binding) ->
                  Token.src list ->
                    thm list -> local_theory -> thm list * local_theory
            ,
            case_names: string list,
            defname: bstring,
            eqvts: thm list,
            fs: term list,
            inducts: thm list option,
            is_partial: bool,
            pinducts: thm list,
            psimps: thm list, simps: thm list option, termination: thm}
           option
    val import_last_function:
       Proof.context ->
         {R: term,
          add_simps:
          (binding -> binding) ->
            string ->
              (binding -> binding) ->
                Token.src list ->
                  thm list -> local_theory -> thm list * local_theory
          ,
          case_names: string list,
          defname: bstring,
          eqvts: thm list,
          fs: term list,
          inducts: thm list option,
          is_partial: bool,
          pinducts: thm list,
          psimps: thm list, simps: thm list option, termination: thm}
         option
    val lift_morphism: Proof.context -> (thm -> thm) -> morphism
    val morph_function_data:
       nominal_info ->
         morphism ->
           {R: term,
            add_simps:
            (binding -> binding) ->
              string ->
                (binding -> binding) ->
                  Token.src list ->
                    thm list -> local_theory -> thm list * local_theory
            ,
            case_names: string list,
            defname: bstring,
            eqvts: thm list,
            fs: term list,
            inducts: thm list option,
            is_partial: bool,
            pinducts: thm list,
            psimps: thm list, simps: thm list option, termination: thm}
    val nominal_default_config: nominal_function_config
    datatype nominal_function_config
    =
         NominalFunctionConfig of
             {default: string option,
              domintros: bool,
              inv: string option, partials: bool, sequential: bool}
    datatype nominal_function_opt
    =
         Default of string
       | DomIntros
       | Invariant of string
       | No_Partials
       | Sequential
    datatype nominal_function_result
    =
         NominalFunctionResult of
             {G: term,
              R: term,
              cases: thm,
              domintros: thm list option,
              eqvts: thm list,
              fs: term list,
              psimps: thm list, simple_pinducts: thm list, termination: thm}
    type nominal_info =
       {R: term,
        add_simps:
        (binding -> binding) ->
          string ->
            (binding -> binding) ->
              Token.src list ->
                thm list -> local_theory -> thm list * local_theory
        ,
        case_names: string list,
        defname: string,
        eqvts: thm list,
        fs: term list,
        inducts: thm list option,
        is_partial: bool,
        pinducts: thm list,
        psimps: thm list, simps: thm list option, termination: thm}
  end
### ML warning (line 100 of "$AFP/Nominal2/nominal_function_core.ML"):
### Value identifier (case_split) has not been referenced.
### ML warning (line 101 of "$AFP/Nominal2/nominal_function_core.ML"):
### Value identifier (fundef_default_value) has not been referenced.
### ML warning (line 102 of "$AFP/Nominal2/nominal_function_core.ML"):
### Value identifier (not_acc_down) has not been referenced.
### ML warning (line 270 of "$AFP/Nominal2/nominal_function_core.ML"):
### Value identifier (thms) has not been referenced.
### ML warning (line 287 of "$AFP/Nominal2/nominal_function_core.ML"):
### Value identifier (case_hypi) has not been referenced.
### ML warning (line 288 of "$AFP/Nominal2/nominal_function_core.ML"):
### Value identifier (case_hypj) has not been referenced.
### ML warning (line 327 of "$AFP/Nominal2/nominal_function_core.ML"):
### Value identifier (lhs) has not been referenced.
### ML warning (line 595 of "$AFP/Nominal2/nominal_function_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 595 of "$AFP/Nominal2/nominal_function_core.ML"):
### Value identifier (raw_induct) has not been referenced.
### ML warning (line 623 of "$AFP/Nominal2/nominal_function_core.ML"):
### Matches are not exhaustive.
### ML warning (line 691 of "$AFP/Nominal2/nominal_function_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 987 of "$AFP/Nominal2/nominal_function_core.ML"):
### Matches are not exhaustive.
signature NOMINAL_FUNCTION_CORE =
  sig
    val inductive_def:
       (binding * typ) * mixfix ->
         term list ->
           local_theory -> (term * thm list * thm * thm) * local_theory
    val prepare_nominal_function:
       Nominal_Function_Common.nominal_function_config ->
         string ->
           ((bstring * typ) * mixfix) list ->
             ((bstring * typ) list * term list * term * term) list ->
               local_theory ->
                 (term * term * thm list * thm * thm *
                  (Proof.context ->
                     thm ->
                       Nominal_Function_Common.nominal_function_result))
                 *
                 local_theory
    val trace: bool ref
  end
structure Nominal_Function_Core: NOMINAL_FUNCTION_CORE
### ML warning (line 100 of "$AFP/Nominal2/nominal_mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 183 of "$AFP/Nominal2/nominal_mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 210 of "$AFP/Nominal2/nominal_mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 221 of "$AFP/Nominal2/nominal_mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "$AFP/Nominal2/nominal_mutual.ML"):
### Value identifier (insts) has not been referenced.
### ML warning (line 311 of "$AFP/Nominal2/nominal_mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 361 of "$AFP/Nominal2/nominal_mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 365 of "$AFP/Nominal2/nominal_mutual.ML"):
### Matches are not exhaustive.
### ML warning (line 371 of "$AFP/Nominal2/nominal_mutual.ML"):
### Matches are not exhaustive.
### ML warning (line 374 of "$AFP/Nominal2/nominal_mutual.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 374 of "$AFP/Nominal2/nominal_mutual.ML"):
### Matches are not exhaustive.
### ML warning (line 397 of "$AFP/Nominal2/nominal_mutual.ML"):
### Value identifier (Q) has not been referenced.
### ML warning (line 397 of "$AFP/Nominal2/nominal_mutual.ML"):
### Matches are not exhaustive.
### ML warning (line 425 of "$AFP/Nominal2/nominal_mutual.ML"):
### Value identifier (fvar) has not been referenced.
signature NOMINAL_FUNCTION_MUTUAL =
  sig
    val prepare_nominal_function_mutual:
       Nominal_Function_Common.nominal_function_config ->
         string ->
           ((string * typ) * mixfix) list ->
             term list ->
               local_theory ->
                 (thm *
                  (Proof.context ->
                     thm ->
                       Nominal_Function_Common.nominal_function_result))
                 *
                 local_theory
  end
structure Nominal_Function_Mutual: NOMINAL_FUNCTION_MUTUAL
### ML warning (line 60 of "$AFP/Nominal2/nominal_function.ML"):
### Value identifier (rvs) has not been referenced.
### ML warning (line 158 of "$AFP/Nominal2/nominal_function.ML"):
### Pattern is not exhaustive.
### ML warning (line 145 of "$AFP/Nominal2/nominal_function.ML"):
### Matches are not exhaustive.
signature NOMINAL_FUNCTION =
  sig
    val add_nominal_function:
       (binding * typ option * mixfix) list ->
         Specification.multi_specs ->
           Nominal_Function_Common.nominal_function_config ->
             (Proof.context -> tactic) ->
               local_theory -> nominal_info * local_theory
    val add_nominal_function_cmd:
       (binding * string option * mixfix) list ->
         Specification.multi_specs_cmd ->
           Nominal_Function_Common.nominal_function_config ->
             (Proof.context -> tactic) ->
               bool -> local_theory -> nominal_info * local_theory
    val get_info: Proof.context -> term -> nominal_info
    val nominal_function:
       (binding * typ option * mixfix) list ->
         Specification.multi_specs ->
           Nominal_Function_Common.nominal_function_config ->
             local_theory -> Proof.state
    val nominal_function_cmd:
       (binding * string option * mixfix) list ->
         Specification.multi_specs_cmd ->
           Nominal_Function_Common.nominal_function_config ->
             bool -> local_theory -> Proof.state
    type nominal_info =
       {R: term,
        add_simps:
        (binding -> binding) ->
          string ->
            (binding -> binding) ->
              Token.src list ->
                thm list -> local_theory -> thm list * local_theory
        ,
        case_names: string list,
        defname: string,
        eqvts: thm list,
        fs: term list,
        inducts: thm list option,
        is_partial: bool,
        pinducts: thm list,
        psimps: thm list, simps: thm list option, termination: thm}
  end
structure Nominal_Function: NOMINAL_FUNCTION
### ML warning (line 67 of "$AFP/Nominal2/nominal_termination.ML"):
### Value identifier (eqvts) has not been referenced.
### ML warning (line 47 of "$AFP/Nominal2/nominal_termination.ML"):
### Matches are not exhaustive.
signature NOMINAL_FUNCTION_TERMINATION =
  sig
    type nominal_info =
       {R: term,
        add_simps:
        (binding -> binding) ->
          string ->
            (binding -> binding) ->
              Token.src list ->
                thm list -> local_theory -> thm list * local_theory
        ,
        case_names: string list,
        defname: string,
        eqvts: thm list,
        fs: term list,
        inducts: thm list option,
        is_partial: bool,
        pinducts: thm list,
        psimps: thm list, simps: thm list option, termination: thm}
    val termination: bool -> term option -> local_theory -> Proof.state
    val termination_cmd:
       bool -> string option -> local_theory -> Proof.state
  end
structure Nominal_Function_Termination: NOMINAL_FUNCTION_TERMINATION
val eqvt_attr =
   [Token
     (("attribute", ({}, {})), (String, "attribute"),
      Value
       (
          SOME
           (
              Name
               ({kind = "attribute", name = "Pure.attribute", print = fn},
                {})
              )
          )),
    Token
     (("<attribute>", ({}, {})), (String, "<attribute>"),
      Value (SOME (Attribute fn)))]:
   Token.src
val simp_attr =
   [Token
     (("attribute", ({}, {})), (String, "attribute"),
      Value
       (
          SOME
           (
              Name
               ({kind = "attribute", name = "Pure.attribute", print = fn},
                {})
              )
          )),
    Token
     (("<attribute>", ({}, {})), (String, "<attribute>"),
      Value (SOME (Attribute fn)))]:
   Token.src
val induct_attr =
   [Token
     (("attribute", ({}, {})), (String, "attribute"),
      Value
       (
          SOME
           (
              Name
               ({kind = "attribute", name = "Pure.attribute", print = fn},
                {})
              )
          )),
    Token
     (("<attribute>", ({}, {})), (String, "<attribute>"),
      Value (SOME (Attribute fn)))]:
   Token.src
val get_cnstrs = fn: ('a * 'b) list -> 'b list
val get_typed_cnstrs = fn:
   ((binding * 'a * 'b) * (binding * 'c * 'd) list) list ->
     (bstring * bstring) list
val get_cnstr_strs = fn:
   ('a * (binding * 'b * 'c) list) list -> bstring list
val get_bn_fun_strs = fn: (binding * 'a * 'b) list -> bstring list
### ML warning (line 80 of "$AFP/Nominal2/Nominal2.thy"):
### Value identifier (ty_ss) has not been referenced.
### ML warning (line 95 of "$AFP/Nominal2/Nominal2.thy"):
### Value identifier (trm_ss) has not been referenced.
val add_raw = fn: string -> string
val add_raws = fn: string list -> string list
val raw_bind = fn: binding -> binding
val replace_str = fn: (''a * ''a) list -> ''a -> ''a
val replace_typ = fn: (string * string) list -> typ -> typ
val raw_dts = fn:
   (string * string) list ->
     ((binding * 'a * 'b) * (binding * typ list * 'c) list) list ->
       ((binding * 'a * mixfix) * (binding * typ list * mixfix) list) list
val replace_aterm = fn: (string * string) list -> term -> term
val replace_term = fn:
   (string * string) list -> (string * string) list -> term -> term
val rawify_dts = fn:
   ((binding * 'a * 'b) * (binding * typ list * 'c) list) list ->
     (string * string) list ->
       ((binding * 'a * mixfix) * (binding * typ list * mixfix) list) list
val rawify_bn_funs = fn:
   (string * string) list ->
     (string * string) list ->
       (string * string) list ->
         (binding * typ * 'a) list ->
           ('b * term) list ->
             (binding * typ option * mixfix) list *
             (('b * term) * 'c list * 'd list) list
val rawify_bclauses = fn:
   (string * string) list ->
     (string * string) list ->
       (string * string) list ->
         bclause list list list -> bclause list list list
val define_raw_dts = fn:
   ((binding * (string * sort) list * 'a) * (binding * typ list * 'b) list)
   list
     ->
     string list ->
       (string * string) list ->
         (binding * typ * 'c) list ->
           ('d * term) list ->
             bclause list list list ->
               local_theory ->
                 bclause list list list *
                 (binding * typ option * mixfix) list *
                 (('d * term) * 'e list * 'f list) list * raw_dt_info *
                 local_theory
### ML warning (line 229 of "$AFP/Nominal2/Nominal2.thy"):
### Value identifier (raw_induct_thms) has not been referenced.
### ML warning (line 224 of "$AFP/Nominal2/Nominal2.thy"):
### Value identifier (raw_fp_sugars) has not been referenced.
### ML warning (line 222 of "$AFP/Nominal2/Nominal2.thy"):
### Value identifier (raw_tys) has not been referenced.
### ML warning (line 221 of "$AFP/Nominal2/Nominal2.thy"):
### Value identifier (raw_dt_names) has not been referenced.
### ML warning (line 417 of "$AFP/Nominal2/Nominal2.thy"):
### Pattern is not exhaustive.
val nominal_datatype2 = fn:
   binding option ->
     ((binding * (string * sort) list * mixfix) *
      (binding * typ list * mixfix) list
     )
     list
       ->
       (binding * typ * mixfix) list ->
         (Attrib.binding * term) list ->
           bclause list list list -> local_theory -> local_theory
val augment_sort = fn: theory -> sort -> sort
val augment_sort_typ = fn: theory -> typ -> typ
val prepare_dts = fn:
   ((binding * (string * string option) list * mixfix) *
    (binding * ('a * string) list * mixfix * 'b) list
   )
   list
     ->
     theory ->
       ((binding * (string * sort) list * mixfix) *
        (binding * typ list * mixfix) list
       )
       list
       *
       theory
val prepare_bn_funs = fn:
   (binding * string option * mixfix) list ->
     Specification.multi_specs_cmd ->
       theory ->
         ((binding * typ * mixfix) list * (Attrib.binding * term) list) *
         theory
val indexify = fn: 'a option list -> ('a * int) list
val index_lookup = fn: (string * 'a) list -> string -> 'a
val prepare_bclauses = fn:
   ('a *
    ('b * (string option * 'c) list * 'd *
     (bmode * string list * string list) list
    )
    list
   )
   list
     -> theory -> bclause list list list * theory
val included = fn: int -> bclause list -> bool
val complete = fn:
   ('a * ('b * 'c list * 'd * 'e) list) list ->
     bclause list list list -> bclause list list list
val nominal_datatype2_cmd = fn:
   binding option *
   ((binding * (string * string option) list * mixfix) *
    (binding * (string option * string) list * mixfix *
     (bmode * string list * string list) list
    )
    list
   )
   list
   *
   (binding * string option * mixfix) list * Specification.multi_specs_cmd
     -> Proof.context -> local_theory
val opt_name = fn: Token.T list -> binding option * Token.T list
val anno_typ = fn: Token.T list -> (string option * string) * Token.T list
val bind_mode = fn: Token.T list -> bmode * Token.T list
val bind_clauses = fn: (bmode * string list * string list) list parser
val cnstr_parser = fn:
   Token.T list ->
     (binding * (string option * string) list * mixfix *
      (bmode * string list * string list) list)
     *
     Token.T list
val dt_parser = fn:
   Token.T list ->
     ((binding * (string * string option) list * mixfix) *
      (binding * (string option * string) list * mixfix *
       (bmode * string list * string list) list
      )
      list)
     *
     Token.T list
val bnfun_parser = fn:
   Token.T list ->
     ((binding * string option * mixfix) list *
      Specification.multi_specs_cmd)
     *
     Token.T list
val main_parser = fn:
   Token.T list ->
     (binding option *
      ((binding * (string * string option) list * mixfix) *
       (binding * (string option * string) list * mixfix *
        (bmode * string list * string list) list
       )
       list
      )
      list
      *
      (binding * string option * mixfix) list *
      Specification.multi_specs_cmd)
     *
     Token.T list
### theory "Nominal2.Nominal2"
### 1.486s elapsed time, 1.595s cpu time, 0.159s GC time
Loading theory "Draft.SyntaxN" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma" via "Draft.Predicates")
instantiation
  hf :: pt
  permute_hf == permute :: perm => hf => hf
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "boolean_axiomsp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "special_axiomsp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "induction_axiomsp"
  Proving monotonicity ...
specification
  extra_axiom_holds: eval_fm ?e extra_axiom
Proofs for inductive predicate(s) "hfthm"
  Proving monotonicity ...
### theory "Draft.SyntaxN"
### 3.423s elapsed time, 3.619s cpu time, 0.267s GC time
Loading theory "Draft.Predicates" (required by "Draft.SigmaMoreTemplates" via "Draft.Sigma")
### theory "Draft.Predicates"
### 0.750s elapsed time, 0.864s cpu time, 0.133s GC time
Loading theory "Draft.Sigma" (required by "Draft.SigmaMoreTemplates")
Proofs for inductive predicate(s) "ss_fm"
  Proving monotonicity ...
Proofs for inductive predicate(s) "se_fm"
  Proving monotonicity ...
### theory "Draft.Sigma"
### 0.676s elapsed time, 0.789s cpu time, 0.154s GC time
Loading theory "Draft.SigmaMoreTemplates"
val templateLemmas =
   [("Sigma.HFun_Sigma_sf", "Sigma_fm (HFun_Sigma ?t)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("Sigma.OrdP_sf", "Sigma_fm (OrdP ?t)",
     template_predicate
      (
         template_app
          (template_hole 1, template_app (template_hole 0, template_var 0))
         )),
    ("Sigma.HDomain_Incl_sf", "Sigma_fm (HDomain_Incl ?t ?u)",
     template_predicate
      (
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0))
         )),
    ("Sigma.OrdNotEqP_sf", "Sigma_fm (?t NEQ ?u)",
     template_predicate
      (
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0))
         )),
    ("Sigma.Subset_sf", "Sigma_fm (?t SUBS ?u)",
     template_predicate
      (
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0))
         )),
    ("Sigma.Equality_sf", "Sigma_fm (?t EQ ?u)",
     template_predicate
      (
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0))
         )),
    ("Sigma.Mem_sf", "Sigma_fm (?t IN ?u)",
     template_predicate
      (
         template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0))
         )),
    ("Predicates.HFun_Sigma_Zero", "?H \<turnstile> HFun_Sigma Zero",
     template_predicate
      (
         template_app
          (template_app (template_hole 2, template_var 0),
           template_app (template_hole 1, template_hole 0))
         )),
    ("HF.HSigma_empty1", "HSigma 0 ?B = 0",
     template_equation
      (template_app
        (template_app (template_hole 1, template_hole 0), template_var 0),
       template_hole 0)),
    ("Product_Type.Sigma_empty1", "Sigma {} ?B = {}",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), template_var 0),
       template_hole 0)),
    ("Sigma.ground_aux_simps", "ground_aux Zero ?S = True",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), template_var 0),
       template_hole 0)),
    ("Sigma.ground_fm_aux_simps", "ground_fm_aux Fls ?S = True",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), template_var 0),
       template_hole 0)),
    ("Sigma.LstSeqP_sf", "Sigma_fm (LstSeqP ?t ?u ?v)",
     template_predicate
      (
         template_app
          (template_hole 1,
           template_app
            (template_app
              (template_app (template_hole 0, template_var 2),
               template_var 1),
             template_var 0))
         )),
    ("Sigma.Subset_Zero_sf", "Sigma_fm (Var ?i SUBS Zero)",
     template_predicate
      (
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 0)),
             template_hole 0))
         )),
    ("Sigma.Eq_Zero_sf", "Sigma_fm (Var ?i EQ Zero)",
     template_predicate
      (
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 0)),
             template_hole 0))
         )),
    ("Sigma.Zero_Mem_sf", "Sigma_fm (Zero IN Var ?i)",
     template_predicate
      (
         template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_app (template_hole 0, template_var 0)))
         )),
    ("Product_Type.Sigma_empty2", "?A \<times> {} = {}",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), t_empty),
       template_hole 0)),
    ("Sigma.Var_Subset_sf", "Sigma_fm (Var ?i SUBS Var ?j)",
     template_predicate
      (
         template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 1)),
             template_app (template_hole 0, template_var 0)))
         )),
    ("Sigma.ss_fm_imp_Sigma_fm", "ss_fm ?A ==> Sigma_fm ?A",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (template_app (template_hole 0, template_var 0)))),
    ("Sigma.ss_imp_se_fm", "ss_fm ?A ==> se_fm ?A",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (template_app (template_hole 0, template_var 0)))),
    ("Sigma.theorem_sf", "{} \<turnstile> ?A ==> Sigma_fm ?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_hole 1),
              template_var 0)
            )],
       template_predicate
        (template_app (template_hole 0, template_var 0)))),
    ("Predicates.HFun_Sigma_fresh_iff",
     "?a \<sharp> HFun_Sigma ?r = ?a \<sharp> ?r",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 1),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("Sigma.ground_fm_aux_simps",
     "ground_fm_aux (Neg ?A) ?S = ground_fm_aux ?A ?S",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 1, template_var 1), template_var 0))),
    ("Predicates.eval_fm_HFun_Sigma",
     "eval_fm ?e (HFun_Sigma ?r) = hfun_sigma_ord \<lbrakk>?r\<rbrakk>?e",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Sigma.subst_fm_in_se_fm", "se_fm ?A ==> se_fm (?A(?k::=?x))",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 2))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0))
           ))),
    ("Sigma.ground_fresh", "ground ?t ==> atom ?i \<sharp> ?t",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 1),
              template_hole 2)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 0)),
             template_var 1)
           ))),
    ("Sigma.ground_fresh", "ground_fm ?A ==> atom ?i \<sharp> ?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 1),
              template_hole 2)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 0)),
             template_var 1)
           ))),
    ("Sigma.ijk", "?i + ?k < Suc (?i + ?j + ?k)",
     template_inequation
      (less_than,
       template_app
        (template_app (template_hole 1, template_var 2), template_var 1),
       template_app
        (template_hole 0,
         template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 1, template_var 2),
               template_var 0)),
           template_var 1)))),
    ("Predicates.HFun_Sigma_subst",
     "(HFun_Sigma ?r)(?i::=?t) = HFun_Sigma (subst ?i ?t ?r)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0),
       template_app
        (template_hole 1,
         template_app
          (template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0),
           template_var 2)))),
    ("Predicates.Subset_HFun_Sigma",
     "{HFun_Sigma ?s, ?s' SUBS ?s} \<turnstile> HFun_Sigma ?s'",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 4,
             template_app
              (template_app
                (template_hole 3,
                 template_app (template_hole 2, template_var 1)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 1, template_var 0),
                     template_var 1)),
                 template_hole 0))),
           template_app (template_hole 2, template_var 0))
         )),
    ("Product_Type.snd_image_Sigma",
     "snd ` Sigma ?A ?B = \<Union> (?B ` ?A)",
     template_equation
      (template_app
        (template_app (template_hole 4, template_hole 3),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, t_empty), template_var 1)))),
    ("Product_Type.Sigma_Union",
     "Sigma (\<Union> ?X) ?B = (UN A:?X. Sigma A ?B)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_var 0),
       template_app
        (template_hole 1,
         template_app
          (template_app (template_hole 0, t_empty), template_var 1)))),
    ("Sigma.ground_aux_simps",
     "ground_aux (Var ?k) ?S = (if atom ?k : ?S then True else False)",
     template_equation
      (template_app
        (template_app
          (template_hole 6, template_app (template_hole 5, template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 4,
             template_app
              (template_app
                (template_hole 3,
                 template_app (template_hole 2, template_var 1)),
               template_var 0)),
           template_hole 1),
         template_hole 0))),
    ("HF.HSigmaD1", "<?a, ?b> <: HSigma ?A ?B ==> ?a <: ?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2)),
              template_app
               (template_app (template_hole 0, template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 2, template_var 3), template_var 1)
           ))),
    ("Product_Type.SigmaD1", "(?a, ?b) : Sigma ?A ?B ==> ?a : ?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 3,
                template_app
                 (template_app (template_hole 2, template_var 3),
                  template_var 2)),
              template_app
               (template_app (template_hole 1, template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 3), template_var 1)
           ))),
    ("Sigma.Sigma_fm_AND",
     "[| Sigma_fm ?A; Sigma_fm ?B |] ==> Sigma_fm (?A AND ?B)",
     template_implication
      ([template_predicate (template_app (template_hole 1, template_var 1)),
        template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("Sigma.Sigma_fm_OR",
     "[| Sigma_fm ?A; Sigma_fm ?B |] ==> Sigma_fm (?A OR ?B)",
     template_implication
      ([template_predicate (template_app (template_hole 1, template_var 1)),
        template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("Sigma.Sigma_fm_Ex",
     "[| Sigma_fm ?A; Sigma_fm ?B |] ==> Sigma_fm (SyntaxN.Ex ?i ?A)",
     template_implication
      ([template_predicate (template_app (template_hole 1, template_var 2)),
        template_predicate
         (template_app (template_hole 1, template_var 1))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 2))
           ))),
    ("Product_Type.Sigma_Diff_distrib1",
     "Sigma (?I - ?J) ?C = Sigma ?I ?C - Sigma ?J ?C",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_var 0)))),
    ("Product_Type.Sigma_Int_distrib1",
     "Sigma (?I Int ?J) ?C = Sigma ?I ?C Int Sigma ?J ?C",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_var 0)))),
    ("Product_Type.Sigma_Un_distrib1",
     "Sigma (?I Un ?J) ?C = Sigma ?I ?C Un Sigma ?J ?C",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_var 0)))),
    ("Sigma.ground_aux_simps",
     "ground_aux (Eats ?t ?u) ?S = (ground_aux ?t ?S & ground_aux ?u ?S)",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_var 0)))),
    ("Sigma.ground_fm_aux_simps",
     "ground_fm_aux (?A AND ?B) ?S =
      (ground_fm_aux ?A ?S & ground_fm_aux ?B ?S)",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_var 0)))),
    ("Sigma.ground_fm_aux_simps",
     "ground_fm_aux (?A OR ?B) ?S =
      (ground_fm_aux ?A ?S & ground_fm_aux ?B ?S)",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_var 0)))),
    ("Sigma.ground_fm_aux_simps",
     "ground_fm_aux (?t EQ ?u) ?S = (ground_aux ?t ?S & ground_aux ?u ?S)",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("Sigma.ground_fm_aux_simps",
     "ground_fm_aux (?A IFF ?B) ?S =
      (ground_fm_aux ?A ?S & ground_fm_aux ?B ?S)",
     template_equation
      (template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 2, template_var 1),
           template_var 0)))),
    ("Sigma.ground_fm_aux_simps",
     "ground_fm_aux (?t IN ?u) ?S = (ground_aux ?t ?S & ground_aux ?u ?S)",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 0)),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("HF.HSigmaD2", "<?a, ?b> <: HSigma ?A ?B ==> ?b <: ?B ?a",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 3),
                  template_var 2)),
              template_app
               (template_app (template_hole 0, template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 2, template_var 2),
             template_app (template_var 0, template_var 3))
           ))),
    ("Product_Type.SigmaD2", "(?a, ?b) : Sigma ?A ?B ==> ?b : ?B ?a",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 3,
                template_app
                 (template_app (template_hole 2, template_var 3),
                  template_var 2)),
              template_app
               (template_app (template_hole 1, template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 2),
             template_app (template_var 0, template_var 3))
           ))),
    ("Product_Type.Pair_vimage_Sigma",
     "Pair ?x -` Sigma ?A ?f = (if ?x : ?A then ?f ?x else {})",
     template_equation
      (template_app
        (template_app
          (template_hole 5, template_app (template_hole 4, template_var 2)),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 2),
               template_var 1)),
           template_app (template_var 0, template_var 2)),
         template_hole 0))),
    ("Sigma.ground_fm_aux_simps",
     "ground_fm_aux (SyntaxN.Ex ?x ?A) ?S =
      ground_fm_aux ?A (?S Un {atom ?x})",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app (template_hole 4, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 5, template_var 1),
         template_app
          (template_app (template_hole 3, template_var 0),
           template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)),
             template_hole 0))))),
    ("Sigma.ex_eval_fm_iff_exists_tm'",
     "eval_fm ?e (SyntaxN.Ex ?k ?A) = (EX t. eval_fm ?e (?A(?k::=t)))",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app (template_hole 1, t_empty))),
    ("Sigma.elts_imp_ground",
     "[| ?u : elts ?t; ground_aux ?t ?S |] ==> ground_aux ?u ?S",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 2),
              template_app (template_hole 1, template_var 1))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 0, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 2), template_var 0)
           ))),
    ("Nominal2_Base.Sigma_eqvt",
     "?p \<bullet> ?X \<times> ?Y =
      (?p \<bullet> ?X) \<times> (?p \<bullet> ?Y)",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app (template_hole 2, template_var 1), t_empty)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1)),
         t_empty))),
    ("Product_Type.Sigma_empty_iff",
     "(Sigma ?I ?X = {}) = (ALL i:?I. ?X i = {})",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app (template_hole 4, template_var 1), t_empty)),
         template_hole 3),
       template_app
        (template_app (template_hole 2, template_var 1), t_empty))),
    ("Transitive_Closure.trancl_subset_Sigma",
     "?r <= ?A \<times> ?A ==> ?r^+ <= ?A \<times> ?A",
     template_implication
      ([template_inequation
         (less_equals, template_var 1,
          template_app
           (template_app (template_hole 1, template_var 0), t_empty))],
       template_inequation
        (less_equals, template_app (template_hole 0, template_var 1),
         template_app
          (template_app (template_hole 1, template_var 0), t_empty)))),
    ("Relation.Sigma_Image",
     "Sigma ?A ?B `` ?X = \<Union> (?B ` (?X Int ?A))",
     template_equation
      (template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 2), t_empty)),
         template_var 0),
       template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, t_empty),
           template_app
            (template_app (template_hole 0, template_var 0),
             template_var 2))))),
    ("Product_Type.Sigma_Diff_distrib2",
     "(SIGMA i:?I. ?A i - ?B i) = Sigma ?I ?A - Sigma ?I ?B",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 2), t_empty),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 2, template_var 2),
           template_var 0)))),
    ("Product_Type.Sigma_Int_distrib2",
     "(SIGMA i:?I. ?A i Int ?B i) = Sigma ?I ?A Int Sigma ?I ?B",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 2), t_empty),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 2, template_var 2),
           template_var 0)))),
    ("Product_Type.Sigma_Un_distrib2",
     "(SIGMA i:?I. ?A i Un ?B i) = Sigma ?I ?A Un Sigma ?I ?B",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 2), t_empty),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 2, template_var 2),
           template_var 0)))),
    ("Transcendental.Sigma_interval_disjoint",
     "(SIGMA i:?A. {..?v i}) Int (SIGMA i:?A. {?v i<..?w}) = {}",
     template_equation
      (template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 2), t_empty)),
         template_app
          (template_app (template_hole 3, template_var 2), t_empty)),
       template_hole 0)),
    ("HF.HSigma_iff",
     "(<?a, ?b> <: HSigma ?A ?B) = (?a <: ?A & ?b <: ?B ?a)",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 3),
             template_var 2)),
         template_app
          (template_app (template_hole 1, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app (template_hole 3, template_var 3),
             template_var 1)),
         template_app
          (template_app (template_hole 3, template_var 2),
           template_app (template_var 0, template_var 3))))),
    ("Product_Type.mem_Sigma_iff",
     "((?a, ?b) : Sigma ?A ?B) = (?a : ?A & ?b : ?B ?a)",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app (template_hole 4, template_var 3),
             template_var 2)),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 3),
             template_var 1)),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_app (template_var 0, template_var 3))))),
    ("Product_Type.fst_image_Sigma",
     "fst ` Sigma ?A ?B = {x: ?A. ?B x ~= {}}",
     template_equation
      (template_app
        (template_app (template_hole 8, template_hole 7),
         template_app
          (template_app (template_hole 6, template_var 1), template_var 0)),
       template_app (template_hole 5, t_empty))),
    ("Sigma.Sigma_fm_imp_thm",
     "[| Sigma_fm ?A; ground_fm ?A; eval_fm e0 ?A |]
      ==> {} \<turnstile> ?A",
     template_implication
      ([template_predicate (template_app (template_hole 6, template_var 0)),
        template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 0),
              template_hole 4)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 3, template_hole 2),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 1, template_hole 0),
             template_var 0)
           ))),
    ("Sigma.se_fm_imp_thm",
     "[| se_fm ?A; ground_fm ?A; eval_fm ?e ?A |] ==> {} \<turnstile> ?A",
     template_implication
      ([template_predicate (template_app (template_hole 5, template_var 1)),
        template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 1),
              template_hole 3)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 0),
              template_var 1)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 1, template_hole 0),
             template_var 1)
           ))),
    ("Product_Type.Collect_case_prod_Sigma",
     "{(x, y). ?P x & ?Q x y} = (SIGMA x:Collect ?P. Collect (?Q x))",
     template_equation
      (template_app
        (template_hole 5, template_app (template_hole 4, t_empty)),
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 1)),
         t_empty))),
    ("Transcendental.pairs_le_eq_Sigma",
     "{(i, j). i + j <= ?m} = (SIGMA r:{..?m}. {..?m - r})",
     template_equation
      (template_app
        (template_hole 6, template_app (template_hole 5, t_empty)),
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         t_empty))),
    ("Sigma.ex_eval_fm_iff_exists_tm",
     "eval_fm ?e (SyntaxN.Ex ?k ?A) =
      (EX t. eval_fm ?e (?A(?k::=t)) & ground t)",
     template_equation
      (template_app
        (template_app (template_hole 6, template_var 2),
         template_app
          (template_app (template_hole 5, template_var 1), template_var 0)),
       template_app (template_hole 4, t_empty))),
    ("Old_Datatype.dprod_Sigma",
     "dprod (?A \<times> ?B) (?C \<times> ?D)
      <= uprod ?A ?C \<times> uprod ?B ?D",
     template_inequation
      (less_equals,
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 3), t_empty)),
         template_app
          (template_app (template_hole 1, template_var 1), t_empty)),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 3),
             template_var 1)),
         t_empty))),
    ("Old_Datatype.dsum_Sigma",
     "dsum (?A \<times> ?B) (?C \<times> ?D)
      <= usum ?A ?C \<times> usum ?B ?D",
     template_inequation
      (less_equals,
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 3), t_empty)),
         template_app
          (template_app (template_hole 1, template_var 1), t_empty)),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 3),
             template_var 1)),
         t_empty))),
    ("Sigma.Subset_Mem_sf_lemma",
     "size ?t + size ?u < ?n ==>
      Sigma_fm (?t SUBS ?u) & Sigma_fm (?t IN ?u)",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_app
             (template_hole 5,
              template_app (template_hole 4, template_var 2)),
            template_app (template_hole 4, template_var 1)),
          template_var 0)],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_hole 2,
                 template_app
                  (template_app (template_hole 1, template_var 2),
                   template_var 1))),
             template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)))
           ))),
    ("Sigma.obtain_const_tm",
     "(!!t. [| \<lbrakk>t\<rbrakk>?e = ?x; ground t |] ==> ?thesis) ==>
      ?thesis",
     template_implication
      ([template_predicate (template_app (template_hole 5, t_empty))],
       template_predicate (template_var 0))),
    ("HF.HSigmaI",
     "[| ?a <: ?A; ?b <: ?B ?a |] ==> <?a, ?b> <: HSigma ?A ?B",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 1),
              template_app (template_var 0, template_var 3))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 3),
                 template_var 1)),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0))
           ))),
    ("Product_Type.SigmaI",
     "[| ?a : ?A; ?b : ?B ?a |] ==> (?a, ?b) : Sigma ?A ?B",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 1),
              template_app (template_var 0, template_var 3))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 3),
                 template_var 1)),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 0))
           ))),
    ("Product_Type.split_paired_Ball_Sigma",
     "(ALL z:Sigma ?A ?B. ?P z) = (ALL x:?A. ALL y:?B x. ?P (x, y))",
     template_equation
      (template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 2),
             template_var 1)),
         t_empty),
       template_app
        (template_app (template_hole 2, template_var 2), t_empty))),
    ("Product_Type.split_paired_Bex_Sigma",
     "(EX z:Sigma ?A ?B. ?P z) = (EX x:?A. EX y:?B x. ?P (x, y))",
     template_equation
      (template_app
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 2),
             template_var 1)),
         t_empty),
       template_app
        (template_app (template_hole 2, template_var 2), t_empty))),
    ("Sigma.ground_subst",
     "[| ground_aux ?tm (insert (atom ?i) ?S); ground ?t |]
      ==> ground_aux (subst ?i ?t ?tm) ?S",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 3),
              template_app
               (template_app
                 (template_hole 3,
                  template_app (template_hole 2, template_var 2)),
                template_var 1))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 0),
              template_hole 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 2),
                   template_var 0),
                 template_var 3)),
             template_var 1)
           ))),
    ("Sigma.ground_subst_fm",
     "[| ground_fm_aux ?A (insert (atom ?i) ?S); ground ?t |]
      ==> ground_fm_aux (?A(?i::=?t)) ?S",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 3),
              template_app
               (template_app
                 (template_hole 4,
                  template_app (template_hole 3, template_var 2)),
                template_var 1))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 0),
              template_hole 1)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 2),
                 template_var 0)),
             template_var 1)
           ))),
    ("Old_Datatype.dprod_subset_Sigma2",
     "dprod (Sigma ?A ?B) (Sigma ?C ?D)
      <= Sigma (uprod ?A ?C)
          (Old_Datatype.Split (%x y. uprod (?B x) (?D y)))",
     template_inequation
      (less_equals,
       template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 3),
             template_var 2)),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 3),
             template_var 1)),
         template_app (template_hole 0, t_empty)))),
    ("Sigma.Sigma_fm_Iff",
     "[| {} \<turnstile> ?B IFF ?A; supp ?A <= supp ?B; Sigma_fm ?A |]
      ==> Sigma_fm ?B",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_hole 4),
              template_app
               (template_app (template_hole 3, template_var 1),
                template_var 0))
            ),
        template_inequation
         (less_equals, template_app (template_hole 1, template_var 0),
          template_app (template_hole 1, template_var 1)),
        template_predicate
         (template_app (template_hole 0, template_var 0))],
       template_predicate
        (template_app (template_hole 0, template_var 1)))),
    ("Product_Type.disjnt_Sigma_iff",
     "disjnt (Sigma ?A ?C) (Sigma ?B ?C) =
      ((ALL i:?A Int ?B. ?C i = {}) | disjnt ?A ?B)",
     template_equation
      (template_app
        (template_app
          (template_hole 7,
           template_app
            (template_app (template_hole 6, template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 6, template_var 0), template_var 1)),
       template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 3, template_var 2),
                 template_var 0)),
             t_empty)),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("Finite_Set.finite_SigmaI",
     "[| finite ?A; !!a. a : ?A ==> finite (?B a) |]
      ==> finite (Sigma ?A ?B)",
     template_implication
      ([template_predicate (template_app (template_hole 5, template_var 1)),
        template_predicate (template_app (template_hole 4, t_empty))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 1), t_empty))
           ))),
    ("Sigma.Sigma_fm_All2",
     "[| Sigma_fm ?A; atom ?i \<sharp> ?t |] ==> Sigma_fm (All2 ?i ?t ?A)",
     template_implication
      ([template_predicate (template_app (template_hole 7, template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 6,
                template_app (template_hole 5, template_var 1)),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_hole 7,
             template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 3, template_var 1),
                 template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_hole 2,
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app
                            (template_hole 1,
                             template_app
                              (template_hole 0, template_var 1)),
                           template_var 0))),
                     template_var 2)))))
           ))),
    ("Product_Type.image_split_eq_Sigma",
     "(%x. (?f x, ?g x)) ` ?A = (SIGMA x:?f ` ?A. ?g ` (?f -` {x} Int ?A))",
     template_equation
      (template_app
        (template_app (template_hole 8, t_empty), template_var 0),
       template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app (template_hole 5, template_var 2),
             template_var 0)),
         t_empty))),
    ("Sigma.Sigma_fm_All2_fresh",
     "[| Sigma_fm ?A; ?i ~= ?j |] ==> Sigma_fm (All2 ?i (Var ?j) ?A)",
     template_implication
      ([template_predicate (template_app (template_hole 7, template_var 2)),
        template_negation
         (template_equation (template_var 1, template_var 0))],
       template_predicate
        (
           template_app
            (template_hole 7,
             template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 3, template_var 1),
                 template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_hole 2,
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app
                            (template_hole 1,
                             template_app
                              (template_hole 0, template_var 1)),
                           template_app
                            (template_hole 0, template_var 0)))),
                     template_var 2)))))
           ))),
    ("Transitive_Closure.trancl_subset_Sigma_aux",
     "[| (?a, ?b) : ?r^*; ?r <= ?A \<times> ?A |] ==> ?a = ?b | ?a : ?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 7,
                template_app
                 (template_app (template_hole 6, template_var 3),
                  template_var 2)),
              template_app (template_hole 5, template_var 1))
            ),
        template_inequation
         (less_equals, template_var 1,
          template_app
           (template_app (template_hole 3, template_var 0), t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 3),
                 template_var 2)),
             template_app
              (template_app (template_hole 0, template_var 3),
               template_var 0))
           ))),
    ("Sigma.ground_se_fm_induction",
     "[| ground_fm ?\<alpha>; size ?\<alpha> < ?n; se_fm ?\<alpha>;
         eval_fm ?e ?\<alpha> |]
      ==> {} \<turnstile> ?\<alpha>",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 7, template_var 2),
              template_hole 6)
            ),
        template_inequation
         (less_than, template_app (template_hole 4, template_var 2),
          template_var 1),
        template_predicate (template_app (template_hole 3, template_var 2)),
        template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 0),
              template_var 2)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 1, template_hole 0),
             template_var 2)
           ))),
    ("Relation.relcomp_subset_Sigma",
     "[| ?r <= ?A \<times> ?B; ?s <= ?B \<times> ?C |]
      ==> ?r O ?s <= ?A \<times> ?C",
     template_implication
      ([template_inequation
         (less_equals, template_var 4,
          template_app
           (template_app (template_hole 5, template_var 3), t_empty)),
        template_inequation
         (less_equals, template_var 1,
          template_app
           (template_app (template_hole 3, template_var 2), t_empty))],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 1, template_var 4), template_var 1),
         template_app
          (template_app (template_hole 0, template_var 3), t_empty)))),
    ("HF.HSigmaE2",
     "[| <?a, ?b> <: HSigma ?A ?B;
         [| ?a <: ?A; ?b <: ?B ?a |] ==> ?thesis |]
      ==> ?thesis",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 4),
                  template_var 3)),
              template_app
               (template_app (template_hole 0, template_var 2),
                template_var 1))
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app (template_hole 2, template_var 4),
                 template_var 2)
               )],
          template_implication
           ([template_predicate
              (
                 template_app
                  (template_app (template_hole 2, template_var 3),
                   template_app (template_var 1, template_var 4))
                 )],
            template_predicate (template_var 0)))],
       template_predicate (template_var 0))),
    ("Product_Type.SigmaE2",
     "[| (?a, ?b) : Sigma ?A ?B; [| ?a : ?A; ?b : ?B ?a |] ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app
                 (template_app (template_hole 3, template_var 4),
                  template_var 3)),
              template_app
               (template_app (template_hole 2, template_var 2),
                template_var 1))
            ),
        template_implication
         ([template_predicate
            (
               template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 2)
               )],
          template_implication
           ([template_predicate
              (
                 template_app
                  (template_app (template_hole 0, template_var 3),
                   template_app (template_var 1, template_var 4))
                 )],
            template_predicate (template_var 0)))],
       template_predicate (template_var 0))),
    ("Sigma.ground_prove_IN",
     "[| ground ?t; ground ?u;
         \<lbrakk>?t\<rbrakk>?e <: \<lbrakk>?u\<rbrakk>?e |]
      ==> {} \<turnstile> ?t IN ?u",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 2),
              template_hole 5)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 1),
              template_hole 5)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app
                 (template_app (template_hole 3, template_var 0),
                  template_var 2)),
              template_app
               (template_app (template_hole 3, template_var 0),
                template_var 1))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 1))
           ))),
    ("Sigma.ground_prove_EQ",
     "[| ground ?t; ground ?u;
         \<lbrakk>?t\<rbrakk>?e = \<lbrakk>?u\<rbrakk>?e |]
      ==> {} \<turnstile> ?t EQ ?u",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 2),
              template_hole 5)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 1),
              template_hole 5)
            ),
        template_equation
         (template_app
           (template_app (template_hole 3, template_var 0), template_var 2),
          template_app
           (template_app (template_hole 3, template_var 0),
            template_var 1))],
       template_predicate
        (
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 1))
           ))),
    ("Sigma.ground_prove_SUBS",
     "[| ground ?t; ground ?u;
         \<lbrakk>?t\<rbrakk>?e <= \<lbrakk>?u\<rbrakk>?e |]
      ==> {} \<turnstile> ?t SUBS ?u",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 2),
              template_hole 5)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 1),
              template_hole 5)
            ),
        template_inequation
         (less_equals,
          template_app
           (template_app (template_hole 3, template_var 0), template_var 2),
          template_app
           (template_app (template_hole 3, template_var 0),
            template_var 1))],
       template_predicate
        (
           template_app
            (template_app (template_hole 2, template_hole 1),
             template_app
              (template_app (template_hole 0, template_var 2),
               template_var 1))
           ))),
    ("Hilbert_Choice.Ex_inj_on_UNION_Sigma",
     "EX f. inj_on f (\<Union> (?A ` ?I)) &
            f ` \<Union> (?A ` ?I) <= Sigma ?I ?A",
     template_predicate (template_app (template_hole 7, t_empty))),
    ("Groups_Big.card_SigmaI",
     "[| finite ?A; ALL a:?A. finite (?B a) |]
      ==> card (Sigma ?A ?B) = (SUM a:?A. card (?B a))",
     template_implication
      ([template_predicate (template_app (template_hole 7, template_var 1)),
        template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 1), t_empty)
            )],
       template_equation
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 1), t_empty)),
         template_app
          (template_app (template_hole 1, t_empty), template_var 1)))),
    ("Sigma.Sigma_fm_All2_Var",
     "[| Sigma_fm ?A; atom ?j \<sharp> (?i, ?A) |]
      ==> Sigma_fm (All2 ?i (Var ?j) ?A)",
     template_implication
      ([template_predicate (template_app (template_hole 8, template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 7,
                template_app (template_hole 6, template_var 1)),
              template_app
               (template_app (template_hole 5, template_var 0),
                template_var 2))
            )],
       template_predicate
        (
           template_app
            (template_hole 8,
             template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 3, template_var 0),
                 template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_hole 2,
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app
                            (template_hole 1,
                             template_app
                              (template_hole 0, template_var 0)),
                           template_app
                            (template_hole 0, template_var 1)))),
                     template_var 2)))))
           ))),
    ("Sigma.Eq_Eats_sf",
     "[| !!j. Sigma_fm (Var j EQ ?t); !!k. Sigma_fm (Var k EQ ?u) |]
      ==> Sigma_fm (Var ?i EQ Eats ?t ?u)",
     template_implication
      ([template_predicate (template_app (template_hole 5, t_empty)),
        template_predicate (template_app (template_hole 5, t_empty))],
       template_predicate
        (
           template_app
            (template_hole 3,
             template_app
              (template_app
                (template_hole 2,
                 template_app (template_hole 1, template_var 0)),
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)))
           ))),
    ("Sigma.Eats_Mem_sf",
     "[| !!j. Sigma_fm (Var j EQ ?t); !!k. Sigma_fm (Var k EQ ?u) |]
      ==> Sigma_fm (Eats ?t ?u IN Var ?i)",
     template_implication
      ([template_predicate (template_app (template_hole 6, t_empty)),
        template_predicate (template_app (template_hole 6, t_empty))],
       template_predicate
        (
           template_app
            (template_hole 4,
             template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app (template_hole 0, template_var 2),
                   template_var 1)),
               template_app (template_hole 2, template_var 0)))
           ))),
    ("Sigma.Subset_Eats_sf",
     "[| !!j. Sigma_fm (Var j IN ?t); !!k. Sigma_fm (Var k EQ ?u) |]
      ==> Sigma_fm (Var ?i SUBS Eats ?t ?u)",
     template_implication
      ([template_predicate (template_app (template_hole 7, t_empty)),
        template_predicate (template_app (template_hole 7, t_empty))],
       template_predicate
        (
           template_app
            (template_hole 5,
             template_app
              (template_app
                (template_hole 1,
                 template_app (template_hole 3, template_var 0)),
               template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1)))
           ))),
    ("Product_Type.Sigma_mono",
     "[| ?A <= ?C; !!x. x : ?A ==> ?B x <= ?D x |]
      ==> Sigma ?A ?B <= Sigma ?C ?D",
     template_implication
      ([template_inequation (less_equals, template_var 3, template_var 2),
        template_predicate (template_app (template_hole 4, t_empty))],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 0, template_var 3), template_var 1),
         template_app
          (template_app (template_hole 0, template_var 2),
           template_var 0)))),
    ("Old_Datatype.dprod_subset_Sigma",
     "[| ?r <= ?A \<times> ?B; ?s <= ?C \<times> ?D |]
      ==> dprod ?r ?s <= uprod ?A ?C \<times> uprod ?B ?D",
     template_implication
      ([template_inequation
         (less_equals, template_var 5,
          template_app
           (template_app (template_hole 2, template_var 4), t_empty)),
        template_inequation
         (less_equals, template_var 2,
          template_app
           (template_app (template_hole 2, template_var 1), t_empty))],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 1, template_var 5), template_var 2),
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 0, template_var 4),
               template_var 1)),
           t_empty)))),
    ("Old_Datatype.dsum_subset_Sigma",
     "[| ?r <= ?A \<times> ?B; ?s <= ?C \<times> ?D |]
      ==> dsum ?r ?s <= usum ?A ?C \<times> usum ?B ?D",
     template_implication
      ([template_inequation
         (less_equals, template_var 5,
          template_app
           (template_app (template_hole 2, template_var 4), t_empty)),
        template_inequation
         (less_equals, template_var 2,
          template_app
           (template_app (template_hole 2, template_var 1), t_empty))],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 1, template_var 5), template_var 2),
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 0, template_var 4),
               template_var 1)),
           t_empty)))),
    ("Sigma.eval_fm_All2_Iff_elts",
     "ground ?t ==>
      eval_fm ?e (All2 ?i ?t ?A) =
      (ALL u:elts ?t. eval_fm ?e (?A(?i::=u)))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 11, template_var 3),
              template_hole 10)
            )],
       template_equation
        (template_app
          (template_app (template_hole 8, template_var 2),
           template_app
            (template_hole 7,
             template_app
              (template_app (template_hole 6, template_var 1),
               template_app
                (template_hole 7,
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_hole 4,
                           template_app (template_hole 3, template_var 1)),
                         template_var 3))),
                   template_var 0))))),
         template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 3)),
           t_empty)))),
    ("Predicates.HFun_Sigma_E",
     "[| ?H \<turnstile> HFun_Sigma ?r; ?H \<turnstile> HPair ?a ?b IN ?r;
         ?H \<turnstile> HPair ?a ?b' IN ?r |]
      ==> ?H \<turnstile> ?b EQ ?b'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 4),
              template_app (template_hole 3, template_var 3))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 4),
              template_app
               (template_app
                 (template_hole 2,
                  template_app
                   (template_app (template_hole 1, template_var 2),
                    template_var 1)),
                template_var 3))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 4),
              template_app
               (template_app
                 (template_hole 2,
                  template_app
                   (template_app (template_hole 1, template_var 2),
                    template_var 0)),
                template_var 3))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 4, template_var 4),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("Product_Type.Sigma_cong",
     "[| ?A = ?B; !!x. x : ?B ==> ?C x = ?D x |]
      ==> Sigma ?A ?C = Sigma ?B ?D",
     template_implication
      ([template_equation (template_var 3, template_var 2),
        template_predicate (template_app (template_hole 4, t_empty))],
       template_equation
        (template_app
          (template_app (template_hole 0, template_var 3), t_empty),
         template_app
          (template_app (template_hole 0, template_var 2), t_empty)))),
    ("Finite_Set.finite_SigmaI2",
     "[| finite {x: ?A. ?B x ~= {}}; !!a. a : ?A ==> finite (?B a) |]
      ==> finite (Sigma ?A ?B)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 10, template_app (template_hole 9, t_empty))
            ),
        template_predicate (template_app (template_hole 3, t_empty))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))
           ))),
    ("HF.HSigmaE",
     "[| ?c <: HSigma ?A ?B;
         !!x y. [| x <: ?A; y <: ?B x; ?c = <x, y> |] ==> ?thesis |]
      ==> ?thesis",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 3),
              template_app
               (template_app (template_hole 3, template_var 2),
                template_var 1))
            ),
        template_predicate (template_app (template_hole 2, t_empty))],
       template_predicate (template_var 0))),
    ("Product_Type.SigmaE",
     "[| ?c : Sigma ?A ?B;
         !!x y. [| x : ?A; y : ?B x; ?c = (x, y) |] ==> ?P |]
      ==> ?P",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 7, template_var 3),
              template_app
               (template_app (template_hole 6, template_var 2),
                template_var 1))
            ),
        template_predicate (template_app (template_hole 5, t_empty))],
       template_predicate (template_var 0))),
    ("Sigma.prove_elts_imp_prove_All2",
     "[| ground ?t; !!u. u : elts ?t ==> {} \<turnstile> ?A(?i::=u) |]
      ==> {} \<turnstile> All2 ?i ?t ?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 12, template_var 2),
              template_hole 11)
            ),
        template_predicate (template_app (template_hole 10, t_empty))],
       template_predicate
        (
           template_app
            (template_app (template_hole 7, template_hole 6),
             template_app
              (template_hole 4,
               template_app
                (template_app (template_hole 3, template_var 0),
                 template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_hole 2,
                       template_app
                        (template_hole 4,
                         template_app
                          (template_app
                            (template_hole 1,
                             template_app
                              (template_hole 0, template_var 0)),
                           template_var 2))),
                     template_var 1)))))
           ))),
    ("Sigma.eval_fm_All2_Eats",
     "atom ?i \<sharp> (?t, ?u) ==>
      eval_fm ?e (All2 ?i (Eats ?t ?u) ?A) =
      (eval_fm ?e (?A(?i::=?u)) & eval_fm ?e (All2 ?i ?t ?A))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 12,
                template_app (template_hole 11, template_var 4)),
              template_app
               (template_app (template_hole 10, template_var 3),
                template_var 2))
            )],
       template_equation
        (template_app
          (template_app (template_hole 8, template_var 1),
           template_app
            (template_hole 7,
             template_app
              (template_app (template_hole 6, template_var 4),
               template_app
                (template_hole 7,
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app
                      (template_hole 7,
                       template_app
                        (template_app
                          (template_hole 4,
                           template_app (template_hole 3, template_var 4)),
                         template_app
                          (template_app (template_hole 2, template_var 3),
                           template_var 2)))),
                   template_var 0))))),
         template_app
          (template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 8, template_var 1),
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 0),
                   template_var 4),
                 template_var 2))),
           template_app
            (template_app (template_hole 8, template_var 1),
             template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 6, template_var 4),
                 template_app
                  (template_hole 7,
                   template_app
                    (template_app
                      (template_hole 5,
                       template_app
                        (template_hole 7,
                         template_app
                          (template_app
                            (template_hole 4,
                             template_app
                              (template_hole 3, template_var 4)),
                           template_var 3))),
                     template_var 0))))))))),
    ("Predicates.HFun_Sigma_Mem_imp_HPair",
     "[| ?H \<turnstile> HFun_Sigma ?r; ?H \<turnstile> ?a IN ?r;
         atom ?x \<sharp> (?y, ?a, ?r); atom ?y \<sharp> (?a, ?r) |]
      ==> ?H \<turnstile>
          SyntaxN.Ex ?x (SyntaxN.Ex ?y (?a EQ HPair (Var ?x) (Var ?y)))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 11, template_var 4),
              template_app (template_hole 10, template_var 3))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 11, template_var 4),
              template_app
               (template_app (template_hole 9, template_var 2),
                template_var 3))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 8,
                template_app (template_hole 7, template_var 1)),
              template_app
               (template_app (template_hole 6, template_var 0),
                template_app
                 (template_app (template_hole 5, template_var 2),
                  template_var 3)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app (template_hole 7, template_var 0)),
              template_app
               (template_app (template_hole 5, template_var 2),
                template_var 3))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 11, template_var 4),
             template_app
              (template_app (template_hole 3, template_var 1),
               template_app
                (template_app (template_hole 3, template_var 0),
                 template_app
                  (template_app (template_hole 2, template_var 2),
                   template_app
                    (template_app
                      (template_hole 1,
                       template_app (template_hole 0, template_var 1)),
                     template_app (template_hole 0, template_var 0))))))
           ))),
    ("Sigma.Eq_Eats_Iff",
     "atom ?i \<sharp> (?z, ?x, ?y) ==>
      {} \<turnstile>
      ?z EQ Eats ?x ?y IFF
      All2 ?i ?z (Var ?i IN ?x OR Var ?i EQ ?y) AND
      ?x SUBS ?z AND ?y IN ?z",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 15,
                template_app (template_hole 14, template_var 3)),
              template_app
               (template_app (template_hole 13, template_var 2),
                template_app
                 (template_app (template_hole 12, template_var 1),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 11, template_hole 10),
             template_app
              (template_app
                (template_hole 9,
                 template_app
                  (template_app (template_hole 8, template_var 2),
                   template_app
                    (template_app (template_hole 7, template_var 1),
                     template_var 0))),
               template_app
                (template_app
                  (template_hole 6,
                   template_app
                    (template_hole 5,
                     template_app
                      (template_app (template_hole 4, template_var 3),
                       template_app
                        (template_hole 5,
                         template_app
                          (template_app
                            (template_hole 3,
                             template_app
                              (template_hole 5,
                               template_app
                                (template_app
                                  (template_hole 2,
                                   template_app
                                    (template_hole 1, template_var 3)),
                                 template_var 2))),
                           template_app
                            (template_app
                              (template_hole 3,
                               template_app
                                (template_app
                                  (template_hole 2,
                                   template_app
                                    (template_hole 1, template_var 3)),
                                 template_var 1)),
                             template_app
                              (template_app
                                (template_hole 8,
                                 template_app
                                  (template_hole 1, template_var 3)),
                               template_var 0))))))),
                 template_app
                  (template_app
                    (template_hole 6,
                     template_app
                      (template_app (template_hole 0, template_var 1),
                       template_var 2)),
                   template_app
                    (template_app (template_hole 2, template_var 0),
                     template_var 2)))))
           ))),
    ("Sigma.ground_prove",
     "[| size ?t + size ?u < ?n; ground ?t; ground ?u |]
      ==> (\<lbrakk>?t\<rbrakk>?e <= \<lbrakk>?u\<rbrakk>?e -->
           {} \<turnstile> ?t SUBS ?u) &
          (\<lbrakk>?t\<rbrakk>?e <: \<lbrakk>?u\<rbrakk>?e -->
           {} \<turnstile> ?t IN ?u)",
     template_implication
      ([template_inequation
         (less_than,
          template_app
           (template_app
             (template_hole 12,
              template_app (template_hole 11, template_var 3)),
            template_app (template_hole 11, template_var 2)),
          template_var 1),
        template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 3),
              template_hole 9)
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 10, template_var 2),
              template_hole 9)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 8,
               template_app
                (template_app
                  (template_hole 7,
                   template_app
                    (template_app
                      (template_hole 6,
                       template_app
                        (template_app (template_hole 5, template_var 0),
                         template_var 3)),
                     template_app
                      (template_app (template_hole 5, template_var 0),
                       template_var 2))),
                 template_app
                  (template_app (template_hole 4, template_hole 3),
                   template_app
                    (template_app (template_hole 2, template_var 3),
                     template_var 2)))),
             template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_app
                    (template_hole 1,
                     template_app
                      (template_app (template_hole 5, template_var 0),
                       template_var 3)),
                   template_app
                    (template_app (template_hole 5, template_var 0),
                     template_var 2))),
               template_app
                (template_app (template_hole 4, template_hole 3),
                 template_app
                  (template_app (template_hole 0, template_var 3),
                   template_var 2))))
           ))),
    ("Sigma.All2_term_Iff",
     "[| atom ?i \<sharp> ?t; atom ?j \<sharp> (?i, ?t, ?A) |]
      ==> {} \<turnstile>
          All2 ?i ?t ?A IFF
          SyntaxN.Ex ?j (Var ?j EQ ?t AND All2 ?i (Var ?j) ?A)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 14,
                template_app (template_hole 13, template_var 3)),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 12,
                template_app (template_hole 13, template_var 1)),
              template_app
               (template_app (template_hole 11, template_var 3),
                template_app
                 (template_app (template_hole 10, template_var 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 9, template_hole 8),
             template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_hole 6,
                   template_app
                    (template_app (template_hole 5, template_var 3),
                     template_app
                      (template_hole 6,
                       template_app
                        (template_app
                          (template_hole 4,
                           template_app
                            (template_hole 6,
                             template_app
                              (template_app
                                (template_hole 3,
                                 template_app
                                  (template_hole 2, template_var 3)),
                               template_var 2))),
                         template_var 0))))),
               template_app
                (template_app (template_hole 5, template_var 1),
                 template_app
                  (template_app
                    (template_hole 1,
                     template_app
                      (template_app
                        (template_hole 0,
                         template_app (template_hole 2, template_var 1)),
                       template_var 2)),
                   template_app
                    (template_hole 6,
                     template_app
                      (template_app (template_hole 5, template_var 3),
                       template_app
                        (template_hole 6,
                         template_app
                          (template_app
                            (template_hole 4,
                             template_app
                              (template_hole 6,
                               template_app
                                (template_app
                                  (template_hole 3,
                                   template_app
                                    (template_hole 2, template_var 3)),
                                 template_app
                                  (template_hole 2, template_var 1)))),
                           template_var 0))))))))
           ))),
    ("Sigma.All2_term_Iff_fresh",
     "[| ?i ~= ?j; atom ?j' \<sharp> (?i, ?j, ?A) |]
      ==> {} \<turnstile>
          All2 ?i (Var ?j) ?A IFF
          SyntaxN.Ex ?j' (Var ?j EQ Var ?j' AND All2 ?i (Var ?j') ?A)",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 13,
                template_app (template_hole 12, template_var 1)),
              template_app
               (template_app (template_hole 11, template_var 3),
                template_app
                 (template_app (template_hole 10, template_var 2),
                  template_var 0)))
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 9, template_hole 8),
             template_app
              (template_app
                (template_hole 7,
                 template_app
                  (template_hole 6,
                   template_app
                    (template_app (template_hole 5, template_var 3),
                     template_app
                      (template_hole 6,
                       template_app
                        (template_app
                          (template_hole 4,
                           template_app
                            (template_hole 6,
                             template_app
                              (template_app
                                (template_hole 3,
                                 template_app
                                  (template_hole 2, template_var 3)),
                               template_app
                                (template_hole 2, template_var 2)))),
                         template_var 0))))),
               template_app
                (template_app (template_hole 5, template_var 1),
                 template_app
                  (template_app
                    (template_hole 1,
                     template_app
                      (template_app
                        (template_hole 0,
                         template_app (template_hole 2, template_var 2)),
                       template_app (template_hole 2, template_var 1))),
                   template_app
                    (template_hole 6,
                     template_app
                      (template_app (template_hole 5, template_var 3),
                       template_app
                        (template_hole 6,
                         template_app
                          (template_app
                            (template_hole 4,
                             template_app
                              (template_hole 6,
                               template_app
                                (template_app
                                  (template_hole 3,
                                   template_app
                                    (template_hole 2, template_var 3)),
                                 template_app
                                  (template_hole 2, template_var 1)))),
                           template_var 0))))))))
           ))),
    ("Sigma.HFun_Sigma_Iff",
     "[| atom ?z \<sharp> (?r, ?z', ?x, ?y, ?x', ?y');
         atom ?z' \<sharp> (?r, ?x, ?y, ?x', ?y');
         atom ?x \<sharp> (?r, ?y, ?x', ?y');
         atom ?y \<sharp> (?r, ?x', ?y'); atom ?x' \<sharp> (?r, ?y');
         atom ?y' \<sharp> ?r |]
      ==> {} \<turnstile>
          HFun_Sigma ?r IFF
          All2 ?z ?r
           (All2 ?z' ?r
             (SyntaxN.Ex ?x
               (SyntaxN.Ex ?y
                 (SyntaxN.Ex ?x'
                   (SyntaxN.Ex ?y'
                     (Var ?z EQ HPair (Var ?x) (Var ?y) AND
                      Var ?z' EQ HPair (Var ?x') (Var ?y') AND
                      OrdP (Var ?x) AND
                      OrdP (Var ?x') AND
                      (Var ?x NEQ Var ?x' OR Var ?y EQ Var ?y')))))))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 29,
                template_app (template_hole 28, template_var 6)),
              template_app
               (template_app (template_hole 27, template_var 5),
                template_app
                 (template_app (template_hole 26, template_var 4),
                  template_app
                   (template_app (template_hole 25, template_var 3),
                    template_app
                     (template_app (template_hole 24, template_var 2),
                      template_app
                       (template_app (template_hole 23, template_var 1),
                        template_var 0))))))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 22,
                template_app (template_hole 28, template_var 4)),
              template_app
               (template_app (template_hole 21, template_var 5),
                template_app
                 (template_app (template_hole 25, template_var 3),
                  template_app
                   (template_app (template_hole 24, template_var 2),
                    template_app
                     (template_app (template_hole 23, template_var 1),
                      template_var 0)))))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 20,
                template_app (template_hole 28, template_var 3)),
              template_app
               (template_app (template_hole 19, template_var 5),
                template_app
                 (template_app (template_hole 24, template_var 2),
                  template_app
                   (template_app (template_hole 23, template_var 1),
                    template_var 0))))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 18,
                template_app (template_hole 28, template_var 2)),
              template_app
               (template_app (template_hole 17, template_var 5),
                template_app
                 (template_app (template_hole 23, template_var 1),
                  template_var 0)))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 16,
                template_app (template_hole 28, template_var 1)),
              template_app
               (template_app (template_hole 15, template_var 5),
                template_var 0))
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 14,
                template_app (template_hole 28, template_var 0)),
              template_var 5)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 13, template_hole 12),
             template_app
              (template_app
                (template_hole 11,
                 template_app (template_hole 10, template_var 5)),
               template_app
                (template_hole 9,
                 template_app
                  (template_app (template_hole 8, template_var 6),
                   template_app
                    (template_hole 9,
                     template_app
                      (template_app
                        (template_hole 7,
                         template_app
                          (template_hole 9,
                           template_app
                            (template_app
                              (template_hole 6,
                               template_app
                                (template_hole 5, template_var 6)),
                             template_var 5))),
                       template_app
                        (template_hole 9,
                         template_app
                          (template_app (template_hole 8, template_var 4),
                           template_app
                            (template_hole 9,
                             template_app
                              (template_app
                                (template_hole 7,
                                 template_app
                                  (template_hole 9,
                                   template_app
                                    (template_app
(template_hole 6, template_app (template_hole 5, template_var 4)),
                                     template_var 5))),
                               template_app
                                (template_app
                                  (template_hole 8, template_var 3),
                                 template_app
                                  (template_app
                                    (template_hole 8, template_var 2),
                                   template_app
                                    (template_app
(template_hole 8, template_var 1),
                                     template_app
(template_app (template_hole 8, template_var 0),
 template_app
  (template_app
    (template_hole 4,
     template_app
      (template_app
        (template_hole 3, template_app (template_hole 5, template_var 6)),
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 5, template_var 3)),
         template_app (template_hole 5, template_var 2)))),
   template_app
    (template_app
      (template_hole 4,
       template_app
        (template_app
          (template_hole 3, template_app (template_hole 5, template_var 4)),
         template_app
          (template_app
            (template_hole 2,
             template_app (template_hole 5, template_var 1)),
           template_app (template_hole 5, template_var 0)))),
     template_app
      (template_app
        (template_hole 4,
         template_app
          (template_hole 1,
           template_app (template_hole 5, template_var 3))),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_hole 1,
             template_app (template_hole 5, template_var 1))),
         template_app
          (template_app
            (template_hole 7,
             template_app
              (template_app
                (template_hole 0,
                 template_app (template_hole 5, template_var 3)),
               template_app (template_hole 5, template_var 1))),
           template_app
            (template_app
              (template_hole 3,
               template_app (template_hole 5, template_var 2)),
             template_app
              (template_hole 5, template_var 0)))))))))))))))))))))
           )))]:
   (string * thm * template) list
### theory "Draft.SigmaMoreTemplates"
### 0.568s elapsed time, 0.723s cpu time, 0.000s GC time
val it = (): unit
