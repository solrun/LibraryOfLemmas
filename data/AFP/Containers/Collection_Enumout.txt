Loading theory "Draft.Containers_Auxiliary" (required by "Draft.Collection_EnumTemplates" via "Draft.Collection_Enum")
Loading theory "Draft.Templates" (required by "Draft.Collection_EnumTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.073s elapsed time, 0.171s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Collection_EnumTemplates")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod" (infix \<open>\<sqsubset>\<close> 50)
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
### theory "Draft.Containers_Auxiliary"
### 0.203s elapsed time, 0.435s cpu time, 0.034s GC time
Loading theory "Draft.Containers_Generator" (required by "Draft.Collection_EnumTemplates" via "Draft.Collection_Enum")
signature CONTAINERS_GENERATOR =
  sig
    val HOLogic_list_conj: term list -> term
    val all_tys: term -> typ list -> term -> term
    val derive_is_c_dots_lemma:
       typ -> string -> thm list -> string -> theory -> theory
    val derive_none:
       string -> sort -> (typ -> term) -> string -> theory -> theory
    val derive_set_map_impl:
       string ->
         sort ->
           (string * term) list -> string -> string -> theory -> theory
    val is_class_instance: theory -> string -> sort -> bool
    val mk_Some: term -> term
    val mk_is_c_dots: typ -> string -> term
    val register_is_c_dots_lemma:
       string -> string -> thm -> theory -> theory
  end
structure Containers_Generator: CONTAINERS_GENERATOR
### theory "Draft.Containers_Generator"
### 0.310s elapsed time, 0.623s cpu time, 0.000s GC time
Loading theory "Draft.Collection_Enum" (required by "Draft.Collection_EnumTemplates")
class cenum = type +
  fixes
    cEnum ::
      "('a list * (('a => bool) => bool) * (('a => bool) => bool)) option"
  assumes
    "UNIV_cenum":
      "!!enum enum_all enum_ex.
          cEnum = Some (enum, enum_all, enum_ex) ==> UNIV = set enum"
    and
    "cenum_all_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==>
          enum_all P = Ball UNIV P"
    and
    "cenum_ex_UNIV":
      "!!enum enum_all enum_ex P.
          cEnum = Some (enum, enum_all, enum_ex) ==> enum_ex P = Bex UNIV P"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.545s elapsed time, 1.112s cpu time, 0.086s GC time
signature CENUM_GENERATOR =
  sig val derive_no_cenum: string -> theory -> theory end
structure Cenum_Generator: CENUM_GENERATOR
### Rewrite rule not in simpset:
### Wellfounded.accp all_n_lists_rel (?P1, ?n1) ==>
### all_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_all (%x. all_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### Rewrite rule not in simpset:
### Wellfounded.accp ex_n_lists_rel (?P1, ?n1) ==>
### ex_n_lists ?P1 ?n1 ==
### if ?n1 = 0 then ?P1 []
### else cenum_ex (%x. ex_n_lists (%xs. ?P1 (x # xs)) (?n1 - 1))
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  fun :: (cenum, cenum) cenum
  cEnum_fun == cEnum ::
    (('a => 'b) list *
     ((('a => 'b) => bool) => bool) * ((('a => 'b) => bool) => bool)) option
### Ambiguous input (line 136 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" map)
###                       ("_cargs"
###                         ("_lambda" ("_position" ys)
###                           ("\<^const>Fun.comp" ("_position" the)
###                             ("_applC" ("_position" map_of)
###                               ("_applC" ("_position" zip)
###                                 ("_cargs" ("_position" enum_a)
###                                   ("_position" ys))))))
###                         ("_applC" ("_position" List.n_lists)
###                           ("_cargs"
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))
###                             ("_position" enum_b)))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" all_n_lists)
###                           ("_cargs" ("_position" enum_all_b)
###                             ("_cargs"
###                               ("_lambda" ("_position" bs)
###                                 ("_applC" ("_position" P)
###                                   ("\<^const>Fun.comp" ("_position" the)
###                                     ("_applC" ("_position" map_of)
### ("_applC" ("_position" zip)
###   ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                               ("_applC" ("_position" length)
###                                 ("_position" enum_a))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" ex_n_lists)
###                             ("_cargs" ("_position" enum_ex_b)
###                               ("_cargs"
###                                 ("_lambda" ("_position" bs)
###                                   ("_applC" ("_position" P)
###                                     ("\<^const>Fun.comp" ("_position" the)
### ("_applC" ("_position" map_of)
###   ("_applC" ("_position" zip)
###     ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                                 ("_applC" ("_position" length)
###                                   ("_position" enum_a))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM" ("\<^type>fun" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" map)
###                   ("_cargs"
###                     ("_lambda" ("_position" ys)
###                       ("\<^const>Fun.comp" ("_position" the)
###                         ("_applC" ("_position" map_of)
###                           ("_applC" ("_position" zip)
###                             ("_cargs" ("_position" enum_a)
###                               ("_position" ys))))))
###                     ("_applC" ("_position" List.n_lists)
###                       ("_cargs"
###                         ("_applC" ("_position" length) ("_position" enum_a))
###                         ("_position" enum_b)))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" all_n_lists)
###                       ("_cargs" ("_position" enum_all_b)
###                         ("_cargs"
###                           ("_lambda" ("_position" bs)
###                             ("_applC" ("_position" P)
###                               ("\<^const>Fun.comp" ("_position" the)
###                                 ("_applC" ("_position" map_of)
###                                   ("_applC" ("_position" zip)
###                                     ("_cargs" ("_position" enum_a)
### ("_position" bs)))))))
###                           ("_applC" ("_position" length)
###                             ("_position" enum_a))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" ex_n_lists)
###                         ("_cargs" ("_position" enum_ex_b)
###                           ("_cargs"
###                             ("_lambda" ("_position" bs)
###                               ("_applC" ("_position" P)
###                                 ("\<^const>Fun.comp" ("_position" the)
###                                   ("_applC" ("_position" map_of)
###                                     ("_applC" ("_position" zip)
### ("_cargs" ("_position" enum_a) ("_position" bs)))))))
###                             ("_applC" ("_position" length)
###                               ("_position" enum_a))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  set :: (cenum) cenum
  cEnum_set == cEnum ::
    ('a set list *
     (('a set => bool) => bool) * (('a set => bool) => bool)) option
instantiation
  unit :: cenum
  cEnum_unit == cEnum ::
    (unit list * ((unit => bool) => bool) * ((unit => bool) => bool)) option
instantiation
  bool :: cenum
  cEnum_bool == cEnum ::
    (bool list * ((bool => bool) => bool) * ((bool => bool) => bool)) option
instantiation
  prod :: (cenum, cenum) cenum
  cEnum_prod == cEnum ::
    (('a * 'b) list *
     (('a * 'b => bool) => bool) * (('a * 'b => bool) => bool)) option
### Ambiguous input (line 225 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("_applC" ("_position" List.product)
###                       ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("_applC" ("_position" enum_all_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" enum_all_b)
###                               ("_lambda" ("_position" y)
###                                 ("_applC" ("_position" P)
###                                   ("_tuple" ("_position" x)
###                                     ("_tuple_arg" ("_position" y)))))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("_applC" ("_position" enum_ex_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" enum_ex_b)
###                                 ("_lambda" ("_position" y)
###                                   ("_applC" ("_position" P)
###                                     ("_tuple" ("_position" x)
### ("_tuple_arg" ("_position" y)))))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Product_Type.prod" ("_position_sort" 'a)
###         ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("_applC" ("_position" List.product)
###                   ("_cargs" ("_position" enum_a) ("_position" enum_b)))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("_applC" ("_position" enum_all_a)
###                       ("_lambda" ("_position" x)
###                         ("_applC" ("_position" enum_all_b)
###                           ("_lambda" ("_position" y)
###                             ("_applC" ("_position" P)
###                               ("_tuple" ("_position" x)
###                                 ("_tuple_arg" ("_position" y)))))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("_applC" ("_position" enum_ex_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" enum_ex_b)
###                             ("_lambda" ("_position" y)
###                               ("_applC" ("_position" P)
###                                 ("_tuple" ("_position" x)
###                                   ("_tuple_arg"
###                                     ("_position" y)))))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  sum :: (cenum, cenum) cenum
  cEnum_sum == cEnum ::
    (('a + 'b) list *
     (('a + 'b => bool) => bool) * (('a + 'b => bool) => bool)) option
### Ambiguous input (line 237 of "$AFP/Containers/Collection_Enum.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case1"
###           ("_applC" ("_position" Some)
###             ("_tuple" ("_position" enum_a)
###               ("_tuple_args" ("_position" enum_all_a)
###                 ("_tuple_arg" ("_position" enum_ex_a)))))
###           ("_case_syntax"
###             ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###             ("_case2" ("_case1" ("_position" None) ("_position" None))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" enum_b)
###                     ("_tuple_args" ("_position" enum_all_b)
###                       ("_tuple_arg" ("_position" enum_ex_b)))))
###                 ("_applC" ("_position" Some)
###                   ("_tuple"
###                     ("\<^const>List.append"
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                       ("_applC" ("_position" map)
###                         ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                     ("_tuple_args"
###                       ("_lambda" ("_position" P)
###                         ("\<^const>HOL.conj"
###                           ("_applC" ("_position" enum_all_a)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inl)
###                                   ("_position" x)))))
###                           ("_applC" ("_position" enum_all_b)
###                             ("_lambda" ("_position" x)
###                               ("_applC" ("_position" P)
###                                 ("_applC" ("_position" Inr)
###                                   ("_position" x)))))))
###                       ("_tuple_arg"
###                         ("_lambda" ("_position" P)
###                           ("\<^const>HOL.disj"
###                             ("_applC" ("_position" enum_ex_a)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inl)
###                                     ("_position" x)))))
###                             ("_applC" ("_position" enum_ex_b)
###                               ("_lambda" ("_position" x)
###                                 ("_applC" ("_position" P)
###                                   ("_applC" ("_position" Inr)
###                                     ("_position" x)))))))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_CENUM"
###       ("\<^type>Sum_Type.sum" ("_position_sort" 'a) ("_position_sort" 'b)))
###     ("_case_syntax"
###       ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'a)))
###       ("_case2" ("_case1" ("_position" None) ("_position" None))
###         ("_case2"
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_a)
###                 ("_tuple_args" ("_position" enum_all_a)
###                   ("_tuple_arg" ("_position" enum_ex_a)))))
###             ("_case_syntax"
###               ("_applC" ("_position" ID) ("_CENUM" ("_position_sort" 'b)))
###               ("_case1" ("_position" None) ("_position" None))))
###           ("_case1"
###             ("_applC" ("_position" Some)
###               ("_tuple" ("_position" enum_b)
###                 ("_tuple_args" ("_position" enum_all_b)
###                   ("_tuple_arg" ("_position" enum_ex_b)))))
###             ("_applC" ("_position" Some)
###               ("_tuple"
###                 ("\<^const>List.append"
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inl) ("_position" enum_a)))
###                   ("_applC" ("_position" map)
###                     ("_cargs" ("_position" Inr) ("_position" enum_b))))
###                 ("_tuple_args"
###                   ("_lambda" ("_position" P)
###                     ("\<^const>HOL.conj"
###                       ("_applC" ("_position" enum_all_a)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inl) ("_position" x)))))
###                       ("_applC" ("_position" enum_all_b)
###                         ("_lambda" ("_position" x)
###                           ("_applC" ("_position" P)
###                             ("_applC" ("_position" Inr)
###                               ("_position" x)))))))
###                   ("_tuple_arg"
###                     ("_lambda" ("_position" P)
###                       ("\<^const>HOL.disj"
###                         ("_applC" ("_position" enum_ex_a)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inl)
###                                 ("_position" x)))))
###                         ("_applC" ("_position" enum_ex_b)
###                           ("_lambda" ("_position" x)
###                             ("_applC" ("_position" P)
###                               ("_applC" ("_position" Inr)
###                                 ("_position" x)))))))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  option :: (cenum) cenum
  cEnum_option == cEnum ::
    ('a option list *
     (('a option => bool) => bool) * (('a option => bool) => bool)) option
instantiation
  Enum.finite_1 :: cenum
  cEnum_finite_1 == cEnum ::
    (Enum.finite_1 list *
     ((Enum.finite_1 => bool) => bool) *
     ((Enum.finite_1 => bool) => bool)) option
instantiation
  Enum.finite_2 :: cenum
  cEnum_finite_2 == cEnum ::
    (Enum.finite_2 list *
     ((Enum.finite_2 => bool) => bool) *
     ((Enum.finite_2 => bool) => bool)) option
instantiation
  Enum.finite_3 :: cenum
  cEnum_finite_3 == cEnum ::
    (Enum.finite_3 list *
     ((Enum.finite_3 => bool) => bool) *
     ((Enum.finite_3 => bool) => bool)) option
instantiation
  Enum.finite_4 :: cenum
  cEnum_finite_4 == cEnum ::
    (Enum.finite_4 list *
     ((Enum.finite_4 => bool) => bool) *
     ((Enum.finite_4 => bool) => bool)) option
instantiation
  Enum.finite_5 :: cenum
  cEnum_finite_5 == cEnum ::
    (Enum.finite_5 list *
     ((Enum.finite_5 => bool) => bool) *
     ((Enum.finite_5 => bool) => bool)) option
instantiation
  char :: cenum
  cEnum_char == cEnum ::
    (char list * ((char => bool) => bool) * ((char => bool) => bool)) option
use None as trivial implementation of cenum for type list
registered list in class cenum
use None as trivial implementation of cenum for type nat
registered nat in class cenum
use None as trivial implementation of cenum for type int
registered int in class cenum
use None as trivial implementation of cenum for type integer
registered integer in class cenum
use None as trivial implementation of cenum for type natural
registered natural in class cenum
use None as trivial implementation of cenum for type literal
registered literal in class cenum
### theory "Draft.Collection_Enum"
### 0.416s elapsed time, 0.535s cpu time, 0.052s GC time
Loading theory "Draft.Collection_EnumTemplates"
val templateLemmas =
   [("Collection_Enum.all_n_lists_iff",
     "all_n_lists (Ball (set ?cenum)) ?P ?n =
      (ALL xs:set (List.n_lists ?n ?cenum). ?P xs)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_hole 4,
               template_app (template_hole 3, template_var 2))),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 2))),
         t_empty))),
    ("Collection_Enum.ex_n_lists_iff",
     "ex_n_lists (Bex (set ?cenum)) ?P ?n =
      (EX xs:set (List.n_lists ?n ?cenum). ?P xs)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_hole 4,
               template_app (template_hole 3, template_var 2))),
           template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_hole 1,
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 2))),
         t_empty)))]:
   (string * thm * template) list
### theory "Draft.Collection_EnumTemplates"
### 0.316s elapsed time, 0.434s cpu time, 0.054s GC time
val it = (): unit
