Loading theory "Draft.Extend_Partial_Order" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2" via "Draft.RBT_Mapping2" via "Draft.Collection_Order" via "Draft.Set_Linorder")
Loading theory "Draft.List_Fusion" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2" via "Draft.RBT_Mapping2" via "Draft.Collection_Order" via "Draft.Set_Linorder" via "Draft.Lexicographic_Order")
Loading theory "Draft.Containers_Auxiliary" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2" via "Draft.RBT_Mapping2" via "Draft.Collection_Order" via "Draft.Set_Linorder")
Loading theory "Draft.Templates" (required by "Draft.RBT_Set2Templates" via "Draft.ExtrEqs")
Proofs for inductive predicate(s) "terminates_onp"
  Proving monotonicity ...
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.070s elapsed time, 0.305s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.RBT_Set2Templates")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Dropping global mixfix syntax: "less_eq_prod" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod" (infix \<open>\<sqsubset>\<close> 50)
### theory "Draft.Extend_Partial_Order"
### 0.198s elapsed time, 0.770s cpu time, 0.035s GC time
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
### theory "Draft.Containers_Auxiliary"
### 0.224s elapsed time, 0.863s cpu time, 0.035s GC time
Loading theory "Draft.Containers_Generator" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2" via "Draft.RBT_Mapping2" via "Draft.Collection_Order")
locale list
  fixes g :: "('a, 's) generator"
consts
  list_has_next :: "'a list => bool"
### No equation for constructor "[]"
consts
  list_next :: "'a list => 'a * 'a list"
Found termination order: "{}"
Found termination order: "case_sum (%x. Suc 0) (%x. 0) <*mlex*> {}"
signature CONTAINERS_GENERATOR =
  sig
    val HOLogic_list_conj: term list -> term
    val all_tys: term -> typ list -> term -> term
    val derive_is_c_dots_lemma:
       typ -> string -> thm list -> string -> theory -> theory
    val derive_none:
       string -> sort -> (typ -> term) -> string -> theory -> theory
    val derive_set_map_impl:
       string ->
         sort ->
           (string * term) list -> string -> string -> theory -> theory
    val is_class_instance: theory -> string -> sort -> bool
    val mk_Some: term -> term
    val mk_is_c_dots: typ -> string -> term
    val register_is_c_dots_lemma:
       string -> string -> thm -> theory -> theory
  end
structure Containers_Generator: CONTAINERS_GENERATOR
### theory "Draft.Containers_Generator"
### 0.367s elapsed time, 1.100s cpu time, 0.136s GC time
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.637s elapsed time, 1.894s cpu time, 0.171s GC time
Proofs for inductive predicate(s) "filter_has_next"
  Proving monotonicity ...
### theory "Draft.List_Fusion"
### 0.836s elapsed time, 2.300s cpu time, 0.171s GC time
Loading theory "Draft.Lexicographic_Order" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2" via "Draft.RBT_Mapping2" via "Draft.Collection_Order" via "Draft.Set_Linorder")
Loading theory "Draft.RBT_ext" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2" via "Draft.RBT_Mapping2")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Draft.Lexicographic_Order"
### 0.241s elapsed time, 0.498s cpu time, 0.048s GC time
Loading theory "Draft.Set_Linorder" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2" via "Draft.RBT_Mapping2" via "Draft.Collection_Order")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
specification
  finite_complement_partition: finite ?A ==> ?A : infinite_complement_partition
  complement_partition: infinite UNIV ==>
(?A : infinite_complement_partition) =
(- ?A ~: infinite_complement_partition)
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### Dropping global mixfix syntax: "less_eq_prod'" (infix \<open>\<sqsubseteq>\<close> 50)
### Dropping global mixfix syntax: "less_prod'" (infix \<open>\<sqsubset>\<close> 50)
consts
  RBT_Impl_diag :: "('a, 'b) rbt => ('a * 'a, 'b) rbt"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "{}"
### Missing patterns in function definition:
### rbt_keys_next ([], rbt.Empty) = undefined
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### rbt_entries_next ([], rbt.Empty) = undefined
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Draft.RBT_ext"
### 1.555s elapsed time, 3.322s cpu time, 0.635s GC time
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
class proper_interval = proper_intrvl +
  assumes
    "proper_interval_simps": "proper_interval None None = True"
      "!!y. proper_interval None (Some y) = (EX z. z < y)"
      "!!x. proper_interval (Some x) None = (EX z. x < z)"
      "!!x y. proper_interval (Some x) (Some y) = (EX z>x. z < y)"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd (snd (snd p)))) <*mlex*>
   (%p. length (fst (snd (snd p)))) <*mlex*> {}"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
instantiation
  unit :: proper_interval
  proper_interval_unit == proper_interval ::
    unit option => unit option => bool
Found termination order: "{}"
instantiation
  bool :: proper_interval
  proper_interval_bool == proper_interval ::
    bool option => bool option => bool
Found termination order: "{}"
instantiation
  nat :: proper_interval
  proper_interval_nat == proper_interval :: nat option => nat option => bool
Found termination order: "{}"
instantiation
  int :: proper_interval
  proper_interval_int == proper_interval :: int option => int option => bool
Found termination order: "{}"
instantiation
  integer :: proper_interval
  proper_interval_integer == proper_interval ::
    integer option => integer option => bool
instantiation
  natural :: proper_interval
  proper_interval_natural == proper_interval ::
    natural option => natural option => bool
instantiation
  char :: proper_interval
  proper_interval_char == proper_interval ::
    char option => char option => bool
Found termination order: "{}"
instantiation
  Enum.finite_1 :: proper_interval
  proper_interval_finite_1 == proper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: proper_interval
  proper_interval_finite_2 == proper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
Found termination order: "{}"
instantiation
  Enum.finite_3 :: proper_interval
  proper_interval_finite_3 == proper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
Found termination order: "{}"
class proper_intrvl = ord +
  fixes proper_interval :: "'a option => 'a option => bool"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Draft.Set_Linorder"
### 5.968s elapsed time, 8.133s cpu time, 1.517s GC time
Loading theory "Draft.Collection_Order" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2" via "Draft.RBT_Mapping2")
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
class ccompare = type +
  fixes ccompare :: "('a => 'a => order) option"
  assumes "ccompare": "!!comp. ccompare = Some comp ==> comparator comp"
signature CCOMPARE_GENERATOR =
  sig
    val ccompare_instance_via_comparator: string -> theory -> theory
    val ccompare_instance_via_compare: string -> theory -> theory
    val derive_no_ccompare: string -> theory -> theory
  end
structure CCompare_Generator: CCOMPARE_GENERATOR
deriving "compare_order" instance for type "Enum.finite_1"
deriving "compare" instance for type "Enum.finite_1"
deriving "compare_order" instance for type "Enum.finite_2"
deriving "compare" instance for type "Enum.finite_2"
deriving "compare_order" instance for type "Enum.finite_3"
deriving "compare" instance for type "Enum.finite_3"
deriving "compare_order" instance for type "Code_Numeral.natural"
deriving "compare" instance for type "Code_Numeral.natural"
deriving "compare_order" instance for type "String.literal"
deriving "compare" instance for type "String.literal"
deriving "ccompare_order" instance for type "Product_Type.unit" via compare_order
derived is_ccompare_unit-lemma
deriving "ccompare_order" instance for type "HOL.bool" via compare_order
derived is_ccompare_bool-lemma
deriving "ccompare_order" instance for type "Nat.nat" via compare_order
derived is_ccompare_nat-lemma
deriving "ccompare_order" instance for type "Int.int" via compare_order
derived is_ccompare_int-lemma
deriving "ccompare_order" instance for type "Enum.finite_1" via compare_order
derived is_ccompare_finite_1-lemma
deriving "ccompare_order" instance for type "Enum.finite_2" via compare_order
derived is_ccompare_finite_2-lemma
deriving "ccompare_order" instance for type "Enum.finite_3" via compare_order
derived is_ccompare_finite_3-lemma
deriving "ccompare_order" instance for type "Code_Numeral.integer" via compare_order
derived is_ccompare_integer-lemma
deriving "ccompare_order" instance for type "Code_Numeral.natural" via compare_order
derived is_ccompare_natural-lemma
deriving "ccompare_order" instance for type "String.char" via compare_order
derived is_ccompare_char-lemma
deriving "ccompare_order" instance for type "String.literal" via compare_order
derived is_ccompare_literal-lemma
use None as trivial implementation of ccompare for type finite_4
registered finite_4 in class ccompare
use None as trivial implementation of ccompare for type finite_5
registered finite_5 in class ccompare
deriving "ccompare" instance for type "Sum_Type.sum"
derived is_ccompare_sum-lemma
deriving "ccompare" instance for type "List.list"
derived is_ccompare_list-lemma
deriving "ccompare" instance for type "Option.option"
derived is_ccompare_option-lemma
deriving "ccompare" instance for type "Product_Type.prod"
derived is_ccompare_prod-lemma
use None as trivial implementation of ccompare for type fun
registered fun in class ccompare
instantiation
  set :: (ccompare) ccompare
  ccompare_set == ccompare :: ('a set => 'a set => order) option
use None as trivial implementation of ccompare for type pred
registered pred in class ccompare
class cproper_interval = ccompare +
  fixes cproper_interval :: "'a option => 'a option => bool"
  assumes
    "cproper_interval":
      "[| ID ccompare ~= None; finite UNIV |]
       ==> class.proper_interval cless cproper_interval"
instantiation
  unit :: cproper_interval
  cproper_interval_unit == cproper_interval ::
    unit option => unit option => bool
instantiation
  bool :: cproper_interval
  cproper_interval_bool == cproper_interval ::
    bool option => bool option => bool
instantiation
  nat :: cproper_interval
  cproper_interval_nat == cproper_interval ::
    nat option => nat option => bool
instantiation
  int :: cproper_interval
  cproper_interval_int == cproper_interval ::
    int option => int option => bool
instantiation
  integer :: cproper_interval
  cproper_interval_integer == cproper_interval ::
    integer option => integer option => bool
instantiation
  natural :: cproper_interval
  cproper_interval_natural == cproper_interval ::
    natural option => natural option => bool
instantiation
  char :: cproper_interval
  cproper_interval_char == cproper_interval ::
    char option => char option => bool
instantiation
  Enum.finite_1 :: cproper_interval
  cproper_interval_finite_1 == cproper_interval ::
    Enum.finite_1 option => Enum.finite_1 option => bool
instantiation
  Enum.finite_2 :: cproper_interval
  cproper_interval_finite_2 == cproper_interval ::
    Enum.finite_2 option => Enum.finite_2 option => bool
instantiation
  Enum.finite_3 :: cproper_interval
  cproper_interval_finite_3 == cproper_interval ::
    Enum.finite_3 option => Enum.finite_3 option => bool
instantiation
  Enum.finite_4 :: cproper_interval
  cproper_interval_finite_4 == cproper_interval ::
    Enum.finite_4 option => Enum.finite_4 option => bool
instantiation
  Enum.finite_5 :: cproper_interval
  cproper_interval_finite_5 == cproper_interval ::
    Enum.finite_5 option => Enum.finite_5 option => bool
instantiation
  sum :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_sum == cproper_interval ::
    ('a + 'b) option => ('a + 'b) option => bool
Found termination order: "{}"
instantiation
  prod :: (cproper_interval, cproper_interval) cproper_interval
  cproper_interval_prod == cproper_interval ::
    ('a * 'b) option => ('a * 'b) option => bool
Found termination order: "{}"
instantiation
  list :: (ccompare) cproper_interval
  cproper_interval_list == cproper_interval ::
    'a list option => 'a list option => bool
instantiation
  String.literal :: cproper_interval
  cproper_interval_literal == cproper_interval ::
    String.literal option => String.literal option => bool
instantiation
  option :: (cproper_interval) cproper_interval
  cproper_interval_option == cproper_interval ::
    'a option option => 'a option option => bool
Found termination order: "{}"
instantiation
  set :: (cproper_interval) cproper_interval
  cproper_interval_set == cproper_interval ::
    'a set option => 'a set option => bool
### Not an equation, in theorem:
### cproper_interval_set_dom (None, None) ==> cproper_interval None None == True
### Not an equation, in theorem:
### cproper_interval_set_dom (None, Some ?B) ==>
### cproper_interval None (Some ?B) == ?B ~= {}
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, None) ==>
### cproper_interval (Some ?A) None == ?A ~= UNIV
### Not an equation, in theorem:
### cproper_interval_set_dom (Some ?A, Some ?B) ==>
### cproper_interval (Some ?A) (Some ?B) ==
### finite UNIV & (EX C. cless ?A C & cless C ?B)
Found termination order: "{}"
instantiation
  fun :: (type, type) cproper_interval
  cproper_interval_fun == cproper_interval ::
    ('a => 'b) option => ('a => 'b) option => bool
### theory "Draft.Collection_Order"
### 1.183s elapsed time, 1.395s cpu time, 0.077s GC time
Loading theory "Draft.RBT_Mapping2" (required by "Draft.RBT_Set2Templates" via "Draft.RBT_Set2")
### Ambiguous input (line 247 of "$AFP/Containers/RBT_Mapping2.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###             ("_case_syntax"
###               ("_applC" ("_position" lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v1)
###                           ("_position" v2))))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lookup)
###       ("_applC" ("_position" meet)
###         ("_cargs" ("_position" f)
###           ("_cargs"
###             ("_constrain" ("_position" t1)
###               ("_tappl" ("_position_sort" 'a) ("_position_sort" 'b)
###                 ("_type_name" mapping_rbt)))
###             ("_position" t2)))))
###     ("_lambda" ("_position" k)
###       ("_case_syntax"
###         ("_applC" ("_position" lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v1))
###               ("_case_syntax"
###                 ("_applC" ("_position" lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" v2))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v1) ("_position" v2))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.RBT_Mapping2"
### 0.820s elapsed time, 0.922s cpu time, 0.110s GC time
Loading theory "Draft.RBT_Set2" (required by "Draft.RBT_Set2Templates")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Draft.RBT_Set2"
### 0.946s elapsed time, 1.058s cpu time, 0.168s GC time
Loading theory "Draft.RBT_Set2Templates"
val templateLemmas =
   [("RBT_Set2.fold_rev_simps", "RBT_Set2.fold_rev ?f rbt.Empty = id",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_hole 0)),
    ("RBT_Set2.map_of_rev_unit", "map_of (rev ?xs) = map_of ?xs",
     template_equation
      (template_app
        (template_hole 1, template_app (template_hole 0, template_var 0)),
       template_app (template_hole 1, template_var 0))),
    ("RBT_Set2.unfoldr_rbt_keys_generator",
     "list.unfoldr rbt_keys_generator (RBT_Set2.init ?t) =
      RBT_Set2.keys ?t",
     template_equation
      (template_app
        (template_app (template_hole 3, template_hole 2),
         template_app (template_hole 1, template_var 0)),
       template_app (template_hole 0, template_var 0))),
    ("RBT_Set2.set_keys_Mapping_RBT",
     "set (RBT_Set2.keys (Mapping_RBT ?t)) = set (RBT_Impl.keys ?t)",
     template_equation
      (template_app
        (template_hole 3,
         template_app
          (template_hole 2,
           template_app (template_hole 1, template_var 0))),
       template_app
        (template_hole 3, template_app (template_hole 0, template_var 0)))),
    ("RBT_Set2.keys_eq_Nil_iff",
     "(RBT_Set2.keys ?rbt = []) = (?rbt = RBT_Set2.empty)",
     template_bimplication
      (template_equation
        (template_app (template_hole 3, template_var 0), template_hole 2),
       template_equation (template_var 0, template_hole 0))),
    ("RBT_Set2.fold_conv_fold_keys'",
     "RBT_Set2.fold ?f ?t =
      fold ?f (RBT_Impl.keys (mapping_rbt.impl_of ?t))",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1), template_var 0),
       template_app
        (template_app (template_hole 2, template_var 1),
         template_app
          (template_hole 1,
           template_app (template_hole 0, template_var 0))))),
    ("RBT_Set2.fold_conv_fold_keys",
     "RBT_Set2.fold ?f ?rbt ?b = fold ?f (RBT_Set2.keys ?rbt) ?b",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 2, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 1, template_var 2),
           template_app (template_hole 0, template_var 1)),
         template_var 0))),
    ("RBT_Set2.member_lookup",
     "RBT_Set2.member ?t ?x = (RBT_Mapping2.lookup ?t ?x = Some ())",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 4, template_var 1),
              template_var 0)
            )],
       template_equation
        (template_app
          (template_app (template_hole 2, template_var 1), template_var 0),
         template_app (template_hole 1, template_hole 0)))),
    ("RBT_Set2.distinct_keys",
     "ID ccompare ~= None ==> distinct (RBT_Set2.keys ?rbt)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 4, template_hole 3),
              template_hole 2)
            )],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 0))
           ))),
    ("RBT_Set2.finite_member",
     "ID ccompare ~= None ==> finite (Collect (RBT_Set2.member ?t))",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 5, template_hole 4),
              template_hole 3)
            )],
       template_predicate
        (
           template_app
            (template_hole 2,
             template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 0)))
           ))),
    ("RBT_Set2.fold1_conv_fold",
     "fold1 ?f ?rbt =
      fold ?f (tl (RBT_Set2.keys ?rbt)) (hd (RBT_Set2.keys ?rbt))",
     template_equation
      (template_app
        (template_app (template_hole 4, template_var 1), template_var 0),
       template_app
        (template_app
          (template_app (template_hole 3, template_var 1),
           template_app
            (template_hole 2,
             template_app (template_hole 1, template_var 0))),
         template_app
          (template_hole 0,
           template_app (template_hole 1, template_var 0))))),
    ("RBT_Set2.sorted_RBT_Set_keys",
     "ID ccompare = Some ?c ==>
      sorted_wrt (le_of_comp ?c) (RBT_Set2.keys ?rbt)",
     template_implication
      ([template_equation
         (template_app (template_hole 5, template_hole 4),
          template_app (template_hole 3, template_var 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 1)),
             template_app (template_hole 0, template_var 0))
           ))),
    ("RBT_Set2.fold_split_conv_map_fst",
     "fold (%(x, y). ?f x) ?xs = fold ?f (map fst ?xs)",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, t_empty)),
         template_var 0),
       template_app
        (template_app (template_hole 2, template_var 1),
         template_app
          (template_app (template_hole 1, template_hole 0),
           template_var 0)))),
    ("RBT_Set2.foldr_split_conv_map_fst",
     "foldr (%(x, y). ?f x) ?xs = foldr ?f (map fst ?xs)",
     template_equation
      (template_app
        (template_app
          (template_hole 4, template_app (template_hole 3, t_empty)),
         template_var 0),
       template_app
        (template_app (template_hole 2, template_var 1),
         template_app
          (template_app (template_hole 1, template_hole 0),
           template_var 0)))),
    ("RBT_Set2.map_of_filter",
     "map_of (filter (%x. ?P (fst x)) ?xs) = map_of ?xs |` Collect ?P",
     template_equation
      (template_app
        (template_hole 4,
         template_app
          (template_app (template_hole 3, t_empty), template_var 0)),
       template_app
        (template_app
          (template_hole 1, template_app (template_hole 4, template_var 0)),
         template_app (template_hole 0, template_var 1)))),
    ("RBT_Set2.is_empty_empty",
     "ID ccompare ~= None ==> RBT_Set2.is_empty ?t = (?t = RBT_Set2.empty)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 6, template_hole 5),
              template_hole 4)
            )],
       template_implication
        ([template_predicate
           (template_app (template_hole 2, template_var 0))],
         template_equation (template_var 0, template_hole 0)))),
    ("RBT_Set2.is_rbt_impl_of",
     "ID ccompare ~= None ==> ord.is_rbt cless (mapping_rbt.impl_of ?t)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 6, template_hole 5),
              template_hole 4)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_hole 2,
                 template_app
                  (template_hole 1,
                   template_app (template_hole 6, template_hole 5)))),
             template_app (template_hole 0, template_var 0))
           ))),
    ("RBT_Set2.filter_conv_foldr",
     "filter ?P ?xs = foldr (%x xs. if ?P x then x # xs else xs) ?xs []",
     template_equation
      (template_app
        (template_app (template_hole 4, template_var 1), template_var 0),
       template_app
        (template_app
          (template_app (template_hole 3, t_empty), template_var 0),
         template_hole 0))),
    ("RBT_Set2.member_conv_keys",
     "ID ccompare ~= None ==>
      RBT_Set2.member ?t = (%x. x : set (RBT_Set2.keys ?t))",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 7, template_hole 6),
              template_hole 5)
            )],
       template_equation
        (template_app (template_hole 3, template_var 0), t_empty))),
    ("RBT_Set2.member_bulkload",
     "ID ccompare ~= None ==>
      RBT_Set2.member (RBT_Set2.bulkload ?xs) ?x = (?x : set ?xs)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 7, template_hole 6),
              template_hole 5)
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_var 1)),
           template_var 0),
         template_app
          (template_app (template_hole 1, template_var 0),
           template_app (template_hole 0, template_var 1))))),
    ("RBT_Set2.member_empty_empty",
     "ID ccompare ~= None ==>
      (RBT_Set2.member ?t = (%_. False)) = (?t = RBT_Set2.empty)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 8, template_hole 7),
              template_hole 6)
            )],
       template_bimplication
        (template_equation
          (template_app (template_hole 3, template_var 0), t_empty),
         template_equation (template_var 0, template_hole 0)))),
    ("RBT_Set2.map_of_map_Pair_const",
     "map_of (map (%x. (x, ?v)) ?xs) =
      (%x. if x : set ?xs then Some ?v else None)",
     template_equation
      (template_app
        (template_hole 7,
         template_app
          (template_app (template_hole 6, t_empty), template_var 0)),
       t_empty)),
    ("RBT_Set2.set_foldr_Cons",
     "set (foldr (%x xs. if ?P x xs then x # xs else xs) ?as [])
      <= set ?as",
     template_inequation
      (less_equals,
       template_app
        (template_hole 4,
         template_app
          (template_app
            (template_app (template_hole 3, t_empty), template_var 0),
           template_hole 0)),
       template_app (template_hole 4, template_var 0))),
    ("RBT_Set2.member_remove",
     "ID ccompare ~= None ==>
      RBT_Set2.member (RBT_Set2.remove ?x ?t) = (RBT_Set2.member ?t)
      (?x := False)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 7, template_hole 6),
              template_hole 5)
            )],
       template_equation
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 1),
             template_var 0)),
         template_app
          (template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 3, template_var 0)),
             template_var 1),
           template_hole 0)))),
    ("RBT_Set2.member_insert",
     "ID ccompare ~= None ==>
      RBT_Set2.member (RBT_Set2.insert ?x ?t) = (RBT_Set2.member ?t)
      (?x := True)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 8, template_hole 7),
              template_hole 6)
            )],
       template_equation
        (template_app
          (template_hole 4,
           template_app
            (template_app
              (template_app (template_hole 3, template_var 1),
               template_hole 2),
             template_var 0)),
         template_app
          (template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 4, template_var 0)),
             template_var 1),
           template_hole 0)))),
    ("RBT_Set2.map_of_map_Pair_key",
     "map_of (map (%k. (k, ?f k)) ?xs) ?x =
      (if ?x : set ?xs then Some (?f ?x) else None)",
     template_equation
      (template_app
        (template_app
          (template_hole 7,
           template_app
            (template_app (template_hole 6, t_empty), template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 4,
             template_app
              (template_app (template_hole 3, template_var 0),
               template_app (template_hole 2, template_var 1))),
           template_app
            (template_hole 1,
             template_app (template_var 2, template_var 0))),
         template_hole 0))),
    ("RBT_Set2.fold_rev_simps",
     "RBT_Set2.fold_rev ?f (Branch ?c ?l ?k ?v ?r) =
      RBT_Set2.fold_rev ?f ?l o ?f ?k ?v o RBT_Set2.fold_rev ?f ?r",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 5),
         template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 3),
               template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_hole 0,
           template_app
            (template_app
              (template_hole 0,
               template_app
                (template_app (template_hole 2, template_var 5),
                 template_var 3)),
             template_app
              (template_app (template_var 5, template_var 2),
               template_var 1))),
         template_app
          (template_app (template_hole 2, template_var 5),
           template_var 0)))),
    ("RBT_Set2.RBT_lookup_empty",
     "ID ccompare ~= None ==>
      (ord.rbt_lookup cless ?t = Map.empty) = (?t = rbt.Empty)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 10, template_hole 9),
              template_hole 8)
            )],
       template_bimplication
        (template_equation
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_hole 4,
                 template_app
                  (template_hole 3,
                   template_app (template_hole 10, template_hole 9)))),
             template_var 0),
           t_empty),
         template_equation (template_var 0, template_hole 0)))),
    ("RBT_Set2.member_inter_list",
     "ID ccompare ~= None ==>
      RBT_Set2.member (inter_list ?t ?xs) =
      (%x. RBT_Set2.member ?t x & x : set ?xs)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 8, template_hole 7),
              template_hole 6)
            )],
       template_equation
        (template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, template_var 1),
             template_var 0)),
         t_empty))),
    ("RBT_Set2.member_minus",
     "ID ccompare ~= None ==>
      RBT_Set2.member (RBT_Set2.minus ?t1.0 ?t2.0) =
      (%x. RBT_Set2.member ?t1.0 x & ~ RBT_Set2.member ?t2.0 x)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 6, template_hole 5),
              template_hole 4)
            )],
       template_equation
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 1),
             template_var 0)),
         t_empty))),
    ("RBT_Set2.member_filter",
     "ID ccompare ~= None ==>
      RBT_Set2.member (RBT_Set2.filter ?P ?t) =
      (%x. RBT_Set2.member ?t x & ?P x)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 8, template_hole 7),
              template_hole 6)
            )],
       template_equation
        (template_app
          (template_hole 4,
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 2, template_var 1),
                 template_hole 1)),
             template_var 0)),
         t_empty))),
    ("RBT_Set2.member_Id_on",
     "ID ccompare ~= None ==>
      RBT_Set2.member (RBT_Set2.Id_on ?t) =
      (%(k, k'). k = k' & RBT_Set2.member ?t k)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 9, template_hole 8),
              template_hole 7)
            )],
       template_equation
        (template_app
          (template_hole 5, template_app (template_hole 4, template_var 0)),
         template_app (template_hole 3, t_empty)))),
    ("RBT_Set2.distinct_fst_foldr_Cons",
     "distinct (map ?f ?as) ==>
      distinct
       (map ?f (foldr (%x xs. if ?P x xs then x # xs else xs) ?as []))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 5,
              template_app
               (template_app (template_hole 4, template_var 2),
                template_var 1))
            )],
       template_predicate
        (
           template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 4, template_var 2),
               template_app
                (template_app
                  (template_app (template_hole 3, t_empty), template_var 1),
                 template_hole 0)))
           ))),
    ("RBT_Set2.all_conv_all_member",
     "ID ccompare ~= None ==>
      RBT_Set2.all ?P ?t = (ALL x. RBT_Set2.member ?t x --> ?P x)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 7, template_hole 6),
              template_hole 5)
            )],
       template_equation
        (template_app
          (template_app (template_hole 3, t_empty), template_var 0),
         template_app (template_hole 2, t_empty)))),
    ("RBT_Set2.ex_conv_ex_member",
     "ID ccompare ~= None ==>
      RBT_Set2.ex ?P ?t = (EX x. RBT_Set2.member ?t x & ?P x)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 7, template_hole 6),
              template_hole 5)
            )],
       template_equation
        (template_app
          (template_app (template_hole 3, t_empty), template_var 0),
         template_app (template_hole 2, t_empty)))),
    ("RBT_Set2.member_impl_of",
     "ID ccompare ~= None ==>
      (ord.rbt_lookup cless (mapping_rbt.impl_of ?t) ?x = Some ()) =
      RBT_Set2.member ?t ?x",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 11, template_hole 10),
              template_hole 9)
            )],
       template_equation
        (template_app
          (template_app
            (template_hole 7,
             template_app
              (template_app
                (template_app
                  (template_hole 6,
                   template_app
                    (template_hole 5,
                     template_app
                      (template_hole 4,
                       template_app (template_hole 11, template_hole 10)))),
                 template_app (template_hole 3, template_var 1)),
               template_var 0)),
           template_app (template_hole 2, template_hole 1)),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("RBT_Set2.neq_Empty_conv",
     "(?t ~= rbt.Empty) = (EX c l k v r. ?t = Branch c l k v r)",
     template_equation
      (template_app
        (template_hole 7,
         template_app
          (template_app (template_hole 6, template_var 0),
           template_hole 5)),
       template_app (template_hole 4, t_empty))),
    ("RBT_Set2.member_union",
     "ID ccompare ~= None ==>
      RBT_Set2.member (RBT_Set2.union ?t1.0 ?t2.0) =
      (%x. RBT_Set2.member ?t1.0 x | RBT_Set2.member ?t2.0 x)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 7, template_hole 6),
              template_hole 5)
            )],
       template_equation
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_app (template_hole 2, t_empty), template_var 1),
             template_var 0)),
         t_empty))),
    ("RBT_Set2.member_inter",
     "ID ccompare ~= None ==>
      RBT_Set2.member (RBT_Set2.inter ?t1.0 ?t2.0) =
      (%x. RBT_Set2.member ?t1.0 x & RBT_Set2.member ?t2.0 x)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 7, template_hole 6),
              template_hole 5)
            )],
       template_equation
        (template_app
          (template_hole 3,
           template_app
            (template_app
              (template_app (template_hole 2, t_empty), template_var 1),
             template_var 0)),
         t_empty))),
    ("RBT_Set2.member_fold_insert",
     "ID ccompare ~= None ==>
      RBT_Set2.member (fold RBT_Set2.insert ?xs ?t) =
      (%x. RBT_Set2.member ?t x | x : set ?xs)",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 10, template_hole 9),
              template_hole 8)
            )],
       template_equation
        (template_app
          (template_hole 6,
           template_app
            (template_app
              (template_app (template_hole 5, t_empty), template_var 1),
             template_var 0)),
         t_empty))),
    ("RBT_Set2.member_product",
     "[| ID ccompare ~= None; ID ccompare ~= None |]
      ==> RBT_Set2.member (RBT_Set2.product ?rbt1.0 ?rbt2.0) =
          (%ab. ab : Collect (RBT_Set2.member ?rbt1.0) \<times>
                     Collect (RBT_Set2.member ?rbt2.0))",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 15, template_hole 14),
              template_hole 13)
            ),
        template_negation
         (
            template_equation
             (template_app (template_hole 11, template_hole 10),
              template_hole 9)
            )],
       template_equation
        (template_app
          (template_hole 7,
           template_app
            (template_app (template_hole 6, template_var 1),
             template_var 0)),
         t_empty))),
    ("RBT_Set2.member_RBT",
     "[| ID ccompare ~= None; ord.is_rbt cless ?t |]
      ==> RBT_Set2.member (Mapping_RBT ?t) ?x =
          (ord.rbt_lookup cless ?t ?x = Some ())",
     template_implication
      ([template_negation
         (
            template_equation
             (template_app (template_hole 12, template_hole 11),
              template_hole 10)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 9,
                template_app
                 (template_hole 8,
                  template_app
                   (template_hole 7,
                    template_app (template_hole 12, template_hole 11)))),
              template_var 1)
            )],
       template_implication
        ([template_predicate
           (
              template_app
               (template_app
                 (template_hole 5,
                  template_app (template_hole 4, template_var 1)),
                template_var 0)
              )],
         template_equation
          (template_app
            (template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_hole 8,
                   template_app
                    (template_hole 7,
                     template_app (template_hole 12, template_hole 11)))),
               template_var 1),
             template_var 0),
           template_app (template_hole 1, template_hole 0)))))]:
   (string * thm * template) list
### theory "Draft.RBT_Set2Templates"
### 0.483s elapsed time, 0.702s cpu time, 0.087s GC time
val it = (): unit
