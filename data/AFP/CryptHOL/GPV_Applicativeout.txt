Loading theory "Draft.Partial_Function_Set" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.GPV_Applicative" via "Draft.Generative_Probabilistic_Value" via "Draft.Resumption")
Loading theory "Draft.Set_Applicative" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.GPV_Applicative" via "Draft.SPMF_Applicative")
Loading theory "Draft.Templates" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.ExtrEqs")
Loading theory "HOL-Library.BigO" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.ExtrEqs")
### theory "Draft.Set_Applicative"
### 0.052s elapsed time, 0.243s cpu time, 0.000s GC time
Loading theory "Draft.SPMF_Applicative" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.GPV_Applicative")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.081s elapsed time, 0.360s cpu time, 0.000s GC time
Loading theory "Draft.Misc_CryptHOL" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.GPV_Applicative" via "Draft.Generative_Probabilistic_Value" via "Draft.Resumption")
### theory "Draft.Partial_Function_Set"
### 0.302s elapsed time, 1.200s cpu time, 0.042s GC time
### theory "Draft.SPMF_Applicative"
### 0.405s elapsed time, 1.452s cpu time, 0.097s GC time
### theory "HOL-Library.BigO"
### 0.685s elapsed time, 2.151s cpu time, 0.167s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.GPV_ApplicativeTemplates")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.491s elapsed time, 1.006s cpu time, 0.076s GC time
Proofs for inductive predicate(s) "Imagep"
  Proving monotonicity ...
specification
  relcompp_witness1: (?A OO ?B) (fst ?xy) (snd ?xy) ==> ?A (fst ?xy) (relcompp_witness ?A ?B ?xy)
  relcompp_witness2: (?A OO ?B) (fst ?xy) (snd ?xy) ==> ?B (relcompp_witness ?A ?B ?xy) (snd ?xy)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
consts
  assert_option :: "bool => unit option"
consts
  sup_option :: "'a option => 'a option => 'a option"
consts
  enforce_option :: "('a => bool) => 'a option => 'a option"
### Ignoring duplicate rewrite rule:
### real ?n1 <= 1 == ?n1 <= 1
Proofs for inductive predicate(s) "finite_chains"
  Proving monotonicity ...
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
Proofs for inductive predicate(s) "nlistsp"
  Proving monotonicity ...
consts
  sprefix :: "'a list => 'a stream => bool"
locale monad_fail_hom
  fixes return1 :: "'a => 'm1"
    and bind1 :: "'m1 => ('a => 'm1) => 'm1"
    and fail1 :: "'m1"
    and return2 :: "'a => 'm2"
    and bind2 :: "'m2 => ('a => 'm2) => 'm2"
    and fail2 :: "'m2"
    and h :: "'m1 => 'm2"
  assumes "monad_fail_hom return1 bind1 fail1 return2 bind2 fail2 h"
specification
  set_rel_witness_pmf': rel_pmf ?A (fst ?xy) (snd ?xy) ==>
set_pmf (rel_witness_pmf ?A ?xy) <= {(a, b). ?A a b}
  map1_rel_witness_pmf': rel_pmf ?A (fst ?xy) (snd ?xy) ==>
map_pmf fst (rel_witness_pmf ?A ?xy) = fst ?xy
  map2_rel_witness_pmf': rel_pmf ?A (fst ?xy) (snd ?xy) ==>
map_pmf snd (rel_witness_pmf ?A ?xy) = snd ?xy
locale option_to_spmf
locale option_le_spmf
### theory "Draft.Misc_CryptHOL"
### 4.793s elapsed time, 6.869s cpu time, 0.855s GC time
Loading theory "Draft.Generat" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.GPV_Applicative" via "Draft.Generative_Probabilistic_Value")
Loading theory "Draft.Resumption" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.GPV_Applicative" via "Draft.Generative_Probabilistic_Value")
Found termination order: "{}"
### Missing patterns in function definition:
### !!vb vc v. rel_witness_generat (IO vb vc, Pure v) = undefined
### !!va vb vc. rel_witness_generat (Pure va, IO vb vc) = undefined
consts
  bind_resumption ::
    "('a, 'out, 'in) Resumption.resumption
     => ('a => ('b, 'out, 'in) Resumption.resumption)
        => ('b, 'out, 'in) Resumption.resumption"
Found termination order: "{}"
### theory "Draft.Generat"
### 1.518s elapsed time, 3.407s cpu time, 0.918s GC time
consts
  ensure :: "bool => (unit, 'out, 'in) Resumption.resumption"
Proofs for coinductive predicate(s) "resumption_ord"
  Proving monotonicity ...
consts
  resumption_lub ::
    "('a, 'out, 'in) Resumption.resumption set
     => ('a, 'out, 'in) Resumption.resumption"
### Cannot skip proof of schematic goal statement
### theory "Draft.Resumption"
### 1.846s elapsed time, 3.762s cpu time, 0.981s GC time
Loading theory "Draft.Generative_Probabilistic_Value" (required by "Draft.GPV_ApplicativeTemplates" via "Draft.GPV_Applicative")
"('a, 'out, 'in) rpv"
consts
  map_gpv' ::
    "('a => 'b)
     => ('out => 'out')
        => ('ret' => 'ret)
           => ('a, 'out, 'ret) gpv => ('b, 'out', 'ret') gpv"
Proofs for coinductive predicate(s) "rel_gpv''"
  Proving monotonicity ...
consts
  Done :: "'a => ('a, 'out, 'in) gpv"
consts
  Pause :: "'out => ('a, 'out, 'in) rpv => ('a, 'out, 'in) gpv"
consts
  lift_spmf :: "'a spmf => ('a, 'out, 'in) gpv"
consts
  bind_gpv ::
    "('a, 'out, 'in) gpv
     => ('a => ('b, 'out, 'in) gpv) => ('b, 'out, 'in) gpv"
locale spmf_to_gpv
locale option_to_gpv
locale option_le_gpv
consts
  lift_resumption ::
    "('a, 'out, 'in) Resumption.resumption => ('a, 'out, 'in) gpv"
### Ambiguous input (line 1428 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))
###     ("_applC" ("_position" map_spmf)
###       ("_cargs"
###         ("_applC" ("_position" map_generat)
###           ("_cargs" ("_position" id)
###             ("_cargs" ("_position" id)
###               ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                 ("_case_syntax"
###                   ("_applC" ("_position" c) ("_position" input))
###                   ("_case2"
###                     ("_case1" ("_applC" ("_position" Inl) ("_position" gpv))
###                       ("_applC" ("_position" try_gpv)
###                         ("_cargs" ("_position" gpv) ("_position" gpv'))))
###                     ("_case1"
###                       ("_applC" ("_position" Inr) ("_position" gpv'))
###                       ("_position" gpv'))))))))
###         ("_applC" ("_position" try_spmf)
###           ("_cargs"
###             ("_applC" ("_position" map_spmf)
###               ("_cargs"
###                 ("_applC" ("_position" map_generat)
###                   ("_cargs" ("_position" id)
###                     ("_cargs" ("_position" id)
###                       ("_applC" ("_position" map_fun)
###                         ("_cargs" ("_position" id) ("_position" Inl))))))
###                 ("_applC" ("_position" the_gpv) ("_position" gpv))))
###             ("_applC" ("_position" map_spmf)
###               ("_cargs"
###                 ("_applC" ("_position" map_generat)
###                   ("_cargs" ("_position" id)
###                     ("_cargs" ("_position" id)
###                       ("_applC" ("_position" map_fun)
###                         ("_cargs" ("_position" id) ("_position" Inr))))))
###                 ("_applC" ("_position" the_gpv) ("_position" gpv'))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^fixed>try_gpv" ("_position" gpv) ("_position" gpv')))
###     ("_applC" ("_position" map_spmf)
###       ("_cargs"
###         ("_applC" ("_position" map_generat)
###           ("_cargs" ("_position" id)
###             ("_cargs" ("_position" id)
###               ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                 ("_case_syntax"
###                   ("_applC" ("_position" c) ("_position" input))
###                   ("_case2"
###                     ("_case1" ("_applC" ("_position" Inl) ("_position" gpv))
###                       ("_applC" ("_position" try_gpv)
###                         ("_cargs" ("_position" gpv) ("_position" gpv'))))
###                     ("_case1"
###                       ("_applC" ("_position" Inr) ("_position" gpv'))
###                       ("_position" gpv'))))))))
###         ("_applC" ("_position" try_spmf)
###           ("_cargs"
###             ("_applC" ("_position" map_spmf)
###               ("_cargs"
###                 ("_applC" ("_position" map_generat)
###                   ("_cargs" ("_position" id)
###                     ("_cargs" ("_position" id)
###                       ("_applC" ("_position" map_fun)
###                         ("_cargs" ("_position" id) ("_position" Inl))))))
###                 ("_applC" ("_position" the_gpv) ("_position" gpv))))
###             ("_applC" ("_position" map_spmf)
###               ("_cargs"
###                 ("_applC" ("_position" map_generat)
###                   ("_cargs" ("_position" id)
###                     ("_cargs" ("_position" id)
###                       ("_applC" ("_position" map_fun)
###                         ("_cargs" ("_position" id) ("_position" Inr))))))
###                 ("_applC" ("_position" the_gpv) ("_position" gpv'))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  try_gpv ::
    "('a, 'call, 'ret) gpv
     => ('a, 'call, 'ret) gpv => ('a, 'call, 'ret) gpv"
### Ambiguous input (line 1434 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" id)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                   ("\<^const>SPMF.try_spmf"
###                     ("_applC" ("_position" c) ("_position" input))
###                     ("_position" gpv'))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" the_gpv) ("_position" gpv')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###         ("_position" gpv')))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" id)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                   ("\<^const>SPMF.try_spmf"
###                     ("_applC" ("_position" c) ("_position" input))
###                     ("_position" gpv'))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" the_gpv) ("_position" gpv')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" id)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                   ("\<^const>SPMF.try_spmf"
###                     ("_applC" ("_position" c) ("_position" input))
###                     ("_position" gpv'))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" the_gpv) ("_position" gpv')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###         ("_position" gpv')))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" id)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                   ("\<^const>SPMF.try_spmf"
###                     ("_applC" ("_position" c) ("_position" input))
###                     ("_position" gpv'))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" the_gpv) ("_position" gpv')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" id)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                   ("\<^const>Generative_Probabilistic_Value.try_gpv"
###                     ("_applC" ("_position" c) ("_position" input))
###                     ("_position" gpv'))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" the_gpv) ("_position" gpv')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###         ("_position" gpv')))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" id)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                   ("\<^const>Generative_Probabilistic_Value.try_gpv"
###                     ("_applC" ("_position" c) ("_position" input))
###                     ("_position" gpv'))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" the_gpv) ("_position" gpv')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" id)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                   ("\<^const>Generative_Probabilistic_Value.try_gpv"
###                     ("_applC" ("_position" c) ("_position" input))
###                     ("_position" gpv'))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" the_gpv) ("_position" gpv')))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###         ("_position" gpv')))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" id)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" c) ("_position" input))
###                   ("\<^const>Generative_Probabilistic_Value.try_gpv"
###                     ("_applC" ("_position" c) ("_position" input))
###                     ("_position" gpv'))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" the_gpv) ("_position" gpv')))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1438 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" Done) ("_position" x)) ("_position" gpv'))
###     ("_applC" ("_position" Done) ("_position" x))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>SPMF.try_spmf" ("_applC" ("_position" Done) ("_position" x))
###       ("_position" gpv'))
###     ("_applC" ("_position" Done) ("_position" x))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1441 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" Fail)
###       ("_position" gpv'))
###     ("_position" gpv')))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>SPMF.try_spmf" ("_position" Fail) ("_position" gpv'))
###     ("_position" gpv')))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1444 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" Pause)
###         ("_cargs" ("_position" out) ("_position" c)))
###       ("_position" gpv'))
###     ("_applC" ("_position" Pause)
###       ("_cargs" ("_position" out)
###         ("_lambda" ("_position" input)
###           ("\<^const>SPMF.try_spmf"
###             ("_applC" ("_position" c) ("_position" input))
###             ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" Pause)
###         ("_cargs" ("_position" out) ("_position" c)))
###       ("_position" gpv'))
###     ("_applC" ("_position" Pause)
###       ("_cargs" ("_position" out)
###         ("_lambda" ("_position" input)
###           ("\<^const>SPMF.try_spmf"
###             ("_applC" ("_position" c) ("_position" input))
###             ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" Pause)
###         ("_cargs" ("_position" out) ("_position" c)))
###       ("_position" gpv'))
###     ("_applC" ("_position" Pause)
###       ("_cargs" ("_position" out)
###         ("_lambda" ("_position" input)
###           ("\<^const>Generative_Probabilistic_Value.try_gpv"
###             ("_applC" ("_position" c) ("_position" input))
###             ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" Pause)
###         ("_cargs" ("_position" out) ("_position" c)))
###       ("_position" gpv'))
###     ("_applC" ("_position" Pause)
###       ("_cargs" ("_position" out)
###         ("_lambda" ("_position" input)
###           ("\<^const>Generative_Probabilistic_Value.try_gpv"
###             ("_applC" ("_position" c) ("_position" input))
###             ("_position" gpv')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1447 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###       ("_position" Fail))
###     ("_position" gpv)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" Fail))
###     ("_position" gpv)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1451 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lift_spmf)
###       ("\<^const>SPMF.try_spmf" ("_position" p) ("_position" q)))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" lift_spmf) ("_position" p))
###       ("_applC" ("_position" lift_spmf) ("_position" q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lift_spmf)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" p)
###         ("_position" q)))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" lift_spmf) ("_position" p))
###       ("_applC" ("_position" lift_spmf) ("_position" q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lift_spmf)
###       ("\<^const>SPMF.try_spmf" ("_position" p) ("_position" q)))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" lift_spmf) ("_position" p))
###       ("_applC" ("_position" lift_spmf) ("_position" q)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" lift_spmf)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" p)
###         ("_position" q)))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" lift_spmf) ("_position" p))
###       ("_applC" ("_position" lift_spmf) ("_position" q)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1454 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" assert_gpv) ("_position" b))
###       ("_position" gpv'))
###     ("\<^const>HOL.If" ("_position" b)
###       ("_applC" ("_position" Done) ("\<^const>Product_Type.Unity"))
###       ("_position" gpv'))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" assert_gpv) ("_position" b))
###       ("_position" gpv'))
###     ("\<^const>HOL.If" ("_position" b)
###       ("_applC" ("_position" Done) ("\<^const>Product_Type.Unity"))
###       ("_position" gpv'))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1469 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" map_gpv)
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g) ("_position" gpv))))
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g) ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" map_gpv)
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("\<^const>Generative_Probabilistic_Value.try_gpv"
###             ("_position" gpv) ("_position" gpv')))))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g) ("_position" gpv))))
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g) ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" map_gpv)
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g) ("_position" gpv))))
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g) ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" map_gpv)
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("\<^const>Generative_Probabilistic_Value.try_gpv"
###             ("_position" gpv) ("_position" gpv')))))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g) ("_position" gpv))))
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g) ("_position" gpv')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1472 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" map_gpv')
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("_cargs" ("_position" h)
###             ("\<^const>SPMF.try_spmf" ("_position" gpv)
###               ("_position" gpv'))))))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_gpv')
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g)
###             ("_cargs" ("_position" h) ("_position" gpv)))))
###       ("_applC" ("_position" map_gpv')
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g)
###             ("_cargs" ("_position" h) ("_position" gpv'))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" map_gpv')
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("_cargs" ("_position" h)
###             ("\<^const>Generative_Probabilistic_Value.try_gpv"
###               ("_position" gpv) ("_position" gpv'))))))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_gpv')
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g)
###             ("_cargs" ("_position" h) ("_position" gpv)))))
###       ("_applC" ("_position" map_gpv')
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g)
###             ("_cargs" ("_position" h) ("_position" gpv'))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" map_gpv')
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("_cargs" ("_position" h)
###             ("\<^const>SPMF.try_spmf" ("_position" gpv)
###               ("_position" gpv'))))))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_gpv')
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g)
###             ("_cargs" ("_position" h) ("_position" gpv)))))
###       ("_applC" ("_position" map_gpv')
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g)
###             ("_cargs" ("_position" h) ("_position" gpv'))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" map_gpv')
###       ("_cargs" ("_position" f)
###         ("_cargs" ("_position" g)
###           ("_cargs" ("_position" h)
###             ("\<^const>Generative_Probabilistic_Value.try_gpv"
###               ("_position" gpv) ("_position" gpv'))))))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_gpv')
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g)
###             ("_cargs" ("_position" h) ("_position" gpv)))))
###       ("_applC" ("_position" map_gpv')
###         ("_cargs" ("_position" f)
###           ("_cargs" ("_position" g)
###             ("_cargs" ("_position" h) ("_position" gpv'))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1477 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("\<^const>Monad_Syntax.bind"
###         ("_applC" ("_position" assert_gpv) ("_position" b)) ("_position" f))
###       ("_position" gpv))
###     ("\<^const>HOL.If" ("_position" b)
###       ("\<^const>SPMF.try_spmf"
###         ("_applC" ("_position" f) ("\<^const>Product_Type.Unity"))
###         ("_position" gpv))
###       ("_position" gpv))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>SPMF.try_spmf"
###       ("\<^const>Monad_Syntax.bind"
###         ("_applC" ("_position" assert_gpv) ("_position" b)) ("_position" f))
###       ("_position" gpv))
###     ("\<^const>HOL.If" ("_position" b)
###       ("\<^const>SPMF.try_spmf"
###         ("_applC" ("_position" f) ("\<^const>Product_Type.Unity"))
###         ("_position" gpv))
###       ("_position" gpv))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("\<^const>Monad_Syntax.bind"
###         ("_applC" ("_position" assert_gpv) ("_position" b)) ("_position" f))
###       ("_position" gpv))
###     ("\<^const>HOL.If" ("_position" b)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv"
###         ("_applC" ("_position" f) ("\<^const>Product_Type.Unity"))
###         ("_position" gpv))
###       ("_position" gpv))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>SPMF.try_spmf"
###       ("\<^const>Monad_Syntax.bind"
###         ("_applC" ("_position" assert_gpv) ("_position" b)) ("_position" f))
###       ("_position" gpv))
###     ("\<^const>HOL.If" ("_position" b)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv"
###         ("_applC" ("_position" f) ("\<^const>Product_Type.Unity"))
###         ("_position" gpv))
###       ("_position" gpv))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for coinductive predicate(s) "ord_gpv"
  Proving monotonicity ...
Proofs for inductive predicate(s) "interaction_bounded_by"
  Proving monotonicity ...
instantiation
  \<I> :: (type, type) order
  less_eq_\<I> == less_eq :: ('a, 'b) \<I> => ('a, 'b) \<I> => bool
  less_\<I> == less :: ('a, 'b) \<I> => ('a, 'b) \<I> => bool
instantiation
  \<I> :: (type, type) order_bot
  bot_\<I> == bot :: ('a, 'b) \<I>
Proofs for inductive predicate(s) "resultsp_gpv"
  Proving monotonicity ...
Proofs for inductive predicate(s) "outsp_gpv"
  Proving monotonicity ...
Proofs for inductive predicate(s) "pred_gpv'"
  Proving monotonicity ...
Proofs for coinductive predicate(s) "WT_gpv"
  Proving monotonicity ...
Proofs for inductive predicate(s) "sub_gpvsp"
  Proving monotonicity ...
### Ambiguous input (line 3300 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" results_gpv)
###       ("_cargs" ("_position" \<I>)
###         ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv'))))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" results_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv)))
###       ("\<^const>HOL.If"
###         ("_applC" ("_position" colossless_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv)))
###         ("\<^const>Set.empty")
###         ("_applC" ("_position" results_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" results_gpv)
###       ("_cargs" ("_position" \<I>)
###         ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###           ("_position" gpv'))))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" results_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv)))
###       ("\<^const>HOL.If"
###         ("_applC" ("_position" colossless_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv)))
###         ("\<^const>Set.empty")
###         ("_applC" ("_position" results_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 3348 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" results'_gpv)
###       ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" results'_gpv) ("_position" gpv))
###       ("\<^const>HOL.If"
###         ("_applC" ("_position" colossless_gpv)
###           ("_cargs" ("_position" \<I>_full) ("_position" gpv)))
###         ("\<^const>Set.empty")
###         ("_applC" ("_position" results'_gpv) ("_position" gpv'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" results'_gpv)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###         ("_position" gpv')))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" results'_gpv) ("_position" gpv))
###       ("\<^const>HOL.If"
###         ("_applC" ("_position" colossless_gpv)
###           ("_cargs" ("_position" \<I>_full) ("_position" gpv)))
###         ("\<^const>Set.empty")
###         ("_applC" ("_position" results'_gpv) ("_position" gpv'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 3353 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" outs'_gpv)
###       ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv')))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" outs'_gpv) ("_position" gpv))
###       ("\<^const>HOL.If"
###         ("_applC" ("_position" colossless_gpv)
###           ("_cargs" ("_position" \<I>_full) ("_position" gpv)))
###         ("\<^const>Set.empty")
###         ("_applC" ("_position" outs'_gpv) ("_position" gpv'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" outs'_gpv)
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###         ("_position" gpv')))
###     ("\<^const>Set.union"
###       ("_applC" ("_position" outs'_gpv) ("_position" gpv))
###       ("\<^const>HOL.If"
###         ("_applC" ("_position" colossless_gpv)
###           ("_cargs" ("_position" \<I>_full) ("_position" gpv)))
###         ("\<^const>Set.empty")
###         ("_applC" ("_position" outs'_gpv) ("_position" gpv'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 3476 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" gen_lossless_gpv)
###       ("_cargs" ("_position" b)
###         ("_cargs" ("_position" \<I>_full) ("_position" gpv)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv'))
###       ("_position" gpv))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" gen_lossless_gpv)
###       ("_cargs" ("_position" b)
###         ("_cargs" ("_position" \<I>_full) ("_position" gpv)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###         ("_position" gpv'))
###       ("_position" gpv))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 3490 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" gen_lossless_gpv)
###       ("_cargs" ("_position" b)
###         ("_cargs" ("_position" \<I>_full) ("_position" gpv)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Generative_Probabilistic_Value.try_gpv"
###         ("_applC" ("_position" bind_gpv)
###           ("_cargs" ("_position" gpv) ("_position" f)))
###         ("_position" gpv'))
###       ("_applC" ("_position" bind_gpv)
###         ("_cargs" ("_position" gpv)
###           ("_lambda" ("_position" x)
###             ("\<^const>SPMF.try_spmf"
###               ("_applC" ("_position" f) ("_position" x))
###               ("_position" gpv'))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" gen_lossless_gpv)
###       ("_cargs" ("_position" b)
###         ("_cargs" ("_position" \<I>_full) ("_position" gpv)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>SPMF.try_spmf"
###         ("_applC" ("_position" bind_gpv)
###           ("_cargs" ("_position" gpv) ("_position" f)))
###         ("_position" gpv'))
###       ("_applC" ("_position" bind_gpv)
###         ("_cargs" ("_position" gpv)
###           ("_lambda" ("_position" x)
###             ("\<^const>SPMF.try_spmf"
###               ("_applC" ("_position" f) ("_position" x))
###               ("_position" gpv'))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" gen_lossless_gpv)
###       ("_cargs" ("_position" b)
###         ("_cargs" ("_position" \<I>_full) ("_position" gpv)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Generative_Probabilistic_Value.try_gpv"
###         ("_applC" ("_position" bind_gpv)
###           ("_cargs" ("_position" gpv) ("_position" f)))
###         ("_position" gpv'))
###       ("_applC" ("_position" bind_gpv)
###         ("_cargs" ("_position" gpv)
###           ("_lambda" ("_position" x)
###             ("\<^const>Generative_Probabilistic_Value.try_gpv"
###               ("_applC" ("_position" f) ("_position" x))
###               ("_position" gpv'))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" gen_lossless_gpv)
###       ("_cargs" ("_position" b)
###         ("_cargs" ("_position" \<I>_full) ("_position" gpv)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>SPMF.try_spmf"
###         ("_applC" ("_position" bind_gpv)
###           ("_cargs" ("_position" gpv) ("_position" f)))
###         ("_position" gpv'))
###       ("_applC" ("_position" bind_gpv)
###         ("_cargs" ("_position" gpv)
###           ("_lambda" ("_position" x)
###             ("\<^const>Generative_Probabilistic_Value.try_gpv"
###               ("_applC" ("_position" f) ("_position" x))
###               ("_position" gpv'))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  mk_lossless_gpv :: "('a, 'b, 'c) gpv => ('a, 'b, 'c) gpv"
### Ambiguous input (line 3541 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" catch_gpv) ("_position" gpv))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" Some)
###           ("_cargs" ("_position" id) ("_position" gpv))))
###       ("_applC" ("_position" Done) ("_position" None)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_applC" ("_position" catch_gpv) ("_position" gpv))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_gpv)
###         ("_cargs" ("_position" Some)
###           ("_cargs" ("_position" id) ("_position" gpv))))
###       ("_applC" ("_position" Done) ("_position" None)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 3559 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("_applC" ("_position" catch_gpv) ("_position" gpv)))
###     ("\<^const>Generative_Probabilistic_Value.try_gpv"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" Some)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" rpv) ("_position" input))
###                   ("_applC" ("_position" catch_gpv)
###                     ("_applC" ("_position" rpv) ("_position" input)))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" return_spmf)
###         ("_applC" ("_position" Pure) ("_position" None))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" the_gpv)
###       ("_applC" ("_position" catch_gpv) ("_position" gpv)))
###     ("\<^const>SPMF.try_spmf"
###       ("_applC" ("_position" map_spmf)
###         ("_cargs"
###           ("_applC" ("_position" map_generat)
###             ("_cargs" ("_position" Some)
###               ("_cargs" ("_position" id)
###                 ("_lambda" ("_pttrns" ("_position" rpv) ("_position" input))
###                   ("_applC" ("_position" catch_gpv)
###                     ("_applC" ("_position" rpv) ("_position" input)))))))
###           ("_applC" ("_position" the_gpv) ("_position" gpv))))
###       ("_applC" ("_position" return_spmf)
###         ("_applC" ("_position" Pure) ("_position" None))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  inline_aux ::
    "('a, 'call, 'ret) gpv * 's +
     ('a, 'call, 'ret) rpv * ('ret * 's, 'call', 'ret') gpv
     => ('a * 's, 'call', 'ret') gpv"
locale raw_converter_invariant
  fixes \<I> :: "('call, 'ret) \<I>"
    and \<I>' :: "('call', 'ret') \<I>"
    and callee :: "'s => 'call => ('ret * 's, 'call', 'ret') gpv"
    and I :: "'s => bool"
  assumes "raw_converter_invariant \<I> \<I>' callee I"
locale raw_converter_invariant
  fixes \<I> :: "('call, 'ret) \<I>"
    and \<I>' :: "('call', 'ret') \<I>"
    and callee :: "'s => 'call => ('ret * 's, 'call', 'ret') gpv"
    and I :: "'s => bool"
  assumes "raw_converter_invariant \<I> \<I>' callee I"
Proofs for inductive predicate(s) "WT_callee"
  Proving monotonicity ...
locale callee_invariant_on_base
  fixes callee :: "'s => 'a => ('b * 's) spmf"
    and I :: "'s => bool"
    and \<I> :: "('a, 'b) \<I>"
locale callee_invariant_on
  fixes callee :: "'s => 'a => ('b * 's) spmf"
    and I :: "'s => bool"
    and \<I> :: "('a, 'b) \<I>"
  assumes "callee_invariant_on callee I \<I>"
consts
  restrict_gpv :: "('a, 'out, 'in) gpv => ('a, 'out, 'in) gpv"
consts
  enforce_\<I>_gpv ::
    "('out, 'in) \<I> => ('a, 'out, 'in) gpv => ('a, 'out, 'in) gpv"
Proofs for inductive predicate(s) "finite_gpv"
  Proving monotonicity ...
### Ambiguous input (line 5702 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("_applC" ("_position" finite_gpv)
###       ("_cargs" ("_position" \<I>)
###         ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv'))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" finite_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv)))
###       ("\<^const>HOL.disj"
###         ("_applC" ("_position" colossless_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv)))
###         ("_applC" ("_position" finite_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("_applC" ("_position" finite_gpv)
###       ("_cargs" ("_position" \<I>)
###         ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###           ("_position" gpv'))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" finite_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv)))
###       ("\<^const>HOL.disj"
###         ("_applC" ("_position" colossless_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv)))
###         ("_applC" ("_position" finite_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 5781 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("_applC" ("_position" colossless_gpv)
###       ("_cargs" ("_position" \<I>)
###         ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv'))))
###     ("\<^const>HOL.disj"
###       ("_applC" ("_position" colossless_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv)))
###       ("_applC" ("_position" colossless_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv'))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("_applC" ("_position" colossless_gpv)
###       ("_cargs" ("_position" \<I>)
###         ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###           ("_position" gpv'))))
###     ("\<^const>HOL.disj"
###       ("_applC" ("_position" colossless_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv)))
###       ("_applC" ("_position" colossless_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv'))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 5828 of "$AFP/CryptHOL/Generative_Probabilistic_Value.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("_applC" ("_position" lossless_gpv)
###       ("_cargs" ("_position" \<I>)
###         ("\<^const>SPMF.try_spmf" ("_position" gpv) ("_position" gpv'))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" finite_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv)))
###       ("\<^const>HOL.disj"
###         ("_applC" ("_position" lossless_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv)))
###         ("_applC" ("_position" lossless_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv')))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.iff"
###     ("_applC" ("_position" lossless_gpv)
###       ("_cargs" ("_position" \<I>)
###         ("\<^const>Generative_Probabilistic_Value.try_gpv" ("_position" gpv)
###           ("_position" gpv'))))
###     ("\<^const>HOL.conj"
###       ("_applC" ("_position" finite_gpv)
###         ("_cargs" ("_position" \<I>) ("_position" gpv)))
###       ("\<^const>HOL.disj"
###         ("_applC" ("_position" lossless_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv)))
###         ("_applC" ("_position" lossless_gpv)
###           ("_cargs" ("_position" \<I>) ("_position" gpv')))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale callee_invariant_on
  fixes callee :: "'s => 'a => ('b * 's) spmf"
    and I :: "'s => bool"
    and \<I> :: "('a, 'b) \<I>"
  assumes "callee_invariant_on callee I \<I>"
### theory "Draft.Generative_Probabilistic_Value"
### 7.268s elapsed time, 8.233s cpu time, 1.419s GC time
Loading theory "Draft.GPV_Applicative" (required by "Draft.GPV_ApplicativeTemplates")
### theory "Draft.GPV_Applicative"
### 0.369s elapsed time, 0.428s cpu time, 0.066s GC time
Loading theory "Draft.GPV_ApplicativeTemplates"
val templateLemmas =
   [("GPV_Applicative.ap_gpv_id",
     "Applicative.ap (Generative_Probabilistic_Value.Done (%x. x)) ?x = ?x",
     template_equation
      (template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, t_empty)),
         template_var 0),
       template_var 0)),
    ("GPV_Applicative.ap_gpv_homo",
     "Applicative.ap (Generative_Probabilistic_Value.Done ?f)
       (Generative_Probabilistic_Value.Done ?x) =
      Generative_Probabilistic_Value.Done (?f ?x)",
     template_equation
      (template_app
        (template_app
          (template_hole 3, template_app (template_hole 2, template_var 1)),
         template_app (template_hole 1, template_var 0)),
       template_app
        (template_hole 0, template_app (template_var 1, template_var 0)))),
    ("GPV_Applicative.map_conv_ap_gpv",
     "map_gpv ?f (%x. x) ?gpv =
      Applicative.ap (Generative_Probabilistic_Value.Done ?f) ?gpv",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 2, template_var 1), t_empty),
         template_var 0),
       template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, template_var 1)),
         template_var 0))),
    ("GPV_Applicative.ap_gpv_interchange",
     "Applicative.ap ?u (Generative_Probabilistic_Value.Done ?x) =
      Applicative.ap (Generative_Probabilistic_Value.Done (%f. f ?x)) ?u",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 1),
         template_app (template_hole 2, template_var 0)),
       template_app
        (template_app
          (template_hole 1, template_app (template_hole 0, t_empty)),
         template_var 1))),
    ("GPV_Applicative.ap_gpv_comp",
     "Applicative.ap
       (Applicative.ap
         (Applicative.ap (Generative_Probabilistic_Value.Done (o)) ?u) ?v)
       ?w =
      Applicative.ap ?u (Applicative.ap ?v ?w)",
     template_equation
      (template_app
        (template_app
          (template_hole 6,
           template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app (template_hole 3, template_hole 2)),
                 template_var 2)),
             template_var 1)),
         template_var 0),
       template_app
        (template_app (template_hole 1, template_var 2),
         template_app
          (template_app (template_hole 0, template_var 1),
           template_var 0)))),
    ("GPV_Applicative.exec_gpv_ap_pure",
     "exec_gpv ?callee
       (Applicative.ap (Generative_Probabilistic_Value.Done ?f) ?x)
       ?\<sigma> =
      Applicative.ap (return_spmf (apfst ?f))
       (exec_gpv ?callee ?x ?\<sigma>)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 7, template_var 3),
           template_app
            (template_app
              (template_hole 6,
               template_app (template_hole 5, template_var 2)),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 4,
           template_app
            (template_hole 3,
             template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)))),
         template_app
          (template_app
            (template_app (template_hole 0, template_var 3),
             template_var 1),
           template_var 0)))),
    ("GPV_Applicative.exec_gpv_ap",
     "exec_gpv ?callee (Applicative.ap ?f ?x) ?\<sigma> =
      exec_gpv ?callee ?f ?\<sigma> >>=
      (%(f', \<sigma>').
          Applicative.ap
           (return_spmf (%(x', \<sigma>''). (f' x', \<sigma>'')))
           (exec_gpv ?callee ?x \<sigma>'))",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 10, template_var 3),
           template_app
            (template_app (template_hole 9, template_var 2),
             template_var 1)),
         template_var 0),
       template_app
        (template_app
          (template_hole 8,
           template_app
            (template_app
              (template_app (template_hole 7, template_var 3),
               template_var 2),
             template_var 0)),
         template_app (template_hole 6, t_empty))))]:
   (string * thm * template) list
### theory "Draft.GPV_ApplicativeTemplates"
### 1.614s elapsed time, 2.061s cpu time, 0.257s GC time
val it = (): unit
