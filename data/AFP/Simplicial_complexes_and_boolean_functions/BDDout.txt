Loading theory "Automatic_Refinement.Foldi" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
Loading theory "Automatic_Refinement.Prio_List" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
Loading theory "HOL-Eisbach.Eisbach" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Assertions" via "Automatic_Refinement.Misc")
Loading theory "Automatic_Refinement.Refine_Util_Bootstrap1" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Refine_Util")
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
signature PRIO_LIST =
  sig
    type T
    val add_after: T -> item -> item -> T
    val add_before: T -> item -> item -> T
    val add_first: T -> item -> T
    val add_last: T -> item -> T
    val contains: T -> item -> bool
    val delete: item -> T -> T
    val dest: T -> item list
    val empty: T
    type item
    val merge: T * T -> T
    val merge': T * T -> item list * T
    val prio_of: (item -> bool) -> (item * item -> bool) -> T -> int
  end
functor Prio_List (sig val eq: item * item -> bool type item end): PRIO_LIST
infix 1 ##
signature BASIC_REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
structure Basic_Refine_Util: BASIC_REFINE_UTIL
val map_option = fn: ('a -> 'b) -> 'a option -> 'b option
val split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val map_fold = fn: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
val split_matching = fn:
   ('a -> 'b -> bool) -> 'a list -> 'b list -> ('b list * 'b list) option
val seq_is_empty = fn: 'a Seq.seq -> bool * 'a Seq.seq
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val yield_singleton2 = fn:
   ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
### theory "Automatic_Refinement.Prio_List"
### 0.035s elapsed time, 0.140s cpu time, 0.000s GC time
Loading theory "Draft.ListLexorder" (required by "Draft.BDDMoreTemplates" via "Draft.BDD")
### theory "Automatic_Refinement.Refine_Util_Bootstrap1"
### 0.036s elapsed time, 0.145s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Mk_Term_Antiquot" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Refine_Util")
consts
  foldli :: "'b list => ('a => bool) => ('b => 'a => 'a) => 'a => 'a"
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
val mk_term_antiquot = fn:
   Context.generic * Token.T list ->
     string * (Context.generic * Token.T list)
### theory "Automatic_Refinement.Mk_Term_Antiquot"
### 0.081s elapsed time, 0.312s cpu time, 0.025s GC time
Loading theory "Automatic_Refinement.Mpat_Antiquot" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Refine_Util")
### theory "Automatic_Refinement.Foldi"
### 0.128s elapsed time, 0.491s cpu time, 0.025s GC time
Loading theory "HOL-Combinatorics.Transposition" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "Jordan_Normal_Form.Missing_Misc" via "HOL-Combinatorics.Permutations")
structure Eisbach_Rule_Insts: sig end
val mpat_antiquot = fn:
   Context.generic * Token.T list ->
     string * (Context.generic * Token.T list)
### theory "Automatic_Refinement.Mpat_Antiquot"
### 0.126s elapsed time, 0.487s cpu time, 0.052s GC time
Loading theory "Automatic_Refinement.Refine_Util" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
### theory "HOL-Combinatorics.Transposition"
### 0.147s elapsed time, 0.566s cpu time, 0.052s GC time
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Library.Monad_Syntax")
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.067s elapsed time, 0.273s cpu time, 0.000s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad")
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
### theory "HOL-Library.Monad_Syntax"
### 0.043s elapsed time, 0.166s cpu time, 0.026s GC time
Loading theory "HOL-Library.Cancellation" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Polynomial_Interpolation.Ring_Hom" via "HOL-Library.Multiset")
### theory "HOL-Eisbach.Eisbach"
### 0.418s elapsed time, 1.637s cpu time, 0.103s GC time
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
### theory "HOL-Library.Code_Abstract_Nat"
### 0.054s elapsed time, 0.250s cpu time, 0.000s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### if ?n = 0 | ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### Suc ?m <= ?n == ?m < ?n
### Code generator: dropping subsumed code equation
### 0 <= ?n == True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n == ?m <= ?n
### Code generator: dropping subsumed code equation
### ?n < 0 == False
### ML warning (line 563 of "$AFP/Automatic_Refinement/Lib/Refine_Util.thy"):
### Handler catches all exceptions.
infix 0 THEN_ELSE'
infix 0 THEN_ELSE_COMB'
infix 1 THEN_ALL_NEW_FWD
infix 1 THEN_INTERVAL
infix 2 ORELSE_INTERVAL
infix 3 ->>
type itactic = int -> int -> tactic
type tactic' = int -> tactic
signature BASIC_REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val ->> :
       'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
         'b context_parser
    val ALL_GOALS_FWD: tactic' -> tactic
    val ALL_GOALS_FWD': tactic' -> tactic'
    val APPEND_LIST': tactic' list -> tactic'
    val CAN': tactic' -> tactic'
    val CASES': (tactic' * tactic) list -> tactic'
    val CONCL_COND': (term -> bool) -> tactic'
    val COND': (term -> bool) -> tactic'
    val IF_EXGOAL: (int -> tactic) -> tactic'
    val INTERVAL_FWD: tactic' -> int -> int -> tactic
    val NTIMES': tactic' -> int -> tactic'
    val ORELSE_INTERVAL: itactic * itactic -> itactic
    val REPEAT': tactic' -> tactic'
    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'
    val REPEAT_DETERM': tactic' -> tactic'
    val RSm: Proof.context -> thm -> thm -> thm
    val SINGLE_INTERVAL: itactic -> tactic'
    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'
    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'
    val THEN_ELSE_COMB':
       tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') ->
         tactic'
    val THEN_INTERVAL: itactic * itactic -> itactic
    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'
    val TRY_SOLVED': tactic' -> tactic'
    val WITH_concl: (term -> tactic') -> tactic'
    val WITH_subgoal: (term -> tactic') -> tactic'
    val elim_all_tac: Proof.context -> thm list -> tactic
    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser
    val eqsubst_inst_tac:
       Proof.context ->
         bool ->
           int list ->
             ((indexname * Position.T) * string) list ->
               thm -> int -> tactic
    val fo_resolve_tac: thm list -> Proof.context -> tactic'
    val fo_rtac: thm -> Proof.context -> tactic'
    val has_Var: term -> bool
    val insert_subgoal_tac: cterm -> tactic'
    val insert_subgoals_tac: cterm list -> tactic'
    val is_Abs: term -> bool
    val is_Comb: term -> bool
    val is_TFree: typ -> bool
    val is_def_thm: thm -> bool
    type itactic = int -> int -> tactic
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val prefer_tac: int -> tactic
    val rprem_tac: int -> Proof.context -> tactic'
    val rprems_tac: Proof.context -> tactic'
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    type tactic' = int -> tactic
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
signature REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val ->> :
       'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
         'b context_parser
    val ALL_GOALS_FWD: tactic' -> tactic
    val ALL_GOALS_FWD': tactic' -> tactic'
    val APPEND_LIST': tactic' list -> tactic'
    val CAN': tactic' -> tactic'
    val CASES': (tactic' * tactic) list -> tactic'
    val CONCL_COND': (term -> bool) -> tactic'
    val COND': (term -> bool) -> tactic'
    val HOL_concl_conv: (Proof.context -> conv) -> Proof.context -> conv
    val IF_EXGOAL: (int -> tactic) -> tactic'
    val INTERVAL_FWD: tactic' -> int -> int -> tactic
    val NTIMES': tactic' -> int -> tactic'
    val OF_fst: thm list -> thm list -> thm
    val ORELSE_INTERVAL: itactic * itactic -> itactic
    val REPEAT': tactic' -> tactic'
    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'
    val REPEAT_DETERM': tactic' -> tactic'
    val RS_fst: thm -> thm list -> thm
    val RSm: Proof.context -> thm -> thm -> thm
    val SINGLE_INTERVAL: itactic -> tactic'
    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'
    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'
    val THEN_ELSE_COMB':
       tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') ->
         tactic'
    val THEN_INTERVAL: itactic * itactic -> itactic
    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'
    val TRY_SOLVED': tactic' -> tactic'
    val WITH_concl: (term -> tactic') -> tactic'
    val WITH_subgoal: (term -> tactic') -> tactic'
    val abs_def: Proof.context -> thm -> thm
    val anorm_term: term -> term
    val anorm_typ: typ -> typ
    val apply_configs:
       ('a Config.T * 'a) list -> Proof.context -> Proof.context
    val build_res_net: thm list -> (int * thm) Net.net
    val cfg_trace_f_tac_conv: bool Config.T
    val changed_rule: (thm -> thm) -> thm -> thm
    val dest_itselfT: typ -> typ
    val dummify_tvars: term -> term
    val elim_all_tac: Proof.context -> thm list -> tactic
    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser
    val eqsubst_inst_tac:
       Proof.context ->
         bool ->
           int list ->
             ((indexname * Position.T) * string) list ->
               thm -> int -> tactic
    val f_tac_conv:
       Proof.context -> (term -> term) -> (Proof.context -> tactic) -> conv
    val fcomb_conv: conv -> conv
    val fix_conv: Proof.context -> conv -> conv
    val fix_left_tuple_from_Ts:
       string -> typ list -> Proof.context -> term * Proof.context
    val fixup_vars: cterm -> thm -> thm
    val fixup_vars_conv: conv -> conv
    val fixup_vars_conv': (Proof.context -> conv) -> Proof.context -> conv
    val fo_matches: theory -> cterm -> term -> bool
    val fo_matchp: theory -> cterm -> term -> term list option
    val fo_resolve_tac: thm list -> Proof.context -> tactic'
    val fo_rtac: thm -> Proof.context -> tactic'
    val fold_binop_left:
       ('a -> 'b * 'a) ->
         ('c -> 'a -> 'b * 'a) ->
           ('b * 'b -> 'b) -> 'c list -> 'a -> 'b * 'a
    val fsub_conv: (Proof.context -> conv) -> Proof.context -> conv
    val ftop_conv: (Proof.context -> conv) -> Proof.context -> conv
    val has_Var: term -> bool
    val import_conv: (Proof.context -> conv) -> Proof.context -> conv
    val import_cterms:
       bool -> cterm list -> Proof.context -> cterm list * Proof.context
    val insert_subgoal_tac: cterm -> tactic'
    val insert_subgoals_tac: cterm list -> tactic'
    val instantiate_tuples:
       Proof.context -> (indexname * typ) list -> thm -> thm
    val instantiate_tuples_from_term_tac: Proof.context -> term -> tactic
    val instantiate_tuples_subgoal_tac: Proof.context -> tactic'
    val is_Abs: term -> bool
    val is_Comb: term -> bool
    val is_TFree: typ -> bool
    val is_def_thm: thm -> bool
    type itactic = int -> int -> tactic
    val ite_conv: conv -> conv -> conv -> conv
    val lambda_tuple: term list -> term -> term
    val list_binop_left: 'a -> ('a * 'a -> 'a) -> 'a list -> 'a
    val list_prodT_left: typ list -> typ
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val mk_compN: int -> term -> term -> term
    val mk_compN1: typ list -> int -> term -> term -> term
    val mk_ltuple: term list -> term
    val monitor_conv: string -> conv -> conv
    val monitor_conv':
       string -> (Proof.context -> conv) -> Proof.context -> conv
    val order_by: ('a * 'a -> order) -> ('b -> 'a) -> 'b list -> 'b list
    val parse_bool_config: string -> bool Config.T -> bool context_parser
    val parse_bool_config':
       string ->
         bool Config.T ->
           Token.T list -> (bool Config.T * bool) * Token.T list
    val parse_paren_list: 'a context_parser -> 'a list context_parser
    val parse_paren_list':
       'a parser -> Token.T list -> 'a list * Token.T list
    val parse_paren_lists: 'a context_parser -> 'a list list context_parser
    val pat_conv: cterm -> (Proof.context -> conv) -> Proof.context -> conv
    val pat_conv':
       cterm -> (string -> Proof.context -> conv) -> Proof.context -> conv
    val prefer_tac: int -> tactic
    val repeat_rule: (thm -> thm) -> thm -> thm
    val rprem_tac: int -> Proof.context -> tactic'
    val rprems_tac: Proof.context -> tactic'
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val shift_lambda_left: thm -> thm
    val shift_lambda_leftN: int -> thm -> thm
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    val strip_prodT_left: typ -> typ list
    val subsume_sort: ('a -> term) -> theory -> 'a list -> 'a list
    val subsume_sort_gen:
       ('a -> term) -> Context.generic -> 'a list -> 'a list
    type tactic' = int -> tactic
    val trace_conv: conv
    val trade_rule:
       (Proof.context -> thm -> thm) -> Proof.context -> thm -> thm
    val try_rule: (thm -> thm) -> thm -> thm
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
structure Refine_Util: REFINE_UTIL
structure Basic_Refine_Util: BASIC_REFINE_UTIL
val map_option = fn: ('a -> 'b) -> 'a option -> 'b option
val split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val REPEAT_DETERM' = fn: tactic' -> tactic'
val RSm = fn: Proof.context -> thm -> thm -> thm
val NTIMES' = fn: tactic' -> int -> tactic'
val fo_resolve_tac = fn: thm list -> Proof.context -> tactic'
val SINGLE_INTERVAL = fn: itactic -> tactic'
val insert_subgoals_tac = fn: cterm list -> tactic'
val insert_subgoal_tac = fn: cterm -> tactic'
val THEN_ALL_NEW_FWD = fn: tactic' * tactic' -> tactic'
val TRY_SOLVED' = fn: tactic' -> tactic'
val INTERVAL_FWD = fn: tactic' -> int -> int -> tactic
val IF_EXGOAL = fn: (int -> tactic) -> tactic'
val eqsubst_inst_tac = fn:
   Proof.context ->
     bool ->
       int list ->
         ((indexname * Position.T) * string) list -> thm -> int -> tactic
val fo_rtac = fn: thm -> Proof.context -> tactic'
val TRADE = fn: (Proof.context -> tactic') -> Proof.context -> tactic'
val is_TFree = fn: typ -> bool
val ALL_GOALS_FWD = fn: tactic' -> tactic
val yield_singleton2 = fn:
   ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val CAN' = fn: tactic' -> tactic'
val WITH_concl = fn: (term -> tactic') -> tactic'
val is_Abs = fn: term -> bool
val COND' = fn: (term -> bool) -> tactic'
val split_matching = fn:
   ('a -> 'b -> bool) -> 'a list -> 'b list -> ('b list * 'b list) option
val REPEAT_ALL_NEW_FWD = fn: tactic' -> tactic'
val CASES' = fn: (tactic' * tactic) list -> tactic'
val APPEND_LIST' = fn: tactic' list -> tactic'
val map_fold = fn: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
val is_def_thm = fn: thm -> bool
val THEN_INTERVAL = fn: itactic * itactic -> itactic
val rprems_tac = fn: Proof.context -> tactic'
val WITH_subgoal = fn: (term -> tactic') -> tactic'
val is_Comb = fn: term -> bool
val THEN_ELSE_COMB' = fn:
   tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') -> tactic'
val eqsubst_inst_meth = fn: (Proof.context -> Proof.method) context_parser
val elim_all_tac = fn: Proof.context -> thm list -> tactic
val ->> = fn:
   'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
     'b context_parser
val ALL_GOALS_FWD' = fn: tactic' -> tactic'
val prefer_tac = fn: int -> tactic
val rprem_tac = fn: int -> Proof.context -> tactic'
val has_Var = fn: term -> bool
val REPEAT' = fn: tactic' -> tactic'
val THEN_ELSE' = fn: tactic' * (tactic' * tactic') -> tactic'
val CONCL_COND' = fn: (term -> bool) -> tactic'
val ORELSE_INTERVAL = fn: itactic * itactic -> itactic
val seq_is_empty = fn: 'a Seq.seq -> bool * 'a Seq.seq
### theory "Automatic_Refinement.Refine_Util"
### 0.316s elapsed time, 1.280s cpu time, 0.067s GC time
Loading theory "Automatic_Refinement.Anti_Unification" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  linorder_list :: (linorder) linorder
  less_eq_linorder_list == less_eq ::
    'a linorder_list => 'a linorder_list => bool
  less_linorder_list == less :: 'a linorder_list => 'a linorder_list => bool
### Code generator: dropping subsumed code equation
### of_nat ?n == semiring_1_class.of_nat_aux (%i. i + (1::?'a)) ?n (0::?'a)
### theory "Draft.ListLexorder"
### 0.578s elapsed time, 2.303s cpu time, 0.144s GC time
Loading theory "Automatic_Refinement.Attr_Comb" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
### theory "HOL-Library.Code_Target_Nat"
### 0.150s elapsed time, 0.580s cpu time, 0.041s GC time
Loading theory "Automatic_Refinement.Indep_Vars" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
signature ANTI_UNIFICATION =
  sig
    val anti_unify: term * term -> term
    val anti_unifyT: typ * typ -> typ_env -> typ * typ_env
    val anti_unify_env: term * term -> env -> term * env
    val anti_unify_list: term list -> term
    val empty: env
    val empty_term: term_env
    val empty_typ: typ_env
    type env = typ_env * term_env
    val specialize_net_tac: Proof.context -> (int * thm) Net.net -> tactic'
    val specialize_tac: Proof.context -> thm list -> tactic'
    type term_env
    type typ_env
  end
structure Anti_Unification: ANTI_UNIFICATION
### theory "Automatic_Refinement.Anti_Unification"
### 0.071s elapsed time, 0.287s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Mk_Record_Simp" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
signature INDEP_VARS = sig val indep_tac: Proof.context -> tactic' end
structure Indep_Vars: INDEP_VARS
### theory "Automatic_Refinement.Indep_Vars"
### 0.045s elapsed time, 0.189s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Tagged_Solver" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
infixr 5 THEN_ATTR
infixr 4 ELSE_ATTR
signature ATTR_COMB =
  sig
    exception ATTR_EXC of string
    val CHECK_PREPARE:
       (Context.generic * thm -> bool) -> attribute -> attribute
    val COND_attr: (Context.generic * thm -> bool) -> attribute
    val EFF_ATTR: (Context.generic * thm -> 'a) -> attribute
    val ELSE_ATTR: attribute * attribute -> attribute
    val ID_ATTR: attribute
    val IGNORE_THM: attribute -> attribute
    val ITE_ATTR: attribute -> attribute -> attribute -> attribute
    val ITE_ATTR': attribute -> attribute -> (exn -> attribute) -> attribute
    val NO_ATTR: attribute
    val RPT1_ATTR: attribute -> attribute
    val RPT_ATTR: attribute -> attribute
    val RS_attr: thm -> attribute
    val RSm_attr: thm -> attribute
    val THEN_ATTR: attribute * attribute -> attribute
    val TRACE_ATTR: string -> attribute -> attribute
    val TRY_ATTR: attribute -> attribute
    val WARN_ATTR: Context.generic -> string -> attribute
  end
structure Attr_Comb: ATTR_COMB
### theory "Automatic_Refinement.Attr_Comb"
### 0.058s elapsed time, 0.231s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Named_Sorted_Thms" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
val mk_record_simp = fn: Context.generic -> thm -> thm
### theory "Automatic_Refinement.Mk_Record_Simp"
### 0.039s elapsed time, 0.159s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Select_Solve" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl" via "Automatic_Refinement.Refine_Lib")
signature NAMED_SORTED_THMS =
  sig
    val add: attribute
    val add_thm: thm -> Context.generic -> Context.generic
    val del: attribute
    val del_thm: thm -> Context.generic -> Context.generic
    val get: Proof.context -> thm list
    val member: Proof.context -> thm -> bool
    val setup: theory -> theory
  end
functor Named_Sorted_Thms (
  sig
    val description: string
    val name: binding
    val sort: Context.generic -> thm list -> thm list
    val transform: Context.generic -> thm -> thm list
  end
  ): 
  NAMED_SORTED_THMS
### theory "Automatic_Refinement.Named_Sorted_Thms"
### 0.034s elapsed time, 0.136s cpu time, 0.000s GC time
Loading theory "HOL-Library.Code_Target_Int" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "HOL-Library.Code_Target_Numeral")
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
### Code generator: dropping subsumed code equation
### 1 == Int.Pos num.One
signature SELECT_SOLVE =
  sig
    val AS_FIRSTGOAL: tactic -> tactic'
    val IF_SUBGOAL_SOLVED: tactic -> tactic -> tactic -> tactic
    val PREFER_SOLVED: tactic -> tactic
    val REPEAT_SOLVE_FWD_SELECT: Proof.context -> int -> tactic' -> tactic'
    val SELECT_FIRST: Proof.context -> tactic -> tactic
    val TRY_SOLVE_FWD: int -> tactic -> tactic
  end
structure Select_Solve: SELECT_SOLVE
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l == ?l
### Code generator: dropping subsumed code equation
### ?k + 0 == ?k
### theory "Automatic_Refinement.Select_Solve"
### 0.087s elapsed time, 0.341s cpu time, 0.032s GC time
Loading theory "HOL-Library.FuncSet" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "Jordan_Normal_Form.Missing_Misc")
### Code generator: dropping subsumed code equation
### - Int.Neg ?m == Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m == Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 == 0
signature TAGGED_SOLVER =
  sig
    val add_triggers:
       string -> thm list -> morphism -> Context.generic -> Context.generic
    val cfg_full: bool Config.T
    val cfg_keep: bool Config.T
    val cfg_step: bool Config.T
    val cfg_trace: bool Config.T
    val declare_solver:
       thm list ->
         binding ->
           string ->
             (Proof.context -> tactic') ->
               morphism -> Context.generic -> Context.generic
    val delete_solver:
       string -> morphism -> Context.generic -> Context.generic
    val get_potential_solvers: Proof.context -> int -> thm -> solver list
    val get_potential_tacs: Proof.context -> int -> thm -> tactic' list
    val get_solvers: Proof.context -> solver list
    val lookup_solver: string -> Context.generic -> solver option
    val pretty_solvers: Proof.context -> Pretty.T
    val solve_full_keep_tac: Proof.context -> tactic'
    val solve_full_step_tac: Proof.context -> tactic'
    val solve_full_tac: Proof.context -> tactic'
    val solve_greedy_keep_tac: Proof.context -> tactic'
    val solve_greedy_step_tac: Proof.context -> tactic'
    val solve_greedy_tac: Proof.context -> tactic'
    val solve_tac: Proof.context -> tactic'
    type solver = thm list * string * string * (Proof.context -> tactic')
    val tac_of_solver: Proof.context -> solver -> tactic'
  end
structure Tagged_Solver: TAGGED_SOLVER
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l == - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 == ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) == Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) == Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l == 0
### Code generator: dropping subsumed code equation
### ?k * 0 == 0
### theory "Automatic_Refinement.Tagged_Solver"
### 0.111s elapsed time, 0.433s cpu time, 0.032s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.BDDMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One == - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One == ?k
### Code generator: dropping subsumed code equation
### 0 div ?k == 0
### Code generator: dropping subsumed code equation
### ?k div 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n == - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n ==
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n ==
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n == snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One == 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One == 0
### Code generator: dropping subsumed code equation
### 0 mod ?k == 0
### Code generator: dropping subsumed code equation
### ?k mod 0 == ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k == True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) == equal_class.equal ?k ?l
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Neg ?l == ?l <= ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Pos ?l == ?k <= ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= 0 == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l == ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l == ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 == False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 < 0 == False
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) == numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 == 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) == - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) == nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 == 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) == 0
### theory "HOL-Library.Code_Target_Int"
### 0.189s elapsed time, 0.739s cpu time, 0.079s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit")
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.514s elapsed time, 2.063s cpu time, 0.120s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Polynomial_Interpolation.Ring_Hom")
### theory "HOL-Library.Function_Algebras"
### 0.135s elapsed time, 0.530s cpu time, 0.047s GC time
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Assertions" via "Automatic_Refinement.Misc")
### theory "HOL-Library.Code_Target_Numeral"
### 0.126s elapsed time, 0.501s cpu time, 0.000s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.BDDMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
consts
  enumerate :: "'a set => nat => 'a"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.FuncSet"
### 0.615s elapsed time, 2.264s cpu time, 0.630s GC time
Loading theory "HOL-Algebra.Congruence" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice" via "HOL-Algebra.Order")
### theory "HOL-Library.Infinite_Set"
### 0.474s elapsed time, 1.715s cpu time, 0.583s GC time
Loading theory "HOL-Library.Disjoint_Sets" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "Jordan_Normal_Form.Missing_Misc" via "HOL-Combinatorics.Permutations")
Found termination order: "size_list size <*mlex*> {}"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
### theory "HOL-Library.Nat_Bijection"
### 0.525s elapsed time, 1.910s cpu time, 0.627s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.BDDMoreTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.Disjoint_Sets"
### 0.311s elapsed time, 1.215s cpu time, 0.128s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Imperative_HOL.Heap" via "HOL-Library.Countable")
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
locale equivalence
  fixes S :: "('a, 'b) eq_object_scheme"  (structure)
  assumes "equivalence S"
locale partition
  fixes A :: "'a set"
    and B :: "'a set set"
  assumes "Congruence.partition A B"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
### theory "HOL-Algebra.Congruence"
### 0.763s elapsed time, 3.000s cpu time, 0.320s GC time
Loading theory "HOL-Algebra.Order" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice" via "HOL-Algebra.Lattice")
consts
  sdrop :: "nat => 'a stream => 'a stream"
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
### theory "HOL-Library.Old_Datatype"
### 0.450s elapsed time, 1.763s cpu time, 0.192s GC time
Loading theory "HOL-Library.Option_ord" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Assertions" via "Automatic_Refinement.Misc")
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
instantiation
  option :: (preorder) preorder
  less_eq_option == less_eq :: 'a option => 'a option => bool
  less_option == less :: 'a option => 'a option => bool
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
instantiation
  option :: (order) order_bot
  bot_option == bot :: 'a option
consts
  cycle :: "'a list => 'a stream"
instantiation
  option :: (order_top) order_top
  top_option == top :: 'a option
instantiation
  option :: (inf) inf
  inf_option == inf :: 'a option => 'a option => 'a option
instantiation
  option :: (sup) sup
  sup_option == sup :: 'a option => 'a option => 'a option
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
instantiation
  option :: (complete_lattice) complete_lattice
  Inf_option == Inf :: 'a option set => 'a option
  Sup_option == Sup :: 'a option set => 'a option
consts
  flat :: "'a list stream => 'a stream"
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
### theory "HOL-Library.Option_ord"
### 0.570s elapsed time, 2.099s cpu time, 0.832s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word" via "HOL-Library.Type_Length" via "HOL-Library.Numeral_Type" via "HOL-Library.Cardinality")
### theory "HOL-Library.Stream"
### 1.196s elapsed time, 4.555s cpu time, 1.109s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.BDDMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
consts
  mset :: "'a list => 'a multiset"
### theory "HOL-Library.Set_Algebras"
### 0.262s elapsed time, 1.025s cpu time, 0.172s GC time
Loading theory "HOL-Library.Signed_Division" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Word_Lib.Signed_Division_Word")
locale weak_partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order L"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class signed_division = type +
  fixes signed_divide :: "'a => 'a => 'a"
    and signed_modulo :: "'a => 'a => 'a"
instantiation
  int :: signed_division
  signed_divide_int == signed_divide :: int => int => int
  signed_modulo_int == signed_modulo :: int => int => int
### theory "HOL-Library.Signed_Division"
### 0.144s elapsed time, 0.565s cpu time, 0.077s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.BDDMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
locale partial_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "partial_order L"
locale weak_partial_order_bottom
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_bottom L"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
locale weak_partial_order_top
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_partial_order_top L"
locale weak_total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_total_order L"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
locale total_order
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "total_order L"
### theory "HOL-Library.Phantom_Type"
### 0.612s elapsed time, 2.400s cpu time, 0.323s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word" via "HOL-Library.Type_Length" via "HOL-Library.Numeral_Type")
### theory "HOL-Algebra.Order"
### 1.202s elapsed time, 4.583s cpu time, 1.155s GC time
Loading theory "HOL-Algebra.Lattice" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group" via "HOL-Algebra.Complete_Lattice")
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
### Additional type variable(s) in locale specification "CARD_1": 'a
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
locale weak_upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_upper_semilattice L"
locale weak_lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lower_semilattice L"
locale weak_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_lattice L"
### Additional type variable(s) in locale specification "card2": 'a
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
Found termination order: "size <*mlex*> {}"
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
Found termination order: "size <*mlex*> {}"
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
locale weak_bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_bounded_lattice L"
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
Found termination order: "size <*mlex*> {}"
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
locale upper_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "upper_semilattice L"
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
locale lower_semilattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lower_semilattice L"
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
locale Lattice.lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "lattice L"
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
Found termination order: "size <*mlex*> {}"
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
### theory "HOL-Library.Cardinality"
### 0.784s elapsed time, 3.078s cpu time, 0.333s GC time
Loading theory "HOL-Library.Numeral_Type" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word" via "HOL-Library.Type_Length")
Found termination order: "size <*mlex*> {}"
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
locale Lattice.bounded_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "bounded_lattice L"
### theory "HOL-Algebra.Lattice"
### 0.883s elapsed time, 3.466s cpu time, 0.383s GC time
Loading theory "HOL-Algebra.Complete_Lattice" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct" via "HOL-Algebra.Group")
Found termination order: "size <*mlex*> {}"
instantiation
  num1 :: CARD_1
instantiation
  num1 :: {comm_monoid_mult,numeral,comm_ring}
  uminus_num1 == uminus :: num1 => num1
  zero_num1 == zero_class.zero :: num1
  minus_num1 == minus :: num1 => num1 => num1
  plus_num1 == plus :: num1 => num1 => num1
  one_num1 == one_class.one :: num1
  times_num1 == times :: num1 => num1 => num1
instantiation
  num1 :: linorder
  less_eq_num1 == less_eq :: num1 => num1 => bool
  less_num1 == less :: num1 => num1 => bool
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale mod_type
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_type n Rep Abs"
locale mod_ring
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_ring n Rep Abs"
instantiation
  bit0 :: (finite) {minus,one,plus,times,uminus,zero}
  bit1 :: (finite) {minus,one,plus,times,uminus,zero}
  zero_bit0 == zero_class.zero :: 'a bit0
  uminus_bit0 == uminus :: 'a bit0 => 'a bit0
  times_bit0 == times :: 'a bit0 => 'a bit0 => 'a bit0
  plus_bit0 == plus :: 'a bit0 => 'a bit0 => 'a bit0
  one_bit0 == one_class.one :: 'a bit0
  minus_bit0 == minus :: 'a bit0 => 'a bit0 => 'a bit0
  zero_bit1 == zero_class.zero :: 'a bit1
  uminus_bit1 == uminus :: 'a bit1 => 'a bit1
  times_bit1 == times :: 'a bit1 => 'a bit1 => 'a bit1
  plus_bit1 == plus :: 'a bit1 => 'a bit1 => 'a bit1
  one_bit1 == one_class.one :: 'a bit1
  minus_bit1 == minus :: 'a bit1 => 'a bit1 => 'a bit1
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
Found termination order: "size <*mlex*> {}"
instantiation
  bit0 :: (finite) linorder
  bit1 :: (finite) linorder
  less_eq_bit0 == less_eq :: 'a bit0 => 'a bit0 => bool
  less_bit0 == less :: 'a bit0 => 'a bit0 => bool
  less_eq_bit1 == less_eq :: 'a bit1 => 'a bit1 => bool
  less_bit1 == less :: 'a bit1 => 'a bit1 => bool
instantiation
  num0 :: equal
  equal_num0 == equal_class.equal :: num0 => num0 => bool
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
instantiation
  num1 :: equal
  equal_num1 == equal_class.equal :: num1 => num1 => bool
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
instantiation
  num1 :: enum
  enum_num1 == enum_class.enum :: num1 list
  enum_all_num1 == enum_class.enum_all :: (num1 => bool) => bool
  enum_ex_num1 == enum_class.enum_ex :: (num1 => bool) => bool
instantiation
  num0 :: card_UNIV
  num1 :: card_UNIV
  card_UNIV_num0 == card_UNIV_class.card_UNIV :: (num0, nat) phantom
  finite_UNIV_num0 == finite_UNIV :: (num0, bool) phantom
  card_UNIV_num1 == card_UNIV_class.card_UNIV :: (num1, nat) phantom
  finite_UNIV_num1 == finite_UNIV :: (num1, bool) phantom
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
instantiation
  bit0 :: (finite) equal
  bit1 :: (finite) equal
  equal_bit0 == equal_class.equal :: 'a bit0 => 'a bit0 => bool
  equal_bit1 == equal_class.equal :: 'a bit1 => 'a bit1 => bool
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
instantiation
  bit0 :: (finite) enum
  enum_bit0 == enum_class.enum :: 'a bit0 list
  enum_all_bit0 == enum_class.enum_all :: ('a bit0 => bool) => bool
  enum_ex_bit0 == enum_class.enum_ex :: ('a bit0 => bool) => bool
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  bit1 :: (finite) enum
  enum_bit1 == enum_class.enum :: 'a bit1 list
  enum_all_bit1 == enum_class.enum_all :: ('a bit1 => bool) => bool
  enum_ex_bit1 == enum_class.enum_ex :: ('a bit1 => bool) => bool
instantiation
  bit0 :: (finite) finite_UNIV
  bit1 :: (finite) finite_UNIV
  finite_UNIV_bit0 == finite_UNIV :: ('a bit0, bool) phantom
  finite_UNIV_bit1 == finite_UNIV :: ('a bit1, bool) phantom
locale Complete_Lattice.complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "complete_lattice L"
instantiation
  bit0 :: ({card_UNIV,finite}) card_UNIV
  bit1 :: ({card_UNIV,finite}) card_UNIV
  card_UNIV_bit0 == card_UNIV_class.card_UNIV :: ('a bit0, nat) phantom
  card_UNIV_bit1 == card_UNIV_class.card_UNIV :: ('a bit1, nat) phantom
locale weak_complete_lattice
  fixes L :: "('a, 'b) gorder_scheme"  (structure)
  assumes "weak_complete_lattice L"
### theory "HOL-Library.Numeral_Type"
### 0.793s elapsed time, 3.108s cpu time, 0.387s GC time
Loading theory "HOL-Library.Type_Length" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word")
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
class len0 = type +
  fixes len_of :: "'a itself => nat"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
### theory "HOL-Algebra.Complete_Lattice"
### 0.801s elapsed time, 3.122s cpu time, 0.407s GC time
Loading theory "HOL-Algebra.Group" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring" via "HOL-Algebra.FiniteProduct")
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
class len = len0 +
  assumes "len_gt_0": "0 < LENGTH('a)"
instantiation
  0 :: len0
  1 :: len0
  len_of_num0 == len_of :: 0 itself => nat
  len_of_num1 == len_of :: 1 itself => nat
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  bit0 :: (len0) len0
  bit1 :: (len0) len0
  len_of_bit0 == len_of :: 'a bit0 itself => nat
  len_of_bit1 == len_of :: 'a bit1 itself => nat
instantiation
  Enum.finite_1 :: len
  len_of_finite_1 == len_of :: Enum.finite_1 itself => nat
Found termination order: "size <*mlex*> {}"
instantiation
  Enum.finite_2 :: len
  len_of_finite_2 == len_of :: Enum.finite_2 itself => nat
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
instantiation
  Enum.finite_3 :: len
  len_of_finite_3 == len_of :: Enum.finite_3 itself => nat
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
### theory "HOL-Library.Multiset"
### 4.421s elapsed time, 17.034s cpu time, 3.066s GC time
Loading theory "HOL-Computational_Algebra.Factorial_Ring" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Polynomial_Interpolation.Ring_Hom")
### theory "HOL-Library.Tree"
### 2.195s elapsed time, 8.587s cpu time, 1.082s GC time
Loading theory "HOL-ex.Quicksort" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Assertions" via "Automatic_Refinement.Misc")
locale Group.monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.monoid G"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale Group.group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.group G"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "HOL-Library.Type_Length"
### 1.108s elapsed time, 4.075s cpu time, 1.909s GC time
Loading theory "HOL-Combinatorics.Permutations" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "Jordan_Normal_Form.Missing_Misc")
overloading
  nat_pow \<equiv> pow :: ('a, 'b) monoid_scheme => 'a => nat => 'a
overloading
  int_pow \<equiv> pow :: ('a, 'b) monoid_scheme => 'a => int => 'a
Found termination order: "length <*mlex*> {}"
locale submonoid
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "submonoid H G"
### theory "HOL-ex.Quicksort"
### 0.901s elapsed time, 3.276s cpu time, 1.704s GC time
Loading theory "Automatic_Refinement.Misc" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Assertions")
locale subgroup
  fixes H :: "'a set"
    and G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "subgroup H G"
Proofs for inductive predicate(s) "swapidseq"
  Proving monotonicity ...
locale group_hom
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
    and H :: "('c, 'd) monoid_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "group_hom G H h"
locale Assoc
  fixes f :: "'a => 'a => 'a"
  assumes "Assoc f"
locale AC
  fixes f :: "'a => 'a => 'a"
  assumes "AC f"
locale su_rel_fun
  fixes F :: "('a * 'b) set"
    and f :: "'a => 'b"
  assumes "su_rel_fun F f"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale comm_group
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "comm_group G"
class normalization_semidom = algebraic_semidom +
  semidom_divide_unit_factor +
  fixes normalize :: "'a => 'a"
  assumes
    "unit_factor_mult_normalize": "!!a. unit_factor a * normalize a = a"
    and "normalize_0": "normalize (0::'a) = (0::'a)"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
### theory "HOL-Combinatorics.Permutations"
### 1.538s elapsed time, 5.806s cpu time, 2.116s GC time
Loading theory "Jordan_Normal_Form.Missing_Misc" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring")
### theory "Jordan_Normal_Form.Missing_Misc"
### 0.121s elapsed time, 0.473s cpu time, 0.078s GC time
Loading theory "HOL-Library.Word" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
### theory "HOL-Algebra.Group"
### 2.624s elapsed time, 9.807s cpu time, 3.949s GC time
Loading theory "HOL-Algebra.FiniteProduct" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring" via "HOL-Algebra.Ring")
Proofs for inductive predicate(s) "foldSetDp"
  Proving monotonicity ...
instantiation
  word :: (len) comm_ring_1
  uminus_word == uminus :: 'a word => 'a word
  one_word == one_class.one :: 'a word
  times_word == times :: 'a word => 'a word => 'a word
  zero_word == zero_class.zero :: 'a word
  minus_word == minus :: 'a word => 'a word => 'a word
  plus_word == plus :: 'a word => 'a word => 'a word
class semiring_gcd = gcd + normalization_semidom +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
    and "normalize_gcd": "!!a b. normalize (gcd a b) = gcd a b"
    and "lcm_gcd": "!!a b. lcm a b = normalize (a * b div gcd a b)"
locale LCD
  fixes B :: "'b set"
    and D :: "'a set"
    and f :: "'b => 'a => 'a"  (infixl \<open>\<cdot>\<close> 70)
  assumes "LCD B D (\<cdot>)"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
signature WORD_LIB =
  sig
    val dest_binT: typ -> int
    val dest_wordT: typ -> int
    val is_wordT: typ -> bool
    val mk_wordT: int -> typ
  end
structure Word_Lib: WORD_LIB
locale ACeD
  fixes D :: "'a set"
    and f :: "'a => 'a => 'a"  (infixl \<open>\<cdot>\<close> 70)
    and e :: "'a"
  assumes "ACeD D (\<cdot>) e"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
instantiation
  word :: (len) equal
  equal_word == equal_class.equal :: 'a word => 'a word => bool
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
### theory "HOL-Algebra.FiniteProduct"
### 0.506s elapsed time, 1.997s cpu time, 0.236s GC time
Loading theory "HOL-Algebra.Ring" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Missing_Ring")
### Ignoring duplicate rewrite rule:
### dom (%x. Some (?f1 x)) == UNIV
consts
  filter_rev_aux :: "'a list => ('a => bool) => 'a list => 'a list"
### Missing patterns in function definition:
### !!a v va. zipf a (v # va) [] = undefined
### !!a v va. zipf a [] (v # va) = undefined
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "!!x. x ~= (0::'a) ==>
            EX A. (ALL x. x :# A --> prime_elem x) &
                  normalize (\<Prod>\<^sub># A) = normalize x"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
### Cannot skip proof of schematic goal statement
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Cannot skip proof of schematic goal statement
locale abelian_monoid
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_monoid G"
### Cannot skip proof of schematic goal statement
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "!!x. x ~= (0::'a) ==>
            EX A. (ALL x. x :# A --> prime_elem x) &
                  normalize (\<Prod>\<^sub># A) = normalize x"
instantiation
  word :: (len) linorder
  less_eq_word == less_eq :: 'a word => 'a word => bool
  less_word == less :: 'a word => 'a word => bool
locale abelian_group
  fixes G :: "('a, 'b) ring_scheme"  (structure)
  assumes "abelian_group G"
instantiation
  word :: (len) enum
  enum_word == enum_class.enum :: 'a word list
  enum_all_word == enum_class.enum_all :: ('a word => bool) => bool
  enum_ex_word == enum_class.enum_ex :: ('a word => bool) => bool
### Cannot skip proof of schematic goal statement
instantiation
  word :: (len) semiring_modulo
  modulo_word == modulo :: 'a word => 'a word => 'a word
  divide_word == divide :: 'a word => 'a word => 'a word
instantiation
  word :: (len) semiring_bits
  bit_word == bit :: 'a word => nat => bool
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
instantiation
  word :: (len) ring_bit_operations
  not_word == not :: 'a word => 'a word
  and_word == and :: 'a word => 'a word => 'a word
  or_word == or :: 'a word => 'a word => 'a word
  xor_word == xor :: 'a word => 'a word => 'a word
  mask_word == mask :: nat => 'a word
  set_bit_word == set_bit :: nat => 'a word => 'a word
  unset_bit_word == unset_bit :: nat => 'a word => 'a word
  flip_bit_word == flip_bit :: nat => 'a word => 'a word
  push_bit_word == push_bit :: nat => 'a word => 'a word
  drop_bit_word == drop_bit :: nat => 'a word => 'a word
  take_bit_word == take_bit :: nat => 'a word => 'a word
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
### Code generator: dropping subsumed code equation
### quicksort (?x # ?xs) ==
### quicksort (filter (%y. y < ?x) ?xs) @
### [?x] @ quicksort (filter ((<=) ?x) ?xs)
### Code generator: dropping subsumed code equation
### quicksort [] == []
locale Ring.field
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "field R"
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
locale Ring.ring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "ring R"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
### ML warning (line 44 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 47 of "~~/src/HOL/Algebra/ringsimp.ML"):
### Matches are not exhaustive.
signature RINGSIMP =
  sig
    val add_struct: string * term list -> attribute
    val algebra_tac: Proof.context -> int -> tactic
    val del_struct: string * term list -> attribute
    val print_structures: Proof.context -> unit
  end
structure Ringsimp: RINGSIMP
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
locale Ring.semiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "semiring R"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
locale domain
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "domain R"
Found termination order: "{}"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
consts
  the_default :: "'a => 'a option => 'a"
locale ring_hom_cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and S :: "('c, 'd) ring_scheme"  (structure)
    and h :: "'a => 'c"
  assumes "ring_hom_cring R S h"
class factorial_semiring_gcd = factorial_semiring + Gcd +
  assumes "gcd_eq_gcd_factorial": "!!a b. gcd a b = gcd_factorial a b"
    and "lcm_eq_lcm_factorial": "!!a b. lcm a b = lcm_factorial a b"
    and "Gcd_eq_Gcd_factorial": "!!A. Gcd A = Gcd_factorial A"
    and "Lcm_eq_Lcm_factorial": "!!A. Lcm A = Lcm_factorial A"
class unique_euclidean_semiring_numeral =
  unique_euclidean_semiring_with_nat + linordered_semidom +
  fixes divmod :: "num => num => 'a * 'a"
    and divmod_step :: "num => 'a * 'a => 'a * 'a"
  assumes
    "div_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a div b = (0::'a)"
    and "mod_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a mod b = a"
    and
    "div_positive": "!!b a. [| (0::'a) < b; b <= a |] ==> (0::'a) < a div b"
    and "mod_less_eq_dividend": "!!a b. (0::'a) <= a ==> a mod b <= a"
    and "pos_mod_bound": "!!b a. (0::'a) < b ==> a mod b < b"
    and "pos_mod_sign": "!!b a. (0::'a) < b ==> (0::'a) <= a mod b"
    and
    "mod_mult2_eq":
      "!!c a b.
          (0::'a) <= c ==> a mod (b * c) = b * (a div b mod c) + a mod b"
    and
    "div_mult2_eq":
      "!!c a b. (0::'a) <= c ==> a div (b * c) = a div b div c"
  assumes "discrete": "!!a b. (a < b) = (a + (1::'a) <= b)"
  assumes
    "divmod_def":
      "!!m n.
          divmod m n = (numeral m div numeral n, numeral m mod numeral n)"
    and
    "divmod_step_def":
      "!!l qr.
          divmod_step l qr =
          (let (q, r) = qr
           in if numeral l <= r then ((2::'a) * q + (1::'a), r - numeral l)
              else ((2::'a) * q, r))"
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |] ==> x <= Sup A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> Sup A <= z"
### theory "Automatic_Refinement.Misc"
### 4.753s elapsed time, 18.490s cpu time, 3.553s GC time
Loading theory "Automatic_Refinement.Refine_Lib" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl")
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
### theory "HOL-Algebra.Ring"
### 2.942s elapsed time, 11.611s cpu time, 1.206s GC time
Loading theory "HOL-Algebra.Module" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix")
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
locale module
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "module R M"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
instantiation
  word :: (len) size
  size_word == size :: 'a word => nat
locale algebra
  fixes R :: "('a, 'b) ring_scheme"  (structure)
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "algebra R M"
signature COND_REWR_CONV =
  sig
    val cond_rewr_conv:
       (Proof.context -> tactic) -> thm -> Proof.context -> conv
    val cond_rewrs_conv:
       (Proof.context -> tactic) -> thm list -> Proof.context -> conv
  end
structure Cond_Rewr_Conv: COND_REWR_CONV
signature REVERT_ABBREV =
  sig
    val revert_abbrev: string -> theory -> theory
    val revert_abbrev_matching: (string -> bool) -> theory -> theory
  end
structure Revert_Abbrev: REVERT_ABBREV
### theory "Automatic_Refinement.Refine_Lib"
### 1.007s elapsed time, 3.984s cpu time, 0.319s GC time
Loading theory "Jordan_Normal_Form.Missing_Ring" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix")
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Min (\<le>s) (set (?x # ?xs)) == fold signed.min ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Max (\<le>s) (set (?x # ?xs)) == fold signed.max ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [?x] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted (?x # ?y # ?zs) == ?x \<le>s ?y & signed.sorted (?y # ?zs)
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted_list_of_set (set ?xs) == signed.sort (remdups ?xs)
locale submodule
  fixes H :: "'c set"
    and R :: "('a, 'b) ring_scheme"
    and M :: "('a, 'c, 'd) module_scheme"  (structure)
  assumes "submodule H R M"
### theory "HOL-Algebra.Module"
### 1.486s elapsed time, 5.874s cpu time, 0.518s GC time
Loading theory "Draft.Templates" (required by "Draft.BDDMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.068s elapsed time, 0.264s cpu time, 0.000s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Imperative_HOL.Heap")
class ordered_semiring_strict = comm_monoid_add +
  ordered_cancel_ab_semigroup_add + semiring +
  assumes
    "mult_strict_left_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> c * a < c * b"
  assumes
    "mult_strict_right_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> a * c < b * c"
val unat_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?v1 ... ?w1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.unat_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val unat_arith_tacs = fn: Proof.context -> tactic list
val unat_arith_tac = fn: Proof.context -> int -> tactic
val uint_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?a1 ... ?b1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.uint_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val uint_arith_tacs = fn: Proof.context -> tactic list
val uint_arith_tac = fn: Proof.context -> int -> tactic
### Additional type variable(s) in locale specification "countable": 'a
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
### theory "HOL-Computational_Algebra.Factorial_Ring"
### 8.046s elapsed time, 31.245s cpu time, 5.871s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.BDDMoreTemplates" via "Draft.ExtrEqs")
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
locale word_rotate
signature SMT_WORD =
  sig
    val add_word_shift': term * string -> Context.generic -> Context.generic
  end
structure SMT_Word: SMT_WORD
### theory "HOL-Library.Word"
### 6.082s elapsed time, 24.021s cpu time, 2.317s GC time
Loading theory "Word_Lib.Bit_Comprehension" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
### theory "HOL-Library.Countable"
### 1.147s elapsed time, 4.524s cpu time, 0.357s GC time
Loading theory "Word_Lib.More_Divides" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit" via "Word_Lib.More_Word")
### theory "Word_Lib.More_Divides"
### 0.172s elapsed time, 0.676s cpu time, 0.090s GC time
Loading theory "Word_Lib.Signed_Division_Word" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
class ordered_idom = ordered_semiring_strict + idom +
  assumes "zero_less_one": "(0::'a) < (1::'a)"
### theory "HOL-Library.BigO"
### 0.841s elapsed time, 3.317s cpu time, 0.352s GC time
Loading theory "HOL-Imperative_HOL.Heap" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad")
instantiation
  word :: (len) signed_division
  signed_divide_word == signed_divide :: 'a word => 'a word => 'a word
  signed_modulo_word == signed_modulo :: 'a word => 'a word => 'a word
### theory "Word_Lib.Signed_Division_Word"
### 0.495s elapsed time, 1.947s cpu time, 0.171s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.BDDMoreTemplates")
class bit_comprehension = ring_bit_operations +
  fixes set_bits :: "(nat => bool) => 'a"
  assumes "set_bits_bit_eq": "!!a. set_bits (bit a) = a"
instantiation
  int :: bit_comprehension
  set_bits_int == set_bits :: (nat => bool) => int
instantiation
  word :: (len) bit_comprehension
  set_bits_word == set_bits :: (nat => bool) => 'a word
Proofs for inductive predicate(s) "wf_set_bits_int"
  Proving monotonicity ...
### theory "Word_Lib.Bit_Comprehension"
### 1.065s elapsed time, 4.220s cpu time, 0.362s GC time
Loading theory "HOL-Library.Complex_Order" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix" via "Jordan_Normal_Form.Conjugate")
instantiation
  complex :: order
  less_eq_complex == less_eq :: complex => complex => bool
  less_complex == less :: complex => complex => bool
### theory "HOL-Library.Complex_Order"
### 0.059s elapsed time, 0.227s cpu time, 0.000s GC time
Loading theory "Jordan_Normal_Form.Conjugate" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix")
class conjugate = type +
  fixes conjugate :: "'a => 'a"
  assumes "conjugate_id": "!!a. conjugate (conjugate a) = a"
    and
    "conjugate_cancel_iff": "!!a b. (conjugate a = conjugate b) = (a = b)"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.671s elapsed time, 2.652s cpu time, 0.205s GC time
Loading theory "Native_Word.Code_Int_Integer_Conversion" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
### theory "Native_Word.Code_Int_Integer_Conversion"
### 0.033s elapsed time, 0.141s cpu time, 0.000s GC time
Loading theory "Polynomial_Interpolation.Ring_Hom" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions" via "Jordan_Normal_Form.Matrix")
consts
  addr_of_array :: "'a array => nat"
consts
  addr_of_ref :: "'a ref => nat"
class conjugatable_ring = conjugate + ring +
  assumes
    "conjugate_dist_mul":
      "!!a b. conjugate (a * b) = conjugate a * conjugate b"
    and
    "conjugate_dist_add":
      "!!a b. conjugate (a + b) = conjugate a + conjugate b"
    and "conjugate_neg": "!!a. conjugate (- a) = - conjugate a"
    and "conjugate_zero": "conjugate (0::'a) = (0::'a)"
### theory "HOL-Imperative_HOL.Heap"
### 1.088s elapsed time, 4.308s cpu time, 0.357s GC time
Loading theory "HOL-Imperative_HOL.Heap_Monad" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array")
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale csemiring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "csemiring R"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
locale Group.comm_monoid
  fixes G :: "('a, 'b) monoid_scheme"  (structure)
  assumes "Group.comm_monoid G"
locale zero_hom
  fixes hom :: "'a => 'b"
  assumes "zero_hom hom"
locale one_hom
  fixes hom :: "'a => 'b"
  assumes "one_hom hom"
locale times_hom
  fixes hom :: "'a => 'b"
  assumes "times_hom hom"
locale plus_hom
  fixes hom :: "'a => 'b"
  assumes "plus_hom hom"
locale semigroup_mult_hom
  fixes hom :: "'a => 'b"
  assumes "semigroup_mult_hom hom"
locale semigroup_add_hom
  fixes hom :: "'a => 'b"
  assumes "semigroup_add_hom hom"
locale monoid_mult_hom
  fixes hom :: "'a => 'b"
  assumes "monoid_mult_hom hom"
locale cring
  fixes R :: "('a, 'b) ring_scheme"  (structure)
  assumes "cring R"
locale monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "monoid_add_hom hom"
### theory "Jordan_Normal_Form.Missing_Ring"
### 3.795s elapsed time, 15.001s cpu time, 1.263s GC time
locale group_add_hom
  fixes hom :: "'a => 'b"
  assumes "group_add_hom hom"
Loading theory "ROBDD.Bool_Func" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.MkIfex" via "ROBDD.BDT")
locale ab_semigroup_mult_hom
  fixes hom :: "'a => 'b"
  assumes "ab_semigroup_mult_hom hom"
locale ab_semigroup_add_hom
  fixes hom :: "'a => 'b"
  assumes "ab_semigroup_add_hom hom"
locale comm_monoid_mult_hom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_mult_hom hom"
locale comm_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_add_hom hom"
locale ab_group_add_hom
  fixes hom :: "'a => 'b"
  assumes "ab_group_add_hom hom"
locale semiring_hom
  fixes hom :: "'a => 'b"
  assumes "semiring_hom hom"
locale ring_hom
  fixes hom :: "'a => 'b"
  assumes "ring_hom hom"
locale comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_hom hom"
locale comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "comm_ring_hom hom"
### theory "ROBDD.Bool_Func"
### 0.121s elapsed time, 0.479s cpu time, 0.000s GC time
Loading theory "ROBDD.BDT" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.MkIfex")
locale idom_hom
  fixes hom :: "'a => 'b"
  assumes "idom_hom hom"
locale idom_divide_hom
  fixes hom :: "'a => 'b"
  assumes "idom_divide_hom hom"
locale field_hom
  fixes hom :: "'a => 'b"
  assumes "field_hom hom"
locale field_char_0_hom
  fixes hom :: "'a => 'b"
  assumes "field_char_0_hom hom"
locale zero_hom_0
  fixes hom :: "'a => 'b"
  assumes "zero_hom_0 hom"
locale one_hom_1
  fixes hom :: "'a => 'b"
  assumes "one_hom_1 hom"
locale monoid_mult_hom_1
  fixes hom :: "'a => 'b"
  assumes "monoid_mult_hom_1 hom"
locale monoid_add_hom_0
  fixes hom :: "'a => 'b"
  assumes "monoid_add_hom_0 hom"
locale comm_monoid_mult_hom_1
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_mult_hom_1 hom"
locale comm_monoid_add_hom_0
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_add_hom_0 hom"
locale injective
  fixes f :: "'a => 'b"
  assumes "injective f"
locale inj_zero_hom
  fixes hom :: "'a => 'b"
  assumes "inj_zero_hom hom"
locale inj_one_hom
  fixes hom :: "'a => 'b"
  assumes "inj_one_hom hom"
locale inj_semigroup_mult_hom
  fixes hom :: "'a => 'b"
  assumes "inj_semigroup_mult_hom hom"
locale inj_semigroup_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_semigroup_add_hom hom"
locale inj_monoid_mult_hom
  fixes hom :: "'a => 'b"
  assumes "inj_monoid_mult_hom hom"
locale inj_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_monoid_add_hom hom"
locale inj_comm_monoid_mult_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_monoid_mult_hom hom"
consts
  execute :: "'a Heap => heap => ('a * heap) option"
locale inj_comm_monoid_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_monoid_add_hom hom"
locale inj_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_semiring_hom hom"
locale inj_comm_semiring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_semiring_hom hom"
locale inj_group_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_group_add_hom hom"
locale inj_ab_group_add_hom
  fixes hom :: "'a => 'b"
  assumes "inj_ab_group_add_hom hom"
locale inj_ring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_ring_hom hom"
locale inj_comm_ring_hom
  fixes hom :: "'a => 'b"
  assumes "inj_comm_ring_hom hom"
locale inj_idom_hom
  fixes hom :: "'a => 'b"
  assumes "inj_idom_hom hom"
locale field_hom
  fixes hom :: "'a => 'b"
  assumes "field_hom hom"
locale surjective
  fixes f :: "'a => 'b"
  assumes "surjective f"
locale bijective
  fixes f :: "'a => 'b"
  assumes "bijective f"
locale bijective
  fixes f :: "'a => 'b"
  assumes "bijective f"
locale monoid_mult_isom
  fixes hom :: "'a => 'b"
  assumes "monoid_mult_isom hom"
locale monoid_add_isom
  fixes hom :: "'a => 'b"
  assumes "monoid_add_isom hom"
locale comm_monoid_mult_isom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_mult_isom hom"
locale comm_monoid_add_isom
  fixes hom :: "'a => 'b"
  assumes "comm_monoid_add_isom hom"
class conjugatable_ordered_ring = conjugatable_ring +
  ordered_comm_monoid_add +
  assumes "conjugate_square_positive": "!!a. (0::'a) <= a * conjugate a"
locale semiring_isom
  fixes hom :: "'a => 'b"
  assumes "semiring_isom hom"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale comm_semiring_isom
  fixes hom :: "'a => 'b"
  assumes "comm_semiring_isom hom"
consts
  fold_map :: "('a => 'b Heap) => 'a list => 'b list Heap"
Found termination order: "size <*mlex*> {}"
locale ring_isom
  fixes hom :: "'a => 'b"
  assumes "ring_isom hom"
### Cannot skip proof of schematic goal statement
Found termination order: "size <*mlex*> {}"
### theory "HOL-Imperative_HOL.Heap_Monad"
### 1.651s elapsed time, 6.529s cpu time, 0.562s GC time
Loading theory "HOL-Imperative_HOL.Array" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run" via "HOL-Imperative_HOL.Imperative_HOL")
locale comm_ring_isom
  fixes hom :: "'a => 'b"
  assumes "comm_ring_isom hom"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
### theory "HOL-Imperative_HOL.Array"
### 0.385s elapsed time, 1.522s cpu time, 0.139s GC time
Loading theory "HOL-Imperative_HOL.Ref" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run" via "HOL-Imperative_HOL.Imperative_HOL")
locale idom_isom
  fixes hom :: "'a => 'b"
  assumes "idom_isom hom"
Found termination order: "size_list size <*mlex*> {}"
### Ambiguous input (line 211 of "~~/src/HOL/Imperative_HOL/Ref.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Ref.lookup" ("_thenM" ("_position" r) ("_position" f)))
###     ("_position" f)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_thenM" ("\<^const>Ref.lookup" ("_position" r)) ("_position" f))
###     ("_position" f)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 215 of "~~/src/HOL/Imperative_HOL/Ref.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Ref.update" ("_position" r)
###     ("\<^const>HOL.eq" ("_position" e)
###       ("_thenM"
###         ("_applC" ("_position" change)
###           ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###             ("_position" r)))
###         ("_applC" ("_position" return) ("\<^const>Product_Type.Unity"))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^const>Ref.update" ("_position" r) ("_position" e))
###     ("_thenM"
###       ("_applC" ("_position" change)
###         ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###           ("_position" r)))
###       ("_applC" ("_position" return) ("\<^const>Product_Type.Unity")))))
### ("\<^const>HOL.Trueprop"
###   ("_thenM"
###     ("\<^const>Ref.update" ("_position" r)
###       ("\<^const>HOL.eq" ("_position" e)
###         ("_applC" ("_position" change)
###           ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###             ("_position" r)))))
###     ("_applC" ("_position" return) ("\<^const>Product_Type.Unity"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "HOL-Imperative_HOL.Ref"
### 0.241s elapsed time, 0.950s cpu time, 0.140s GC time
Loading theory "HOL-Imperative_HOL.Imperative_HOL" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Run")
locale field_isom
  fixes hom :: "'a => 'b"
  assumes "field_isom hom"
### theory "HOL-Imperative_HOL.Imperative_HOL"
### 0.030s elapsed time, 0.115s cpu time, 0.000s GC time
Loading theory "Separation_Logic_Imperative_HOL.Imperative_HOL_Add" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Assertions")
### theory "Separation_Logic_Imperative_HOL.Imperative_HOL_Add"
### 0.047s elapsed time, 0.191s cpu time, 0.000s GC time
Loading theory "Separation_Logic_Imperative_HOL.Run" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple")
consts
  is_exn :: "'a option => bool"
### No equation for constructor "None"
consts
  the_state :: "'a option => 'a"
Proofs for inductive predicate(s) "run"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
### theory "Separation_Logic_Imperative_HOL.Run"
### 0.327s elapsed time, 1.288s cpu time, 0.142s GC time
Loading theory "ROBDD.Option_Helpers" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl" via "ROBDD.Abstract_Impl")
Found termination order: "size <*mlex*> {}"
instantiation
  complex :: conjugatable_ordered_field
  conjugate_complex == conjugate :: complex => complex
consts
  oassert :: "bool => unit option"
instantiation
  real :: conjugatable_ordered_field
  conjugate_real == conjugate :: real => real
consts
  ospec :: "'a option => ('a => bool) => bool"
instantiation
  rat :: conjugatable_ordered_field
  conjugate_rat == conjugate :: rat => rat
instantiation
  int :: conjugatable_ordered_ring
  conjugate_int == conjugate :: int => int
### theory "Jordan_Normal_Form.Conjugate"
### 3.180s elapsed time, 12.552s cpu time, 1.165s GC time
Loading theory "ROBDD.Pointer_Map" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl")
Found termination order: "size <*mlex*> {}"
locale inj_idom_divide_hom
  fixes hom :: "'a => 'b"
  assumes "inj_idom_divide_hom hom"
### theory "ROBDD.Option_Helpers"
### 0.168s elapsed time, 0.662s cpu time, 0.069s GC time
Loading theory "Separation_Logic_Imperative_HOL.Syntax_Match" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple" via "Separation_Logic_Imperative_HOL.Assertions")
locale field_hom
  fixes hom :: "'a => 'b"
  assumes "field_hom hom"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
### ML warning (line 40 of "$AFP/Separation_Logic_Imperative_HOL/Tools/Syntax_Match.thy"):
### Pattern is not exhaustive.
### ML warning (line 53 of "$AFP/Separation_Logic_Imperative_HOL/Tools/Syntax_Match.thy"):
### Pattern is not exhaustive.
structure Syntax_Match:
  sig
    val fo_nomatch_simproc: Proof.context -> cterm -> thm option
    val fo_nomatch_thm: thm
    val nomatch_simproc: Proof.context -> cterm -> thm option
    val nomatch_thm: thm
  end
locale ac_operator
  fixes f :: "'a => 'a => 'a"
  assumes "ac_operator f"
### theory "Separation_Logic_Imperative_HOL.Syntax_Match"
### 0.070s elapsed time, 0.286s cpu time, 0.000s GC time
Loading theory "Separation_Logic_Imperative_HOL.Assertions" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation" via "Separation_Logic_Imperative_HOL.Hoare_Triple")
Found termination order: "size_list size <*mlex*> {}"
### theory "ROBDD.BDT"
### 2.439s elapsed time, 9.611s cpu time, 0.986s GC time
Loading theory "Draft.MkIfex" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive")
### theory "ROBDD.Pointer_Map"
### 0.363s elapsed time, 1.432s cpu time, 0.167s GC time
Loading theory "ROBDD.Abstract_Impl" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Middle_Impl")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Polynomial_Interpolation.Ring_Hom"
### 3.291s elapsed time, 12.988s cpu time, 1.227s GC time
Loading theory "Jordan_Normal_Form.Matrix" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex" via "Draft.Boolean_functions")
### theory "Draft.MkIfex"
### 0.142s elapsed time, 0.574s cpu time, 0.000s GC time
Loading theory "Word_Lib.More_Arithmetic" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit" via "Word_Lib.More_Word")
### theory "Word_Lib.More_Arithmetic"
### 0.097s elapsed time, 0.371s cpu time, 0.127s GC time
Loading theory "Word_Lib.More_Word" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit")
Found termination order: "{}"
instantiation
  assn :: one
  one_assn == one_class.one :: assn
Found termination order: "{}"
instantiation
  assn :: times
  times_assn == times :: assn => assn => assn
Found termination order: "{}"
instantiation
  assn :: comm_monoid_mult
Found termination order: "{}"
instantiation
  assn :: boolean_algebra
  minus_assn == minus :: assn => assn => assn
  uminus_assn == uminus :: assn => assn
  bot_assn == bot :: assn
  top_assn == top :: assn
  inf_assn == inf :: assn => assn => assn
  sup_assn == sup :: assn => assn => assn
  less_eq_assn == less_eq :: assn => assn => bool
  less_assn == less :: assn => assn => bool
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
locale bdd_impl_pre
  fixes R :: "'s => ('ni * 'a ifex) set"
    and I :: "'s => bool"
locale bdd_impl
  fixes I :: "'s => bool"
    and R :: "'s => ('ni * 'a ifex) set"
    and Timpl :: "'s => ('ni * 's) option"
    and Fimpl :: "'s => ('ni * 's) option"
    and IFimpl :: "'a => 'ni => 'ni => 's => ('ni * 's) option"
    and DESTRimpl :: "'ni => 's => ('a, 'ni) IFEXD option"
  assumes "bdd_impl I R Timpl Fimpl IFimpl DESTRimpl"
instantiation
  vec :: (plus) plus
  plus_vec == plus :: 'a vec => 'a vec => 'a vec
instantiation
  vec :: (minus) minus
  minus_vec == minus :: 'a vec => 'a vec => 'a vec
### theory "Separation_Logic_Imperative_HOL.Assertions"
### 1.534s elapsed time, 6.037s cpu time, 0.784s GC time
Loading theory "Separation_Logic_Imperative_HOL.Hoare_Triple" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main" via "Separation_Logic_Imperative_HOL.Automation")
consts
  lowest_tops_impl :: "'ni list => 's => ('a option * 's) option"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  vec :: (uminus) uminus
  uminus_vec == uminus :: 'a vec => 'a vec
### theory "Word_Lib.More_Word"
### 1.413s elapsed time, 5.555s cpu time, 0.698s GC time
Loading theory "Word_Lib.Bit_Shifts_Infix_Syntax" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Generic_set_bit" via "Word_Lib.Most_significant_bit")
locale bdd_impl_cmp_pre
  fixes R :: "'a => ('b * 'c ifex) set"
    and I :: "'a => bool"
instantiation
  vec :: (ord) ord
  less_eq_vec == less_eq :: 'a vec => 'a vec => bool
  less_vec == less :: 'a vec => 'a vec => bool
locale bdd_impl_cmp
  fixes I :: "'a => bool"
    and R :: "'a => ('b * 'c ifex) set"
    and Timpl :: "'a => ('b * 'a) option"
    and Fimpl :: "'a => ('b * 'a) option"
    and IFimpl :: "'c => 'b => 'b => 'a => ('b * 'a) option"
    and DESTRimpl :: "'b => 'a => ('c, 'b) IFEXD option"
    and M :: "'a => 'b * 'b * 'b => 'b option"
    and U :: "'a => 'b * 'b * 'b => 'b => 'a"
    and cmp :: "'b => 'b => bool"
  assumes "bdd_impl_cmp I R Timpl Fimpl IFimpl DESTRimpl M U cmp"
instantiation
  vec :: (preorder) preorder
instantiation
  vec :: (order) order
### theory "Separation_Logic_Imperative_HOL.Hoare_Triple"
### 0.438s elapsed time, 1.713s cpu time, 0.207s GC time
Loading theory "Separation_Logic_Imperative_HOL.Automation" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit" via "Separation_Logic_Imperative_HOL.Sep_Main")
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Found termination order: "{}"
Found termination order: "{}"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
### theory "ROBDD.Abstract_Impl"
### 2.165s elapsed time, 8.517s cpu time, 1.063s GC time
Loading theory "ROBDD.Middle_Impl" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl")
instantiation
  mat :: (ord) ord
  less_eq_mat == less_eq :: 'a mat => 'a mat => bool
  less_mat == less :: 'a mat => 'a mat => bool
instantiation
  mat :: (preorder) preorder
instantiation
  mat :: (order) order
instantiation
  mat :: (plus) plus
  plus_mat == plus :: 'a mat => 'a mat => 'a mat
instantiation
  mat :: (uminus) uminus
  uminus_mat == uminus :: 'a mat => 'a mat
instantiation
  mat :: (minus) minus
  minus_mat == minus :: 'a mat => 'a mat => 'a mat
instantiation
  mat :: (semiring_0) times
  times_mat == times :: 'a mat => 'a mat => 'a mat
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
### ML warning (line 401 of "$AFP/Separation_Logic_Imperative_HOL/Automation.thy"):
### Pattern is not exhaustive.
### ML warning (line 407 of "$AFP/Separation_Logic_Imperative_HOL/Automation.thy"):
### Pattern is not exhaustive.
### ML warning (line 418 of "$AFP/Separation_Logic_Imperative_HOL/Automation.thy"):
### Matches are not exhaustive.
### ML warning (line 424 of "$AFP/Separation_Logic_Imperative_HOL/Automation.thy"):
### Matches are not exhaustive.
### ML warning (line 489 of "$AFP/Separation_Logic_Imperative_HOL/Automation.thy"):
### Handler catches all exceptions.
infix 1 THEN_IGNORE_NEWGOALS
structure Seplogic_Auto:
  sig
    val REPEAT_DETERM': ('a -> tactic) -> 'a -> thm -> thm Seq.seq
    val THEN_IGNORE_NEWGOALS:
       (int -> tactic) * (int -> thm -> thm Seq.seq) ->
         int -> thm -> thm Seq.seq
    val assn_simproc: simproc
    val assn_simproc_fun: Proof.context -> cterm -> thm option
    val decon_modifiers:
       (Token.T list -> Method.modifier * Token.T list) list
    val dflt_simps_modifiers:
       (Token.T list -> Method.modifier * Token.T list) list
    val dflt_tac: Proof.context -> int -> tactic
    val dfs_opr:
       string ->
         ('a -> term -> 'a * term option) -> 'a -> term -> 'a * term option
    val dfs_replace_atomic: string -> term -> term -> term -> term option
    val eintros_modifiers:
       (Token.T list -> Method.modifier * Token.T list) list
    val extract_ex_tac: Proof.context -> int -> thm -> thm Seq.seq
    val find_similar: (term -> term) -> term list -> (term * term) option
    val frame_inference_tac: Proof.context -> int -> tactic
    val heap_modifiers:
       (Token.T list -> Method.modifier * Token.T list) list
    val heap_rule_tac: Proof.context -> thm list -> int -> tactic
    val match_frame_tac: (int -> tactic) -> Proof.context -> int -> tactic
    val sep_auto_modifiers: Method.modifier parser list
    val sep_autosolve_tac:
       bool -> bool -> Proof.context -> int -> thm -> thm Seq.seq
    val solve_entails_modifiers:
       (Token.T list -> Method.modifier * Token.T list) list
    val solve_entails_tac: Proof.context -> int -> tactic
    val tr_term: term -> string
    val vcg_modifiers: (Token.T list -> Method.modifier * Token.T list) list
    val vcg_step_tac: Proof.context -> int -> tactic
    val vcg_tac: Proof.context -> int -> thm -> thm Seq.seq
  end
### Cannot skip proof of schematic goal statement
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
### theory "Separation_Logic_Imperative_HOL.Automation"
### 0.940s elapsed time, 3.677s cpu time, 0.424s GC time
Loading theory "Separation_Logic_Imperative_HOL.Sep_Main" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List" via "Separation_Logic_Imperative_HOL.Array_Blit")
### theory "Separation_Logic_Imperative_HOL.Sep_Main"
### 0.044s elapsed time, 0.168s cpu time, 0.043s GC time
Loading theory "Separation_Logic_Imperative_HOL.Array_Blit" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "ROBDD.Array_List")
### theory "Word_Lib.Bit_Shifts_Infix_Syntax"
### 1.196s elapsed time, 4.668s cpu time, 0.535s GC time
Loading theory "Separation_Logic_Imperative_HOL.Imp_Map_Spec" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl")
Found termination order: "{}"
locale imp_map
  fixes is_map :: "('k => 'v option) => 'm => assn"
  assumes "imp_map is_map"
locale imp_map_empty
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and empty :: "'m Heap"
  assumes "imp_map_empty is_map empty"
locale imp_map_is_empty
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and is_empty :: "'m => bool Heap"
  assumes "imp_map_is_empty is_map is_empty"
Found termination order: "{}"
locale imp_map_lookup
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and lookup :: "'k => 'm => 'v option Heap"
  assumes "imp_map_lookup is_map lookup"
locale imp_map_update
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and update :: "'k => 'v => 'm => 'm Heap"
  assumes "imp_map_update is_map update"
locale imp_map_delete
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and delete :: "'k => 'm => 'm Heap"
  assumes "imp_map_delete is_map delete"
Found termination order: "{}"
locale imp_map_add
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and add :: "'m => 'm => 'm Heap"
  assumes "imp_map_add is_map add"
locale imp_map_size
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and size :: "'m => nat Heap"
  assumes "imp_map_size is_map size"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale imp_map_iterate
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and
    is_it :: "('k => 'v option) => 'm => ('k => 'v option) => 'it => assn"
    and it_init :: "'m => 'it Heap"
    and it_has_next :: "'it => bool Heap"
    and it_next :: "'it => (('k * 'v) * 'it) Heap"
  assumes "imp_map_iterate is_map is_it it_init it_has_next it_next"
Found termination order: "{}"
locale imp_map_iterate'
  fixes is_map :: "('k => 'v option) => 'm => assn"
    and is_it :: "('k => 'v option) => 'm => ('k * 'v) list => 'it => assn"
    and it_init :: "'m => 'it Heap"
    and it_has_next :: "'it => bool Heap"
    and it_next :: "'it => (('k * 'v) * 'it) Heap"
  assumes "imp_map_iterate' is_map is_it it_init it_has_next it_next"
### theory "Separation_Logic_Imperative_HOL.Imp_Map_Spec"
### 0.199s elapsed time, 0.788s cpu time, 0.059s GC time
Loading theory "Word_Lib.Least_significant_bit" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int")
consts
  blit :: "'a array => nat => 'a array => nat => nat => unit Heap"
### theory "Separation_Logic_Imperative_HOL.Array_Blit"
### 0.465s elapsed time, 1.826s cpu time, 0.186s GC time
Loading theory "Word_Lib.Most_significant_bit" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Generic_set_bit")
class msb = type +
  fixes msb :: "'a => bool"
instantiation
  int :: msb
  msb_int == msb :: int => bool
instantiation
  word :: (len) msb
  msb_word == msb :: 'a word => bool
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### Ignoring duplicate rewrite rule:
### Rmi_g (Suc (Suc ?va1)) Trueif ?uw1 == False
### theory "Word_Lib.Most_significant_bit"
### 0.151s elapsed time, 0.594s cpu time, 0.048s GC time
Loading theory "Word_Lib.Generic_set_bit" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int")
Found termination order: "length <*mlex*> {}"
class lsb = semiring_bits +
  fixes lsb :: "'a => bool"
  assumes "lsb_odd": "lsb = odd"
instantiation
  int :: lsb
  lsb_int == lsb :: int => bool
instantiation
  word :: (len) lsb
  lsb_word == lsb :: 'a word => bool
### theory "Word_Lib.Least_significant_bit"
### 0.632s elapsed time, 2.456s cpu time, 0.347s GC time
val mk_2elem_list = fn: term -> term -> term
val mk_compr = fn: term -> term -> term
val test1 = "[1, 2]": cterm
val test2 = "{x: {1, 2, 3}. 2 < x}": cterm
val test3 =
   Const ("Groups.plus_class.plus", "nat => nat => nat") $ Bound 0 $
     Bound 0:
   term
val dest_pair_singleton = fn: term -> term
val dest_nat_pair_singleton = fn: term -> term * term
val dest_pair_singleton_T = fn: term -> (term * typ) * (term * typ)
val dest_pair_lambda = fn: term -> string * typ * string * typ * term * term
val foo = fn: term -> term * term * int * term * term
"True"
  :: "bool"
\<Sqinter> (Sup ` ?A) = \<Squnion> (Inf ` {f ` ?A |f. ALL Y:?A. f Y : Y})
(0 < length ?xs) = (?xs ~= [])
"(bij, bij_betw, permutation)"
  :: "(('a => 'b) => bool) *
      (('c => 'd) => 'c set => 'd set => bool) * (('e => 'e) => bool)"
carrier (| carrier = ?carrier, ... = ?more |) = ?carrier
partial_object.more (| carrier = ?carrier, ... = ?more |) = ?more
carrier_update ?carrier' (| carrier = ?carrier, ... = ?more |) =
(| carrier = ?carrier' ?carrier, ... = ?more |)
partial_object.more_update ?more' (| carrier = ?carrier, ... = ?more |) =
(| carrier = ?carrier, ... = ?more' ?more |)
(\<otimes>\<^bsub>(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |)\<^esub>) =
?mult
\<one>\<^bsub>(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |)\<^esub> =
?one
monoid.more
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
?more
mult_update ?mult'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult' ?mult, one = ?one, ... = ?more |)
one_update ?one'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult, one = ?one' ?one, ... = ?more |)
monoid.more_update ?more'
 (| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more |) =
(| carrier = ?carrier, mult = ?mult, one = ?one, ... = ?more' ?more |)
"merge"
  :: "'a"
Array.update ?a ?i ?x ?h = Array.set ?a ((Array.get ?h ?a)[?i := ?x]) ?h
[| distinct ?xs; ?i < length ?xs; ?j < length ?xs |]
==> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)
(EX x xa. ?P \<Longrightarrow>\<^sub>A ?Q1 x xa) -->
(?P \<Longrightarrow>\<^sub>A \<exists>\<^sub>Ax xa. ?Q1 x xa)
?i < length ?xs ==>
<?a \<mapsto>\<^sub>a ?xs> Array.nth ?a ?i
<%r. ?a \<mapsto>\<^sub>a ?xs * \<up> (r = ?xs ! ?i)>
?P (case ?nat of 0 => ?f1.0 | Suc x => ?f2.0 x) =
((?nat = 0 --> ?P ?f1.0) & (ALL x2. ?nat = Suc x2 --> ?P (?f2.0 x2)))
[| !!bdd. ?P 0 Falseif bdd; !!bdd. ?P (Suc 0) Trueif bdd;
   !!n v t e bdd.
      [| !!x y xa ya.
            [| (x, y) = pm_pth (dpm bdd) n; (xa, ya) = y |] ==> ?P xa t bdd;
         !!x y xa ya.
            [| (x, y) = pm_pth (dpm bdd) n; (xa, ya) = y |]
            ==> ?P ya e bdd |]
      ==> ?P (Suc (Suc n)) (IF v t e) bdd;
   !!va uw_. ?P (Suc (Suc va)) Trueif uw_;
   !!va uw_. ?P (Suc (Suc va)) Falseif uw_; !!v uw_. ?P (Suc v) Falseif uw_;
   !!va vb vc uw_. ?P (Suc 0) (IF va vb vc) uw_; !!uw_. ?P 0 Trueif uw_;
   !!va uw_. ?P (Suc (Suc va)) Trueif uw_;
   !!v va vb uw_. ?P 0 (IF v va vb) uw_;
   !!v va vb uw_. ?P (Suc 0) (IF v va vb) uw_ |]
==> ?P ?a0.0 ?a1.0 ?a2.0
locale semiring_hom
  fixes hom :: "'a => 'b"
  assumes "semiring_hom hom"
### theory "ROBDD.Middle_Impl"
### 1.580s elapsed time, 6.166s cpu time, 0.758s GC time
class set_bit = semiring_bits +
  fixes set_bit :: "'a => nat => bool => 'a"
  assumes
    "bit_set_bit_iff_2n":
      "!!a m b n.
          bit (set_bit_class.set_bit a m b) n =
          ((if m = n then b else bit a n) & (2::'a) ^ n ~= (0::'a))"
instantiation
  int :: set_bit
  set_bit_int == set_bit_class.set_bit :: int => nat => bool => int
instantiation
  word :: (len) set_bit
  set_bit_word == set_bit_class.set_bit :: 'a word => nat => bool => 'a word
### theory "Word_Lib.Generic_set_bit"
### 0.656s elapsed time, 2.310s cpu time, 0.399s GC time
Loading theory "Native_Word.Code_Symbolic_Bits_Int" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
instantiation
  vec :: (conjugate) conjugate
  conjugate_vec == conjugate :: 'a vec => 'a vec
### theory "Jordan_Normal_Form.Matrix"
### 4.070s elapsed time, 15.580s cpu time, 1.912s GC time
Loading theory "Draft.Boolean_functions" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func" via "Draft.Simplicial_complex")
locale boolean_functions
  fixes n :: "nat"
locale boolean_functions
  fixes n :: "nat"
### theory "Draft.Boolean_functions"
### 0.098s elapsed time, 0.204s cpu time, 0.000s GC time
Loading theory "Draft.Simplicial_complex" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive" via "Draft.Bij_betw_simplicial_complex_bool_func")
locale simplicial_complex
  fixes n :: "nat"
instantiation
  bool :: {one,zero}
  zero_bool == zero_class.zero :: bool
  one_bool == one_class.one :: bool
locale simplicial_complex
  fixes n :: "nat"
### theory "Native_Word.Code_Symbolic_Bits_Int"
### 0.459s elapsed time, 1.098s cpu time, 0.117s GC time
Loading theory "Native_Word.Bits_Integer" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "ROBDD.Level_Collapse" via "ROBDD.Conc_Impl" via "ROBDD.Pointer_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map_Impl" via "Separation_Logic_Imperative_HOL.Hash_Map" via "Separation_Logic_Imperative_HOL.Hash_Table" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
locale simplicial_complex
  fixes n :: "nat"
### theory "Draft.Simplicial_complex"
### 0.368s elapsed time, 0.772s cpu time, 0.096s GC time
Loading theory "Draft.Bij_betw_simplicial_complex_bool_func" (required by "Draft.BDDMoreTemplates" via "Draft.BDD" via "Draft.Evasive")
locale simplicial_complex
  fixes n :: "nat"
### theory "Draft.Bij_betw_simplicial_complex_bool_func"
### 0.079s elapsed time, 0.159s cpu time, 0.000s GC time
Loading theory "Draft.Evasive" (required by "Draft.BDDMoreTemplates" via "Draft.BDD")
instantiation
  integer :: lsb
  lsb_integer == lsb :: integer => bool
instantiation
  integer :: msb
  msb_integer == msb :: integer => bool
instantiation
  integer :: set_bit
  set_bit_integer == set_bit_class.set_bit ::
    integer => nat => bool => integer
### Code generator: dropping subsumed code equation
### not ?k == - ?k - 1
### Code generator: dropping subsumed code equation
### and ?k ?l ==
### if ?k = 0 | ?l = 0 then 0
### else if ?k = - 1 then ?l
###      else if ?l = - 1 then ?k
###           else ?k mod 2 * (?l mod 2) + 2 * and (?k div 2) (?l div 2)
### Code generator: dropping subsumed code equation
### or ?k ?l ==
### if ?k = - 1 | ?l = - 1 then - 1
### else if ?k = 0 then ?l
###      else if ?l = 0 then ?k
###           else max (?k mod 2) (?l mod 2) + 2 * or (?k div 2) (?l div 2)
### Code generator: dropping subsumed code equation
### xor ?k ?l ==
### if ?k = - 1 then not ?l
### else if ?l = - 1 then not ?k
###      else if ?k = 0 then ?l
###           else if ?l = 0 then ?k
###                else \<bar>?k mod 2 - ?l mod 2\<bar> +
###                     2 * xor (?k div 2) (?l div 2)
Found termination order: "size <*mlex*> {}"
### theory "Draft.Evasive"
### 0.402s elapsed time, 0.856s cpu time, 0.093s GC time
### theory "Native_Word.Bits_Integer"
### 0.799s elapsed time, 1.575s cpu time, 0.183s GC time
*** Failed to load theory "ROBDD.Array_List" (unresolved "Separation_Logic_Imperative_HOL.Array_Blit")
*** Failed to load theory "Native_Word.Code_Target_Bits_Int" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Collections.Code_Target_ICF" (unresolved "Native_Word.Code_Target_Bits_Int")
*** Failed to load theory "Native_Word.Code_Target_Word_Base" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Native_Word.Word_Type_Copies" (unresolved "Native_Word.Code_Target_Word_Base")
*** Failed to load theory "Native_Word.Uint32" (unresolved "Native_Word.Code_Target_Word_Base", "Native_Word.Word_Type_Copies")
*** Failed to load theory "Collections.HashCode" (unresolved "Native_Word.Uint32")
*** Failed to load theory "Separation_Logic_Imperative_HOL.Hash_Table" (unresolved "Collections.Code_Target_ICF", "Collections.HashCode")
*** Failed to load theory "Separation_Logic_Imperative_HOL.Hash_Map" (unresolved "Separation_Logic_Imperative_HOL.Hash_Table")
*** Failed to load theory "Separation_Logic_Imperative_HOL.Hash_Map_Impl" (unresolved "Separation_Logic_Imperative_HOL.Hash_Map")
*** Failed to load theory "ROBDD.Pointer_Map_Impl" (unresolved "ROBDD.Array_List", "Separation_Logic_Imperative_HOL.Hash_Map_Impl")
*** Failed to load theory "ROBDD.Conc_Impl" (unresolved "ROBDD.Pointer_Map_Impl")
*** Failed to load theory "ROBDD.Level_Collapse" (unresolved "ROBDD.Conc_Impl")
*** Failed to load theory "Draft.BDD" (unresolved "ROBDD.Level_Collapse")
*** Failed to load theory "Draft.BDDMoreTemplates" (unresolved "Draft.BDD")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "4")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 653 of "$AFP/Native_Word/Bits_Integer.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "2")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 166 of "$AFP/Separation_Logic_Imperative_HOL/Examples/Array_Blit.thy")
Exception- TOPLEVEL_ERROR raised
