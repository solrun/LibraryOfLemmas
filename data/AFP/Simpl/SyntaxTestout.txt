Loading theory "Draft.Simpl_Heap" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.HeapList")
Loading theory "Draft.Language" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps" via "Draft.HoarePartialDef" via "Draft.Semantic")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.SyntaxTestTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.SyntaxTestTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "Draft.Simpl_Heap"
### 0.068s elapsed time, 0.295s cpu time, 0.000s GC time
Loading theory "Draft.HeapList" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest")
consts
  Path :: "ref => (ref => ref) => ref => ref list => bool"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.140s elapsed time, 0.576s cpu time, 0.077s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.SyntaxTestTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### theory "Draft.HeapList"
### 0.144s elapsed time, 0.563s cpu time, 0.077s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.SyntaxTestTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Nat_Bijection"
### 0.297s elapsed time, 1.202s cpu time, 0.077s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.SyntaxTestTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.Set_Algebras"
### 0.162s elapsed time, 0.642s cpu time, 0.000s GC time
Loading theory "Draft.Generalise" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg")
### ML warning (line 109 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 98 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 223 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 212 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 201 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 186 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 227 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 228 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 230 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 233 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 242 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 190 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 191 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 194 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 198 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 168 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 169 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 171 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 174 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 183 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 214 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 215 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 203 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 204 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 163 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
signature SPLIT_STATE =
  sig
    val abs_state: term -> term option
    val abs_var: Proof.context -> term -> string * typ
    val ex_tac: Proof.context -> term list -> tactic
    val isState: term -> bool
    val split_state:
       Proof.context -> string -> typ -> term -> term * term list
  end
functor GeneraliseFun (sig structure SplitState: SPLIT_STATE end): 
  sig
    val GENERALISE: Proof.context -> int -> tactic
    val OF_RAW: thm * thm -> thm
    val SIMPLE_OF: Proof.context -> thm -> thm list -> thm
    val SIMPLE_OF_RAW: Proof.context -> thm -> thm -> thm
    val conc_of: thm -> term
    val decomp:
       Proof.context ->
         term * cterm -> term list * cterm list * (thm list -> thm)
    val dest_All: term -> term
    val dest_prop: term -> term
    val eta_expand: Proof.context -> cterm -> cterm
    val genAll: thm
    val genAllShift: thm
    val genConj: thm
    val genEx: thm
    val genImp: thm
    val genImpl: thm
    val genRefl: thm
    val genRefl': thm
    val genTrans: thm
    val gen_all: thm
    val gen_allShift: thm
    val gen_thm:
       ('a * 'b -> 'a list * 'b list * ('c list -> 'c)) -> 'a * 'b -> 'c
    val generalise: Proof.context -> cterm -> thm
    val generalise_over_all_states_tac: Proof.context -> int -> tactic
    val generalise_over_tac:
       Proof.context -> (term -> term option) -> int -> thm -> thm Seq.seq
    val generalise_tac: Proof.context -> int -> thm -> thm Seq.seq
    val init: cterm -> thm
    val list_exists: (string * typ) list * term -> term
    val meta_spec: thm
    val prem_of: thm -> term
    val protectImp: thm
    val protectRefl: thm
    datatype qantifier = Hol_all | Hol_ex | Meta_all
    val spec': cterm -> thm -> thm
    val split_abs:
       Proof.context -> cterm -> (string * typ * term) * (cterm * cterm)
    val split_thm:
       qantifier -> Proof.context -> string -> typ -> term -> thm
  end
### theory "Draft.Generalise"
### 0.261s elapsed time, 0.873s cpu time, 0.516s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.SyntaxTestTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Stream"
### 0.996s elapsed time, 3.771s cpu time, 0.785s GC time
### theory "HOL-Library.BigO"
### 0.745s elapsed time, 2.928s cpu time, 0.269s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 1.805s elapsed time, 5.695s cpu time, 0.981s GC time
Loading theory "Draft.Templates" (required by "Draft.SyntaxTestTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.050s elapsed time, 0.098s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.SyntaxTestTemplates")
consts
  switch ::
    "('s => 'v) => ('v set * ('s, 'p, 'f) com) list => ('s, 'p, 'f) com"
consts
  guards :: "('f * 's set) list => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  flatten :: "('s, 'p, 'f) com => ('s, 'p, 'f) com list"
consts
  sequence ::
    "(('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com)
     => ('s, 'p, 'f) com list => ('s, 'p, 'f) com"
consts
  normalize :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  strip_guards :: "'f set => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  mark_guards :: "'f => ('s, 'p, 'g) com => ('s, 'p, 'f) com"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.502s elapsed time, 1.040s cpu time, 0.068s GC time
### No equation for constructor "Skip"
### No equation for constructor "Basic"
### No equation for constructor "Spec"
### No equation for constructor "Seq"
### No equation for constructor "Cond"
### No equation for constructor "While"
### No equation for constructor "Call"
### No equation for constructor "DynCom"
### No equation for constructor "Throw"
### No equation for constructor "Catch"
consts
  dest_Guard :: "('s, 'p, 'f) com => 'f * 's set * ('s, 'p, 'f) com"
consts
  merge_guards :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  noguards :: "('s, 'p, 'f) com => bool"
consts
  nothrows :: "('s, 'p, 'f) com => bool"
Proofs for inductive predicate(s) "com_relp"
  Proving monotonicity ...
### Legacy feature! Old 'recdef' command -- use 'fun' or 'function' instead
Defining recursive function "Language.inter_guards" ...
Proving induction theorem ...
Postprocessing ...
Simplifying nested TCs ...
... Postprocessing finished
Proving unsplit equation...
th:
(Skip \<inter>\<^sub>g Skip) = None ==> (Skip \<inter>\<^sub>g Skip) = None
split ths:
(Skip \<inter>\<^sub>g Basic ?bc) = None
(Skip \<inter>\<^sub>g Spec ?bd) = None
(Skip \<inter>\<^sub>g Seq ?be ?bf) = None
(Skip \<inter>\<^sub>g Cond ?bg ?bh ?bi) = None
(Skip \<inter>\<^sub>g While ?bj ?bk) = None
(Skip \<inter>\<^sub>g Call ?bl) = None
(Skip \<inter>\<^sub>g DynCom ?bm) = None
(Skip \<inter>\<^sub>g Guard ?bn ?bo ?bp) = None
(Skip \<inter>\<^sub>g Throw) = None
(Skip \<inter>\<^sub>g Catch ?bq ?br) = None
(Basic ?w \<inter>\<^sub>g Skip) = None
(Basic ?w \<inter>\<^sub>g Spec ?cj) = None
(Basic ?w \<inter>\<^sub>g Seq ?ck ?cl) = None
(Basic ?w \<inter>\<^sub>g Cond ?cm ?cn ?co) = None
(Basic ?w \<inter>\<^sub>g While ?cp ?cq) = None
(Basic ?w \<inter>\<^sub>g Call ?cr) = None
(Basic ?w \<inter>\<^sub>g DynCom ?cs) = None
(Basic ?w \<inter>\<^sub>g Guard ?ct ?cu ?cv) = None
(Basic ?w \<inter>\<^sub>g Throw) = None
(Basic ?w \<inter>\<^sub>g Catch ?cw ?cx) = None
(Spec ?x \<inter>\<^sub>g Skip) = None
(Spec ?x \<inter>\<^sub>g Basic ?do) = None
(Spec ?x \<inter>\<^sub>g Seq ?dq ?dr) = None
(Spec ?x \<inter>\<^sub>g Cond ?ds ?dt ?du) = None
(Spec ?x \<inter>\<^sub>g While ?dv ?dw) = None
(Spec ?x \<inter>\<^sub>g Call ?dx) = None
(Spec ?x \<inter>\<^sub>g DynCom ?dy) = None
(Spec ?x \<inter>\<^sub>g Guard ?dz ?ea ?eb) = None
(Spec ?x \<inter>\<^sub>g Throw) = None
(Spec ?x \<inter>\<^sub>g Catch ?ec ?ed) = None
(Seq ?y ?z \<inter>\<^sub>g Skip) = None
(Seq ?y ?z \<inter>\<^sub>g Basic ?ev) = None
(Seq ?y ?z \<inter>\<^sub>g Spec ?ew) = None
(Seq ?y ?z \<inter>\<^sub>g Cond ?ez ?fa ?fb) = None
(Seq ?y ?z \<inter>\<^sub>g While ?fc ?fd) = None
(Seq ?y ?z \<inter>\<^sub>g Call ?fe) = None
(Seq ?y ?z \<inter>\<^sub>g DynCom ?ff) = None
(Seq ?y ?z \<inter>\<^sub>g Guard ?fg ?fh ?fi) = None
(Seq ?y ?z \<inter>\<^sub>g Throw) = None
(Seq ?y ?z \<inter>\<^sub>g Catch ?fj ?fk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Skip) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Basic ?gb) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Spec ?gc) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Seq ?gd ?ge) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g While ?gi ?gj) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Call ?gk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g DynCom ?gl) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Guard ?gm ?gn ?go) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Throw) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Catch ?gp ?gq) = None
(While ?ad ?ae \<inter>\<^sub>g Skip) = None
(While ?ad ?ae \<inter>\<^sub>g Basic ?hh) = None
(While ?ad ?ae \<inter>\<^sub>g Spec ?hi) = None
(While ?ad ?ae \<inter>\<^sub>g Seq ?hj ?hk) = None
(While ?ad ?ae \<inter>\<^sub>g Cond ?hl ?hm ?hn) = None
(While ?ad ?ae \<inter>\<^sub>g Call ?hq) = None
(While ?ad ?ae \<inter>\<^sub>g DynCom ?hr) = None
(While ?ad ?ae \<inter>\<^sub>g Guard ?hs ?ht ?hu) = None
(While ?ad ?ae \<inter>\<^sub>g Throw) = None
(While ?ad ?ae \<inter>\<^sub>g Catch ?hv ?hw) = None
(Call ?af \<inter>\<^sub>g Skip) = None
(Call ?af \<inter>\<^sub>g Basic ?in) = None
(Call ?af \<inter>\<^sub>g Spec ?io) = None
(Call ?af \<inter>\<^sub>g Seq ?ip ?iq) = None
(Call ?af \<inter>\<^sub>g Cond ?ir ?is ?it) = None
(Call ?af \<inter>\<^sub>g While ?iu ?iv) = None
(Call ?af \<inter>\<^sub>g DynCom ?ix) = None
(Call ?af \<inter>\<^sub>g Guard ?iy ?iz ?ja) = None
(Call ?af \<inter>\<^sub>g Throw) = None
(Call ?af \<inter>\<^sub>g Catch ?jb ?jc) = None
(DynCom ?ag \<inter>\<^sub>g Skip) = None
(DynCom ?ag \<inter>\<^sub>g Basic ?jt) = None
(DynCom ?ag \<inter>\<^sub>g Spec ?ju) = None
(DynCom ?ag \<inter>\<^sub>g Seq ?jv ?jw) = None
(DynCom ?ag \<inter>\<^sub>g Cond ?jx ?jy ?jz) = None
(DynCom ?ag \<inter>\<^sub>g While ?ka ?kb) = None
(DynCom ?ag \<inter>\<^sub>g Call ?kc) = None
(DynCom ?ag \<inter>\<^sub>g Guard ?ke ?kf ?kg) = None
(DynCom ?ag \<inter>\<^sub>g Throw) = None
(DynCom ?ag \<inter>\<^sub>g Catch ?kh ?ki) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Skip) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Basic ?kz) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Spec ?la) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Seq ?lb ?lc) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Cond ?ld ?le ?lf) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g While ?lg ?lh) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Call ?li) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g DynCom ?lj) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Throw) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Catch ?ln ?lo) = None
(Throw \<inter>\<^sub>g Skip) = None
(Throw \<inter>\<^sub>g Basic ?mf) = None
(Throw \<inter>\<^sub>g Spec ?mg) = None
(Throw \<inter>\<^sub>g Seq ?mh ?mi) = None
(Throw \<inter>\<^sub>g Cond ?mj ?mk ?ml) = None
(Throw \<inter>\<^sub>g While ?mm ?mn) = None
(Throw \<inter>\<^sub>g Call ?mo) = None
(Throw \<inter>\<^sub>g DynCom ?mp) = None
(Throw \<inter>\<^sub>g Guard ?mq ?mr ?ms) = None
(Throw \<inter>\<^sub>g Catch ?mt ?mu) = None
(Catch ?ak ?al \<inter>\<^sub>g Skip) = None
(Catch ?ak ?al \<inter>\<^sub>g Basic ?nl) = None
(Catch ?ak ?al \<inter>\<^sub>g Spec ?nm) = None
(Catch ?ak ?al \<inter>\<^sub>g Seq ?nn ?no) = None
(Catch ?ak ?al \<inter>\<^sub>g Cond ?np ?nq ?nr) = None
(Catch ?ak ?al \<inter>\<^sub>g While ?ns ?nt) = None
(Catch ?ak ?al \<inter>\<^sub>g Call ?nu) = None
(Catch ?ak ?al \<inter>\<^sub>g DynCom ?nv) = None
(Catch ?ak ?al \<inter>\<^sub>g Guard ?nw ?nx ?ny) = None
(Catch ?ak ?al \<inter>\<^sub>g Throw) = None
--
### recdef (solve_eq): splitto: cannot find variable to split on
Proofs for inductive predicate(s) "subseteq_guards"
  Proving monotonicity ...
### theory "Draft.Language"
### 3.866s elapsed time, 9.078s cpu time, 1.239s GC time
Loading theory "Draft.Semantic" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps" via "Draft.HoarePartialDef")
Proofs for inductive predicate(s) "exec"
  Proving monotonicity ...
Proofs for inductive predicate(s) "execn"
  Proving monotonicity ...
### theory "Draft.Semantic"
### 2.391s elapsed time, 3.539s cpu time, 1.339s GC time
Loading theory "Draft.HoarePartialDef" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps")
Loading theory "Draft.Termination" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps" via "Draft.SmallStep")
Proofs for inductive predicate(s) "terminates"
### Ambiguous input (line 84 of "$AFP/Simpl/HoarePartialDef.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_position" n)
###       ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###         ("_position" \<Theta>) ("_position" n) ("_position" F)
###         ("_position" P) ("_position" c) ("_position" Q) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_tuple"
###       ("\<^const>HOL.All_binder" ("_position" n) ("_position" \<Gamma>))
###       ("_tuple_arg"
###         ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###           ("_position" n) ("_position" F) ("_position" P) ("_position" c)
###           ("_position" Q) ("_position" A)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoarep"
  Proving monotonicity ...
### theory "Draft.HoarePartialDef"
### 0.326s elapsed time, 0.694s cpu time, 0.000s GC time
Loading theory "Draft.HoarePartialProps" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial")
### Ambiguous input (line 1078 of "$AFP/Simpl/HoarePartialProps.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.All_binder" ("_position" n)
###             ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###               ("_position" \<Theta>) ("_position" n) ("_position" F)
###               ("_position" P') ("_position" c) ("_position" Q')
###               ("_position" A')))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("_tuple"
###             ("\<^const>HOL.All_binder" ("_position" n)
###               ("_position" \<Gamma>))
###             ("_tuple_arg"
###               ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###                 ("_position" n) ("_position" F) ("_position" P')
###                 ("_position" c) ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Termination"
### 0.533s elapsed time, 1.141s cpu time, 0.106s GC time
Loading theory "Draft.HoareTotalDef" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps")
Loading theory "Draft.SmallStep" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps")
### No equation for constructor "Spec"
consts
  procs :: "('s, 'p, 'f) com => 'p set"
consts
  noSpec :: "('s, 'p, 'f) com => bool"
consts
  redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
Proofs for inductive predicate(s) "step"
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoaret"
  Proving monotonicity ...
### theory "Draft.HoarePartialProps"
### 0.597s elapsed time, 1.731s cpu time, 0.390s GC time
Loading theory "Draft.HoarePartial" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare")
### theory "Draft.HoareTotalDef"
### 0.523s elapsed time, 1.697s cpu time, 0.405s GC time
val tranclp_induct2 =
   "[| ?r^++ (?aa, ?ab) (?ba, ?bb); !!a b. ?r (?aa, ?ab) (a, b) ==> ?P a b;
       !!a b aa ba.
          [| ?r^++ (?aa, ?ab) (a, b); ?r (a, b) (aa, ba); ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  subst_redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
val trancl_induct2 =
   "[| ((?aa, ?ab), ?ba, ?bb) : ?r^+;
       !!a b. ((?aa, ?ab), a, b) : ?r ==> ?P a b;
       !!a b aa ba.
          [| ((?aa, ?ab), a, b) : ?r^+; ((a, b), aa, ba) : ?r; ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  seq :: "(nat => ('s, 'p, 'f) com) => 'p => nat => ('s, 'p, 'f) com"
### theory "Draft.HoarePartial"
### 1.087s elapsed time, 3.114s cpu time, 1.817s GC time
consts
  redexes :: "('s, 'p, 'f) com => ('s, 'p, 'f) com set"
### theory "Draft.SmallStep"
### 1.533s elapsed time, 4.410s cpu time, 2.102s GC time
Loading theory "Draft.HoareTotalProps" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal")
### theory "Draft.HoareTotalProps"
### 0.733s elapsed time, 0.922s cpu time, 0.252s GC time
Loading theory "Draft.HoareTotal" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare")
### theory "Draft.HoareTotal"
### 0.573s elapsed time, 0.692s cpu time, 0.158s GC time
Loading theory "Draft.Hoare" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg" via "Draft.StateSpace")
"\<Gamma>|-/F P c Q"
  :: "bool"
locale hoare
  fixes \<Gamma> :: "'p => ('s, 'p, 'f) com option"
"\<Gamma>|-P c Q"
  :: "bool"
"\<Gamma>|-P c Q,A"
  :: "bool"
"\<Gamma>|-/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>|-tP c Q"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^bsub>/F \<^esub>P c Q,A"
  :: "bool"
"\<Gamma>|-tP c Q,A"
  :: "bool"
"\<Gamma>|-t/F P c Q"
  :: "bool"
"\<Gamma>|-t/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-t/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^sub>t\<^bsub>/F\<^esub> P c Q,A"
  :: "bool"
consts
  assoc :: "('a * 'b) list => 'a => 'b"
### theory "Draft.Hoare"
### 0.185s elapsed time, 0.205s cpu time, 0.000s GC time
Loading theory "Draft.StateSpace" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest" via "Draft.Vcg")
### theory "Draft.StateSpace"
### 0.250s elapsed time, 0.250s cpu time, 0.000s GC time
Loading theory "Draft.Vcg" (required by "Draft.SyntaxTestTemplates" via "Draft.SyntaxTest")
### Ignoring duplicate rewrite rule:
### ~ ~ ?y == ?y
### Ignoring duplicate rewrite rule:
### (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
### Ignoring duplicate rewrite rule:
### ?P1 | ~ ?P1 == True
### Ignoring duplicate rewrite rule:
### ~ ?P1 | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?x1 = ?x1 == True
### Ignoring duplicate rewrite rule:
### ~ True == False
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### (~ ?P1) = ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 = (~ ?P1) == False
### Ignoring duplicate rewrite rule:
### True = ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y = True == ?y
### Ignoring duplicate rewrite rule:
### False = ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 = False == ~ ?P1
### Ignoring duplicate rewrite rule:
### True --> ?y == ?y
### Ignoring duplicate rewrite rule:
### False --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> True == True
### Ignoring duplicate rewrite rule:
### ?P1 --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> False == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 --> ~ ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?y & True == ?y
### Ignoring duplicate rewrite rule:
### True & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & False == False
### Ignoring duplicate rewrite rule:
### False & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 & ~ ?P1 == False
### Ignoring duplicate rewrite rule:
### ~ ?P1 & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 | True == True
### Ignoring duplicate rewrite rule:
### True | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?y | False == ?y
### Ignoring duplicate rewrite rule:
### False | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
### Ignoring duplicate rewrite rule:
### ALL x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 == True
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x == True
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x ~= ?t1 == False
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 ~= x == False
### ML warning (line 165 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 450 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 455 of "$AFP/Simpl/hoare.ML"):
### Value identifier (prf) has not been referenced.
### ML warning (line 472 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 469 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 628 of "$AFP/Simpl/hoare.ML"):
### Value identifier (default_state_kind) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare.ML"):
### Value identifier (generate_guard) has not been referenced.
### ML warning (line 897 of "$AFP/Simpl/hoare.ML"):
### Value identifier (less) has not been referenced.
### ML warning (line 902 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1085 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1150 of "$AFP/Simpl/hoare.ML"):
### Value identifier (pE) has not been referenced.
### ML warning (line 1270 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fold_com) has not been referenced.
### ML warning (line 1386 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t1) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 1433 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1493 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1770 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1773 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1775 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1782 of "$AFP/Simpl/hoare.ML"):
### Value identifier (hoare) has not been referenced.
### ML warning (line 1872 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1842 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1940 of "$AFP/Simpl/hoare.ML"):
### Value identifier (mode) has not been referenced.
### ML warning (line 1982 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2012 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Q) has not been referenced.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Value identifier (a_vT) has not been referenced.
### ML warning (line 2076 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gT) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2094 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2118 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 2137 of "$AFP/Simpl/hoare.ML"):
### Value identifier (G) has not been referenced.
### ML warning (line 2287 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2382 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 2404 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2412 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fs) has not been referenced.
### ML warning (line 2459 of "$AFP/Simpl/hoare.ML"):
### Value identifier (b) has not been referenced.
### ML warning (line 2478 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (A) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 2720 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2737 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2744 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2832 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (name) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (destr) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2920 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fld_idx) has not been referenced.
### ML warning (line 2968 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3011 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3126 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 3114 of "$AFP/Simpl/hoare.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x_upd') has not been referenced.
### ML warning (line 3172 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3282 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3283 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3296 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3298 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3330 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
### ML warning (line 3336 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
signature HOARE =
  sig
    val BasicSimpTac:
       Proof.context ->
         state_kind -> bool -> thm list -> (int -> tactic) -> int -> tactic
    val add_foldcongs: thm list -> theory -> theory
    val add_foldcongsimps: thm list -> theory -> theory
    val add_params:
       morphism ->
         string ->
           (par_kind * string) list -> Context.generic -> Context.generic
    val add_recursive:
       morphism -> string -> Context.generic -> Context.generic
    val add_state_kind:
       morphism ->
         string -> state_kind -> Context.generic -> Context.generic
    datatype 'a bodykind = BodyTerm of 'a | BodyTyp of 'a
    val chopsfx: string -> string -> string
    val clique_name: string list -> string
    val deco: string
    val extern: Proof.context -> string -> string
    val gen_proc_rec: Proof.context -> hoareMode -> int -> thm
    val generate_guard: Proof.context -> term -> term option
    val get_data: Proof.context -> hoare_data
    val get_default_state_kind: Proof.context -> state_kind
    val get_foldcong_ss: theory -> simpset
    val get_params:
       string -> Proof.context -> (par_kind * string) list option
    val get_state_kind: string -> Proof.context -> state_kind option
    val hoare: (Proof.context -> Proof.method) context_parser
    datatype hoareMode = Partial | Total
    type hoare_data =
       {active_procs: string list list,
        default_state_kind: state_kind,
        generate_guard: stamp * (Proof.context -> term -> term option),
        hoare_tacs: (string * hoare_tac) list,
        proc_info: proc_info Symtab.table,
        vcg_simps: thm list, wp_tacs: (string * hoare_tac) list}
    val hoare_raw: (Proof.context -> Proof.method) context_parser
    val hoare_rule: (Proof.context -> Proof.method) context_parser
    val hoare_rule_tac: Proof.context -> thm list -> int -> tactic
    type hoare_tac =
       (bool -> int -> tactic) ->
         Proof.context -> hoareMode -> int -> tactic
    val implementationN: string
    val install_generate_guard:
       (Proof.context -> term -> term option) ->
         Context.generic -> Context.generic
    val is_state_var: string -> bool
    val modeqN: string
    val modexN: string
    val par_deco: string -> string
    datatype par_kind = In | Out
    val proc_deco: string
    type proc_info =
       {params: (par_kind * string) list,
        recursive: bool, state_kind: state_kind}
    val proc_specs: (bstring * string) list parser
    val remdeco: Proof.context -> string -> string
    val remdeco': string -> string
    val resuffix: string -> string -> string -> string
    val set_default_state_kind:
       state_kind -> Context.generic -> Context.generic
    val specL: string
    datatype state_kind = Function | Record
    val undeco: Proof.context -> term -> term
    val varname: string -> string
    val vcg: (Proof.context -> Proof.method) context_parser
    val vcg_step: (Proof.context -> Proof.method) context_parser
    val vcg_tac:
       string -> string -> string list -> Proof.context -> int -> tactic
  end
structure Hoare: HOARE
### ML warning (line 98 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 97 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ys) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 107 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 242 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 271 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 282 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 281 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 279 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 322 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_val) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 5 is redundant.
### ML warning (line 469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 492 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 499 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 502 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 533 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 535 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 581 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 583 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 667 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 701 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 699 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 706 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 750 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 14 is redundant.
### ML warning (line 758 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 786 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 773 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 788 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 800 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 825 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 813 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 816 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 837 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 827 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 851 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 839 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 842 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 876 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 975 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 972 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 969 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 967 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 965 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 963 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 961 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 959 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 957 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 953 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 993 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1042 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (values) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (idxs) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (value) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1098 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 2 is redundant.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (constr) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (dest) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd') has not been referenced.
### ML warning (line 1165 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1152 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1143 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1178 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1211 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 1235 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1274 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1300 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1302 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (result) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1341 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1362 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1442 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1439 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1473 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1492 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1502 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1506 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1525 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1542 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1534 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1555 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 1611 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 1602 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
signature HOARE_SYNTAX =
  sig
    val antiquoteCur: string
    val antiquoteOld: string
    val antiquoteOld_tr: Proof.context -> term list -> term
    val antiquote_applied_only_to: (term -> bool) -> term -> bool
    val antiquote_varname_tr: string -> term list -> term
    val app_quote_tr': Proof.context -> term -> term list -> term
    val assert_tr': Proof.context -> term list -> term
    val assign_tr: Proof.context -> term list -> term
    val assign_tr': Proof.context -> term list -> term
    val basic_assigns_tr: Proof.context -> term list -> term
    val basic_tr: Proof.context -> term list -> term
    val basic_tr': Proof.context -> term list -> term
    val bexp_tr': string -> Proof.context -> term list -> term
    val bind_tr': Proof.context -> term list -> term
    val call_ass_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr': Proof.context -> term list -> term
    val dyn_call_tr': Proof.context -> term list -> term
    val fcall_tr: Proof.context -> term list -> term
    val fcall_tr': Proof.context -> term list -> term
    val guarded_Assign_tr: Proof.context -> term list -> term
    val guarded_Cond_tr: Proof.context -> term list -> term
    val guarded_NNew_tr: Proof.context -> term list -> term
    val guarded_New_tr: Proof.context -> term list -> term
    val guarded_WhileFix_tr: Proof.context -> term list -> term
    val guarded_While_tr: Proof.context -> term list -> term
    val guards_tr': Proof.context -> term list -> term
    val hide_guards: bool Config.T
    val init_tr: Proof.context -> term list -> term
    val init_tr': Proof.context -> term list -> term
    val loc_tr: Proof.context -> term list -> term
    val loc_tr': Proof.context -> term list -> term
    val new_tr: Proof.context -> term list -> term
    val new_tr': Proof.context -> term list -> term
    val nnew_tr: Proof.context -> term list -> term
    val nnew_tr': Proof.context -> term list -> term
    val proc_ass_tr: Proof.context -> term list -> term
    val proc_tr: Proof.context -> term list -> term
    val proc_tr': Proof.context -> term list -> term
    val quote_mult_tr':
       Proof.context -> (term -> bool) -> string -> string -> term -> term
    val quote_tr: Proof.context -> string -> term -> term
    val quote_tr': Proof.context -> string -> term -> term
    val raise_tr: Proof.context -> term list -> term
    val raise_tr': Proof.context -> term list -> term
    val switch_tr': Proof.context -> term list -> term
    val update_comp:
       Proof.context ->
         string list -> bool -> bool -> xstring -> term -> term -> term
    val use_call_tr': bool Config.T
    val whileAnnoGFix_tr': Proof.context -> term list -> term
    val whileAnnoG_tr': Proof.context -> term list -> term
  end
structure Hoare_Syntax: HOARE_SYNTAX
### theory "Draft.Vcg"
### 3.397s elapsed time, 5.147s cpu time, 2.370s GC time
Loading theory "Draft.SyntaxTest" (required by "Draft.SyntaxTestTemplates")
"(False, {|in_range (3 - 1)|})|->\<acute>R :== 3 - 1 "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|1 < 3|})|->\<acute>I :== 3 - 1 "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|i < length \<acute>A|})|->\<acute>I :== \<acute>A ! i "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"\<acute>A ! i :== j"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
locale Foo_impl
  fixes
    \<Gamma> ::
      "char list => (('a, 'b) vars_scheme, char list, 'c) com option"
    and Foo_'proc :: "char list"
  assumes "Foo_impl \<Gamma> Foo_'proc"
"\<acute>AA :== \<acute>AA !! [i, j]"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
"\<acute>AA !! [i, j] :== \<acute>AA"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
"(False, {|i < length \<acute>A|})|->\<acute>A ! i :== j "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
### theory "Draft.SyntaxTest"
### 0.395s elapsed time, 0.416s cpu time, 0.000s GC time
Loading theory "Draft.SyntaxTestTemplates"
"(False,
  {|i < length \<acute>GA &
    j < length (\<acute>GA ! i)|})|->\<acute>p :== \<acute>GA ! i ! j "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False, {|\<acute>p ~= Null|})|->\<acute>p :== \<acute>p->\<acute>next "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|i < length \<acute>GA &
    j < length (\<acute>GA ! i)|})|->\<acute>GA ! i ! j :== \<acute>p "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False, {|\<acute>p ~= Null|})|->\<acute>p->\<acute>next :== \<acute>p "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|\<acute>p ~= Null &
    \<acute>p->\<acute>next ~=
    Null|})|->\<acute>p->\<acute>next->\<acute>next :== \<acute>p "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"\<acute>p :== NEW sz [\<acute>next :== Null, \<acute>cont :== 0]"
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, 'd) com"
"\<acute>p :== NNEW sz [\<acute>next :== Null, \<acute>cont :== 0]"
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, 'd) com"
"(False,
  {|in_range (\<acute>N + 1) &
    (\<acute>N + 1 < 0 -->
     in_range
      (\<acute>M +
       \<acute>N))|})|->\<acute>B :==
                        \<acute>N + 1 < 0 & \<acute>M + \<acute>N < n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|\<acute>p ~=
    Null|})|->\<acute>p->\<acute>next :==
               NEW sz [\<acute>next :== Null, \<acute>cont :== 0] "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|in_range (\<acute>N + 1) &
    (~ \<acute>N + 1 < 0 -->
     in_range
      (\<acute>M +
       \<acute>N))|})|->\<acute>B :==
                        \<acute>N + 1 < 0 | \<acute>M + \<acute>N < n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|n ~= 0|})|->\<acute>I :== \<acute>N mod n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|n ~= 0 & in_range (\<acute>N div n)|})|->\<acute>I :== \<acute>N div n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|n ~= 0|})|->\<acute>R :== \<acute>R mod n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|n ~= 0 & in_range (\<acute>R div n)|})|->\<acute>R :== \<acute>R div n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|in_range (\<acute>R * n)|})|->\<acute>R :== \<acute>R * n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|\<acute>N < \<acute>I|})|->\<acute>I :== \<acute>I - \<acute>N "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|\<acute>p ~=
    Null|})|->\<acute>p->\<acute>next :==
               NNEW sz [\<acute>next :== Null, \<acute>cont :== 0] "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|in_range
     (\<acute>R - \<acute>S)|})|->\<acute>R :== \<acute>R - \<acute>S "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"\<acute>R :== int \<acute>I"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
"(False, {|0 <= \<acute>R|})|->\<acute>I :== nat \<acute>R "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|in_range (- \<acute>R)|})|->\<acute>R :== - \<acute>R "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|i < length
         \<acute>A|})|->IF \<acute>A ! i < \<acute>N THEN c1 ELSE c2 FI "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"WHILE (False, {|i < length \<acute>A|})|-> \<acute>A ! i < \<acute>N DO c 
 OD"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"WHILE (False, {|i < length \<acute>A|})|-> 
       \<acute>A ! i < \<acute>N INV {|foo|} 
 DO c OD"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"WHILE (False, {|i < length \<acute>A|})
       \<longmapsto> \<acute>A ! i < \<acute>N INV {|foo|}
 VAR bar x DO c OD"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"WHILE (False, {|i < length \<acute>A|})
       \<longmapsto> \<acute>A ! i < \<acute>N INV {|foo|}
 VAR bar x DO c OD;;
 c"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"\<acute>q :== CALL Foo(\<acute>p,\<acute>M)"
  :: "(('d, 'e) vars_scheme, char list, 'f) com"
"(False, {|in_range (\<acute>M + 1)|})|->\<acute>q :== CALL Foo(\<acute>p,
 \<acute>M + 1) "
  :: "(('d, 'e) vars_scheme, char list, bool) com"
"c;;
 WHILE (False, {|i < length \<acute>A|})
       \<longmapsto> \<acute>A ! i < \<acute>N INV {|foo|}
 VAR MEASURE \<acute>N + \<acute>M DO c;; c OD;;
 c"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"\<acute>q :== CALL Foo(\<acute>p->\<acute>next,\<acute>M)"
  :: "(('d globals_scheme, 'e) vars_scheme, char list, 'f) com"
"\<acute>q->\<acute>next :== CALL Foo(\<acute>p,\<acute>M)"
  :: "(('d globals_scheme, 'e) vars_scheme, char list, 'f) com"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.SyntaxTestTemplates"
### 0.404s elapsed time, 0.594s cpu time, 0.000s GC time
val it = (): unit
