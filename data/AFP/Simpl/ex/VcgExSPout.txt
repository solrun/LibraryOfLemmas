Loading theory "Draft.Simpl_Heap" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.HeapList")
Loading theory "Draft.Language" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps" via "Draft.HoarePartialDef" via "Draft.Semantic")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.VcgExSPTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.VcgExSPTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Draft.Simpl_Heap"
### 0.112s elapsed time, 0.465s cpu time, 0.034s GC time
Loading theory "Draft.HeapList" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP")
### theory "HOL-Library.Function_Algebras"
### 0.139s elapsed time, 0.571s cpu time, 0.034s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.VcgExSPTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
consts
  Path :: "ref => (ref => ref) => ref => ref list => bool"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
Found termination order: "size_list size <*mlex*> {}"
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### theory "HOL-Library.Nat_Bijection"
### 0.259s elapsed time, 1.057s cpu time, 0.034s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.VcgExSPTemplates" via "Draft.ExtrEqs")
### theory "Draft.HeapList"
### 0.177s elapsed time, 0.706s cpu time, 0.000s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.VcgExSPTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Set_Algebras"
### 0.260s elapsed time, 1.032s cpu time, 0.174s GC time
Loading theory "Draft.Generalise" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg")
### ML warning (line 109 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 98 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 223 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 212 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 201 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 186 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 227 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 228 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 230 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 233 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 242 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 190 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 191 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 194 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 198 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 168 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 169 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 171 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 174 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 183 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 214 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 215 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 203 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 204 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 163 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
signature SPLIT_STATE =
  sig
    val abs_state: term -> term option
    val abs_var: Proof.context -> term -> string * typ
    val ex_tac: Proof.context -> term list -> tactic
    val isState: term -> bool
    val split_state:
       Proof.context -> string -> typ -> term -> term * term list
  end
functor GeneraliseFun (sig structure SplitState: SPLIT_STATE end): 
  sig
    val GENERALISE: Proof.context -> int -> tactic
    val OF_RAW: thm * thm -> thm
    val SIMPLE_OF: Proof.context -> thm -> thm list -> thm
    val SIMPLE_OF_RAW: Proof.context -> thm -> thm -> thm
    val conc_of: thm -> term
    val decomp:
       Proof.context ->
         term * cterm -> term list * cterm list * (thm list -> thm)
    val dest_All: term -> term
    val dest_prop: term -> term
    val eta_expand: Proof.context -> cterm -> cterm
    val genAll: thm
    val genAllShift: thm
    val genConj: thm
    val genEx: thm
    val genImp: thm
    val genImpl: thm
    val genRefl: thm
    val genRefl': thm
    val genTrans: thm
    val gen_all: thm
    val gen_allShift: thm
    val gen_thm:
       ('a * 'b -> 'a list * 'b list * ('c list -> 'c)) -> 'a * 'b -> 'c
    val generalise: Proof.context -> cterm -> thm
    val generalise_over_all_states_tac: Proof.context -> int -> tactic
    val generalise_over_tac:
       Proof.context -> (term -> term option) -> int -> thm -> thm Seq.seq
    val generalise_tac: Proof.context -> int -> thm -> thm Seq.seq
    val init: cterm -> thm
    val list_exists: (string * typ) list * term -> term
    val meta_spec: thm
    val prem_of: thm -> term
    val protectImp: thm
    val protectRefl: thm
    datatype qantifier = Hol_all | Hol_ex | Meta_all
    val spec': cterm -> thm -> thm
    val split_abs:
       Proof.context -> cterm -> (string * typ * term) * (cterm * cterm)
    val split_thm:
       qantifier -> Proof.context -> string -> typ -> term -> thm
  end
### theory "Draft.Generalise"
### 0.073s elapsed time, 0.301s cpu time, 0.000s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.VcgExSPTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  cycle :: "'a list => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
### theory "HOL-Library.Stream"
### 1.037s elapsed time, 3.885s cpu time, 0.962s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.921s elapsed time, 3.345s cpu time, 0.788s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 1.868s elapsed time, 5.738s cpu time, 1.220s GC time
Loading theory "Draft.Templates" (required by "Draft.VcgExSPTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.049s elapsed time, 0.099s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.VcgExSPTemplates")
consts
  switch ::
    "('s => 'v) => ('v set * ('s, 'p, 'f) com) list => ('s, 'p, 'f) com"
consts
  guards :: "('f * 's set) list => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  flatten :: "('s, 'p, 'f) com => ('s, 'p, 'f) com list"
consts
  sequence ::
    "(('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com)
     => ('s, 'p, 'f) com list => ('s, 'p, 'f) com"
consts
  normalize :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  strip_guards :: "'f set => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  mark_guards :: "'f => ('s, 'p, 'g) com => ('s, 'p, 'f) com"
### No equation for constructor "Skip"
### No equation for constructor "Basic"
### No equation for constructor "Spec"
### No equation for constructor "Seq"
### No equation for constructor "Cond"
### No equation for constructor "While"
### No equation for constructor "Call"
### No equation for constructor "DynCom"
### No equation for constructor "Throw"
### No equation for constructor "Catch"
consts
  dest_Guard :: "('s, 'p, 'f) com => 'f * 's set * ('s, 'p, 'f) com"
consts
  merge_guards :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.529s elapsed time, 1.143s cpu time, 0.178s GC time
consts
  noguards :: "('s, 'p, 'f) com => bool"
consts
  nothrows :: "('s, 'p, 'f) com => bool"
Proofs for inductive predicate(s) "com_relp"
  Proving monotonicity ...
### Legacy feature! Old 'recdef' command -- use 'fun' or 'function' instead
Defining recursive function "Language.inter_guards" ...
Proving induction theorem ...
Postprocessing ...
Simplifying nested TCs ...
... Postprocessing finished
Proving unsplit equation...
th:
(Skip \<inter>\<^sub>g Skip) = None ==> (Skip \<inter>\<^sub>g Skip) = None
split ths:
(Skip \<inter>\<^sub>g Basic ?bc) = None
(Skip \<inter>\<^sub>g Spec ?bd) = None
(Skip \<inter>\<^sub>g Seq ?be ?bf) = None
(Skip \<inter>\<^sub>g Cond ?bg ?bh ?bi) = None
(Skip \<inter>\<^sub>g While ?bj ?bk) = None
(Skip \<inter>\<^sub>g Call ?bl) = None
(Skip \<inter>\<^sub>g DynCom ?bm) = None
(Skip \<inter>\<^sub>g Guard ?bn ?bo ?bp) = None
(Skip \<inter>\<^sub>g Throw) = None
(Skip \<inter>\<^sub>g Catch ?bq ?br) = None
(Basic ?w \<inter>\<^sub>g Skip) = None
(Basic ?w \<inter>\<^sub>g Spec ?cj) = None
(Basic ?w \<inter>\<^sub>g Seq ?ck ?cl) = None
(Basic ?w \<inter>\<^sub>g Cond ?cm ?cn ?co) = None
(Basic ?w \<inter>\<^sub>g While ?cp ?cq) = None
(Basic ?w \<inter>\<^sub>g Call ?cr) = None
(Basic ?w \<inter>\<^sub>g DynCom ?cs) = None
(Basic ?w \<inter>\<^sub>g Guard ?ct ?cu ?cv) = None
(Basic ?w \<inter>\<^sub>g Throw) = None
(Basic ?w \<inter>\<^sub>g Catch ?cw ?cx) = None
(Spec ?x \<inter>\<^sub>g Skip) = None
(Spec ?x \<inter>\<^sub>g Basic ?do) = None
(Spec ?x \<inter>\<^sub>g Seq ?dq ?dr) = None
(Spec ?x \<inter>\<^sub>g Cond ?ds ?dt ?du) = None
(Spec ?x \<inter>\<^sub>g While ?dv ?dw) = None
(Spec ?x \<inter>\<^sub>g Call ?dx) = None
(Spec ?x \<inter>\<^sub>g DynCom ?dy) = None
(Spec ?x \<inter>\<^sub>g Guard ?dz ?ea ?eb) = None
(Spec ?x \<inter>\<^sub>g Throw) = None
(Spec ?x \<inter>\<^sub>g Catch ?ec ?ed) = None
(Seq ?y ?z \<inter>\<^sub>g Skip) = None
(Seq ?y ?z \<inter>\<^sub>g Basic ?ev) = None
(Seq ?y ?z \<inter>\<^sub>g Spec ?ew) = None
(Seq ?y ?z \<inter>\<^sub>g Cond ?ez ?fa ?fb) = None
(Seq ?y ?z \<inter>\<^sub>g While ?fc ?fd) = None
(Seq ?y ?z \<inter>\<^sub>g Call ?fe) = None
(Seq ?y ?z \<inter>\<^sub>g DynCom ?ff) = None
(Seq ?y ?z \<inter>\<^sub>g Guard ?fg ?fh ?fi) = None
(Seq ?y ?z \<inter>\<^sub>g Throw) = None
(Seq ?y ?z \<inter>\<^sub>g Catch ?fj ?fk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Skip) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Basic ?gb) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Spec ?gc) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Seq ?gd ?ge) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g While ?gi ?gj) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Call ?gk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g DynCom ?gl) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Guard ?gm ?gn ?go) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Throw) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Catch ?gp ?gq) = None
(While ?ad ?ae \<inter>\<^sub>g Skip) = None
(While ?ad ?ae \<inter>\<^sub>g Basic ?hh) = None
(While ?ad ?ae \<inter>\<^sub>g Spec ?hi) = None
(While ?ad ?ae \<inter>\<^sub>g Seq ?hj ?hk) = None
(While ?ad ?ae \<inter>\<^sub>g Cond ?hl ?hm ?hn) = None
(While ?ad ?ae \<inter>\<^sub>g Call ?hq) = None
(While ?ad ?ae \<inter>\<^sub>g DynCom ?hr) = None
(While ?ad ?ae \<inter>\<^sub>g Guard ?hs ?ht ?hu) = None
(While ?ad ?ae \<inter>\<^sub>g Throw) = None
(While ?ad ?ae \<inter>\<^sub>g Catch ?hv ?hw) = None
(Call ?af \<inter>\<^sub>g Skip) = None
(Call ?af \<inter>\<^sub>g Basic ?in) = None
(Call ?af \<inter>\<^sub>g Spec ?io) = None
(Call ?af \<inter>\<^sub>g Seq ?ip ?iq) = None
(Call ?af \<inter>\<^sub>g Cond ?ir ?is ?it) = None
(Call ?af \<inter>\<^sub>g While ?iu ?iv) = None
(Call ?af \<inter>\<^sub>g DynCom ?ix) = None
(Call ?af \<inter>\<^sub>g Guard ?iy ?iz ?ja) = None
(Call ?af \<inter>\<^sub>g Throw) = None
(Call ?af \<inter>\<^sub>g Catch ?jb ?jc) = None
(DynCom ?ag \<inter>\<^sub>g Skip) = None
(DynCom ?ag \<inter>\<^sub>g Basic ?jt) = None
(DynCom ?ag \<inter>\<^sub>g Spec ?ju) = None
(DynCom ?ag \<inter>\<^sub>g Seq ?jv ?jw) = None
(DynCom ?ag \<inter>\<^sub>g Cond ?jx ?jy ?jz) = None
(DynCom ?ag \<inter>\<^sub>g While ?ka ?kb) = None
(DynCom ?ag \<inter>\<^sub>g Call ?kc) = None
(DynCom ?ag \<inter>\<^sub>g Guard ?ke ?kf ?kg) = None
(DynCom ?ag \<inter>\<^sub>g Throw) = None
(DynCom ?ag \<inter>\<^sub>g Catch ?kh ?ki) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Skip) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Basic ?kz) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Spec ?la) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Seq ?lb ?lc) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Cond ?ld ?le ?lf) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g While ?lg ?lh) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Call ?li) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g DynCom ?lj) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Throw) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Catch ?ln ?lo) = None
(Throw \<inter>\<^sub>g Skip) = None
(Throw \<inter>\<^sub>g Basic ?mf) = None
(Throw \<inter>\<^sub>g Spec ?mg) = None
(Throw \<inter>\<^sub>g Seq ?mh ?mi) = None
(Throw \<inter>\<^sub>g Cond ?mj ?mk ?ml) = None
(Throw \<inter>\<^sub>g While ?mm ?mn) = None
(Throw \<inter>\<^sub>g Call ?mo) = None
(Throw \<inter>\<^sub>g DynCom ?mp) = None
(Throw \<inter>\<^sub>g Guard ?mq ?mr ?ms) = None
(Throw \<inter>\<^sub>g Catch ?mt ?mu) = None
(Catch ?ak ?al \<inter>\<^sub>g Skip) = None
(Catch ?ak ?al \<inter>\<^sub>g Basic ?nl) = None
(Catch ?ak ?al \<inter>\<^sub>g Spec ?nm) = None
(Catch ?ak ?al \<inter>\<^sub>g Seq ?nn ?no) = None
(Catch ?ak ?al \<inter>\<^sub>g Cond ?np ?nq ?nr) = None
(Catch ?ak ?al \<inter>\<^sub>g While ?ns ?nt) = None
(Catch ?ak ?al \<inter>\<^sub>g Call ?nu) = None
(Catch ?ak ?al \<inter>\<^sub>g DynCom ?nv) = None
(Catch ?ak ?al \<inter>\<^sub>g Guard ?nw ?nx ?ny) = None
(Catch ?ak ?al \<inter>\<^sub>g Throw) = None
--
### recdef (solve_eq): splitto: cannot find variable to split on
Proofs for inductive predicate(s) "subseteq_guards"
  Proving monotonicity ...
### theory "Draft.Language"
### 4.394s elapsed time, 10.470s cpu time, 2.344s GC time
Loading theory "Draft.Semantic" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps" via "Draft.HoarePartialDef")
Proofs for inductive predicate(s) "exec"
  Proving monotonicity ...
Proofs for inductive predicate(s) "execn"
  Proving monotonicity ...
### theory "Draft.Semantic"
### 2.134s elapsed time, 2.620s cpu time, 0.423s GC time
Loading theory "Draft.HoarePartialDef" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps")
Loading theory "Draft.Termination" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps" via "Draft.SmallStep")
### Ambiguous input (line 84 of "$AFP/Simpl/HoarePartialDef.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_position" n)
###       ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###         ("_position" \<Theta>) ("_position" n) ("_position" F)
###         ("_position" P) ("_position" c) ("_position" Q) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_tuple"
###       ("\<^const>HOL.All_binder" ("_position" n) ("_position" \<Gamma>))
###       ("_tuple_arg"
###         ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###           ("_position" n) ("_position" F) ("_position" P) ("_position" c)
###           ("_position" Q) ("_position" A)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "terminates"
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoarep"
  Proving monotonicity ...
### theory "Draft.HoarePartialDef"
### 0.363s elapsed time, 0.856s cpu time, 0.140s GC time
Loading theory "Draft.HoarePartialProps" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial")
### Ambiguous input (line 1078 of "$AFP/Simpl/HoarePartialProps.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.All_binder" ("_position" n)
###             ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###               ("_position" \<Theta>) ("_position" n) ("_position" F)
###               ("_position" P') ("_position" c) ("_position" Q')
###               ("_position" A')))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("_tuple"
###             ("\<^const>HOL.All_binder" ("_position" n)
###               ("_position" \<Gamma>))
###             ("_tuple_arg"
###               ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###                 ("_position" n) ("_position" F) ("_position" P')
###                 ("_position" c) ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### No equation for constructor "Spec"
consts
  procs :: "('s, 'p, 'f) com => 'p set"
### theory "Draft.Termination"
### 0.577s elapsed time, 1.262s cpu time, 0.140s GC time
Loading theory "Draft.SmallStep" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps")
Loading theory "Draft.HoareTotalDef" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps")
consts
  noSpec :: "('s, 'p, 'f) com => bool"
consts
  redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
Proofs for inductive predicate(s) "step"
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoaret"
  Proving monotonicity ...
### theory "Draft.HoarePartialProps"
### 1.019s elapsed time, 3.198s cpu time, 1.671s GC time
Loading theory "Draft.HoarePartial" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare")
### theory "Draft.HoareTotalDef"
### 1.008s elapsed time, 3.409s cpu time, 1.791s GC time
val tranclp_induct2 =
   "[| ?r^++ (?aa, ?ab) (?ba, ?bb); !!a b. ?r (?aa, ?ab) (a, b) ==> ?P a b;
       !!a b aa ba.
          [| ?r^++ (?aa, ?ab) (a, b); ?r (a, b) (aa, ba); ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  subst_redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
val trancl_induct2 =
   "[| ((?aa, ?ab), ?ba, ?bb) : ?r^+;
       !!a b. ((?aa, ?ab), a, b) : ?r ==> ?P a b;
       !!a b aa ba.
          [| ((?aa, ?ab), a, b) : ?r^+; ((a, b), aa, ba) : ?r; ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  seq :: "(nat => ('s, 'p, 'f) com) => 'p => nat => ('s, 'p, 'f) com"
### theory "Draft.HoarePartial"
### 0.694s elapsed time, 1.677s cpu time, 0.246s GC time
consts
  redexes :: "('s, 'p, 'f) com => ('s, 'p, 'f) com set"
### theory "Draft.SmallStep"
### 1.568s elapsed time, 4.468s cpu time, 1.917s GC time
Loading theory "Draft.HoareTotalProps" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal")
### theory "Draft.HoareTotalProps"
### 0.631s elapsed time, 0.772s cpu time, 0.190s GC time
Loading theory "Draft.HoareTotal" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare")
### theory "Draft.HoareTotal"
### 0.586s elapsed time, 0.736s cpu time, 0.201s GC time
Loading theory "Draft.Hoare" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg" via "Draft.StateSpace")
"\<Gamma>|-P c Q"
  :: "bool"
"\<Gamma>|-P c Q,A"
  :: "bool"
"\<Gamma>|-/F P c Q"
  :: "bool"
locale hoare
  fixes \<Gamma> :: "'p => ('s, 'p, 'f) com option"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-/F P c Q"
  :: "bool"
"\<Gamma>|-/F P c Q,A"
  :: "bool"
"\<Gamma>|-tP c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^bsub>/F \<^esub>P c Q,A"
  :: "bool"
"\<Gamma>|-t/F P c Q"
  :: "bool"
"\<Gamma>|-tP c Q,A"
  :: "bool"
"\<Gamma>|-t/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-t/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^sub>t\<^bsub>/F\<^esub> P c Q,A"
  :: "bool"
consts
  assoc :: "('a * 'b) list => 'a => 'b"
### theory "Draft.Hoare"
### 0.187s elapsed time, 0.208s cpu time, 0.000s GC time
Loading theory "Draft.StateSpace" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP" via "Draft.Vcg")
### theory "Draft.StateSpace"
### 0.754s elapsed time, 2.084s cpu time, 1.815s GC time
Loading theory "Draft.Vcg" (required by "Draft.VcgExSPTemplates" via "Draft.VcgExSP")
### Ignoring duplicate rewrite rule:
### ~ ~ ?y == ?y
### Ignoring duplicate rewrite rule:
### (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
### Ignoring duplicate rewrite rule:
### ?P1 | ~ ?P1 == True
### Ignoring duplicate rewrite rule:
### ~ ?P1 | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?x1 = ?x1 == True
### Ignoring duplicate rewrite rule:
### ~ True == False
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### (~ ?P1) = ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 = (~ ?P1) == False
### Ignoring duplicate rewrite rule:
### True = ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y = True == ?y
### Ignoring duplicate rewrite rule:
### False = ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 = False == ~ ?P1
### Ignoring duplicate rewrite rule:
### True --> ?y == ?y
### Ignoring duplicate rewrite rule:
### False --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> True == True
### Ignoring duplicate rewrite rule:
### ?P1 --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> False == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 --> ~ ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?y & True == ?y
### Ignoring duplicate rewrite rule:
### True & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & False == False
### Ignoring duplicate rewrite rule:
### False & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 & ~ ?P1 == False
### Ignoring duplicate rewrite rule:
### ~ ?P1 & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 | True == True
### Ignoring duplicate rewrite rule:
### True | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?y | False == ?y
### Ignoring duplicate rewrite rule:
### False | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
### Ignoring duplicate rewrite rule:
### ALL x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 == True
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x == True
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x ~= ?t1 == False
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 ~= x == False
### ML warning (line 165 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 450 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 455 of "$AFP/Simpl/hoare.ML"):
### Value identifier (prf) has not been referenced.
### ML warning (line 472 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 469 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 628 of "$AFP/Simpl/hoare.ML"):
### Value identifier (default_state_kind) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare.ML"):
### Value identifier (generate_guard) has not been referenced.
### ML warning (line 897 of "$AFP/Simpl/hoare.ML"):
### Value identifier (less) has not been referenced.
### ML warning (line 902 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1085 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1150 of "$AFP/Simpl/hoare.ML"):
### Value identifier (pE) has not been referenced.
### ML warning (line 1270 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fold_com) has not been referenced.
### ML warning (line 1386 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t1) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 1433 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1493 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1770 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1773 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1775 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1782 of "$AFP/Simpl/hoare.ML"):
### Value identifier (hoare) has not been referenced.
### ML warning (line 1872 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1842 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1940 of "$AFP/Simpl/hoare.ML"):
### Value identifier (mode) has not been referenced.
### ML warning (line 1982 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2012 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Q) has not been referenced.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Value identifier (a_vT) has not been referenced.
### ML warning (line 2076 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gT) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2094 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2118 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 2137 of "$AFP/Simpl/hoare.ML"):
### Value identifier (G) has not been referenced.
### ML warning (line 2287 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2382 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 2404 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2412 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fs) has not been referenced.
### ML warning (line 2459 of "$AFP/Simpl/hoare.ML"):
### Value identifier (b) has not been referenced.
### ML warning (line 2478 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (A) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 2720 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2737 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2744 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2832 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (name) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (destr) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2920 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fld_idx) has not been referenced.
### ML warning (line 2968 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3011 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3126 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 3114 of "$AFP/Simpl/hoare.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x_upd') has not been referenced.
### ML warning (line 3172 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3282 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3283 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3296 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3298 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3330 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
### ML warning (line 3336 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
signature HOARE =
  sig
    val BasicSimpTac:
       Proof.context ->
         state_kind -> bool -> thm list -> (int -> tactic) -> int -> tactic
    val add_foldcongs: thm list -> theory -> theory
    val add_foldcongsimps: thm list -> theory -> theory
    val add_params:
       morphism ->
         string ->
           (par_kind * string) list -> Context.generic -> Context.generic
    val add_recursive:
       morphism -> string -> Context.generic -> Context.generic
    val add_state_kind:
       morphism ->
         string -> state_kind -> Context.generic -> Context.generic
    datatype 'a bodykind = BodyTerm of 'a | BodyTyp of 'a
    val chopsfx: string -> string -> string
    val clique_name: string list -> string
    val deco: string
    val extern: Proof.context -> string -> string
    val gen_proc_rec: Proof.context -> hoareMode -> int -> thm
    val generate_guard: Proof.context -> term -> term option
    val get_data: Proof.context -> hoare_data
    val get_default_state_kind: Proof.context -> state_kind
    val get_foldcong_ss: theory -> simpset
    val get_params:
       string -> Proof.context -> (par_kind * string) list option
    val get_state_kind: string -> Proof.context -> state_kind option
    val hoare: (Proof.context -> Proof.method) context_parser
    datatype hoareMode = Partial | Total
    type hoare_data =
       {active_procs: string list list,
        default_state_kind: state_kind,
        generate_guard: stamp * (Proof.context -> term -> term option),
        hoare_tacs: (string * hoare_tac) list,
        proc_info: proc_info Symtab.table,
        vcg_simps: thm list, wp_tacs: (string * hoare_tac) list}
    val hoare_raw: (Proof.context -> Proof.method) context_parser
    val hoare_rule: (Proof.context -> Proof.method) context_parser
    val hoare_rule_tac: Proof.context -> thm list -> int -> tactic
    type hoare_tac =
       (bool -> int -> tactic) ->
         Proof.context -> hoareMode -> int -> tactic
    val implementationN: string
    val install_generate_guard:
       (Proof.context -> term -> term option) ->
         Context.generic -> Context.generic
    val is_state_var: string -> bool
    val modeqN: string
    val modexN: string
    val par_deco: string -> string
    datatype par_kind = In | Out
    val proc_deco: string
    type proc_info =
       {params: (par_kind * string) list,
        recursive: bool, state_kind: state_kind}
    val proc_specs: (bstring * string) list parser
    val remdeco: Proof.context -> string -> string
    val remdeco': string -> string
    val resuffix: string -> string -> string -> string
    val set_default_state_kind:
       state_kind -> Context.generic -> Context.generic
    val specL: string
    datatype state_kind = Function | Record
    val undeco: Proof.context -> term -> term
    val varname: string -> string
    val vcg: (Proof.context -> Proof.method) context_parser
    val vcg_step: (Proof.context -> Proof.method) context_parser
    val vcg_tac:
       string -> string -> string list -> Proof.context -> int -> tactic
  end
structure Hoare: HOARE
### ML warning (line 98 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 97 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ys) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 107 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 242 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 271 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 282 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 281 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 279 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 322 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_val) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 5 is redundant.
### ML warning (line 469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 492 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 499 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 502 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 533 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 535 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 581 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 583 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 667 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 701 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 699 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 706 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 750 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 14 is redundant.
### ML warning (line 758 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 786 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 773 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 788 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 800 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 825 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 813 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 816 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 837 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 827 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 851 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 839 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 842 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 876 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 975 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 972 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 969 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 967 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 965 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 963 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 961 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 959 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 957 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 953 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 993 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1042 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (values) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (idxs) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (value) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1098 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 2 is redundant.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (constr) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (dest) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd') has not been referenced.
### ML warning (line 1165 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1152 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1143 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1178 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1211 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 1235 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1274 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1300 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1302 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (result) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1341 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1362 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1442 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1439 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1473 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1492 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1502 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1506 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1525 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1542 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1534 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1555 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 1611 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 1602 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
signature HOARE_SYNTAX =
  sig
    val antiquoteCur: string
    val antiquoteOld: string
    val antiquoteOld_tr: Proof.context -> term list -> term
    val antiquote_applied_only_to: (term -> bool) -> term -> bool
    val antiquote_varname_tr: string -> term list -> term
    val app_quote_tr': Proof.context -> term -> term list -> term
    val assert_tr': Proof.context -> term list -> term
    val assign_tr: Proof.context -> term list -> term
    val assign_tr': Proof.context -> term list -> term
    val basic_assigns_tr: Proof.context -> term list -> term
    val basic_tr: Proof.context -> term list -> term
    val basic_tr': Proof.context -> term list -> term
    val bexp_tr': string -> Proof.context -> term list -> term
    val bind_tr': Proof.context -> term list -> term
    val call_ass_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr': Proof.context -> term list -> term
    val dyn_call_tr': Proof.context -> term list -> term
    val fcall_tr: Proof.context -> term list -> term
    val fcall_tr': Proof.context -> term list -> term
    val guarded_Assign_tr: Proof.context -> term list -> term
    val guarded_Cond_tr: Proof.context -> term list -> term
    val guarded_NNew_tr: Proof.context -> term list -> term
    val guarded_New_tr: Proof.context -> term list -> term
    val guarded_WhileFix_tr: Proof.context -> term list -> term
    val guarded_While_tr: Proof.context -> term list -> term
    val guards_tr': Proof.context -> term list -> term
    val hide_guards: bool Config.T
    val init_tr: Proof.context -> term list -> term
    val init_tr': Proof.context -> term list -> term
    val loc_tr: Proof.context -> term list -> term
    val loc_tr': Proof.context -> term list -> term
    val new_tr: Proof.context -> term list -> term
    val new_tr': Proof.context -> term list -> term
    val nnew_tr: Proof.context -> term list -> term
    val nnew_tr': Proof.context -> term list -> term
    val proc_ass_tr: Proof.context -> term list -> term
    val proc_tr: Proof.context -> term list -> term
    val proc_tr': Proof.context -> term list -> term
    val quote_mult_tr':
       Proof.context -> (term -> bool) -> string -> string -> term -> term
    val quote_tr: Proof.context -> string -> term -> term
    val quote_tr': Proof.context -> string -> term -> term
    val raise_tr: Proof.context -> term list -> term
    val raise_tr': Proof.context -> term list -> term
    val switch_tr': Proof.context -> term list -> term
    val update_comp:
       Proof.context ->
         string list -> bool -> bool -> xstring -> term -> term -> term
    val use_call_tr': bool Config.T
    val whileAnnoGFix_tr': Proof.context -> term list -> term
    val whileAnnoG_tr': Proof.context -> term list -> term
  end
structure Hoare_Syntax: HOARE_SYNTAX
### theory "Draft.Vcg"
### 3.122s elapsed time, 3.634s cpu time, 0.666s GC time
Loading theory "Draft.VcgExSP" (required by "Draft.VcgExSPTemplates")
Defining statespace "state_space" ...
consts
  sum :: "(nat => nat) => nat => nat"
consts
  fac :: "nat => nat"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'Fac_'
variable not fixed or declared: N_'Fac_'
variable not fixed or declared: R_'Fac_'
variable not fixed or declared: R_'Fac_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
Defining statespace "Fac_parameters" ...
Defining statespace "Fac_variables" ...
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
locale Fac_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and N_'Fac_' :: "'b"
    and R_'Fac_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and StateType :: "'b => 'c"
    and Fac_'proc :: "char list"
  assumes
    "Fac_impl \<Gamma> N_'Fac_' R_'Fac_' project_Nat_nat inject_Nat_nat
      Fac_'proc"
locale Fac_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and N_'Fac_' :: "'b"
    and R_'Fac_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and StateType :: "'b => 'c"
    and Fac_'proc :: "char list"
  assumes
    "Fac_impl \<Gamma> N_'Fac_' R_'Fac_' project_Nat_nat inject_Nat_nat
      Fac_'proc"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ N{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ N{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}Fac{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}proc{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ N{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ N{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}Fac{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}proc{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
"call
  (%s. s(| locals :=
             update project_Nat_nat inject_Nat_nat N_'Fac_'
              (K_statefun (lookup project_Nat_nat N_'Fac_' (locals s)))
              (locals s) |))
  Fac_'proc (%s t. s(| globals := globals t |))
  (%i t. \<acute>R :== lookup project_Nat_nat R_'Fac_' (locals t))"
  :: "(('f, 'b, 'c, 'g) stateSP_scheme, char list, 'h) com"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'even_'
variable not fixed or declared: N_'even_'
variable not fixed or declared: A_'even_'
variable not fixed or declared: A_'even_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'odd_'
variable not fixed or declared: N_'odd_'
variable not fixed or declared: A_'odd_'
variable not fixed or declared: A_'odd_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'odd_'
variable not fixed or declared: N_'odd_'
variable not fixed or declared: A_'odd_'
variable not fixed or declared: A_'odd_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'even_'
variable not fixed or declared: N_'even_'
variable not fixed or declared: A_'even_'
variable not fixed or declared: A_'even_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
Defining statespace "odd_even_parameters" ...
Defining statespace "odd_even_variables" ...
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'even_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'odd_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'odd_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'even_'proc_'
locale odd_even_clique
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'd, 'e, 'b) stateSP_scheme, char list, 'c) com option"
    and N_'odd_even_' :: "'d"
    and A_'odd_even_' :: "'d"
    and project_Nat_nat :: "'e => nat"
    and inject_Nat_nat :: "nat => 'e"
    and StateType :: "'d => 'e"
    and even_'proc :: "char list"
    and odd_'proc :: "char list"
  assumes
    "odd_even_clique \<Gamma> N_'odd_even_' A_'odd_even_' project_Nat_nat
      inject_Nat_nat even_'proc odd_'proc"
  notes
    "odd_even.odd_even_parameters_namespace_axioms" =
      (\<open>odd_even_parameters_namespace N_'odd_even_'
               A_'odd_even_'\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even.distinct_names" =
      (\<open>all_distinct
               (Node Tip A_'odd_even_' False
                 (Node Tip N_'odd_even_' False Tip))\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even_variables_namespace_axioms" =
      (\<open>odd_even_variables_namespace N_'odd_even_'
               A_'odd_even_'\<close>)
      ["attribute" "<attribute>"]
  notes
    "distinct_names" =
      (\<open>all_distinct
               (Node Tip A_'odd_even_' False
                 (Node Tip N_'odd_even_' False Tip))\<close>)
      ["attribute" "<attribute>"]
  notes
    "Nat_nat.project_inject_axioms" =
      (\<open>project_inject project_Nat_nat inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes
    "Nat_nat.project_inject_cancel" =
      (\<open>project_Nat_nat (inject_Nat_nat ?x) = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.ex_project" = (\<open>EX v. project_Nat_nat v = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.project_inject_comp_id" =
      (\<open>project_Nat_nat o inject_Nat_nat = id\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.project_inject_comp_cancel" =
      (\<open>?f o project_Nat_nat o inject_Nat_nat = ?f\<close>)
      ["statefun_simp"]
  notes
    "odd_even_variables_valuetypes_axioms" =
      (\<open>odd_even_variables_valuetypes project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even.odd_even_parameters_valuetypes_axioms" =
      (\<open>odd_even_parameters_valuetypes project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even.odd_even_parameters_axioms" =
      (\<open>odd_even_parameters N_'odd_even_' A_'odd_even_'
               project_Nat_nat inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "odd_even_variables_axioms" =
      (\<open>odd_even_variables N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "even_signature_axioms" =
      (\<open>even_signature N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "odd_body_axioms" =
      (\<open>VcgExSP.odd_body N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "odd_body_def" =
      \<open>local.odd_body ==
             IF \<acute>N = 0 THEN \<acute>A :== 0
             ELSE IF \<acute>N = 1
                  THEN \<acute>A :== CALL even(\<acute>N - 1)
                  ELSE \<acute>A :== CALL odd(\<acute>N - 2) FI
             FI\<close>
  notes
    "odd_signature_axioms" =
      (\<open>odd_signature N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "even_body_axioms" =
      (\<open>VcgExSP.even_body N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "even_body_def" =
      \<open>local.even_body ==
             IF \<acute>N = 0 THEN \<acute>A :== 1
             ELSE IF \<acute>N = 1
                  THEN \<acute>A :== CALL odd(\<acute>N - 1)
                  ELSE \<acute>A :== CALL even(\<acute>N - 2) FI
             FI\<close>
  notes
    "odd_even_clique_names_axioms" =
      (\<open>odd_even_clique_names odd_'proc even_'proc\<close>)
      ["attribute" "<attribute>"]
  notes
    "distinct_names" =
      (\<open>all_distinct
               (Node Tip odd_'proc False
                 (Node Tip even_'proc False Tip))\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_impl_axioms" =
      (\<open>odd_impl \<Gamma> N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat even_'proc odd_'proc\<close>)
      ["attribute" "<attribute>"]
  notes
    "even_impl_axioms" =
      (\<open>even_impl \<Gamma> N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat even_'proc odd_'proc\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even_clique_axioms" =
      (\<open>odd_even_clique \<Gamma> N_'odd_even_' A_'odd_even_'
               project_Nat_nat inject_Nat_nat even_'proc odd_'proc\<close>)
      ["attribute" "<attribute>"]
  notes "odd_impl" = \<open>\<Gamma> odd_'proc = Some local.odd_body\<close>
  notes
    "even_impl" = \<open>\<Gamma> even_'proc = Some local.even_body\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
theorems:
  even_body.axioms:
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  even_body.even_body.cong:
    even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?odd_'proc ?even_'proc ==
    even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?odd_'proc ?even_'proc
  even_body.even_body_def:
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?odd_'proc ?even_'proc ==
    IF \<acute>(lookup ?project_Nat_nat ?N_'odd_even_') = 0
    THEN Basic
          (%s. s(| locals :=
                     update ?project_Nat_nat ?inject_Nat_nat ?A_'odd_even_'
                      (K_statefun 1) (locals s) |))
    ELSE IF \<acute>(lookup ?project_Nat_nat ?N_'odd_even_') = 1
         THEN call
               (%s. s(| locals :=
                          update ?project_Nat_nat ?inject_Nat_nat
                           ?N_'odd_even_'
                           (K_statefun
                             (lookup ?project_Nat_nat ?N_'odd_even_'
                               (locals s) -
                              1))
                           (locals s) |))
               ?odd_'proc (%s t. s(| globals := globals t |))
               (%i t. Basic
                       (%s. s(| locals :=
                                  update ?project_Nat_nat ?inject_Nat_nat
                                   ?A_'odd_even_'
                                   (K_statefun
                                     (lookup ?project_Nat_nat ?A_'odd_even_'
 (locals t)))
                                   (locals s) |)))
         ELSE call
               (%s. s(| locals :=
                          update ?project_Nat_nat ?inject_Nat_nat
                           ?N_'odd_even_'
                           (K_statefun
                             (lookup ?project_Nat_nat ?N_'odd_even_'
                               (locals s) -
                              2))
                           (locals s) |))
               ?even_'proc (%s t. s(| globals := globals t |))
               (%i t. Basic
                       (%s. s(| locals :=
                                  update ?project_Nat_nat ?inject_Nat_nat
                                   ?A_'odd_even_'
                                   (K_statefun
                                     (lookup ?project_Nat_nat ?A_'odd_even_'
 (locals t)))
                                   (locals s) |)))
         FI
    FI
  even_body.intro:
    [| odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat;
       odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat |]
    ==> even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
         ?inject_Nat_nat
  even_body_def:
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat &
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  even_impl.axioms:
    even_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  even_impl.intro:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    even_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  even_impl_def:
    even_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  even_signature.axioms:
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  even_signature.intro:
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  even_signature_def:
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_body.axioms:
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_body.intro:
    [| odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat;
       even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat |]
    ==> odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
         ?inject_Nat_nat
  odd_body.odd_body.cong:
    odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_body.odd_body_def:
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    IF \<acute>(lookup ?project_Nat_nat ?N_'odd_even_') = 0
    THEN Basic
          (%s. s(| locals :=
                     update ?project_Nat_nat ?inject_Nat_nat ?A_'odd_even_'
                      (K_statefun 0) (locals s) |))
    ELSE IF \<acute>(lookup ?project_Nat_nat ?N_'odd_even_') = 1
         THEN call
               (%s. s(| locals :=
                          update ?project_Nat_nat ?inject_Nat_nat
                           ?N_'odd_even_'
                           (K_statefun
                             (lookup ?project_Nat_nat ?N_'odd_even_'
                               (locals s) -
                              1))
                           (locals s) |))
               ?even_'proc (%s t. s(| globals := globals t |))
               (%i t. Basic
                       (%s. s(| locals :=
                                  update ?project_Nat_nat ?inject_Nat_nat
                                   ?A_'odd_even_'
                                   (K_statefun
                                     (lookup ?project_Nat_nat ?A_'odd_even_'
 (locals t)))
                                   (locals s) |)))
         ELSE call
               (%s. s(| locals :=
                          update ?project_Nat_nat ?inject_Nat_nat
                           ?N_'odd_even_'
                           (K_statefun
                             (lookup ?project_Nat_nat ?N_'odd_even_'
                               (locals s) -
                              2))
                           (locals s) |))
               ?odd_'proc (%s t. s(| globals := globals t |))
               (%i t. Basic
                       (%s. s(| locals :=
                                  update ?project_Nat_nat ?inject_Nat_nat
                                   ?A_'odd_even_'
                                   (K_statefun
                                     (lookup ?project_Nat_nat ?A_'odd_even_'
 (locals t)))
                                   (locals s) |)))
         FI
    FI
  odd_body_def:
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat &
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_even_clique.axioms:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat ?inject_Nat_nat
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat ?inject_Nat_nat
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_even_clique_names ?odd_'proc ?even_'proc
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
     ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_even_clique.even_impl:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    ?\<Gamma> ?even_'proc =
    Some
     (even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
       ?inject_Nat_nat ?odd_'proc ?even_'proc)
  odd_even_clique.intro:
    [| odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat;
       even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat;
       odd_even_clique_names ?odd_'proc ?even_'proc;
       odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
        ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc |]
    ==> odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
         ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_even_clique.odd_impl:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    ?\<Gamma> ?odd_'proc =
    Some
     (odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
       ?inject_Nat_nat ?even_'proc ?odd_'proc)
  odd_even_clique_axioms.intro:
    [| ?\<Gamma> ?odd_'proc =
       Some
        (odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
          ?inject_Nat_nat ?even_'proc ?odd_'proc);
       ?\<Gamma> ?even_'proc =
       Some
        (even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
          ?inject_Nat_nat ?odd_'proc ?even_'proc) |]
    ==> odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
         ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_even_clique_axioms_def:
    odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
     ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    ?\<Gamma> ?odd_'proc =
    Some
     (odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
       ?inject_Nat_nat ?even_'proc ?odd_'proc) &
    ?\<Gamma> ?even_'proc =
    Some
     (even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
       ?inject_Nat_nat ?odd_'proc ?even_'proc)
  odd_even_clique_def:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    (odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
      ?inject_Nat_nat &
     even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
      ?inject_Nat_nat) &
    odd_even_clique_names ?odd_'proc ?even_'proc &
    odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
     ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_even_clique_names.distinct_names:
    odd_even_clique_names ?odd_'proc ?even_'proc ==>
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip))
  odd_even_clique_names.intro:
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip)) ==>
    odd_even_clique_names ?odd_'proc ?even_'proc
  odd_even_clique_names_def:
    odd_even_clique_names ?odd_'proc ?even_'proc ==
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip))
  odd_even_parameters.axioms:
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_'
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_parameters.intro:
    [| odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_';
       odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat |]
    ==> odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
         ?inject_Nat_nat
  odd_even_parameters_def:
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_' &
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_parameters_namespace.distinct_names:
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_' ==>
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip))
  odd_even_parameters_namespace.intro:
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip)) ==>
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_'
  odd_even_parameters_namespace_def:
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_' ==
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip))
  odd_even_parameters_valuetypes.axioms:
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat ==>
    project_inject ?project_Nat_nat ?inject_Nat_nat
  odd_even_parameters_valuetypes.intro:
    project_inject ?project_Nat_nat ?inject_Nat_nat ==>
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_parameters_valuetypes_def:
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat ==
    project_inject ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables.axioms:
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_'
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables.intro:
    [| odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_';
       odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat |]
    ==> odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
         ?inject_Nat_nat
  odd_even_variables_def:
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_' &
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables_namespace.distinct_names:
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_' ==>
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip))
  odd_even_variables_namespace.intro:
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip)) ==>
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_'
  odd_even_variables_namespace_def:
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_' ==
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip))
  odd_even_variables_valuetypes.axioms:
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat ==>
    project_inject ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables_valuetypes.intro:
    project_inject ?project_Nat_nat ?inject_Nat_nat ==>
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables_valuetypes_def:
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat ==
    project_inject ?project_Nat_nat ?inject_Nat_nat
  odd_impl.axioms:
    odd_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_impl.intro:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_impl_def:
    odd_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_signature.axioms:
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_signature.intro:
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_signature_def:
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
val ProcRec2 =
   "[| ALL Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z, ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z, ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^bsub>/?F \<^esub>(?P1.0 Z) the (?\<Gamma> ?p1.0)
       (?Q1.0 Z),(?A1.0 Z);
       ALL Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z, ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z, ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^bsub>/?F \<^esub>(?P2.0 Z) the (?\<Gamma> ?p2.0)
       (?Q2.0 Z),(?A2.0 Z);
       ?p1.0 : dom ?\<Gamma>; ?p2.0 : dom ?\<Gamma> |]
    ==> (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^bsub>/?F \<^esub>(?P1.0 Z) Call ?p1.0
         (?Q1.0 Z),(?A1.0 Z)) &
        (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^bsub>/?F \<^esub>(?P2.0 Z) Call ?p2.0
         (?Q2.0 Z),(?A2.0 Z))":
   thm
val it = (): unit
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'odd_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'even_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
Defining statespace "globals_list" ...
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'append_'
variable not fixed or declared: q_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
Defining statespace "append_parameters" ...
Defining statespace "append_variables" ...
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
locale append_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a => 'b, 'c, 'd, 'e) stateSP_scheme, char list, 'f) com option"
    and p_'append_' :: "'c"
    and q_'append_' :: "'c"
    and project_Simpl_Heap_ref :: "'d => ref"
    and inject_Simpl_Heap_ref :: "ref => 'd"
    and StateType :: "'c => 'd"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and append_'proc :: "char list"
  assumes
    "append_impl \<Gamma> p_'append_' q_'append_' project_Simpl_Heap_ref
      inject_Simpl_Heap_ref next_' cont_' project_Nat_nat_Simpl_Heap_ref_fun
      inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun append_'proc"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
"call
  (%s. s(| locals :=
             update project_Simpl_Heap_ref inject_Simpl_Heap_ref q_'append_'
              (K_statefun
                (lookup project_Simpl_Heap_ref q_'append_' (locals s)))
              (update project_Simpl_Heap_ref inject_Simpl_Heap_ref
                p_'append_'
                (K_statefun
                  (lookup project_Simpl_Heap_ref p_'append_' (locals s)))
                (locals s)) |))
  append_'proc (%s t. s(| globals := globals t |))
  (%i t. lookup project_Simpl_Heap_ref p_'append_'
          (locals i)->\<acute>next :==
         lookup project_Simpl_Heap_ref p_'append_' (locals t))"
  :: "(('a => 'b, 'c, 'd, 'g) stateSP_scheme, char list, 'h) com"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
consts
  sorted :: "('a => 'a => bool) => 'a list => bool"
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: cont_'
variable not fixed or declared: cont_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: cont_'
variable not fixed or declared: cont_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'insert_'
variable not fixed or declared: r_'insert_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
Defining statespace "insert_parameters" ...
Defining statespace "insert_variables" ...
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'proc_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
Defining statespace "insertSort_parameters" ...
Defining statespace "insertSort_variables" ...
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'insert_'proc_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insertSort_'proc_'
locale insertSort_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a => 'b, 'c, 'd, 'e) stateSP_scheme, char list, 'f) com option"
    and p_'insertSort_' :: "'c"
    and r_'insertSort_' :: "'c"
    and q_'insertSort_' :: "'c"
    and project_Simpl_Heap_ref :: "'d => ref"
    and inject_Simpl_Heap_ref :: "ref => 'd"
    and StateType :: "'c => 'd"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and r_'insert_' :: "'c"
    and p_'insert_' :: "'c"
    and insert_'proc :: "char list"
    and insertSort_'proc :: "char list"
  assumes
    "insertSort_impl \<Gamma> p_'insertSort_' r_'insertSort_'
      q_'insertSort_' project_Simpl_Heap_ref inject_Simpl_Heap_ref next_'
      cont_' project_Nat_nat_Simpl_Heap_ref_fun
      inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun r_'insert_' p_'insert_'
      insert_'proc insertSort_'proc"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insertSort_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
Defining statespace "globals_list_alloc" ...
Defining statespace "locals_list_alloc" ...
locale list_alloc
  fixes alloc_' :: "'a"
    and free_' :: "'a"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and project_Nat_nat :: "'b => nat"
    and inject_Nat_nat :: "nat => 'b"
    and project_Simpl_Heap_ref_List_list :: "'b => ref list"
    and inject_Simpl_Heap_ref_List_list :: "ref list => 'b"
    and i_' :: "'c"
    and first_' :: "'c"
    and p_' :: "'c"
    and q_' :: "'c"
    and r_' :: "'c"
    and root_' :: "'c"
    and tmp_' :: "'c"
    and project_Simpl_Heap_ref :: "'b => ref"
    and inject_Simpl_Heap_ref :: "ref => 'b"
  assumes
    "list_alloc alloc_' free_' next_' cont_'
      project_Nat_nat_Simpl_Heap_ref_fun inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun project_Nat_nat
      inject_Nat_nat project_Simpl_Heap_ref_List_list
      inject_Simpl_Heap_ref_List_list i_' first_' p_' q_' r_' root_' tmp_'
      project_Simpl_Heap_ref inject_Simpl_Heap_ref"
locale list_alloc
  fixes alloc_' :: "'a"
    and free_' :: "'a"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and project_Nat_nat :: "'b => nat"
    and inject_Nat_nat :: "nat => 'b"
    and project_Simpl_Heap_ref_List_list :: "'b => ref list"
    and inject_Simpl_Heap_ref_List_list :: "ref list => 'b"
    and i_' :: "'c"
    and first_' :: "'c"
    and p_' :: "'c"
    and q_' :: "'c"
    and r_' :: "'c"
    and root_' :: "'c"
    and tmp_' :: "'c"
    and project_Simpl_Heap_ref :: "'b => ref"
    and inject_Simpl_Heap_ref :: "ref => 'b"
  assumes
    "list_alloc alloc_' free_' next_' cont_'
      project_Nat_nat_Simpl_Heap_ref_fun inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun project_Nat_nat
      inject_Nat_nat project_Simpl_Heap_ref_List_list
      inject_Simpl_Heap_ref_List_list i_' first_' p_' q_' r_' root_' tmp_'
      project_Simpl_Heap_ref inject_Simpl_Heap_ref"
locale state_space
  fixes A_' :: "'a"
    and I_' :: "'a"
    and M_' :: "'a"
    and N_' :: "'a"
    and R_' :: "'a"
    and S_' :: "'a"
    and B_' :: "'a"
    and Abr_' :: "'a"
    and project_Nat_nat :: "'b => nat"
    and inject_Nat_nat :: "nat => 'b"
    and project_HOL_bool :: "'b => bool"
    and inject_HOL_bool :: "bool => 'b"
    and project_String_char_List_list :: "'b => char list"
    and inject_String_char_List_list :: "char list => 'b"
  assumes
    "state_space A_' I_' M_' N_' R_' S_' B_' Abr_' project_Nat_nat
      inject_Nat_nat project_HOL_bool inject_HOL_bool
      project_String_char_List_list inject_String_char_List_list"
"ANNO (\<tau>, m, k). {|\<tau>. \<acute>M = m|}
 \<acute>M :== \<acute>N;; \<acute>N :== \<acute>I
 {|\<acute>M = \<^bsup>\<tau>\<^esup>N &
   \<acute>N = \<^bsup>\<tau>\<^esup>I|},
 {}"
  :: "(('c, 'a, 'b, 'd) stateSP_scheme, 'f, 'g) com"
### theory "Draft.VcgExSP"
### 1.865s elapsed time, 2.098s cpu time, 0.235s GC time
Loading theory "Draft.VcgExSPTemplates"
val templateLemmas =
   [("VcgExSP.fac_simp", "0 < ?i ==> fac ?i = ?i * fac (?i - 1)",
     template_implication
      ([template_inequation (less_than, template_hole 5, template_var 0)],
       template_equation
        (template_app (template_hole 3, template_var 0),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_app
            (template_hole 3,
             template_app
              (template_app (template_hole 1, template_var 0),
               template_hole 0)))))),
    ("VcgExSP.path_is_list",
     "[| Path ?b ?next ?a ?Ps; ?a ~: set ?Ps; ?a ~= Null |]
      ==> List ?b (?next(?a := Null)) (?Ps @ [?a])",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 10, template_var 3),
                  template_var 2),
                template_var 1),
              template_var 0)
            ),
        template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 8, template_var 1),
                  template_app (template_hole 7, template_var 0))
                )
            ),
        template_negation
         (template_equation (template_var 1, template_hole 5))],
       template_predicate
        (
           template_app
            (template_app
              (template_app (template_hole 4, template_var 3),
               template_app
                (template_app
                  (template_app (template_hole 3, template_var 2),
                   template_var 1),
                 template_hole 5)),
             template_app
              (template_app (template_hole 2, template_var 0),
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_hole 0)))
           ))),
    ("VcgExSP.neq_dP",
     "[| ?p ~= ?q; Path ?p ?h ?q ?Ps; distinct ?Ps |]
      ==> EX Qs. ?p ~= Null & ?Ps = ?p # Qs & ?p ~: set Qs",
     template_implication
      ([template_negation
         (template_equation (template_var 3, template_var 2)),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app (template_hole 8, template_var 3),
                  template_var 1),
                template_var 2),
              template_var 0)
            ),
        template_predicate
         (template_app (template_hole 7, template_var 0))],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("VcgExSP.CombineStrip'",
     "[| ?\<Gamma>,?\<Theta>\<turnstile>\<^bsub>/?F \<^esub>?P ?c' ?Q,?A;
         ?\<Gamma>,?\<Theta>|- ?P ?c'' UNIV,UNIV;
         ?c'' = mark_guards False (strip_guards (- ?F) ?c');
         ?c = mark_guards False ?c' |]
      ==> ?\<Gamma>,?\<Theta>|- ?P ?c ?Q,?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app (template_hole 7, template_var 8),
                        template_var 7),
                      template_var 6),
                    template_var 5),
                  template_var 4),
                template_var 3),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app
                     (template_app
                       (template_app (template_hole 7, template_var 8),
                        template_var 7),
                      template_hole 6),
                    template_var 5),
                  template_var 1),
                template_hole 5),
              template_hole 5)
            ),
        template_equation
         (template_var 1,
          template_app
           (template_app (template_hole 3, template_hole 2),
            template_app
             (template_app
               (template_hole 1,
                template_app (template_hole 0, template_var 6)),
              template_var 4))),
        template_equation
         (template_var 0,
          template_app
           (template_app (template_hole 3, template_hole 2),
            template_var 4))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 7, template_var 8),
                       template_var 7),
                     template_hole 6),
                   template_var 5),
                 template_var 0),
               template_var 3),
             template_var 2)
           ))),
    ("VcgExSP.ProcRec2",
     "[| ALL Z.
            ?\<Gamma>,?\<Theta> Un
                      ((UN Z. {(?P1.0 Z, ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                       (UN Z. {(?P2.0 Z, ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
               \<turnstile>\<^bsub>/?F \<^esub>(?P1.0 Z)
         the (?\<Gamma> ?p1.0) (?Q1.0 Z),(?A1.0 Z);
         ALL Z.
            ?\<Gamma>,?\<Theta> Un
                      ((UN Z. {(?P1.0 Z, ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                       (UN Z. {(?P2.0 Z, ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
               \<turnstile>\<^bsub>/?F \<^esub>(?P2.0 Z)
         the (?\<Gamma> ?p2.0) (?Q2.0 Z),(?A2.0 Z);
         ?p1.0 : dom ?\<Gamma>; ?p2.0 : dom ?\<Gamma> |]
      ==> (ALL Z.
              ?\<Gamma>,?\<Theta>
                 \<turnstile>\<^bsub>/?F \<^esub>(?P1.0 Z) Call ?p1.0
           (?Q1.0 Z),(?A1.0 Z)) &
          (ALL Z.
              ?\<Gamma>,?\<Theta>
                 \<turnstile>\<^bsub>/?F \<^esub>(?P2.0 Z) Call ?p2.0
           (?Q2.0 Z),(?A2.0 Z))",
     template_implication
      ([template_predicate (template_app (template_hole 15, t_empty)),
        template_predicate (template_app (template_hole 15, t_empty)),
        template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 7),
              template_app (template_hole 2, template_var 10))
            ),
        template_predicate
         (
            template_app
             (template_app (template_hole 3, template_var 3),
              template_app (template_hole 2, template_var 10))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1, template_app (template_hole 15, t_empty)),
             template_app (template_hole 15, t_empty))
           )))]:
   (string * thm * template) list
### theory "Draft.VcgExSPTemplates"
### 0.445s elapsed time, 0.640s cpu time, 0.120s GC time
val it = (): unit
