Loading theory "Draft.Language" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps" via "Draft.HoarePartialDef" via "Draft.Semantic")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.ProcParExSPTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.ProcParExSPTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.ProcParExSPTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.155s elapsed time, 0.621s cpu time, 0.074s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.ProcParExSPTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.270s elapsed time, 1.072s cpu time, 0.074s GC time
Loading theory "Draft.Generalise" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg")
### theory "HOL-Library.Nat_Bijection"
### 0.318s elapsed time, 1.276s cpu time, 0.074s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.ProcParExSPTemplates" via "Draft.ExtrEqs")
### ML warning (line 109 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 98 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 223 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 212 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 201 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 186 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 227 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 228 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 230 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 233 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 242 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 190 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 191 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 194 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 198 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 168 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 169 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 171 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 174 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 183 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 214 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 215 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 203 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 204 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 163 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
signature SPLIT_STATE =
  sig
    val abs_state: term -> term option
    val abs_var: Proof.context -> term -> string * typ
    val ex_tac: Proof.context -> term list -> tactic
    val isState: term -> bool
    val split_state:
       Proof.context -> string -> typ -> term -> term * term list
  end
functor GeneraliseFun (sig structure SplitState: SPLIT_STATE end): 
  sig
    val GENERALISE: Proof.context -> int -> tactic
    val OF_RAW: thm * thm -> thm
    val SIMPLE_OF: Proof.context -> thm -> thm list -> thm
    val SIMPLE_OF_RAW: Proof.context -> thm -> thm -> thm
    val conc_of: thm -> term
    val decomp:
       Proof.context ->
         term * cterm -> term list * cterm list * (thm list -> thm)
    val dest_All: term -> term
    val dest_prop: term -> term
    val eta_expand: Proof.context -> cterm -> cterm
    val genAll: thm
    val genAllShift: thm
    val genConj: thm
    val genEx: thm
    val genImp: thm
    val genImpl: thm
    val genRefl: thm
    val genRefl': thm
    val genTrans: thm
    val gen_all: thm
    val gen_allShift: thm
    val gen_thm:
       ('a * 'b -> 'a list * 'b list * ('c list -> 'c)) -> 'a * 'b -> 'c
    val generalise: Proof.context -> cterm -> thm
    val generalise_over_all_states_tac: Proof.context -> int -> tactic
    val generalise_over_tac:
       Proof.context -> (term -> term option) -> int -> thm -> thm Seq.seq
    val generalise_tac: Proof.context -> int -> thm -> thm Seq.seq
    val init: cterm -> thm
    val list_exists: (string * typ) list * term -> term
    val meta_spec: thm
    val prem_of: thm -> term
    val protectImp: thm
    val protectRefl: thm
    datatype qantifier = Hol_all | Hol_ex | Meta_all
    val spec': cterm -> thm -> thm
    val split_abs:
       Proof.context -> cterm -> (string * typ * term) * (cterm * cterm)
    val split_thm:
       qantifier -> Proof.context -> string -> typ -> term -> thm
  end
### theory "Draft.Generalise"
### 0.124s elapsed time, 0.496s cpu time, 0.000s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.ProcParExSPTemplates" via "Draft.ExtrEqs")
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
consts
  snth :: "'a stream => nat => 'a"
Found termination order: "size <*mlex*> {}"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 0.991s elapsed time, 3.746s cpu time, 0.721s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 1.053s elapsed time, 3.897s cpu time, 0.880s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 1.885s elapsed time, 6.160s cpu time, 1.108s GC time
Loading theory "Draft.Templates" (required by "Draft.ProcParExSPTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.049s elapsed time, 0.101s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.ProcParExSPTemplates")
consts
  switch ::
    "('s => 'v) => ('v set * ('s, 'p, 'f) com) list => ('s, 'p, 'f) com"
consts
  guards :: "('f * 's set) list => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  flatten :: "('s, 'p, 'f) com => ('s, 'p, 'f) com list"
consts
  sequence ::
    "(('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com)
     => ('s, 'p, 'f) com list => ('s, 'p, 'f) com"
consts
  normalize :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.753s elapsed time, 1.855s cpu time, 0.834s GC time
consts
  strip_guards :: "'f set => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  mark_guards :: "'f => ('s, 'p, 'g) com => ('s, 'p, 'f) com"
### No equation for constructor "Skip"
### No equation for constructor "Basic"
### No equation for constructor "Spec"
### No equation for constructor "Seq"
### No equation for constructor "Cond"
### No equation for constructor "While"
### No equation for constructor "Call"
### No equation for constructor "DynCom"
### No equation for constructor "Throw"
### No equation for constructor "Catch"
consts
  dest_Guard :: "('s, 'p, 'f) com => 'f * 's set * ('s, 'p, 'f) com"
consts
  merge_guards :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  noguards :: "('s, 'p, 'f) com => bool"
consts
  nothrows :: "('s, 'p, 'f) com => bool"
Proofs for inductive predicate(s) "com_relp"
  Proving monotonicity ...
### Legacy feature! Old 'recdef' command -- use 'fun' or 'function' instead
Defining recursive function "Language.inter_guards" ...
Proving induction theorem ...
Postprocessing ...
Simplifying nested TCs ...
... Postprocessing finished
Proving unsplit equation...
th:
(Skip \<inter>\<^sub>g Skip) = None ==> (Skip \<inter>\<^sub>g Skip) = None
split ths:
(Skip \<inter>\<^sub>g Basic ?bc) = None
(Skip \<inter>\<^sub>g Spec ?bd) = None
(Skip \<inter>\<^sub>g Seq ?be ?bf) = None
(Skip \<inter>\<^sub>g Cond ?bg ?bh ?bi) = None
(Skip \<inter>\<^sub>g While ?bj ?bk) = None
(Skip \<inter>\<^sub>g Call ?bl) = None
(Skip \<inter>\<^sub>g DynCom ?bm) = None
(Skip \<inter>\<^sub>g Guard ?bn ?bo ?bp) = None
(Skip \<inter>\<^sub>g Throw) = None
(Skip \<inter>\<^sub>g Catch ?bq ?br) = None
(Basic ?w \<inter>\<^sub>g Skip) = None
(Basic ?w \<inter>\<^sub>g Spec ?cj) = None
(Basic ?w \<inter>\<^sub>g Seq ?ck ?cl) = None
(Basic ?w \<inter>\<^sub>g Cond ?cm ?cn ?co) = None
(Basic ?w \<inter>\<^sub>g While ?cp ?cq) = None
(Basic ?w \<inter>\<^sub>g Call ?cr) = None
(Basic ?w \<inter>\<^sub>g DynCom ?cs) = None
(Basic ?w \<inter>\<^sub>g Guard ?ct ?cu ?cv) = None
(Basic ?w \<inter>\<^sub>g Throw) = None
(Basic ?w \<inter>\<^sub>g Catch ?cw ?cx) = None
(Spec ?x \<inter>\<^sub>g Skip) = None
(Spec ?x \<inter>\<^sub>g Basic ?do) = None
(Spec ?x \<inter>\<^sub>g Seq ?dq ?dr) = None
(Spec ?x \<inter>\<^sub>g Cond ?ds ?dt ?du) = None
(Spec ?x \<inter>\<^sub>g While ?dv ?dw) = None
(Spec ?x \<inter>\<^sub>g Call ?dx) = None
(Spec ?x \<inter>\<^sub>g DynCom ?dy) = None
(Spec ?x \<inter>\<^sub>g Guard ?dz ?ea ?eb) = None
(Spec ?x \<inter>\<^sub>g Throw) = None
(Spec ?x \<inter>\<^sub>g Catch ?ec ?ed) = None
(Seq ?y ?z \<inter>\<^sub>g Skip) = None
(Seq ?y ?z \<inter>\<^sub>g Basic ?ev) = None
(Seq ?y ?z \<inter>\<^sub>g Spec ?ew) = None
(Seq ?y ?z \<inter>\<^sub>g Cond ?ez ?fa ?fb) = None
(Seq ?y ?z \<inter>\<^sub>g While ?fc ?fd) = None
(Seq ?y ?z \<inter>\<^sub>g Call ?fe) = None
(Seq ?y ?z \<inter>\<^sub>g DynCom ?ff) = None
(Seq ?y ?z \<inter>\<^sub>g Guard ?fg ?fh ?fi) = None
(Seq ?y ?z \<inter>\<^sub>g Throw) = None
(Seq ?y ?z \<inter>\<^sub>g Catch ?fj ?fk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Skip) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Basic ?gb) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Spec ?gc) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Seq ?gd ?ge) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g While ?gi ?gj) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Call ?gk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g DynCom ?gl) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Guard ?gm ?gn ?go) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Throw) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Catch ?gp ?gq) = None
(While ?ad ?ae \<inter>\<^sub>g Skip) = None
(While ?ad ?ae \<inter>\<^sub>g Basic ?hh) = None
(While ?ad ?ae \<inter>\<^sub>g Spec ?hi) = None
(While ?ad ?ae \<inter>\<^sub>g Seq ?hj ?hk) = None
(While ?ad ?ae \<inter>\<^sub>g Cond ?hl ?hm ?hn) = None
(While ?ad ?ae \<inter>\<^sub>g Call ?hq) = None
(While ?ad ?ae \<inter>\<^sub>g DynCom ?hr) = None
(While ?ad ?ae \<inter>\<^sub>g Guard ?hs ?ht ?hu) = None
(While ?ad ?ae \<inter>\<^sub>g Throw) = None
(While ?ad ?ae \<inter>\<^sub>g Catch ?hv ?hw) = None
(Call ?af \<inter>\<^sub>g Skip) = None
(Call ?af \<inter>\<^sub>g Basic ?in) = None
(Call ?af \<inter>\<^sub>g Spec ?io) = None
(Call ?af \<inter>\<^sub>g Seq ?ip ?iq) = None
(Call ?af \<inter>\<^sub>g Cond ?ir ?is ?it) = None
(Call ?af \<inter>\<^sub>g While ?iu ?iv) = None
(Call ?af \<inter>\<^sub>g DynCom ?ix) = None
(Call ?af \<inter>\<^sub>g Guard ?iy ?iz ?ja) = None
(Call ?af \<inter>\<^sub>g Throw) = None
(Call ?af \<inter>\<^sub>g Catch ?jb ?jc) = None
(DynCom ?ag \<inter>\<^sub>g Skip) = None
(DynCom ?ag \<inter>\<^sub>g Basic ?jt) = None
(DynCom ?ag \<inter>\<^sub>g Spec ?ju) = None
(DynCom ?ag \<inter>\<^sub>g Seq ?jv ?jw) = None
(DynCom ?ag \<inter>\<^sub>g Cond ?jx ?jy ?jz) = None
(DynCom ?ag \<inter>\<^sub>g While ?ka ?kb) = None
(DynCom ?ag \<inter>\<^sub>g Call ?kc) = None
(DynCom ?ag \<inter>\<^sub>g Guard ?ke ?kf ?kg) = None
(DynCom ?ag \<inter>\<^sub>g Throw) = None
(DynCom ?ag \<inter>\<^sub>g Catch ?kh ?ki) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Skip) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Basic ?kz) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Spec ?la) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Seq ?lb ?lc) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Cond ?ld ?le ?lf) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g While ?lg ?lh) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Call ?li) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g DynCom ?lj) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Throw) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Catch ?ln ?lo) = None
(Throw \<inter>\<^sub>g Skip) = None
(Throw \<inter>\<^sub>g Basic ?mf) = None
(Throw \<inter>\<^sub>g Spec ?mg) = None
(Throw \<inter>\<^sub>g Seq ?mh ?mi) = None
(Throw \<inter>\<^sub>g Cond ?mj ?mk ?ml) = None
(Throw \<inter>\<^sub>g While ?mm ?mn) = None
(Throw \<inter>\<^sub>g Call ?mo) = None
(Throw \<inter>\<^sub>g DynCom ?mp) = None
(Throw \<inter>\<^sub>g Guard ?mq ?mr ?ms) = None
(Throw \<inter>\<^sub>g Catch ?mt ?mu) = None
(Catch ?ak ?al \<inter>\<^sub>g Skip) = None
(Catch ?ak ?al \<inter>\<^sub>g Basic ?nl) = None
(Catch ?ak ?al \<inter>\<^sub>g Spec ?nm) = None
(Catch ?ak ?al \<inter>\<^sub>g Seq ?nn ?no) = None
(Catch ?ak ?al \<inter>\<^sub>g Cond ?np ?nq ?nr) = None
(Catch ?ak ?al \<inter>\<^sub>g While ?ns ?nt) = None
(Catch ?ak ?al \<inter>\<^sub>g Call ?nu) = None
(Catch ?ak ?al \<inter>\<^sub>g DynCom ?nv) = None
(Catch ?ak ?al \<inter>\<^sub>g Guard ?nw ?nx ?ny) = None
(Catch ?ak ?al \<inter>\<^sub>g Throw) = None
--
### recdef (solve_eq): splitto: cannot find variable to split on
Proofs for inductive predicate(s) "subseteq_guards"
  Proving monotonicity ...
### theory "Draft.Language"
### 4.562s elapsed time, 10.493s cpu time, 2.122s GC time
Loading theory "Draft.Semantic" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps" via "Draft.HoarePartialDef")
Proofs for inductive predicate(s) "exec"
  Proving monotonicity ...
Proofs for inductive predicate(s) "execn"
  Proving monotonicity ...
### theory "Draft.Semantic"
### 1.978s elapsed time, 2.306s cpu time, 0.219s GC time
Loading theory "Draft.HoarePartialDef" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps")
Loading theory "Draft.Termination" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps" via "Draft.SmallStep")
Proofs for inductive predicate(s) "terminates"
### Ambiguous input (line 84 of "$AFP/Simpl/HoarePartialDef.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_position" n)
###       ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###         ("_position" \<Theta>) ("_position" n) ("_position" F)
###         ("_position" P) ("_position" c) ("_position" Q) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_tuple"
###       ("\<^const>HOL.All_binder" ("_position" n) ("_position" \<Gamma>))
###       ("_tuple_arg"
###         ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###           ("_position" n) ("_position" F) ("_position" P) ("_position" c)
###           ("_position" Q) ("_position" A)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoarep"
  Proving monotonicity ...
### theory "Draft.HoarePartialDef"
### 0.386s elapsed time, 0.959s cpu time, 0.305s GC time
Loading theory "Draft.HoarePartialProps" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial")
### Ambiguous input (line 1078 of "$AFP/Simpl/HoarePartialProps.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.All_binder" ("_position" n)
###             ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###               ("_position" \<Theta>) ("_position" n) ("_position" F)
###               ("_position" P') ("_position" c) ("_position" Q')
###               ("_position" A')))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("_tuple"
###             ("\<^const>HOL.All_binder" ("_position" n)
###               ("_position" \<Gamma>))
###             ("_tuple_arg"
###               ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###                 ("_position" n) ("_position" F) ("_position" P')
###                 ("_position" c) ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Termination"
### 0.864s elapsed time, 2.391s cpu time, 1.405s GC time
Loading theory "Draft.HoareTotalDef" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps")
Loading theory "Draft.SmallStep" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps")
### No equation for constructor "Spec"
consts
  procs :: "('s, 'p, 'f) com => 'p set"
consts
  noSpec :: "('s, 'p, 'f) com => bool"
consts
  redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
Proofs for inductive predicate(s) "step"
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoaret"
  Proving monotonicity ...
### theory "Draft.HoarePartialProps"
### 0.690s elapsed time, 2.030s cpu time, 0.393s GC time
Loading theory "Draft.HoarePartial" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare")
### theory "Draft.HoareTotalDef"
### 0.603s elapsed time, 1.948s cpu time, 0.382s GC time
val tranclp_induct2 =
   "[| ?r^++ (?aa, ?ab) (?ba, ?bb); !!a b. ?r (?aa, ?ab) (a, b) ==> ?P a b;
       !!a b aa ba.
          [| ?r^++ (?aa, ?ab) (a, b); ?r (a, b) (aa, ba); ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  subst_redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
val trancl_induct2 =
   "[| ((?aa, ?ab), ?ba, ?bb) : ?r^+;
       !!a b. ((?aa, ?ab), a, b) : ?r ==> ?P a b;
       !!a b aa ba.
          [| ((?aa, ?ab), a, b) : ?r^+; ((a, b), aa, ba) : ?r; ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  seq :: "(nat => ('s, 'p, 'f) com) => 'p => nat => ('s, 'p, 'f) com"
consts
  redexes :: "('s, 'p, 'f) com => ('s, 'p, 'f) com set"
### theory "Draft.HoarePartial"
### 0.661s elapsed time, 1.552s cpu time, 0.280s GC time
### theory "Draft.SmallStep"
### 1.198s elapsed time, 3.230s cpu time, 0.703s GC time
Loading theory "Draft.HoareTotalProps" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal")
### theory "Draft.HoareTotalProps"
### 1.064s elapsed time, 2.353s cpu time, 1.763s GC time
Loading theory "Draft.HoareTotal" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace" via "Draft.Hoare")
### theory "Draft.HoareTotal"
### 0.651s elapsed time, 0.715s cpu time, 0.085s GC time
Loading theory "Draft.Hoare" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg" via "Draft.StateSpace")
"\<Gamma>|-P c Q,A"
  :: "bool"
"\<Gamma>|-/F P c Q"
  :: "bool"
"\<Gamma>|-P c Q"
  :: "bool"
locale hoare
  fixes \<Gamma> :: "'p => ('s, 'p, 'f) com option"
"\<Gamma>|-/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^bsub>/F \<^esub>P c Q,A"
  :: "bool"
"\<Gamma>|-tP c Q"
  :: "bool"
"\<Gamma>|-tP c Q,A"
  :: "bool"
"\<Gamma>|-t/F P c Q"
  :: "bool"
"\<Gamma>|-t/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-t/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^sub>t\<^bsub>/F\<^esub> P c Q,A"
  :: "bool"
consts
  assoc :: "('a * 'b) list => 'a => 'b"
### theory "Draft.Hoare"
### 0.230s elapsed time, 0.340s cpu time, 0.120s GC time
Loading theory "Draft.StateSpace" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP" via "Draft.Vcg")
### theory "Draft.StateSpace"
### 0.245s elapsed time, 0.246s cpu time, 0.000s GC time
Loading theory "Draft.Vcg" (required by "Draft.ProcParExSPTemplates" via "Draft.ProcParExSP")
### Ignoring duplicate rewrite rule:
### ~ ~ ?y == ?y
### Ignoring duplicate rewrite rule:
### (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
### Ignoring duplicate rewrite rule:
### ?P1 | ~ ?P1 == True
### Ignoring duplicate rewrite rule:
### ~ ?P1 | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?x1 = ?x1 == True
### Ignoring duplicate rewrite rule:
### ~ True == False
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### (~ ?P1) = ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 = (~ ?P1) == False
### Ignoring duplicate rewrite rule:
### True = ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y = True == ?y
### Ignoring duplicate rewrite rule:
### False = ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 = False == ~ ?P1
### Ignoring duplicate rewrite rule:
### True --> ?y == ?y
### Ignoring duplicate rewrite rule:
### False --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> True == True
### Ignoring duplicate rewrite rule:
### ?P1 --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> False == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 --> ~ ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?y & True == ?y
### Ignoring duplicate rewrite rule:
### True & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & False == False
### Ignoring duplicate rewrite rule:
### False & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 & ~ ?P1 == False
### Ignoring duplicate rewrite rule:
### ~ ?P1 & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 | True == True
### Ignoring duplicate rewrite rule:
### True | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?y | False == ?y
### Ignoring duplicate rewrite rule:
### False | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
### Ignoring duplicate rewrite rule:
### ALL x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 == True
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x == True
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x ~= ?t1 == False
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 ~= x == False
### ML warning (line 165 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 450 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 455 of "$AFP/Simpl/hoare.ML"):
### Value identifier (prf) has not been referenced.
### ML warning (line 472 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 469 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 628 of "$AFP/Simpl/hoare.ML"):
### Value identifier (default_state_kind) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare.ML"):
### Value identifier (generate_guard) has not been referenced.
### ML warning (line 897 of "$AFP/Simpl/hoare.ML"):
### Value identifier (less) has not been referenced.
### ML warning (line 902 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1085 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1150 of "$AFP/Simpl/hoare.ML"):
### Value identifier (pE) has not been referenced.
### ML warning (line 1270 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fold_com) has not been referenced.
### ML warning (line 1386 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t1) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 1433 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1493 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1770 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1773 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1775 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1782 of "$AFP/Simpl/hoare.ML"):
### Value identifier (hoare) has not been referenced.
### ML warning (line 1872 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1842 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1940 of "$AFP/Simpl/hoare.ML"):
### Value identifier (mode) has not been referenced.
### ML warning (line 1982 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2012 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Q) has not been referenced.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Value identifier (a_vT) has not been referenced.
### ML warning (line 2076 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gT) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2094 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2118 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 2137 of "$AFP/Simpl/hoare.ML"):
### Value identifier (G) has not been referenced.
### ML warning (line 2287 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2382 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 2404 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2412 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fs) has not been referenced.
### ML warning (line 2459 of "$AFP/Simpl/hoare.ML"):
### Value identifier (b) has not been referenced.
### ML warning (line 2478 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (A) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 2720 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2737 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2744 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2832 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (name) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (destr) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2920 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fld_idx) has not been referenced.
### ML warning (line 2968 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3011 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3126 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 3114 of "$AFP/Simpl/hoare.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x_upd') has not been referenced.
### ML warning (line 3172 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3282 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3283 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3296 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3298 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3330 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
### ML warning (line 3336 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
signature HOARE =
  sig
    val BasicSimpTac:
       Proof.context ->
         state_kind -> bool -> thm list -> (int -> tactic) -> int -> tactic
    val add_foldcongs: thm list -> theory -> theory
    val add_foldcongsimps: thm list -> theory -> theory
    val add_params:
       morphism ->
         string ->
           (par_kind * string) list -> Context.generic -> Context.generic
    val add_recursive:
       morphism -> string -> Context.generic -> Context.generic
    val add_state_kind:
       morphism ->
         string -> state_kind -> Context.generic -> Context.generic
    datatype 'a bodykind = BodyTerm of 'a | BodyTyp of 'a
    val chopsfx: string -> string -> string
    val clique_name: string list -> string
    val deco: string
    val extern: Proof.context -> string -> string
    val gen_proc_rec: Proof.context -> hoareMode -> int -> thm
    val generate_guard: Proof.context -> term -> term option
    val get_data: Proof.context -> hoare_data
    val get_default_state_kind: Proof.context -> state_kind
    val get_foldcong_ss: theory -> simpset
    val get_params:
       string -> Proof.context -> (par_kind * string) list option
    val get_state_kind: string -> Proof.context -> state_kind option
    val hoare: (Proof.context -> Proof.method) context_parser
    datatype hoareMode = Partial | Total
    type hoare_data =
       {active_procs: string list list,
        default_state_kind: state_kind,
        generate_guard: stamp * (Proof.context -> term -> term option),
        hoare_tacs: (string * hoare_tac) list,
        proc_info: proc_info Symtab.table,
        vcg_simps: thm list, wp_tacs: (string * hoare_tac) list}
    val hoare_raw: (Proof.context -> Proof.method) context_parser
    val hoare_rule: (Proof.context -> Proof.method) context_parser
    val hoare_rule_tac: Proof.context -> thm list -> int -> tactic
    type hoare_tac =
       (bool -> int -> tactic) ->
         Proof.context -> hoareMode -> int -> tactic
    val implementationN: string
    val install_generate_guard:
       (Proof.context -> term -> term option) ->
         Context.generic -> Context.generic
    val is_state_var: string -> bool
    val modeqN: string
    val modexN: string
    val par_deco: string -> string
    datatype par_kind = In | Out
    val proc_deco: string
    type proc_info =
       {params: (par_kind * string) list,
        recursive: bool, state_kind: state_kind}
    val proc_specs: (bstring * string) list parser
    val remdeco: Proof.context -> string -> string
    val remdeco': string -> string
    val resuffix: string -> string -> string -> string
    val set_default_state_kind:
       state_kind -> Context.generic -> Context.generic
    val specL: string
    datatype state_kind = Function | Record
    val undeco: Proof.context -> term -> term
    val varname: string -> string
    val vcg: (Proof.context -> Proof.method) context_parser
    val vcg_step: (Proof.context -> Proof.method) context_parser
    val vcg_tac:
       string -> string -> string list -> Proof.context -> int -> tactic
  end
structure Hoare: HOARE
### ML warning (line 98 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 97 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ys) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 107 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 242 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 271 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 282 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 281 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 279 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 322 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_val) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 5 is redundant.
### ML warning (line 469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 492 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 499 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 502 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 533 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 535 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 581 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 583 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 667 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 701 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 699 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 706 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 750 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 14 is redundant.
### ML warning (line 758 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 786 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 773 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 788 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 800 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 825 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 813 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 816 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 837 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 827 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 851 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 839 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 842 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 876 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 975 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 972 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 969 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 967 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 965 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 963 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 961 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 959 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 957 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 953 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 993 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1042 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (values) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (idxs) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (value) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1098 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 2 is redundant.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (constr) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (dest) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd') has not been referenced.
### ML warning (line 1165 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1152 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1143 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1178 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1211 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 1235 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1274 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1300 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1302 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (result) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1341 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1362 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1442 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1439 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1473 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1492 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1502 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1506 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1525 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1542 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1534 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1555 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 1611 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 1602 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
signature HOARE_SYNTAX =
  sig
    val antiquoteCur: string
    val antiquoteOld: string
    val antiquoteOld_tr: Proof.context -> term list -> term
    val antiquote_applied_only_to: (term -> bool) -> term -> bool
    val antiquote_varname_tr: string -> term list -> term
    val app_quote_tr': Proof.context -> term -> term list -> term
    val assert_tr': Proof.context -> term list -> term
    val assign_tr: Proof.context -> term list -> term
    val assign_tr': Proof.context -> term list -> term
    val basic_assigns_tr: Proof.context -> term list -> term
    val basic_tr: Proof.context -> term list -> term
    val basic_tr': Proof.context -> term list -> term
    val bexp_tr': string -> Proof.context -> term list -> term
    val bind_tr': Proof.context -> term list -> term
    val call_ass_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr': Proof.context -> term list -> term
    val dyn_call_tr': Proof.context -> term list -> term
    val fcall_tr: Proof.context -> term list -> term
    val fcall_tr': Proof.context -> term list -> term
    val guarded_Assign_tr: Proof.context -> term list -> term
    val guarded_Cond_tr: Proof.context -> term list -> term
    val guarded_NNew_tr: Proof.context -> term list -> term
    val guarded_New_tr: Proof.context -> term list -> term
    val guarded_WhileFix_tr: Proof.context -> term list -> term
    val guarded_While_tr: Proof.context -> term list -> term
    val guards_tr': Proof.context -> term list -> term
    val hide_guards: bool Config.T
    val init_tr: Proof.context -> term list -> term
    val init_tr': Proof.context -> term list -> term
    val loc_tr: Proof.context -> term list -> term
    val loc_tr': Proof.context -> term list -> term
    val new_tr: Proof.context -> term list -> term
    val new_tr': Proof.context -> term list -> term
    val nnew_tr: Proof.context -> term list -> term
    val nnew_tr': Proof.context -> term list -> term
    val proc_ass_tr: Proof.context -> term list -> term
    val proc_tr: Proof.context -> term list -> term
    val proc_tr': Proof.context -> term list -> term
    val quote_mult_tr':
       Proof.context -> (term -> bool) -> string -> string -> term -> term
    val quote_tr: Proof.context -> string -> term -> term
    val quote_tr': Proof.context -> string -> term -> term
    val raise_tr: Proof.context -> term list -> term
    val raise_tr': Proof.context -> term list -> term
    val switch_tr': Proof.context -> term list -> term
    val update_comp:
       Proof.context ->
         string list -> bool -> bool -> xstring -> term -> term -> term
    val use_call_tr': bool Config.T
    val whileAnnoGFix_tr': Proof.context -> term list -> term
    val whileAnnoG_tr': Proof.context -> term list -> term
  end
structure Hoare_Syntax: HOARE_SYNTAX
### theory "Draft.Vcg"
### 3.473s elapsed time, 5.376s cpu time, 2.584s GC time
Loading theory "Draft.ProcParExSP" (required by "Draft.ProcParExSPTemplates")
Defining statespace "compare_parameters" ...
Defining statespace "compare_variables" ...
locale compare_signature
  fixes i_'compare_' :: "'a"
    and j_'compare_' :: "'a"
    and r_'compare_' :: "'a"
    and project_Nat_nat :: "'b => nat"
    and inject_Nat_nat :: "nat => 'b"
    and project_HOL_bool :: "'b => bool"
    and inject_HOL_bool :: "bool => 'b"
    and StateType :: "'a => 'b"
    and compare_'proc :: "char list"
  assumes
    "compare_signature i_'compare_' j_'compare_' r_'compare_'
      project_Nat_nat inject_Nat_nat project_HOL_bool inject_HOL_bool"
  notes
    "compare_parameters_namespace_axioms" =
      (\<open>compare_parameters_namespace i_'compare_' j_'compare_'
               r_'compare_'\<close>)
      ["attribute" "<attribute>"]
  notes
    "distinct_names" =
      (\<open>all_distinct
               (Node (Node Tip i_'compare_' False Tip) j_'compare_' False
                 (Node Tip r_'compare_' False Tip))\<close>)
      ["attribute" "<attribute>"]
  notes
    "Nat_nat.project_inject_axioms" =
      (\<open>project_inject project_Nat_nat inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes
    "Nat_nat.project_inject_cancel" =
      (\<open>project_Nat_nat (inject_Nat_nat ?x) = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.ex_project" = (\<open>EX v. project_Nat_nat v = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.project_inject_comp_id" =
      (\<open>project_Nat_nat o inject_Nat_nat = id\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.project_inject_comp_cancel" =
      (\<open>?f o project_Nat_nat o inject_Nat_nat = ?f\<close>)
      ["statefun_simp"]
  notes
    "HOL_bool.project_inject_axioms" =
      (\<open>project_inject project_HOL_bool inject_HOL_bool\<close>)
      ["attribute" "<attribute>"]
  notes
    "HOL_bool.project_inject_cancel" =
      (\<open>project_HOL_bool (inject_HOL_bool ?x) = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "HOL_bool.ex_project" = (\<open>EX v. project_HOL_bool v = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "HOL_bool.project_inject_comp_id" =
      (\<open>project_HOL_bool o inject_HOL_bool = id\<close>)
      ["statefun_simp"]
  notes theorem
    "HOL_bool.project_inject_comp_cancel" =
      (\<open>?f o project_HOL_bool o inject_HOL_bool = ?f\<close>)
      ["statefun_simp"]
  notes
    "compare_parameters_valuetypes_axioms" =
      (\<open>compare_parameters_valuetypes project_Nat_nat inject_Nat_nat
               project_HOL_bool inject_HOL_bool\<close>)
      ["attribute" "<attribute>"]
  notes
    "compare_parameters_axioms" =
      (\<open>compare_parameters i_'compare_' j_'compare_' r_'compare_'
               project_Nat_nat inject_Nat_nat project_HOL_bool
               inject_HOL_bool\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "compare_signature_axioms" =
      (\<open>compare_signature i_'compare_' j_'compare_' r_'compare_'
               project_Nat_nat inject_Nat_nat project_HOL_bool
               inject_HOL_bool\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
locale compare_impl
  fixes \<Gamma> :: "'a => ('b, 'a, 'c) com option"
    and i_'compare_' :: "'d"
    and j_'compare_' :: "'d"
    and r_'compare_' :: "'d"
    and project_Nat_nat :: "'e => nat"
    and inject_Nat_nat :: "nat => 'e"
    and project_HOL_bool :: "'e => bool"
    and inject_HOL_bool :: "bool => 'e"
    and StateType :: "'d => 'e"
    and compare_'proc :: "char list"
  assumes
    "compare_impl i_'compare_' j_'compare_' r_'compare_' project_Nat_nat
      inject_Nat_nat project_HOL_bool inject_HOL_bool"
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
Defining statespace "LEQ_parameters" ...
"call
  (%s. s(| locals :=
             update project_Nat_nat inject_Nat_nat j_'compare_'
              (K_statefun (lookup project_Nat_nat j_'compare_' (locals s)))
              (update project_Nat_nat inject_Nat_nat i_'compare_'
                (K_statefun
                  (lookup project_Nat_nat i_'compare_' (locals s)))
                (locals s)) |))
  compare_'proc (%s t. s(| globals := globals t |))
  (%i t. \<acute>r :== lookup project_HOL_bool r_'compare_' (locals t))"
  :: "(('f, 'd, 'e, 'g) stateSP_scheme, char list, 'h) com"
Defining statespace "LEQ_variables" ...
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
Defining statespace "Max_parameters" ...
Defining statespace "Max_variables" ...
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'compare_'proc_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
locale Max_spec
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and Max_'proc :: "char list"
    and i_'compare_' :: "'b"
    and j_'compare_' :: "'b"
    and r_'compare_' :: "'b"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and compare_'proc :: "char list"
  assumes
    "Max_spec \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_'
      project_Nat_nat inject_Nat_nat project_String_char_List_list
      inject_String_char_List_list Max_'proc i_'compare_' j_'compare_'
      r_'compare_' project_HOL_bool inject_HOL_bool"
ALL \<sigma>.
   \<Gamma>
      |-({\<sigma>} Int
         {|(ALL \<tau>.
               \<Gamma>
                  |-{\<tau>} Call \<acute>compare
                    {s. \<^bsup>s\<^esup>r =
                        ?leq \<^bsup>\<tau>\<^esup>i
                         \<^bsup>\<tau>\<^esup>j}) &
           (ALL \<tau>.
               \<Gamma>
                  |-{\<tau>} Call \<acute>compare
                    {t. t may_not_modify_globals \<tau>})|})
        \<acute>k :== PROC Max(\<acute>compare,\<acute>n,\<acute>m)
        {|\<acute>k =
          mx ?leq \<^bsup>\<sigma>\<^esup>n \<^bsup>\<sigma>\<^esup>m|}
locale Max_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and b_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and i_'compare_' :: "'b"
    and j_'compare_' :: "'b"
    and r_'compare_' :: "'b"
    and compare_'proc :: "char list"
    and Max_'proc :: "char list"
  assumes
    "Max_impl \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_' b_'Max_'
      project_Nat_nat inject_Nat_nat project_HOL_bool inject_HOL_bool
      project_String_char_List_list inject_String_char_List_list
      i_'compare_' j_'compare_' r_'compare_' Max_'proc"
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'compare_'proc_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'compare_'proc_'
"\<acute>b :== DYNCALL \<acute>compare(\<acute>n,\<acute>m)"
  :: "(('f, 'b, 'c, 'g) stateSP_scheme, char list, 'h) com"
"dynCall
  (%s. s(| locals :=
             update project_Nat_nat inject_Nat_nat j_'compare_'
              (K_statefun (lookup project_Nat_nat m_'Max_' (locals s)))
              (update project_Nat_nat inject_Nat_nat i_'compare_'
                (K_statefun (lookup project_Nat_nat n_'Max_' (locals s)))
                (locals s)) |))
  (%s. lookup project_String_char_List_list compare_'Max_' (locals s))
  (%s t. s(| globals := globals t |))
  (%i t. \<acute>b :== lookup project_HOL_bool r_'compare_' (locals t))"
  :: "(('f, 'b, 'c, 'g) stateSP_scheme, char list, 'h) com"
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
locale Max_spec
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and Max_'proc :: "char list"
    and i_'compare_' :: "'b"
    and j_'compare_' :: "'b"
    and r_'compare_' :: "'b"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and compare_'proc :: "char list"
  assumes
    "Max_spec \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_'
      project_Nat_nat inject_Nat_nat project_String_char_List_list
      inject_String_char_List_list Max_'proc i_'compare_' j_'compare_'
      r_'compare_' project_HOL_bool inject_HOL_bool"
locale Max_test
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and Max_'proc :: "char list"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and compare_'proc :: "char list"
    and i_'LEQ_' :: "'b"
    and j_'LEQ_' :: "'b"
    and r_'LEQ_' :: "'b"
    and LEQ_'proc :: "char list"
  assumes
    "Max_test \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_'
      project_Nat_nat inject_Nat_nat project_String_char_List_list
      inject_String_char_List_list Max_'proc project_HOL_bool
      inject_HOL_bool i_'LEQ_' j_'LEQ_' r_'LEQ_' LEQ_'proc"
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
locale Max_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and b_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and i_'compare_' :: "'b"
    and j_'compare_' :: "'b"
    and r_'compare_' :: "'b"
    and compare_'proc :: "char list"
    and Max_'proc :: "char list"
  assumes
    "Max_impl \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_' b_'Max_'
      project_Nat_nat inject_Nat_nat project_HOL_bool inject_HOL_bool
      project_String_char_List_list inject_String_char_List_list
      i_'compare_' j_'compare_' r_'compare_' Max_'proc"
locale Max_test'
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and b_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and compare_'proc :: "char list"
    and Max_'proc :: "char list"
    and i_'LEQ_' :: "'b"
    and j_'LEQ_' :: "'b"
    and r_'LEQ_' :: "'b"
    and LEQ_'proc :: "char list"
  assumes
    "Max_test' \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_' b_'Max_'
      project_Nat_nat inject_Nat_nat project_HOL_bool inject_HOL_bool
      project_String_char_List_list inject_String_char_List_list Max_'proc
      i_'LEQ_' j_'LEQ_' r_'LEQ_' LEQ_'proc"
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'LEQ_'
### theory "Draft.ProcParExSP"
### 0.850s elapsed time, 0.914s cpu time, 0.050s GC time
Loading theory "Draft.ProcParExSPTemplates"
val templateLemmas =
   [("ProcParExSP.conseq_exploit_pre'",
     "ALL s:?S. ?\<Gamma>,?\<Theta>|- ({s} Int ?P) ?c ?Q,?A ==>
      ?\<Gamma>,?\<Theta>|- (?P Int ?S) ?c ?Q,?A",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 6), t_empty)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 4, template_var 5),
                       template_var 4),
                     template_hole 3),
                   template_app
                    (template_app (template_hole 2, template_var 3),
                     template_var 6)),
                 template_var 2),
               template_var 1),
             template_var 0)
           ))),
    ("ProcParExSP.conseq_exploit_pre'''",
     "ALL s:?S.
         ALL Z. ?\<Gamma>,?\<Theta>|- ({s} Int ?P Z) ?c (?Q Z),(?A Z) ==>
      ALL Z. ?\<Gamma>,?\<Theta>|- (?P Z Int ?S) ?c (?Q Z),(?A Z)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 6), t_empty)
            )],
       template_predicate (template_app (template_hole 5, t_empty)))),
    ("ProcParExSP.conseq_exploit_pre''",
     "ALL Z.
         ALL s:?S Z.
            ?\<Gamma>,?\<Theta>|- ({s} Int ?P Z) ?c (?Q Z),(?A Z) ==>
      ALL Z. ?\<Gamma>,?\<Theta>|- (?P Z Int ?S Z) ?c (?Q Z),(?A Z)",
     template_implication
      ([template_predicate (template_app (template_hole 6, t_empty))],
       template_predicate (template_app (template_hole 6, t_empty)))),
    ("ProcParExSP.DynProcProcPar'",
     "[| ?P <= {s. ?p s = ?q &
                   (EX Z. ?init s : ?P' Z &
                          (ALL t:?Q' Z. ?return s t : ?R s t) &
                          (ALL t:?A' Z. ?return s t : ?A))};
         ALL s t.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^bsub>/?F \<^esub>(?R s t) ?result s t ?Q,?A;
         ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^bsub>/?F \<^esub>(?P' Z) Call ?q (?Q' Z),
         (?A' Z) |]
      ==> ?\<Gamma>,?\<Theta>
             \<turnstile>\<^bsub>/?F \<^esub>?P
       dynCall ?init ?p ?return ?result ?Q,?A",
     template_implication
      ([template_inequation
         (less_equals, template_var 14,
          template_app (template_hole 10, t_empty)),
        template_predicate (template_app (template_hole 4, t_empty)),
        template_predicate (template_app (template_hole 2, t_empty))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 3, template_var 4),
                       template_var 3),
                     template_var 2),
                   template_var 14),
                 template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 0, template_var 11),
                       template_var 13),
                     template_var 8),
                   template_var 1)),
               template_var 0),
             template_var 5)
           )))]:
   (string * thm * template) list
### theory "Draft.ProcParExSPTemplates"
### 0.417s elapsed time, 0.599s cpu time, 0.086s GC time
val it = (): unit
