Loading theory "Draft.Simpl_Heap" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.SyntaxTest" via "Draft.HeapList")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.SimplTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "Draft.Language" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps" via "Draft.HoarePartialDef" via "Draft.Semantic")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.SimplTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "Draft.Simpl_Heap"
### 0.075s elapsed time, 0.330s cpu time, 0.000s GC time
Loading theory "Draft.HeapList" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.SyntaxTest")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  Path :: "ref => (ref => ref) => ref => ref list => bool"
### theory "HOL-Library.Function_Algebras"
### 0.155s elapsed time, 0.632s cpu time, 0.064s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.SimplTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
Found termination order: "size_list size <*mlex*> {}"
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### theory "Draft.HeapList"
### 0.145s elapsed time, 0.565s cpu time, 0.064s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.SimplTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Nat_Bijection"
### 0.285s elapsed time, 1.146s cpu time, 0.064s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.SimplTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.Set_Algebras"
### 0.220s elapsed time, 0.878s cpu time, 0.000s GC time
Loading theory "Draft.Generalise" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.SyntaxTest" via "Draft.Vcg")
### ML warning (line 109 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 98 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 223 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 212 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 201 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 186 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/generalise_state.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 245 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 227 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 228 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 230 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 233 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 242 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 190 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 191 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 194 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 198 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 168 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 169 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 171 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 174 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 183 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 214 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 215 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 203 of "$AFP/Simpl/generalise_state.ML"):
### Pattern is not exhaustive.
### ML warning (line 204 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 163 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "$AFP/Simpl/generalise_state.ML"):
### Matches are not exhaustive.
signature SPLIT_STATE =
  sig
    val abs_state: term -> term option
    val abs_var: Proof.context -> term -> string * typ
    val ex_tac: Proof.context -> term list -> tactic
    val isState: term -> bool
    val split_state:
       Proof.context -> string -> typ -> term -> term * term list
  end
functor GeneraliseFun (sig structure SplitState: SPLIT_STATE end): 
  sig
    val GENERALISE: Proof.context -> int -> tactic
    val OF_RAW: thm * thm -> thm
    val SIMPLE_OF: Proof.context -> thm -> thm list -> thm
    val SIMPLE_OF_RAW: Proof.context -> thm -> thm -> thm
    val conc_of: thm -> term
    val decomp:
       Proof.context ->
         term * cterm -> term list * cterm list * (thm list -> thm)
    val dest_All: term -> term
    val dest_prop: term -> term
    val eta_expand: Proof.context -> cterm -> cterm
    val genAll: thm
    val genAllShift: thm
    val genConj: thm
    val genEx: thm
    val genImp: thm
    val genImpl: thm
    val genRefl: thm
    val genRefl': thm
    val genTrans: thm
    val gen_all: thm
    val gen_allShift: thm
    val gen_thm:
       ('a * 'b -> 'a list * 'b list * ('c list -> 'c)) -> 'a * 'b -> 'c
    val generalise: Proof.context -> cterm -> thm
    val generalise_over_all_states_tac: Proof.context -> int -> tactic
    val generalise_over_tac:
       Proof.context -> (term -> term option) -> int -> thm -> thm Seq.seq
    val generalise_tac: Proof.context -> int -> thm -> thm Seq.seq
    val init: cterm -> thm
    val list_exists: (string * typ) list * term -> term
    val meta_spec: thm
    val prem_of: thm -> term
    val protectImp: thm
    val protectRefl: thm
    datatype qantifier = Hol_all | Hol_ex | Meta_all
    val spec': cterm -> thm -> thm
    val split_abs:
       Proof.context -> cterm -> (string * typ * term) * (cterm * cterm)
    val split_thm:
       qantifier -> Proof.context -> string -> typ -> term -> thm
  end
### theory "Draft.Generalise"
### 0.146s elapsed time, 0.563s cpu time, 0.235s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.SimplTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  snth :: "'a stream => nat => 'a"
Found termination order: "size <*mlex*> {}"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.041s elapsed time, 3.912s cpu time, 0.945s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.BigO"
### 0.949s elapsed time, 3.439s cpu time, 0.858s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 1.871s elapsed time, 5.974s cpu time, 1.244s GC time
Loading theory "Draft.Templates" (required by "Draft.SimplTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.075s elapsed time, 0.194s cpu time, 0.095s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.SimplTemplates")
consts
  switch ::
    "('s => 'v) => ('v set * ('s, 'p, 'f) com) list => ('s, 'p, 'f) com"
consts
  guards :: "('f * 's set) list => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  flatten :: "('s, 'p, 'f) com => ('s, 'p, 'f) com list"
consts
  sequence ::
    "(('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com)
     => ('s, 'p, 'f) com list => ('s, 'p, 'f) com"
consts
  normalize :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  strip_guards :: "'f set => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.514s elapsed time, 1.077s cpu time, 0.102s GC time
consts
  mark_guards :: "'f => ('s, 'p, 'g) com => ('s, 'p, 'f) com"
### No equation for constructor "Skip"
### No equation for constructor "Basic"
### No equation for constructor "Spec"
### No equation for constructor "Seq"
### No equation for constructor "Cond"
### No equation for constructor "While"
### No equation for constructor "Call"
### No equation for constructor "DynCom"
### No equation for constructor "Throw"
### No equation for constructor "Catch"
consts
  dest_Guard :: "('s, 'p, 'f) com => 'f * 's set * ('s, 'p, 'f) com"
consts
  merge_guards :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
consts
  noguards :: "('s, 'p, 'f) com => bool"
consts
  nothrows :: "('s, 'p, 'f) com => bool"
Proofs for inductive predicate(s) "com_relp"
  Proving monotonicity ...
### Legacy feature! Old 'recdef' command -- use 'fun' or 'function' instead
Defining recursive function "Language.inter_guards" ...
Proving induction theorem ...
Postprocessing ...
Simplifying nested TCs ...
... Postprocessing finished
Proving unsplit equation...
th:
(Skip \<inter>\<^sub>g Skip) = None ==> (Skip \<inter>\<^sub>g Skip) = None
split ths:
(Skip \<inter>\<^sub>g Basic ?bc) = None
(Skip \<inter>\<^sub>g Spec ?bd) = None
(Skip \<inter>\<^sub>g Seq ?be ?bf) = None
(Skip \<inter>\<^sub>g Cond ?bg ?bh ?bi) = None
(Skip \<inter>\<^sub>g While ?bj ?bk) = None
(Skip \<inter>\<^sub>g Call ?bl) = None
(Skip \<inter>\<^sub>g DynCom ?bm) = None
(Skip \<inter>\<^sub>g Guard ?bn ?bo ?bp) = None
(Skip \<inter>\<^sub>g Throw) = None
(Skip \<inter>\<^sub>g Catch ?bq ?br) = None
(Basic ?w \<inter>\<^sub>g Skip) = None
(Basic ?w \<inter>\<^sub>g Spec ?cj) = None
(Basic ?w \<inter>\<^sub>g Seq ?ck ?cl) = None
(Basic ?w \<inter>\<^sub>g Cond ?cm ?cn ?co) = None
(Basic ?w \<inter>\<^sub>g While ?cp ?cq) = None
(Basic ?w \<inter>\<^sub>g Call ?cr) = None
(Basic ?w \<inter>\<^sub>g DynCom ?cs) = None
(Basic ?w \<inter>\<^sub>g Guard ?ct ?cu ?cv) = None
(Basic ?w \<inter>\<^sub>g Throw) = None
(Basic ?w \<inter>\<^sub>g Catch ?cw ?cx) = None
(Spec ?x \<inter>\<^sub>g Skip) = None
(Spec ?x \<inter>\<^sub>g Basic ?do) = None
(Spec ?x \<inter>\<^sub>g Seq ?dq ?dr) = None
(Spec ?x \<inter>\<^sub>g Cond ?ds ?dt ?du) = None
(Spec ?x \<inter>\<^sub>g While ?dv ?dw) = None
(Spec ?x \<inter>\<^sub>g Call ?dx) = None
(Spec ?x \<inter>\<^sub>g DynCom ?dy) = None
(Spec ?x \<inter>\<^sub>g Guard ?dz ?ea ?eb) = None
(Spec ?x \<inter>\<^sub>g Throw) = None
(Spec ?x \<inter>\<^sub>g Catch ?ec ?ed) = None
(Seq ?y ?z \<inter>\<^sub>g Skip) = None
(Seq ?y ?z \<inter>\<^sub>g Basic ?ev) = None
(Seq ?y ?z \<inter>\<^sub>g Spec ?ew) = None
(Seq ?y ?z \<inter>\<^sub>g Cond ?ez ?fa ?fb) = None
(Seq ?y ?z \<inter>\<^sub>g While ?fc ?fd) = None
(Seq ?y ?z \<inter>\<^sub>g Call ?fe) = None
(Seq ?y ?z \<inter>\<^sub>g DynCom ?ff) = None
(Seq ?y ?z \<inter>\<^sub>g Guard ?fg ?fh ?fi) = None
(Seq ?y ?z \<inter>\<^sub>g Throw) = None
(Seq ?y ?z \<inter>\<^sub>g Catch ?fj ?fk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Skip) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Basic ?gb) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Spec ?gc) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Seq ?gd ?ge) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g While ?gi ?gj) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Call ?gk) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g DynCom ?gl) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Guard ?gm ?gn ?go) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Throw) = None
(Cond ?aa ?ab ?ac \<inter>\<^sub>g Catch ?gp ?gq) = None
(While ?ad ?ae \<inter>\<^sub>g Skip) = None
(While ?ad ?ae \<inter>\<^sub>g Basic ?hh) = None
(While ?ad ?ae \<inter>\<^sub>g Spec ?hi) = None
(While ?ad ?ae \<inter>\<^sub>g Seq ?hj ?hk) = None
(While ?ad ?ae \<inter>\<^sub>g Cond ?hl ?hm ?hn) = None
(While ?ad ?ae \<inter>\<^sub>g Call ?hq) = None
(While ?ad ?ae \<inter>\<^sub>g DynCom ?hr) = None
(While ?ad ?ae \<inter>\<^sub>g Guard ?hs ?ht ?hu) = None
(While ?ad ?ae \<inter>\<^sub>g Throw) = None
(While ?ad ?ae \<inter>\<^sub>g Catch ?hv ?hw) = None
(Call ?af \<inter>\<^sub>g Skip) = None
(Call ?af \<inter>\<^sub>g Basic ?in) = None
(Call ?af \<inter>\<^sub>g Spec ?io) = None
(Call ?af \<inter>\<^sub>g Seq ?ip ?iq) = None
(Call ?af \<inter>\<^sub>g Cond ?ir ?is ?it) = None
(Call ?af \<inter>\<^sub>g While ?iu ?iv) = None
(Call ?af \<inter>\<^sub>g DynCom ?ix) = None
(Call ?af \<inter>\<^sub>g Guard ?iy ?iz ?ja) = None
(Call ?af \<inter>\<^sub>g Throw) = None
(Call ?af \<inter>\<^sub>g Catch ?jb ?jc) = None
(DynCom ?ag \<inter>\<^sub>g Skip) = None
(DynCom ?ag \<inter>\<^sub>g Basic ?jt) = None
(DynCom ?ag \<inter>\<^sub>g Spec ?ju) = None
(DynCom ?ag \<inter>\<^sub>g Seq ?jv ?jw) = None
(DynCom ?ag \<inter>\<^sub>g Cond ?jx ?jy ?jz) = None
(DynCom ?ag \<inter>\<^sub>g While ?ka ?kb) = None
(DynCom ?ag \<inter>\<^sub>g Call ?kc) = None
(DynCom ?ag \<inter>\<^sub>g Guard ?ke ?kf ?kg) = None
(DynCom ?ag \<inter>\<^sub>g Throw) = None
(DynCom ?ag \<inter>\<^sub>g Catch ?kh ?ki) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Skip) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Basic ?kz) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Spec ?la) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Seq ?lb ?lc) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Cond ?ld ?le ?lf) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g While ?lg ?lh) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Call ?li) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g DynCom ?lj) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Throw) = None
(Guard ?ah ?ai ?aj \<inter>\<^sub>g Catch ?ln ?lo) = None
(Throw \<inter>\<^sub>g Skip) = None
(Throw \<inter>\<^sub>g Basic ?mf) = None
(Throw \<inter>\<^sub>g Spec ?mg) = None
(Throw \<inter>\<^sub>g Seq ?mh ?mi) = None
(Throw \<inter>\<^sub>g Cond ?mj ?mk ?ml) = None
(Throw \<inter>\<^sub>g While ?mm ?mn) = None
(Throw \<inter>\<^sub>g Call ?mo) = None
(Throw \<inter>\<^sub>g DynCom ?mp) = None
(Throw \<inter>\<^sub>g Guard ?mq ?mr ?ms) = None
(Throw \<inter>\<^sub>g Catch ?mt ?mu) = None
(Catch ?ak ?al \<inter>\<^sub>g Skip) = None
(Catch ?ak ?al \<inter>\<^sub>g Basic ?nl) = None
(Catch ?ak ?al \<inter>\<^sub>g Spec ?nm) = None
(Catch ?ak ?al \<inter>\<^sub>g Seq ?nn ?no) = None
(Catch ?ak ?al \<inter>\<^sub>g Cond ?np ?nq ?nr) = None
(Catch ?ak ?al \<inter>\<^sub>g While ?ns ?nt) = None
(Catch ?ak ?al \<inter>\<^sub>g Call ?nu) = None
(Catch ?ak ?al \<inter>\<^sub>g DynCom ?nv) = None
(Catch ?ak ?al \<inter>\<^sub>g Guard ?nw ?nx ?ny) = None
(Catch ?ak ?al \<inter>\<^sub>g Throw) = None
--
### recdef (solve_eq): splitto: cannot find variable to split on
Proofs for inductive predicate(s) "subseteq_guards"
  Proving monotonicity ...
### theory "Draft.Language"
### 4.460s elapsed time, 10.549s cpu time, 2.408s GC time
Loading theory "Draft.Semantic" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps" via "Draft.HoarePartialDef")
Proofs for inductive predicate(s) "exec"
  Proving monotonicity ...
Proofs for inductive predicate(s) "execn"
  Proving monotonicity ...
### theory "Draft.Semantic"
### 1.970s elapsed time, 2.277s cpu time, 0.190s GC time
Loading theory "Draft.HoarePartialDef" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial" via "Draft.HoarePartialProps")
Loading theory "Draft.Termination" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps" via "Draft.SmallStep")
Proofs for inductive predicate(s) "terminates"
### Ambiguous input (line 84 of "$AFP/Simpl/HoarePartialDef.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.All_binder" ("_position" n)
###       ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###         ("_position" \<Theta>) ("_position" n) ("_position" F)
###         ("_position" P) ("_position" c) ("_position" Q) ("_position" A))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_tuple"
###       ("\<^const>HOL.All_binder" ("_position" n) ("_position" \<Gamma>))
###       ("_tuple_arg"
###         ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###           ("_position" n) ("_position" F) ("_position" P) ("_position" c)
###           ("_position" Q) ("_position" A)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HoarePartialDef.cvalid" ("_position" \<Gamma>)
###       ("_position" \<Theta>) ("_position" F) ("_position" P) ("_position" c)
###       ("_position" Q) ("_position" A))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoarep"
  Proving monotonicity ...
### theory "Draft.HoarePartialDef"
### 0.378s elapsed time, 0.957s cpu time, 0.297s GC time
Loading theory "Draft.HoarePartialProps" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoarePartial")
### Ambiguous input (line 1078 of "$AFP/Simpl/HoarePartialProps.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("\<^const>HOL.All_binder" ("_position" n)
###             ("\<^const>HoarePartialDef.cnvalid" ("_position" \<Gamma>)
###               ("_position" \<Theta>) ("_position" n) ("_position" F)
###               ("_position" P') ("_position" c) ("_position" Q')
###               ("_position" A')))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_Ball" ("_position" s) ("_position" P)
###     ("\<^const>HOL.All_binder"
###       ("_idtyp" ("_position" t)
###         ("_tappl" ("_position_sort" 's) ("_position_sort" 'f)
###           ("_type_name" xstate)))
###       ("\<^const>HOL.Ex_binder"
###         ("_idts" ("_position" P')
###           ("_idts" ("_position" Q') ("_position" A')))
###         ("\<^const>HOL.conj"
###           ("_tuple"
###             ("\<^const>HOL.All_binder" ("_position" n)
###               ("_position" \<Gamma>))
###             ("_tuple_arg"
###               ("\<^const>HoarePartialDef.nvalid" ("_position" \<Theta>)
###                 ("_position" n) ("_position" F) ("_position" P')
###                 ("_position" c) ("_position" Q') ("_position" A'))))
###           ("\<^const>HOL.implies"
###             ("\<^const>HOL.implies"
###               ("\<^const>Set.member" ("_position" s) ("_position" P'))
###               ("\<^const>Set.member" ("_position" t)
###                 ("\<^const>Set.union"
###                   ("\<^const>Set.image" ("_position" Normal)
###                     ("_position" Q'))
###                   ("\<^const>Set.image" ("_position" Abrupt)
###                     ("_position" A')))))
###             ("\<^const>Set.member" ("_position" t)
###               ("\<^const>Set.union"
###                 ("\<^const>Set.image" ("_position" Normal) ("_position" Q))
###                 ("\<^const>Set.image" ("_position" Abrupt)
###                   ("_position" A))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### No equation for constructor "Spec"
consts
  procs :: "('s, 'p, 'f) com => 'p set"
### theory "Draft.Termination"
### 0.537s elapsed time, 1.189s cpu time, 0.165s GC time
Loading theory "Draft.HoareTotalDef" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps")
Loading theory "Draft.SmallStep" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal" via "Draft.HoareTotalProps")
consts
  noSpec :: "('s, 'p, 'f) com => bool"
consts
  redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com"
Proofs for inductive predicate(s) "step"
  Proving monotonicity ...
Proofs for inductive predicate(s) "hoaret"
  Proving monotonicity ...
### theory "Draft.HoarePartialProps"
### 0.602s elapsed time, 1.748s cpu time, 0.431s GC time
Loading theory "Draft.HoarePartial" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare")
### theory "Draft.HoareTotalDef"
### 0.904s elapsed time, 3.096s cpu time, 1.813s GC time
Loading theory "Draft.AlternativeSmallStep" (required by "Draft.SimplTemplates" via "Draft.Simpl")
Proofs for inductive predicate(s) "step"
  Proving monotonicity ...
val tranclp_induct2 =
   "[| ?r^++ (?aa, ?ab) (?ba, ?bb); !!a b. ?r (?aa, ?ab) (a, b) ==> ?P a b;
       !!a b aa ba.
          [| ?r^++ (?aa, ?ab) (a, b); ?r (a, b) (aa, ba); ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  subst_redex :: "('s, 'p, 'f) com => ('s, 'p, 'f) com => ('s, 'p, 'f) com"
val trancl_induct2 =
   "[| ((?aa, ?ab), ?ba, ?bb) : ?r^+;
       !!a b. ((?aa, ?ab), a, b) : ?r ==> ?P a b;
       !!a b aa ba.
          [| ((?aa, ?ab), a, b) : ?r^+; ((a, b), aa, ba) : ?r; ?P a b |]
          ==> ?P aa ba |]
    ==> ?P ?ba ?bb":
   thm
val it = (): unit
consts
  seq :: "(nat => ('s, 'p, 'f) com) => 'p => nat => ('s, 'p, 'f) com"
### theory "Draft.HoarePartial"
### 1.225s elapsed time, 4.247s cpu time, 1.992s GC time
consts
  redexes :: "('s, 'p, 'f) com => ('s, 'p, 'f) com set"
### theory "Draft.SmallStep"
### 1.672s elapsed time, 5.703s cpu time, 2.258s GC time
Loading theory "Draft.HoareTotalProps" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare" via "Draft.HoareTotal")
val trancl_induct3 =
   "[| ?r^++ (?ax, ?ay, ?az) (?bx, ?by, ?bz);
       !!a aa b. ?r (?ax, ?ay, ?az) (a, aa, b) ==> ?P a aa b;
       !!a aa b ab ac ba.
          [| ?r^++ (?ax, ?ay, ?az) (a, aa, b); ?r (a, aa, b) (ab, ac, ba);
             ?P a aa b |]
          ==> ?P ab ac ba |]
    ==> ?P ?bx ?by ?bz":
   thm
val it = (): unit
Proofs for inductive predicate(s) "execs"
  Proving monotonicity ...
val converse_rtrancl_induct3 =
   "[| ?r^** (?cs, ?css, ?s) (?cs', ?css', ?t); ?P ?cs' ?css' ?t;
       !!a aa b ab ac ba.
          [| ?r (a, aa, b) (ab, ac, ba);
             ?r^** (ab, ac, ba) (?cs', ?css', ?t); ?P ab ac ba |]
          ==> ?P a aa b |]
    ==> ?P ?cs ?css ?s":
   thm
val it = (): unit
Proofs for inductive predicate(s) "terminatess"
  Proving monotonicity ...
val rtrancl_induct3 =
   "[| ?r^** (?ax, ?ay, ?az) (?bx, ?by, ?bz); ?P ?ax ?ay ?az;
       !!a aa b ab ac ba.
          [| ?r^** (?ax, ?ay, ?az) (a, aa, b); ?r (a, aa, b) (ab, ac, ba);
             ?P a aa b |]
          ==> ?P ab ac ba |]
    ==> ?P ?bx ?by ?bz":
   thm
val it = (): unit
locale AlternativeSmallStep.inf
  fixes
    CS ::
      "('s, 'p, 'f) com list *
       (('s, 'p, 'f) com list * ('s, 'p, 'f) com list) list *
       ('s, 'f) xstate
       => ('s, 'p, 'f) com list"
    and
    CSS ::
      "('s, 'p, 'f) com list *
       (('s, 'p, 'f) com list * ('s, 'p, 'f) com list) list *
       ('s, 'f) xstate
       => (('s, 'p, 'f) com list * ('s, 'p, 'f) com list) list"
    and
    S :: "('s, 'p, 'f) com list *
          (('s, 'p, 'f) com list * ('s, 'p, 'f) com list) list *
          ('s, 'f) xstate
          => ('s, 'f) xstate"
  defines "CS == fst"
    and "CSS == %c. fst (snd c)"
    and "S == %c. snd (snd c)"
### theory "Draft.HoareTotalProps"
### 0.792s elapsed time, 1.828s cpu time, 0.370s GC time
Loading theory "Draft.Compose" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.ComposeEx")
Loading theory "Draft.HoareTotal" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace" via "Draft.Hoare")
consts
  lift\<^sub>c ::
    "('S => 's) => ('S => 's => 'S) => ('s, 'p, 'f) com => ('S, 'p, 'f) com"
locale lift_state_space
  fixes project :: "'S => 's"
    and inject :: "'S => 's => 'S"
    and project\<^sub>x :: "('S, 'f) xstate => ('s, 'f) xstate"
    and
    lift\<^sub>e ::
      "('p => ('s, 'p, 'f) com option) => 'p => ('S, 'p, 'f) com option"
    and lift\<^sub>c :: "('s, 'p, 'f) com => ('S, 'p, 'f) com"
    and lift\<^sub>f :: "('s => 's) => 'S => 'S"
    and lift\<^sub>s :: "'s set => 'S set"
    and lift\<^sub>r :: "('s * 's) set => ('S * 'S) set"
  assumes "lift_state_space project inject"
  defines "lift\<^sub>c == lift\<^sub>c project inject"
    and "project\<^sub>x == xstate_map project"
    and "lift\<^sub>e == %\<Gamma> p. map_option lift\<^sub>c (\<Gamma> p)"
    and "lift\<^sub>f == lift\<^sub>f project inject"
    and "lift\<^sub>s == lift\<^sub>s project"
    and "lift\<^sub>r == lift\<^sub>r project inject"
consts
  seq :: "(nat => 'a list) => nat => 'a list"
### Ambiguous input (line 2968 of "$AFP/Simpl/AlternativeSmallStep.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>AlternativeSmallStep.terminatess" ("_position" \<Gamma>)
###       ("_position" cs) ("_position" css) ("_position" s))
###     ("\<^const>HOL.Not"
###       ("_applC" ("_position" inf)
###         ("_cargs" ("_position" \<Gamma>)
###           ("_cargs" ("_position" cs)
###             ("_cargs" ("_position" css) ("_position" s))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>AlternativeSmallStep.terminatess" ("_position" \<Gamma>)
###     ("_position" cs) ("_position" css)
###     ("\<^const>HOL.eq" ("_position" s)
###       ("\<^const>HOL.Not"
###         ("_applC" ("_position" inf)
###           ("_cargs" ("_position" \<Gamma>)
###             ("_cargs" ("_position" cs)
###               ("_cargs" ("_position" css) ("_position" s)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale lift_state_space_ext
  fixes project :: "'a => 'b"
    and inject :: "'a => 'b => 'a"
    and project\<^sub>x :: "('a, 'c) xstate => ('b, 'c) xstate"
    and
    lift\<^sub>e ::
      "('d => ('b, 'd, 'c) com option) => 'd => ('a, 'd, 'c) com option"
    and lift\<^sub>c :: "('b, 'd, 'c) com => ('a, 'd, 'c) com"
    and lift\<^sub>f :: "('b => 'b) => 'a => 'a"
    and lift\<^sub>s :: "'b set => 'a set"
    and lift\<^sub>r :: "('b * 'b) set => ('a * 'a) set"
  assumes "lift_state_space_ext project inject"
  defines "lift\<^sub>c == lift\<^sub>c project inject"
    and "project\<^sub>x == xstate_map project"
    and "lift\<^sub>e == %\<Gamma> p. map_option lift\<^sub>c (\<Gamma> p)"
    and "lift\<^sub>f == lift\<^sub>f project inject"
    and "lift\<^sub>s == lift\<^sub>s project"
    and "lift\<^sub>r == lift\<^sub>r project inject"
### theory "Draft.AlternativeSmallStep"
### 2.113s elapsed time, 6.181s cpu time, 1.200s GC time
consts
  rename :: "('p => 'q) => ('s, 'p, 'f) com => ('s, 'q, 'f) com"
### theory "Draft.Compose"
### 0.689s elapsed time, 2.021s cpu time, 0.385s GC time
### theory "Draft.HoareTotal"
### 0.801s elapsed time, 2.129s cpu time, 0.385s GC time
Loading theory "Draft.Hoare" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.StateSpace")
"\<Gamma>|-/F P c Q"
  :: "bool"
locale hoare
  fixes \<Gamma> :: "'p => ('s, 'p, 'f) com option"
"\<Gamma>|-P c Q"
  :: "bool"
"\<Gamma>|-P c Q,A"
  :: "bool"
"\<Gamma>|-/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>|-tP c Q"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^bsub>/F \<^esub>P c Q,A"
  :: "bool"
"\<Gamma>|-tP c Q,A"
  :: "bool"
"\<Gamma>|-t/F P c Q"
  :: "bool"
"\<Gamma>|-t/F P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>|-P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|-t/F P c Q"
  :: "bool"
"\<Gamma>,\<Theta>|- P c Q,A"
  :: "bool"
"\<Gamma>,\<Theta>\<turnstile>\<^sub>t\<^bsub>/F\<^esub> P c Q,A"
  :: "bool"
consts
  assoc :: "('a * 'b) list => 'a => 'b"
### theory "Draft.Hoare"
### 0.224s elapsed time, 0.314s cpu time, 0.096s GC time
Loading theory "Draft.Closure" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.ClosureEx")
Loading theory "Draft.StateSpace" (required by "Draft.SimplTemplates" via "Draft.Simpl")
### theory "Draft.Closure"
### 0.123s elapsed time, 0.246s cpu time, 0.000s GC time
### theory "Draft.StateSpace"
### 0.278s elapsed time, 0.405s cpu time, 0.000s GC time
Loading theory "Draft.Vcg" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.SyntaxTest")
### Ignoring duplicate rewrite rule:
### ~ ~ ?y == ?y
### Ignoring duplicate rewrite rule:
### (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
### Ignoring duplicate rewrite rule:
### ?P1 | ~ ?P1 == True
### Ignoring duplicate rewrite rule:
### ~ ?P1 | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?x1 = ?x1 == True
### Ignoring duplicate rewrite rule:
### ~ True == False
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### (~ ?P1) = ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 = (~ ?P1) == False
### Ignoring duplicate rewrite rule:
### True = ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y = True == ?y
### Ignoring duplicate rewrite rule:
### False = ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 = False == ~ ?P1
### Ignoring duplicate rewrite rule:
### True --> ?y == ?y
### Ignoring duplicate rewrite rule:
### False --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> True == True
### Ignoring duplicate rewrite rule:
### ?P1 --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> False == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 --> ~ ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?y & True == ?y
### Ignoring duplicate rewrite rule:
### True & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & False == False
### Ignoring duplicate rewrite rule:
### False & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 & ~ ?P1 == False
### Ignoring duplicate rewrite rule:
### ~ ?P1 & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 | True == True
### Ignoring duplicate rewrite rule:
### True | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?y | False == ?y
### Ignoring duplicate rewrite rule:
### False | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
### Ignoring duplicate rewrite rule:
### ALL x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 == True
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x == True
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x ~= ?t1 == False
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 ~= x == False
### ML warning (line 165 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 164 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 383 of "$AFP/Simpl/hoare.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 451 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 450 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 449 of "$AFP/Simpl/hoare.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 455 of "$AFP/Simpl/hoare.ML"):
### Value identifier (prf) has not been referenced.
### ML warning (line 472 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 469 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 467 of "$AFP/Simpl/hoare.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 628 of "$AFP/Simpl/hoare.ML"):
### Value identifier (default_state_kind) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare.ML"):
### Value identifier (generate_guard) has not been referenced.
### ML warning (line 897 of "$AFP/Simpl/hoare.ML"):
### Value identifier (less) has not been referenced.
### ML warning (line 902 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1085 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1150 of "$AFP/Simpl/hoare.ML"):
### Value identifier (pE) has not been referenced.
### ML warning (line 1270 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fold_com) has not been referenced.
### ML warning (line 1386 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1348 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t1) has not been referenced.
### ML warning (line 1363 of "$AFP/Simpl/hoare.ML"):
### Value identifier (aT) has not been referenced.
### ML warning (line 1433 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1493 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1770 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 1773 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1775 of "$AFP/Simpl/hoare.ML"):
### Matches are not exhaustive.
### ML warning (line 1782 of "$AFP/Simpl/hoare.ML"):
### Value identifier (hoare) has not been referenced.
### ML warning (line 1872 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1842 of "$AFP/Simpl/hoare.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1940 of "$AFP/Simpl/hoare.ML"):
### Value identifier (mode) has not been referenced.
### ML warning (line 1982 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2012 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Q) has not been referenced.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2069 of "$AFP/Simpl/hoare.ML"):
### Value identifier (a_vT) has not been referenced.
### ML warning (line 2076 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gT) has not been referenced.
### ML warning (line 2101 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2094 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2111 of "$AFP/Simpl/hoare.ML"):
### Value identifier (subst) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (Z) has not been referenced.
### ML warning (line 2105 of "$AFP/Simpl/hoare.ML"):
### Value identifier (globs) has not been referenced.
### ML warning (line 2118 of "$AFP/Simpl/hoare.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 2137 of "$AFP/Simpl/hoare.ML"):
### Value identifier (G) has not been referenced.
### ML warning (line 2287 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2382 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 2404 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 2412 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fs) has not been referenced.
### ML warning (line 2459 of "$AFP/Simpl/hoare.ML"):
### Value identifier (b) has not been referenced.
### ML warning (line 2478 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (A) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 2520 of "$AFP/Simpl/hoare.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 2720 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2737 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2744 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2796 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2785 of "$AFP/Simpl/hoare.ML"):
### Value identifier (loc) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2771 of "$AFP/Simpl/hoare.ML"):
### Value identifier (glob) has not been referenced.
### ML warning (line 2832 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 2874 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 2881 of "$AFP/Simpl/hoare.ML"):
### Pattern 2 is redundant.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2899 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2888 of "$AFP/Simpl/hoare.ML"):
### Value identifier (var) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (name) has not been referenced.
### ML warning (line 2884 of "$AFP/Simpl/hoare.ML"):
### Value identifier (destr) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (abs) has not been referenced.
### ML warning (line 2883 of "$AFP/Simpl/hoare.ML"):
### Value identifier (app) has not been referenced.
### ML warning (line 2920 of "$AFP/Simpl/hoare.ML"):
### Value identifier (fld_idx) has not been referenced.
### ML warning (line 2968 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3011 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3126 of "$AFP/Simpl/hoare.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 3110 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 3114 of "$AFP/Simpl/hoare.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3121 of "$AFP/Simpl/hoare.ML"):
### Value identifier (x_upd') has not been referenced.
### ML warning (line 3172 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3282 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3283 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3296 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3298 of "$AFP/Simpl/hoare.ML"):
### Pattern is not exhaustive.
### ML warning (line 3330 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
### ML warning (line 3336 of "$AFP/Simpl/hoare.ML"):
### Value identifier (exnames) has not been referenced.
signature HOARE =
  sig
    val BasicSimpTac:
       Proof.context ->
         state_kind -> bool -> thm list -> (int -> tactic) -> int -> tactic
    val add_foldcongs: thm list -> theory -> theory
    val add_foldcongsimps: thm list -> theory -> theory
    val add_params:
       morphism ->
         string ->
           (par_kind * string) list -> Context.generic -> Context.generic
    val add_recursive:
       morphism -> string -> Context.generic -> Context.generic
    val add_state_kind:
       morphism ->
         string -> state_kind -> Context.generic -> Context.generic
    datatype 'a bodykind = BodyTerm of 'a | BodyTyp of 'a
    val chopsfx: string -> string -> string
    val clique_name: string list -> string
    val deco: string
    val extern: Proof.context -> string -> string
    val gen_proc_rec: Proof.context -> hoareMode -> int -> thm
    val generate_guard: Proof.context -> term -> term option
    val get_data: Proof.context -> hoare_data
    val get_default_state_kind: Proof.context -> state_kind
    val get_foldcong_ss: theory -> simpset
    val get_params:
       string -> Proof.context -> (par_kind * string) list option
    val get_state_kind: string -> Proof.context -> state_kind option
    val hoare: (Proof.context -> Proof.method) context_parser
    datatype hoareMode = Partial | Total
    type hoare_data =
       {active_procs: string list list,
        default_state_kind: state_kind,
        generate_guard: stamp * (Proof.context -> term -> term option),
        hoare_tacs: (string * hoare_tac) list,
        proc_info: proc_info Symtab.table,
        vcg_simps: thm list, wp_tacs: (string * hoare_tac) list}
    val hoare_raw: (Proof.context -> Proof.method) context_parser
    val hoare_rule: (Proof.context -> Proof.method) context_parser
    val hoare_rule_tac: Proof.context -> thm list -> int -> tactic
    type hoare_tac =
       (bool -> int -> tactic) ->
         Proof.context -> hoareMode -> int -> tactic
    val implementationN: string
    val install_generate_guard:
       (Proof.context -> term -> term option) ->
         Context.generic -> Context.generic
    val is_state_var: string -> bool
    val modeqN: string
    val modexN: string
    val par_deco: string -> string
    datatype par_kind = In | Out
    val proc_deco: string
    type proc_info =
       {params: (par_kind * string) list,
        recursive: bool, state_kind: state_kind}
    val proc_specs: (bstring * string) list parser
    val remdeco: Proof.context -> string -> string
    val remdeco': string -> string
    val resuffix: string -> string -> string -> string
    val set_default_state_kind:
       state_kind -> Context.generic -> Context.generic
    val specL: string
    datatype state_kind = Function | Record
    val undeco: Proof.context -> term -> term
    val varname: string -> string
    val vcg: (Proof.context -> Proof.method) context_parser
    val vcg_step: (Proof.context -> Proof.method) context_parser
    val vcg_tac:
       string -> string -> string list -> Proof.context -> int -> tactic
  end
structure Hoare: HOARE
### ML warning (line 98 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 97 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 102 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ys) has not been referenced.
### ML warning (line 101 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 107 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (eq) has not been referenced.
### ML warning (line 242 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 271 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 282 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 281 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 279 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 322 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 321 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 428 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_val) has not been referenced.
### ML warning (line 424 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (off_var) has not been referenced.
### ML warning (line 454 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 5 is redundant.
### ML warning (line 469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 471 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 492 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 499 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 502 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 533 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 535 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 581 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 583 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 631 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 667 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 702 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 701 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 699 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 706 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 740 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (globals) has not been referenced.
### ML warning (line 750 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 14 is redundant.
### ML warning (line 758 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 786 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 773 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 788 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 800 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 825 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 813 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 816 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 837 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 827 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 851 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 839 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 842 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern is not exhaustive.
### ML warning (line 876 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 975 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 972 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 969 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 967 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 965 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 963 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 961 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 959 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 957 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 955 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 953 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 993 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1042 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r) has not been referenced.
### ML warning (line 1075 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (values) has not been referenced.
### ML warning (line 1091 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (idxs) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (value) has not been referenced.
### ML warning (line 1088 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1098 of "$AFP/Simpl/hoare_syntax.ML"):
### Pattern 2 is redundant.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (constr) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (dest) has not been referenced.
### ML warning (line 1108 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd') has not been referenced.
### ML warning (line 1165 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1152 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1143 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1178 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1168 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1211 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1209 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1213 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 1235 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1253 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1257 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1274 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1300 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1302 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1307 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1305 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (result) has not been referenced.
### ML warning (line 1339 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (return) has not been referenced.
### ML warning (line 1341 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 1362 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1360 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 1442 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1439 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1470 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1469 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1473 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1492 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (gupd) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (new) has not been referenced.
### ML warning (line 1503 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (upd) has not been referenced.
### ML warning (line 1502 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (free) has not been referenced.
### ML warning (line 1506 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1525 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (r') has not been referenced.
### ML warning (line 1542 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1534 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
### ML warning (line 1555 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 1611 of "$AFP/Simpl/hoare_syntax.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 1602 of "$AFP/Simpl/hoare_syntax.ML"):
### Matches are not exhaustive.
signature HOARE_SYNTAX =
  sig
    val antiquoteCur: string
    val antiquoteOld: string
    val antiquoteOld_tr: Proof.context -> term list -> term
    val antiquote_applied_only_to: (term -> bool) -> term -> bool
    val antiquote_varname_tr: string -> term list -> term
    val app_quote_tr': Proof.context -> term -> term list -> term
    val assert_tr': Proof.context -> term list -> term
    val assign_tr: Proof.context -> term list -> term
    val assign_tr': Proof.context -> term list -> term
    val basic_assigns_tr: Proof.context -> term list -> term
    val basic_tr: Proof.context -> term list -> term
    val basic_tr': Proof.context -> term list -> term
    val bexp_tr': string -> Proof.context -> term list -> term
    val bind_tr': Proof.context -> term list -> term
    val call_ass_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr: bool -> bool -> Proof.context -> term list -> term
    val call_tr': Proof.context -> term list -> term
    val dyn_call_tr': Proof.context -> term list -> term
    val fcall_tr: Proof.context -> term list -> term
    val fcall_tr': Proof.context -> term list -> term
    val guarded_Assign_tr: Proof.context -> term list -> term
    val guarded_Cond_tr: Proof.context -> term list -> term
    val guarded_NNew_tr: Proof.context -> term list -> term
    val guarded_New_tr: Proof.context -> term list -> term
    val guarded_WhileFix_tr: Proof.context -> term list -> term
    val guarded_While_tr: Proof.context -> term list -> term
    val guards_tr': Proof.context -> term list -> term
    val hide_guards: bool Config.T
    val init_tr: Proof.context -> term list -> term
    val init_tr': Proof.context -> term list -> term
    val loc_tr: Proof.context -> term list -> term
    val loc_tr': Proof.context -> term list -> term
    val new_tr: Proof.context -> term list -> term
    val new_tr': Proof.context -> term list -> term
    val nnew_tr: Proof.context -> term list -> term
    val nnew_tr': Proof.context -> term list -> term
    val proc_ass_tr: Proof.context -> term list -> term
    val proc_tr: Proof.context -> term list -> term
    val proc_tr': Proof.context -> term list -> term
    val quote_mult_tr':
       Proof.context -> (term -> bool) -> string -> string -> term -> term
    val quote_tr: Proof.context -> string -> term -> term
    val quote_tr': Proof.context -> string -> term -> term
    val raise_tr: Proof.context -> term list -> term
    val raise_tr': Proof.context -> term list -> term
    val switch_tr': Proof.context -> term list -> term
    val update_comp:
       Proof.context ->
         string list -> bool -> bool -> xstring -> term -> term -> term
    val use_call_tr': bool Config.T
    val whileAnnoGFix_tr': Proof.context -> term list -> term
    val whileAnnoG_tr': Proof.context -> term list -> term
  end
structure Hoare_Syntax: HOARE_SYNTAX
### theory "Draft.Vcg"
### 3.012s elapsed time, 3.433s cpu time, 0.568s GC time
Loading theory "Draft.ClosureEx" (required by "Draft.SimplTemplates" via "Draft.Simpl")
Loading theory "Draft.ComposeEx" (required by "Draft.SimplTemplates" via "Draft.Simpl")
Loading theory "Draft.ProcParEx" (required by "Draft.SimplTemplates" via "Draft.Simpl")
Loading theory "Draft.ProcParExSP" (required by "Draft.SimplTemplates" via "Draft.Simpl")
Defining statespace "compare_parameters" ...
Defining statespace "compare_variables" ...
locale compare_impl
  fixes \<Gamma> :: "'a => ('b, 'a, 'c) com option"
    and i_'compare_' :: "'d"
    and j_'compare_' :: "'d"
    and r_'compare_' :: "'d"
    and project_Nat_nat :: "'e => nat"
    and inject_Nat_nat :: "nat => 'e"
    and project_HOL_bool :: "'e => bool"
    and inject_HOL_bool :: "bool => 'e"
    and StateType :: "'d => 'e"
    and compare_'proc :: "char list"
  assumes
    "compare_impl i_'compare_' j_'compare_' r_'compare_' project_Nat_nat
      inject_Nat_nat project_HOL_bool inject_HOL_bool"
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
Defining statespace "LEQ_parameters" ...
Defining statespace "LEQ_variables" ...
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
locale compare_signature
  fixes compare_'proc :: "char list"
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
Defining statespace "Max_parameters" ...
Defining statespace "Max_variables" ...
locale Max_test
  fixes
    \<Gamma> ::
      "char list => (('a, 'b) vars_scheme, char list, 'c) com option"
    and Max_'proc :: "char list"
    and LEQ_'proc :: "char list"
  assumes "Max_test \<Gamma> Max_'proc LEQ_'proc"
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'compare_'proc_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
locale Max_test'
  fixes
    \<Gamma> ::
      "char list => (('a, 'b) vars_scheme, char list, 'c) com option"
    and compare_'proc :: "char list"
    and Max_'proc :: "char list"
    and LEQ_'proc :: "char list"
  assumes "Max_test' \<Gamma> Max_'proc LEQ_'proc"
### theory "Draft.ProcParEx"
### 0.499s elapsed time, 1.987s cpu time, 0.166s GC time
Loading theory "Draft.Quicksort" (required by "Draft.SimplTemplates" via "Draft.Simpl")
locale NewCounter_impl'
  fixes
    \<Gamma> ::
      "char list
       => (('a globals_scheme, 'b) vars_scheme, char list, 'c) com option"
    and Inc_'proc :: "char list"
    and NewCounter_'proc :: "char list"
  assumes "NewCounter_impl' \<Gamma> Inc_'proc NewCounter_'proc"
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
### Ambiguous input (line 189 of "$AFP/Simpl/ex/ClosureEx.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_hoarep_emptyCtx_noAbr_emptyFaults" ("_position" \<Gamma>)
###     ("_Assert"
###       ("\<^const>Orderings.ord_class.less_eq"
###         ("\<^const>Groups.one_class.one")
###         ("_antiquoteCur0" ("_position" free))))
###     ("_seq"
###       ("_seq"
###         ("_CallAss" ("_antiquoteCur0" ("_position" c))
###           ("_position" NewCounter) ("_actuals_empty"))
###         ("_applC" ("_position" dynCallClosure)
###           ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###             ("_cargs" ("_position" upd)
###               ("_cargs" ("_position" c_')
###                 ("_cargs"
###                   ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                     ("_record_update" ("_position" s)
###                       ("_field_update" ("_constify" globals)
###                         ("_applC" ("_position" globals) ("_position" t)))))
###                   ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                     ("_applC" ("_position" Basic)
###                       ("_lambda" ("_position" u)
###                         ("_record_update" ("_position" u)
###                           ("_field_update" ("_constify" r_')
###                             ("_applC" ("_position" r_')
###                               ("_position" t)))))))))))))
###       ("_applC" ("_position" dynCallClosure)
###         ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###           ("_cargs" ("_position" upd)
###             ("_cargs" ("_position" c_')
###               ("_cargs"
###                 ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                   ("_record_update" ("_position" s)
###                     ("_field_update" ("_constify" globals)
###                       ("_applC" ("_position" globals) ("_position" t)))))
###                 ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                   ("_applC" ("_position" Basic)
###                     ("_lambda" ("_position" u)
###                       ("_record_update" ("_position" u)
###                         ("_field_update" ("_constify" r_')
###                           ("_applC" ("_position" r_')
###                             ("_position" t)))))))))))))
###     ("_Assert"
###       ("\<^const>HOL.eq" ("_antiquoteCur0" ("_position" r))
###         ("_Numeral" ("_constify" ("_position" 2)))))))
### ("\<^const>HOL.Trueprop"
###   ("_seq"
###     ("_hoarep_emptyCtx_noAbr_emptyFaults" ("_position" \<Gamma>)
###       ("_Assert"
###         ("\<^const>Orderings.ord_class.less_eq"
###           ("\<^const>Groups.one_class.one")
###           ("_antiquoteCur0" ("_position" free))))
###       ("_seq"
###         ("_CallAss" ("_antiquoteCur0" ("_position" c))
###           ("_position" NewCounter) ("_actuals_empty"))
###         ("_applC" ("_position" dynCallClosure)
###           ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###             ("_cargs" ("_position" upd)
###               ("_cargs" ("_position" c_')
###                 ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                   ("_record_update" ("_position" s)
###                     ("_field_update" ("_constify" globals)
###                       ("_applC" ("_position" globals)
###                         ("_position" t))))))))))
###       ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###         ("_applC" ("_position" Basic)
###           ("_lambda" ("_position" u)
###             ("_record_update" ("_position" u)
###               ("_field_update" ("_constify" r_')
###                 ("_applC" ("_position" r_') ("_position" t))))))))
###     ("_applC" ("_position" dynCallClosure)
###       ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###         ("_cargs" ("_position" upd)
###           ("_cargs" ("_position" c_')
###             ("_cargs"
###               ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                 ("_record_update" ("_position" s)
###                   ("_field_update" ("_constify" globals)
###                     ("_applC" ("_position" globals) ("_position" t)))))
###               ("_cargs"
###                 ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                   ("_applC" ("_position" Basic)
###                     ("_lambda" ("_position" u)
###                       ("_record_update" ("_position" u)
###                         ("_field_update" ("_constify" r_')
###                           ("_applC" ("_position" r_') ("_position" t)))))))
###                 ("_Assert"
###                   ("\<^const>HOL.eq" ("_antiquoteCur0" ("_position" r))
###                     ("_Numeral" ("_constify" ("_position" 2)))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 226 of "$AFP/Simpl/ex/ClosureEx.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("_hoarep_emptyCtx_noAbr_emptyFaults" ("_position" \<Gamma>)
###     ("_Assert"
###       ("\<^const>Orderings.ord_class.less_eq"
###         ("\<^const>Groups.one_class.one")
###         ("_antiquoteCur0" ("_position" free))))
###     ("_seq"
###       ("_seq"
###         ("_seq"
###           ("_seq"
###             ("_CallAss" ("_antiquoteCur0" ("_position" c))
###               ("_position" NewCounter) ("_actuals_empty"))
###             ("_Assign" ("_antiquoteCur0" ("_position" d))
###               ("_antiquoteCur0" ("_position" c))))
###           ("_applC" ("_position" dynCallClosure)
###             ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###               ("_cargs" ("_position" upd)
###                 ("_cargs" ("_position" c_')
###                   ("_cargs"
###                     ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                       ("_record_update" ("_position" s)
###                         ("_field_update" ("_constify" globals)
###                           ("_applC" ("_position" globals)
###                             ("_position" t)))))
###                     ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                       ("_applC" ("_position" Basic)
###                         ("_lambda" ("_position" u)
###                           ("_record_update" ("_position" u)
###                             ("_field_update" ("_constify" n_')
###                               ("_applC" ("_position" r_')
###                                 ("_position" t)))))))))))))
###         ("_applC" ("_position" dynCallClosure)
###           ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###             ("_cargs" ("_position" upd)
###               ("_cargs" ("_position" d_')
###                 ("_cargs"
###                   ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                     ("_record_update" ("_position" s)
###                       ("_field_update" ("_constify" globals)
###                         ("_applC" ("_position" globals) ("_position" t)))))
###                   ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                     ("_applC" ("_position" Basic)
###                       ("_lambda" ("_position" u)
###                         ("_record_update" ("_position" u)
###                           ("_field_update" ("_constify" m_')
###                             ("_applC" ("_position" r_')
###                               ("_position" t)))))))))))))
###       ("_Assign" ("_antiquoteCur0" ("_position" r))
###         ("\<^const>Groups.plus_class.plus"
###           ("_antiquoteCur0" ("_position" n))
###           ("_antiquoteCur0" ("_position" m)))))
###     ("_Assert"
###       ("\<^const>HOL.eq" ("_antiquoteCur0" ("_position" r))
###         ("_Numeral" ("_constify" ("_position" 3)))))))
### ("\<^const>HOL.Trueprop"
###   ("_seq"
###     ("_seq"
###       ("_hoarep_emptyCtx_noAbr_emptyFaults" ("_position" \<Gamma>)
###         ("_Assert"
###           ("\<^const>Orderings.ord_class.less_eq"
###             ("\<^const>Groups.one_class.one")
###             ("_antiquoteCur0" ("_position" free))))
###         ("_seq"
###           ("_seq"
###             ("_CallAss" ("_antiquoteCur0" ("_position" c))
###               ("_position" NewCounter) ("_actuals_empty"))
###             ("_Assign" ("_antiquoteCur0" ("_position" d))
###               ("_antiquoteCur0" ("_position" c))))
###           ("_applC" ("_position" dynCallClosure)
###             ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###               ("_cargs" ("_position" upd)
###                 ("_cargs" ("_position" c_')
###                   ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                     ("_record_update" ("_position" s)
###                       ("_field_update" ("_constify" globals)
###                         ("_applC" ("_position" globals)
###                           ("_position" t))))))))))
###         ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###           ("_applC" ("_position" Basic)
###             ("_lambda" ("_position" u)
###               ("_record_update" ("_position" u)
###                 ("_field_update" ("_constify" n_')
###                   ("_applC" ("_position" r_') ("_position" t))))))))
###       ("_applC" ("_position" dynCallClosure)
###         ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###           ("_cargs" ("_position" upd)
###             ("_cargs" ("_position" d_')
###               ("_cargs"
###                 ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                   ("_record_update" ("_position" s)
###                     ("_field_update" ("_constify" globals)
###                       ("_applC" ("_position" globals) ("_position" t)))))
###                 ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                   ("_applC" ("_position" Basic)
###                     ("_lambda" ("_position" u)
###                       ("_record_update" ("_position" u)
###                         ("_field_update" ("_constify" m_')
###                           ("_applC" ("_position" r_')
###                             ("_position" t)))))))))))))
###     ("_Assign" ("_antiquoteCur0" ("_position" r))
###       ("\<^const>Groups.plus_class.plus" ("_antiquoteCur0" ("_position" n))
###         ("_applC" ("_antiquoteCur0" ("_position" m))
###           ("_Assert"
###             ("\<^const>HOL.eq" ("_antiquoteCur0" ("_position" r))
###               ("_Numeral" ("_constify" ("_position" 3))))))))))
### ("\<^const>HOL.Trueprop"
###   ("_seq"
###     ("_hoarep_emptyCtx_noAbr_emptyFaults" ("_position" \<Gamma>)
###       ("_Assert"
###         ("\<^const>Orderings.ord_class.less_eq"
###           ("\<^const>Groups.one_class.one")
###           ("_antiquoteCur0" ("_position" free))))
###       ("_seq"
###         ("_seq"
###           ("_seq"
###             ("_CallAss" ("_antiquoteCur0" ("_position" c))
###               ("_position" NewCounter) ("_actuals_empty"))
###             ("_Assign" ("_antiquoteCur0" ("_position" d))
###               ("_antiquoteCur0" ("_position" c))))
###           ("_applC" ("_position" dynCallClosure)
###             ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###               ("_cargs" ("_position" upd)
###                 ("_cargs" ("_position" c_')
###                   ("_cargs"
###                     ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                       ("_record_update" ("_position" s)
###                         ("_field_update" ("_constify" globals)
###                           ("_applC" ("_position" globals)
###                             ("_position" t)))))
###                     ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                       ("_applC" ("_position" Basic)
###                         ("_lambda" ("_position" u)
###                           ("_record_update" ("_position" u)
###                             ("_field_update" ("_constify" n_')
###                               ("_applC" ("_position" r_')
###                                 ("_position" t)))))))))))))
###         ("_applC" ("_position" dynCallClosure)
###           ("_cargs" ("_lambda" ("_position" s) ("_position" s))
###             ("_cargs" ("_position" upd)
###               ("_cargs" ("_position" d_')
###                 ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###                   ("_record_update" ("_position" s)
###                     ("_field_update" ("_constify" globals)
###                       ("_applC" ("_position" globals)
###                         ("_position" t))))))))))
###       ("_lambda" ("_pttrns" ("_position" s) ("_position" t))
###         ("_applC" ("_position" Basic)
###           ("_lambda" ("_position" u)
###             ("_record_update" ("_position" u)
###               ("_field_update" ("_constify" m_')
###                 ("_applC" ("_position" r_') ("_position" t))))))))
###     ("_Assign" ("_antiquoteCur0" ("_position" r))
###       ("\<^const>Groups.plus_class.plus" ("_antiquoteCur0" ("_position" n))
###         ("_applC" ("_antiquoteCur0" ("_position" m))
###           ("_Assert"
###             ("\<^const>HOL.eq" ("_antiquoteCur0" ("_position" r))
###               ("_Numeral" ("_constify" ("_position" 3))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.ClosureEx"
### 0.731s elapsed time, 2.906s cpu time, 0.277s GC time
Loading theory "Draft.SyntaxTest" (required by "Draft.SimplTemplates" via "Draft.Simpl")
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
locale Max_spec
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and Max_'proc :: "char list"
    and i_'compare_' :: "'b"
    and j_'compare_' :: "'b"
    and r_'compare_' :: "'b"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and compare_'proc :: "char list"
  assumes
    "Max_spec \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_'
      project_Nat_nat inject_Nat_nat project_String_char_List_list
      inject_String_char_List_list Max_'proc i_'compare_' j_'compare_'
      r_'compare_' project_HOL_bool inject_HOL_bool"
locale Max_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and b_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and i_'compare_' :: "'b"
    and j_'compare_' :: "'b"
    and r_'compare_' :: "'b"
    and compare_'proc :: "char list"
    and Max_'proc :: "char list"
  assumes
    "Max_impl \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_' b_'Max_'
      project_Nat_nat inject_Nat_nat project_HOL_bool inject_HOL_bool
      project_String_char_List_list inject_String_char_List_list
      i_'compare_' j_'compare_' r_'compare_' Max_'proc"
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
locale RevStr_impl
  fixes \<Gamma> :: "char list => (state, char list, bool) com option"
    and RevStr_'proc :: "char list"
  assumes "RevStr_impl \<Gamma> RevStr_'proc"
locale Max_test
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and Max_'proc :: "char list"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and compare_'proc :: "char list"
    and i_'LEQ_' :: "'b"
    and j_'LEQ_' :: "'b"
    and r_'LEQ_' :: "'b"
    and LEQ_'proc :: "char list"
  assumes
    "Max_test \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_'
      project_Nat_nat inject_Nat_nat project_String_char_List_list
      inject_String_char_List_list Max_'proc project_HOL_bool
      inject_HOL_bool i_'LEQ_' j_'LEQ_' r_'LEQ_' LEQ_'proc"
locale RevStr_impl
  fixes \<Gamma> :: "char list => (state, char list, bool) com option"
    and RevStr_'proc :: "char list"
  assumes "RevStr_impl \<Gamma> RevStr_'proc"
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: k_'LEQ_'
### theory "Draft.ComposeEx"
### 0.926s elapsed time, 3.686s cpu time, 0.377s GC time
Loading theory "Draft.VcgEx" (required by "Draft.SimplTemplates" via "Draft.Simpl")
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'Max_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'Max_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'LEQ_'proc_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
locale Max_test'
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and b_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and compare_'proc :: "char list"
    and Max_'proc :: "char list"
    and i_'LEQ_' :: "'b"
    and j_'LEQ_' :: "'b"
    and r_'LEQ_' :: "'b"
    and LEQ_'proc :: "char list"
  assumes
    "Max_test' \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_' b_'Max_'
      project_Nat_nat inject_Nat_nat project_HOL_bool inject_HOL_bool
      project_String_char_List_list inject_String_char_List_list Max_'proc
      i_'LEQ_' j_'LEQ_' r_'LEQ_' LEQ_'proc"
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'LEQ_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'LEQ_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'Max_'proc_'
variable not fixed or declared: k_'LEQ_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'
variable not fixed or declared: k_'LEQ_'
### theory "Draft.ProcParExSP"
### 1.058s elapsed time, 4.219s cpu time, 0.482s GC time
Loading theory "Draft.VcgExSP" (required by "Draft.SimplTemplates" via "Draft.Simpl")
consts
  sorted :: "('a => 'a => bool) => 'a list => bool"
Defining statespace "state_space" ...
locale Foo_impl
  fixes
    \<Gamma> ::
      "char list => (('a, 'b) vars_scheme, char list, 'c) com option"
    and Foo_'proc :: "char list"
  assumes "Foo_impl \<Gamma> Foo_'proc"
### theory "Draft.SyntaxTest"
### 0.584s elapsed time, 2.326s cpu time, 0.344s GC time
Loading theory "Draft.VcgExTotal" (required by "Draft.SimplTemplates" via "Draft.Simpl")
### theory "Draft.Quicksort"
### 0.905s elapsed time, 3.604s cpu time, 0.454s GC time
Loading theory "Draft.XVcg" (required by "Draft.SimplTemplates" via "Draft.Simpl" via "Draft.XVcgEx")
### theory "Draft.XVcg"
### 0.051s elapsed time, 0.202s cpu time, 0.085s GC time
Loading theory "Draft.XVcgEx" (required by "Draft.SimplTemplates" via "Draft.Simpl")
consts
  sum :: "(nat => nat) => nat => nat"
consts
  fac :: "nat => nat"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'Fac_'
variable not fixed or declared: N_'Fac_'
variable not fixed or declared: R_'Fac_'
variable not fixed or declared: R_'Fac_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
Defining statespace "Fac_parameters" ...
Defining statespace "Fac_variables" ...
consts
  sum :: "(nat => nat) => nat => nat"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
consts
  fac :: "nat => nat"
locale Fac_impl
  fixes
    \<Gamma> ::
      "char list => (('a, 'b) vars_scheme, char list, 'c) com option"
    and Fac_'proc :: "char list"
  assumes "Fac_impl \<Gamma> Fac_'proc"
locale Fac_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and N_'Fac_' :: "'b"
    and R_'Fac_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and StateType :: "'b => 'c"
    and Fac_'proc :: "char list"
  assumes
    "Fac_impl \<Gamma> N_'Fac_' R_'Fac_' project_Nat_nat inject_Nat_nat
      Fac_'proc"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ N{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ N{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}Fac{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}proc{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ N{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ N{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}Fac{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}proc{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'even_'
variable not fixed or declared: N_'even_'
variable not fixed or declared: A_'even_'
variable not fixed or declared: A_'even_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'odd_'
variable not fixed or declared: N_'odd_'
variable not fixed or declared: A_'odd_'
variable not fixed or declared: A_'odd_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'odd_'
variable not fixed or declared: N_'odd_'
variable not fixed or declared: A_'odd_'
variable not fixed or declared: A_'odd_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'even_'
variable not fixed or declared: N_'even_'
variable not fixed or declared: A_'even_'
variable not fixed or declared: A_'even_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
Defining statespace "odd_even_parameters" ...
Defining statespace "odd_even_variables" ...
consts
  fac :: "nat => nat"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'even_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'odd_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'odd_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'even_'proc_'
val ProcRec2 =
   "[| ALL Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z, ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z, ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^bsub>/?F \<^esub>(?P1.0 Z) the (?\<Gamma> ?p1.0)
       (?Q1.0 Z),(?A1.0 Z);
       ALL Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z, ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z, ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^bsub>/?F \<^esub>(?P2.0 Z) the (?\<Gamma> ?p2.0)
       (?Q2.0 Z),(?A2.0 Z);
       ?p1.0 : dom ?\<Gamma>; ?p2.0 : dom ?\<Gamma> |]
    ==> (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^bsub>/?F \<^esub>(?P1.0 Z) Call ?p1.0
         (?Q1.0 Z),(?A1.0 Z)) &
        (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^bsub>/?F \<^esub>(?P2.0 Z) Call ?p2.0
         (?Q2.0 Z),(?A2.0 Z))":
   thm
val it = (): unit
### theory "Draft.XVcgEx"
### 0.653s elapsed time, 2.597s cpu time, 0.281s GC time
Loading theory "Draft.UserGuide" (required by "Draft.SimplTemplates" via "Draft.Simpl")
val ProcRec2 =
   "[| ALL Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z, ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z, ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^bsub>/?F \<^esub>(?P1.0 Z) the (?\<Gamma> ?p1.0)
       (?Q1.0 Z),(?A1.0 Z);
       ALL Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z, ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z, ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^bsub>/?F \<^esub>(?P2.0 Z) the (?\<Gamma> ?p2.0)
       (?Q2.0 Z),(?A2.0 Z);
       ?p1.0 : dom ?\<Gamma>; ?p2.0 : dom ?\<Gamma> |]
    ==> (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^bsub>/?F \<^esub>(?P1.0 Z) Call ?p1.0
         (?Q1.0 Z),(?A1.0 Z)) &
        (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^bsub>/?F \<^esub>(?P2.0 Z) Call ?p2.0
         (?Q2.0 Z),(?A2.0 Z))":
   thm
val it = (): unit
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'odd_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'even_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: A_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
Defining statespace "globals_list" ...
locale append_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a globals_list_scheme, 'b) list_vars_scheme, char list,
           'c) com option"
    and append_'proc :: "char list"
  assumes "append_impl \<Gamma> append_'proc"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'append_'
variable not fixed or declared: q_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
Defining statespace "append_parameters" ...
Defining statespace "append_variables" ...
consts
  sorted :: "('a => 'a => bool) => 'a list => bool"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
locale append_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a => 'b, 'c, 'd, 'e) stateSP_scheme, char list, 'f) com option"
    and p_'append_' :: "'c"
    and q_'append_' :: "'c"
    and project_Simpl_Heap_ref :: "'d => ref"
    and inject_Simpl_Heap_ref :: "ref => 'd"
    and StateType :: "'c => 'd"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and append_'proc :: "char list"
  assumes
    "append_impl \<Gamma> p_'append_' q_'append_' project_Simpl_Heap_ref
      inject_Simpl_Heap_ref next_' cont_' project_Nat_nat_Simpl_Heap_ref_fun
      inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun append_'proc"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
consts
  sorted :: "('a => 'a => bool) => 'a list => bool"
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: cont_'
variable not fixed or declared: cont_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: cont_'
variable not fixed or declared: cont_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'insert_'
variable not fixed or declared: r_'insert_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
Defining statespace "insert_parameters" ...
Defining statespace "insert_variables" ...
val HoareTotal_ProcRec2 =
   "[| ALL \<sigma> Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z Int
                              {s. (......... ......, \<sigma>, ?p1.0) : ?r},
                              ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z Int
                              {s. (......... ......, \<sigma>, ?p1.0) : ?r},
                              ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^sub>t\<^bsub>/?F\<^esub> ({\<sigma>} Int
                ?P1.0 Z)
               the (?\<Gamma> ?p1.0) (?Q1.0 Z),(?A1.0 Z);
       ALL \<sigma> Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z Int
                              {s. (......... ......, \<sigma>, ?p2.0) : ?r},
                              ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z Int
                              {s. (......... ......, \<sigma>, ?p2.0) : ?r},
                              ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^sub>t\<^bsub>/?F\<^esub> ({\<sigma>} Int
                ?P2.0 Z)
               the (?\<Gamma> ?p2.0) (?Q2.0 Z),(?A2.0 Z);
       wf ?r; ?p1.0 : dom ?\<Gamma>; ?p2.0 : dom ?\<Gamma> |]
    ==> (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^sub>t\<^bsub>/?F\<^esub> (?P1.0 Z) Call ?p1.0
                 (?Q1.0 Z),(?A1.0 Z)) &
        (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^sub>t\<^bsub>/?F\<^esub> (?P2.0 Z) Call ?p2.0
                 (?Q2.0 Z),(?A2.0 Z))":
   thm
val it = (): unit
Defining statespace "vars" ...
### theory "Draft.VcgExTotal"
### 1.432s elapsed time, 5.696s cpu time, 0.661s GC time
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
locale compare_signature
  fixes i_'compare_' :: "'a"
    and j_'compare_' :: "'a"
    and r_'compare_' :: "'a"
    and project_Nat_nat :: "'b => nat"
    and inject_Nat_nat :: "nat => 'b"
    and project_HOL_bool :: "'b => bool"
    and inject_HOL_bool :: "bool => 'b"
    and StateType :: "'a => 'b"
    and compare_'proc :: "char list"
  assumes
    "compare_signature i_'compare_' j_'compare_' r_'compare_'
      project_Nat_nat inject_Nat_nat project_HOL_bool inject_HOL_bool"
  notes
    "compare_parameters_namespace_axioms" =
      (\<open>compare_parameters_namespace i_'compare_' j_'compare_'
               r_'compare_'\<close>)
      ["attribute" "<attribute>"]
  notes
    "distinct_names" =
      (\<open>all_distinct
               (Node (Node Tip i_'compare_' False Tip) j_'compare_' False
                 (Node Tip r_'compare_' False Tip))\<close>)
      ["attribute" "<attribute>"]
  notes
    "Nat_nat.project_inject_axioms" =
      (\<open>project_inject project_Nat_nat inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes
    "Nat_nat.project_inject_cancel" =
      (\<open>project_Nat_nat (inject_Nat_nat ?x) = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.ex_project" = (\<open>EX v. project_Nat_nat v = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.project_inject_comp_id" =
      (\<open>project_Nat_nat o inject_Nat_nat = id\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.project_inject_comp_cancel" =
      (\<open>?f o project_Nat_nat o inject_Nat_nat = ?f\<close>)
      ["statefun_simp"]
  notes
    "HOL_bool.project_inject_axioms" =
      (\<open>project_inject project_HOL_bool inject_HOL_bool\<close>)
      ["attribute" "<attribute>"]
  notes
    "HOL_bool.project_inject_cancel" =
      (\<open>project_HOL_bool (inject_HOL_bool ?x) = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "HOL_bool.ex_project" = (\<open>EX v. project_HOL_bool v = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "HOL_bool.project_inject_comp_id" =
      (\<open>project_HOL_bool o inject_HOL_bool = id\<close>)
      ["statefun_simp"]
  notes theorem
    "HOL_bool.project_inject_comp_cancel" =
      (\<open>?f o project_HOL_bool o inject_HOL_bool = ?f\<close>)
      ["statefun_simp"]
  notes
    "compare_parameters_valuetypes_axioms" =
      (\<open>compare_parameters_valuetypes project_Nat_nat inject_Nat_nat
               project_HOL_bool inject_HOL_bool\<close>)
      ["attribute" "<attribute>"]
  notes
    "compare_parameters_axioms" =
      (\<open>compare_parameters i_'compare_' j_'compare_' r_'compare_'
               project_Nat_nat inject_Nat_nat project_HOL_bool
               inject_HOL_bool\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "compare_signature_axioms" =
      (\<open>compare_signature i_'compare_' j_'compare_' r_'compare_'
               project_Nat_nat inject_Nat_nat project_HOL_bool
               inject_HOL_bool\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
variable not fixed or declared: i_'
variable not fixed or declared: i_'
variable not fixed or declared: j_'
variable not fixed or declared: j_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'compare_'proc_'
"call
  (%s. s(| locals :=
             update project_Nat_nat inject_Nat_nat j_'compare_'
              (K_statefun (lookup project_Nat_nat j_'compare_' (locals s)))
              (update project_Nat_nat inject_Nat_nat i_'compare_'
                (K_statefun
                  (lookup project_Nat_nat i_'compare_' (locals s)))
                (locals s)) |))
  compare_'proc (%s t. s(| globals := globals t |))
  (%i t. \<acute>r :== lookup project_HOL_bool r_'compare_' (locals t))"
  :: "(('f, 'd, 'e, 'g) stateSP_scheme, char list, 'h) com"
locale compare_signature
  fixes compare_'proc :: "char list"
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
"call (%s. s(| n_' := n_' s, m_' := m_' s |)) compare_'proc
  (%s t. s(| globals := globals t |)) (%i t. \<acute>b :== b_' t)"
  :: "(('a, 'b) vars_scheme, char list, 'c) com"
### Ambiguous input (line 92 of "$AFP/Simpl/UserGuide.thy") produces 2 parse trees:
### ("_statespace_lookup" ("_position" s) ("_position" A_'))
### ("\<^const>List.list.Cons" ("_position" s) ("_position" A_'))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
"dynCall (%s. s(| n_' := n_' s, m_' := m_' s |)) compare_'
  (%s t. s(| globals := globals t |)) (%i t. \<acute>b :== b_' t)"
  :: "(('a, 'b) vars_scheme, char list, 'c) com"
"\<acute>b :== DYNCALL \<acute>compare(\<acute>n,\<acute>m)"
  :: "(('a, 'b) vars_scheme, char list, 'c) com"
"{|{s. \<^bsup>s\<^esup>n = n' & \<^bsup>s\<^esup>m = m'} = X|}"
  :: "'a set"
theorems:
  Rev_body.Rev_body_def:
    Rev_body.Rev_body == \<acute>sl_q :== Null;;
    WHILE \<acute>p ~= Null 
    DO \<acute>r :== \<acute>p;;
       (False,
        {|\<acute>p ~= Null|})|->\<acute>p :== \<acute>p->\<acute>next ;;
       (False,
        {|\<acute>r ~= Null|})|->\<acute>r->\<acute>next :== \<acute>sl_q ;;
       \<acute>sl_q :== \<acute>r 
    OD
  Rev_clique.Rev_impl:
    Rev_clique ?\<Gamma> ?Rev_'proc ==>
    ?\<Gamma> ?Rev_'proc = Some Rev_body.Rev_body
  Rev_clique.intro:
    ?\<Gamma> ?Rev_'proc = Some Rev_body.Rev_body ==>
    Rev_clique ?\<Gamma> ?Rev_'proc
  Rev_clique_def:
    Rev_clique ?\<Gamma> ?Rev_'proc ==
    ?\<Gamma> ?Rev_'proc = Some Rev_body.Rev_body
  Rev_impl.axioms:
    Rev_impl ?\<Gamma> ?Rev_'proc ==> Rev_clique ?\<Gamma> ?Rev_'proc
  Rev_impl.intro:
    Rev_clique ?\<Gamma> ?Rev_'proc ==> Rev_impl ?\<Gamma> ?Rev_'proc
  Rev_impl_def:
    Rev_impl ?\<Gamma> ?Rev_'proc == Rev_clique ?\<Gamma> ?Rev_'proc
ALL \<sigma>.
   \<Gamma>
      |-({\<sigma>} Int
         {|(ALL \<tau>.
               \<Gamma>
                  |-{\<tau>} Call \<acute>compare
                    {s. \<^bsup>s\<^esup>r =
                        ?leq \<^bsup>\<tau>\<^esup>i
                         \<^bsup>\<tau>\<^esup>j}) &
           (ALL \<tau>.
               \<Gamma>
                  |-{\<tau>} Call \<acute>compare
                    {t. t may_not_modify_globals \<tau>})|})
        \<acute>k :== PROC Max(\<acute>compare,\<acute>n,\<acute>m)
        {|\<acute>k =
          mx ?leq \<^bsup>\<sigma>\<^esup>n \<^bsup>\<sigma>\<^esup>m|}
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'compare_'proc_'
"\<acute>b :== DYNCALL \<acute>compare(\<acute>n,\<acute>m)"
  :: "(('f, 'b, 'c, 'g) stateSP_scheme, char list, 'h) com"
variable not fixed or declared: compare_'
variable not fixed or declared: compare_'
variable not fixed or declared: n_'
variable not fixed or declared: n_'
variable not fixed or declared: m_'
variable not fixed or declared: m_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'
variable not fixed or declared: b_'compare_'proc_'
locale hoare_ex
  fixes
    \<Gamma> ::
      "'c => (('a globals_list_alloc_scheme, 'b) list_vars'_scheme, 'c,
              'd) com option"
"dynCall
  (%s. s(| locals :=
             update project_Nat_nat inject_Nat_nat j_'compare_'
              (K_statefun (lookup project_Nat_nat m_'Max_' (locals s)))
              (update project_Nat_nat inject_Nat_nat i_'compare_'
                (K_statefun (lookup project_Nat_nat n_'Max_' (locals s)))
                (locals s)) |))
  (%s. lookup project_String_char_List_list compare_'Max_' (locals s))
  (%s t. s(| globals := globals t |))
  (%i t. \<acute>b :== lookup project_HOL_bool r_'compare_' (locals t))"
  :: "(('f, 'b, 'c, 'g) stateSP_scheme, char list, 'h) com"
locale lift_state_space
  fixes project :: "'S => 's"
    and inject :: "'S => 's => 'S"
    and project\<^sub>x :: "('S, 'f) xstate => ('s, 'f) xstate"
    and
    lift\<^sub>e ::
      "('p => ('s, 'p, 'f) com option) => 'p => ('S, 'p, 'f) com option"
    and lift\<^sub>c :: "('s, 'p, 'f) com => ('S, 'p, 'f) com"
    and lift\<^sub>f :: "('s => 's) => 'S => 'S"
    and lift\<^sub>s :: "'s set => 'S set"
    and lift\<^sub>r :: "('s * 's) set => ('S * 'S) set"
  assumes "lift_state_space project inject"
  defines "lift\<^sub>c == lift\<^sub>c project inject"
    and "project\<^sub>x == xstate_map project"
    and "lift\<^sub>e == %\<Gamma> p. map_option lift\<^sub>c (\<Gamma> p)"
    and "lift\<^sub>f == lift\<^sub>f project inject"
    and "lift\<^sub>s == lift\<^sub>s project"
    and "lift\<^sub>r == lift\<^sub>r project inject"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
Defining statespace "Square_parameters" ...
Defining statespace "Square_variables" ...
theorems:
  Rev_lift_spec:
    Rev_impl ?\<Gamma> ''Rev'' ==>
    ALL Z.
       lift\<^sub>e ?\<Gamma>
          |-{|List \<acute>str \<acute>strnext Z|} Call ''Rev''
            {|List \<acute>q \<acute>strnext (rev Z)|}
locale Max_spec
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and Max_'proc :: "char list"
    and i_'compare_' :: "'b"
    and j_'compare_' :: "'b"
    and r_'compare_' :: "'b"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and compare_'proc :: "char list"
  assumes
    "Max_spec \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_'
      project_Nat_nat inject_Nat_nat project_String_char_List_list
      inject_String_char_List_list Max_'proc i_'compare_' j_'compare_'
      r_'compare_' project_HOL_bool inject_HOL_bool"
ALL Z.
   lift\<^sub>e [''Rev'' |-> Rev_body.Rev_body]
      |-{|List \<acute>str \<acute>strnext Z|} Call ''Rev''
        {|List \<acute>q \<acute>strnext (rev Z)|}
ALL Z.
   \<Gamma>
      |-{|List \<acute>str \<acute>strnext Z|}
        \<acute>q :== PROC RevStr(\<acute>str)
        {|List \<acute>q \<acute>strnext (rev Z)|}
Rev_clique [''Rev'' |-> Rev_body.Rev_body] ?Rev_'proc ==>
ALL \<sigma>.
   [''Rev'' |-> Rev_body.Rev_body]
      |-/UNIV {\<sigma>} Call ?Rev_'proc
              {t. t may_only_modify_globals \<sigma> in [next]}
locale hoare_ex_guard
  fixes
    \<Gamma> ::
      "'c => (('a globals_list_alloc_scheme, 'b) list_vars'_scheme, 'c,
              bool) com option"
locale Max_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and compare_'Max_' :: "'b"
    and n_'Max_' :: "'b"
    and m_'Max_' :: "'b"
    and k_'Max_' :: "'b"
    and b_'Max_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and project_HOL_bool :: "'c => bool"
    and inject_HOL_bool :: "bool => 'c"
    and project_String_char_List_list :: "'c => char list"
    and inject_String_char_List_list :: "char list => 'c"
    and StateType :: "'b => 'c"
    and i_'compare_' :: "'b"
    and j_'compare_' :: "'b"
    and r_'compare_' :: "'b"
    and compare_'proc :: "char list"
    and Max_'proc :: "char list"
  assumes
    "Max_impl \<Gamma> compare_'Max_' n_'Max_' m_'Max_' k_'Max_' b_'Max_'
      project_Nat_nat inject_Nat_nat project_HOL_bool inject_HOL_bool
      project_String_char_List_list inject_String_char_List_list
      i_'compare_' j_'compare_' r_'compare_' Max_'proc"
"(False, {|1 < 3|})|->\<acute>I :== 3 - 1 "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|in_range (3 - 1)|})|->\<acute>R :== 3 - 1 "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|i < length \<acute>A|})|->\<acute>I :== \<acute>A ! i "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"\<acute>A ! i :== j"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
"\<acute>AA :== \<acute>AA !! [i, j]"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
"\<acute>AA !! [i, j] :== \<acute>AA"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
"(False, {|i < length \<acute>A|})|->\<acute>A ! i :== j "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|i < length \<acute>GA &
    j < length (\<acute>GA ! i)|})|->\<acute>p :== \<acute>GA ! i ! j "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|i < length \<acute>GA &
    j < length (\<acute>GA ! i)|})|->\<acute>GA ! i ! j :== \<acute>p "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False, {|\<acute>p ~= Null|})|->\<acute>p :== \<acute>p->\<acute>next "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False, {|\<acute>p ~= Null|})|->\<acute>p->\<acute>next :== \<acute>p "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|\<acute>p ~= Null &
    \<acute>p->\<acute>next ~=
    Null|})|->\<acute>p->\<acute>next->\<acute>next :== \<acute>p "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"\<acute>p :== NEW sz [\<acute>next :== Null, \<acute>cont :== 0]"
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, 'd) com"
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'proc_'
"(False,
  {|\<acute>p ~=
    Null|})|->\<acute>p->\<acute>next :==
               NEW sz [\<acute>next :== Null, \<acute>cont :== 0] "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"\<acute>p :== NNEW sz [\<acute>next :== Null, \<acute>cont :== 0]"
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, 'd) com"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'proc_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
"(False,
  {|\<acute>p ~=
    Null|})|->\<acute>p->\<acute>next :==
               NNEW sz [\<acute>next :== Null, \<acute>cont :== 0] "
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|in_range (\<acute>N + 1) &
    (\<acute>N + 1 < 0 -->
     in_range
      (\<acute>M +
       \<acute>N))|})|->\<acute>B :==
                        \<acute>N + 1 < 0 & \<acute>M + \<acute>N < n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
Defining statespace "insertSort_parameters" ...
"(False,
  {|in_range (\<acute>N + 1) &
    (~ \<acute>N + 1 < 0 -->
     in_range
      (\<acute>M +
       \<acute>N))|})|->\<acute>B :==
                        \<acute>N + 1 < 0 | \<acute>M + \<acute>N < n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|n ~= 0|})|->\<acute>I :== \<acute>N mod n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|n ~= 0 & in_range (\<acute>N div n)|})|->\<acute>I :== \<acute>N div n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|n ~= 0 & in_range (\<acute>R div n)|})|->\<acute>R :== \<acute>R div n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|n ~= 0|})|->\<acute>R :== \<acute>R mod n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|in_range (\<acute>R * n)|})|->\<acute>R :== \<acute>R * n "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|\<acute>N < \<acute>I|})|->\<acute>I :== \<acute>I - \<acute>N "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
Defining statespace "insertSort_variables" ...
"(False,
  {|in_range
     (\<acute>R - \<acute>S)|})|->\<acute>R :== \<acute>R - \<acute>S "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"\<acute>R :== int \<acute>I"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
"(False, {|0 <= \<acute>R|})|->\<acute>I :== nat \<acute>R "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False, {|in_range (- \<acute>R)|})|->\<acute>R :== - \<acute>R "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"(False,
  {|i < length
         \<acute>A|})|->IF \<acute>A ! i < \<acute>N THEN c1 ELSE c2 FI "
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"WHILE (False, {|i < length \<acute>A|})|-> \<acute>A ! i < \<acute>N DO c 
 OD"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"WHILE (False, {|i < length \<acute>A|})|-> 
       \<acute>A ! i < \<acute>N INV {|foo|} 
 DO c OD"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"WHILE (False, {|i < length \<acute>A|})
       \<longmapsto> \<acute>A ! i < \<acute>N INV {|foo|}
 VAR bar x DO c OD"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"WHILE (False, {|i < length \<acute>A|})
       \<longmapsto> \<acute>A ! i < \<acute>N INV {|foo|}
 VAR bar x DO c OD;;
 c"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"c;;
 WHILE (False, {|i < length \<acute>A|})
       \<longmapsto> \<acute>A ! i < \<acute>N INV {|foo|}
 VAR MEASURE \<acute>N + \<acute>M DO c;; c OD;;
 c"
  :: "(('a, 'b) vars_scheme, 'c, bool) com"
"\<acute>q :== CALL Foo(\<acute>p,\<acute>M)"
  :: "(('d, 'e) vars_scheme, char list, 'f) com"
"(False, {|in_range (\<acute>M + 1)|})|->\<acute>q :== CALL Foo(\<acute>p,
 \<acute>M + 1) "
  :: "(('d, 'e) vars_scheme, char list, bool) com"
"\<acute>q :== CALL Foo(\<acute>p->\<acute>next,\<acute>M)"
  :: "(('d globals_scheme, 'e) vars_scheme, char list, 'f) com"
"\<acute>q->\<acute>next :== CALL Foo(\<acute>p,\<acute>M)"
  :: "(('d globals_scheme, 'e) vars_scheme, char list, 'f) com"
Fac_body.Fac_body ?Fac_'proc ==
IF \<acute>N = 0 THEN \<acute>R :== 1
ELSE \<acute>R :== CALL ?Fac_'proc(\<acute>N - 1);;
  \<acute>R :== \<acute>N * \<acute>R
FI
locale Fac_impl
  fixes
    \<Gamma> ::
      "char list => (('a, 'b) vars_scheme, char list, 'c) com option"
    and Fac_'proc :: "char list"
  assumes "Fac_impl \<Gamma> Fac_'proc"
"call (%s. s(| N_' := N_' s |)) Fac_'proc
  (%s t. s(| globals := globals t |)) (%i t. \<acute>M :== R_' t)"
  :: "(('d, 'e) vars_scheme, char list, 'f) com"
locale Square_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and N_'Square_' :: "'b"
    and R_'Square_' :: "'b"
    and I_'Square_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and StateType :: "'b => 'c"
    and Square_'proc :: "char list"
  assumes
    "Square_impl \<Gamma> N_'Square_' R_'Square_' I_'Square_'
      project_Nat_nat inject_Nat_nat Square_'proc"
locale Fac_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'b, 'c, 'd) stateSP_scheme, char list, 'e) com option"
    and N_'Fac_' :: "'b"
    and R_'Fac_' :: "'b"
    and project_Nat_nat :: "'c => nat"
    and inject_Nat_nat :: "nat => 'c"
    and StateType :: "'b => 'c"
    and Fac_'proc :: "char list"
  assumes
    "Fac_impl \<Gamma> N_'Fac_' R_'Fac_' project_Nat_nat inject_Nat_nat
      Fac_'proc"
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: I_'
variable not fixed or declared: I_'
variable not fixed or declared: I_'Square_'proc_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
"call
  (%s. s(| locals :=
             update project_Nat_nat inject_Nat_nat N_'Fac_'
              (K_statefun (lookup project_Nat_nat N_'Fac_' (locals s)))
              (locals s) |))
  Fac_'proc (%s t. s(| globals := globals t |))
  (%i t. \<acute>R :== lookup project_Nat_nat R_'Fac_' (locals t))"
  :: "(('f, 'b, 'c, 'g) stateSP_scheme, char list, 'h) com"
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ I{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ I{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ I{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}Square{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}proc{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable not fixed or declared: I_'
variable not fixed or declared: I_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Square_'proc_'
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ I{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ I{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ R{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}Square{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}proc{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'insert_'proc_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
theorems:
  even_body.even_body.cong:
    even_body.even_body ?odd_'proc ?even_'proc ==
    even_body.even_body ?odd_'proc ?even_'proc
  even_body.even_body_def:
    even_body.even_body ?odd_'proc ?even_'proc ==
    IF \<acute>N = 0 THEN \<acute>A :== 1
    ELSE IF \<acute>N = 1 THEN \<acute>A :== CALL ?odd_'proc(\<acute>N - 1)
         ELSE \<acute>A :== CALL ?even_'proc(\<acute>N - 2) FI
    FI
  even_impl.axioms:
    even_impl ?\<Gamma> ?even_'proc ?odd_'proc ==>
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc
  even_impl.intro:
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc ==>
    even_impl ?\<Gamma> ?even_'proc ?odd_'proc
  even_impl_def:
    even_impl ?\<Gamma> ?even_'proc ?odd_'proc ==
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc
  odd_body.odd_body.cong:
    odd_body.odd_body ?even_'proc ?odd_'proc ==
    odd_body.odd_body ?even_'proc ?odd_'proc
  odd_body.odd_body_def:
    odd_body.odd_body ?even_'proc ?odd_'proc ==
    IF \<acute>N = 0 THEN \<acute>A :== 0
    ELSE IF \<acute>N = 1 THEN \<acute>A :== CALL ?even_'proc(\<acute>N - 1)
         ELSE \<acute>A :== CALL ?odd_'proc(\<acute>N - 2) FI
    FI
  odd_even_clique.axioms:
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc ==>
    odd_even_clique_names ?odd_'proc ?even_'proc
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc ==>
    odd_even_clique_axioms ?\<Gamma> ?even_'proc ?odd_'proc
  odd_even_clique.even_impl:
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc ==>
    ?\<Gamma> ?even_'proc =
    Some (even_body.even_body ?odd_'proc ?even_'proc)
  odd_even_clique.intro:
    [| odd_even_clique_names ?odd_'proc ?even_'proc;
       odd_even_clique_axioms ?\<Gamma> ?even_'proc ?odd_'proc |]
    ==> odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc
  odd_even_clique.odd_impl:
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc ==>
    ?\<Gamma> ?odd_'proc = Some (odd_body.odd_body ?even_'proc ?odd_'proc)
  odd_even_clique_axioms.intro:
    [| ?\<Gamma> ?odd_'proc =
       Some (odd_body.odd_body ?even_'proc ?odd_'proc);
       ?\<Gamma> ?even_'proc =
       Some (even_body.even_body ?odd_'proc ?even_'proc) |]
    ==> odd_even_clique_axioms ?\<Gamma> ?even_'proc ?odd_'proc
  odd_even_clique_axioms_def:
    odd_even_clique_axioms ?\<Gamma> ?even_'proc ?odd_'proc ==
    ?\<Gamma> ?odd_'proc = Some (odd_body.odd_body ?even_'proc ?odd_'proc) &
    ?\<Gamma> ?even_'proc =
    Some (even_body.even_body ?odd_'proc ?even_'proc)
  odd_even_clique_def:
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc ==
    odd_even_clique_names ?odd_'proc ?even_'proc &
    odd_even_clique_axioms ?\<Gamma> ?even_'proc ?odd_'proc
  odd_even_clique_names.distinct_names:
    odd_even_clique_names ?odd_'proc ?even_'proc ==>
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip))
  odd_even_clique_names.intro:
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip)) ==>
    odd_even_clique_names ?odd_'proc ?even_'proc
  odd_even_clique_names_def:
    odd_even_clique_names ?odd_'proc ?even_'proc ==
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip))
  odd_impl.axioms:
    odd_impl ?\<Gamma> ?even_'proc ?odd_'proc ==>
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc
  odd_impl.intro:
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc ==>
    odd_impl ?\<Gamma> ?even_'proc ?odd_'proc
  odd_impl_def:
    odd_impl ?\<Gamma> ?even_'proc ?odd_'proc ==
    odd_even_clique ?\<Gamma> ?even_'proc ?odd_'proc
odd_body.odd_body ?even_'proc ?odd_'proc ==
IF \<acute>N = 0 THEN \<acute>A :== 0
ELSE IF \<acute>N = 1 THEN \<acute>A :== CALL ?even_'proc(\<acute>N - 1)
     ELSE \<acute>A :== CALL ?odd_'proc(\<acute>N - 2) FI
FI
even_body.even_body ?odd_'proc ?even_'proc ==
IF \<acute>N = 0 THEN \<acute>A :== 1
ELSE IF \<acute>N = 1 THEN \<acute>A :== CALL ?odd_'proc(\<acute>N - 1)
     ELSE \<acute>A :== CALL ?even_'proc(\<acute>N - 2) FI
FI
locale odd_even_clique
  fixes
    \<Gamma> ::
      "char list => (('a, 'b) vars_scheme, char list, 'c) com option"
    and even_'proc :: "char list"
    and odd_'proc :: "char list"
  assumes "odd_even_clique \<Gamma> even_'proc odd_'proc"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Square_'proc_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
"\<acute>??.XVcgEx.vars :==\<^bsub>[B, A]\<^esub> {y, x}"
  :: "(('a, 'b) vars_scheme, 'c, 'd) com"
"\<acute>??.XVcgEx.globals. :==\<^bsub>[]\<^esub> [{G_' (globals B.0)}, {}]"
  :: "(('a globals_scheme, 'b) state_scheme, 'c, 'd) com"
"BASIC
 LET (x, y) = (\<acute>A, b); z = \<acute>B
 IN \<acute>G :== \<acute>A + y + z
 END"
  :: "(('a globals_scheme, 'b) vars_scheme, 'c, 'd) com"
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Square_'proc_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: I_'
variable not fixed or declared: I_'
variable not fixed or declared: I_'
variable not fixed or declared: I_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Square_'proc_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: I_'
variable not fixed or declared: I_'
variable not fixed or declared: I_'
variable not fixed or declared: I_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Square_'proc_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
theorems:
  even_body.axioms:
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  even_body.even_body.cong:
    even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?odd_'proc ?even_'proc ==
    even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?odd_'proc ?even_'proc
  even_body.even_body_def:
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?odd_'proc ?even_'proc ==
    IF \<acute>(lookup ?project_Nat_nat ?N_'odd_even_') = 0
    THEN Basic
          (%s. s(| locals :=
                     update ?project_Nat_nat ?inject_Nat_nat ?A_'odd_even_'
                      (K_statefun 1) (locals s) |))
    ELSE IF \<acute>(lookup ?project_Nat_nat ?N_'odd_even_') = 1
         THEN call
               (%s. s(| locals :=
                          update ?project_Nat_nat ?inject_Nat_nat
                           ?N_'odd_even_'
                           (K_statefun
                             (lookup ?project_Nat_nat ?N_'odd_even_'
                               (locals s) -
                              1))
                           (locals s) |))
               ?odd_'proc (%s t. s(| globals := globals t |))
               (%i t. Basic
                       (%s. s(| locals :=
                                  update ?project_Nat_nat ?inject_Nat_nat
                                   ?A_'odd_even_'
                                   (K_statefun
                                     (lookup ?project_Nat_nat ?A_'odd_even_'
 (locals t)))
                                   (locals s) |)))
         ELSE call
               (%s. s(| locals :=
                          update ?project_Nat_nat ?inject_Nat_nat
                           ?N_'odd_even_'
                           (K_statefun
                             (lookup ?project_Nat_nat ?N_'odd_even_'
                               (locals s) -
                              2))
                           (locals s) |))
               ?even_'proc (%s t. s(| globals := globals t |))
               (%i t. Basic
                       (%s. s(| locals :=
                                  update ?project_Nat_nat ?inject_Nat_nat
                                   ?A_'odd_even_'
                                   (K_statefun
                                     (lookup ?project_Nat_nat ?A_'odd_even_'
 (locals t)))
                                   (locals s) |)))
         FI
    FI
  even_body.intro:
    [| odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat;
       odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat |]
    ==> even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
         ?inject_Nat_nat
  even_body_def:
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat &
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  even_impl.axioms:
    even_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  even_impl.intro:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    even_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  even_impl_def:
    even_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  even_signature.axioms:
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  even_signature.intro:
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  even_signature_def:
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_body.axioms:
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_body.intro:
    [| odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat;
       even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat |]
    ==> odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
         ?inject_Nat_nat
  odd_body.odd_body.cong:
    odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_body.odd_body_def:
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    IF \<acute>(lookup ?project_Nat_nat ?N_'odd_even_') = 0
    THEN Basic
          (%s. s(| locals :=
                     update ?project_Nat_nat ?inject_Nat_nat ?A_'odd_even_'
                      (K_statefun 0) (locals s) |))
    ELSE IF \<acute>(lookup ?project_Nat_nat ?N_'odd_even_') = 1
         THEN call
               (%s. s(| locals :=
                          update ?project_Nat_nat ?inject_Nat_nat
                           ?N_'odd_even_'
                           (K_statefun
                             (lookup ?project_Nat_nat ?N_'odd_even_'
                               (locals s) -
                              1))
                           (locals s) |))
               ?even_'proc (%s t. s(| globals := globals t |))
               (%i t. Basic
                       (%s. s(| locals :=
                                  update ?project_Nat_nat ?inject_Nat_nat
                                   ?A_'odd_even_'
                                   (K_statefun
                                     (lookup ?project_Nat_nat ?A_'odd_even_'
 (locals t)))
                                   (locals s) |)))
         ELSE call
               (%s. s(| locals :=
                          update ?project_Nat_nat ?inject_Nat_nat
                           ?N_'odd_even_'
                           (K_statefun
                             (lookup ?project_Nat_nat ?N_'odd_even_'
                               (locals s) -
                              2))
                           (locals s) |))
               ?odd_'proc (%s t. s(| globals := globals t |))
               (%i t. Basic
                       (%s. s(| locals :=
                                  update ?project_Nat_nat ?inject_Nat_nat
                                   ?A_'odd_even_'
                                   (K_statefun
                                     (lookup ?project_Nat_nat ?A_'odd_even_'
 (locals t)))
                                   (locals s) |)))
         FI
    FI
  odd_body_def:
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat &
    even_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_even_clique.axioms:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat ?inject_Nat_nat
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat ?inject_Nat_nat
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_even_clique_names ?odd_'proc ?even_'proc
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
     ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_even_clique.even_impl:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    ?\<Gamma> ?even_'proc =
    Some
     (even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
       ?inject_Nat_nat ?odd_'proc ?even_'proc)
  odd_even_clique.intro:
    [| odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat;
       even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
        ?inject_Nat_nat;
       odd_even_clique_names ?odd_'proc ?even_'proc;
       odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
        ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc |]
    ==> odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
         ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_even_clique.odd_impl:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    ?\<Gamma> ?odd_'proc =
    Some
     (odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
       ?inject_Nat_nat ?even_'proc ?odd_'proc)
  odd_even_clique_axioms.intro:
    [| ?\<Gamma> ?odd_'proc =
       Some
        (odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
          ?inject_Nat_nat ?even_'proc ?odd_'proc);
       ?\<Gamma> ?even_'proc =
       Some
        (even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
          ?inject_Nat_nat ?odd_'proc ?even_'proc) |]
    ==> odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
         ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_even_clique_axioms_def:
    odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
     ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    ?\<Gamma> ?odd_'proc =
    Some
     (odd_body.odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
       ?inject_Nat_nat ?even_'proc ?odd_'proc) &
    ?\<Gamma> ?even_'proc =
    Some
     (even_body.even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
       ?inject_Nat_nat ?odd_'proc ?even_'proc)
  odd_even_clique_def:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    (odd_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
      ?inject_Nat_nat &
     even_body ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
      ?inject_Nat_nat) &
    odd_even_clique_names ?odd_'proc ?even_'proc &
    odd_even_clique_axioms ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_'
     ?project_Nat_nat ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_even_clique_names.distinct_names:
    odd_even_clique_names ?odd_'proc ?even_'proc ==>
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip))
  odd_even_clique_names.intro:
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip)) ==>
    odd_even_clique_names ?odd_'proc ?even_'proc
  odd_even_clique_names_def:
    odd_even_clique_names ?odd_'proc ?even_'proc ==
    all_distinct
     (Node Tip ?odd_'proc False (Node Tip ?even_'proc False Tip))
  odd_even_parameters.axioms:
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_'
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_parameters.intro:
    [| odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_';
       odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat |]
    ==> odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
         ?inject_Nat_nat
  odd_even_parameters_def:
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_' &
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_parameters_namespace.distinct_names:
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_' ==>
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip))
  odd_even_parameters_namespace.intro:
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip)) ==>
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_'
  odd_even_parameters_namespace_def:
    odd_even_parameters_namespace ?N_'odd_even_' ?A_'odd_even_' ==
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip))
  odd_even_parameters_valuetypes.axioms:
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat ==>
    project_inject ?project_Nat_nat ?inject_Nat_nat
  odd_even_parameters_valuetypes.intro:
    project_inject ?project_Nat_nat ?inject_Nat_nat ==>
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_parameters_valuetypes_def:
    odd_even_parameters_valuetypes ?project_Nat_nat ?inject_Nat_nat ==
    project_inject ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables.axioms:
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_'
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables.intro:
    [| odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_';
       odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat |]
    ==> odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
         ?inject_Nat_nat
  odd_even_variables_def:
    odd_even_variables ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_' &
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables_namespace.distinct_names:
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_' ==>
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip))
  odd_even_variables_namespace.intro:
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip)) ==>
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_'
  odd_even_variables_namespace_def:
    odd_even_variables_namespace ?N_'odd_even_' ?A_'odd_even_' ==
    all_distinct
     (Node Tip ?A_'odd_even_' False (Node Tip ?N_'odd_even_' False Tip))
  odd_even_variables_valuetypes.axioms:
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat ==>
    project_inject ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables_valuetypes.intro:
    project_inject ?project_Nat_nat ?inject_Nat_nat ==>
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat
  odd_even_variables_valuetypes_def:
    odd_even_variables_valuetypes ?project_Nat_nat ?inject_Nat_nat ==
    project_inject ?project_Nat_nat ?inject_Nat_nat
  odd_impl.axioms:
    odd_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_impl.intro:
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==>
    odd_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_impl_def:
    odd_impl ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc ==
    odd_even_clique ?\<Gamma> ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ?even_'proc ?odd_'proc
  odd_signature.axioms:
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_signature.intro:
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==>
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
  odd_signature_def:
    odd_signature ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat ==
    odd_even_parameters ?N_'odd_even_' ?A_'odd_even_' ?project_Nat_nat
     ?inject_Nat_nat
consts
  fac :: "nat => nat"
### theory "Draft.VcgEx"
### 2.207s elapsed time, 8.799s cpu time, 1.082s GC time
locale odd_even_clique
  fixes
    \<Gamma> ::
      "char list
       => (('a, 'd, 'e, 'b) stateSP_scheme, char list, 'c) com option"
    and N_'odd_even_' :: "'d"
    and A_'odd_even_' :: "'d"
    and project_Nat_nat :: "'e => nat"
    and inject_Nat_nat :: "nat => 'e"
    and StateType :: "'d => 'e"
    and even_'proc :: "char list"
    and odd_'proc :: "char list"
  assumes
    "odd_even_clique \<Gamma> N_'odd_even_' A_'odd_even_' project_Nat_nat
      inject_Nat_nat even_'proc odd_'proc"
  notes
    "odd_even.odd_even_parameters_namespace_axioms" =
      (\<open>odd_even_parameters_namespace N_'odd_even_'
               A_'odd_even_'\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even.distinct_names" =
      (\<open>all_distinct
               (Node Tip A_'odd_even_' False
                 (Node Tip N_'odd_even_' False Tip))\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even_variables_namespace_axioms" =
      (\<open>odd_even_variables_namespace N_'odd_even_'
               A_'odd_even_'\<close>)
      ["attribute" "<attribute>"]
  notes
    "distinct_names" =
      (\<open>all_distinct
               (Node Tip A_'odd_even_' False
                 (Node Tip N_'odd_even_' False Tip))\<close>)
      ["attribute" "<attribute>"]
  notes
    "Nat_nat.project_inject_axioms" =
      (\<open>project_inject project_Nat_nat inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes
    "Nat_nat.project_inject_cancel" =
      (\<open>project_Nat_nat (inject_Nat_nat ?x) = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.ex_project" = (\<open>EX v. project_Nat_nat v = ?x\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.project_inject_comp_id" =
      (\<open>project_Nat_nat o inject_Nat_nat = id\<close>)
      ["statefun_simp"]
  notes theorem
    "Nat_nat.project_inject_comp_cancel" =
      (\<open>?f o project_Nat_nat o inject_Nat_nat = ?f\<close>)
      ["statefun_simp"]
  notes
    "odd_even_variables_valuetypes_axioms" =
      (\<open>odd_even_variables_valuetypes project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even.odd_even_parameters_valuetypes_axioms" =
      (\<open>odd_even_parameters_valuetypes project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even.odd_even_parameters_axioms" =
      (\<open>odd_even_parameters N_'odd_even_' A_'odd_even_'
               project_Nat_nat inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "odd_even_variables_axioms" =
      (\<open>odd_even_variables N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "even_signature_axioms" =
      (\<open>even_signature N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "odd_body_axioms" =
      (\<open>VcgExSP.odd_body N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "odd_body_def" =
      \<open>local.odd_body ==
             IF \<acute>N = 0 THEN \<acute>A :== 0
             ELSE IF \<acute>N = 1
                  THEN \<acute>A :== CALL even(\<acute>N - 1)
                  ELSE \<acute>A :== CALL odd(\<acute>N - 2) FI
             FI\<close>
  notes
    "odd_signature_axioms" =
      (\<open>odd_signature N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "even_body_axioms" =
      (\<open>VcgExSP.even_body N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat\<close>)
      ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes
    "even_body_def" =
      \<open>local.even_body ==
             IF \<acute>N = 0 THEN \<acute>A :== 1
             ELSE IF \<acute>N = 1
                  THEN \<acute>A :== CALL odd(\<acute>N - 1)
                  ELSE \<acute>A :== CALL even(\<acute>N - 2) FI
             FI\<close>
  notes
    "odd_even_clique_names_axioms" =
      (\<open>odd_even_clique_names odd_'proc even_'proc\<close>)
      ["attribute" "<attribute>"]
  notes
    "distinct_names" =
      (\<open>all_distinct
               (Node Tip odd_'proc False
                 (Node Tip even_'proc False Tip))\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_impl_axioms" =
      (\<open>odd_impl \<Gamma> N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat even_'proc odd_'proc\<close>)
      ["attribute" "<attribute>"]
  notes
    "even_impl_axioms" =
      (\<open>even_impl \<Gamma> N_'odd_even_' A_'odd_even_' project_Nat_nat
               inject_Nat_nat even_'proc odd_'proc\<close>)
      ["attribute" "<attribute>"]
  notes
    "odd_even_clique_axioms" =
      (\<open>odd_even_clique \<Gamma> N_'odd_even_' A_'odd_even_'
               project_Nat_nat inject_Nat_nat even_'proc odd_'proc\<close>)
      ["attribute" "<attribute>"]
  notes "odd_impl" = \<open>\<Gamma> odd_'proc = Some local.odd_body\<close>
  notes
    "even_impl" = \<open>\<Gamma> even_'proc = Some local.even_body\<close>
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
  notes (\<open>TERM _\<close>) ["attribute" "<attribute>"]
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
"call (%s. s(| p_' := p_' s, q_' := q_' s |)) append_'proc
  (%s t. s(| globals := globals t |)) (%i t. p_' i->\<acute>next :== p_' t)"
  :: "(('d globals_list_scheme, 'e) list_vars_scheme, char list, 'f) com"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'Fac_'
variable not fixed or declared: N_'Fac_'
variable not fixed or declared: R_'Fac_'
variable not fixed or declared: R_'Fac_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
"call
  (%s. s(| locals :=
             update project_Simpl_Heap_ref inject_Simpl_Heap_ref q_'append_'
              (K_statefun
                (lookup project_Simpl_Heap_ref q_'append_' (locals s)))
              (update project_Simpl_Heap_ref inject_Simpl_Heap_ref
                p_'append_'
                (K_statefun
                  (lookup project_Simpl_Heap_ref p_'append_' (locals s)))
                (locals s)) |))
  append_'proc (%s t. s(| globals := globals t |))
  (%i t. lookup project_Simpl_Heap_ref p_'append_'
          (locals i)->\<acute>next :==
         lookup project_Simpl_Heap_ref p_'append_' (locals t))"
  :: "(('a => 'b, 'c, 'd, 'g) stateSP_scheme, char list, 'h) com"
Defining statespace "Fac_parameters" ...
"\<Gamma>
    |-/{True} {|True|}
              WHILE (False, {|i < length \<acute>Arr|})
                    \<longmapsto> \<acute>N < \<acute>Arr ! i FIX Z.
              INV {|\<acute>N < 2|}DO \<acute>N :== \<acute>M OD
              {|hard|}"
  :: "bool"
Defining statespace "Fac_variables" ...
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
Defining statespace "globals_heap" ...
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'append_'
variable not fixed or declared: q_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'append_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insertSort_'proc_'
Defining statespace "append_parameters" ...
locale insertSort_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a => 'b, 'c, 'd, 'e) stateSP_scheme, char list, 'f) com option"
    and p_'insertSort_' :: "'c"
    and r_'insertSort_' :: "'c"
    and q_'insertSort_' :: "'c"
    and project_Simpl_Heap_ref :: "'d => ref"
    and inject_Simpl_Heap_ref :: "ref => 'd"
    and StateType :: "'c => 'd"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and r_'insert_' :: "'c"
    and p_'insert_' :: "'c"
    and insert_'proc :: "char list"
    and insertSort_'proc :: "char list"
  assumes
    "insertSort_impl \<Gamma> p_'insertSort_' r_'insertSort_'
      q_'insertSort_' project_Simpl_Heap_ref inject_Simpl_Heap_ref next_'
      cont_' project_Nat_nat_Simpl_Heap_ref_fun
      inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun r_'insert_' p_'insert_'
      insert_'proc insertSort_'proc"
Defining statespace "append_variables" ...
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insertSort_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
Defining statespace "globals_list_alloc" ...
Defining statespace "locals_list_alloc" ...
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
locale list_alloc
  fixes alloc_' :: "'a"
    and free_' :: "'a"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and project_Nat_nat :: "'b => nat"
    and inject_Nat_nat :: "nat => 'b"
    and project_Simpl_Heap_ref_List_list :: "'b => ref list"
    and inject_Simpl_Heap_ref_List_list :: "ref list => 'b"
    and i_' :: "'c"
    and first_' :: "'c"
    and p_' :: "'c"
    and q_' :: "'c"
    and r_' :: "'c"
    and root_' :: "'c"
    and tmp_' :: "'c"
    and project_Simpl_Heap_ref :: "'b => ref"
    and inject_Simpl_Heap_ref :: "ref => 'b"
  assumes
    "list_alloc alloc_' free_' next_' cont_'
      project_Nat_nat_Simpl_Heap_ref_fun inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun project_Nat_nat
      inject_Nat_nat project_Simpl_Heap_ref_List_list
      inject_Simpl_Heap_ref_List_list i_' first_' p_' q_' r_' root_' tmp_'
      project_Simpl_Heap_ref inject_Simpl_Heap_ref"
locale append_impl
  fixes
    \<Gamma> ::
      "char list
       => (('a => 'b, 'c, 'd, 'e) stateSP_scheme, char list, 'f) com option"
    and p_'append_' :: "'c"
    and q_'append_' :: "'c"
    and project_Simpl_Heap_ref :: "'d => ref"
    and inject_Simpl_Heap_ref :: "ref => 'd"
    and StateType :: "'c => 'd"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and append_'proc :: "char list"
  assumes
    "append_impl \<Gamma> p_'append_' q_'append_' project_Simpl_Heap_ref
      inject_Simpl_Heap_ref next_' cont_' project_Nat_nat_Simpl_Heap_ref_fun
      inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun append_'proc"
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ q{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ q{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}append{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}proc{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ q{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ q{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable\ not\ fixed\ or\ declared{\isacharcolon}{\kern0pt}\ p{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}append{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}proc{\isacharunderscore}{\kern0pt}{\isacharprime}{\kern0pt}
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'Fac_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: R_'
variable not fixed or declared: R_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'append_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'coast_'
variable not fixed or declared: N_'coast_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'coast_'
variable not fixed or declared: M_'coast_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'pedal_'
variable not fixed or declared: N_'pedal_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'pedal_'
variable not fixed or declared: M_'pedal_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'pedal_'
variable not fixed or declared: N_'pedal_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'pedal_'
variable not fixed or declared: M_'pedal_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'coast_'
variable not fixed or declared: N_'coast_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'coast_'
variable not fixed or declared: M_'coast_'
Defining statespace "pedal_coast_parameters" ...
locale list_alloc
  fixes alloc_' :: "'a"
    and free_' :: "'a"
    and next_' :: "'a"
    and cont_' :: "'a"
    and project_Nat_nat_Simpl_Heap_ref_fun :: "'b => ref => nat"
    and inject_Nat_nat_Simpl_Heap_ref_fun :: "(ref => nat) => 'b"
    and project_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "'b => ref => ref"
    and inject_Simpl_Heap_ref_Simpl_Heap_ref_fun :: "(ref => ref) => 'b"
    and project_Nat_nat :: "'b => nat"
    and inject_Nat_nat :: "nat => 'b"
    and project_Simpl_Heap_ref_List_list :: "'b => ref list"
    and inject_Simpl_Heap_ref_List_list :: "ref list => 'b"
    and i_' :: "'c"
    and first_' :: "'c"
    and p_' :: "'c"
    and q_' :: "'c"
    and r_' :: "'c"
    and root_' :: "'c"
    and tmp_' :: "'c"
    and project_Simpl_Heap_ref :: "'b => ref"
    and inject_Simpl_Heap_ref :: "ref => 'b"
  assumes
    "list_alloc alloc_' free_' next_' cont_'
      project_Nat_nat_Simpl_Heap_ref_fun inject_Nat_nat_Simpl_Heap_ref_fun
      project_Simpl_Heap_ref_Simpl_Heap_ref_fun
      inject_Simpl_Heap_ref_Simpl_Heap_ref_fun project_Nat_nat
      inject_Nat_nat project_Simpl_Heap_ref_List_list
      inject_Simpl_Heap_ref_List_list i_' first_' p_' q_' r_' root_' tmp_'
      project_Simpl_Heap_ref inject_Simpl_Heap_ref"
Defining statespace "pedal_coast_variables" ...
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
locale state_space
  fixes A_' :: "'a"
    and I_' :: "'a"
    and M_' :: "'a"
    and N_' :: "'a"
    and R_' :: "'a"
    and S_' :: "'a"
    and B_' :: "'a"
    and Abr_' :: "'a"
    and project_Nat_nat :: "'b => nat"
    and inject_Nat_nat :: "nat => 'b"
    and project_HOL_bool :: "'b => bool"
    and inject_HOL_bool :: "bool => 'b"
    and project_String_char_List_list :: "'b => char list"
    and inject_String_char_List_list :: "char list => 'b"
  assumes
    "state_space A_' I_' M_' N_' R_' S_' B_' Abr_' project_Nat_nat
      inject_Nat_nat project_HOL_bool inject_HOL_bool
      project_String_char_List_list inject_String_char_List_list"
"ANNO (\<tau>, m, k). {|\<tau>. \<acute>M = m|}
 \<acute>M :== \<acute>N;; \<acute>N :== \<acute>I
 {|\<acute>M = \<^bsup>\<tau>\<^esup>N &
   \<acute>N = \<^bsup>\<tau>\<^esup>I|},
 {}"
  :: "(('c, 'a, 'b, 'd) stateSP_scheme, 'f, 'g) com"
### theory "Draft.VcgExSP"
### 2.724s elapsed time, 9.690s cpu time, 1.112s GC time
val HoareTotal_ProcRec2 =
   "[| ALL \<sigma> Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z Int
                              _Collect s (......... ...... ...... ... ?r),
                              ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z Int
                              _Collect s (......... ...... ...... ... ?r),
                              ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^sub>t\<^bsub>/?F\<^esub> ({\<sigma>} Int
                ?P1.0 Z)
               the (?\<Gamma> ?p1.0) (?Q1.0 Z),(?A1.0 Z);
       ALL \<sigma> Z.
          ?\<Gamma>,?\<Theta> Un
                    ((UN Z. {(?P1.0 Z Int
                              _Collect s (......... ...... ...... ... ?r),
                              ?p1.0, ?Q1.0 Z, ?A1.0 Z)}) Un
                     (UN Z. {(?P2.0 Z Int
                              _Collect s (......... ...... ...... ... ?r),
                              ?p2.0, ?Q2.0 Z, ?A2.0 Z)}))
             \<turnstile>\<^sub>t\<^bsub>/?F\<^esub> ({\<sigma>} Int
                ?P2.0 Z)
               the (?\<Gamma> ?p2.0) (?Q2.0 Z),(?A2.0 Z);
       wf ?r; ?p1.0 : dom ?\<Gamma>; ?p2.0 : dom ?\<Gamma> |]
    ==> (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^sub>t\<^bsub>/?F\<^esub> (?P1.0 Z) Call ?p1.0
                 (?Q1.0 Z),(?A1.0 Z)) &
        (ALL Z.
            ?\<Gamma>,?\<Theta>
               \<turnstile>\<^sub>t\<^bsub>/?F\<^esub> (?P2.0 Z) Call ?p2.0
                 (?Q2.0 Z),(?A2.0 Z))":
   thm
val it = (): unit
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
consts
  sorted :: "('a => 'a => bool) => 'a list => bool"
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: cont_'
variable not fixed or declared: cont_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: cont_'
variable not fixed or declared: cont_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'insert_'
variable not fixed or declared: r_'insert_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'insert_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
Defining statespace "insert_parameters" ...
Defining statespace "insert_variables" ...
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insert_'proc_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: next_'
variable not fixed or declared: next_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
Defining statespace "insertSort_parameters" ...
Defining statespace "insertSort_variables" ...
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: q_'
variable not fixed or declared: q_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'insert_'proc_'
variable not fixed or declared: r_'
variable not fixed or declared: r_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insertSort_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'insertSort_'proc_'
variable not fixed or declared: p_'
variable not fixed or declared: p_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
Defining statespace "foo_parameters" ...
Defining statespace "foo_variables" ...
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'foo_'proc_'
### Additional type variable(s) in locale specification "foo_spec": 'f
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'foo_'proc_'
### Additional type variable(s) in specification of "foo_spec": 'f
### Illegal free variable(s) in term: Q, P
### in constant abbreviation "foo_spec"
### abbreviation: 'foo_spec' not added
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'foo_'proc_'
variable not fixed or declared: N_'
variable not fixed or declared: N_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'
variable not fixed or declared: M_'foo_'proc_'
### theory "Draft.UserGuide"
### 2.770s elapsed time, 6.729s cpu time, 0.781s GC time
Loading theory "Draft.Simpl" (required by "Draft.SimplTemplates")
### theory "Draft.Simpl"
### 1.378s elapsed time, 1.479s cpu time, 0.132s GC time
Loading theory "Draft.SimplTemplates"
val templateLemmas =
   [("Simpl_Heap.new_not_Null", "finite ?A ==> new ?A ~= Null",
     template_implication
      ([template_predicate
         (template_app (template_hole 4, template_var 0))],
       template_negation
        (
           template_equation
            (template_app (template_hole 1, template_var 0),
             template_hole 0)
           ))),
    ("Simpl_Heap.new_notin", "finite ?A ==> new ?A ~: ?A",
     template_implication
      ([template_predicate
         (template_app (template_hole 3, template_var 0))],
       template_negation
        (
           template_predicate
            (
               template_app
                (template_app
                  (template_hole 1,
                   template_app (template_hole 0, template_var 0)),
                 template_var 0)
               )
           ))),
    ("Simpl_Heap.finite_nat_ex_max", "finite ?N ==> EX m. ALL n:?N. n < m",
     template_implication
      ([template_predicate
         (template_app (template_hole 3, template_var 0))],
       template_predicate (template_app (template_hole 2, t_empty))))]:
   (string * thm * template) list
### theory "Draft.SimplTemplates"
### 0.619s elapsed time, 0.831s cpu time, 0.087s GC time
val it = (): unit
