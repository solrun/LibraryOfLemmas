Loading theory "Auto2_HOL.HOL_Base" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms" via "Auto2_HOL.Logic_Thms" via "Auto2_HOL.Auto2_HOL")
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Library.Monad_Syntax")
Loading theory "HOL-Library.Cancellation" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms" via "Auto2_HOL.Set_Thms" via "HOL-Library.Multiset")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "Auto2_HOL.HOL_Base"
### 0.073s elapsed time, 0.326s cpu time, 0.000s GC time
Loading theory "Auto2_HOL.Auto2_HOL" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms" via "Auto2_HOL.Logic_Thms")
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.099s elapsed time, 0.435s cpu time, 0.000s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad")
### theory "HOL-Library.Monad_Syntax"
### 0.051s elapsed time, 0.189s cpu time, 0.024s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
### theory "HOL-Library.Function_Algebras"
### 0.152s elapsed time, 0.630s cpu time, 0.024s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Imperative_HOL.Heap" via "HOL-Library.Countable")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
signature BASIC_UTIL =
  sig
    val apply_to_lhs: conv -> thm -> thm
    val apply_to_rhs: conv -> thm -> thm
    val apply_to_thm: conv -> thm -> thm
    val assert: bool -> string -> unit
    val dest_arg: term -> term
    val dest_arg1: term -> term
    val filter_split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val fo_init: Type.tyenv * Envir.tenv
    val lookup_inst: Type.tyenv * Envir.tenv -> string -> term
    val lookup_instn: Type.tyenv * Envir.tenv -> string * int -> term
    val meta_sym: thm -> thm
    val propT: typ
    val the_pair: 'a list -> 'a * 'a
    val the_triple: 'a list -> 'a * 'a * 'a
    val trace_fullthm: Proof.context -> string -> thm -> unit
    val trace_fullthm_global: string -> thm -> unit
    val trace_t: Proof.context -> string -> term -> unit
    val trace_thm: Proof.context -> string -> thm -> unit
    val trace_thm_global: string -> thm -> unit
    val trace_tlist: Proof.context -> string -> term list -> unit
  end
signature UTIL =
  sig
    val all_pairs: 'a list * 'b list -> ('a * 'b) list
    val all_permutes: 'a list -> 'a list list
    val apply_to_lhs: conv -> thm -> thm
    val apply_to_rhs: conv -> thm -> thm
    val apply_to_thm: conv -> thm -> thm
    val arg_backn_conv: int -> conv -> conv
    val argn_conv: int -> conv -> conv
    val assert: bool -> string -> unit
    val assume_meta_eq: theory -> term * term -> thm
    val assume_thm: Proof.context -> term -> thm
    val comb_equiv: cterm * thm list -> thm
    val concl_conv: conv -> conv
    val concl_conv_n: int -> conv -> conv
    val cterm_pat_setup: theory -> theory
    val declare_free_term: term -> Proof.context -> Proof.context
    val defined_instn: Type.tyenv * Envir.tenv -> string * int -> bool
    val dest_arg: term -> term
    val dest_arg1: term -> term
    val dest_argn: int -> term -> term
    val dest_args: term -> term list
    val dest_binop: term -> term * (term * term)
    val dest_binop_args: term -> term * term
    val dest_binop_cargs: cterm -> cterm * cterm
    val dest_binop_head: term -> term
    val dest_cargs: cterm -> cterm list
    val eq_cong_th: int -> term -> term -> Proof.context -> thm
    val eq_env:
       (Type.tyenv * Envir.tenv) * (Type.tyenv * Envir.tenv) -> bool
    val exn_trace: (unit -> 'a) -> 'a
    val filter_split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val first_order_match_list:
       theory ->
         (term * term) list ->
           Type.tyenv * Envir.tenv -> Type.tyenv * Envir.tenv
    val fo_init: Type.tyenv * Envir.tenv
    val forall_elim_sch: thm -> thm
    val get_head_name: term -> string
    val has_subterm: term list -> term -> bool
    val has_vars: term -> bool
    val is_abs: term -> bool
    val is_head: term -> term -> bool
    val is_implies: term -> bool
    val is_just_internal: string -> bool
    val is_meta_eq: term -> bool
    val is_pattern: term -> bool
    val is_pattern_list: term list -> bool
    val is_prefix_str: string -> string -> bool
    val is_subseq: ('a * 'a -> bool) -> 'a list * 'a list -> bool
    val is_subterm: term -> term -> bool
    val lambda_abstract: term -> term -> term
    val lhs_of: thm -> term
    val list_meta_horn: term list * (term list * term) -> term
    val lookup_inst: Type.tyenv * Envir.tenv -> string -> term
    val lookup_instn: Type.tyenv * Envir.tenv -> string * int -> term
    val lookup_tyinst: Type.tyenv * Envir.tenv -> string -> typ
    val max: ('a * 'a -> order) -> 'a list -> 'a
    val max_partial: ('a -> 'a -> bool) -> 'a list -> 'a list
    val meta_sym: thm -> thm
    val name_of_thm: thm -> string
    val normalize_meta_all_imp: Proof.context -> conv
    val normalize_meta_horn: Proof.context -> conv
    val occurs_free: term -> term -> bool
    val occurs_frees: term list -> term -> bool
    val pattern_rewr_conv: term -> (term * thm) list -> conv
    val print_term_detail: Proof.context -> term -> string
    val propT: typ
    val remove_dup_lists:
       ('a * 'a -> order) -> 'a list * 'a list -> 'a list * 'a list
    val rename_abs_term: term list -> term -> term
    val repeat_n_conv: int -> conv -> conv
    val reverse_eta_conv: Proof.context -> conv
    val rhs_of: thm -> term
    val send_all_to_hyps: thm -> thm
    val send_first_to_hyps: thm -> thm
    val skip_n_conv: int -> conv -> conv
    val string_of_bool: bool -> string
    val string_of_env: Proof.context -> Envir.tenv -> string
    val string_of_list: ('a -> string) -> 'a list -> string
    val string_of_list': ('a -> string) -> 'a list -> string
    val string_of_terms: Proof.context -> term list -> string
    val string_of_terms_global: theory -> term list -> string
    val string_of_tyenv: Proof.context -> Type.tyenv -> string
    val strip_meta_horn: term -> term list * (term list * term)
    val subsets: 'a list -> 'a list list
    val subst_term_norm: Type.tyenv * Envir.tenv -> term -> term
    val subst_thm: Proof.context -> Type.tyenv * Envir.tenv -> thm -> thm
    val subst_thm_atomic: (cterm * cterm) list -> thm -> thm
    val subst_thm_thy: theory -> Type.tyenv * Envir.tenv -> thm -> thm
    val swap_meta_imp_alls: Proof.context -> conv
    val term_pat_setup: theory -> theory
    val test_conv:
       Proof.context -> conv -> string -> string * string -> unit
    val the_pair: 'a list -> 'a * 'a
    val the_triple: 'a list -> 'a * 'a * 'a
    val timer: string * (unit -> 'a) -> 'a
    val to_internal_vars:
       Proof.context -> term list * term -> term list * term
    val trace_fullthm: Proof.context -> string -> thm -> unit
    val trace_fullthm_global: string -> thm -> unit
    val trace_t: Proof.context -> string -> term -> unit
    val trace_thm: Proof.context -> string -> thm -> unit
    val trace_thm_global: string -> thm -> unit
    val trace_tlist: Proof.context -> string -> term list -> unit
    val transitive_list: thm list -> thm
    val type_pat_setup: theory -> theory
    val update_env:
       indexname * term ->
         Type.tyenv * Envir.tenv -> Type.tyenv * Envir.tenv
    val update_name_of_thm: thm -> string -> thm -> thm
  end
structure Util: UTIL
structure Basic_Util: BASIC_UTIL
val dest_arg1 = fn: term -> term
val trace_fullthm = fn: Proof.context -> string -> thm -> unit
val propT = "prop": typ
val apply_to_rhs = fn: conv -> thm -> thm
val lookup_instn = fn: Type.tyenv * Envir.tenv -> string * int -> term
val the_triple = fn: 'a list -> 'a * 'a * 'a
val filter_split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val trace_thm = fn: Proof.context -> string -> thm -> unit
val trace_tlist = fn: Proof.context -> string -> term list -> unit
val the_pair = fn: 'a list -> 'a * 'a
val apply_to_thm = fn: conv -> thm -> thm
val lookup_inst = fn: Type.tyenv * Envir.tenv -> string -> term
val apply_to_lhs = fn: conv -> thm -> thm
val trace_thm_global = fn: string -> thm -> unit
val trace_fullthm_global = fn: string -> thm -> unit
val assert = fn: bool -> string -> unit
val meta_sym = fn: thm -> thm
val trace_t = fn: Proof.context -> string -> term -> unit
val fo_init = ({}, {}): Type.tyenv * Envir.tenv
val dest_arg = fn: term -> term
signature BASIC_UTIL_BASE =
  sig
    val bFalse: term
    val bTrue: term
    val boolT: typ
    val cdest_eq: cterm -> cterm * cterm
    val dest_eq: term -> term * term
    val is_eq_term: term -> bool
    val mk_eq: term * term -> term
    val true_th: thm
  end
signature UTIL_BASE =
  sig
    val All_name: string
    val Ball_def_th: thm
    val Ball_name: string
    val Bex_def_th: thm
    val Bex_name: string
    val Conj_name: string
    val Disj_name: string
    val Ex_name: string
    val Imp_name: string
    val Mem_name: string
    val Not_name: string
    val Trueprop_name: string
    val all_trivial_th: thm
    val atomize_all_th: thm
    val atomize_conjL_th: thm
    val atomize_imp_th: thm
    val bFalse: term
    val bTrue: term
    val backward1_conv_th: thm
    val backward2_conv_th: thm
    val backward_conv_th: thm
    val boolT: typ
    val cConj: cterm
    val cDisj: cterm
    val cNot: cterm
    val cTrueprop: cterm
    val case_split_th: thm
    val cdest_eq: cterm -> cterm * cterm
    val conjI_th: thm
    val conj_assoc_th: thm
    val conj_commute_th: thm
    val conjunct1_th: thm
    val conjunct2_th: thm
    val contra_triv_th: thm
    val de_Morgan_conj_th: thm
    val de_Morgan_disj_th: thm
    val dest_eq: term -> term * term
    val disj_True1_th: thm
    val disj_True2_th: thm
    val disj_assoc_th: thm
    val disj_commute_th: thm
    val eq_True_inv_th: thm
    val eq_True_th: thm
    val exE_th': thm
    val ex_vardef_th: thm
    val iffD1_th: thm
    val iffD2_th: thm
    val iffD_th: thm
    val imp_conv_disj_th: thm
    val inv_back_th: thm
    val is_eq_term: term -> bool
    val is_if: term -> bool
    val mk_eq: term * term -> term
    val mk_setT: typ -> typ
    val nn_cancel_th: thm
    val nn_create_th: thm
    val not_all_th: thm
    val not_ex_th: thm
    val not_imp_th: thm
    val obj_sym_cv: conv
    val or_cancel1_th: thm
    val or_cancel2_th: thm
    val or_intro1_th: thm
    val or_intro2_th: thm
    val resolve_conv_th: thm
    val swap_all_disj_th: thm
    val swap_ex_conj_th: thm
    val sym_th: thm
    val to_contra_form_th: thm
    val to_contra_form_th': thm
    val to_meta_eq_cv: conv
    val to_obj_eq_cv: conv
    val to_obj_eq_iff: thm -> thm
    val true_th: thm
  end
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
structure UtilBase: UTIL_BASE
structure Basic_UtilBase: BASIC_UTIL_BASE
val true_th = "True": thm
val cdest_eq = fn: cterm -> cterm * cterm
val boolT = "bool": typ
val bTrue = Const ("HOL.True", "bool"): term
val is_eq_term = fn: term -> bool
val bFalse = Const ("HOL.False", "bool"): term
val mk_eq = fn: term * term -> term
val dest_eq = fn: term -> term * term
Found termination order: "size_list size <*mlex*> {}"
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.477s elapsed time, 1.906s cpu time, 0.132s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms" via "Auto2_HOL.Set_Thms")
### theory "HOL-Library.Nat_Bijection"
### 0.370s elapsed time, 1.448s cpu time, 0.108s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.ExtrEqs")
signature BASIC_UTIL_LOGIC =
  sig
    val Not: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val apply_to_thm': conv -> thm -> thm
    val assume_eq: theory -> term * term -> thm
    val concl_of': thm -> term
    val conj: term
    val conj_left_th: thm -> thm
    val conj_right_th: thm -> thm
    val cprop_of': thm -> cterm
    val dest_Trueprop: term -> term
    val dest_imp: term -> term * term
    val dest_not: term -> term
    val disj: term
    val equiv_backward_th: thm -> thm
    val equiv_forward_th: thm -> thm
    val get_neg: term -> term
    val get_neg': term -> term
    val imp: term
    val inv_backward_th: thm -> thm
    val is_Trueprop: term -> bool
    val is_ball: term -> bool
    val is_bex: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_ex: term -> bool
    val is_imp: term -> bool
    val is_mem: term -> bool
    val is_neg: term -> bool
    val is_obj_all: term -> bool
    val is_true_th: thm -> bool
    val list_conj: term list -> term
    val list_disj: term list -> term
    val list_obj_imp: term list * term -> term
    val make_trueprop_eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_conj: term * term -> term
    val mk_disj: term * term -> term
    val mk_exists: term -> term -> term
    val mk_imp: term * term -> term
    val mk_mem: term * term -> term
    val mk_not: term -> term
    val mk_obj_all: term -> term -> term
    val obj_sym: thm -> thm
    val obj_sym_th: thm -> thm
    val pFalse: term
    val prop_of': thm -> term
    val rewr_obj_eq: thm -> conv
    val strip_conj: term -> term list
    val strip_disj: term -> term list
    val strip_obj_imp: term -> term list * term
    val to_meta_eq: thm -> thm
    val to_obj_eq: thm -> thm
    val to_obj_eq_iff_th: thm -> thm
    val to_obj_eq_th: thm -> thm
  end
signature UTIL_LOGIC =
  sig
    val Not: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val apply_to_thm': conv -> thm -> thm
    val assume_eq: theory -> term * term -> thm
    val bool_of_term: term -> bool
    val concl_of': thm -> term
    val conj: term
    val conj_left_th: thm -> thm
    val conj_right_th: thm -> thm
    val contra_by_tac:
       (Proof.context -> int -> tactic) -> Proof.context -> thm list -> thm
    val cprop_of': thm -> cterm
    val dest_Trueprop: term -> term
    val dest_imp: term -> term * term
    val dest_not: term -> term
    val disj: term
    val equiv_backward_th: thm -> thm
    val equiv_forward_th: thm -> thm
    val ex_elim: Proof.context -> term -> thm -> thm
    val force_abs_form: term -> term
    val get_all_subterms: term -> term list
    val get_all_subterms_skip_if: term -> term list
    val get_cneg: cterm -> cterm
    val get_neg: term -> term
    val get_neg': term -> term
    val imp: term
    val inv_backward_th: thm -> thm
    val is_Trueprop: term -> bool
    val is_ball: term -> bool
    val is_bex: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_ex: term -> bool
    val is_ex_form_gen: term -> bool
    val is_imp: term -> bool
    val is_mem: term -> bool
    val is_neg: term -> bool
    val is_obj_all: term -> bool
    val is_true_th: thm -> bool
    val list_conj: term list -> term
    val list_disj: term list -> term
    val list_obj_horn: term list * (term list * term) -> term
    val list_obj_imp: term list * term -> term
    val list_subterms: term -> term list
    val make_neg_eq: thm -> thm
    val make_trueprop_eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_conj: term * term -> term
    val mk_conjs_th: thm list -> thm
    val mk_disj: term * term -> term
    val mk_exists: term -> term -> term
    val mk_imp: term * term -> term
    val mk_mem: term * term -> term
    val mk_not: term -> term
    val mk_obj_all: term -> term -> term
    val normalize_exists: Proof.context -> conv
    val obj_sym: thm -> thm
    val obj_sym_th: thm -> thm
    val pFalse: term
    val prop_of': thm -> term
    val prove_by_tac:
       (Proof.context -> int -> tactic) ->
         Proof.context -> thm list -> term -> thm
    val rewr_obj_eq: thm -> conv
    val rewrite_from_contra_form: conv
    val rewrite_to_contra_form: conv
    val split_conj_gen_th: thm -> thm list
    val split_conj_th: thm -> thm list
    val split_not_disj_th: thm -> thm list
    val strip_conj: term -> term list
    val strip_disj: term -> term list
    val strip_exists: term -> term list * term
    val strip_horn': thm -> term list * term
    val strip_obj_horn: term -> term list * (term list * term)
    val strip_obj_imp: term -> term list * term
    val term_of_bool: bool -> term
    val to_meta_conv: Proof.context -> conv
    val to_meta_eq: thm -> thm
    val to_obj_conv: Proof.context -> conv
    val to_obj_conv_on_horn: Proof.context -> conv
    val to_obj_eq: thm -> thm
    val to_obj_eq_iff_th: thm -> thm
    val to_obj_eq_th: thm -> thm
  end
structure UtilLogic: UTIL_LOGIC
structure Basic_UtilLogic: BASIC_UTIL_LOGIC
val mk_obj_all = fn: term -> term -> term
val dest_not = fn: term -> term
val mk_mem = fn: term * term -> term
val apply_to_thm' = fn: conv -> thm -> thm
val mk_not = fn: term -> term
val is_true_th = fn: thm -> bool
val is_ex = fn: term -> bool
val list_conj = fn: term list -> term
val prop_of' = fn: thm -> term
val inv_backward_th = fn: thm -> thm
val assume_eq = fn: theory -> term * term -> thm
val equiv_forward_th = fn: thm -> thm
val dest_imp = fn: term -> term * term
val concl_of' = fn: thm -> term
val mk_imp = fn: term * term -> term
val strip_disj = fn: term -> term list
val pFalse =
   Const ("HOL.Trueprop", "bool => prop") $ Const ("HOL.False", "bool"):
   term
val cprop_of' = fn: thm -> cterm
val Trueprop = Const ("HOL.Trueprop", "bool => prop"): term
val strip_conj = fn: term -> term list
val mk_conj = fn: term * term -> term
val mk_Trueprop = fn: term -> term
val rewr_obj_eq = fn: thm -> conv
val disj = Const ("HOL.disj", "bool => bool => bool"): term
val strip_obj_imp = fn: term -> term list * term
val to_obj_eq = fn: thm -> thm
val Trueprop_conv = fn: conv -> conv
val imp = Const ("HOL.implies", "bool => bool => bool"): term
val is_neg = fn: term -> bool
val dest_Trueprop = fn: term -> term
val make_trueprop_eq = fn: thm -> thm
val is_bex = fn: term -> bool
val conj_left_th = fn: thm -> thm
val is_ball = fn: term -> bool
val is_disj = fn: term -> bool
val obj_sym_th = fn: thm -> thm
val is_obj_all = fn: term -> bool
val list_obj_imp = fn: term list * term -> term
val to_obj_eq_iff_th = fn: thm -> thm
val equiv_backward_th = fn: thm -> thm
val is_mem = fn: term -> bool
val Not = Const ("HOL.Not", "bool => bool"): term
val to_meta_eq = fn: thm -> thm
val get_neg = fn: term -> term
val conj = Const ("HOL.conj", "bool => bool => bool"): term
val to_obj_eq_th = fn: thm -> thm
val mk_exists = fn: term -> term -> term
val conj_right_th = fn: thm -> thm
val is_imp = fn: term -> bool
val obj_sym = fn: thm -> thm
val list_disj = fn: term list -> term
val mk_disj = fn: term * term -> term
val is_conj = fn: term -> bool
val is_Trueprop = fn: term -> bool
val get_neg' = fn: term -> term
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.394s elapsed time, 1.541s cpu time, 0.108s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
signature BOXID =
  sig
    val add_incr_id: box_id -> box_id
    val add_prim_id: box_id -> Proof.context -> int * Proof.context
    val add_resolved: box_id -> Proof.context -> Proof.context
    type box_id
    type box_lattice
    val get_all_merges: Proof.context -> box_id list list -> box_id list
    val get_all_merges_info:
       Proof.context -> (box_id * 'a) list list -> (box_id * 'a list) list
    val get_ancestors_prim: Proof.context -> box_id -> int list
    val get_parent_at_i: Proof.context -> box_id -> int -> box_id
    val get_parent_prim: Proof.context -> int -> box_id
    val has_incr_id: box_id -> bool
    val home_id: int
    val id_is_eq_ancestor:
       Proof.context -> box_id * 'a -> box_id * 'a -> bool
    val info_eq_better:
       Proof.context -> box_id * thm -> box_id * thm -> bool
    val is_box_resolved: Proof.context -> box_id -> bool
    val is_box_unresolved: Proof.context -> box_id -> bool
    val is_eq_ancestor: Proof.context -> box_id -> box_id -> bool
    val is_eq_descendent: Proof.context -> box_id -> box_id -> bool
    val merge_box_with_info:
       Proof.context -> box_id -> (box_id * 'a) list -> (box_id * 'a) list
    val merge_boxes: Proof.context -> box_id * box_id -> box_id
    val merge_eq_infos:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val reduce_box_id: Proof.context -> int list -> box_id
    val replace_incr_id: box_id -> box_id
    val string_of_box_id: box_id -> string
  end
type box_id = ?.BoxID.box_id
type id_inst = box_id * (Type.tyenv * Envir.tenv)
type id_inst_th = id_inst * thm
type id_inst_ths = id_inst * thm list
structure BoxID: BOXID
structure Boxidtab: TABLE
signature CONSTS =
  sig
    val add_const_data: string * (term -> bool) -> theory -> theory
    val detect_const: theory -> term -> string option
    val detect_const_ctxt: Proof.context -> term -> string option
    val is_const: theory -> term -> bool
    val is_const_ctxt: Proof.context -> term -> bool
    val neq_const: theory -> term * term -> bool
    val neq_const_ctxt: Proof.context -> term * term -> bool
  end
structure Consts: CONSTS
signature PROPERTY =
  sig
    val add_property_field_const: term -> theory -> theory
    val add_property_update: thm -> theory -> theory
    val can_add_property_update: thm -> theory -> bool
    val get_property_arg: term -> term
    val get_property_arg_th: thm -> cterm
    val get_property_name: term -> string
    val get_property_names: term list -> string list
    val instantiate_property_update:
       Proof.context -> term -> thm -> thm option
    val is_property: term -> bool
    val is_property_field: theory -> term -> bool
    val is_property_prem: theory -> term -> bool
    val lookup_property_update: theory -> string -> thm list
    val lookup_property_update_fun: theory -> string -> thm list
    val strip_property_field: theory -> term -> term list
  end
structure Property: PROPERTY
val add_property_field_const = fn: term -> theory -> theory
signature WELLFORM =
  sig
    val is_subterm_wellform_data:
       theory -> term -> term list -> (term * term) option
    val is_subterm_wellform_data':
       theory -> term -> term -> (term * term) option
    val lookup_wellform_data: theory -> term -> term list
    val lookup_wellform_pattern:
       theory -> term * term -> (term * term) option
    val register_wellform_data: string * string list -> theory -> theory
  end
structure WellForm: WELLFORM
val register_wellform_data = fn: string * string list -> theory -> theory
infix 1 then_wfconv
infix 0 else_wfconv
datatype wfterm = WfComb of cterm * wfterm list * thm list | WfTerm of cterm
type wfconv = wfterm -> wfterm * thm
signature WFTERM =
  sig
    val all_conv: wfconv
    val arg1_conv: wfconv -> wfconv
    val arg_conv: wfconv -> wfconv
    val argn_conv: int -> wfconv -> wfconv
    val binop_conv: wfconv -> wfconv
    val conv_of: conv -> wfconv
    val cterm_of: wfterm -> cterm
    val cterm_to_wfterm_assume: term list -> cterm -> wfterm
    val cterm_to_wfterm_on_ths: thm list -> term list -> cterm -> wfterm
    val else_wfconv: wfconv * wfconv -> wfconv
    val every_conv: wfconv list -> wfconv
    val find_target_on_ths: thm list -> term -> thm
    val first_conv: wfconv list -> wfconv
    val no_conv: wfconv
    val repeat_conv: wfconv -> wfconv
    val rewr_obj_eq: term list -> thm -> wfconv
    val rewrite_on_eqs: term list -> (wfterm * thm) list -> wfconv
    val string_of_wfterm: Proof.context -> wfterm -> string
    val strip_comb: wfterm -> cterm * wfterm list
    val term_of: wfterm -> term
    val test_wfconv:
       Proof.context ->
         term list -> wfconv -> string -> string * string -> unit
    val then_wfconv: wfconv * wfconv -> wfconv
    val theory_of_wft: wfterm -> theory
    val try_conv: wfconv -> wfconv
    val wellform_ths_of: wfterm -> thm list
  end
constructor WfComb: cterm * wfterm list * thm list -> wfterm
constructor WfTerm: cterm -> wfterm
structure WfTerm: WFTERM
val then_wfconv = fn: wfconv * wfconv -> wfconv
val else_wfconv = fn: wfconv * wfconv -> wfconv
### theory "HOL-Library.Set_Algebras"
### 0.248s elapsed time, 0.977s cpu time, 0.132s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
type rewrite_table =
   {all_equiv: (box_id * thm) list Termtab.table,
    contain: cterm list Termtab.table,
    equiv: (box_id * thm) list Termtab.table,
    reps: (box_id * thm) list Termtab.table,
    simp: (box_id * thm) list Termtab.table,
    subsimp: (box_id * thm) list Termtab.table,
    terms: (box_id list * cterm) Termtab.table}
signature REWRITE_TABLE =
  sig
    val add_contain: cterm -> term -> Proof.context -> Proof.context
    val add_equiv: box_id * thm -> Proof.context -> Proof.context
    val add_rewrite:
       box_id * thm -> Proof.context -> (box_id * thm) list * Proof.context
    val add_rewrite_raw: box_id -> thm -> Proof.context -> Proof.context
    val add_term:
       box_id * cterm ->
         Proof.context -> (box_id * thm) list * Proof.context
    val add_term_list:
       (box_id * cterm) list ->
         Proof.context -> (box_id * thm) list * Proof.context
    val add_term_raw: box_id * cterm -> Proof.context -> Proof.context
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val complete_table: Proof.context -> (box_id * thm) list * Proof.context
    val equiv_info:
       Proof.context -> box_id -> cterm * cterm -> (box_id * thm) list
    val equiv_info_t:
       Proof.context -> box_id -> term * term -> (box_id * thm) list
    val equiv_neighs: Proof.context -> term -> (box_id * thm) list
    val get_all_equiv: Proof.context -> term -> (box_id * thm) list
    val get_all_id_terms: Proof.context -> (box_id * cterm) list
    val get_all_terms: Proof.context -> cterm list
    val get_cached_subterm_rewrite: box_id -> Proof.context -> cterm -> thm
    val get_cached_subterm_rewrite_info:
       Proof.context -> term -> (box_id * thm) list
    val get_head_equiv: Proof.context -> cterm -> (box_id * thm) list
    val get_head_equiv_with_t:
       Proof.context -> box_id * cterm -> term -> (box_id * thm) list
    val get_head_rep: box_id -> Proof.context -> term -> thm option
    val get_head_rep_info: Proof.context -> term -> (box_id * thm) list
    val get_head_rep_with_id_th:
       Proof.context -> box_id * thm -> (box_id * thm) list
    val get_new_terms:
       Proof.context * Proof.context -> (box_id * cterm) list
    val get_reachable_terms: bool -> Proof.context -> term list -> term list
    val get_rewrite: box_id -> Proof.context -> cterm -> thm
    val get_rewrite_info: Proof.context -> cterm -> (box_id * thm) list
    val get_subterm_rewrite_info:
       Proof.context -> cterm -> (box_id * thm) list
    val head_simplify: box_id -> Proof.context -> cterm -> thm
    val immediate_contains: Proof.context -> term -> cterm list
    val in_table_raw: Proof.context -> term -> bool
    val in_table_raw_for_id: Proof.context -> box_id * term -> bool
    val in_table_raw_ids: Proof.context -> term -> box_id list
    val is_equiv: box_id -> Proof.context -> cterm * cterm -> bool
    val is_equiv_t: box_id -> Proof.context -> term * term -> bool
    val process_update_simp:
       (box_id * thm) list -> Proof.context -> Proof.context
    val remove_rep: box_id * thm -> Proof.context -> Proof.context
    val simp_val: box_id -> Proof.context -> cterm -> cterm
    val simp_val_t: box_id -> Proof.context -> term -> term
    val simplify: box_id -> Proof.context -> cterm -> thm
    val simplify_info: Proof.context -> cterm -> (box_id * thm) list
    val subequiv_info:
       Proof.context -> box_id -> cterm * cterm -> (box_id * thm) list
    val subterm_simplify: box_id -> Proof.context -> cterm -> thm
    val subterm_simplify_info: Proof.context -> cterm -> (box_id * thm) list
    val update_simp: box_id * thm -> Proof.context -> Proof.context
    val update_subsimp: box_id * thm -> Proof.context -> Proof.context
  end
val simp_ord = fn: thm * thm -> order
val eq_info = fn: (''a * thm) * (''a * thm) -> bool
val print_info = fn: Proof.context -> BoxID.box_id * thm -> string
val print_infos = fn: Proof.context -> (BoxID.box_id * thm) list -> string
val print_info' = fn: Proof.context -> BoxID.box_id * thm list -> string
val print_infos' = fn:
   Proof.context -> (BoxID.box_id * thm list) list -> string
structure RewriteTable: REWRITE_TABLE
  Proving monotonicity ...
signature PROPERTY_DATA =
  sig
    val add_property: box_id * thm -> Proof.context -> Proof.context
    val add_property_raw: box_id * thm -> Proof.context -> Proof.context
    val apply_property_update_on_term:
       Proof.context -> box_id -> term -> (box_id * thm) list
    val apply_property_update_rule:
       Proof.context -> box_id -> thm option -> (box_id * thm) list
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val convert_property:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val get_new_property: Proof.context -> (box_id * thm) list
    val get_property: Proof.context -> box_id * cterm -> (box_id * thm) list
    val get_property_for_term: Proof.context -> term -> (box_id * thm) list
    val get_property_t:
       Proof.context -> box_id * term -> (box_id * thm) list
    val process_rewrite_property:
       box_id * thm -> Proof.context -> Proof.context
    val process_update_property:
       (box_id * thm) list -> Proof.context -> Proof.context
  end
structure PropertyData: PROPERTY_DATA
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
signature MATCHER =
  sig
    val check_type: theory -> typ * typ -> id_inst -> id_inst option
    val check_type_term:
       theory -> term * term -> id_inst -> (id_inst * term) option
    val match:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_all_head:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_comb:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_head:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_list:
       Proof.context ->
         term list -> term list * cterm list -> id_inst -> id_inst_ths list
    val pre_match: Proof.context -> term * cterm -> bool
    val pre_match_all_head: Proof.context -> term * cterm -> bool
    val pre_match_comb: Proof.context -> term * cterm -> bool
    val pre_match_head: Proof.context -> term * cterm -> bool
    val pre_match_head': Proof.context -> term * cterm -> bool
    val pre_match_type: Proof.context -> typ * typ -> bool
    val rewrite_match:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val rewrite_match_head:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val rewrite_match_list:
       Proof.context ->
         (bool * (term * cterm)) list -> id_inst -> id_inst_ths list
    val rewrite_match_subset:
       Proof.context ->
         term list -> term list * cterm list -> id_inst -> id_inst_ths list
    val update_inst:
       term list -> indexname -> cterm -> id_inst -> id_inst_th list
  end
structure Matcher: MATCHER
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
datatype raw_item
= Fact of string * term list * thm | Handler of term list * term * thm
type box_item =
   {id: box_id,
    prop: thm, sc: int, tname: cterm list, ty_str: string, uid: int}
signature BOXITEM =
  sig
    val dest_handler_raw: raw_item -> term list * term * thm
    val eq_item: box_item * box_item -> bool
    val eq_ritem: raw_item * raw_item -> bool
    val get_thm_raw: raw_item -> thm
    val get_tname_raw: raw_item -> term list
    val instantiate: (cterm * cterm) list -> raw_item -> raw_item
    val is_fact_raw: raw_item -> bool
    val is_handler_raw: raw_item -> bool
    val item_replace_incr: box_item -> box_item
    val item_with_id: box_id -> box_item -> box_item
    val item_with_incr: box_item -> box_item
    val match_ty_str: string -> box_item -> bool
    val match_ty_str_raw: string -> raw_item -> bool
    val match_ty_strs: string list -> box_item -> bool
    val match_ty_strs_raw: string list -> raw_item -> bool
    val merged_id: Proof.context -> box_item list -> box_id
    val mk_box_item:
       Proof.context -> int * box_id * int * raw_item -> box_item
    val null_item: box_item
    val obtain_variant_frees:
       Proof.context * raw_item list -> Proof.context * (cterm * cterm) list
    val term_to_fact: term -> raw_item
    val var_to_fact: term -> raw_item
  end
val TY_NULL = "NULL": string
val TY_EQ = "EQ": string
val TY_VAR = "VAR": string
val TY_PROP = "PROP": string
val TY_TERM = "TERM": string
val TY_PROPERTY = "PROPERTY": string
constructor Fact: string * term list * thm -> raw_item
constructor Handler: term list * term * thm -> raw_item
type item_matcher =
   {match: term -> box_item -> Proof.context -> id_inst -> id_inst_th list,
    pre_match: term -> box_item -> Proof.context -> bool}
type item_output = Proof.context -> term list * thm -> string
type item_io_info =
   {output_fn: (item_output * serial) option,
    prop_matchers: (item_matcher * serial) list,
    shadow_fn:
    ((Proof.context -> box_id -> term list * cterm list -> bool) * serial)
    option
    ,
    term_fn: ((term list -> term list) * serial) option,
    typed_matchers: (item_matcher * serial) list}
datatype match_arg
=
     PropMatch of term
   | PropertyMatch of term
   | TypedMatch of string * term
   | TypedUniv of string
   | WellFormMatch of term * term
type prfstep_filter = Proof.context -> id_inst -> bool
signature ITEM_IO =
  sig
    val add_basic_item_io: theory -> theory
    val add_item_type:
       string * (term list -> term list) option * item_output option *
       (Proof.context -> box_id -> term list * cterm list -> bool) option
         -> theory -> theory
    val add_prop_matcher: string * item_matcher -> theory -> theory
    val add_typed_matcher: string * item_matcher -> theory -> theory
    val assert_valid_arg: match_arg -> unit
    val check_ty_str: string -> match_arg -> bool
    val eq_tname_typed_matcher: item_matcher
    val get_io_info: theory -> string -> item_io_info
    val get_prop_matchers: theory -> string -> item_matcher list
    val get_typed_matchers: theory -> string -> item_matcher list
    val is_ordinary_match: match_arg -> bool
    val is_side_match: match_arg -> bool
    val match_arg:
       Proof.context -> match_arg -> box_item -> id_inst -> id_inst_th list
    val no_rewr_terms: term list -> term list
    val null_eq_matcher: item_matcher
    val null_property_matcher: item_matcher
    val output_prop_fn: item_output
    val pat_of_match_arg: match_arg -> term
    val pre_match_arg: Proof.context -> match_arg -> box_item -> bool
    val prop_matcher: item_matcher
    val rewr_terms_of_item: Proof.context -> string * term list -> term list
    val string_of_item: Proof.context -> box_item -> string
    val string_of_item_info:
       Proof.context -> string * term list * thm -> string
    val string_of_raw_item: Proof.context -> raw_item -> string
    val subst_arg: Type.tyenv * Envir.tenv -> match_arg -> match_arg
    val term_prop_matcher: item_matcher
    val term_property_matcher: item_matcher
    val term_typed_matcher: item_matcher
    val trace_item: Proof.context -> string -> box_item -> unit
    val trace_items: Proof.context -> string -> box_item list -> unit
    val trace_ritem: Proof.context -> string -> raw_item -> unit
    val trace_ritems: Proof.context -> string -> raw_item list -> unit
  end
structure BoxItem: BOXITEM
constructor PropMatch: term -> match_arg
constructor PropertyMatch: term -> match_arg
constructor TypedMatch: string * term -> match_arg
constructor TypedUniv: string -> match_arg
constructor WellFormMatch: term * term -> match_arg
structure ItemIO: ITEM_IO
consts
  flat :: "'a list stream => 'a stream"
signature WELLFORM_DATA =
  sig
    val add_wellform_data_raw:
       term * (box_id * thm) -> Proof.context -> Proof.context
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val complete_wellform_data:
       box_item list -> Proof.context -> Proof.context
    val complete_wellform_data_for_terms:
       box_item list -> term list -> Proof.context -> Proof.context
    val convert_wellform:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val cterm_to_wfterm:
       Proof.context ->
         term list -> box_id * cterm -> (box_id * wfterm) list
    val find_fact:
       Proof.context ->
         box_item list -> box_id * cterm -> (box_id * thm) list
    val get_complete_wellform:
       Proof.context -> box_id * cterm -> (box_id * thm list) list
    val get_head_equiv:
       Proof.context ->
         term list -> box_id * cterm -> (box_id * (wfterm * thm)) list
    val get_new_wellform_data: Proof.context -> (term * (box_id * thm)) list
    val get_wellform: Proof.context -> box_id * cterm -> (box_id * thm) list
    val get_wellform_for_term:
       Proof.context -> term -> (cterm * (box_id * thm) list) list
    val get_wellform_infos_for_term:
       Proof.context -> term -> (box_id * thm) list
    val get_wellform_t:
       Proof.context -> box_id * term -> (box_id * thm) list
    val initialize_wellform_data: term -> Proof.context -> Proof.context
    val simplify:
       Proof.context ->
         term list ->
           cterm list -> box_id * wfterm -> (box_id * (wfterm * thm)) list
    val simplify_info:
       Proof.context -> term list -> cterm -> (box_id * (wfterm * thm)) list
    val term_to_wfterm:
       Proof.context -> term list -> box_id * term -> (box_id * wfterm) list
  end
structure WellformData: WELLFORM_DATA
consts
  left :: "'a tree => 'a tree"
signature AUTO2_DATA =
  sig
    val add_terms:
       box_item list ->
         (box_id * cterm) list -> Proof.context -> Proof.context
    val get_incr_type:
       box_item list -> box_item list -> Proof.context -> Proof.context
    val get_single_type: Proof.context -> Proof.context
    val relevant_terms_single: box_item -> term list
  end
structure Auto2Data: AUTO2_DATA
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  right :: "'a tree => 'a tree"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "size <*mlex*> {}"
datatype raw_update
=
     AddBoxes of {id: box_id, init_assum: term, sc: int option}
   | AddItems of {id: box_id, raw_items: raw_item list, sc: int option}
   | ResolveBox of {id: box_id, th: thm}
   | ShadowItem of {id: box_id, item: box_item}
type update =
   {prfstep_name: string,
    raw_updt: raw_update, sc: int, source: box_item list}
signature UPDATE =
  sig
    val apply_exists_ritems: Proof.context -> thm -> raw_item list * thm
    val replace_id_of_update: raw_update -> raw_update
    val source_info: update -> string
    val string_of_raw_update: Proof.context -> raw_update -> string
    val target_of_update: raw_update -> box_id
    val thm_to_ritem: thm -> raw_item
    val thm_update: box_id * thm -> raw_update
    val thm_update_sc: int -> box_id * thm -> raw_update
    val update_info: Proof.context -> box_id -> raw_item list -> string
  end
constructor AddBoxes:
   {id: box_id, init_assum: term, sc: int option} -> raw_update
constructor AddItems:
   {id: box_id, raw_items: raw_item list, sc: int option} -> raw_update
constructor ResolveBox: {id: box_id, th: thm} -> raw_update
constructor ShadowItem: {id: box_id, item: box_item} -> raw_update
type status =
   {assums: term list,
    ctxt: Proof.context,
    handlers: (box_id * (term list * term * thm)) list,
    items: (box_item * box_id list) Inttab.table,
    queue: Updates_Heap.T, resolve_th: thm option}
signature STATUS =
  sig
    val add_handler: box_id * (term list * term * thm) -> status -> status
    val add_item: box_item -> status -> status
    val add_prim_box: box_id -> term -> status -> int * status
    val add_resolved: box_id -> status -> status
    val add_shadowed: box_id * box_item -> status -> status
    val add_to_queue: update -> status -> status
    val clear_incr: status -> status
    val delmin_from_queue: status -> status
    val empty_status: Proof.context -> status
    val find_fact: status -> box_id -> term -> thm option
    val find_prim_box: status -> box_id -> term -> int option
    val find_ritem_exact: status -> box_id -> raw_item -> bool
    val get_all_items_at_id: status -> box_id -> box_item list
    val get_handlers: status -> (box_id * (term list * term * thm)) list
    val get_init_assum: status -> int -> term
    val get_init_assums: status -> box_id -> term list
    val get_items: status -> box_item list
    val get_num_items: status -> int
    val get_on_resolve: status -> box_id -> int -> thm -> thm
    val get_resolve_th: status -> thm
    val invoke_handler:
       Proof.context -> term list * term * thm -> thm -> thm
    val lookup_item: status -> int -> (box_item * box_id list) option
    val map_context: (Proof.context -> Proof.context) -> status -> status
    val map_queue: (Updates_Heap.T -> Updates_Heap.T) -> status -> status
    val query_removed: status -> box_item -> bool
    val query_shadowed: status -> box_id -> box_item -> bool
    val set_resolve_th: thm -> status -> status
  end
structure Update: UPDATE
structure Updates_Heap: HEAP
structure Status: STATUS
### theory "HOL-Library.Stream"
### 1.163s elapsed time, 4.411s cpu time, 0.820s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Imperative_HOL.Heap")
Found termination order: "size <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
signature NORMALIZER =
  sig
    val add_inj_struct_data: thm -> theory -> theory
    val add_normalizer: string * normalizer -> theory -> theory
    val add_rewr_normalizer: string * thm -> theory -> theory
    val add_th_normalizer:
       string * (Proof.context -> thm -> thm list) -> theory -> theory
    val def_subst: (term * term) list -> term -> term
    val get_normalizers: theory -> (string * normalizer) list
    val is_def_eq: theory -> term -> bool
    val meta_use_vardef: thm -> (term * term) list * thm
    val meta_use_vardefs: thm -> (term * term) list * thm
    val normalize: Proof.context -> raw_item -> raw_item list
    val normalize_keep: Proof.context -> raw_item -> raw_item list
    type normalizer = Proof.context -> raw_item -> raw_item list
    val swap_eq_to_front: conv
  end
structure Normalizer: NORMALIZER
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
datatype proofstep_fn
=
     OneStep of Proof.context -> box_item -> raw_update list
   | TwoStep of Proof.context -> box_item -> box_item -> raw_update list
type proofstep = {args: match_arg list, func: proofstep_fn, name: string}
datatype prfstep_descriptor
=
     CreateCase of term
   | CreateConcl of term
   | Filter of prfstep_filter
   | GetFact of term * thm
   | ShadowFirst
   | ShadowSecond
   | WithFact of term
   | WithItem of string * term
   | WithProperty of term
   | WithScore of int
   | WithWellForm of term * term
signature PROOFSTEP =
  sig
    val WithGoal: term -> prfstep_descriptor
    val WithProp: term -> prfstep_descriptor
    val WithTerm: term -> prfstep_descriptor
    val all_insts: prfstep_filter
    val apply_pat_r: Proof.context -> id_inst_ths -> term * thm -> thm
    val apply_prfstep:
       Proof.context -> box_item list -> proofstep -> raw_update list
    val eq_prfstep: proofstep * proofstep -> bool
    val gen_prfstep: string -> prfstep_descriptor list -> proofstep
    val get_side_ths:
       Proof.context ->
         id_inst -> match_arg list -> (box_id * thm list) list
    val neq_filter: term -> prfstep_filter
    val not_type_filter: string -> typ -> prfstep_filter
    val order_filter: string -> string -> prfstep_filter
    val prfstep_conv: string -> prfstep_descriptor list -> conv -> proofstep
    val prfstep_custom:
       string ->
         prfstep_descriptor list ->
           (id_inst_ths ->
              box_item list -> Proof.context -> raw_update list)
             -> proofstep
    val prfstep_pre_conv:
       string ->
         prfstep_descriptor list -> (Proof.context -> conv) -> proofstep
    val retrieve_args: prfstep_descriptor list -> match_arg list
    val retrieve_cases: prfstep_descriptor list -> term list
    val retrieve_filts: prfstep_descriptor list -> prfstep_filter
    val retrieve_pats_r: prfstep_descriptor list -> (term * thm) list
    val retrieve_shadows: prfstep_descriptor list -> int list
    val size1_filter: string -> prfstep_filter
    val string_of_desc: theory -> prfstep_descriptor -> string
    val string_of_descs: theory -> prfstep_descriptor list -> string
  end
constructor OneStep:
   (Proof.context -> box_item -> raw_update list) -> proofstep_fn
constructor TwoStep:
   (Proof.context -> box_item -> box_item -> raw_update list) ->
     proofstep_fn
constructor CreateCase: term -> prfstep_descriptor
constructor CreateConcl: term -> prfstep_descriptor
constructor Filter: prfstep_filter -> prfstep_descriptor
constructor GetFact: term * thm -> prfstep_descriptor
constructor ShadowFirst: prfstep_descriptor
constructor ShadowSecond: prfstep_descriptor
constructor WithFact: term -> prfstep_descriptor
constructor WithItem: string * term -> prfstep_descriptor
constructor WithProperty: term -> prfstep_descriptor
constructor WithScore: int -> prfstep_descriptor
constructor WithWellForm: term * term -> prfstep_descriptor
signature PROOFSTEP_DATA =
  sig
    val add_backward1_prfstep: thm -> theory -> theory
    val add_backward1_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_backward2_prfstep: thm -> theory -> theory
    val add_backward2_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_backward_prfstep: thm -> theory -> theory
    val add_backward_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward'_prfstep: thm -> theory -> theory
    val add_forward'_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward_prfstep: thm -> theory -> theory
    val add_forward_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_gen_prfstep:
       string * prfstep_descriptor list -> theory -> theory
    val add_prfstep: proofstep -> theory -> theory
    val add_prfstep_check_req: string * string -> theory -> theory
    val add_prfstep_conv:
       string * prfstep_descriptor list * conv -> theory -> theory
    val add_prfstep_custom:
       string * prfstep_descriptor list *
       (id_inst_ths -> box_item list -> Proof.context -> raw_update list)
         -> theory -> theory
    val add_prfstep_pre_conv:
       string * prfstep_descriptor list * (Proof.context -> conv) ->
         theory -> theory
    val add_resolve_prfstep: thm -> theory -> theory
    val add_resolve_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule: thm -> theory -> theory
    val add_rewrite_rule_back: thm -> theory -> theory
    val add_rewrite_rule_back_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule_bidir: thm -> theory -> theory
    val add_rewrite_rule_bidir_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val del_prfstep: string -> theory -> theory
    val del_prfstep_pred: (string -> bool) -> theory -> theory
    val del_prfstep_thm: thm -> theory -> theory
    val del_prfstep_thm_eqforward: thm -> theory -> theory
    val del_prfstep_thm_str: string -> thm -> theory -> theory
    val get_prfsteps: theory -> proofstep list
    type pre_prfstep_descriptor = Proof.context -> prfstep_descriptor
    datatype prfstep_mode
    =
         MODE_BACKWARD
       | MODE_BACKWARD1
       | MODE_BACKWARD2
       | MODE_FORWARD
       | MODE_FORWARD'
       | MODE_RESOLVE
    val setup_attrib: (thm -> theory -> theory) -> attribute context_parser
    val with_cond: string -> pre_prfstep_descriptor
    val with_conds: string list -> pre_prfstep_descriptor list
    val with_filt: prfstep_filter -> pre_prfstep_descriptor
    val with_filts: prfstep_filter list -> pre_prfstep_descriptor list
    val with_score: int -> pre_prfstep_descriptor
    val with_term: string -> pre_prfstep_descriptor
  end
structure ProofStep: PROOFSTEP
val WithTerm = fn: term -> prfstep_descriptor
val WithGoal = fn: term -> prfstep_descriptor
val WithProp = fn: term -> prfstep_descriptor
val neq_filter = fn: term -> prfstep_filter
val order_filter = fn: string -> string -> prfstep_filter
val size1_filter = fn: string -> prfstep_filter
val not_type_filter = fn: string -> typ -> prfstep_filter
datatype prfstep_mode
=
     MODE_BACKWARD
   | MODE_BACKWARD1
   | MODE_BACKWARD2
   | MODE_FORWARD
   | MODE_FORWARD'
   | MODE_RESOLVE
type pre_prfstep_descriptor = Proof.context -> prfstep_descriptor
structure ProofStepData: PROOFSTEP_DATA
constructor MODE_FORWARD': prfstep_mode
constructor MODE_BACKWARD1: prfstep_mode
val del_prfstep_thm_eqforward = fn: thm -> theory -> theory
val get_prfsteps = fn: theory -> proofstep list
val del_prfstep_thm = fn: thm -> theory -> theory
val add_forward'_prfstep = fn: thm -> theory -> theory
val with_conds = fn: string list -> pre_prfstep_descriptor list
val add_prfstep_custom = fn:
   string * prfstep_descriptor list *
   (id_inst_ths -> box_item list -> Proof.context -> raw_update list)
     -> theory -> theory
val add_rewrite_rule_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward'_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val del_prfstep_thm_str = fn: string -> thm -> theory -> theory
val add_rewrite_rule = fn: thm -> theory -> theory
val with_cond = fn: string -> pre_prfstep_descriptor
val add_gen_prfstep = fn:
   string * prfstep_descriptor list -> theory -> theory
val add_backward_prfstep = fn: thm -> theory -> theory
val add_resolve_prfstep = fn: thm -> theory -> theory
constructor MODE_RESOLVE: prfstep_mode
val with_filts = fn: prfstep_filter list -> pre_prfstep_descriptor list
val add_prfstep_check_req = fn: string * string -> theory -> theory
val add_backward_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val with_score = fn: int -> pre_prfstep_descriptor
val add_rewrite_rule_back = fn: thm -> theory -> theory
val add_backward1_prfstep = fn: thm -> theory -> theory
val add_rewrite_rule_bidir_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val with_filt = fn: prfstep_filter -> pre_prfstep_descriptor
constructor MODE_BACKWARD2: prfstep_mode
val add_resolve_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep_pre_conv = fn:
   string * prfstep_descriptor list * (Proof.context -> conv) ->
     theory -> theory
val add_forward_prfstep = fn: thm -> theory -> theory
val add_backward2_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep = fn: proofstep -> theory -> theory
val setup_attrib = fn: (thm -> theory -> theory) -> attribute context_parser
val del_prfstep = fn: string -> theory -> theory
constructor MODE_FORWARD: prfstep_mode
constructor MODE_BACKWARD: prfstep_mode
val add_rewrite_rule_bidir = fn: thm -> theory -> theory
val del_prfstep_pred = fn: (string -> bool) -> theory -> theory
val add_rewrite_rule_back_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep_conv = fn:
   string * prfstep_descriptor list * conv -> theory -> theory
val add_backward1_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_backward2_prfstep = fn: thm -> theory -> theory
val with_term = fn: string -> pre_prfstep_descriptor
Found termination order: "size <*mlex*> {}"
type auto2_frame =
   {after_qed: (term list * (thm list -> thm -> thm)) option,
    goals: (term * thm) list,
    induct_stmt: term option, prem_only: term list, selected: int option}
type auto2_state = auto2_frame list
signature AUTO2_STATE =
  sig
    val add_prem_only: term -> Proof.context -> Proof.context
    val get_last_induct_stmt: Proof.context -> term option
    val get_num_frame: Proof.context -> int
    val get_selected: Proof.context -> thm
    val get_subgoal: Proof.context -> term
    val get_top_frame: Proof.context -> auto2_frame
    val lookup_prem_only: Proof.context -> term -> bool
    val map_head_th: (thm -> thm) -> Proof.context -> Proof.context
    val multiple_frame:
       (term * cterm) list * (term list * (thm list -> thm -> thm)) option
         -> auto2_frame
    val pop_head: Proof.context -> Proof.context
    val print_state: Proof.context -> unit
    val push_head: auto2_frame -> Proof.context -> Proof.context
    val set_induct_stmt: term -> Proof.context -> Proof.context
    val set_selected: int option -> Proof.context -> Proof.context
    val simple_frame:
       cterm * (term list * (thm list -> thm -> thm)) option -> auto2_frame
  end
structure Auto2_State: AUTO2_STATE
Found termination order: "size <*mlex*> {}"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
Found termination order: "size <*mlex*> {}"
### Additional type variable(s) in locale specification "countable": 'a
consts
  mset :: "'a list => 'a multiset"
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
signature LOGIC_PROOFSTEPS =
  sig
    val TY_DISJ: string
    val add_disj_normalizers: theory -> theory
    val add_disj_proofsteps: theory -> theory
    val add_logic_proofsteps: theory -> theory
    val analyze_disj_th: Proof.context -> thm -> term * thm
    val dest_tname_of_disj: cterm list -> term * cterm list
    val disj_create_case_prfstep: proofstep
    val disj_match_iff_prfstep: proofstep
    val disj_normalizer: Normalizer.normalizer
    val disj_prop_match:
       Proof.context ->
         id_inst ->
           term * (term list * term list) *
           ((indexname * typ) list * cterm list)
             -> id_inst_th list
    val disj_prop_matcher: item_matcher
    val disj_rewr_terms: term list -> term list
    val disj_shadow_prfstep: proofstep
    val disj_to_ritems: bool -> term -> thm -> raw_item list
    val disj_to_update:
       bool -> term -> box_id * int option * thm -> raw_update
    val eq_normalizer: Normalizer.normalizer
    val exists_elim_prfstep: proofstep
    val is_match_prem_only: box_item -> bool
    val logic_thm_update: Proof.context -> box_id * thm -> raw_update
    val match_one_sch_prfstep: proofstep
    val match_update_prfstep: proofstep
    val mk_all_disj: term list * term list -> term
    val norm_all_disj: Proof.context -> conv
    val norm_conj: conv
    val output_disj_fn: item_output
    val property_normalizer: Normalizer.normalizer
    val reduce_disj_True: conv
    val replace_disj_vars:
       Proof.context -> term list * term list -> term list * term list
    val shadow_prop_item: proofstep
    val shadow_term_item: proofstep
    val split_conj_gen_th: Proof.context -> thm -> thm list
    val split_not_imp_th: thm -> thm list
    val strip_all_disj: term -> term list * term list
  end
structure Logic_ProofSteps: LOGIC_PROOFSTEPS
val TY_DISJ = "DISJ": string
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
signature SCORES =
  sig
    val get_score: raw_update -> int
    val item_score: raw_item -> int
    val items_score: raw_item list -> int
  end
signature PROOFSTATUS =
  sig
    val apply_update: update -> status -> status
    val apply_update_instant: update -> status -> status
    val check_hyps: box_id -> thm -> status -> unit
    val init_status: Proof.context -> term -> status
    val process_add_boxes: update -> status -> status
    val process_add_items: update -> status -> status
    val process_fact_all: box_id -> int -> box_item list -> status -> status
    val process_resolve: update -> status -> status
    val process_shadow: update -> status -> status
    val scoring:
       proofstep ->
         int ->
           box_item list ->
             status -> (box_item -> raw_update list) -> update list
    val solve_root: int * status -> int * status
  end
structure Scores: SCORES
val print_trace =
   Config
    {get_value = fn, map_value = fn, name = "print_trace", pos =
     {line=41, offset=1042, end_offset=1053, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_intended =
   Config
    {get_value = fn, map_value = fn, name = "print_intended", pos =
     {line=43, offset=1127, end_offset=1141, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_term =
   Config
    {get_value = fn, map_value = fn, name = "print_term", pos =
     {line=45, offset=1211, end_offset=1221, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_shadow =
   Config
    {get_value = fn, map_value = fn, name = "print_shadow", pos =
     {line=47, offset=1293, end_offset=1305, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_score =
   Config
    {get_value = fn, map_value = fn, name = "print_score", pos =
     {line=49, offset=1376, end_offset=1387, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val max_steps =
   Config
    {get_value = fn, map_value = fn, name = "max_steps", pos =
     {line=53, offset=1507, end_offset=1516, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   int Config.T
signature AUTO2 = sig val auto2_tac: Proof.context -> tactic end
structure ProofStatus: PROOFSTATUS
structure Auto2: AUTO2
Found termination order: "size <*mlex*> {}"
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
signature AUTO2_OUTER =
  sig
    val auto2_solve: Proof.context -> cterm -> thm
    val case_after_qed: Proof.context -> thm list -> thm -> thm
    val case_cmd: string * bool -> Proof.state -> Proof.state
    val case_resolve: Proof.context -> term list -> thm -> thm
    val contra_after_qed: Proof.context -> thm -> thm
    val contra_cmd: Proof.state -> Proof.state
    val contra_resolve:
       Proof.context -> term list -> term list -> term -> thm
    val end_cmd: Proof.state -> Proof.state
    val endgoal_cmd: Proof.state -> Proof.state
    val have_after_qed: Proof.context -> thm -> thm -> thm
    val have_cmd: bool * string * bool -> Proof.state -> Proof.state
    val have_resolve: Proof.context -> term list -> thm -> term -> thm
    val init_state: Proof.state -> Proof.state
    val let_after_qed: Proof.context -> term list -> thm -> thm
    val let_cmd: string list -> Proof.state -> Proof.state
    val let_resolve:
       Proof.context -> term list -> term -> term list -> term -> thm
    val obtain_after_qed: Proof.context -> thm list -> thm -> thm
    val obtain_cmd:
       string list * string list * bool -> Proof.state -> Proof.state
    val obtain_resolve: Proof.context -> term list -> thm -> term -> thm
    val qed_cmd: Proof.state -> Proof.context
    val refine_subgoal_th: thm -> thm -> thm
    val subgoal_cmd: string -> Proof.state -> Proof.state
  end
structure Auto2_Outer: AUTO2_OUTER
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
type ac_info =
   {assoc_th: thm,
    cfhead: cterm,
    comm_th: thm, unit: cterm option, unitl_th: thm, unitr_th: thm}
signature ACUTIL =
  sig
    val ac_last_conv: ac_info -> conv -> conv
    val add_ac_data: ac_info -> theory -> theory
    val assoc_cv: ac_info -> conv
    val assoc_sym_cv: ac_info -> conv
    val cdest_ac: ac_info -> cterm -> cterm list
    val comb_ac_equiv: ac_info -> thm list -> thm
    val comm_cv: ac_info -> conv
    val dest_ac: ac_info -> term -> term list
    val eq_unit: ac_info -> term -> bool
    val get_head_ac_info: theory -> term -> ac_info option
    val has_assoc_th: ac_info -> bool
    val has_comm_th: ac_info -> bool
    val has_unit_th: ac_info -> bool
    val head_agrees: ac_info -> term -> bool
    val inst_ac_info: theory -> typ -> ac_info -> ac_info option
    val move_outmost: ac_info -> term -> conv
    val norm_combine: ac_info -> (term -> bool) -> conv -> conv
    val normalize_all_ac: ac_info -> conv
    val normalize_assoc: ac_info -> conv
    val normalize_au: ac_info -> conv
    val normalize_comm: ac_info -> conv
    val normalize_comm_gen: ac_info -> (term * term -> bool) -> conv
    val normalize_unit: ac_info -> conv
    val swap_cv: ac_info -> conv
    val swap_r_cv: ac_info -> conv
  end
structure ACUtil: ACUTIL
signature AC_PROOFSTEPS =
  sig
    val ac_expand:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val ac_expand_equiv: proofstep
    val ac_expand_once:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val ac_expand_unit: proofstep
    val add_ac_proofsteps: theory -> theory
    val get_ac_head_equiv:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val max_ac: int Config.T
    val simp_ac_expr:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
  end
structure AC_ProofSteps: AC_PROOFSTEPS
signature UNFOLDING =
  sig
    val get_unfold_thms: theory -> term -> thm list
    val get_unfold_thms_by_name: theory -> string -> thm list
    val unfold: theory -> conv
    val unfold_cmd: string -> Proof.state -> Proof.state
  end
structure Unfolding: UNFOLDING
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
signature INDUCT_PROOFSTEPS =
  sig
    val add_case_induct_rule: thm -> theory -> theory
    val add_cases_rule: thm -> theory -> theory
    val add_fun_induct_rule: term * thm -> theory -> theory
    val add_induct_data: string -> term * thm -> theory -> theory
    val add_prop_induct_rule: thm -> theory -> theory
    val add_strong_induct_rule: thm -> theory -> theory
    val add_typed_induct_data: string -> typ * thm -> theory -> theory
    val add_var_induct_rule: thm -> theory -> theory
    val apply_induct_hyp_cmd: string list -> Proof.state -> Proof.state
    val case_induct_cmd: string -> Proof.state -> Proof.state
    val check_strong_ind_prop: term -> term list * term
    val fun_induct_cmd:
       string * string list * string option -> Proof.state -> Proof.state
    val get_term_ind_th: theory -> string -> term -> thm
    val get_typed_ind_th: theory -> string -> typ -> thm
    val induct_cmd:
       string ->
         string * string option * string list * string option ->
           Proof.state -> Proof.state
    val is_simple_fun_induct: thm -> bool
    val prop_induct_cmd:
       string * string option -> Proof.state -> Proof.state
    val strong_induct_cmd:
       string * string list -> Proof.state -> Proof.state
  end
structure Induct_ProofSteps: INDUCT_PROOFSTEPS
val add_strong_induct_rule = fn: thm -> theory -> theory
val add_case_induct_rule = fn: thm -> theory -> theory
val add_prop_induct_rule = fn: thm -> theory -> theory
val add_var_induct_rule = fn: thm -> theory -> theory
val add_fun_induct_rule = fn: term * thm -> theory -> theory
val add_cases_rule = fn: thm -> theory -> theory
Found termination order: "size <*mlex*> {}"
signature EXTRA_HOL =
  sig
    val add_forward_arg1_prfstep: thm -> theory -> theory
    val add_forward_arg1_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward_arg_prfstep: thm -> theory -> theory
    val add_forward_arg_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_arg_rule: thm -> theory -> theory
    val add_rewrite_arg_rule_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_simple_datatype: string -> theory -> theory
    val del_simple_datatype: string -> theory -> theory
  end
structure Extra_HOL: EXTRA_HOL
val add_forward_arg_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward_arg1_prfstep = fn: thm -> theory -> theory
val add_forward_arg_prfstep = fn: thm -> theory -> theory
val add_simple_datatype = fn: string -> theory -> theory
val del_simple_datatype = fn: string -> theory -> theory
val add_rewrite_arg_rule_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_rewrite_arg_rule = fn: thm -> theory -> theory
val add_forward_arg1_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
### theory "HOL-Library.Countable"
### 1.253s elapsed time, 4.914s cpu time, 0.474s GC time
Loading theory "HOL-Imperative_HOL.Heap" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad")
### theory "Auto2_HOL.Auto2_HOL"
### 2.904s elapsed time, 11.225s cpu time, 1.427s GC time
Loading theory "Auto2_HOL.Logic_Thms" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms")
HOL.refl@res
WithGoal ?t = ?t
GetResolve HOL.refl@res
HOL_Base.contra_triv
WithGoal ?A
WithFact ?A
GetResolve HOL_Base.contra_triv
HOL.TrueI@res
WithGoal True
GetResolve HOL.TrueI@res
Logic_Thms.FalseD@res
WithFact False
GetResolve Logic_Thms.FalseD@res
Logic_Thms.exists_triv_eq@res
WithGoal EX x. x = x
GetResolve Logic_Thms.exists_triv_eq@res
HOL.not_sym
WithGoal ?t = ?s
GetGoal (?s = ?t, HOL.not_sym) + 1 filters
Logic_Thms.iff_goal_1
WithGoal ?A = ?B
WithFact ?A
WithScore 1
GetGoal (?B, Logic_Thms.iff_goal_1)
Logic_Thms.iff_goal_2
WithGoal ?A = ?B
WithFact ?B
WithScore 1
GetGoal (?A, Logic_Thms.iff_goal_2)
Logic_Thms.iff_goal_3
WithGoal ?A = ?B
WithGoal ?A
WithScore 1
GetFact (?B, Logic_Thms.iff_goal_3)
Logic_Thms.iff_goal_4
WithGoal ?A = ?B
WithGoal ?B
WithScore 1
GetFact (?A, Logic_Thms.iff_goal_4)
Logic_Thms.iff_goal_5
WithGoal (~ ?A) = ?B
WithFact ?A
WithScore 1
GetFact (?B, Logic_Thms.iff_goal_5)
Logic_Thms.iff_goal_6
WithGoal ?A = (~ ?B)
WithFact ?B
WithScore 1
GetFact (?A, Logic_Thms.iff_goal_6)
Logic_Thms.exists_split@eqbackward@back
WithGoal EX x y. ?P x & ?Q y
GetGoal ((EX x. ?P x) & (EX y. ?Q y), Logic_Thms.exists_split@eqbackward@back)
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
HOL.if_P
WithTerm if ?P then ?x else ?y
WithFact ?P
WithScore 1
GetFact ((if ?P then ?x else ?y) = ?x, HOL.if_P)
HOL.if_not_P
WithTerm if ?P then ?x else ?y
WithGoal ?P
WithScore 1
GetFact ((if ?P then ?x else ?y) = ?y, HOL.if_not_P)
Logic_Thms.if_eval'
WithTerm if ~ ?P then ?x else ?y
WithFact ?P
WithScore 1
GetFact ((if ~ ?P then ?x else ?y) = ?y, Logic_Thms.if_eval')
Logic_Thms.ifb_eval_1@eqforward
WithFact if ?Pa then ?P else ?y
WithFact ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_1@eqforward)
Logic_Thms.ifb_eval_1@invbackward
WithGoal if ?P then ?B else ?y
WithFact ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_1@invbackward)
Logic_Thms.ifb_eval_2@eqforward
WithFact if ?Pa then ?x else ?P
WithGoal ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_2@eqforward)
Logic_Thms.ifb_eval_2@invbackward
WithGoal if ?P then ?x else ?B
WithGoal ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_2@invbackward)
Logic_Thms.ifb_eval_3@eqforward
WithFact if ~ ?Pa then ?x else ?P
WithFact ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_3@eqforward)
Logic_Thms.ifb_eval_3@invbackward
WithGoal if ~ ?P then ?x else ?B
WithFact ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_3@invbackward)
HOL.theI'
WithTerm THE x. ?P x
WithFact EX! x. ?P x
GetFact (?P (THE x. ?P x), HOL.theI')
Logic_Thms.ex_ex1I'@back1
WithGoal EX! x. ?P x
WithFact ?P ?x
GetGoal (ALL y. ?P y --> ?x = y, Logic_Thms.ex_ex1I'@back1)
Logic_Thms.the1_equality'
WithTerm THE x. ?P x
WithFact ?P ?a
GetFact ((EX! x. ?P x) --> (THE x. ?P x) = ?a, Logic_Thms.the1_equality')
Hilbert_Choice.someI
WithTerm SOME x. ?P x
WithFact ?P ?x
GetFact (?P (Eps ?P), Hilbert_Choice.someI)
Hilbert_Choice.someI_ex
WithTerm SOME x. ?P x
WithFact EX x. ?P x
GetFact (?P (SOME x. ?P x), Hilbert_Choice.someI_ex)
Logic_Thms.Least_equality'@back1
WithGoal Least ?P = ?x
WithFact ALL y. ?P y --> ?x <= y
GetGoal (?P ?x, Logic_Thms.Least_equality'@back1)
Product_Type.fst_conv
WithTerm fst (?x1.0, ?x2.0)
GetFact (fst (?x1.0, ?x2.0) = ?x1.0, Product_Type.fst_conv)
Product_Type.snd_conv
WithTerm snd (?x1.0, ?x2.0)
GetFact (snd (?x1.0, ?x2.0) = ?x2.0, Product_Type.snd_conv)
Product_Type.prod.simps_1@eqforward
WithFact (?x1.0, ?x2.0) = (?y1.0, ?y2.0)
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Product_Type.prod.simps_1@eqforward)
Product_Type.surjective_pairing
WithTerm ?t
GetFact (?t = (fst ?t, snd ?t), Product_Type.surjective_pairing) + 1 filters
Relation.symD
WithProperty sym ?r
WithFact (?b, ?a) : ?r
GetFact ((?a, ?b) : ?r, Relation.symD)
Relation.symI@back
WithGoal sym ?r
GetGoal (ALL a b. (a, b) : ?r --> (b, a) : ?r, Relation.symI@back)
Relation.transD
WithProperty trans ?r
WithFact (?x, ?y) : ?r
WithFact (?y, ?z) : ?r
GetFact ((?x, ?z) : ?r, Relation.transD)
Relation.transI@back
WithGoal trans ?r
GetGoal (ALL x y z. (x, y) : ?r --> (y, z) : ?r --> (x, z) : ?r, Relation.transI@back)
Option.option.distinct_1@res
WithFact None = Some ?x2.0
GetResolve Option.option.distinct_1@res
Option.option.sel
WithTerm the (Some ?x2.0)
GetFact (the (Some ?x2.0) = ?x2.0, Option.option.sel)
Option.option.collapse
WithGoal ?option = None
GetFact (Some (the ?option) = ?option, Option.option.collapse)
Option.option.simps_1@eqforward
WithFact Some ?x2.0 = Some ?y2.0
GetFact (?x2.0 = ?y2.0, Option.option.simps_1@eqforward)
Option.option.case_1
WithTerm case None of None => ?f1.0 | Some x => ?f2.0 x
WithScore 1
GetFact ((case None of None => ?f1.0 | Some x => ?f2.0 x) = ?f1.0, Option.option.case_1)
Option.option.case_2
WithTerm case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x
WithScore 1
GetFact ((case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x) = ?f2.0 ?x2.0, Option.option.case_2)
### theory "Auto2_HOL.Logic_Thms"
### 0.187s elapsed time, 0.730s cpu time, 0.090s GC time
Loading theory "Auto2_HOL.Order_Thms" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms")
### theory "HOL-Library.Tree"
### 2.365s elapsed time, 9.112s cpu time, 1.252s GC time
Loading theory "Draft.Templates" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.069s elapsed time, 0.273s cpu time, 0.000s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.ExtrEqs")
signature UTIL_ARITH =
  sig
    val contra_by_arith: Proof.context -> thm list -> thm
    val dest_numc: term -> int
    val dest_numc_rat: term -> Rat.rat
    val intT: typ
    val is_divide: term -> bool
    val is_linorder: Proof.context -> term -> bool
    val is_minus: term -> bool
    val is_numc: term -> bool
    val is_one: term -> bool
    val is_order: term -> bool
    val is_plus: term -> bool
    val is_times: term -> bool
    val is_zero: term -> bool
    val natT: typ
    val neg_ineq_back_cv: conv
    val neg_ineq_cv: conv
    val prove_by_arith: Proof.context -> thm list -> term -> thm
    val ratT: typ
    val rat_zero: Rat.rat
  end
structure UtilArith: UTIL_ARITH
val natT = "nat": typ
val intT = "int": typ
Orderings.preorder_class.order.trans
WithFact ?a <= ?b
WithFact ?b <= ?c
GetFact (?a <= ?c, Orderings.preorder_class.order.trans) + 1 filters
Orderings.preorder_class.order.strict_trans
WithFact ?a < ?b
WithFact ?b < ?c
GetFact (?a < ?c, Orderings.preorder_class.order.strict_trans) + 1 filters
Orderings.order_le_less_trans
WithFact ?x <= ?y
WithFact ?y < ?z
GetFact (?x < ?z, Orderings.order_le_less_trans) + 1 filters
Orderings.order_less_le_trans
WithFact ?x < ?y
WithFact ?y <= ?z
GetFact (?x < ?z, Orderings.order_less_le_trans) + 1 filters
Orderings.preorder_class.order.irrefl@res
WithFact ?a < ?a
GetResolve Orderings.preorder_class.order.irrefl@res
Orderings.order_class.le_neq_trans
WithFact ?a <= ?b
WithGoal ?a = ?b
GetFact (?a < ?b, Orderings.order_class.le_neq_trans) + 1 filters
Orderings.order_class.order_antisym
WithFact ?x <= ?y
WithFact ?y <= ?x
GetFact (?x = ?y, Orderings.order_class.order_antisym) + 2 filters
Lattices.linorder_class.min.commute
WithTerm min ?a ?b
GetFact (min ?a ?b = min ?b ?a, Lattices.linorder_class.min.commute)
Lattices.linorder_class.min.idem
WithTerm min ?a ?a
GetFact (min ?a ?a = ?a, Lattices.linorder_class.min.idem)
Lattices.linorder_class.min.cobounded1
WithTerm min ?a ?b
GetFact (min ?a ?b <= ?a, Lattices.linorder_class.min.cobounded1)
Lattices.linorder_class.min.cobounded2
WithTerm min ?a ?b
GetFact (min ?a ?b <= ?b, Lattices.linorder_class.min.cobounded2)
Lattices.linorder_class.min.boundedI@back2
WithGoal ?a <= min ?b ?c
WithFact ?a <= ?b
GetGoal (?a <= ?c, Lattices.linorder_class.min.boundedI@back2)
Lattices.linorder_class.min.mono@back2
WithGoal min ?a ?b <= min ?c ?d
WithFact ?a <= ?c
GetGoal (?b <= ?d, Lattices.linorder_class.min.mono@back2)
Lattices.linorder_class.min.absorb1
WithTerm min ?a ?b
WithFact ?a <= ?b
GetFact (min ?a ?b = ?a, Lattices.linorder_class.min.absorb1)
Lattices.linorder_class.min.absorb2
WithTerm min ?a ?b
WithFact ?b <= ?a
GetFact (min ?a ?b = ?b, Lattices.linorder_class.min.absorb2)
Lattices.linorder_class.max.commute
WithTerm max ?a ?b
GetFact (max ?a ?b = max ?b ?a, Lattices.linorder_class.max.commute)
Lattices.linorder_class.max.idem
WithTerm max ?a ?a
GetFact (max ?a ?a = ?a, Lattices.linorder_class.max.idem)
Lattices.linorder_class.max.cobounded1
WithTerm max ?a ?b
GetFact (?a <= max ?a ?b, Lattices.linorder_class.max.cobounded1)
Lattices.linorder_class.max.cobounded2
WithTerm max ?a ?b
GetFact (?b <= max ?a ?b, Lattices.linorder_class.max.cobounded2)
Lattices.linorder_class.max.boundedI@back2
WithGoal max ?b ?c <= ?a
WithFact ?b <= ?a
GetGoal (?c <= ?a, Lattices.linorder_class.max.boundedI@back2)
Lattices.linorder_class.max.mono@back2
WithGoal max ?c ?d <= max ?a ?b
WithFact ?c <= ?a
GetGoal (?d <= ?b, Lattices.linorder_class.max.mono@back2)
Lattices.linorder_class.max.absorb1
WithTerm max ?a ?b
WithFact ?b <= ?a
GetFact (max ?a ?b = ?a, Lattices.linorder_class.max.absorb1)
Lattices.linorder_class.max.absorb2
WithTerm max ?a ?b
WithFact ?a <= ?b
GetFact (max ?a ?b = ?b, Lattices.linorder_class.max.absorb2)
Lattices_Big.linorder_class.Min_in@back
WithProperty finite ?A
WithGoal Min ?A : ?A
GetFact (?A = {}, Lattices_Big.linorder_class.Min_in@back)
Lattices_Big.linorder_class.Min_le@back
WithProperty finite ?A
WithGoal Min ?A <= ?x
GetGoal (?x : ?A, Lattices_Big.linorder_class.Min_le@back)
Lattices_Big.linorder_class.Min_eqI@back2
WithProperty finite ?A
WithGoal Min ?A = ?x
WithFact ALL y. y : ?A --> ?x <= y
GetGoal (?x : ?A, Lattices_Big.linorder_class.Min_eqI@back2)
Order_Thms.exists_ge@res
WithGoal EX k. ?i <= k
GetResolve Order_Thms.exists_ge@res
Orderings.no_bot_class.lt_ex@res
WithGoal EX y. y < ?x
GetResolve Orderings.no_bot_class.lt_ex@res
Orderings.no_top_class.gt_ex@res
WithGoal EX y. ?x < y
GetResolve Orderings.no_top_class.gt_ex@res
Orderings.dense_order_class.dense@back
WithGoal EX z>?x. z < ?y
GetGoal (?x < ?y, Orderings.dense_order_class.dense@back)
### theory "Auto2_HOL.Order_Thms"
### 0.356s elapsed time, 1.396s cpu time, 0.084s GC time
Loading theory "Auto2_HOL.Arith_Thms" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main")
Add ac data for function Groups.plus_class.plus
Add ac data for function Groups.times_class.times
Add ac data for function GCD.gcd_class.gcd
signature NAT_UTIL =
  sig
    val add_arith_ac_data: theory -> theory
    val add_arith_proofsteps: theory -> theory
    val cnat0: cterm
    val lookup_numc: Type.tyenv * Envir.tenv -> int -> int
    val lookup_numc0: Type.tyenv * Envir.tenv -> int
    val lookup_numc1: Type.tyenv * Envir.tenv -> int
    val lookup_numc2: Type.tyenv * Envir.tenv -> int
    val mk_int: int -> term
    val mk_le: term * term -> term
    val mk_less: term * term -> term
    val mk_nat: int -> term
    val nat0: term
    val nat_fold_conv: conv
    val nat_fold_reduce: term -> term
    val nat_le_th: int -> int -> thm
    val nat_less_th: int -> int -> thm
    val nat_neq_th: int -> int -> thm
    val plus_ac_on_typ: theory -> typ -> ac_info
    val times_ac_on_typ: theory -> typ -> ac_info
  end
structure Nat_Util: NAT_UTIL
val mk_nat = fn: int -> term
val mk_int = fn: int -> term
val plus_ac_on_typ = fn: theory -> typ -> ac_info
val times_ac_on_typ = fn: theory -> typ -> ac_info
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
signature NAT_ORDER =
  sig
    val add_nat_order_proofsteps: theory -> theory
    val convert_const_x: thm -> thm
    val convert_const_y: thm -> thm
    val dest_ineq: term -> term * term * int
    val dest_ineq_th: thm -> term * term * int
    val fold_double_plus: conv
    val get_nat_order_info: box_item -> order_info
    val is_minus_const: term -> bool
    val is_order: term -> bool
    val is_plus_const: term -> bool
    val is_standard_ineq: term -> bool
    val nat_eq_diff_prfstep: proofstep
    val nat_order_match:
       term -> box_item -> Proof.context -> id_inst -> id_inst_th list
    val nat_order_matcher: item_matcher
    val nat_order_normalizer: Normalizer.normalizer
    val nat_order_noteq_matcher: item_matcher
    val nat_order_single_match:
       term -> box_item -> Proof.context -> id_inst -> id_inst_th list
    val nat_order_single_matcher: item_matcher
    val nat_order_typed_matcher: item_matcher
    val norm_ineq_minus_th: thm -> thm option
    val norm_ineq_minus_th': thm -> thm option
    val norm_ineq_th: thm -> thm
    val norm_ineq_th': thm -> thm
    type order_info
    datatype order_type
    =
         LE
       | LESS
       | LESS_LMINUS
       | LESS_LPLUS
       | LESS_RMINUS
       | LESS_RPLUS
       | LE_LMINUS
       | LE_LPLUS
       | LE_RMINUS
       | LE_RPLUS
    val output_nat_order: Proof.context -> term list * thm -> string
    val shadow_nat_order:
       Proof.context -> box_id -> term list * cterm list -> bool
    val shadow_nat_order_prfstep: proofstep
    val shadow_nat_order_single: proofstep
    val single_resolve: proofstep
    val single_resolve_zero: proofstep
    val string_of_nat_order:
       Proof.context -> term * term * int * thm -> string
    val th_to_normed_ritems: thm -> raw_item list
    val th_to_ritem: thm -> raw_item
    val to_normal_th: order_type -> thm -> thm
    val transitive: proofstep
    val transitive_resolve: proofstep
  end
val TY_NAT_ORDER = "NAT_ORDER": string
structure Nat_Order: NAT_ORDER
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
### theory "HOL-Library.BigO"
### 1.213s elapsed time, 4.586s cpu time, 1.406s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Sep_ExamplesMoreTemplates")
consts
  addr_of_array :: "'a array => nat"
consts
  addr_of_ref :: "'a ref => nat"
### theory "HOL-Imperative_HOL.Heap"
### 1.541s elapsed time, 5.876s cpu time, 1.496s GC time
Loading theory "HOL-Imperative_HOL.Heap_Monad" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array")
val test_fold_double_plus = [(), (), (), ()]: unit list
val convert_prop_to_nat_order = fn: term -> raw_item list
val test_parse_prop = (): unit
val test_nat_order_match = (): unit
val test_nat_order_single_match = (): unit
Groups.minus_class.minus_case
WithTerm ?a - ?b
CreateConcl ?b <= ?a
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Proofs for inductive predicate(s) "pred_mset"
signature NAT_SUB =
  sig
    val add_nat_sub_proofsteps: theory -> theory
    val add_polynomial_list: monomial list * monomial list -> monomial list
    val cancel_terms: wfconv
    val fheads: term list
    val get_sub_head_equiv:
       Proof.context -> box_id * cterm -> (box_id * (wfterm * thm)) list
    type monomial = cterm list * int
    val move_outmost: term -> wfconv
    val nat_sub_expand:
       Proof.context -> box_id * cterm -> (box_id * (wfterm * thm)) list
    val nat_sub_expand_equiv: proofstep
    val nat_sub_expand_once:
       Proof.context -> box_id * wfterm -> (box_id * (wfterm * thm)) list
    val nat_sub_expand_unit: proofstep
    val norm_minus: wfconv
    val norm_minus': wfconv
    val norm_minus_ct: cterm -> monomial list
    val norm_plus: wfconv
    val norm_plus1: wfconv
    val norm_ring_term: cterm -> term
    val reduce_monomial_list: monomial list -> monomial list
  end
structure NatSub: NAT_SUB
  Proving monotonicity ...
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
### theory "HOL-Library.Multiset"
### 4.388s elapsed time, 16.887s cpu time, 2.917s GC time
Loading theory "Auto2_HOL.Set_Thms" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms")
val test_term = fn:
   Proof.context -> (cterm -> term) -> string -> string * string -> unit
val test =
   [(), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (),
    (), (), ...]:
   unit list
Arith_Thms.le_neq_implies_less'
WithGoal ?m = ?n
WithFact ?m <= ?n
GetFact (?m < ?n, Arith_Thms.le_neq_implies_less')
Arith_Thms.le_zero_to_equal_zero
WithFact ?n <= 0
GetFact (?n = 0, Arith_Thms.le_zero_to_equal_zero)
Arith_Thms.less_one_to_equal_zero
WithFact ?n < 1
GetFact (?n = 0, Arith_Thms.less_one_to_equal_zero)
Nat.mult_le_mono1@back
WithGoal ?i * ?k <= ?j * ?k
GetGoal (?i <= ?j, Nat.mult_le_mono1@back) + 1 filters
Nat.not_add_less1@res
WithFact ?i + ?j < ?i
GetResolve Nat.not_add_less1@res
Arith_Thms.not_minus_less@res
WithFact ?i < ?i - ?j
GetResolve Arith_Thms.not_minus_less@res
Arith_Thms.nat_le_prod_with_same@back
WithGoal ?n <= ?m * ?n
GetFact (?m = 0, Arith_Thms.nat_le_prod_with_same@back)
Arith_Thms.nat_le_prod_with_le@back1
WithGoal ?n <= ?k * ?m
WithFact ?n <= ?m
GetFact (?k = 0, Arith_Thms.nat_le_prod_with_le@back1)
Arith_Thms.nat_plus_le_to_less@back1
WithGoal ?a < ?c
WithFact ?a + ?b <= ?c
GetFact (?b = 0, Arith_Thms.nat_plus_le_to_less@back1)
Arith_Thms.nat_plus_le_to_less2@back1
WithGoal ?b < ?c
WithFact ?a + ?b <= ?c
GetFact (?a = 0, Arith_Thms.nat_plus_le_to_less2@back1)
Groups.cancel_semigroup_add_class.add_right_imp_eq
WithFact ?b + ?a = ?c + ?a
GetFact (?b = ?c, Groups.cancel_semigroup_add_class.add_right_imp_eq)
Groups.cancel_semigroup_add_class.add_left_imp_eq
WithFact ?a + ?b = ?a + ?c
GetFact (?b = ?c, Groups.cancel_semigroup_add_class.add_left_imp_eq)
Nat.le_diff_conv2@eqforward
WithWellForm ?k <= ?j
WithTerm ?i + ?k
WithFact ?i <= ?j - ?k
GetFact (?i + ?k <= ?j, Nat.le_diff_conv2@eqforward)
Nat.le_diff_conv2@invbackward
WithWellForm ?k <= ?j
WithTerm ?i + ?k
WithGoal ?i <= ?j - ?k
GetGoal (?i + ?k <= ?j, Nat.le_diff_conv2@invbackward)
Arith_Thms.nat_less_diff_conv
WithTerm ?i + ?k
WithFact ?i < ?j - ?k
GetFact (?i + ?k < ?j, Arith_Thms.nat_less_diff_conv) + 1 filters
Arith_Thms.Nat_le_diff_conv2_same
WithWellForm ?j <= ?i
WithFact ?i <= ?i - ?j
GetFact (?j = 0, Arith_Thms.Nat_le_diff_conv2_same)
Arith_Thms.nat_gt_zero
WithFact 0 < ?b - ?a
GetFact (?a < ?b, Arith_Thms.nat_gt_zero)
Arith_Thms.n_minus_1_less_n
WithWellForm 1 <= ?n
WithTerm ?n - 1
GetFact (?n - 1 < ?n, Arith_Thms.n_minus_1_less_n)
Nat.diff_le_mono@back
WithGoal ?m - ?l <= ?n - ?l
GetGoal (?m <= ?n, Nat.diff_le_mono@back)
Nat.diff_less_mono@back2
WithGoal ?a - ?c < ?b - ?c
WithFact ?a < ?b
GetGoal (?c <= ?a, Nat.diff_less_mono@back2)
Nat.mult_le_mono2@back
WithGoal ?k * ?i <= ?k * ?j
GetGoal (?i <= ?j, Nat.mult_le_mono2@back)
Nat.le_add1@res
WithGoal ?n <= ?n + ?m
GetResolve Nat.le_add1@res
Nat.le_add2@res
WithGoal ?n <= ?m + ?n
GetResolve Nat.le_add2@res
Groups.ordered_ab_semigroup_add_class.add_left_mono@back
WithGoal ?c + ?a <= ?c + ?b
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_left_mono@back)
Groups.ordered_ab_semigroup_add_class.add_right_mono@back
WithGoal ?a + ?c <= ?b + ?c
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_right_mono@back)
Arith_Thms.add_mono_neutr@back
WithGoal ?a <= ?a + ?b
GetGoal ((0::?'a) <= ?b, Arith_Thms.add_mono_neutr@back)
Arith_Thms.add_mono_neutl@back
WithGoal ?a <= ?b + ?a
GetGoal ((0::?'a) <= ?b, Arith_Thms.add_mono_neutl@back)
Groups.ordered_ab_semigroup_add_imp_le_class.add_less_imp_less_left
WithFact ?c + ?a < ?c + ?b
GetFact (?a < ?b, Groups.ordered_ab_semigroup_add_imp_le_class.add_less_imp_less_left)
Arith_Thms.sum_le_zero1
WithFact ?a + ?b < (0::?'a)
WithFact (0::?'a) <= ?a
GetFact (?b < (0::?'a), Arith_Thms.sum_le_zero1)
Arith_Thms.less_sum1@back
WithGoal ?a < ?a + ?b
GetGoal (0 < ?b, Arith_Thms.less_sum1@back)
Nat.trans_less_add2@back
WithGoal ?i < ?m + ?j
GetGoal (?i < ?j, Nat.trans_less_add2@back)
Nat.add_less_mono1@back
WithGoal ?i + ?k < ?j + ?k
GetGoal (?i < ?j, Nat.add_less_mono1@back)
Nat.add_less_mono@back1
WithGoal ?i + ?k < ?j + ?l
WithFact ?k < ?l
GetGoal (?i < ?j, Nat.add_less_mono@back1)
Nat.add_le_mono@back1
WithGoal ?i + ?k <= ?j + ?l
WithFact ?k <= ?l
GetGoal (?i <= ?j, Nat.add_le_mono@back1)
Groups.ordered_comm_monoid_add_class.add_increasing2@back1
WithGoal ?b <= ?a + ?c
WithFact ?b <= ?a
GetGoal ((0::?'a) <= ?c, Groups.ordered_comm_monoid_add_class.add_increasing2@back1)
Groups.ordered_ab_semigroup_add_class.add_mono@back1
WithGoal ?a + ?c <= ?b + ?d
WithFact ?c <= ?d
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_mono@back1)
Groups.ordered_cancel_ab_semigroup_add_class.add_strict_left_mono@back
WithGoal ?c + ?a < ?c + ?b
GetGoal (?a < ?b, Groups.ordered_cancel_ab_semigroup_add_class.add_strict_left_mono@back)
Nat.mult_le_mono@back1
WithGoal ?i * ?k <= ?j * ?l
WithFact ?k <= ?l
GetGoal (?i <= ?j, Nat.mult_le_mono@back1)
Arith_Thms.nat_add_eq_self_zero
WithFact ?m = ?m + ?n
GetFact (?n = 0, Arith_Thms.nat_add_eq_self_zero)
Arith_Thms.nat_add_eq_self_zero'
WithFact ?m = ?n + ?m
GetFact (?n = 0, Arith_Thms.nat_add_eq_self_zero')
Fun.injI@back
WithGoal inj ?f
GetGoal (ALL x y. ?f x = ?f y --> x = y, Fun.injI@back)
Arith_Thms.nat_mult_2
WithTerm ?a + ?a
GetFact (?a + ?a = 2 * ?a, Arith_Thms.nat_mult_2) + 1 filters
Arith_Thms.plus_one_non_zero@res
WithFact ?n + 1 = 0
GetResolve Arith_Thms.plus_one_non_zero@res
Arith_Thms.nat_same_minus_ge
WithFact ?c - ?b <= ?c - ?a
WithFact ?a <= ?c
GetFact (?a <= ?b, Arith_Thms.nat_same_minus_ge)
Arith_Thms.diff_eq_zero
WithWellForm ?k <= ?j
WithFact ?j - ?k = 0
GetFact (?j = ?k, Arith_Thms.diff_eq_zero)
Arith_Thms.diff_eq_zero'
WithWellForm ?k <= ?j
WithFact ?j - ?k + ?i = ?j
GetFact (?k = ?i, Arith_Thms.diff_eq_zero')
Add ac data for function Lattices.inf_class.inf
Add ac data for function Lattices.sup_class.sup
Arith_Thms.dvd_defD1@res
WithGoal EX k. ?b = ?a * k
WithFact ?a dvd ?b
GetResolve Arith_Thms.dvd_defD1@res
Set.mem_Collect_eq@eqforward
WithFact ?a : Collect ?P
GetFact (?P ?a, Set.mem_Collect_eq@eqforward)
Set.mem_Collect_eq@invbackward
WithGoal ?a : Collect ?P
GetGoal (?P ?a, Set.mem_Collect_eq@invbackward)
Arith_Thms.dvd_defD2@res
WithGoal EX k. ?b = k * ?a
WithFact ?a dvd ?b
GetResolve Arith_Thms.dvd_defD2@res
Set_Thms.ball_single@eqforward
WithFact ALL x:{?x}. ?P x
GetFact (?P ?x, Set_Thms.ball_single@eqforward)
Set_Thms.ball_single@invbackward
WithGoal ALL x:{?x}. ?P x
GetGoal (?P ?x, Set_Thms.ball_single@invbackward)
Nat.dvd_imp_le
WithFact ?k dvd ?n
WithFact 0 < ?n
GetFact (?k <= ?n, Nat.dvd_imp_le)
Arith_Thms.dvd_ineq2
WithFact ?k dvd ?n
WithFact 0 < ?n
GetFact (1 <= ?k, Arith_Thms.dvd_ineq2)
Set.singleton_iff@eqforward
WithFact ?b : {?a}
GetFact (?b = ?a, Set.singleton_iff@eqforward)
Set.singleton_iff@invbackward
WithGoal ?b : {?a}
GetGoal (?b = ?a, Set.singleton_iff@invbackward)
Set.empty_iff@eqforward
WithFact ?c : {}
GetResolve Set.empty_iff@eqforward
Rings.comm_monoid_mult_class.dvd_trans
WithFact ?a dvd ?b
WithFact ?b dvd ?c
GetFact (?a dvd ?c, Rings.comm_monoid_mult_class.dvd_trans) + 3 filters
Set_Thms.set_membership_distinct
WithFact ?x : ?s
WithGoal ?y : ?s
GetGoal (?x = ?y, Set_Thms.set_membership_distinct)
Nat.dvd_antisym
WithFact ?m dvd ?n
WithFact ?n dvd ?m
GetFact (?m = ?n, Nat.dvd_antisym) + 1 filters
Set_Thms.non_empty_exist_elt@back
WithGoal EX x. x : ?U
GetFact (?U = {}, Set_Thms.non_empty_exist_elt@back)
Arith_Thms.dvd_cancel@back1
WithGoal ?a dvd ?b
WithFact ?a * ?c dvd ?b * ?c
GetGoal (0 < ?c, Arith_Thms.dvd_cancel@back1)
Set_Thms.non_univ_exist_compl@back
WithGoal EX x. x ~: ?U
GetFact (?U = UNIV, Set_Thms.non_univ_exist_compl@back)
Rings.comm_semiring_1_cancel_class.dvd_add_right_iff@eqforward
WithFact ?a dvd ?b
WithFact ?a dvd ?b + ?c
GetFact (?a dvd ?c, Rings.comm_semiring_1_cancel_class.dvd_add_right_iff@eqforward)
Set.UNIV_I@res
WithGoal ?x : UNIV
GetResolve Set.UNIV_I@res
Rings.comm_monoid_mult_class.dvd_refl@res
WithGoal ?a dvd ?a
GetResolve Rings.comm_monoid_mult_class.dvd_refl@res
Arith_Thms.exists_n_dvd_n@back
WithGoal EX k. k dvd ?n & ?P k
GetGoal (?P ?n, Arith_Thms.exists_n_dvd_n@back)
Set.insert_iff@eqbackward@back
WithGoal ?a : insert ?b ?A
GetGoal (?a = ?b | ?a : ?A, Set.insert_iff@eqbackward@back) + 1 filters
Rings.comm_monoid_mult_class.one_dvd@res
WithGoal (1::?'a) dvd ?a
GetResolve Rings.comm_monoid_mult_class.one_dvd@res
Arith_Thms.any_n_dvd_0
WithGoal EX k. k dvd 0 & ?P k
GetGoal (EX k. ?P k, Arith_Thms.any_n_dvd_0)
Set.insert_iff@eqforward
WithFact ?a : insert ?b ?A
WithScore 500
GetFact (?a = ?b | ?a : ?A, Set.insert_iff@eqforward) + 1 filters
Arith_Thms.n_dvd_one
WithFact is_unit ?n
GetFact (?n = 1, Arith_Thms.n_dvd_one) + 1 filters
Set.insert_subset@eqforward
WithFact insert ?x ?A <= ?B
GetFact (?x : ?B & ?A <= ?B, Set.insert_subset@eqforward) + 1 filters
Rings.mult_zero_class.mult_zero_left
WithTerm (0::?'a) * ?a
GetFact ((0::?'a) * ?a = (0::?'a), Rings.mult_zero_class.mult_zero_left)
Arith_Thms.prod_ineqs1
WithFact 0 < ?m * ?k
GetFact (0 < ?m & 0 < ?k, Arith_Thms.prod_ineqs1)
Set.insert_subset@eqbackward@back
WithGoal insert ?x ?A <= ?B
WithScore 500
GetGoal (?x : ?B & ?A <= ?B, Set.insert_subset@eqbackward@back) + 1 filters
Arith_Thms.prod_ineqs2@back
WithGoal ?m <= ?m * ?k
GetGoal (0 < ?k, Arith_Thms.prod_ineqs2@back)
Set_Thms.set_ext
WithFact ALL a. (a : ?S) = (a : ?T)
GetFact (?S = ?T, Set_Thms.set_ext)
Arith_Thms.prod_cancel
WithFact ?a * ?b = ?a * ?c
WithFact 0 < ?a
GetFact (?b = ?c, Arith_Thms.prod_cancel) + 1 filters
Set_Thms.set_ext@back
WithGoal ?S = ?T
WithScore 500
GetGoal (ALL a. (a : ?S) = (a : ?T), Set_Thms.set_ext@back) + 1 filters
Set_Thms.set_pair_ext
WithFact ALL a b. ((a, b) : ?S) = ((a, b) : ?T)
GetFact (?S = ?T, Set_Thms.set_pair_ext)
Arith_Thms.mult_n1n
WithFact ?n = ?m * ?n
WithFact 0 < ?n
GetFact (?m = 1, Arith_Thms.mult_n1n) + 1 filters
Arith_Thms.prod_is_one
WithFact ?x * ?y = 1
GetFact (?x = 1, Arith_Thms.prod_is_one)
Set.Un_iff@eqforward
WithFact ?c : ?A Un ?B
WithScore 500
GetFact (?c : ?A | ?c : ?B, Set.Un_iff@eqforward)
Arith_Thms.prod_dvd_intro@back
WithGoal ?k dvd ?m * ?n
GetGoal (?k dvd ?m | ?k dvd ?n, Arith_Thms.prod_dvd_intro@back)
Set.Un_iff@eqbackward@back
WithGoal ?c : ?A Un ?B
GetGoal (?c : ?A | ?c : ?B, Set.Un_iff@eqbackward@back)
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
GCD.semiring_gcd_class.gcd_dvd1
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b dvd ?a, GCD.semiring_gcd_class.gcd_dvd1)
### theory "Draft.ExtrEqs"
### 1.114s elapsed time, 4.328s cpu time, 1.477s GC time
Set_Thms.UnD1
WithFact ?c : ?A Un ?B
WithGoal ?c : ?A
GetFact (?c : ?B, Set_Thms.UnD1)
GCD.semiring_gcd_class.gcd_dvd2
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b dvd ?b, GCD.semiring_gcd_class.gcd_dvd2)
Set_Thms.UnD2
WithFact ?c : ?A Un ?B
WithGoal ?c : ?B
GetFact (?c : ?A, Set_Thms.UnD2)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@eqforward
WithFact coprime ?a ?b
GetFact (gcd ?a ?b = (1::?'a), GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@eqforward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@invbackward
WithGoal coprime ?a ?b
GetGoal (gcd ?a ?b = (1::?'a), GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@invbackward)
Set_Thms.UnD1_single
WithFact ?c : {?a} Un ?B
WithGoal ?c = ?a
GetFact (?c : ?B, Set_Thms.UnD1_single)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@eqforward
WithFact gcd ?a ?b = (1::?'a)
GetFact (coprime ?a ?b, GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@eqforward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@invbackward
WithGoal gcd ?a ?b = (1::?'a)
GetGoal (coprime ?a ?b, GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@invbackward)
Arith_Thms.coprime_exp@back
WithGoal coprime ?d (?a ^ ?n)
GetGoal (coprime ?d ?a, Arith_Thms.coprime_exp@back)
Set_Thms.UnD2_single
WithFact ?c : ?A Un {?b}
WithGoal ?c = ?b
GetFact (?c : ?A, Set_Thms.UnD2_single)
Arith_Thms.coprime_exp@back
WithGoal coprime ?d (?a ^ ?n)
GetGoal (coprime ?d ?a, Arith_Thms.coprime_exp@back)
Set.UnI1
WithTerm ?A Un ?B
WithFact ?c : ?A
GetFact (?c : ?A Un ?B, Set.UnI1)
GCD.semiring_gcd_class.gcd.commute
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b = gcd ?b ?a, GCD.semiring_gcd_class.gcd.commute)
Set.UnI2
WithTerm ?A Un ?B
WithFact ?c : ?B
GetFact (?c : ?A Un ?B, Set.UnI2)
Arith_Thms.coprime_dvd_mult@back1
WithGoal ?a dvd ?c
WithFact ?a dvd ?c * ?b
GetGoal (coprime ?a ?b, Arith_Thms.coprime_dvd_mult@back1)
Arith_Thms.coprime_dvd_mult'@back1
WithGoal ?a dvd ?c
WithFact ?a dvd ?b * ?c
GetGoal (coprime ?a ?b, Arith_Thms.coprime_dvd_mult'@back1)
Arith_Thms.coprime_dvd
WithFact coprime ?a ?b
WithFact ?p dvd ?a
GetFact (1 < ?p --> ~ ?p dvd ?b, Arith_Thms.coprime_dvd)
Set_Thms.UnI1_single
WithTerm {?a} Un ?B
GetFact (?a : {?a} Un ?B, Set_Thms.UnI1_single)
Power.power_class.power.power_0
WithTerm ?a ^ 0
GetFact (?a ^ 0 = (1::?'a), Power.power_class.power.power_0)
Arith_Thms.power_ge_0
WithTerm ?p ^ ?m
WithGoal ?m = 0
GetFact (?p ^ ?m = ?p * ?p ^ (?m - 1), Arith_Thms.power_ge_0)
Set_Thms.UnI2_single
WithTerm ?A Un {?b}
GetFact (?b : ?A Un {?b}, Set_Thms.UnI2_single)
Power.monoid_mult_class.power_one
WithTerm (1::?'a) ^ ?n
GetFact ((1::?'a) ^ ?n = (1::?'a), Power.monoid_mult_class.power_one) + 1 filters
Set_Thms.union_single_eq
WithTerm {?x} Un ?p
WithFact ?x : ?p
GetFact ({?x} Un ?p = ?p, Set_Thms.union_single_eq)
Set_Thms.union_single_eq@back
WithGoal {?x} Un ?p = ?p
GetGoal (?x : ?p, Set_Thms.union_single_eq@back)
Power.monoid_mult_class.power_one_right
WithTerm ?a ^ 1
GetFact (?a ^ 1 = ?a, Power.monoid_mult_class.power_one_right) + 1 filters
Set.Int_iff@eqforward
WithFact ?c : ?A Int ?B
GetFact (?c : ?A & ?c : ?B, Set.Int_iff@eqforward)
Arith_Thms.one_is_power_of_any@res
WithGoal EX i. 1 = ?a ^ i
GetResolve Arith_Thms.one_is_power_of_any@res
Set.Int_iff@eqbackward@back
WithGoal ?c : ?A Int ?B
WithScore 500
GetGoal (?c : ?A & ?c : ?B, Set.Int_iff@eqbackward@back)
Power.power_class.power.power_Suc
WithTerm ?a ^ Suc ?n
GetFact (?a ^ Suc ?n = ?a * ?a ^ ?n, Power.power_class.power.power_Suc)
Arith_Thms.power_dvd
WithFact ?p ^ ?n dvd ?a
WithGoal ?n = 0
GetFact (?p dvd ?a, Arith_Thms.power_dvd)
Set.Int_empty_left
WithTerm {} Int ?B
GetFact ({} Int ?B = {}, Set.Int_empty_left)
Set.Int_empty_right
WithTerm ?A Int {}
GetFact (?A Int {} = {}, Set.Int_empty_right)
Arith_Thms.power_eq_one
WithFact ?b ^ ?n = 1
GetFact (?b = 1 | ?n = 0, Arith_Thms.power_eq_one) + 2 filters
Set.Int_absorb
WithTerm ?A Int ?A
GetFact (?A Int ?A = ?A, Set.Int_absorb)
Arith_Thms.fact_ge_1_nat
WithTerm fact ?n
GetFact (1 <= fact ?n, Arith_Thms.fact_ge_1_nat)
Set_Thms.set_disjoint_mp
WithFact ?A Int ?B = {}
WithFact ?p : ?A
GetGoal (?p : ?B, Set_Thms.set_disjoint_mp)
Set_Thms.set_disjoint_mp@back2
WithFact ?p : ?B
WithFact ?A Int ?B = {}
GetGoal (?p : ?A, Set_Thms.set_disjoint_mp@back2)
Factorial.dvd_fact@back1
WithGoal ?m dvd fact ?n
WithFact ?m <= ?n
GetGoal (1 <= ?m, Factorial.dvd_fact@back1)
Nat.Suc_eq_plus1
WithTerm Suc ?n
GetFact (Suc ?n = ?n + 1, Nat.Suc_eq_plus1)
Set_Thms.set_disjoint_single@eqforward
WithFact {?x} Int ?B = {}
GetGoal (?x : ?B, Set_Thms.set_disjoint_single@eqforward)
Set_Thms.set_disjoint_single@invbackward
WithGoal {?x} Int ?B = {}
GetFact (?x : ?B, Set_Thms.set_disjoint_single@invbackward)
Nat.gr0_implies_Suc@back
WithGoal EX m. ?n = Suc m
GetGoal (0 < ?n, Nat.gr0_implies_Suc@back)
Set.subsetI
WithFact ALL x. x : ?A --> x : ?B
GetFact (?A <= ?B, Set.subsetI)
Nat.nat.case_1
WithTerm case 0 of 0 => ?f1.0 | Suc x => ?f2.0 x
GetFact ((case 0 of 0 => ?f1.0 | Suc x => ?f2.0 x) = ?f1.0, Nat.nat.case_1)
Nat.nat.case_2
WithTerm case Suc ?x2.0 of 0 => ?f1.0 | Suc x => ?f2.0 x
GetFact ((case Suc ?x2.0 of 0 => ?f1.0 | Suc x => ?f2.0 x) = ?f2.0 ?x2.0, Nat.nat.case_2)
Euclidean_Division.times_div_less_eq_dividend@res
WithGoal ?n * (?m div ?n) <= ?m
GetResolve Euclidean_Division.times_div_less_eq_dividend@res
Set.subsetI@back
WithGoal ?A <= ?B
WithScore 500
GetGoal (ALL x. x : ?A --> x : ?B, Set.subsetI@back)
Nat.nat_less_induct
Substitution: ?n, ALL m<?n. ?P m
Set.empty_subsetI@res
WithGoal {} <= ?A
GetResolve Set.empty_subsetI@res
### theory "Auto2_HOL.Arith_Thms"
### 2.128s elapsed time, 8.079s cpu time, 2.828s GC time
Set.subsetD
WithFact ?A <= ?B
WithFact ?c : ?A
GetFact (?c : ?B, Set.subsetD)
Set_Thms.subset_single@eqforward
WithFact {?a} <= ?B
GetFact (?a : ?B, Set_Thms.subset_single@eqforward)
Set_Thms.subset_single@invbackward
WithGoal {?a} <= ?B
GetGoal (?a : ?B, Set_Thms.subset_single@invbackward)
Set.basic_monos_1@res
WithGoal ?A <= ?A
GetResolve Set.basic_monos_1@res
Set.Un_upper1@res
WithGoal ?A <= ?A Un ?B
GetResolve Set.Un_upper1@res
Set.Un_upper2@res
WithGoal ?B <= ?A Un ?B
GetResolve Set.Un_upper2@res
Set_Thms.union_is_subset
WithFact ?A Un ?B <= ?C
GetFact (?A <= ?C & ?B <= ?C, Set_Thms.union_is_subset)
Set.Un_least@back1
WithGoal ?A Un ?B <= ?C
WithFact ?B <= ?C
GetGoal (?A <= ?C, Set.Un_least@back1)
Set.Un_least@back2
WithGoal ?A Un ?B <= ?C
WithFact ?A <= ?C
GetGoal (?B <= ?C, Set.Un_least@back2)
Set_Thms.subset_union_same1@back
WithGoal ?A Un ?B <= ?A Un ?C
GetGoal (?B <= ?C, Set_Thms.subset_union_same1@back)
Set_Thms.subset_union_same2@back
WithGoal ?A Un ?C <= ?B Un ?C
GetGoal (?A <= ?B, Set_Thms.subset_union_same2@back)
Set.Diff_iff@eqforward
WithFact ?c : ?A - ?B
GetFact (?c : ?A & ?c ~: ?B, Set.Diff_iff@eqforward)
Set.Diff_iff@eqbackward@back
WithGoal ?c : ?A - ?B
WithScore 500
GetGoal (?c : ?A & ?c ~: ?B, Set.Diff_iff@eqbackward@back)
Set.empty_Diff
WithTerm {} - ?A
GetFact ({} - ?A = {}, Set.empty_Diff)
Set_Thms.mem_diff@eqforward
WithFact ?x : ?A - ?B
GetFact (?x : ?A & ?x ~: ?B, Set_Thms.mem_diff@eqforward)
Set_Thms.mem_diff@invbackward
WithGoal ?x : ?A - ?B
GetGoal (?x : ?A & ?x ~: ?B, Set_Thms.mem_diff@invbackward)
Set_Thms.set_union_minus_same1
WithTerm ?A Un ?B - ?B
GetFact (?A Un ?B - ?B = ?A - ?B, Set_Thms.set_union_minus_same1)
Set_Thms.set_union_minus_same2
WithTerm ?B Un ?A - ?B
GetFact (?B Un ?A - ?B = ?A - ?B, Set_Thms.set_union_minus_same2)
Set_Thms.set_union_minus_distinct
WithTerm {?a} Un (?B - {?c})
WithGoal ?a = ?c
GetFact ({?a} Un (?B - {?c}) = {?a} Un ?B - {?c}, Set_Thms.set_union_minus_distinct)
Set.Diff_subset
WithTerm ?A - ?B
GetFact (?A - ?B <= ?A, Set.Diff_subset)
Set_Thms.union_subtract_elt1
WithTerm {?x} Un ?B - {?x}
WithGoal ?x : ?B
GetFact ({?x} Un ?B - {?x} = ?B, Set_Thms.union_subtract_elt1)
Set_Thms.union_subtract_elt2
WithTerm ?B Un {?x} - {?x}
WithGoal ?x : ?B
GetFact (?B Un {?x} - {?x} = ?B, Set_Thms.union_subtract_elt2)
Set_Thms.subset_sub1@back
WithGoal ?A - {?x} < ?A
GetGoal (?x : ?A, Set_Thms.subset_sub1@back)
Set_Thms.member_notin
WithFact ?x : ?S - {?y}
GetGoal (?x = ?y, Set_Thms.member_notin)
Set_Thms.member_notin_contra
WithTerm ?S - {?y}
WithFact ?x : ?S
GetFact (?x ~= ?y --> ?x : ?S - {?y}, Set_Thms.member_notin_contra)
Finite_Set.finite.emptyI@res
WithGoal finite {}
GetResolve Finite_Set.finite.emptyI@res
Set_Thms.set_finite_single@res
WithGoal finite {?x}
GetResolve Set_Thms.set_finite_single@res
Finite_Set.finite_Un@eqforward
WithFact finite (?F Un ?G)
GetFact (finite ?F & finite ?G, Finite_Set.finite_Un@eqforward)
Finite_Set.finite_Un@invbackward
WithGoal finite (?F Un ?G)
GetGoal (finite ?F & finite ?G, Finite_Set.finite_Un@invbackward)
Set_Thms.Max_ge'
WithProperty finite ?A
WithFact Max ?A < ?x
GetGoal (?x : ?A, Set_Thms.Max_ge')
Finite_Set.finite_image_set@back
WithGoal finite {?f x |x. ?P x}
GetGoal (finite {x. ?P x}, Finite_Set.finite_image_set@back)
Add property rule for function Set_Interval.ord_class.atLeastAtMost
Finite_Set.rev_finite_subset
WithProperty finite ?B
WithFact ?A <= ?B
GetFact (finite ?A, Finite_Set.rev_finite_subset)
Finite_Set.rev_finite_subset@back1
WithGoal finite ?A
WithFact ?A <= ?B
GetGoal (finite ?B, Finite_Set.rev_finite_subset@back1)
Finite_Set.card.empty
WithTerm card {}
GetFact (card {} = 0, Finite_Set.card.empty)
Set_Thms.card_emptyD
WithProperty finite ?S
WithTerm ?S
WithFact card ?S = 0
GetFact (?S = {}, Set_Thms.card_emptyD)
Set_Thms.card_minus1
WithTerm card (?S - {?x})
WithFact ?x : ?S
GetFact (card (?S - {?x}) = card ?S - 1, Set_Thms.card_minus1)
Add property rule for function Groups.minus_class.minus
Finite_Set.card_mono@res
WithProperty finite ?B
WithGoal card ?A <= card ?B
WithFact ?A <= ?B
GetResolve Finite_Set.card_mono@res
Set.image_Un
WithTerm ?f ` (?A Un ?B)
GetFact (?f ` (?A Un ?B) = ?f ` ?A Un ?f ` ?B, Set.image_Un)
Fun.image_set_diff
WithTerm ?f ` (?A - ?B)
WithFact inj ?f
GetFact (?f ` (?A - ?B) = ?f ` ?A - ?f ` ?B, Fun.image_set_diff)
Set_Thms.mset_member_empty@res
WithFact ?p :# {#}
GetResolve Set_Thms.mset_member_empty@res
Set_Thms.mem_multiset_single@eqforward
WithFact ?x :# {#?y#}
GetFact (?x = ?y, Set_Thms.mem_multiset_single@eqforward)
Set_Thms.mem_multiset_single@invbackward
WithGoal ?x :# {#?y#}
GetGoal (?x = ?y, Set_Thms.mem_multiset_single@invbackward)
Multiset.subset_mset.antisym@back2
WithGoal ?a = ?b
WithFact ?a <=# ?b
GetGoal (?b <=# ?a, Multiset.subset_mset.antisym@back2)
Multiset.empty_le@res
WithGoal {#} <=# ?A
GetResolve Multiset.empty_le@res
Multiset.mset_subsetD
WithFact ?A <# ?B
WithFact ?x :# ?A
GetFact (?x :# ?B, Multiset.mset_subsetD)
Set_Thms.multi_contain_add_self1@res
WithGoal ?A <# {#?x#} + ?A
GetResolve Set_Thms.multi_contain_add_self1@res
Set_Thms.multi_contain_add_self2@res
WithGoal ?A <# ?A + {#?x#}
GetResolve Set_Thms.multi_contain_add_self2@res
Multiset.multi_member_this
WithTerm {#?x#} + ?XS
GetFact (?x :# {#?x#} + ?XS, Multiset.multi_member_this)
Set_Thms.multi_member_this2
WithTerm ?XS + {#?x#}
GetFact (?x :# ?XS + {#?x#}, Set_Thms.multi_member_this2)
Multiset.subset_mset.add_left_mono@back
WithGoal ?c + ?a <=# ?c + ?b
GetGoal (?a <=# ?b, Multiset.subset_mset.add_left_mono@back)
Multiset.subset_mset.add_right_mono@back
WithGoal ?a + ?c <=# ?b + ?c
GetGoal (?a <=# ?b, Multiset.subset_mset.add_right_mono@back)
Set_Thms.multi_nonempty_split'@res
WithGoal EX M' m. ?M = M' + {#m#}
WithGoal ?M = {#}
GetResolve Set_Thms.multi_nonempty_split'@res
Set_Thms.multi_member_split'@back
WithGoal EX M'. ?M = M' + {#?x#}
GetGoal (?x :# ?M, Set_Thms.multi_member_split'@back)
Multiset.full_multiset_induct
Substitution: ?B, ALL A. A <# ?B --> ?P A
consts
  execute :: "'a Heap => heap => ('a * heap) option"
Multiset.set_mset_empty
WithTerm set_mset {#}
GetFact (set_mset {#} = {}, Multiset.set_mset_empty)
Multiset.set_mset_single
WithTerm set_mset {#?b#}
GetFact (set_mset {#?b#} = {?b}, Multiset.set_mset_single)
Multiset.set_mset_union
WithTerm set_mset (?M + ?N)
GetFact (set_mset (?M + ?N) = set_mset ?M Un set_mset ?N, Multiset.set_mset_union)
Multiset.image_mset_empty
WithTerm image_mset ?f {#}
GetFact (image_mset ?f {#} = {#}, Multiset.image_mset_empty)
Multiset.image_mset_single
WithTerm image_mset ?f {#?x#}
GetFact (image_mset ?f {#?x#} = {#?f ?x#}, Multiset.image_mset_single)
Multiset.image_mset_union
WithTerm image_mset ?f (?M + ?N)
GetFact (image_mset ?f (?M + ?N) = image_mset ?f ?M + image_mset ?f ?N, Multiset.image_mset_union)
Multiset.comm_monoid_mult_class.prod_mset_empty
WithTerm \<Prod>\<^sub># {#}
GetFact (\<Prod>\<^sub># {#} = (1::?'a), Multiset.comm_monoid_mult_class.prod_mset_empty)
Multiset.comm_monoid_mult_class.prod_mset_singleton
WithTerm \<Prod>\<^sub># {#?x#}
GetFact (\<Prod>\<^sub># {#?x#} = ?x, Multiset.comm_monoid_mult_class.prod_mset_singleton)
Multiset.comm_monoid_mult_class.prod_mset_Un
WithTerm \<Prod>\<^sub># (?A + ?B)
GetFact (\<Prod>\<^sub># (?A + ?B) = \<Prod>\<^sub># ?A * \<Prod>\<^sub># ?B, Multiset.comm_monoid_mult_class.prod_mset_Un)
Set_Interval.ord_class.lessThan_iff@eqforward
WithFact ?i : {..<?k}
GetFact (?i < ?k, Set_Interval.ord_class.lessThan_iff@eqforward)
Set_Interval.ord_class.lessThan_iff@invbackward
WithGoal ?i : {..<?k}
GetGoal (?i < ?k, Set_Interval.ord_class.lessThan_iff@invbackward)
Set_Interval.ord_class.atLeastAtMost_iff@eqforward
WithFact ?i : {?l..?u}
GetFact (?l <= ?i & ?i <= ?u, Set_Interval.ord_class.atLeastAtMost_iff@eqforward)
Set_Interval.ord_class.atLeastAtMost_iff@invbackward
WithGoal ?i : {?l..?u}
GetGoal (?l <= ?i & ?i <= ?u, Set_Interval.ord_class.atLeastAtMost_iff@invbackward)
### theory "Auto2_HOL.Set_Thms"
### 0.923s elapsed time, 3.171s cpu time, 1.378s GC time
Loading theory "Auto2_HOL.Lists_Thms" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main")
List.list.distinct_2@res
WithFact ?x21.0 # ?x22.0 = []
GetResolve List.list.distinct_2@res
List.list.simps_1@eqforward
WithFact ?x21.0 # ?x22.0 = ?y21.0 # ?y22.0
GetFact (?x21.0 = ?y21.0 & ?x22.0 = ?y22.0, List.list.simps_1@eqforward)
List.list.sel_1
WithTerm hd (?x21.0 # ?x22.0)
GetFact (hd (?x21.0 # ?x22.0) = ?x21.0, List.list.sel_1)
List.list.sel_2
WithTerm tl []
GetFact (tl [] = [], List.list.sel_2)
List.list.sel_3
WithTerm tl (?x21.0 # ?x22.0)
GetFact (tl (?x21.0 # ?x22.0) = ?x22.0, List.list.sel_3)
List.list.collapse
WithTerm hd ?list # tl ?list
WithGoal ?list = []
GetFact (hd ?list # tl ?list = ?list, List.list.collapse)
List.list.size_3
WithTerm length []
GetFact (length [] = 0, List.list.size_3)
Lists_Thms.length_one
WithTerm length [?x]
GetFact (length [?x] = 1, Lists_Thms.length_one)
Lists_Thms.length_Cons
WithTerm length (?a # ?b)
GetFact (length (?a # ?b) = length ?b + 1, Lists_Thms.length_Cons)
Lists_Thms.length_snoc
WithTerm length (?xs @ [?x])
GetFact (length (?xs @ [?x]) = length ?xs + 1, Lists_Thms.length_snoc)
Lists_Thms.length_zero_is_nil
WithFact length ?xs = 0
GetFact (?xs = [], Lists_Thms.length_zero_is_nil)
Lists_Thms.length_gt_zero
WithFact 0 < length ?xs
GetGoal (?xs = [], Lists_Thms.length_gt_zero)
List.length_append
WithTerm length (?xs @ ?ys)
GetFact (length (?xs @ ?ys) = length ?xs + length ?ys, List.length_append)
List.append.simps_2
WithTerm (?x # ?xs) @ ?ys
GetFact ((?x # ?xs) @ ?ys = ?x # ?xs @ ?ys, List.append.simps_2) + 1 filters
List.hd_append2
WithTerm hd (?xs @ ?ys)
WithGoal ?xs = []
GetFact (hd (?xs @ ?ys) = hd ?xs, List.hd_append2)
Lists_Thms.append_is_empty
WithFact ?xs @ ?ys = []
GetFact (?xs = [] & ?ys = [], Lists_Thms.append_is_empty)
Lists_Thms.cons_to_append@sym
WithTerm [?a] @ ?b
GetFact ([?a] @ ?b = ?a # ?b, Lists_Thms.cons_to_append@sym)
signature LIST_AC =
  sig
    val add_list_proofsteps: theory -> theory
    val append_const: typ -> term
    val case_head: typ -> term -> heads
    val dest_list_full: Proof.context -> typ -> cterm -> cterm list
    val get_list_head_equiv:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val get_list_ty: term -> typ option
    datatype heads = LIST_APPEND | LIST_CONS | LIST_NIL | LIST_OTHER
    val is_list_head: typ -> term -> bool
    val list_expand:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val list_expand_equiv: proofstep
    val list_expand_once:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val list_expand_unit: proofstep
    val normalize_list: typ -> conv
    val normalize_list_assoc: typ -> conv
    val rewrite_on_eqs: typ -> thm list -> cterm -> thm
    val simp_list_expr:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
  end
structure List_AC: LIST_AC
val test_norm_t = fn: string -> string * string -> unit
val test = [(), (), (), (), (), (), (), (), (), (), (), ()]: unit list
List.nth_equalityI@back2
WithGoal ?xs = ?ys
WithFact length ?xs = length ?ys
GetGoal (ALL i<length ?xs. ?xs ! i = ?ys ! i, List.nth_equalityI@back2) + 1 filters
List.set_simps_1
WithTerm set []
GetFact (set [] = {}, List.set_simps_1)
Lists_Thms.set_one
WithTerm set [?u]
GetFact (set [?u] = {?u}, Lists_Thms.set_one)
Lists_Thms.set_two
WithTerm set [?u, ?v]
GetFact (set [?u, ?v] = {?u, ?v}, Lists_Thms.set_two)
Lists_Thms.set_simps2
WithTerm set (?x # ?xs)
GetFact (set (?x # ?xs) = {?x} Un set ?xs, Lists_Thms.set_simps2) + 2 filters
List.set_append
WithTerm set (?xs @ ?ys)
GetFact (set (?xs @ ?ys) = set ?xs Un set ?ys, List.set_append)
List.set_rev
WithTerm set (rev ?xs)
GetFact (set (rev ?xs) = set ?xs, List.set_rev)
List.finite_set@res
WithGoal finite (set ?xs)
GetResolve List.finite_set@res
List.in_set_conv_nth@eqforward@back
WithGoal EX i<length ?xs. ?xs ! i = ?x
GetGoal (?x : set ?xs, List.in_set_conv_nth@eqforward@back)
List.hd_in_set
WithWellForm ?xs ~= []
WithTerm hd ?xs
GetFact (hd ?xs : set ?xs, List.hd_in_set)
List.length_tl
WithTerm length (tl ?xs)
GetFact (length (tl ?xs) = length ?xs - 1, List.length_tl)
Lists_Thms.nth_tl'
WithTerm tl ?xs ! ?i
WithFact ?i < length (tl ?xs)
GetFact (tl ?xs ! ?i = ?xs ! (?i + 1), Lists_Thms.nth_tl')
Lists_Thms.set_tl_subset
WithTerm set (tl ?xs)
GetFact (set (tl ?xs) <= set ?xs, Lists_Thms.set_tl_subset)
List.nth_case
WithTerm ?xs ! ?i
CreateConcl ?i < length ?xs
List.hd_conv_nth@sym
WithTerm ?xs ! 0
WithGoal ?xs = []
GetFact (?xs ! 0 = hd ?xs, List.hd_conv_nth@sym)
List.nth_Cons'
WithTerm (?x # ?xs) ! ?n
GetFact ((?x # ?xs) ! ?n = (if ?n = 0 then ?x else ?xs ! (?n - 1)), List.nth_Cons')
List.nth_append
WithTerm (?xs @ ?ys) ! ?n
GetFact ((?xs @ ?ys) ! ?n =
(if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs)), List.nth_append)
List.nth_mem
WithWellForm ?n < length ?xs
WithTerm ?xs ! ?n
GetFact (?xs ! ?n : set ?xs, List.nth_mem)
Lists_Thms.sorted_Nil@res
WithGoal Lists_Thms.sorted []
GetResolve Lists_Thms.sorted_Nil@res
Lists_Thms.sorted_single@res
WithGoal Lists_Thms.sorted [?x]
GetResolve Lists_Thms.sorted_single@res
Lists_Thms.sorted_simps2@eqbackward@back
WithGoal Lists_Thms.sorted (?x # ?ys)
GetGoal (Ball (set ?ys) ((<=) ?x) & Lists_Thms.sorted ?ys, Lists_Thms.sorted_simps2@eqbackward@back)
Lists_Thms.sorted_ConsD1
WithFact Lists_Thms.sorted (?x # ?xs)
GetFact (Lists_Thms.sorted ?xs, Lists_Thms.sorted_ConsD1)
Lists_Thms.sorted_ConsD2
WithFact Lists_Thms.sorted (?x # ?xs)
WithFact ?y : set ?xs
GetFact (?x <= ?y, Lists_Thms.sorted_ConsD2)
Lists_Thms.sorted_ConsD2@back2
WithGoal ?x <= ?y
WithFact Lists_Thms.sorted (?x # ?xs)
GetGoal (?y : set ?xs, Lists_Thms.sorted_ConsD2@back2)
Lists_Thms.sorted_appendI@back
WithGoal Lists_Thms.sorted (?xs @ ?ys)
GetGoal (Lists_Thms.sorted ?xs &
Lists_Thms.sorted ?ys & (ALL x:set ?xs. ALL y:set ?ys. x <= y), Lists_Thms.sorted_appendI@back)
Lists_Thms.sorted_appendE
WithFact Lists_Thms.sorted (?xs @ ?ys)
GetFact (Lists_Thms.sorted ?xs & Lists_Thms.sorted ?ys, Lists_Thms.sorted_appendE)
Lists_Thms.sorted_appendE2
WithFact Lists_Thms.sorted (?xs @ ?ys)
WithFact ?x : set ?xs
GetFact (ALL y:set ?ys. ?x <= y, Lists_Thms.sorted_appendE2)
Lists_Thms.sorted_nth_mono'@back
WithProperty Lists_Thms.sorted ?xs
WithWellForm ?j < length ?xs
WithGoal ?xs ! ?i <= ?xs ! ?j
GetGoal (?i <= ?j, Lists_Thms.sorted_nth_mono'@back)
Lists_Thms.sorted_nth_mono_less
WithProperty Lists_Thms.sorted ?xs
WithWellForm ?i < length ?xs
WithFact ?xs ! ?i < ?xs ! ?j
GetFact (?i < ?j, Lists_Thms.sorted_nth_mono_less)
Lists_Thms.sorted_sort
WithTerm sort ?xs
GetFact (Lists_Thms.sorted (sort ?xs), Lists_Thms.sorted_sort)
List.linorder_class.length_sort
WithTerm length (sort_key ?f ?xs)
GetFact (length (sort_key ?f ?xs) = length ?xs, List.linorder_class.length_sort)
Multiset.linorder_class.mset_sort
WithTerm mset (sort_key ?k ?xs)
GetFact (mset (sort_key ?k ?xs) = mset ?xs, Multiset.linorder_class.mset_sort)
List.linorder_class.set_sort
WithTerm set (sort_key ?f ?xs)
GetFact (set (sort_key ?f ?xs) = set ?xs, List.linorder_class.set_sort)
Lists_Thms.properties_for_sort@back
WithGoal sort ?xs = ?ys
GetGoal (mset ?ys = mset ?xs & Lists_Thms.sorted ?ys, Lists_Thms.properties_for_sort@back)
Lists_Thms.sort_Nil
WithTerm sort []
GetFact (sort [] = [], Lists_Thms.sort_Nil)
Lists_Thms.sort_singleton
WithTerm sort [?a]
GetFact (sort [?a] = [?a], Lists_Thms.sort_singleton)
Lists_Thms.distinct_Nil@res
WithGoal distinct []
GetResolve Lists_Thms.distinct_Nil@res
List.distinct_singleton@res
WithGoal distinct [?x]
GetResolve List.distinct_singleton@res
List.distinct.simps_2@eqforward
WithFact distinct (?x # ?xs)
GetFact (?x ~: set ?xs & distinct ?xs, List.distinct.simps_2@eqforward) + 1 filters
List.distinct.simps_2@invbackward
WithGoal distinct (?x # ?xs)
GetGoal (?x ~: set ?xs & distinct ?xs, List.distinct.simps_2@invbackward) + 1 filters
List.distinct_append@eqforward
WithFact distinct (?xs @ ?ys)
GetFact (distinct ?xs & distinct ?ys & set ?xs Int set ?ys = {}, List.distinct_append@eqforward)
List.distinct_append@invbackward
WithGoal distinct (?xs @ ?ys)
GetGoal (distinct ?xs & distinct ?ys & set ?xs Int set ?ys = {}, List.distinct_append@invbackward)
List.distinct_rev@eqforward
WithFact distinct (rev ?xs)
GetFact (distinct ?xs, List.distinct_rev@eqforward)
List.distinct_rev@invbackward
WithGoal distinct (rev ?xs)
GetGoal (distinct ?xs, List.distinct_rev@invbackward)
List.linorder_class.distinct_sort@eqforward
WithFact distinct (sort_key ?f ?xs)
GetFact (distinct ?xs, List.linorder_class.distinct_sort@eqforward)
List.linorder_class.distinct_sort@invbackward
WithGoal distinct (sort_key ?f ?xs)
GetGoal (distinct ?xs, List.linorder_class.distinct_sort@invbackward)
List.distinct_conv_nth@eqbackward@res
WithGoal distinct ?xs
WithFact ALL i<length ?xs. ALL j<length ?xs. i ~= j --> ?xs ! i ~= ?xs ! j
GetResolve List.distinct_conv_nth@eqbackward@res
Lists_Thms.distinct_nthE
WithProperty distinct ?xs
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithFact ?xs ! ?i = ?xs ! ?j
GetFact (?i = ?j, Lists_Thms.distinct_nthE)
List.list.map_1
WithTerm map ?f []
GetFact (map ?f [] = [], List.list.map_1)
List.list.map_2
WithTerm map ?f (?x21.0 # ?x22.0)
GetFact (map ?f (?x21.0 # ?x22.0) = ?f ?x21.0 # map ?f ?x22.0, List.list.map_2)
List.length_map
WithTerm length (map ?f ?xs)
GetFact (length (map ?f ?xs) = length ?xs, List.length_map)
List.nth_map
WithTerm map ?f ?xs ! ?n
WithFact ?n < length ?xs
GetFact (map ?f ?xs ! ?n = ?f (?xs ! ?n), List.nth_map)
List.map_append
WithTerm map ?f (?xs @ ?ys)
GetFact (map ?f (?xs @ ?ys) = map ?f ?xs @ map ?f ?ys, List.map_append)
List.length_replicate
WithTerm replicate ?n ?x
GetFact (length (replicate ?n ?x) = ?n, List.length_replicate)
List.nth_replicate
WithTerm replicate ?n ?x ! ?i
WithFact ?i < ?n
GetFact (replicate ?n ?x ! ?i = ?x, List.nth_replicate)
Lists_Thms.last_eval1
WithTerm last [?x]
GetFact (last [?x] = ?x, Lists_Thms.last_eval1)
Lists_Thms.last_eval2
WithTerm last [?u, ?v]
GetFact (last [?u, ?v] = ?v, Lists_Thms.last_eval2)
List.last_ConsR
WithTerm last (?x # ?xs)
WithGoal ?xs = []
GetFact (last (?x # ?xs) = last ?xs, List.last_ConsR)
List.last_appendR
WithTerm last (?xs @ ?ys)
WithGoal ?ys = []
GetFact (last (?xs @ ?ys) = last ?ys, List.last_appendR)
List.last_snoc
WithTerm last (?xs @ [?x])
GetFact (last (?xs @ [?x]) = ?x, List.last_snoc)
List.last_conv_nth@sym
WithTerm ?xs ! (length ?xs - 1)
WithGoal ?xs = []
GetFact (?xs ! (length ?xs - 1) = last ?xs, List.last_conv_nth@sym)
List.last_in_set
WithWellForm ?as ~= []
WithTerm last ?as
GetFact (last ?as : set ?as, List.last_in_set)
List.length_butlast
WithTerm butlast ?xs
GetFact (length (butlast ?xs) = length ?xs - 1, List.length_butlast)
List.nth_butlast
WithWellForm ?n < length (butlast ?xs)
WithTerm butlast ?xs ! ?n
GetFact (butlast ?xs ! ?n = ?xs ! ?n, List.nth_butlast)
List.butlast_conv_take@sym
WithTerm take (length ?xs - 1) ?xs
GetFact (take (length ?xs - 1) ?xs = butlast ?xs, List.butlast_conv_take@sym)
List.butlast_snoc
WithTerm butlast (?xs @ [?x])
GetFact (butlast (?xs @ [?x]) = ?xs, List.butlast_snoc)
Lists_Thms.butlast_eval1
WithTerm butlast [?x]
GetFact (butlast [?x] = [], Lists_Thms.butlast_eval1)
Lists_Thms.butlast_eval2
WithTerm butlast [?x, ?y]
GetFact (butlast [?x, ?y] = [?x], Lists_Thms.butlast_eval2)
Lists_Thms.butlast_cons
WithTerm butlast (?a # ?as)
WithGoal ?as = []
GetFact (butlast (?a # ?as) = ?a # butlast ?as, Lists_Thms.butlast_cons)
Lists_Thms.butlast_append'
WithTerm butlast (?as @ ?bs)
WithGoal ?bs = []
GetFact (butlast (?as @ ?bs) = ?as @ butlast ?bs, Lists_Thms.butlast_append')
List.append_butlast_last_id
WithWellForm ?xs ~= []
WithTerm butlast ?xs @ [last ?xs]
GetFact (butlast ?xs @ [last ?xs] = ?xs, List.append_butlast_last_id)
Lists_Thms.set_butlast_is_subset
WithTerm set (butlast ?xs)
GetFact (set (butlast ?xs) <= set ?xs, Lists_Thms.set_butlast_is_subset)
List.length_list_update
WithTerm ?xs[?i := ?x]
GetFact (length (?xs[?i := ?x]) = length ?xs, List.length_list_update)
List.nth_list_update_eq
WithWellForm ?i < length ?xs
WithTerm ?xs[?i := ?x] ! ?i
GetFact (?xs[?i := ?x] ! ?i = ?x, List.nth_list_update_eq)
List.nth_list_update_neq
WithTerm ?xs[?i := ?x] ! ?j
WithGoal ?i = ?j
GetFact (?xs[?i := ?x] ! ?j = ?xs ! ?j, List.nth_list_update_neq)
List.nth_list_update
WithWellForm ?i < length ?xs
WithTerm ?xs[?i := ?x] ! ?j
GetFact (?xs[?i := ?x] ! ?j = (if ?i = ?j then ?x else ?xs ! ?j), List.nth_list_update)
List.take_case
WithTerm take ?n ?xs
CreateConcl ?n <= length ?xs
Lists_Thms.length_take
WithWellForm ?n <= length ?xs
WithTerm take ?n ?xs
GetFact (length (take ?n ?xs) = ?n, Lists_Thms.length_take)
Lists_Thms.nth_take
WithWellForm ?i < length (take ?n ?xs)
WithTerm take ?n ?xs ! ?i
GetFact (take ?n ?xs ! ?i = ?xs ! ?i, Lists_Thms.nth_take)
List.take_0
WithTerm take 0 ?xs
GetFact (take 0 ?xs = [], List.take_0)
List.take_Suc_conv_app_nth
WithTerm take (Suc ?i) ?xs
WithFact ?i < length ?xs
GetFact (take (Suc ?i) ?xs = take ?i ?xs @ [?xs ! ?i], List.take_Suc_conv_app_nth)
Lists_Thms.take_length
WithTerm take (length ?xs) ?xs
GetFact (take (length ?xs) ?xs = ?xs, Lists_Thms.take_length)
List.set_take_subset
WithTerm set (take ?n ?xs)
GetFact (set (take ?n ?xs) <= set ?xs, List.set_take_subset)
Lists_Thms.take_Suc
WithWellForm Suc ?n <= length ?xs
WithTerm take (Suc ?n) ?xs
GetFact (take (Suc ?n) ?xs = take ?n ?xs @ [?xs ! ?n], Lists_Thms.take_Suc)
List.take_update_cancel
WithTerm take ?n (?xs[?m := ?y])
WithFact ?n <= ?m
GetFact (take ?n (?xs[?m := ?y]) = take ?n ?xs, List.take_update_cancel)
List.append_take_drop_id
WithTerm take ?n ?xs @ drop ?n ?xs
GetFact (take ?n ?xs @ drop ?n ?xs = ?xs, List.append_take_drop_id)
List.take_all
WithTerm take ?n ?xs
WithFact length ?xs <= ?n
GetFact (take ?n ?xs = ?xs, List.take_all)
List.length_drop
WithTerm drop ?n ?xs
GetFact (length (drop ?n ?xs) = length ?xs - ?n, List.length_drop)
Lists_Thms.nth_drop
WithWellForm ?i < length (drop ?n ?xs)
WithTerm drop ?n ?xs ! ?i
GetFact (drop ?n ?xs ! ?i = ?xs ! (?n + ?i), Lists_Thms.nth_drop)
List.drop_0
WithTerm drop 0 ?xs
GetFact (drop 0 ?xs = ?xs, List.drop_0)
List.drop_all
WithTerm drop ?n ?xs
WithFact length ?xs <= ?n
GetFact (drop ?n ?xs = [], List.drop_all)
List.take_drop@sym
WithTerm drop ?m (take (?n + ?m) ?xs)
GetFact (drop ?m (take (?n + ?m) ?xs) = take ?n (drop ?m ?xs), List.take_drop@sym)
List.drop_drop
WithTerm drop ?n (drop ?m ?xs)
GetFact (drop ?n (drop ?m ?xs) = drop (?n + ?m) ?xs, List.drop_drop)
List.length_rev
WithTerm rev ?xs
GetFact (length (rev ?xs) = length ?xs, List.length_rev)
List.rev.simps_1
WithTerm rev []
GetFact (rev [] = [], List.rev.simps_1)
List.rev.simps_2
WithTerm rev (?x # ?xs)
GetFact (rev (?x # ?xs) = rev ?xs @ [?x], List.rev.simps_2)
List.rev_append
WithTerm rev (?xs @ ?ys)
GetFact (rev (?xs @ ?ys) = rev ?ys @ rev ?xs, List.rev_append)
List.rev_rev_ident
WithTerm rev (rev ?xs)
GetFact (rev (rev ?xs) = ?xs, List.rev_rev_ident)
List.filter.simps_1
WithTerm filter ?P []
GetFact (filter ?P [] = [], List.filter.simps_1)
List.filter.simps_2
WithTerm filter ?P (?x # ?xs)
GetFact (filter ?P (?x # ?xs) = (if ?P ?x then ?x # filter ?P ?xs else filter ?P ?xs), List.filter.simps_2)
List.filter_append
WithTerm filter ?P (?xs @ ?ys)
GetFact (filter ?P (?xs @ ?ys) = filter ?P ?xs @ filter ?P ?ys, List.filter_append)
List.rev_filter
WithTerm rev (filter ?P ?xs)
GetFact (rev (filter ?P ?xs) = filter ?P (rev ?xs), List.rev_filter)
List.rev_filter@sym
WithTerm filter ?P (rev ?xs)
GetFact (filter ?P (rev ?xs) = rev (filter ?P ?xs), List.rev_filter@sym)
List.concat.simps_1
WithTerm concat []
GetFact (concat [] = [], List.concat.simps_1)
List.concat.simps_2
WithTerm concat (?x # ?xs)
GetFact (concat (?x # ?xs) = ?x @ concat ?xs, List.concat.simps_2)
Multiset.mset.simps_1
WithTerm mset []
GetFact (mset [] = {#}, Multiset.mset.simps_1)
Lists_Thms.mset_simps_2
WithTerm mset (?a # ?x)
GetFact (mset (?a # ?x) = mset ?x + {#?a#}, Lists_Thms.mset_simps_2)
Multiset.mset_append
WithTerm mset (?xs @ ?ys)
GetFact (mset (?xs @ ?ys) = mset ?xs + mset ?ys, Multiset.mset_append)
Multiset.mset_eq_setD
WithTerm set ?xs
WithFact mset ?xs = mset ?ys
GetFact (set ?xs = set ?ys, Multiset.mset_eq_setD)
Multiset.in_multiset_in_set@eqforward
WithTerm set ?xs
WithFact ?x :# mset ?xs
GetFact (?x : set ?xs, Multiset.in_multiset_in_set@eqforward)
Multiset.in_multiset_in_set@invbackward
WithTerm set ?xs
WithGoal ?x :# mset ?xs
GetGoal (?x : set ?xs, Multiset.in_multiset_in_set@invbackward)
Multiset.in_multiset_in_set@sym@eqforward
WithTerm mset ?xs
WithFact ?x : set ?xs
GetFact (?x :# mset ?xs, Multiset.in_multiset_in_set@sym@eqforward)
Multiset.in_multiset_in_set@sym@invbackward
WithTerm mset ?xs
WithGoal ?x : set ?xs
GetGoal (?x :# mset ?xs, Multiset.in_multiset_in_set@sym@invbackward)
Multiset.nth_mem_mset@back
WithGoal ?ls ! ?i :# mset ?ls
GetGoal (?i < length ?ls, Multiset.nth_mem_mset@back)
Lists_Thms.in_mset_conv_nth@res
WithGoal EX i<length ?xs. ?x = ?xs ! i
WithFact ?x :# mset ?xs
GetResolve Lists_Thms.in_mset_conv_nth@res
Lists_Thms.hd_in_mset
WithWellForm ?xs ~= []
WithTerm hd ?xs
WithTerm mset ?xs
GetFact (hd ?xs :# mset ?xs, Lists_Thms.hd_in_mset)
Lists_Thms.last_in_mset
WithWellForm ?xs ~= []
WithTerm last ?xs
WithTerm mset ?xs
GetFact (last ?xs :# mset ?xs, Lists_Thms.last_in_mset)
Lists_Thms.mset_butlast
WithTerm mset (butlast ?xs)
WithGoal ?xs = []
GetFact (mset (butlast ?xs) = mset ?xs - {#last ?xs#}, Lists_Thms.mset_butlast)
Lists_Thms.insert_mset_to_set
WithTerm set ?xs'
WithFact mset ?xs' = mset ?xs + {#?x#}
GetFact (set ?xs' = set ?xs Un {?x}, Lists_Thms.insert_mset_to_set)
Lists_Thms.delete_mset_to_set
WithProperty distinct ?xs
WithTerm set ?xs'
WithFact mset ?xs' = mset ?xs - {#?x#}
GetFact (set ?xs' = set ?xs - {?x}, Lists_Thms.delete_mset_to_set)
Lists_Thms.update_mset_to_set
WithProperty distinct ?xs
WithTerm set ?xs'
WithFact mset ?xs' = {#?y#} + (mset ?xs - {#?x#})
GetFact (set ?xs' = set ?xs - {?x} Un {?y}, Lists_Thms.update_mset_to_set)
Lists_Thms.mset_update'
WithWellForm ?i < length ?ls
WithTerm mset (?ls[?i := ?v])
GetFact (mset (?ls[?i := ?v]) = {#?v#} + (mset ?ls - {#?ls ! ?i#}), Lists_Thms.mset_update')
Multiset.mset_swap
WithWellForm ?i < length ?ls
WithWellForm ?j < length ?ls
WithTerm mset (?ls[?j := ?ls ! ?i, ?i := ?ls ! ?j])
GetFact (mset (?ls[?j := ?ls ! ?i, ?i := ?ls ! ?j]) = mset ?ls, Multiset.mset_swap)
List.set_swap
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithTerm set (?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i])
GetFact (set (?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i]) = set ?xs, List.set_swap)
Lists_Thms.upt_zero_length
WithTerm length [0..<?n]
GetFact (length [0..<?n] = ?n, Lists_Thms.upt_zero_length)
Lists_Thms.nth_upt_zero
WithWellForm ?i < length [0..<?n]
WithTerm [0..<?n] ! ?i
GetFact ([0..<?n] ! ?i = ?i, Lists_Thms.nth_upt_zero)
Lists_Thms.list_length
WithTerm list ?s ?n
GetFact (length (list ?s ?n) = ?n, Lists_Thms.list_length)
Lists_Thms.list_nth
WithWellForm ?i < length (list ?s ?n)
WithTerm list ?s ?n ! ?i
GetFact (list ?s ?n ! ?i = ?s ?i, Lists_Thms.list_nth)
List.split_list@res
WithGoal EX ys zs. ?xs = ys @ ?x # zs
WithFact ?x : set ?xs
GetResolve List.split_list@res
List.not_distinct_decomp@back
WithGoal EX xs ys zs y. ?ws = xs @ [y] @ ys @ [y] @ zs
GetFact (distinct ?ws, List.not_distinct_decomp@back)
List.finite_lists_length_le@res
WithProperty finite ?A
WithGoal finite {xs. set xs <= ?A & length xs <= ?n}
GetResolve List.finite_lists_length_le@res
List.distinct_card
WithProperty distinct ?xs
WithTerm card (set ?xs)
GetFact (card (set ?xs) = length ?xs, List.distinct_card)
### theory "Auto2_HOL.Lists_Thms"
### 0.438s elapsed time, 0.891s cpu time, 0.041s GC time
Loading theory "Auto2_HOL.Auto2_Main" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base")
consts
  fold_map :: "('a => 'b Heap) => 'a list => 'b list Heap"
### Cannot skip proof of schematic goal statement
### theory "HOL-Imperative_HOL.Heap_Monad"
### 1.997s elapsed time, 6.176s cpu time, 1.582s GC time
Loading theory "HOL-Imperative_HOL.Array" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL")
### theory "Auto2_HOL.Auto2_Main"
### 0.247s elapsed time, 0.544s cpu time, 0.036s GC time
Loading theory "Draft.Arrays_Ex" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Arrays_Impl")
Loading theory "Draft.Interval" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Rect_Intersect_Impl" via "Draft.Rect_Intersect" via "Draft.Interval_Tree")
Loading theory "Draft.Mapping_Str" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.BST_Impl" via "Draft.BST" via "Draft.Lists_Ex")
Arrays_Ex.list_swap_def
WithTerm list_swap ?xs ?i ?j
GetFact (list_swap ?xs ?i ?j = ?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i], Arrays_Ex.list_swap_def)
Arrays_Ex.list_swap_case
WithTerm list_swap ?xs ?i ?j
CreateConcl ?i < length ?xs & ?j < length ?xs
Arrays_Ex.list_swap_eval
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithTerm list_swap ?xs ?i ?j ! ?k
GetFact (list_swap ?xs ?i ?j ! ?k =
(if ?k = ?i then ?xs ! ?j else if ?k = ?j then ?xs ! ?i else ?xs ! ?k), Arrays_Ex.list_swap_eval) + 2 filters
Arrays_Ex.list_swap_eval_triv_1
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithTerm list_swap ?xs ?i ?j ! ?i
GetFact (list_swap ?xs ?i ?j ! ?i = ?xs ! ?j, Arrays_Ex.list_swap_eval_triv_1)
Arrays_Ex.list_swap_eval_triv_2
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithTerm list_swap ?xs ?i ?j ! ?j
GetFact (list_swap ?xs ?i ?j ! ?j = ?xs ! ?i, Arrays_Ex.list_swap_eval_triv_2)
Arrays_Ex.length_list_swap
WithTerm list_swap ?xs ?i ?j
GetFact (length (list_swap ?xs ?i ?j) = length ?xs, Arrays_Ex.length_list_swap)
Arrays_Ex.mset_list_swap
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithTerm mset (list_swap ?xs ?i ?j)
GetFact (mset (list_swap ?xs ?i ?j) = mset ?xs, Arrays_Ex.mset_list_swap)
Arrays_Ex.set_list_swap
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithTerm set (list_swap ?xs ?i ?j)
GetFact (set (list_swap ?xs ?i ?j) = set ?xs, Arrays_Ex.set_list_swap)
Delete Arrays_Ex.list_swap_def
Arrays_Ex.list_swap_def@sym
WithTerm ?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i]
GetFact (?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i] = list_swap ?xs ?i ?j, Arrays_Ex.list_swap_def@sym)
Arrays_Ex.rev_nth
WithTerm rev ?xs ! ?n
WithFact ?n < length ?xs
GetFact (rev ?xs ! ?n = ?xs ! (length ?xs - 1 - ?n), Arrays_Ex.rev_nth)
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Arrays_Ex.rev_swap_case
WithTerm rev_swap ?xs ?i ?j
CreateConcl ?j < length ?xs
Arrays_Ex.rev_swap_length
WithWellForm ?j < length ?xs
WithTerm rev_swap ?xs ?i ?j
GetFact (length (rev_swap ?xs ?i ?j) = length ?xs, Arrays_Ex.rev_swap_length)
Arrays_Ex.rev_swap_eval
WithWellForm ?j < length ?xs
WithTerm rev_swap ?xs ?i ?j ! ?k
GetFact (rev_swap ?xs ?i ?j ! ?k =
(if ?k < ?i then ?xs ! ?k
 else if ?j < ?k then ?xs ! ?k else ?xs ! (?j - (?k - ?i))), Arrays_Ex.rev_swap_eval)
Arrays_Ex.rev_swap_is_rev
WithWellForm 1 <= length ?xs
WithTerm rev_swap ?xs 0 (length ?xs - 1)
GetFact (rev_swap ?xs 0 (length ?xs - 1) = rev ?xs, Arrays_Ex.rev_swap_is_rev)
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Arrays_Ex.array_copy.simps_1
WithTerm array_copy ?xs ?xs' 0
GetFact (array_copy ?xs ?xs' 0 = ?xs', Arrays_Ex.array_copy.simps_1)
Arrays_Ex.array_copy.simps_2
WithTerm array_copy ?xs ?xs' (Suc ?n)
GetFact (array_copy ?xs ?xs' (Suc ?n) = (array_copy ?xs ?xs' ?n)[?n := ?xs ! ?n], Arrays_Ex.array_copy.simps_2)
Arrays_Ex.array_copy_case
WithTerm array_copy ?xs ?xs' ?n
CreateConcl ?n <= length ?xs & ?n <= length ?xs'
Arrays_Ex.array_copy_length
WithWellForm ?n <= length ?xs
WithWellForm ?n <= length ?xs'
WithTerm array_copy ?xs ?xs' ?n
GetFact (length (array_copy ?xs ?xs' ?n) = length ?xs', Arrays_Ex.array_copy_length)
Arrays_Ex.array_copy_ind
WithWellForm ?n <= length ?xs
WithWellForm ?n <= length ?xs'
WithTerm array_copy ?xs ?xs' ?n ! ?k
WithFact ?k < ?n
GetFact (array_copy ?xs ?xs' ?n ! ?k = ?xs ! ?k, Arrays_Ex.array_copy_ind)
Arrays_Ex.array_copy_correct
WithWellForm ?n <= length ?xs
WithWellForm ?n <= length ?xs'
WithTerm take ?n (array_copy ?xs ?xs' ?n)
GetFact (take ?n (array_copy ?xs ?xs' ?n) = take ?n ?xs, Arrays_Ex.array_copy_correct)
Arrays_Ex.sublist_def
WithTerm sublist ?l ?r ?xs
GetFact (sublist ?l ?r ?xs = drop ?l (take ?r ?xs), Arrays_Ex.sublist_def)
Arrays_Ex.sublist_case
WithTerm sublist ?l ?r ?xs
CreateConcl ?l <= ?r & ?r <= length ?xs
Arrays_Ex.length_sublist
WithWellForm ?r <= length ?xs
WithTerm sublist ?l ?r ?xs
GetFact (length (sublist ?l ?r ?xs) = ?r - ?l, Arrays_Ex.length_sublist)
Apply def ?xs' = sublist ?l ?r ?xs
Arrays_Ex.nth_sublist
WithWellForm ?r <= length ?xs
WithWellForm ?i < length (sublist ?l ?r ?xs)
WithTerm sublist ?l ?r ?xs ! ?i
GetFact (sublist ?l ?r ?xs ! ?i = ?xs ! (?i + ?l), Arrays_Ex.nth_sublist)
Arrays_Ex.sublist_nil
WithWellForm ?r <= length ?xs
WithTerm sublist ?l ?r ?xs
WithFact ?r <= ?l
GetFact (sublist ?l ?r ?xs = [], Arrays_Ex.sublist_nil)
Arrays_Ex.sublist_0
WithTerm sublist 0 ?l ?xs
GetFact (sublist 0 ?l ?xs = take ?l ?xs, Arrays_Ex.sublist_0)
Arrays_Ex.sublist_drop
WithTerm sublist ?l ?r (drop ?n ?xs)
GetFact (sublist ?l ?r (drop ?n ?xs) = sublist (?l + ?n) (?r + ?n) ?xs, Arrays_Ex.sublist_drop)
Delete Arrays_Ex.sublist_def
Arrays_Ex.sublist_single
WithWellForm ?l + 1 <= length ?xs
WithTerm sublist ?l (?l + 1) ?xs
GetFact (sublist ?l (?l + 1) ?xs = [?xs ! ?l], Arrays_Ex.sublist_single)
Arrays_Ex.sublist_append
WithWellForm ?l <= ?m
WithWellForm ?m <= ?r
WithWellForm ?r <= length ?xs
WithTerm sublist ?l ?m ?xs @ sublist ?m ?r ?xs
GetFact (sublist ?l ?m ?xs @ sublist ?m ?r ?xs = sublist ?l ?r ?xs, Arrays_Ex.sublist_append)
Arrays_Ex.sublist_Cons
WithWellForm ?r <= length ?xs
WithTerm ?xs ! ?l # sublist (?l + 1) ?r ?xs
WithFact ?l < ?r
GetFact (?xs ! ?l # sublist (?l + 1) ?r ?xs = sublist ?l ?r ?xs, Arrays_Ex.sublist_Cons)
Arrays_Ex.sublist_equalityI@back2
WithWellForm ?i <= ?j
WithWellForm ?j <= length ?xs
WithGoal sublist ?i ?j ?xs = sublist ?i ?j ?ys
WithFact length ?xs = length ?ys
GetGoal (ALL k>=?i. k < ?j --> ?xs ! k = ?ys ! k, Arrays_Ex.sublist_equalityI@back2) + 1 filters
Arrays_Ex.set_sublist@res
WithWellForm ?j <= length ?xs
WithGoal EX k>=?i. k < ?j & ?x = ?xs ! k
WithFact ?x : set (sublist ?i ?j ?xs)
GetResolve Arrays_Ex.set_sublist@res
Arrays_Ex.list_take_sublist_drop_eq
WithWellForm ?l <= ?r
WithWellForm ?r <= length ?xs
WithTerm take ?l ?xs @ sublist ?l ?r ?xs @ drop ?r ?xs
GetFact (take ?l ?xs @ sublist ?l ?r ?xs @ drop ?r ?xs = ?xs, Arrays_Ex.list_take_sublist_drop_eq)
Arrays_Ex.list_update_set_def
WithTerm list_update_set ?S ?f ?xs
GetFact (list_update_set ?S ?f ?xs =
list (%i. if ?S i then ?f i else ?xs ! i) (length ?xs), Arrays_Ex.list_update_set_def)
Arrays_Ex.list_update_set_length
WithTerm list_update_set ?S ?f ?xs
GetFact (length (list_update_set ?S ?f ?xs) = length ?xs, Arrays_Ex.list_update_set_length)
Apply def ?xs' = list_update_set ?S ?f ?xs
Arrays_Ex.list_update_set_nth
WithWellForm ?i < length (list_update_set ?S ?f ?xs)
WithTerm list_update_set ?S ?f ?xs ! ?i
GetFact (list_update_set ?S ?f ?xs ! ?i = (if ?S ?i then ?f ?i else ?xs ! ?i), Arrays_Ex.list_update_set_nth)
Delete Arrays_Ex.list_update_set_def
### theory "HOL-Imperative_HOL.Array"
### 0.375s elapsed time, 1.442s cpu time, 0.159s GC time
Loading theory "Draft.Partial_Equiv_Rel" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Union_Find_Impl" via "Draft.Union_Find")
Partial_Equiv_Rel.part_equiv_def@eqforward
WithFact part_equiv ?R
GetFact (sym ?R & trans ?R, Partial_Equiv_Rel.part_equiv_def@eqforward)
Partial_Equiv_Rel.part_equiv_def@invbackward
WithGoal part_equiv ?R
GetGoal (sym ?R & trans ?R, Partial_Equiv_Rel.part_equiv_def@invbackward)
Add property rule for [Relation.sym, Relation.trans]
Add property rule for [Partial_Equiv_Rel.part_equiv]
Add property rule for [Partial_Equiv_Rel.part_equiv]
Delete Partial_Equiv_Rel.part_equiv_def@eqforward
Partial_Equiv_Rel.per_union_def
WithTerm per_union ?R ?a ?b
GetFact (per_union ?R ?a ?b =
?R Un {(x, y). (x, ?a) : ?R & (?b, y) : ?R} Un
{(x, y). (x, ?b) : ?R & (?a, y) : ?R}, Partial_Equiv_Rel.per_union_def)
Partial_Equiv_Rel.per_union_memI1@back
WithGoal (?x, ?y) : per_union ?R ?a ?b
GetGoal ((?x, ?y) : ?R, Partial_Equiv_Rel.per_union_memI1@back)
Partial_Equiv_Rel.per_union_memI1
WithTerm per_union ?R ?a ?b
WithFact (?x, ?y) : ?R
GetFact ((?x, ?y) : per_union ?R ?a ?b, Partial_Equiv_Rel.per_union_memI1)
Partial_Equiv_Rel.per_union_memI2@back
WithGoal (?x, ?y) : per_union ?R ?a ?b
GetGoal ((?x, ?a) : ?R & (?b, ?y) : ?R, Partial_Equiv_Rel.per_union_memI2@back)
Partial_Equiv_Rel.per_union_memI3@back
WithGoal (?x, ?y) : per_union ?R ?a ?b
GetGoal ((?x, ?b) : ?R & (?a, ?y) : ?R, Partial_Equiv_Rel.per_union_memI3@back)
Partial_Equiv_Rel.per_union_memD
WithFact (?x, ?y) : per_union ?R ?a ?b
GetFact ((?x, ?y) : ?R |
(?x, ?a) : ?R & (?b, ?y) : ?R | (?x, ?b) : ?R & (?a, ?y) : ?R, Partial_Equiv_Rel.per_union_memD) + 2 filters
Delete Partial_Equiv_Rel.per_union_def
Add property rule for function Partial_Equiv_Rel.per_union
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Add property rule for function Partial_Equiv_Rel.per_union
### theory "Draft.Partial_Equiv_Rel"
### 0.103s elapsed time, 0.406s cpu time, 0.075s GC time
Loading theory "Draft.Union_Find" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Union_Find_Impl")
Arrays_Ex.list_update_set_impl.simps_1
WithTerm list_update_set_impl ?S ?f ?xs 0
GetFact (list_update_set_impl ?S ?f ?xs 0 = ?xs, Arrays_Ex.list_update_set_impl.simps_1)
Arrays_Ex.list_update_set_impl.simps_2
WithTerm list_update_set_impl ?S ?f ?xs (Suc ?k)
GetFact (list_update_set_impl ?S ?f ?xs (Suc ?k) =
(let xs' = list_update_set_impl ?S ?f ?xs ?k
 in if ?S ?k then xs'[?k := ?f ?k] else xs'), Arrays_Ex.list_update_set_impl.simps_2)
Arrays_Ex.list_update_set_impl_ind
WithWellForm ?n <= length ?xs
WithTerm list_update_set_impl ?S ?f ?xs ?n
GetFact (list_update_set_impl ?S ?f ?xs ?n =
list (%i. if i < ?n then if ?S i then ?f i else ?xs ! i else ?xs ! i)
 (length ?xs), Arrays_Ex.list_update_set_impl_ind)
Arrays_Ex.list_update_set_impl_correct
WithTerm list_update_set_impl ?S ?f ?xs (length ?xs)
GetFact (list_update_set_impl ?S ?f ?xs (length ?xs) = list_update_set ?S ?f ?xs, Arrays_Ex.list_update_set_impl_correct)
### theory "Draft.Arrays_Ex"
### 0.477s elapsed time, 1.886s cpu time, 0.234s GC time
Loading theory "Draft.Quicksort" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Quicksort_Impl")
Interval.interval.collapse@sym
WithTerm ?interval
GetFact (?interval = Interval (low ?interval) (high ?interval), Interval.interval.collapse@sym) + 1 filters
Interval.interval.case
WithTerm case Interval ?x1.0 ?x2.0 of Interval x xa => ?f x xa
GetFact ((case Interval ?x1.0 ?x2.0 of Interval x xa => ?f x xa) = ?f ?x1.0 ?x2.0, Interval.interval.case)
Interval.interval.sel_1
WithTerm low (Interval ?x1.0 ?x2.0)
GetFact (low (Interval ?x1.0 ?x2.0) = ?x1.0, Interval.interval.sel_1)
Interval.interval.sel_2
WithTerm high (Interval ?x1.0 ?x2.0)
GetFact (high (Interval ?x1.0 ?x2.0) = ?x2.0, Interval.interval.sel_2)
Interval.interval.simps_1@eqforward
WithFact Interval ?x1.0 ?x2.0 = Interval ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Interval.interval.simps_1@eqforward)
instantiation
  interval :: (linorder) linorder
  less_eq_interval == less_eq :: 'a interval => 'a interval => bool
  less_interval == less :: 'a interval => 'a interval => bool
Quicksort.outer_remains_def@eqforward
WithFact outer_remains ?xs ?xs' ?l ?r
GetFact (length ?xs = length ?xs' & (ALL i. i < ?l | ?r < i --> ?xs ! i = ?xs' ! i), Quicksort.outer_remains_def@eqforward)
Quicksort.outer_remains_def@invbackward
WithGoal outer_remains ?xs ?xs' ?l ?r
GetGoal (length ?xs = length ?xs' & (ALL i. i < ?l | ?r < i --> ?xs ! i = ?xs' ! i), Quicksort.outer_remains_def@invbackward)
Quicksort.outer_remains_length
WithFact outer_remains ?xs ?xs' ?l ?r
GetFact (length ?xs = length ?xs', Quicksort.outer_remains_length)
Quicksort.outer_remains_eq_1@sym
WithTerm ?xs' ! ?i
WithFact outer_remains ?xs ?xs' ?l ?r
GetFact (?i < ?l --> ?xs' ! ?i = ?xs ! ?i, Quicksort.outer_remains_eq_1@sym)
Quicksort.outer_remains_eq_2@sym
WithTerm ?xs' ! ?i
WithFact outer_remains ?xs ?xs' ?l ?r
GetFact (?r < ?i --> ?xs' ! ?i = ?xs ! ?i, Quicksort.outer_remains_eq_2@sym)
Quicksort.outer_remains_sublist_1@back2
WithGoal take ?i ?xs = take ?i ?xs'
WithFact outer_remains ?xs ?xs' ?l ?r
GetGoal (?i < ?l, Quicksort.outer_remains_sublist_1@back2)
Quicksort.outer_remains_sublist_2@back2
WithGoal drop ?i ?xs = drop ?i ?xs'
WithFact outer_remains ?xs ?xs' ?l ?r
GetGoal (?r < ?i, Quicksort.outer_remains_sublist_2@back2)
Quicksort.outer_remains_sublist_3@back2
WithWellForm ?i <= ?j
WithWellForm ?j <= length ?xs
WithGoal sublist ?i ?j ?xs = sublist ?i ?j ?xs'
WithFact outer_remains ?xs ?xs' ?l ?r
GetGoal (?j <= ?l, Quicksort.outer_remains_sublist_3@back2)
Quicksort.outer_remains_sublist_4@back2
WithWellForm ?i <= ?j
WithWellForm ?j <= length ?xs
WithGoal sublist ?i ?j ?xs = sublist ?i ?j ?xs'
WithFact outer_remains ?xs ?xs' ?l ?r
GetGoal (?r < ?i, Quicksort.outer_remains_sublist_4@back2)
Delete Quicksort.outer_remains_def@eqforward
Interval.is_interval_def@eqforward
WithFact is_interval ?it
GetFact (low ?it <= high ?it, Interval.is_interval_def@eqforward)
Interval.is_interval_def@invbackward
WithGoal is_interval ?it
GetGoal (low ?it <= high ?it, Interval.is_interval_def@invbackward)
Found termination order: "{}"
Union_Find.rep_of.domintros@back
WithGoal rep_of_dom (?l, ?i)
GetGoal (?l ! ?i ~= ?i --> rep_of_dom (?l, ?l ! ?i), Union_Find.rep_of.domintros@back)
Union_Find.rep_of.psimps
WithTerm rep_of ?l ?i
WithFact rep_of_dom (?l, ?i)
GetFact (rep_of ?l ?i = (if ?l ! ?i = ?i then ?i else rep_of ?l (?l ! ?i)), Union_Find.rep_of.psimps)
Mapping_Str.meval.simps
WithTerm Map ?f\<langle>?h\<rangle>
GetFact (Map ?f\<langle>?h\<rangle> = ?f ?h, Mapping_Str.meval.simps)
Mapping_Str.meval_ext@back
WithGoal ?M = ?N
GetGoal (ALL x. ?M\<langle>x\<rangle> = ?N\<langle>x\<rangle>, Mapping_Str.meval_ext@back) + 1 filters
Union_Find.ufa_invar_def@eqforward
WithFact ufa_invar ?l
GetFact (ALL i<length ?l. rep_of_dom (?l, i) & ?l ! i < length ?l, Union_Find.ufa_invar_def@eqforward)
Union_Find.ufa_invar_def@invbackward
WithGoal ufa_invar ?l
GetGoal (ALL i<length ?l. rep_of_dom (?l, i) & ?l ! i < length ?l, Union_Find.ufa_invar_def@invbackward)
Union_Find.ufa_invarD
WithProperty ufa_invar ?l
WithWellForm ?i < length ?l
WithTerm ?l ! ?i
GetFact (rep_of_dom (?l, ?i) & ?l ! ?i < length ?l, Union_Find.ufa_invarD)
Mapping_Str.empty_map_def
WithTerm empty_map
GetFact (empty_map = Map Map.empty, Mapping_Str.empty_map_def)
Delete Union_Find.ufa_invar_def@eqforward
Union_Find.rep_of_id
WithProperty ufa_invar ?l
WithWellForm ?i < length ?l
WithTerm rep_of ?l ?i
WithFact ?l ! ?i = ?i
GetFact (rep_of ?l ?i = ?i, Union_Find.rep_of_id)
Union_Find.rep_of_iff
WithProperty ufa_invar ?l
WithWellForm ?i < length ?l
WithTerm rep_of ?l ?i
GetFact (rep_of ?l ?i = (if ?l ! ?i = ?i then ?i else rep_of ?l (?l ! ?i)), Union_Find.rep_of_iff)
Delete Union_Find.rep_of.psimps
Mapping_Str.update_map_def
WithTerm  ?M { ?k \<rightarrow> ?v }
GetFact ( ?M { ?k \<rightarrow> ?v } =
Map (%x. if x = ?k then Some ?v else ?M\<langle>x\<rangle>), Mapping_Str.update_map_def)
Union_Find.rep_of_min
WithProperty ufa_invar ?l
WithWellForm ?i < length ?l
WithTerm ?l ! rep_of ?l ?i
GetFact (?l ! rep_of ?l ?i = rep_of ?l ?i, Union_Find.rep_of_min)
Mapping_Str.delete_map_def
WithTerm delete_map ?k ?M
GetFact (delete_map ?k ?M = Map (%x. if x = ?k then None else ?M\<langle>x\<rangle>), Mapping_Str.delete_map_def)
Union_Find.rep_of_bound
WithProperty ufa_invar ?l
WithWellForm ?i < length ?l
WithTerm rep_of ?l ?i
GetFact (rep_of ?l ?i < length ?l, Union_Find.rep_of_bound)
Union_Find.rep_of_idem
WithProperty ufa_invar ?l
WithWellForm ?i < length ?l
WithTerm rep_of ?l (rep_of ?l ?i)
GetFact (rep_of ?l (rep_of ?l ?i) = rep_of ?l ?i, Union_Find.rep_of_idem)
Union_Find.rep_of_idx
WithProperty ufa_invar ?l
WithWellForm ?i < length ?l
WithTerm rep_of ?l (?l ! ?i)
GetFact (rep_of ?l (?l ! ?i) = rep_of ?l ?i, Union_Find.rep_of_idx)
Union_Find.ufa_\<alpha>_def
WithTerm ufa_\<alpha> ?l
GetFact (ufa_\<alpha> ?l =
{(x, y). x < length ?l & y < length ?l & rep_of ?l x = rep_of ?l y}, Union_Find.ufa_\<alpha>_def)
Union_Find.ufa_\<alpha>_memI@back
WithGoal (?x, ?y) : ufa_\<alpha> ?l
GetGoal (?x < length ?l & ?y < length ?l & rep_of ?l ?x = rep_of ?l ?y, Union_Find.ufa_\<alpha>_memI@back)
Union_Find.ufa_\<alpha>_memI
WithWellForm ?x < length ?l
WithWellForm ?y < length ?l
WithTerm ufa_\<alpha> ?l
WithFact rep_of ?l ?x = rep_of ?l ?y
GetFact ((?x, ?y) : ufa_\<alpha> ?l, Union_Find.ufa_\<alpha>_memI)
Union_Find.ufa_\<alpha>_memD
WithFact (?x, ?y) : ufa_\<alpha> ?l
GetFact (?x < length ?l & ?y < length ?l & rep_of ?l ?x = rep_of ?l ?y, Union_Find.ufa_\<alpha>_memD)
Delete Union_Find.ufa_\<alpha>_def
Add property rule for function Union_Find.ufa_\<alpha>
Union_Find.ufa_\<alpha>_refl@eqforward
WithFact (?i, ?i) : ufa_\<alpha> ?l
GetFact (?i < length ?l, Union_Find.ufa_\<alpha>_refl@eqforward)
Union_Find.ufa_\<alpha>_refl@invbackward
WithGoal (?i, ?i) : ufa_\<alpha> ?l
GetGoal (?i < length ?l, Union_Find.ufa_\<alpha>_refl@invbackward)
Quicksort.part1_case
WithTerm part1 ?xs ?l ?r ?a
CreateConcl ?r < length ?xs
Union_Find.uf_init_rel_def
WithTerm uf_init_rel ?n
GetFact (uf_init_rel ?n = ufa_\<alpha> [0..<?n], Union_Find.uf_init_rel_def)
Union_Find.ufa_init_invar@res
WithGoal ufa_invar [0..<?n]
GetResolve Union_Find.ufa_init_invar@res
Union_Find.ufa_init_correct@eqforward
WithFact (?x, ?y) : uf_init_rel ?n
GetFact (?x = ?y & ?x < ?n, Union_Find.ufa_init_correct@eqforward)
Union_Find.ufa_init_correct@invbackward
WithGoal (?x, ?y) : uf_init_rel ?n
GetGoal (?x = ?y & ?x < ?n, Union_Find.ufa_init_correct@invbackward)
Apply def ?rs = fst (part1 ?xs ?l ?r ?a)
Apply def ?xs' = snd (part1 ?xs ?l ?r ?a)
Quicksort.part1_basic
WithWellForm ?r < length ?xs
WithTerm part1 ?xs ?l ?r ?a
WithFact ?l <= ?r
GetFact (outer_remains ?xs (snd (part1 ?xs ?l ?r ?a)) ?l ?r &
mset (snd (part1 ?xs ?l ?r ?a)) = mset ?xs &
?l <= fst (part1 ?xs ?l ?r ?a) & fst (part1 ?xs ?l ?r ?a) <= ?r, Quicksort.part1_basic)
Apply def ?l' = ufa_union ?l ?x ?y
Union_Find.ufa_union_invar
WithProperty ufa_invar ?l
WithWellForm ?x < length ?l
WithWellForm ?y < length ?l
WithTerm ufa_union ?l ?x ?y
GetFact (ufa_invar (ufa_union ?l ?x ?y), Union_Find.ufa_union_invar)
Apply def ?rs = fst (part1 ?xs ?l ?r ?a)
Apply def ?xs' = snd (part1 ?xs ?l ?r ?a)
Quicksort.part1_partitions1@back
WithWellForm ?r < length ?xs
WithGoal snd (part1 ?xs ?l ?r ?a) ! ?i <= ?a
GetGoal (?l <= ?i & ?i < fst (part1 ?xs ?l ?r ?a), Quicksort.part1_partitions1@back)
Apply def ?l' = ufa_union ?l ?x ?y
Union_Find.ufa_union_aux
WithProperty ufa_invar ?l
WithWellForm ?x < length ?l
WithWellForm ?y < length ?l
WithWellForm ?i < length (ufa_union ?l ?x ?y)
WithTerm rep_of (ufa_union ?l ?x ?y) ?i
GetFact (rep_of (ufa_union ?l ?x ?y) ?i =
(if rep_of ?l ?i = rep_of ?l ?x then rep_of ?l ?y else rep_of ?l ?i), Union_Find.ufa_union_aux)
Apply def ?rs = fst (part1 ?xs ?l ?r ?a)
Apply def ?xs' = snd (part1 ?xs ?l ?r ?a)
Quicksort.part1_partitions2@back
WithWellForm ?r < length ?xs
WithGoal ?a <= snd (part1 ?xs ?l ?r ?a) ! ?i
GetGoal (fst (part1 ?xs ?l ?r ?a) < ?i & ?i <= ?r, Quicksort.part1_partitions2@back)
Apply def ?l' = ufa_union ?l ?x ?y
Union_Find.ufa_union_correct
WithProperty ufa_invar ?l
WithWellForm ?x < length ?l
WithWellForm ?y < length ?l
WithTerm ufa_\<alpha> (ufa_union ?l ?x ?y)
GetFact (ufa_\<alpha> (ufa_union ?l ?x ?y) = per_union (ufa_\<alpha> ?l) ?x ?y, Union_Find.ufa_union_correct)
Apply def ?l' = ufa_compress ?l ?x
Quicksort.partition_def
WithTerm Quicksort.partition ?xs ?l ?r
GetFact (Quicksort.partition ?xs ?l ?r =
(let p = ?xs ! ?r; (m, xs') = part1 ?xs ?l (?r - 1) p;
     m' = if xs' ! m <= p then m + 1 else m
 in (m', list_swap xs' m' ?r)), Quicksort.partition_def)
Union_Find.ufa_compress_invar
WithProperty ufa_invar ?l
WithWellForm ?x < length ?l
WithTerm ufa_compress ?l ?x
GetFact (ufa_invar (ufa_compress ?l ?x), Union_Find.ufa_compress_invar)
Apply def ?l' = ufa_compress ?l ?x
Union_Find.ufa_compress_aux
WithProperty ufa_invar ?l
WithWellForm ?x < length ?l
WithWellForm ?i < length (ufa_compress ?l ?x)
WithTerm rep_of (ufa_compress ?l ?x) ?i
GetFact (rep_of (ufa_compress ?l ?x) ?i = rep_of ?l ?i, Union_Find.ufa_compress_aux)
Union_Find.ufa_compress_correct
WithProperty ufa_invar ?l
WithWellForm ?x < length ?l
WithTerm ufa_\<alpha> (ufa_compress ?l ?x)
GetFact (ufa_\<alpha> (ufa_compress ?l ?x) = ufa_\<alpha> ?l, Union_Find.ufa_compress_correct)
Apply def ?rs = fst (Quicksort.partition ?xs ?l ?r)
Delete Union_Find.rep_of_iff
Apply def ?xs' = snd (Quicksort.partition ?xs ?l ?r)
Found termination order: "size_list size <*mlex*> {}"
Quicksort.partition_basic
WithWellForm ?l < ?r
WithWellForm ?r < length ?xs
WithTerm Quicksort.partition ?xs ?l ?r
GetFact (outer_remains ?xs (snd (Quicksort.partition ?xs ?l ?r)) ?l ?r &
mset (snd (Quicksort.partition ?xs ?l ?r)) = mset ?xs &
?l <= fst (Quicksort.partition ?xs ?l ?r) &
fst (Quicksort.partition ?xs ?l ?r) <= ?r, Quicksort.partition_basic)
### theory "Draft.Union_Find"
### 0.240s elapsed time, 0.953s cpu time, 0.087s GC time
Loading theory "Draft.Connectivity" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Connectivity_Impl")
Apply def ?rs = fst (Quicksort.partition ?xs ?l ?r)
Apply def ?xs' = snd (Quicksort.partition ?xs ?l ?r)
Quicksort.partition_partitions1
WithWellForm ?l < ?r
WithWellForm ?r < length ?xs
WithFact ?x : set (sublist ?l (fst (Quicksort.partition ?xs ?l ?r))
           (snd (Quicksort.partition ?xs ?l ?r)))
GetFact (?x <= snd (Quicksort.partition ?xs ?l ?r) !
      fst (Quicksort.partition ?xs ?l ?r), Quicksort.partition_partitions1)
Mapping_Str.map_of_alist.simps_1
WithTerm map_of_alist []
GetFact (map_of_alist [] = empty_map, Mapping_Str.map_of_alist.simps_1)
Mapping_Str.map_of_alist.simps_2
WithTerm map_of_alist (?x # ?xs)
GetFact (map_of_alist (?x # ?xs) =  map_of_alist ?xs { fst ?x \<rightarrow> snd ?x }, Mapping_Str.map_of_alist.simps_2)
Apply def ?rs = fst (Quicksort.partition ?xs ?l ?r)
Apply def ?xs'' = snd (Quicksort.partition ?xs ?l ?r)
Quicksort.partition_partitions2
WithWellForm ?l < ?r
WithWellForm ?r < length ?xs
WithFact ?x : set (sublist (fst (Quicksort.partition ?xs ?l ?r) + 1) (?r + 1)
           (snd (Quicksort.partition ?xs ?l ?r)))
GetFact (snd (Quicksort.partition ?xs ?l ?r) ! fst (Quicksort.partition ?xs ?l ?r)
<= ?x, Quicksort.partition_partitions2)
Delete Quicksort.partition_def
Mapping_Str.has_key_alist_def@eqforward
WithFact has_key_alist ?xs ?a
GetFact (EX p:set ?xs. fst p = ?a, Mapping_Str.has_key_alist_def@eqforward)
Mapping_Str.has_key_alist_def@invbackward
WithGoal has_key_alist ?xs ?a
GetGoal (EX p:set ?xs. fst p = ?a, Mapping_Str.has_key_alist_def@invbackward)
Mapping_Str.map_of_alist_nil@sym@eqforward
WithGoal map_of_alist ?ys\<langle>?x\<rangle> = None
GetFact (has_key_alist ?ys ?x, Mapping_Str.map_of_alist_nil@sym@eqforward)
Mapping_Str.map_of_alist_nil@sym@invbackward
WithFact map_of_alist ?ys\<langle>?x\<rangle> = None
GetGoal (has_key_alist ?ys ?x, Mapping_Str.map_of_alist_nil@sym@invbackward)
Mapping_Str.map_of_alist_nil@eqforward
WithTerm map_of_alist ?ys\<langle>?x\<rangle>
WithFact has_key_alist ?ys ?x
GetGoal (map_of_alist ?ys\<langle>?x\<rangle> = None, Mapping_Str.map_of_alist_nil@eqforward)
Mapping_Str.map_of_alist_nil@invbackward
WithTerm map_of_alist ?ys\<langle>?x\<rangle>
WithGoal has_key_alist ?ys ?x
GetFact (map_of_alist ?ys\<langle>?x\<rangle> = None, Mapping_Str.map_of_alist_nil@invbackward)
Mapping_Str.map_of_alist_some
WithFact map_of_alist ?xs\<langle>?k\<rangle> = Some ?v
GetFact ((?k, ?v) : set ?xs, Mapping_Str.map_of_alist_some)
Mapping_Str.map_of_alist_nil'@eqforward
WithTerm map_of_alist ?ys\<langle>?x\<rangle>
WithFact ?x : set (map fst ?ys)
GetGoal (map_of_alist ?ys\<langle>?x\<rangle> = None, Mapping_Str.map_of_alist_nil'@eqforward)
Mapping_Str.map_of_alist_nil'@invbackward
WithTerm map_of_alist ?ys\<langle>?x\<rangle>
WithGoal ?x : set (map fst ?ys)
GetFact (map_of_alist ?ys\<langle>?x\<rangle> = None, Mapping_Str.map_of_alist_nil'@invbackward)
Mapping_Str.unique_keys_set_def@eqforward
WithFact unique_keys_set ?S
GetFact (ALL i x y. (i, x) : ?S --> (i, y) : ?S --> x = y, Mapping_Str.unique_keys_set_def@eqforward)
Mapping_Str.unique_keys_set_def@invbackward
WithGoal unique_keys_set ?S
GetGoal (ALL i x y. (i, x) : ?S --> (i, y) : ?S --> x = y, Mapping_Str.unique_keys_set_def@invbackward)
Mapping_Str.unique_keys_setD
WithProperty unique_keys_set ?S
WithFact (?i, ?x) : ?S
WithFact (?i, ?y) : ?S
GetFact (?x = ?y, Mapping_Str.unique_keys_setD)
Delete Mapping_Str.unique_keys_set_def@eqforward
Mapping_Str.map_of_aset_def
WithTerm map_of_aset ?S
GetFact (map_of_aset ?S =
Map (%a. if EX b. (a, b) : ?S then Some (THE b. (a, b) : ?S) else None), Mapping_Str.map_of_aset_def)
Mapping_Str.map_of_aset_case
WithTerm map_of_aset ?S
CreateConcl unique_keys_set ?S
Mapping_Str.map_of_asetI1
WithProperty unique_keys_set ?S
WithTerm map_of_aset ?S\<langle>?a\<rangle>
WithFact (?a, ?b) : ?S
GetFact (map_of_aset ?S\<langle>?a\<rangle> = Some ?b, Mapping_Str.map_of_asetI1)
Mapping_Str.map_of_asetI2
WithTerm map_of_aset ?S\<langle>?a\<rangle>
WithFact ALL b. (?a, b) ~: ?S
GetFact (map_of_aset ?S\<langle>?a\<rangle> = None, Mapping_Str.map_of_asetI2)
Mapping_Str.map_of_asetD1
WithFact map_of_aset ?S\<langle>?a\<rangle> = None
GetFact (ALL b. (?a, b) ~: ?S, Mapping_Str.map_of_asetD1)
Mapping_Str.map_of_asetD2
WithProperty unique_keys_set ?S
WithFact map_of_aset ?S\<langle>?a\<rangle> = Some ?b
GetFact ((?a, ?b) : ?S, Mapping_Str.map_of_asetD2)
Delete Mapping_Str.map_of_aset_def
Mapping_Str.map_of_aset_insert
WithTerm map_of_aset (?S Un {(?k, ?v)})
WithFact unique_keys_set (?S Un {(?k, ?v)})
GetFact (map_of_aset (?S Un {(?k, ?v)}) =  map_of_aset ?S { ?k \<rightarrow> ?v }, Mapping_Str.map_of_aset_insert)
Mapping_Str.map_of_alist_to_aset
WithTerm map_of_aset (set ?xs)
WithFact unique_keys_set (set ?xs)
GetFact (map_of_aset (set ?xs) = map_of_alist ?xs, Mapping_Str.map_of_alist_to_aset)
Mapping_Str.map_of_aset_delete
WithProperty unique_keys_set ?S
WithTerm map_of_aset (?S - {(?k, ?v)})
WithFact (?k, ?v) : ?S
GetFact (map_of_aset (?S - {(?k, ?v)}) = delete_map ?k (map_of_aset ?S), Mapping_Str.map_of_aset_delete)
Mapping_Str.map_of_aset_update
WithProperty unique_keys_set ?S
WithTerm map_of_aset (?S - {(?k, ?v)} Un {(?k, ?v')})
WithFact (?k, ?v) : ?S
GetFact (map_of_aset (?S - {(?k, ?v)} Un {(?k, ?v')}) =
 map_of_aset ?S { ?k \<rightarrow> ?v' }, Mapping_Str.map_of_aset_update)
Mapping_Str.map_of_alist_delete
WithTerm map_of_alist ?xs'
WithFact set ?xs' = set ?xs - {?x}
GetFact (unique_keys_set (set ?xs) -->
?x : set ?xs --> map_of_alist ?xs' = delete_map (fst ?x) (map_of_alist ?xs), Mapping_Str.map_of_alist_delete)
Mapping_Str.map_of_alist_insert
WithTerm map_of_alist ?xs'
WithFact set ?xs' = set ?xs Un {?x}
GetFact (unique_keys_set (set ?xs') -->
map_of_alist ?xs' =  map_of_alist ?xs { fst ?x \<rightarrow> snd ?x }, Mapping_Str.map_of_alist_insert)
Mapping_Str.map_of_alist_update
WithTerm map_of_alist ?xs'
WithFact set ?xs' = set ?xs - {(?k, ?v)} Un {(?k, ?v')}
GetFact (unique_keys_set (set ?xs) -->
(?k, ?v) : set ?xs -->
map_of_alist ?xs' =  map_of_alist ?xs { ?k \<rightarrow> ?v' }, Mapping_Str.map_of_alist_update)
Mapping_Str.keys_of_def
WithTerm keys_of ?M
GetFact (keys_of ?M = {x. ?M\<langle>x\<rangle> ~= None}, Mapping_Str.keys_of_def)
Mapping_Str.keys_of_iff@eqforward
WithFact ?x : keys_of ?M
GetGoal (?M\<langle>?x\<rangle> = None, Mapping_Str.keys_of_iff@eqforward)
Mapping_Str.keys_of_iff@invbackward
WithGoal ?x : keys_of ?M
GetFact (?M\<langle>?x\<rangle> = None, Mapping_Str.keys_of_iff@invbackward)
Mapping_Str.keys_of_iff@sym@eqforward
WithGoal ?M\<langle>?x\<rangle> = None
GetFact (?x : keys_of ?M, Mapping_Str.keys_of_iff@sym@eqforward)
Mapping_Str.keys_of_iff@sym@invbackward
WithFact ?M\<langle>?x\<rangle> = None
GetGoal (?x : keys_of ?M, Mapping_Str.keys_of_iff@sym@invbackward)
Delete Mapping_Str.keys_of_def
Mapping_Str.keys_of_empty
WithTerm keys_of empty_map
GetFact (keys_of empty_map = {}, Mapping_Str.keys_of_empty)
Mapping_Str.keys_of_delete
WithTerm keys_of (delete_map ?x ?M)
GetFact (keys_of (delete_map ?x ?M) = keys_of ?M - {?x}, Mapping_Str.keys_of_delete)
Mapping_Str.is_heap_min_def@eqforward
WithFact is_heap_min ?x ?M
GetFact (?x : keys_of ?M &
(ALL k:keys_of ?M. the ?M\<langle>?x\<rangle> <= the ?M\<langle>k\<rangle>), Mapping_Str.is_heap_min_def@eqforward)
Mapping_Str.is_heap_min_def@invbackward
WithGoal is_heap_min ?x ?M
GetGoal (?x : keys_of ?M &
(ALL k:keys_of ?M. the ?M\<langle>?x\<rangle> <= the ?M\<langle>k\<rangle>), Mapping_Str.is_heap_min_def@invbackward)
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
Quicksort.quicksort_basic
WithTerm quicksort ?xs ?l ?r
GetFact (mset (quicksort ?xs ?l ?r) = mset ?xs &
outer_remains ?xs (quicksort ?xs ?l ?r) ?l ?r, Quicksort.quicksort_basic)
Quicksort.quicksort_trivial1
WithTerm quicksort ?xs ?l ?r
WithFact ?r <= ?l
GetFact (quicksort ?xs ?l ?r = ?xs, Quicksort.quicksort_trivial1)
Quicksort.quicksort_trivial2
WithTerm quicksort ?xs ?l ?r
WithFact length ?xs <= ?r
GetFact (quicksort ?xs ?l ?r = ?xs, Quicksort.quicksort_trivial2)
Connectivity.is_path.simps_1@eqforward
WithFact is_path ?n ?S []
GetResolve Connectivity.is_path.simps_1@eqforward
Connectivity.is_path.simps_1@invbackward
WithGoal is_path ?n ?S []
GetGoal (False, Connectivity.is_path.simps_1@invbackward)
Apply def ?xs' = quicksort ?xs ?l ?r
Connectivity.is_path.simps_2@eqforward
WithFact is_path ?n ?S (?x # ?xs)
GetFact (if ?xs = [] then ?x < ?n
else ((?x, hd ?xs) : ?S | (hd ?xs, ?x) : ?S) & is_path ?n ?S ?xs, Connectivity.is_path.simps_2@eqforward)
Quicksort.quicksort_permutes@res
WithGoal set (sublist ?l (?r + 1) (quicksort ?xs ?l ?r)) =
set (sublist ?l (?r + 1) ?xs)
GetResolve Quicksort.quicksort_permutes@res
Connectivity.is_path.simps_2@invbackward
WithGoal is_path ?n ?S (?x # ?xs)
GetGoal (if ?xs = [] then ?x < ?n
else ((?x, hd ?xs) : ?S | (hd ?xs, ?x) : ?S) & is_path ?n ?S ?xs, Connectivity.is_path.simps_2@invbackward)
Quicksort.quicksort_sorts
WithTerm sublist ?l (?r + 1) (quicksort ?xs ?l ?r)
WithFact ?r < length ?xs
GetFact (Lists_Thms.sorted (sublist ?l (?r + 1) (quicksort ?xs ?l ?r)), Quicksort.quicksort_sorts)
Connectivity.has_path_def@eqforward
WithFact has_path ?n ?S ?i ?j
GetFact (EX p. is_path ?n ?S p & hd p = ?i & last p = ?j, Connectivity.has_path_def@eqforward)
Quicksort.quicksort_sorts_all
WithTerm quicksort ?xs 0 (length ?xs - 1)
WithGoal ?xs = []
GetFact (quicksort ?xs 0 (length ?xs - 1) = sort ?xs, Quicksort.quicksort_sorts_all)
Connectivity.has_path_def@invbackward
WithGoal has_path ?n ?S ?i ?j
GetGoal (EX p. is_path ?n ?S p & hd p = ?i & last p = ?j, Connectivity.has_path_def@invbackward)
### theory "Draft.Quicksort"
### 0.376s elapsed time, 1.495s cpu time, 0.087s GC time
Loading theory "Draft.SepLogic_Base" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto")
Connectivity.is_path_nonempty
WithFact is_path ?n ?S ?p
GetGoal (?p = [], Connectivity.is_path_nonempty)
Connectivity.nonempty_is_not_path@res
WithFact is_path ?n ?S []
GetResolve Connectivity.nonempty_is_not_path@res
Connectivity.is_path_extend
WithFact is_path ?n ?S ?p
WithFact ?S <= ?T
GetFact (is_path ?n ?T ?p, Connectivity.is_path_extend)
Connectivity.has_path_extend
WithFact has_path ?n ?S ?i ?j
WithFact ?S <= ?T
GetFact (has_path ?n ?T ?i ?j, Connectivity.has_path_extend)
Connectivity.joinable_def@eqforward
WithFact joinable ?p ?q
GetFact (last ?p = hd ?q, Connectivity.joinable_def@eqforward)
Connectivity.joinable_def@invbackward
WithGoal joinable ?p ?q
GetGoal (last ?p = hd ?q, Connectivity.joinable_def@invbackward)
Connectivity.path_join_def
WithTerm path_join ?p ?q
GetFact (path_join ?p ?q = ?p @ tl ?q, Connectivity.path_join_def)
Connectivity.path_join_case
WithTerm path_join ?p ?q
CreateConcl joinable ?p ?q
Connectivity.path_join_hd
WithTerm hd (path_join ?p ?q)
WithGoal ?p = []
GetFact (hd (path_join ?p ?q) = hd ?p, Connectivity.path_join_hd)
Connectivity.path_join_last
WithWellForm joinable ?p ?q
WithTerm last (path_join ?p ?q)
WithGoal ?q = []
GetFact (last (path_join ?p ?q) = last ?q, Connectivity.path_join_last)
Connectivity.path_join_is_path@back
WithWellForm joinable ?p ?q
WithGoal is_path ?n ?S (path_join ?p ?q)
GetGoal (is_path ?n ?S ?p & is_path ?n ?S ?q, Connectivity.path_join_is_path@back)
Connectivity.has_path_trans
WithFact has_path ?n ?S ?i ?j
WithFact has_path ?n ?S ?j ?k
GetFact (has_path ?n ?S ?i ?k, Connectivity.has_path_trans)
signature SEP_UTIL =
  sig
    val apply_to_entail_r: conv -> thm -> thm
    val assnT: typ
    val assn_ac_info: ac_info
    val assn_rewr_terms: term -> term list
    val assn_true: term
    val bind_rule_th': thm
    val cdest_entail: cterm -> cterm * cterm
    val dest_entail: term -> term * term
    val dest_hoare_triple: term -> term * term * term
    val emp: term
    val entail_t: term
    val entail_triv_th: Proof.context -> term -> thm
    val entail_true_th: Proof.context -> term -> thm
    val entails_equiv_backward_th: thm
    val entails_equiv_forward_th: thm
    val entails_ex_post_th: thm
    val entails_ex_th: thm
    val entails_frame_th': thm
    val entails_frame_th'': thm
    val entails_pure_post_th: thm
    val entails_pure_th: thm
    val entails_pure_th': thm
    val entails_trans2_th: thm
    val has_pure_assn: term -> bool
    val heap_eq_pat: term
    val hoare_triple_pat: term
    val is_bind_cmd: term -> bool
    val is_entail: term -> bool
    val is_ex_assn: term -> bool
    val is_hoare_triple: term -> bool
    val is_pure_assn: term -> bool
    val is_true_assn: term -> bool
    val mult_emp_left: conv
    val mult_emp_right: conv
    val norm_pre_pure_iff2_th: thm
    val norm_pre_pure_iff_th: thm
    val normalize_assn_cv: Proof.context -> conv
    val normalize_times_cv: Proof.context -> conv
    val post_rule_th': thm
    val pre_ex_rule_th: thm
    val pre_pure_rule_th: thm
    val pre_pure_rule_th': thm
    val pre_rule_th': thm
    val pre_rule_th'': thm
    val pure_conj_th: thm
    val pure_ord: term * term -> bool
    val reduce_emp_right: conv
    val strip_pure_assn: term -> term
  end
Connectivity.is_valid_graph_def@eqforward
WithFact is_valid_graph ?n ?S
GetFact (ALL p:?S. fst p < ?n & snd p < ?n, Connectivity.is_valid_graph_def@eqforward)
Connectivity.is_valid_graph_def@invbackward
WithGoal is_valid_graph ?n ?S
GetGoal (ALL p:?S. fst p < ?n & snd p < ?n, Connectivity.is_valid_graph_def@invbackward)
Connectivity.has_path_single1@back1
WithGoal has_path ?n ?S ?a ?b
WithFact (?a, ?b) : ?S
GetGoal (is_valid_graph ?n ?S, Connectivity.has_path_single1@back1)
Connectivity.has_path_single2@back1
WithGoal has_path ?n ?S ?b ?a
WithFact (?a, ?b) : ?S
GetGoal (is_valid_graph ?n ?S, Connectivity.has_path_single2@back1)
Connectivity.has_path_refl@back2
WithGoal has_path ?n ?S ?a ?a
WithFact is_valid_graph ?n ?S
GetGoal (?a < ?n, Connectivity.has_path_refl@back2)
Connectivity.connected_rel_iff@eqforward
WithFact (?a, ?b) : connected_rel ?n ?S
GetFact (has_path ?n ?S ?a ?b, Connectivity.connected_rel_iff@eqforward)
Connectivity.connected_rel_iff@invbackward
WithGoal (?a, ?b) : connected_rel ?n ?S
GetGoal (has_path ?n ?S ?a ?b, Connectivity.connected_rel_iff@invbackward)
Add property rule for function Connectivity.connected_rel
Connectivity.connected_rel_refl@back2
WithGoal (?a, ?a) : connected_rel ?n ?S
WithFact is_valid_graph ?n ?S
GetGoal (?a < ?n, Connectivity.connected_rel_refl@back2)
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Connectivity.is_path_per_union@eqforward
WithFact has_path ?n (?S Un {(?a, ?b)}) ?i ?j
WithFact is_valid_graph ?n (?S Un {(?a, ?b)})
GetFact ((?i, ?j) : per_union (connected_rel ?n ?S) ?a ?b, Connectivity.is_path_per_union@eqforward)
Connectivity.is_path_per_union@invbackward
WithGoal has_path ?n (?S Un {(?a, ?b)}) ?i ?j
WithFact is_valid_graph ?n (?S Un {(?a, ?b)})
GetGoal ((?i, ?j) : per_union (connected_rel ?n ?S) ?a ?b, Connectivity.is_path_per_union@invbackward)
Mapping_Str.map_constr.simps_1
WithTerm map_constr ?S ?f 0
GetFact (map_constr ?S ?f 0 = empty_map, Mapping_Str.map_constr.simps_1)
Mapping_Str.map_constr.simps_2
WithTerm map_constr ?S ?f (Suc ?k)
GetFact (map_constr ?S ?f (Suc ?k) =
(let M = map_constr ?S ?f ?k
 in if ?S ?k then  M { ?k \<rightarrow> ?f ?k } else M), Mapping_Str.map_constr.simps_2)
Connectivity.connected_rel_union
WithTerm connected_rel ?n (?S Un {(?a, ?b)})
WithFact is_valid_graph ?n (?S Un {(?a, ?b)})
GetFact (connected_rel ?n (?S Un {(?a, ?b)}) = per_union (connected_rel ?n ?S) ?a ?b, Connectivity.connected_rel_union)
Connectivity.connected_rel_init
WithTerm connected_rel ?n {}
GetFact (connected_rel ?n {} = uf_init_rel ?n, Connectivity.connected_rel_init)
Mapping_Str.map_constr_eval
WithTerm map_constr ?S ?f ?n
GetFact (map_constr ?S ?f ?n =
Map (%i. if i < ?n then if ?S i then Some (?f i) else None else None), Mapping_Str.map_constr_eval)
Mapping_Str.keys_of_map_constr@eqforward
WithFact ?i : keys_of (map_constr ?S ?f ?n)
GetFact (?S ?i & ?i < ?n, Mapping_Str.keys_of_map_constr@eqforward)
Mapping_Str.keys_of_map_constr@invbackward
WithGoal ?i : keys_of (map_constr ?S ?f ?n)
GetGoal (?S ?i & ?i < ?n, Mapping_Str.keys_of_map_constr@invbackward)
Mapping_Str.map_update_all_def
WithTerm map_update_all ?f ?M
GetFact (map_update_all ?f ?M =
Map (%i. if i : keys_of ?M then Some (?f i) else ?M\<langle>i\<rangle>), Mapping_Str.map_update_all_def)
type assn_matcher =
   Proof.context -> term * cterm -> id_inst -> id_inst_th list
signature ASSN_MATCHER =
  sig
    val add_assn_matcher: assn_matcher -> theory -> theory
    val add_assn_matcher_proofsteps: theory -> theory
    val add_entail_matcher: thm -> theory -> theory
    val assn_match_all:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val assn_match_single:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val assn_match_strict:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val assn_match_term:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val emp_assn_matcher: assn_matcher
    val triv_assn_matcher: assn_matcher
    val true_assn_matcher: assn_matcher
  end
structure MatchData: THEORY_DATA
functor AssnMatcher (SepUtil: SEP_UTIL): ASSN_MATCHER
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Connectivity.connected_rel_ind.simps_1
WithTerm connected_rel_ind ?n ?es 0
GetFact (connected_rel_ind ?n ?es 0 = uf_init_rel ?n, Connectivity.connected_rel_ind.simps_1)
Connectivity.connected_rel_ind.simps_2
WithTerm connected_rel_ind ?n ?es (Suc ?k)
GetFact (connected_rel_ind ?n ?es (Suc ?k) =
(let R = connected_rel_ind ?n ?es ?k; p = ?es ! ?k
 in per_union R (fst p) (snd p)), Connectivity.connected_rel_ind.simps_2)
Connectivity.connected_rel_ind_rule
WithTerm connected_rel_ind ?n ?es ?k
WithFact is_valid_graph ?n (set ?es)
GetFact (?k <= length ?es -->
connected_rel_ind ?n ?es ?k = connected_rel ?n (set (take ?k ?es)), Connectivity.connected_rel_ind_rule)
signature SEP_LOGIC =
  sig
    val TY_CODE_POS: string
    val TY_ENTAIL: string
    val add_backward_ent_prfstep: thm -> theory -> theory
    val add_forward_ent_prfstep: thm -> theory -> theory
    val add_hoare_triple_prfstep: thm -> theory -> theory
    val add_rewrite_ent_rule: thm -> theory -> theory
    val add_sep_logic_proofsteps: theory -> theory
    val contract_hoare_cv: Proof.context -> conv
    val entail_create_case: proofstep
    val entail_goal_update: Proof.context -> box_id * thm -> raw_update
    val entail_pure: proofstep
    val entails_resolve: proofstep
    val extract_pure_hoare_cv: conv
    val get_first_cmd: term -> term
    val get_hoare_triples: theory -> string -> thm list
    val get_proc_def: theory -> term -> thm list
    val hoare_create_case: proofstep
    val hoare_goal_update: Proof.context -> box_id * thm -> raw_update
    val hoare_triple: proofstep
    val init_entail: proofstep
    val init_pos: proofstep
    val is_bind_cmd: term -> bool
    val is_implies_item: box_item -> bool
    val is_neg_entail: term -> bool
    val is_neg_hoare_triple: term -> bool
    val match_assn_pure: proofstep
    val match_hoare_disj: proofstep
    val match_hoare_prop: proofstep
    val match_hoare_th:
       box_id -> Proof.context -> thm -> thm -> box_item -> raw_update list
    val norm_entail_conds: Proof.context -> conv
    val norm_precond: Proof.context -> conv
    val normalize_entail_goal_cv: Proof.context -> conv
    val normalize_hoare_goal_cv: Proof.context -> conv
    val rewrite_pos: proofstep
    val update_hoare_triple: thm -> theory -> theory
  end
functor SepLogic (SepUtil: SEP_UTIL): SEP_LOGIC
Connectivity.connected_rel_ind_compute
WithTerm connected_rel_ind ?n ?es (length ?es)
WithFact is_valid_graph ?n (set ?es)
GetFact (connected_rel_ind ?n ?es (length ?es) = connected_rel ?n (set ?es), Connectivity.connected_rel_ind_compute)
### theory "Draft.SepLogic_Base"
### 0.186s elapsed time, 0.737s cpu time, 0.078s GC time
Loading theory "HOL-Imperative_HOL.Ref" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL")
### theory "Draft.Connectivity"
### 0.340s elapsed time, 1.349s cpu time, 0.078s GC time
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Mapping_Str.map_update_all_impl.simps_1
WithTerm map_update_all_impl ?f ?M 0
GetFact (map_update_all_impl ?f ?M 0 = ?M, Mapping_Str.map_update_all_impl.simps_1)
Mapping_Str.map_update_all_impl.simps_2
WithTerm map_update_all_impl ?f ?M (Suc ?k)
GetFact (map_update_all_impl ?f ?M (Suc ?k) =
(let M' = map_update_all_impl ?f ?M ?k
 in if ?k : keys_of ?M then  M' { ?k \<rightarrow> ?f ?k } else M'), Mapping_Str.map_update_all_impl.simps_2)
Mapping_Str.map_update_all_impl_ind
WithTerm map_update_all_impl ?f ?M ?n
GetFact (map_update_all_impl ?f ?M ?n =
Map (%i. if i < ?n then if i : keys_of ?M then Some (?f i) else None
         else ?M\<langle>i\<rangle>), Mapping_Str.map_update_all_impl_ind)
Mapping_Str.map_update_all_impl_correct
WithTerm map_update_all_impl ?f ?M ?n
WithFact ALL i:keys_of ?M. i < ?n
GetFact (map_update_all_impl ?f ?M ?n = map_update_all ?f ?M, Mapping_Str.map_update_all_impl_correct)
Mapping_Str.keys_of_map_update_all
WithTerm keys_of (map_update_all ?f ?M)
GetFact (keys_of (map_update_all ?f ?M) = keys_of ?M, Mapping_Str.keys_of_map_update_all)
### theory "Draft.Mapping_Str"
### 1.080s elapsed time, 4.235s cpu time, 0.398s GC time
Loading theory "Draft.Dijkstra" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Dijkstra_Impl")
Loading theory "Draft.Indexed_PQueue" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Indexed_PQueue_Impl")
Interval.idx_interval.collapse@sym
WithTerm ?idx_interval
GetFact (?idx_interval =
IdxInterval (idx_interval.int ?idx_interval) (idx ?idx_interval), Interval.idx_interval.collapse@sym) + 1 filters
Interval.idx_interval.case
WithTerm case IdxInterval ?x1.0 ?x2.0 of IdxInterval x xa => ?f x xa
GetFact ((case IdxInterval ?x1.0 ?x2.0 of IdxInterval x xa => ?f x xa) =
?f ?x1.0 ?x2.0, Interval.idx_interval.case)
Interval.idx_interval.sel_1
WithTerm idx_interval.int (IdxInterval ?x1.0 ?x2.0)
GetFact (idx_interval.int (IdxInterval ?x1.0 ?x2.0) = ?x1.0, Interval.idx_interval.sel_1)
Interval.idx_interval.sel_2
WithTerm idx (IdxInterval ?x1.0 ?x2.0)
GetFact (idx (IdxInterval ?x1.0 ?x2.0) = ?x2.0, Interval.idx_interval.sel_2)
Interval.idx_interval.simps_1@eqforward
WithFact IdxInterval ?x1.0 ?x2.0 = IdxInterval ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Interval.idx_interval.simps_1@eqforward)
instantiation
  idx_interval :: (linorder) linorder
  less_eq_idx_interval == less_eq ::
    'a idx_interval => 'a idx_interval => bool
  less_idx_interval == less :: 'a idx_interval => 'a idx_interval => bool
Interval.interval_less_to_le_low
WithFact ?a < ?b
GetFact (low (idx_interval.int ?a) <= low (idx_interval.int ?b), Interval.interval_less_to_le_low)
### Ambiguous input (line 211 of "~~/src/HOL/Imperative_HOL/Ref.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Ref.lookup" ("_thenM" ("_position" r) ("_position" f)))
###     ("_position" f)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_thenM" ("\<^const>Ref.lookup" ("_position" r)) ("_position" f))
###     ("_position" f)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Interval.is_overlap_def@eqforward
WithFact is_overlap ?x ?y
GetFact (low ?y <= high ?x & low ?x <= high ?y, Interval.is_overlap_def@eqforward)
Interval.is_overlap_def@invbackward
WithGoal is_overlap ?x ?y
GetGoal (low ?y <= high ?x & low ?x <= high ?y, Interval.is_overlap_def@invbackward)
### Ambiguous input (line 215 of "~~/src/HOL/Imperative_HOL/Ref.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Ref.update" ("_position" r)
###     ("\<^const>HOL.eq" ("_position" e)
###       ("_thenM"
###         ("_applC" ("_position" change)
###           ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###             ("_position" r)))
###         ("_applC" ("_position" return) ("\<^const>Product_Type.Unity"))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^const>Ref.update" ("_position" r) ("_position" e))
###     ("_thenM"
###       ("_applC" ("_position" change)
###         ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###           ("_position" r)))
###       ("_applC" ("_position" return) ("\<^const>Product_Type.Unity")))))
### ("\<^const>HOL.Trueprop"
###   ("_thenM"
###     ("\<^const>Ref.update" ("_position" r)
###       ("\<^const>HOL.eq" ("_position" e)
###         ("_applC" ("_position" change)
###           ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###             ("_position" r)))))
###     ("_applC" ("_position" return) ("\<^const>Product_Type.Unity"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Interval.has_overlap_def@eqforward
WithFact has_overlap ?xs ?y
GetFact (EX x:?xs. is_overlap (idx_interval.int x) ?y, Interval.has_overlap_def@eqforward)
Interval.has_overlap_def@invbackward
WithGoal has_overlap ?xs ?y
GetGoal (EX x:?xs. is_overlap (idx_interval.int x) ?y, Interval.has_overlap_def@invbackward)
### theory "Draft.Interval"
### 1.242s elapsed time, 4.879s cpu time, 0.459s GC time
Loading theory "Draft.Lists_Ex" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.BST_Impl" via "Draft.BST")
### theory "HOL-Imperative_HOL.Ref"
### 0.226s elapsed time, 0.854s cpu time, 0.061s GC time
Loading theory "HOL-Imperative_HOL.Imperative_HOL" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl" via "Draft.SepAuto")
### theory "HOL-Imperative_HOL.Imperative_HOL"
### 0.030s elapsed time, 0.126s cpu time, 0.000s GC time
Loading theory "Draft.SepAuto" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.GCD_Impl")
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
Lists_Ex.itrev.simps_1
WithTerm itrev [] ?ys
GetFact (itrev [] ?ys = ?ys, Lists_Ex.itrev.simps_1)
Lists_Ex.itrev.simps_2
WithTerm itrev (?x # ?xs) ?ys
GetFact (itrev (?x # ?xs) ?ys = itrev ?xs (?x # ?ys), Lists_Ex.itrev.simps_2)
Found termination order: "{}"
Found termination order: "{}"
Indexed_PQueue.s_inj_1
WithFact s1 ?m = s1 ?m'
GetFact (?m = ?m', Indexed_PQueue.s_inj_1)
Indexed_PQueue.s_inj_2
WithFact s2 ?m = s2 ?m'
GetFact (?m = ?m', Indexed_PQueue.s_inj_2)
Indexed_PQueue.s_neq_1@res
WithFact s1 ?m = s2 ?m'
GetResolve Indexed_PQueue.s_neq_1@res
Indexed_PQueue.s_neq_2@res
WithGoal ?m < s1 ?m
GetResolve Indexed_PQueue.s_neq_2@res
Indexed_PQueue.s_neq_3@res
WithGoal ?m < s2 ?m
GetResolve Indexed_PQueue.s_neq_3@res
Indexed_PQueue.s_neq_4@res
WithGoal s1 ?m < s2 ?m
GetResolve Indexed_PQueue.s_neq_4@res
Indexed_PQueue.s_neq_2
WithTerm s1 ?m
GetFact (?m < s1 ?m, Indexed_PQueue.s_neq_2)
Indexed_PQueue.s_neq_3
WithTerm s2 ?m
GetFact (?m < s2 ?m, Indexed_PQueue.s_neq_3)
Indexed_PQueue.s_neq_4
WithTerm s2 ?m
WithTerm s1 ?m
GetFact (s1 ?m < s2 ?m, Indexed_PQueue.s_neq_4)
Found termination order: "length <*mlex*> {}"
Proofs for inductive predicate(s) "eq_pred"
  Proving monotonicity ...
Lists_Ex.strict_sorted.simps_1@eqforward
WithFact strict_sorted []
GetFact (True, Lists_Ex.strict_sorted.simps_1@eqforward)
Lists_Ex.strict_sorted.simps_1@invbackward
WithGoal strict_sorted []
GetGoal (True, Lists_Ex.strict_sorted.simps_1@invbackward)
Lists_Ex.strict_sorted.simps_2@eqforward
WithFact strict_sorted (?x # ?ys)
GetFact (Ball (set ?ys) ((<) ?x) & strict_sorted ?ys, Lists_Ex.strict_sorted.simps_2@eqforward)
Lists_Ex.strict_sorted.simps_2@invbackward
WithGoal strict_sorted (?x # ?ys)
GetGoal (Ball (set ?ys) ((<) ?x) & strict_sorted ?ys, Lists_Ex.strict_sorted.simps_2@invbackward)
Lists_Ex.strict_sorted_appendI@back
WithGoal strict_sorted (?xs @ ?ys)
GetGoal (strict_sorted ?xs &
strict_sorted ?ys & (ALL x:set ?xs. ALL y:set ?ys. x < y), Lists_Ex.strict_sorted_appendI@back)
Lists_Ex.strict_sorted_appendE1
WithFact strict_sorted (?xs @ ?ys)
GetFact (strict_sorted ?xs & strict_sorted ?ys, Lists_Ex.strict_sorted_appendE1)
Lists_Ex.strict_sorted_appendE2
WithFact strict_sorted (?xs @ ?ys)
WithFact ?x : set ?xs
GetFact (ALL y:set ?ys. ?x < y, Lists_Ex.strict_sorted_appendE2)
Add property rule for [Lists_Ex.strict_sorted]
Indexed_PQueue.eq_pred.intros_1@res
WithGoal eq_pred ?n ?n
GetResolve Indexed_PQueue.eq_pred.intros_1@res
Indexed_PQueue.eq_pred.intros_2@back
WithGoal eq_pred ?n (s1 ?m)
GetGoal (eq_pred ?n ?m, Indexed_PQueue.eq_pred.intros_2@back)
Indexed_PQueue.eq_pred.intros_3@back
WithGoal eq_pred ?n (s2 ?m)
GetGoal (eq_pred ?n ?m, Indexed_PQueue.eq_pred.intros_3@back)
Indexed_PQueue.eq_pred_parent1
WithFact eq_pred ?i (s1 ?k)
WithGoal ?i = s1 ?k
GetFact (eq_pred ?i ?k, Indexed_PQueue.eq_pred_parent1)
Indexed_PQueue.eq_pred_parent2
WithFact eq_pred ?i (s2 ?k)
WithGoal ?i = s2 ?k
GetFact (eq_pred ?i ?k, Indexed_PQueue.eq_pred_parent2)
Indexed_PQueue.eq_pred_cases
WithFact eq_pred ?i ?j
GetFact (eq_pred (s1 ?i) ?j | eq_pred (s2 ?i) ?j | ?j = ?i | ?j = s1 ?i | ?j = s2 ?i, Indexed_PQueue.eq_pred_cases) + 2 filters
Indexed_PQueue.eq_pred_le
WithFact eq_pred ?i ?j
GetFact (?i <= ?j, Indexed_PQueue.eq_pred_le)
Indexed_PQueue.is_heap_def@eqforward
WithFact is_heap ?xs
GetFact (ALL i j. eq_pred i j --> j < length ?xs --> snd (?xs ! i) <= snd (?xs ! j), Indexed_PQueue.is_heap_def@eqforward)
Indexed_PQueue.is_heap_def@invbackward
WithGoal is_heap ?xs
GetGoal (ALL i j. eq_pred i j --> j < length ?xs --> snd (?xs ! i) <= snd (?xs ! j), Indexed_PQueue.is_heap_def@invbackward)
Indexed_PQueue.is_heapD
WithProperty is_heap ?xs
WithWellForm ?j < length ?xs
WithTerm ?xs ! ?j
WithFact eq_pred ?i ?j
GetFact (snd (?xs ! ?i) <= snd (?xs ! ?j), Indexed_PQueue.is_heapD)
Delete Indexed_PQueue.is_heap_def@eqforward
Indexed_PQueue.is_heap_partial1_def@eqforward
WithFact is_heap_partial1 ?xs ?k
GetFact (ALL i j.
   eq_pred i j -->
   i ~= ?k --> j < length ?xs --> snd (?xs ! i) <= snd (?xs ! j), Indexed_PQueue.is_heap_partial1_def@eqforward)
Indexed_PQueue.is_heap_partial1_def@invbackward
WithGoal is_heap_partial1 ?xs ?k
GetGoal (ALL i j.
   eq_pred i j -->
   i ~= ?k --> j < length ?xs --> snd (?xs ! i) <= snd (?xs ! j), Indexed_PQueue.is_heap_partial1_def@invbackward)
Indexed_PQueue.bubble_down1
WithWellForm s1 ?k < length ?xs
WithTerm list_swap ?xs ?k (s1 ?k)
WithFact is_heap_partial1 ?xs ?k
GetFact (snd (?xs ! s1 ?k) < snd (?xs ! ?k) -->
snd (?xs ! s1 ?k) <= snd (?xs ! s2 ?k) -->
is_heap_partial1 (list_swap ?xs ?k (s1 ?k)) (s1 ?k), Indexed_PQueue.bubble_down1)
Indexed_PQueue.bubble_down2
WithWellForm s1 ?k < length ?xs
WithTerm list_swap ?xs ?k (s1 ?k)
WithFact is_heap_partial1 ?xs ?k
GetFact (snd (?xs ! s1 ?k) < snd (?xs ! ?k) -->
length ?xs <= s2 ?k --> is_heap_partial1 (list_swap ?xs ?k (s1 ?k)) (s1 ?k), Indexed_PQueue.bubble_down2)
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Apply def ?xs' = list_swap ?xs ?k (s2 ?k)
Indexed_PQueue.bubble_down3
WithWellForm s2 ?k < length ?xs
WithTerm list_swap ?xs ?k (s2 ?k)
WithFact is_heap_partial1 ?xs ?k
GetFact (snd (?xs ! s2 ?k) < snd (?xs ! s1 ?k) -->
snd (?xs ! s2 ?k) < snd (?xs ! ?k) -->
is_heap_partial1 (list_swap ?xs ?k (s2 ?k)) (s2 ?k), Indexed_PQueue.bubble_down3)
Lists_Ex.ordered_insert.simps_1
WithTerm ordered_insert ?x []
GetFact (ordered_insert ?x [] = [?x], Lists_Ex.ordered_insert.simps_1)
Lists_Ex.ordered_insert.simps_2
WithTerm ordered_insert ?x (?y # ?ys)
GetFact (ordered_insert ?x (?y # ?ys) =
(if ?x = ?y then ?y # ?ys
 else if ?x < ?y then ?x # ?y # ?ys else ?y # ordered_insert ?x ?ys), Lists_Ex.ordered_insert.simps_2)
Lists_Ex.ordered_insert_set
WithTerm set (ordered_insert ?x ?ys)
GetFact (set (ordered_insert ?x ?ys) = {?x} Un set ?ys, Lists_Ex.ordered_insert_set)
Add property rule for function Lists_Ex.ordered_insert
Lists_Ex.ordered_insert_binary
WithTerm ordered_insert ?x (?xs @ ?a # ?ys)
WithFact strict_sorted (?xs @ ?a # ?ys)
GetFact (ordered_insert ?x (?xs @ ?a # ?ys) =
(if ?x < ?a then ordered_insert ?x ?xs @ ?a # ?ys
 else if ?a < ?x then ?xs @ ?a # ordered_insert ?x ?ys else ?xs @ ?a # ?ys), Lists_Ex.ordered_insert_binary)
Found termination order: "{}"
Indexed_PQueue.ps_inverse_1
WithTerm par (s1 ?k)
GetFact (par (s1 ?k) = ?k, Indexed_PQueue.ps_inverse_1)
Indexed_PQueue.ps_inverse_2
WithTerm par (s2 ?k)
GetFact (par (s2 ?k) = ?k, Indexed_PQueue.ps_inverse_2)
Indexed_PQueue.p_basic
WithWellForm ?m ~= 0
WithTerm par ?m
GetFact (par ?m < ?m, Indexed_PQueue.p_basic)
Indexed_PQueue.p_cases
WithWellForm ?m ~= 0
WithTerm par ?m
GetFact (?m = s1 (par ?m) | ?m = s2 (par ?m), Indexed_PQueue.p_cases)
Indexed_PQueue.eq_pred_p_next
WithWellForm ?i ~= 0
WithTerm par ?i
WithFact eq_pred ?i ?j
GetFact (eq_pred (par ?i) ?j, Indexed_PQueue.eq_pred_p_next)
Indexed_PQueue.heap_implies_hd_min@res
WithProperty is_heap ?xs
WithWellForm ?i < length ?xs
WithWellForm ?xs ~= []
WithGoal snd (hd ?xs) <= snd (?xs ! ?i)
GetResolve Indexed_PQueue.heap_implies_hd_min@res
Indexed_PQueue.is_heap_partial2_def@eqforward
WithFact is_heap_partial2 ?xs ?k
GetFact (ALL i j.
   eq_pred i j -->
   j < length ?xs --> j ~= ?k --> snd (?xs ! i) <= snd (?xs ! j), Indexed_PQueue.is_heap_partial2_def@eqforward)
Indexed_PQueue.is_heap_partial2_def@invbackward
WithGoal is_heap_partial2 ?xs ?k
GetGoal (ALL i j.
   eq_pred i j -->
   j < length ?xs --> j ~= ?k --> snd (?xs ! i) <= snd (?xs ! j), Indexed_PQueue.is_heap_partial2_def@invbackward)
Indexed_PQueue.bubble_up1
WithWellForm ?k < length ?xs
WithFact is_heap_partial2 ?xs ?k
WithFact snd (?xs ! ?k) < snd (?xs ! par ?k)
GetFact (?k ~= 0 --> is_heap_partial2 (list_swap ?xs ?k (par ?k)) (par ?k), Indexed_PQueue.bubble_up1)
Indexed_PQueue.bubble_up2
WithWellForm ?k < length ?xs
WithFact is_heap_partial2 ?xs ?k
WithFact snd (?xs ! par ?k) <= snd (?xs ! ?k)
GetFact (?k ~= 0 --> is_heap ?xs, Indexed_PQueue.bubble_up2)
Found termination order: "{}"
Delete Indexed_PQueue.p_cases
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Lists_Ex.remove_elt_list.simps_1
WithTerm remove_elt_list ?x []
GetFact (remove_elt_list ?x [] = [], Lists_Ex.remove_elt_list.simps_1)
Lists_Ex.remove_elt_list.simps_2
WithTerm remove_elt_list ?x (?y # ?ys)
GetFact (remove_elt_list ?x (?y # ?ys) =
(if ?y = ?x then remove_elt_list ?x ?ys else ?y # remove_elt_list ?x ?ys), Lists_Ex.remove_elt_list.simps_2)
Lists_Ex.remove_elt_list_set
WithTerm set (remove_elt_list ?x ?ys)
GetFact (set (remove_elt_list ?x ?ys) = set ?ys - {?x}, Lists_Ex.remove_elt_list_set)
Add property rule for function Lists_Ex.remove_elt_list
Lists_Ex.remove_elt_idem
WithTerm remove_elt_list ?x ?ys
WithGoal ?x : set ?ys
GetFact (remove_elt_list ?x ?ys = ?ys, Lists_Ex.remove_elt_idem)
Lists_Ex.remove_elt_list_binary
WithTerm remove_elt_list ?x (?xs @ ?a # ?ys)
WithFact strict_sorted (?xs @ ?a # ?ys)
GetFact (remove_elt_list ?x (?xs @ ?a # ?ys) =
(if ?x < ?a then remove_elt_list ?x ?xs @ ?a # ?ys
 else if ?a < ?x then ?xs @ ?a # remove_elt_list ?x ?ys else ?xs @ ?ys), Lists_Ex.remove_elt_list_binary)
Found termination order: "{}"
Found termination order: "{}"
Indexed_PQueue.index_of_pqueue.simps@eqforward
WithFact index_of_pqueue (?xs, ?m)
GetFact ((ALL i<length ?xs.
    fst (?xs ! i) < length ?m & ?m ! fst (?xs ! i) = Some i) &
(ALL i k.
    k < length ?m -->
    ?m ! k = Some i --> i < length ?xs & fst (?xs ! i) = k), Indexed_PQueue.index_of_pqueue.simps@eqforward)
Indexed_PQueue.index_of_pqueue.simps@invbackward
WithGoal index_of_pqueue (?xs, ?m)
GetGoal ((ALL i<length ?xs.
    fst (?xs ! i) < length ?m & ?m ! fst (?xs ! i) = Some i) &
(ALL i k.
    k < length ?m -->
    ?m ! k = Some i --> i < length ?xs & fst (?xs ! i) = k), Indexed_PQueue.index_of_pqueue.simps@invbackward)
Indexed_PQueue.index_of_pqueueD1
WithWellForm ?i < length ?xs
WithTerm ?xs ! ?i
WithFact index_of_pqueue (?xs, ?m)
GetFact (fst (?xs ! ?i) < length ?m & ?m ! fst (?xs ! ?i) = Some ?i, Indexed_PQueue.index_of_pqueueD1)
Indexed_PQueue.index_of_pqueueD2
WithWellForm ?k < length ?m
WithFact index_of_pqueue (?xs, ?m)
WithFact ?m ! ?k = Some ?i
GetFact (?i < length ?xs & fst (?xs ! ?i) = ?k, Indexed_PQueue.index_of_pqueueD2)
Indexed_PQueue.index_of_pqueueD3
WithFact index_of_pqueue (?xs, ?m)
WithFact ?p : set ?xs
GetFact (fst ?p < length ?m, Indexed_PQueue.index_of_pqueueD3)
Found termination order: "{}"
Delete Indexed_PQueue.index_of_pqueue.simps@eqforward
Indexed_PQueue.has_index_unique_key
WithFact index_of_pqueue (?xs, ?m)
GetFact (unique_keys_set (set ?xs), Indexed_PQueue.has_index_unique_key)
Indexed_PQueue.has_index_keys_of@eqforward
WithFact has_key_alist ?xs ?k
WithFact index_of_pqueue (?xs, ?m)
GetFact (?k < length ?m & ?m ! ?k ~= None, Indexed_PQueue.has_index_keys_of@eqforward)
Indexed_PQueue.has_index_keys_of@invbackward
WithGoal has_key_alist ?xs ?k
WithFact index_of_pqueue (?xs, ?m)
GetGoal (?k < length ?m & ?m ! ?k ~= None, Indexed_PQueue.has_index_keys_of@invbackward)
Dijkstra.valid_graph.simps@eqforward
WithFact valid_graph (Graph ?G)
GetFact (ALL i<length ?G. length (?G ! i) = length ?G, Dijkstra.valid_graph.simps@eqforward)
Dijkstra.valid_graph.simps@invbackward
WithGoal valid_graph (Graph ?G)
GetGoal (ALL i<length ?G. length (?G ! i) = length ?G, Dijkstra.valid_graph.simps@invbackward)
Indexed_PQueue.has_index_distinct
WithFact index_of_pqueue (?xs, ?m)
GetFact (distinct ?xs, Indexed_PQueue.has_index_distinct)
Dijkstra.verts_mem@eqforward
WithFact ?i : verts ?G
GetFact (?i < Dijkstra.size ?G, Dijkstra.verts_mem@eqforward)
Dijkstra.verts_mem@invbackward
WithGoal ?i : verts ?G
GetGoal (?i < Dijkstra.size ?G, Dijkstra.verts_mem@invbackward)
Dijkstra.card_verts
WithTerm card (verts ?G)
GetFact (card (verts ?G) = Dijkstra.size ?G, Dijkstra.card_verts)
Add property rule for function Dijkstra.verts
Dijkstra.is_path_def@eqforward
WithFact is_path ?G ?p
GetFact (?p ~= [] & set ?p <= verts ?G, Dijkstra.is_path_def@eqforward)
Dijkstra.is_path_def@invbackward
WithGoal is_path ?G ?p
GetGoal (?p ~= [] & set ?p <= verts ?G, Dijkstra.is_path_def@invbackward)
Dijkstra.is_path_to_in_verts
WithFact is_path ?G ?p
GetFact (hd ?p : verts ?G & last ?p : verts ?G, Dijkstra.is_path_to_in_verts)
Dijkstra.joinable_def@eqforward
WithFact joinable ?G ?p ?q
GetFact (is_path ?G ?p & is_path ?G ?q & last ?p = hd ?q, Dijkstra.joinable_def@eqforward)
Dijkstra.joinable_def@invbackward
WithGoal joinable ?G ?p ?q
GetGoal (is_path ?G ?p & is_path ?G ?q & last ?p = hd ?q, Dijkstra.joinable_def@invbackward)
Dijkstra.path_join_def
WithTerm path_join ?G ?p ?q
GetFact (path_join ?G ?p ?q = ?p @ tl ?q, Dijkstra.path_join_def)
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
Dijkstra.path_join_case
WithTerm path_join ?G ?p ?q
CreateConcl joinable ?G ?p ?q
Dijkstra.path_join_is_path
WithWellForm joinable ?G ?p ?q
WithTerm path_join ?G ?p ?q
GetFact (is_path ?G (path_join ?G ?p ?q), Dijkstra.path_join_is_path)
Lists_Ex.ordered_insert_pairs.simps_1
WithTerm ordered_insert_pairs ?x ?v []
GetFact (ordered_insert_pairs ?x ?v [] = [(?x, ?v)], Lists_Ex.ordered_insert_pairs.simps_1)
Lists_Ex.ordered_insert_pairs.simps_2
WithTerm ordered_insert_pairs ?x ?v (?y # ?ys)
GetFact (ordered_insert_pairs ?x ?v (?y # ?ys) =
(if ?x = fst ?y then (?x, ?v) # ?ys
 else if ?x < fst ?y then (?x, ?v) # ?y # ?ys
      else ?y # ordered_insert_pairs ?x ?v ?ys), Lists_Ex.ordered_insert_pairs.simps_2)
Lists_Ex.ordered_insert_pairs_map
WithTerm map_of_alist (ordered_insert_pairs ?x ?v ?ys)
GetFact (map_of_alist (ordered_insert_pairs ?x ?v ?ys) =
 map_of_alist ?ys { ?x \<rightarrow> ?v }, Lists_Ex.ordered_insert_pairs_map)
Lists_Ex.ordered_insert_pairs_set
WithTerm set (map fst (ordered_insert_pairs ?x ?v ?ys))
GetFact (set (map fst (ordered_insert_pairs ?x ?v ?ys)) = {?x} Un set (map fst ?ys), Lists_Ex.ordered_insert_pairs_set)
Lists_Ex.ordered_insert_pairs_sorted@back
WithGoal strict_sorted (map fst (ordered_insert_pairs ?x ?v ?ys))
GetGoal (strict_sorted (map fst ?ys), Lists_Ex.ordered_insert_pairs_sorted@back)
Lists_Ex.ordered_insert_pairs_binary
WithTerm ordered_insert_pairs ?x ?v (?xs @ ?a # ?ys)
WithFact strict_sorted (map fst (?xs @ ?a # ?ys))
GetFact (ordered_insert_pairs ?x ?v (?xs @ ?a # ?ys) =
(if ?x < fst ?a then ordered_insert_pairs ?x ?v ?xs @ ?a # ?ys
 else if fst ?a < ?x then ?xs @ ?a # ordered_insert_pairs ?x ?v ?ys
      else ?xs @ (?x, ?v) # ?ys), Lists_Ex.ordered_insert_pairs_binary)
Found termination order: "{}"
Indexed_PQueue.index_of_pqueue_swap
WithTerm idx_pqueue_swap_fun (?xs, ?m) ?i ?j
WithFact ?i < length ?xs
GetFact (?j < length ?xs -->
index_of_pqueue (?xs, ?m) -->
index_of_pqueue (idx_pqueue_swap_fun (?xs, ?m) ?i ?j), Indexed_PQueue.index_of_pqueue_swap)
Indexed_PQueue.fst_idx_pqueue_swap
WithTerm fst (idx_pqueue_swap_fun (?xs, ?m) ?i ?j)
GetFact (fst (idx_pqueue_swap_fun (?xs, ?m) ?i ?j) = list_swap ?xs ?i ?j, Indexed_PQueue.fst_idx_pqueue_swap)
Indexed_PQueue.snd_idx_pqueue_swap
WithTerm length (snd (idx_pqueue_swap_fun (?xs, ?m) ?i ?j))
GetFact (length (snd (idx_pqueue_swap_fun (?xs, ?m) ?i ?j)) = length ?m, Indexed_PQueue.snd_idx_pqueue_swap)
Found termination order:
  "(%p. size_list size_class.size (snd p)) <*mlex*> {}"
Dijkstra.path_weight.simps_1
WithTerm path_weight ?G []
GetFact (path_weight ?G [] = 0, Dijkstra.path_weight.simps_1)
Dijkstra.path_weight.simps_2
WithTerm path_weight ?G (?x # ?xs)
GetFact (path_weight ?G (?x # ?xs) =
(if ?xs = [] then 0 else weight ?G ?x (hd ?xs) + path_weight ?G ?xs), Dijkstra.path_weight.simps_2)
Dijkstra.path_weight_singleton
WithTerm path_weight ?G [?x]
GetFact (path_weight ?G [?x] = 0, Dijkstra.path_weight_singleton)
Dijkstra.path_weight_doubleton
WithTerm path_weight ?G [?m, ?n]
GetFact (path_weight ?G [?m, ?n] = weight ?G ?m ?n, Dijkstra.path_weight_doubleton)
Dijkstra.path_weight_sum
WithWellForm joinable ?G ?p ?q
WithTerm path_weight ?G (path_join ?G ?p ?q)
GetFact (path_weight ?G (path_join ?G ?p ?q) = path_weight ?G ?p + path_weight ?G ?q, Dijkstra.path_weight_sum)
Found termination order: "{}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Apply def ?r = idx_pqueue_push_fun ?k ?v (?xs, ?m)
Lists_Ex.remove_elt_pairs.simps_1
WithTerm remove_elt_pairs ?x []
GetFact (remove_elt_pairs ?x [] = [], Lists_Ex.remove_elt_pairs.simps_1)
Lists_Ex.remove_elt_pairs.simps_2
WithTerm remove_elt_pairs ?x (?y # ?ys)
GetFact (remove_elt_pairs ?x (?y # ?ys) =
(if fst ?y = ?x then ?ys else ?y # remove_elt_pairs ?x ?ys), Lists_Ex.remove_elt_pairs.simps_2)
Indexed_PQueue.idx_pqueue_push_correct
WithTerm idx_pqueue_push_fun ?k ?v (?xs, ?m)
WithFact index_of_pqueue (?xs, ?m)
GetFact (?k < length ?m -->
~ has_key_alist ?xs ?k -->
index_of_pqueue (idx_pqueue_push_fun ?k ?v (?xs, ?m)) &
fst (idx_pqueue_push_fun ?k ?v (?xs, ?m)) = ?xs @ [(?k, ?v)] &
length (snd (idx_pqueue_push_fun ?k ?v (?xs, ?m))) = length ?m, Indexed_PQueue.idx_pqueue_push_correct)
Found termination order: "{}"
Lists_Ex.remove_elt_pairs_map
WithTerm map_of_alist (remove_elt_pairs ?x ?ys)
WithFact strict_sorted (map fst ?ys)
GetFact (map_of_alist (remove_elt_pairs ?x ?ys) = delete_map ?x (map_of_alist ?ys), Lists_Ex.remove_elt_pairs_map)
Lists_Ex.remove_elt_pairs_on_set
WithTerm set (map fst (remove_elt_pairs ?x ?ys))
WithFact strict_sorted (map fst ?ys)
GetFact (set (map fst (remove_elt_pairs ?x ?ys)) = set (map fst ?ys) - {?x}, Lists_Ex.remove_elt_pairs_on_set)
Dijkstra.path_set_mem@eqforward
WithFact ?p : path_set ?G ?m ?n
GetFact (is_path ?G ?p & hd ?p = ?m & last ?p = ?n, Dijkstra.path_set_mem@eqforward)
Dijkstra.path_set_mem@invbackward
WithGoal ?p : path_set ?G ?m ?n
GetGoal (is_path ?G ?p & hd ?p = ?m & last ?p = ?n, Dijkstra.path_set_mem@invbackward)
Lists_Ex.remove_elt_pairs_sorted@back
WithGoal strict_sorted (map fst (remove_elt_pairs ?x ?ys))
GetGoal (strict_sorted (map fst ?ys), Lists_Ex.remove_elt_pairs_sorted@back)
Lists_Ex.remove_elt_pairs_idem
WithTerm remove_elt_pairs ?x ?ys
WithGoal ?x : set (map fst ?ys)
GetFact (remove_elt_pairs ?x ?ys = ?ys, Lists_Ex.remove_elt_pairs_idem)
Dijkstra.path_join_set
WithWellForm joinable ?G ?p ?q
WithTerm path_join ?G ?p ?q
GetFact (path_join ?G ?p ?q : path_set ?G (hd ?p) (last ?q), Dijkstra.path_join_set)
Lists_Ex.remove_elt_pairs_binary
WithTerm remove_elt_pairs ?x (?xs @ ?a # ?ys)
WithFact strict_sorted (map fst (?xs @ ?a # ?ys))
GetFact (remove_elt_pairs ?x (?xs @ ?a # ?ys) =
(if ?x < fst ?a then remove_elt_pairs ?x ?xs @ ?a # ?ys
 else if fst ?a < ?x then ?xs @ ?a # remove_elt_pairs ?x ?ys else ?xs @ ?ys), Lists_Ex.remove_elt_pairs_binary)
Dijkstra.is_shortest_path_def@eqforward
WithFact is_shortest_path ?G ?m ?n ?p
GetFact (?p : path_set ?G ?m ?n &
(ALL p':path_set ?G ?m ?n. path_weight ?G ?p <= path_weight ?G p'), Dijkstra.is_shortest_path_def@eqforward)
Dijkstra.is_shortest_path_def@invbackward
WithGoal is_shortest_path ?G ?m ?n ?p
GetGoal (?p : path_set ?G ?m ?n &
(ALL p':path_set ?G ?m ?n. path_weight ?G ?p <= path_weight ?G p'), Dijkstra.is_shortest_path_def@invbackward)
Dijkstra.is_shortest_pathD1
WithFact is_shortest_path ?G ?m ?n ?p
GetFact (?p : path_set ?G ?m ?n, Dijkstra.is_shortest_pathD1)
Dijkstra.is_shortest_pathD2
WithFact is_shortest_path ?G ?m ?n ?p
WithFact ?p' : path_set ?G ?m ?n
GetFact (path_weight ?G ?p <= path_weight ?G ?p', Dijkstra.is_shortest_pathD2)
Lists_Ex.map_of_alist_binary
WithTerm map_of_alist (?xs @ ?a # ?ys)\<langle>?x\<rangle>
WithFact strict_sorted (map fst (?xs @ ?a # ?ys))
GetFact (map_of_alist (?xs @ ?a # ?ys)\<langle>?x\<rangle> =
(if ?x < fst ?a then map_of_alist ?xs\<langle>?x\<rangle>
 else if fst ?a < ?x then map_of_alist ?ys\<langle>?x\<rangle>
      else Some (snd ?a)), Lists_Ex.map_of_alist_binary)
Delete Dijkstra.is_shortest_path_def@eqforward
### theory "Draft.Lists_Ex"
### 0.746s elapsed time, 2.959s cpu time, 0.288s GC time
Loading theory "Draft.BST" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.BST_Impl")
Dijkstra.has_dist_def@eqforward
WithFact has_dist ?G ?m ?n
GetFact (EX p. is_shortest_path ?G ?m ?n p, Dijkstra.has_dist_def@eqforward)
Dijkstra.has_dist_def@invbackward
WithGoal has_dist ?G ?m ?n
GetGoal (EX p. is_shortest_path ?G ?m ?n p, Dijkstra.has_dist_def@invbackward)
Dijkstra.has_distI
WithFact is_shortest_path ?G ?m ?n ?p
GetFact (has_dist ?G ?m ?n, Dijkstra.has_distI)
Dijkstra.has_distD@res
WithGoal EX p. is_shortest_path ?G ?m ?n p
WithFact has_dist ?G ?m ?n
GetResolve Dijkstra.has_distD@res
Dijkstra.has_dist_to_in_verts
WithFact has_dist ?G ?u ?v
GetFact (?u : verts ?G & ?v : verts ?G, Dijkstra.has_dist_to_in_verts)
Delete Dijkstra.has_dist_def@eqforward
Delete Dijkstra.has_dist_def@invbackward
Dijkstra.dist_def
WithTerm dist ?G ?m ?n
GetFact (dist ?G ?m ?n = path_weight ?G (SOME p. is_shortest_path ?G ?m ?n p), Dijkstra.dist_def)
Found termination order: "{}"
Dijkstra.dist_eq
WithTerm dist ?G ?m ?n
WithFact is_shortest_path ?G ?m ?n ?p
GetFact (dist ?G ?m ?n = path_weight ?G ?p, Dijkstra.dist_eq)
Dijkstra.distD
WithFact has_dist ?G ?m ?n
WithFact ?p : path_set ?G ?m ?n
GetFact (dist ?G ?m ?n <= path_weight ?G ?p, Dijkstra.distD)
Delete Dijkstra.dist_def
Dijkstra.shortest_init@res
WithGoal is_shortest_path ?G ?n ?n [?n]
WithFact ?n : verts ?G
GetResolve Dijkstra.shortest_init@res
Apply def ?r = idx_pqueue_pop_fun (?xs, ?m)
Indexed_PQueue.idx_pqueue_pop_correct
WithTerm idx_pqueue_pop_fun (?xs, ?m)
WithFact index_of_pqueue (?xs, ?m)
GetFact (?xs ~= [] -->
index_of_pqueue (idx_pqueue_pop_fun (?xs, ?m)) &
fst (idx_pqueue_pop_fun (?xs, ?m)) = butlast ?xs &
length (snd (idx_pqueue_pop_fun (?xs, ?m))) = length ?m, Indexed_PQueue.idx_pqueue_pop_correct)
Dijkstra.int_pts_def
WithTerm int_pts ?p
GetFact (int_pts ?p = set (butlast ?p), Dijkstra.int_pts_def)
Dijkstra.int_pts_singleton
WithTerm int_pts [?x]
GetFact (int_pts [?x] = {}, Dijkstra.int_pts_singleton)
Dijkstra.int_pts_doubleton
WithTerm int_pts [?x, ?y]
GetFact (int_pts [?x, ?y] = {?x}, Dijkstra.int_pts_doubleton)
Dijkstra.path_set_on_mem@eqforward
WithFact ?p : path_set_on ?G ?m ?n ?V
GetFact (?p : path_set ?G ?m ?n & int_pts ?p <= ?V, Dijkstra.path_set_on_mem@eqforward)
Dijkstra.path_set_on_mem@invbackward
WithGoal ?p : path_set_on ?G ?m ?n ?V
GetGoal (?p : path_set ?G ?m ?n & int_pts ?p <= ?V, Dijkstra.path_set_on_mem@invbackward)
Dijkstra.is_shortest_path_on_def@eqforward
WithFact is_shortest_path_on ?G ?m ?n ?p ?V
GetFact (?p : path_set_on ?G ?m ?n ?V &
(ALL p':path_set_on ?G ?m ?n ?V. path_weight ?G ?p <= path_weight ?G p'), Dijkstra.is_shortest_path_on_def@eqforward)
Dijkstra.is_shortest_path_on_def@invbackward
WithGoal is_shortest_path_on ?G ?m ?n ?p ?V
GetGoal (?p : path_set_on ?G ?m ?n ?V &
(ALL p':path_set_on ?G ?m ?n ?V. path_weight ?G ?p <= path_weight ?G p'), Dijkstra.is_shortest_path_on_def@invbackward)
Dijkstra.is_shortest_path_onD1
WithFact is_shortest_path_on ?G ?m ?n ?p ?V
GetFact (?p : path_set_on ?G ?m ?n ?V, Dijkstra.is_shortest_path_onD1)
SepAuto.pheap.collapse@sym
WithTerm ?pheap
GetFact (?pheap = pHeap (heapOf ?pheap) (addrOf ?pheap), SepAuto.pheap.collapse@sym) + 1 filters
Dijkstra.is_shortest_path_onD2
WithFact is_shortest_path_on ?G ?m ?n ?p ?V
WithFact ?p' : path_set_on ?G ?m ?n ?V
GetFact (path_weight ?G ?p <= path_weight ?G ?p', Dijkstra.is_shortest_path_onD2)
SepAuto.pheap.case
WithTerm case pHeap ?x1.0 ?x2.0 of pHeap x xa => ?f x xa
GetFact ((case pHeap ?x1.0 ?x2.0 of pHeap x xa => ?f x xa) = ?f ?x1.0 ?x2.0, SepAuto.pheap.case)
SepAuto.pheap.sel_1
WithTerm heapOf (pHeap ?x1.0 ?x2.0)
GetFact (heapOf (pHeap ?x1.0 ?x2.0) = ?x1.0, SepAuto.pheap.sel_1)
SepAuto.pheap.sel_2
WithTerm addrOf (pHeap ?x1.0 ?x2.0)
GetFact (addrOf (pHeap ?x1.0 ?x2.0) = ?x2.0, SepAuto.pheap.sel_2)
SepAuto.pheap.simps_1@eqforward
WithFact pHeap ?x1.0 ?x2.0 = pHeap ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, SepAuto.pheap.simps_1@eqforward)
Delete Dijkstra.is_shortest_path_on_def@eqforward
Dijkstra.has_dist_on_def@eqforward
WithFact has_dist_on ?G ?m ?n ?V
GetFact (EX p. is_shortest_path_on ?G ?m ?n p ?V, Dijkstra.has_dist_on_def@eqforward)
Dijkstra.has_dist_on_def@invbackward
WithGoal has_dist_on ?G ?m ?n ?V
GetGoal (EX p. is_shortest_path_on ?G ?m ?n p ?V, Dijkstra.has_dist_on_def@invbackward)
Dijkstra.has_dist_onI
WithFact is_shortest_path_on ?G ?m ?n ?p ?V
GetFact (has_dist_on ?G ?m ?n ?V, Dijkstra.has_dist_onI)
Dijkstra.has_dist_onD@res
WithGoal EX p. is_shortest_path_on ?G ?m ?n p ?V
WithFact has_dist_on ?G ?m ?n ?V
GetResolve Dijkstra.has_dist_onD@res
Delete Dijkstra.has_dist_on_def@eqforward
Delete Dijkstra.has_dist_on_def@invbackward
Dijkstra.dist_on_def
WithTerm dist_on ?G ?m ?n ?V
GetFact (dist_on ?G ?m ?n ?V =
path_weight ?G (SOME p. is_shortest_path_on ?G ?m ?n p ?V), Dijkstra.dist_on_def)
Dijkstra.dist_on_eq
WithTerm dist_on ?G ?m ?n ?V
WithFact is_shortest_path_on ?G ?m ?n ?p ?V
GetFact (dist_on ?G ?m ?n ?V = path_weight ?G ?p, Dijkstra.dist_on_eq)
Dijkstra.dist_onD
WithFact has_dist_on ?G ?m ?n ?V
WithFact ?p : path_set_on ?G ?m ?n ?V
GetFact (dist_on ?G ?m ?n ?V <= path_weight ?G ?p, Dijkstra.dist_onD)
Delete Dijkstra.dist_on_def
Dijkstra.path_split1@back
WithGoal EX p1 p2.
   joinable ?G p1 p2 &
   ?p = path_join ?G p1 p2 & int_pts p1 <= ?V & hd p2 ~: ?V
GetGoal (is_path ?G ?p & hd ?p : ?V & last ?p ~: ?V, Dijkstra.path_split1@back)
Found termination order: "{}"
Dijkstra.path_split2@back
WithGoal EX q n. joinable ?G q [n, last ?p] & ?p = path_join ?G q [n, last ?p]
GetGoal (is_path ?G ?p & hd ?p ~= last ?p, Dijkstra.path_split2@back)
SepAuto.in_range.simps@eqforward
WithFact in_range (?h, ?as)
GetFact (ALL a:?as. a < lim ?h, SepAuto.in_range.simps@eqforward)
SepAuto.in_range.simps@invbackward
WithGoal in_range (?h, ?as)
GetGoal (ALL a:?as. a < lim ?h, SepAuto.in_range.simps@invbackward)
Dijkstra.known_dists_def@eqforward
WithFact known_dists ?G ?V
GetFact (?V <= verts ?G &
0 : ?V &
(ALL i:verts ?G. has_dist_on ?G 0 i ?V) &
(ALL i:?V. has_dist ?G 0 i & dist ?G 0 i = dist_on ?G 0 i ?V), Dijkstra.known_dists_def@eqforward)
Dijkstra.known_dists_def@invbackward
WithGoal known_dists ?G ?V
GetGoal (?V <= verts ?G &
0 : ?V &
(ALL i:verts ?G. has_dist_on ?G 0 i ?V) &
(ALL i:?V. has_dist ?G 0 i & dist ?G 0 i = dist_on ?G 0 i ?V), Dijkstra.known_dists_def@invbackward)
SepAuto.relH_def@eqforward
WithFact relH ?as ?h ?h'
GetFact (in_range (?h, ?as) &
in_range (?h', ?as) &
(ALL t.
    ALL a:?as. refs ?h t a = refs ?h' t a & arrays ?h t a = arrays ?h' t a), SepAuto.relH_def@eqforward)
SepAuto.relH_def@invbackward
WithGoal relH ?as ?h ?h'
GetGoal (in_range (?h, ?as) &
in_range (?h', ?as) &
(ALL t.
    ALL a:?as. refs ?h t a = refs ?h' t a & arrays ?h t a = arrays ?h' t a), SepAuto.relH_def@invbackward)
SepAuto.relH_D
WithFact relH ?as ?h ?h'
GetFact (in_range (?h, ?as) & in_range (?h', ?as), SepAuto.relH_D)
Dijkstra.derive_dist@back2
WithGoal has_dist ?G 0 ?m & dist ?G 0 ?m = dist_on ?G 0 ?m ?V
WithFact known_dists ?G ?V
GetGoal (?m : verts ?G - ?V &
(ALL i:verts ?G - ?V. dist_on ?G 0 ?m ?V <= dist_on ?G 0 i ?V), Dijkstra.derive_dist@back2)
SepAuto.relH_D2_1
WithTerm refs ?h ?t ?a
WithFact relH ?as ?h ?h'
GetFact (?a : ?as --> refs ?h ?t ?a = refs ?h' ?t ?a, SepAuto.relH_D2_1)
SepAuto.relH_D2_2
WithTerm arrays ?h ?t ?a
WithFact relH ?as ?h ?h'
GetFact (?a : ?as --> arrays ?h ?t ?a = arrays ?h' ?t ?a, SepAuto.relH_D2_2)
Dijkstra.join_def'@res
WithWellForm joinable ?G ?p ?q
WithGoal path_join ?G ?p ?q = butlast ?p @ ?q
GetResolve Dijkstra.join_def'@res
Delete SepAuto.relH_def@eqforward
Dijkstra.int_pts_join
WithWellForm joinable ?G ?p ?q
WithTerm int_pts (path_join ?G ?p ?q)
GetFact (int_pts (path_join ?G ?p ?q) = int_pts ?p Un int_pts ?q, Dijkstra.int_pts_join)
SepAuto.relH_dist_union
WithFact relH (?as Un ?as') ?h ?h'
GetFact (relH ?as ?h ?h' & relH ?as' ?h ?h', SepAuto.relH_dist_union)
SepAuto.relH_ref
WithTerm Ref.get ?h ?r
WithFact relH ?as ?h ?h'
GetFact (addr_of_ref ?r : ?as --> Ref.get ?h ?r = Ref.get ?h' ?r, SepAuto.relH_ref)
SepAuto.relH_array
WithTerm Array.get ?h ?r
WithFact relH ?as ?h ?h'
GetFact (addr_of_array ?r : ?as --> Array.get ?h ?r = Array.get ?h' ?r, SepAuto.relH_array)
Dijkstra.dist_on_triangle_ineq@back
WithWellForm has_dist_on ?G ?k ?m ?V
WithWellForm has_dist_on ?G ?k ?n ?V
WithGoal dist_on ?G ?k ?n ?V <= dist_on ?G ?k ?m ?V + weight ?G ?m ?n
GetGoal (?V <= verts ?G & ?n : verts ?G & ?m : ?V, Dijkstra.dist_on_triangle_ineq@back)
SepAuto.relH_set_ref@res
WithGoal relH {a. a < lim ?h & a ~: {addr_of_ref ?r}} ?h (Ref.set ?r ?x ?h)
GetResolve SepAuto.relH_set_ref@res
SepAuto.relH_set_array@res
WithGoal relH {a. a < lim ?h & a ~: {addr_of_array ?r}} ?h (Array.set ?r ?x ?h)
GetResolve SepAuto.relH_set_array@res
Apply def ?V' = ?V Un {?m}
Dijkstra.derive_dist_on@back2
WithGoal has_dist_on ?G 0 ?n (?V Un {?m}) &
dist_on ?G 0 ?n (?V Un {?m}) =
min (dist_on ?G 0 ?n ?V) (dist_on ?G 0 ?m ?V + weight ?G ?m ?n)
WithFact known_dists ?G ?V
GetGoal (?m : verts ?G - ?V &
(ALL i:verts ?G - ?V. dist_on ?G 0 ?m ?V <= dist_on ?G 0 i ?V) &
?n : verts ?G - (?V Un {?m}), Dijkstra.derive_dist_on@back2)
Apply def ?r = idx_bubble_down_fun ?x ?k
Indexed_PQueue.idx_bubble_down_fun_correct
WithTerm idx_bubble_down_fun ?x ?k
WithFact is_heap_partial1 (fst ?x) ?k
GetFact (is_heap (fst (idx_bubble_down_fun ?x ?k)) &
mset (fst (idx_bubble_down_fun ?x ?k)) = mset (fst ?x) &
length (snd (idx_bubble_down_fun ?x ?k)) = length (snd ?x), Indexed_PQueue.idx_bubble_down_fun_correct)
Add property rule for function Indexed_PQueue.idx_bubble_down_fun
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Apply def ?r = idx_bubble_up_fun ?x ?k
Indexed_PQueue.idx_bubble_up_fun_correct
WithTerm idx_bubble_up_fun ?x ?k
WithFact is_heap_partial2 (fst ?x) ?k
GetFact (is_heap (fst (idx_bubble_up_fun ?x ?k)) &
mset (fst (idx_bubble_up_fun ?x ?k)) = mset (fst ?x) &
length (snd (idx_bubble_up_fun ?x ?k)) = length (snd ?x), Indexed_PQueue.idx_bubble_up_fun_correct)
Add property rule for function Indexed_PQueue.idx_bubble_up_fun
Found termination order: "{}"
Found termination order: "{}"
Apply def ?res = delete_min_idx_pqueue_fun (?xs, ?m)
Indexed_PQueue.delete_min_idx_pqueue_correct
WithTerm delete_min_idx_pqueue_fun (?xs, ?m)
WithFact index_of_pqueue (?xs, ?m)
GetFact (?xs ~= [] --> index_of_pqueue (snd (delete_min_idx_pqueue_fun (?xs, ?m))), Indexed_PQueue.delete_min_idx_pqueue_correct)
SepAuto.aseval.simps@eqforward
WithFact aseval (Assn ?f) ?h
GetFact (?f ?h, SepAuto.aseval.simps@eqforward)
SepAuto.aseval.simps@invbackward
WithGoal aseval (Assn ?f) ?h
GetGoal (?f ?h, SepAuto.aseval.simps@invbackward)
Indexed_PQueue.hd_last_swap_eval_last
WithTerm last (list_swap ?xs 0 (length ?xs - 1))
WithGoal ?xs = []
GetFact (last (list_swap ?xs 0 (length ?xs - 1)) = hd ?xs, Indexed_PQueue.hd_last_swap_eval_last)
SepAuto.proper_def@eqforward
WithFact proper ?P
GetFact ((ALL h as. aseval ?P (pHeap h as) --> in_range (h, as)) &
(ALL h h' as.
    aseval ?P (pHeap h as) -->
    relH as h h' --> in_range (h', as) --> aseval ?P (pHeap h' as)), SepAuto.proper_def@eqforward)
SepAuto.proper_def@invbackward
WithGoal proper ?P
GetGoal ((ALL h as. aseval ?P (pHeap h as) --> in_range (h, as)) &
(ALL h h' as.
    aseval ?P (pHeap h as) -->
    relH as h h' --> in_range (h', as) --> aseval ?P (pHeap h' as)), SepAuto.proper_def@invbackward)
Apply def ?res = delete_min_idx_pqueue_fun (?xs, ?m)
Indexed_PQueue.delete_min_idx_pqueue_correct2
WithProperty is_heap ?xs
WithTerm delete_min_idx_pqueue_fun (?xs, ?m)
WithGoal ?xs = []
GetFact (index_of_pqueue (?xs, ?m) -->
is_heap (fst (snd (delete_min_idx_pqueue_fun (?xs, ?m)))) &
fst (delete_min_idx_pqueue_fun (?xs, ?m)) = hd ?xs &
length (snd (snd (delete_min_idx_pqueue_fun (?xs, ?m)))) = length ?m &
map_of_alist (fst (snd (delete_min_idx_pqueue_fun (?xs, ?m)))) =
delete_map (fst (fst (delete_min_idx_pqueue_fun (?xs, ?m))))
 (map_of_alist ?xs), Indexed_PQueue.delete_min_idx_pqueue_correct2)
Dijkstra.state.collapse@sym
WithTerm ?state
GetFact (?state = State (est ?state) (heap ?state), Dijkstra.state.collapse@sym) + 1 filters
Dijkstra.state.case
WithTerm case State ?x1.0 ?x2.0 of State x xa => ?f x xa
GetFact ((case State ?x1.0 ?x2.0 of State x xa => ?f x xa) = ?f ?x1.0 ?x2.0, Dijkstra.state.case)
Dijkstra.state.sel_1
WithTerm est (State ?x1.0 ?x2.0)
GetFact (est (State ?x1.0 ?x2.0) = ?x1.0, Dijkstra.state.sel_1)
Dijkstra.state.sel_2
WithTerm heap (State ?x1.0 ?x2.0)
GetFact (heap (State ?x1.0 ?x2.0) = ?x2.0, Dijkstra.state.sel_2)
Dijkstra.state.simps_1@eqforward
WithFact State ?x1.0 ?x2.0 = State ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Dijkstra.state.simps_1@eqforward)
Dijkstra.unknown_set_def
WithTerm unknown_set ?S
GetFact (unknown_set ?S = keys_of (heap ?S), Dijkstra.unknown_set_def)
Dijkstra.known_set_def
WithTerm known_set ?S
GetFact (known_set ?S = {..<length (est ?S)} - unknown_set ?S, Dijkstra.known_set_def)
Found termination order: "{}"
SepAuto.in_range_assn.simps@eqforward
WithFact in_range_assn (pHeap ?h ?as)
GetFact (ALL a:?as. a < lim ?h, SepAuto.in_range_assn.simps@eqforward)
SepAuto.in_range_assn.simps@invbackward
WithGoal in_range_assn (pHeap ?h ?as)
GetGoal (ALL a:?as. a < lim ?h, SepAuto.in_range_assn.simps@invbackward)
Dijkstra.inv_def@eqforward
WithFact Dijkstra.inv ?G ?S
GetFact (let V = known_set ?S; W = unknown_set ?S; M = heap ?S
in length (est ?S) = Dijkstra.size ?G &
   known_dists ?G V &
   keys_of M <= verts ?G &
   (ALL i:W. M\<langle>i\<rangle> = Some (est ?S ! i)) &
   (ALL i:V. est ?S ! i = dist ?G 0 i) &
   (ALL i:verts ?G. est ?S ! i = dist_on ?G 0 i V), Dijkstra.inv_def@eqforward)
Dijkstra.inv_def@invbackward
WithGoal Dijkstra.inv ?G ?S
GetGoal (let V = known_set ?S; W = unknown_set ?S; M = heap ?S
in length (est ?S) = Dijkstra.size ?G &
   known_dists ?G V &
   keys_of M <= verts ?G &
   (ALL i:W. M\<langle>i\<rangle> = Some (est ?S ! i)) &
   (ALL i:V. est ?S ! i = dist ?G 0 i) &
   (ALL i:verts ?G. est ?S ! i = dist_on ?G 0 i V), Dijkstra.inv_def@invbackward)
Dijkstra.invE1
WithFact Dijkstra.inv ?G ?S
GetFact (length (est ?S) = Dijkstra.size ?G &
known_dists ?G (known_set ?S) & unknown_set ?S <= verts ?G, Dijkstra.invE1)
Dijkstra.invE2
WithFact Dijkstra.inv ?G ?S
WithFact ?i : known_set ?S
GetFact (est ?S ! ?i = dist ?G 0 ?i, Dijkstra.invE2)
Dijkstra.invE3
WithFact Dijkstra.inv ?G ?S
WithFact ?i : verts ?G
GetFact (est ?S ! ?i = dist_on ?G 0 ?i (known_set ?S), Dijkstra.invE3)
Found termination order: "{}"
Dijkstra.invE4
WithTerm heap ?S\<langle>?i\<rangle>
WithFact Dijkstra.inv ?G ?S
GetFact (?i : unknown_set ?S --> heap ?S\<langle>?i\<rangle> = Some (est ?S ! ?i), Dijkstra.invE4)
Delete Dijkstra.inv_def@eqforward
SepAuto.assn.Rep_assn_inject@eqforward
WithFact Rep_assn ?x = Rep_assn ?y
GetFact (?x = ?y, SepAuto.assn.Rep_assn_inject@eqforward)
SepAuto.assn.Rep_assn_inject@invbackward
WithGoal Rep_assn ?x = Rep_assn ?y
GetGoal (?x = ?y, SepAuto.assn.Rep_assn_inject@invbackward)
Dijkstra.inv_unknown_set
WithTerm unknown_set ?S
WithFact Dijkstra.inv ?G ?S
GetFact (unknown_set ?S = verts ?G - known_set ?S, Dijkstra.inv_unknown_set)
SepAuto.assn.Abs_assn_case
WithTerm Abs_assn ?P
CreateConcl proper ?P
Indexed_PQueue.insert_idx_pqueue_correct
WithTerm insert_idx_pqueue_fun ?k ?v (?xs, ?m)
WithFact index_of_pqueue (?xs, ?m)
GetFact (?k < length ?m -->
~ has_key_alist ?xs ?k -->
index_of_pqueue (insert_idx_pqueue_fun ?k ?v (?xs, ?m)), Indexed_PQueue.insert_idx_pqueue_correct)
SepAuto.Abs_assn_inverse'
WithWellForm proper ?y
WithTerm Rep_assn (Abs_assn ?y)
GetFact (Rep_assn (Abs_assn ?y) = ?y, SepAuto.Abs_assn_inverse')
Dijkstra.dijkstra_end_inv
WithFact Dijkstra.inv ?G ?S
WithFact unknown_set ?S = {}
GetFact (ALL i:verts ?G. has_dist ?G 0 i & est ?S ! i = dist ?G 0 i, Dijkstra.dijkstra_end_inv)
Add property rule for function SepAuto.assn.Rep_assn
SepAuto.models_def@eqforward
WithFact ?h \<Turnstile> ?P
GetFact (aseval (Rep_assn ?P) ?h, SepAuto.models_def@eqforward)
SepAuto.models_def@invbackward
WithGoal ?h \<Turnstile> ?P
GetGoal (aseval (Rep_assn ?P) ?h, SepAuto.models_def@invbackward)
SepAuto.models_def@sym@eqforward
WithFact aseval (Rep_assn ?P) ?h
GetFact (?h \<Turnstile> ?P, SepAuto.models_def@sym@eqforward)
SepAuto.models_def@sym@invbackward
WithGoal aseval (Rep_assn ?P) ?h
GetGoal (?h \<Turnstile> ?P, SepAuto.models_def@sym@invbackward)
Apply def ?r = insert_idx_pqueue_fun ?k ?v (?xs, ?m)
Dijkstra.dijkstra_start_state_def
WithTerm dijkstra_start_state ?G
GetFact (dijkstra_start_state ?G =
State (list (%i. if i = 0 then 0 else weight ?G 0 i) (Dijkstra.size ?G))
 (map_constr ((<) 0) (weight ?G 0) (Dijkstra.size ?G)), Dijkstra.dijkstra_start_state_def)
Indexed_PQueue.insert_idx_pqueue_correct2
WithTerm insert_idx_pqueue_fun ?k ?v (?xs, ?m)
WithFact index_of_pqueue (?xs, ?m)
GetFact (is_heap ?xs -->
?k < length ?m -->
~ has_key_alist ?xs ?k -->
is_heap (fst (insert_idx_pqueue_fun ?k ?v (?xs, ?m))) &
length (snd (insert_idx_pqueue_fun ?k ?v (?xs, ?m))) = length ?m &
map_of_alist (fst (insert_idx_pqueue_fun ?k ?v (?xs, ?m))) =
 map_of_alist ?xs { ?k \<rightarrow> ?v }, Indexed_PQueue.insert_idx_pqueue_correct2)
SepAuto.models_in_range@res
WithGoal in_range (?h, ?as)
WithFact pHeap ?h ?as \<Turnstile> ?P
GetResolve SepAuto.models_in_range@res
Dijkstra.dijkstra_start_known_set
WithWellForm 0 < Dijkstra.size ?G
WithTerm known_set (dijkstra_start_state ?G)
GetFact (known_set (dijkstra_start_state ?G) = {0}, Dijkstra.dijkstra_start_known_set)
SepAuto.mod_relH
WithFact relH ?as ?h ?h'
WithFact pHeap ?h ?as \<Turnstile> ?P
GetFact (pHeap ?h' ?as \<Turnstile> ?P, SepAuto.mod_relH)
instantiation
  assn :: one
  one_assn == one_class.one :: assn
Dijkstra.dijkstra_start_unknown_set
WithWellForm 0 < Dijkstra.size ?G
WithTerm unknown_set (dijkstra_start_state ?G)
GetFact (unknown_set (dijkstra_start_state ?G) = verts ?G - {0}, Dijkstra.dijkstra_start_unknown_set)
Dijkstra.card_start_state
WithWellForm 0 < Dijkstra.size ?G
WithTerm card (unknown_set (dijkstra_start_state ?G))
GetFact (card (unknown_set (dijkstra_start_state ?G)) = Dijkstra.size ?G - 1, Dijkstra.card_start_state)
Dijkstra.dijkstra_start_inv@back
WithGoal Dijkstra.inv ?G (dijkstra_start_state ?G)
GetGoal (0 < Dijkstra.size ?G, Dijkstra.dijkstra_start_inv@back)
SepAuto.one_assn_def@obj_eq
WithTerm 1
GetFact (1 = Abs_assn (Assn (%h. addrOf h = {})), SepAuto.one_assn_def@obj_eq)
SepAuto.one_assn_rule@eqforward
WithFact ?h \<Turnstile> emp
GetFact (addrOf ?h = {}, SepAuto.one_assn_rule@eqforward)
SepAuto.one_assn_rule@invbackward
WithGoal ?h \<Turnstile> emp
GetGoal (addrOf ?h = {}, SepAuto.one_assn_rule@invbackward)
Delete SepAuto.one_assn_def@obj_eq
instantiation
  assn :: times
  times_assn == times :: assn => assn => assn
SepAuto.times_assn_def
WithTerm ?P * ?Q
GetFact (?P * ?Q =
Abs_assn
 (Assn
   (%h. EX as1 as2.
           addrOf h = as1 Un as2 &
           as1 Int as2 = {} &
           aseval (Rep_assn ?P) (pHeap (heapOf h) as1) &
           aseval (Rep_assn ?Q) (pHeap (heapOf h) as2))), SepAuto.times_assn_def)
SepAuto.mod_star_conv@eqforward
WithFact pHeap ?h ?as \<Turnstile> ?A * ?B
GetFact (EX as1 as2.
   ?as = as1 Un as2 &
   as1 Int as2 = {} &
   pHeap ?h as1 \<Turnstile> ?A & pHeap ?h as2 \<Turnstile> ?B, SepAuto.mod_star_conv@eqforward)
SepAuto.mod_star_conv@invbackward
WithGoal pHeap ?h ?as \<Turnstile> ?A * ?B
GetGoal (EX as1 as2.
   ?as = as1 Un as2 &
   as1 Int as2 = {} &
   pHeap ?h as1 \<Turnstile> ?A & pHeap ?h as2 \<Turnstile> ?B, SepAuto.mod_star_conv@invbackward)
Delete SepAuto.times_assn_def
SepAuto.aseval_ext@back
WithGoal ?P = ?P'
GetGoal (ALL h. aseval ?P h = aseval ?P' h, SepAuto.aseval_ext@back)
SepAuto.assn_ext@back
WithGoal ?P = ?Q
GetGoal (ALL h as. (pHeap h as \<Turnstile> ?P) = (pHeap h as \<Turnstile> ?Q), SepAuto.assn_ext@back) + 1 filters
Delete SepAuto.aseval_ext@back
instantiation
  assn :: comm_monoid_mult
SepAuto.ex_assn_def
WithTerm \<exists>\<^sub>Ax. ?P x
GetFact ((\<exists>\<^sub>Ax. ?P x) = Abs_assn (Assn (%h. EX x. h \<Turnstile> ?P x)), SepAuto.ex_assn_def)
SepAuto.mod_ex_dist@eqforward
WithFact ?h \<Turnstile> (\<exists>\<^sub>Ax. ?P x)
GetFact (EX x. ?h \<Turnstile> ?P x, SepAuto.mod_ex_dist@eqforward)
SepAuto.mod_ex_dist@invbackward
WithGoal ?h \<Turnstile> (\<exists>\<^sub>Ax. ?P x)
GetGoal (EX x. ?h \<Turnstile> ?P x, SepAuto.mod_ex_dist@invbackward)
Found termination order: "{}"
Delete SepAuto.ex_assn_def
Indexed_PQueue.update_idx_pqueue_correct
WithTerm update_idx_pqueue_fun ?k ?v (?xs, ?m)
WithFact index_of_pqueue (?xs, ?m)
GetFact (?k < length ?m --> index_of_pqueue (update_idx_pqueue_fun ?k ?v (?xs, ?m)), Indexed_PQueue.update_idx_pqueue_correct)
SepAuto.sngr_assn_def
WithTerm ?r \<mapsto>\<^sub>r ?x
GetFact (?r \<mapsto>\<^sub>r ?x =
Abs_assn
 (Assn
   (%h. Ref.get (heapOf h) ?r = ?x &
        addrOf h = {addr_of_ref ?r} & addr_of_ref ?r < lim (heapOf h))), SepAuto.sngr_assn_def)
Apply def ?r = update_idx_pqueue_fun ?k ?v (?xs, ?m)
SepAuto.sngr_assn_rule@eqforward
WithFact pHeap ?h ?as \<Turnstile> ?r \<mapsto>\<^sub>r ?x
GetFact (Ref.get ?h ?r = ?x & ?as = {addr_of_ref ?r} & addr_of_ref ?r < lim ?h, SepAuto.sngr_assn_rule@eqforward)
SepAuto.sngr_assn_rule@invbackward
WithGoal pHeap ?h ?as \<Turnstile> ?r \<mapsto>\<^sub>r ?x
GetGoal (Ref.get ?h ?r = ?x & ?as = {addr_of_ref ?r} & addr_of_ref ?r < lim ?h, SepAuto.sngr_assn_rule@invbackward)
Indexed_PQueue.update_idx_pqueue_correct2
WithTerm update_idx_pqueue_fun ?k ?v (?xs, ?m)
WithFact index_of_pqueue (?xs, ?m)
GetFact (is_heap ?xs -->
?k < length ?m -->
is_heap (fst (update_idx_pqueue_fun ?k ?v (?xs, ?m))) &
length (snd (update_idx_pqueue_fun ?k ?v (?xs, ?m))) = length ?m &
map_of_alist (fst (update_idx_pqueue_fun ?k ?v (?xs, ?m))) =
 map_of_alist ?xs { ?k \<rightarrow> ?v }, Indexed_PQueue.update_idx_pqueue_correct2)
Delete SepAuto.sngr_assn_def
### theory "Draft.Indexed_PQueue"
### 1.679s elapsed time, 6.638s cpu time, 0.653s GC time
Loading theory "Draft.Interval_Tree" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Rect_Intersect_Impl" via "Draft.Rect_Intersect")
Found termination order: "{}"
SepAuto.snga_assn_def
WithTerm ?r \<mapsto>\<^sub>a ?x
GetFact (?r \<mapsto>\<^sub>a ?x =
Abs_assn
 (Assn
   (%h. Array.get (heapOf h) ?r = ?x &
        addrOf h = {addr_of_array ?r} & addr_of_array ?r < lim (heapOf h))), SepAuto.snga_assn_def)
Dijkstra.dijkstra_step.simps
WithTerm dijkstra_step ?G ?m (State ?e ?M)
GetFact (dijkstra_step ?G ?m (State ?e ?M) =
(let M' = delete_map ?m ?M;
     e' = list_update_set (%i. i : keys_of M')
           (%i. min (?e ! ?m + weight ?G ?m i) (?e ! i)) ?e
 in Let (map_update_all ((!) e') M') (State e')), Dijkstra.dijkstra_step.simps)
SepAuto.snga_assn_rule@eqforward
WithFact pHeap ?h ?as \<Turnstile> ?r \<mapsto>\<^sub>a ?x
GetFact (Array.get ?h ?r = ?x & ?as = {addr_of_array ?r} & addr_of_array ?r < lim ?h, SepAuto.snga_assn_rule@eqforward)
SepAuto.snga_assn_rule@invbackward
WithGoal pHeap ?h ?as \<Turnstile> ?r \<mapsto>\<^sub>a ?x
GetGoal (Array.get ?h ?r = ?x & ?as = {addr_of_array ?r} & addr_of_array ?r < lim ?h, SepAuto.snga_assn_rule@invbackward)
Dijkstra.has_dist_on_larger@back1
WithWellForm has_dist ?G ?m ?n
WithGoal has_dist_on ?G ?m ?n (?V Un {?x}) &
dist_on ?G ?m ?n (?V Un {?x}) = dist ?G ?m ?n
WithFact dist_on ?G ?m ?n ?V = dist ?G ?m ?n
GetGoal (has_dist_on ?G ?m ?n ?V, Dijkstra.has_dist_on_larger@back1)
Delete SepAuto.snga_assn_def
Dijkstra.dijkstra_step_unknown_set
WithWellForm Dijkstra.inv ?G ?S
WithWellForm ?m : unknown_set ?S
WithTerm unknown_set (dijkstra_step ?G ?m ?S)
GetFact (unknown_set (dijkstra_step ?G ?m ?S) = unknown_set ?S - {?m}, Dijkstra.dijkstra_step_unknown_set)
Dijkstra.dijkstra_step_known_set
WithWellForm Dijkstra.inv ?G ?S
WithWellForm ?m : unknown_set ?S
WithTerm known_set (dijkstra_step ?G ?m ?S)
GetFact (known_set (dijkstra_step ?G ?m ?S) = known_set ?S Un {?m}, Dijkstra.dijkstra_step_known_set)
Dijkstra.dijkstra_step_preserves_inv@back
WithWellForm Dijkstra.inv ?G ?S
WithGoal Dijkstra.inv ?G (dijkstra_step ?G ?m ?S)
GetGoal (is_heap_min ?m (heap ?S), Dijkstra.dijkstra_step_preserves_inv@back)
SepAuto.pure_assn_def
WithTerm \<up> ?b
GetFact (\<up> ?b = Abs_assn (Assn (%h. addrOf h = {} & ?b)), SepAuto.pure_assn_def)
SepAuto.pure_assn_rule@eqforward
WithFact ?h \<Turnstile> \<up> ?b
GetFact (addrOf ?h = {} & ?b, SepAuto.pure_assn_rule@eqforward)
SepAuto.pure_assn_rule@invbackward
WithGoal ?h \<Turnstile> \<up> ?b
GetGoal (addrOf ?h = {} & ?b, SepAuto.pure_assn_rule@invbackward)
BST.tree.distinct_1@res
WithFact Tip = Node ?x21.0 ?x22.0 ?x23.0 ?x24.0
GetResolve BST.tree.distinct_1@res
BST.tree.sel_1
WithTerm lsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0)
GetFact (lsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0) = ?x21.0, BST.tree.sel_1)
BST.tree.sel_2
WithTerm key (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0)
GetFact (key (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0) = ?x22.0, BST.tree.sel_2)
Delete SepAuto.pure_assn_def
BST.tree.sel_3
WithTerm nval (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0)
GetFact (nval (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0) = ?x23.0, BST.tree.sel_3)
BST.tree.sel_4
WithTerm rsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0)
GetFact (rsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0) = ?x24.0, BST.tree.sel_4)
Dijkstra.is_dijkstra_step_def@eqforward
WithFact is_dijkstra_step ?G ?S ?S'
GetFact (EX m. is_heap_min m (heap ?S) & ?S' = dijkstra_step ?G m ?S, Dijkstra.is_dijkstra_step_def@eqforward)
Dijkstra.is_dijkstra_step_def@invbackward
WithGoal is_dijkstra_step ?G ?S ?S'
GetGoal (EX m. is_heap_min m (heap ?S) & ?S' = dijkstra_step ?G m ?S, Dijkstra.is_dijkstra_step_def@invbackward)
BST.tree.collapse
WithGoal ?tree = Tip
GetFact (Node (lsub ?tree) (key ?tree) (nval ?tree) (rsub ?tree) = ?tree, BST.tree.collapse)
Dijkstra.is_dijkstra_stepI@back2
WithGoal is_dijkstra_step ?G ?S ?S'
WithFact is_heap_min ?m (heap ?S)
GetGoal (dijkstra_step ?G ?m ?S = ?S', Dijkstra.is_dijkstra_stepI@back2)
SepAuto.top_assn_def
WithTerm true
GetFact (true = Abs_assn (Assn in_range_assn), SepAuto.top_assn_def)
Dijkstra.is_dijkstra_stepD1
WithFact Dijkstra.inv ?G ?S
WithFact is_dijkstra_step ?G ?S ?S'
GetFact (Dijkstra.inv ?G ?S', Dijkstra.is_dijkstra_stepD1)
SepAuto.top_assn_rule@eqforward
WithFact pHeap ?h ?as \<Turnstile> true
GetFact (in_range (?h, ?as), SepAuto.top_assn_rule@eqforward)
SepAuto.top_assn_rule@invbackward
WithGoal pHeap ?h ?as \<Turnstile> true
GetGoal (in_range (?h, ?as), SepAuto.top_assn_rule@invbackward)
Dijkstra.is_dijkstra_stepD2
WithFact Dijkstra.inv ?G ?S
WithFact is_dijkstra_step ?G ?S ?S'
GetFact (card (unknown_set ?S') = card (unknown_set ?S) - 1, Dijkstra.is_dijkstra_stepD2)
Delete Dijkstra.is_dijkstra_step_def@eqforward
Delete Dijkstra.is_dijkstra_step_def@invbackward
Delete SepAuto.top_assn_def
### theory "Draft.Dijkstra"
### 1.737s elapsed time, 6.874s cpu time, 0.653s GC time
Loading theory "Draft.RBTree" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.RBTree_Impl")
Delete SepAuto.models_def@eqforward
Delete SepAuto.models_def@invbackward
Delete SepAuto.models_def@sym@eqforward
Delete SepAuto.models_def@sym@invbackward
SepAuto.mod_pure_star_dist@eqforward
WithFact ?h \<Turnstile> ?P * \<up> ?b
GetFact (?h \<Turnstile> ?P & ?b, SepAuto.mod_pure_star_dist@eqforward)
SepAuto.mod_pure_star_dist@invbackward
WithGoal ?h \<Turnstile> ?P * \<up> ?b
GetGoal (?h \<Turnstile> ?P & ?b, SepAuto.mod_pure_star_dist@invbackward)
SepAuto.entails_def@eqforward
WithFact ?P \<Longrightarrow>\<^sub>A ?Q
GetFact (ALL h. h \<Turnstile> ?P --> h \<Turnstile> ?Q, SepAuto.entails_def@eqforward)
SepAuto.entails_def@invbackward
WithGoal ?P \<Longrightarrow>\<^sub>A ?Q
GetGoal (ALL h. h \<Turnstile> ?P --> h \<Turnstile> ?Q, SepAuto.entails_def@invbackward)
SepAuto.entails_frame@back
WithGoal ?P * ?R \<Longrightarrow>\<^sub>A ?Q * ?R
GetGoal (?P \<Longrightarrow>\<^sub>A ?Q, SepAuto.entails_frame@back)
SepAuto.entailsD
WithFact ?P \<Longrightarrow>\<^sub>A ?Q
WithFact ?h \<Turnstile> ?P
GetFact (?h \<Turnstile> ?Q, SepAuto.entailsD)
Delete SepAuto.entails_def@eqforward
Delete SepAuto.entails_def@invbackward
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "run"
BST.in_traverse.simps_1
WithTerm in_traverse Tip
GetFact (in_traverse Tip = [], BST.in_traverse.simps_1)
BST.in_traverse.simps_2
WithTerm in_traverse (Node ?l ?k ?v ?r)
GetFact (in_traverse (Node ?l ?k ?v ?r) = in_traverse ?l @ ?k # in_traverse ?r, BST.in_traverse.simps_2)
  Proving monotonicity ...
SepAuto.run.intros_1@res
WithGoal run ?c None None ?r
GetResolve SepAuto.run.intros_1@res
SepAuto.run.intros_2@res
WithGoal run ?c (Some ?h) None ?r
WithFact execute ?c ?h = None
GetResolve SepAuto.run.intros_2@res
SepAuto.run.intros_3
WithFact execute ?c ?h = Some (?r, ?h')
GetFact (run ?c (Some ?h) (Some ?h') ?r, SepAuto.run.intros_3)
SepAuto.run_complete@res
WithGoal EX \<sigma>' r. run ?c ?\<sigma> \<sigma>' r
GetResolve SepAuto.run_complete@res
SepAuto.run_to_execute
WithFact run ?c (Some ?h) ?\<sigma>' ?r
GetFact (if ?\<sigma>' = None then execute ?c ?h = None
else execute ?c ?h = Some (?r, the ?\<sigma>'), SepAuto.run_to_execute)
Heap_Monad.execute_bind_1
WithTerm execute (?f >>= ?g) ?h
WithFact execute ?f ?h = Some (?x, ?h')
GetFact (execute (?f >>= ?g) ?h = execute (?g ?x) ?h', Heap_Monad.execute_bind_1)
SepAuto.runE
WithFact run ?f (Some ?h) (Some ?h') ?r'
WithFact run (?f >>= ?g) (Some ?h) ?\<sigma> ?r
GetFact (run (?g ?r') (Some ?h') ?\<sigma> ?r, SepAuto.runE)
Array.get_alloc
WithTerm Array.get (snd (Array.alloc ?xs ?h)) (fst (Array.alloc ?ys ?h))
GetFact (Array.get (snd (Array.alloc ?xs ?h)) (fst (Array.alloc ?ys ?h)) = ?xs, Array.get_alloc)
Ref.get_alloc
WithTerm Ref.get (snd (Ref.alloc ?x ?h)) (fst (Ref.alloc ?x' ?h))
GetFact (Ref.get (snd (Ref.alloc ?x ?h)) (fst (Ref.alloc ?x' ?h)) = ?x, Ref.get_alloc)
Found termination order: "size <*mlex*> {}"
Array.length_def
WithTerm Array.length ?h ?a
GetFact (Array.length ?h ?a = length (Array.get ?h ?a), Array.length_def)
Array.length_def@sym
WithTerm length (Array.get ?h ?a)
GetFact (length (Array.get ?h ?a) = Array.length ?h ?a, Array.length_def@sym)
BST.tree_set.simps_1
WithTerm tree_set Tip
GetFact (tree_set Tip = {}, BST.tree_set.simps_1)
BST.tree_set.simps_2
WithTerm tree_set (Node ?l ?k ?v ?r)
GetFact (tree_set (Node ?l ?k ?v ?r) = {?k} Un tree_set ?l Un tree_set ?r, BST.tree_set.simps_2)
SepAuto.new_addrs_def
WithTerm new_addrs ?h ?as ?h'
GetFact (new_addrs ?h ?as ?h' = ?as Un {a. lim ?h <= a & a < lim ?h'}, SepAuto.new_addrs_def)
SepAuto.hoare_triple_def@eqforward
WithFact <?P> ?c <?Q>
GetFact (ALL h as \<sigma> r.
   pHeap h as \<Turnstile> ?P -->
   run ?c (Some h) \<sigma> r -->
   \<sigma> ~= None &
   pHeap (the \<sigma>) (new_addrs h as (the \<sigma>)) \<Turnstile> ?Q r &
   relH {a. a < lim h & a ~: as} h (the \<sigma>) &
   lim h <= lim (the \<sigma>), SepAuto.hoare_triple_def@eqforward)
SepAuto.hoare_triple_def@invbackward
WithGoal <?P> ?c <?Q>
GetGoal (ALL h as \<sigma> r.
   pHeap h as \<Turnstile> ?P -->
   run ?c (Some h) \<sigma> r -->
   \<sigma> ~= None &
   pHeap (the \<sigma>) (new_addrs h as (the \<sigma>)) \<Turnstile> ?Q r &
   relH {a. a < lim h & a ~: as} h (the \<sigma>) &
   lim h <= lim (the \<sigma>), SepAuto.hoare_triple_def@invbackward)
SepAuto.hoare_tripleD
WithFact <?P> ?c <?Q>
WithFact run ?c (Some ?h) ?\<sigma> ?r
GetFact (ALL as.
   pHeap ?h as \<Turnstile> ?P -->
   ?\<sigma> ~= None &
   pHeap (the ?\<sigma>) (new_addrs ?h as (the ?\<sigma>)) \<Turnstile>
   ?Q ?r &
   relH {a. a < lim ?h & a ~: as} ?h (the ?\<sigma>) &
   lim ?h <= lim (the ?\<sigma>), SepAuto.hoare_tripleD)
Delete SepAuto.hoare_triple_def@eqforward
SepAuto.frame_rule@back
WithGoal <?P * ?R> ?c <%x. ?Q x * ?R>
GetGoal (<?P> ?c <?Q>, SepAuto.frame_rule@back)
Delete SepAuto.mod_star_conv@eqforward
Delete SepAuto.mod_star_conv@invbackward
Found termination order: "size <*mlex*> {}"
Delete SepAuto.entailsD
Delete SepAuto.entails_frame@back
Delete SepAuto.frame_rule@back
BST.in_traverse_pairs.simps_1
WithTerm in_traverse_pairs Tip
GetFact (in_traverse_pairs Tip = [], BST.in_traverse_pairs.simps_1)
BST.in_traverse_pairs.simps_2
WithTerm in_traverse_pairs (Node ?l ?k ?v ?r)
GetFact (in_traverse_pairs (Node ?l ?k ?v ?r) =
in_traverse_pairs ?l @ (?k, ?v) # in_traverse_pairs ?r, BST.in_traverse_pairs.simps_2)
BST.in_traverse_fst
WithTerm map fst (in_traverse_pairs ?t)
GetFact (map fst (in_traverse_pairs ?t) = in_traverse ?t, BST.in_traverse_fst)
Heap_Monad.execute_assert_1
WithTerm execute (assert ?P ?x) ?h
WithFact ?P ?x
GetFact (execute (assert ?P ?x) ?h = Some (?x, ?h), Heap_Monad.execute_assert_1)
SepAuto.execute_return'
WithTerm execute (return ?x) ?h
GetFact (execute (return ?x) ?h = Some (?x, ?h), SepAuto.execute_return')
BST.tree_map_def
WithTerm tree_map ?t
GetFact (tree_map ?t = map_of_alist (in_traverse_pairs ?t), BST.tree_map_def)
Array.execute_nth_1
WithTerm execute (Array.nth ?a ?i) ?h
WithFact ?i < Array.length ?h ?a
GetFact (execute (Array.nth ?a ?i) ?h = Some (Array.get ?h ?a ! ?i, ?h), Array.execute_nth_1)
Array.execute_len
WithTerm execute (Array.len ?a) ?h
GetFact (execute (Array.len ?a) ?h = Some (Array.length ?h ?a, ?h), Array.execute_len)
Ref.execute_lookup
WithTerm execute (!?r) ?h
GetFact (execute (!?r) ?h = Some (Ref.get ?h ?r, ?h), Ref.execute_lookup)
Array.execute_freeze
WithTerm execute (Array.freeze ?a) ?h
GetFact (execute (Array.freeze ?a) ?h = Some (Array.get ?h ?a, ?h), Array.execute_freeze)
Ref.lim_set
WithTerm lim (Ref.set ?r ?v ?h)
GetFact (lim (Ref.set ?r ?v ?h) = lim ?h, Ref.lim_set)
SepAuto.Array_lim_set
WithTerm lim (Array.set ?p ?xs ?h)
GetFact (lim (Array.set ?p ?xs ?h) = lim ?h, SepAuto.Array_lim_set)
Ref.get_set_eq
WithTerm Ref.get (Ref.set ?r ?x ?h) ?r
GetFact (Ref.get (Ref.set ?r ?x ?h) ?r = ?x, Ref.get_set_eq)
Array.get_set_eq
WithTerm Array.get (Array.set ?r ?x ?h) ?r
GetFact (Array.get (Array.set ?r ?x ?h) ?r = ?x, Array.get_set_eq)
Array.update_def
WithTerm Array.update ?a ?i ?x ?h
GetFact (Array.update ?a ?i ?x ?h = Array.set ?a ((Array.get ?h ?a)[?i := ?x]) ?h, Array.update_def)
Array.execute_upd_1
WithTerm execute (Array.upd ?i ?x ?a) ?h
WithFact ?i < Array.length ?h ?a
GetFact (execute (Array.upd ?i ?x ?a) ?h = Some (?a, Array.update ?a ?i ?x ?h), Array.execute_upd_1)
Ref.execute_update
WithTerm execute (?r := ?v) ?h
GetFact (execute (?r := ?v) ?h = Some ((), Ref.set ?r ?v ?h), Ref.execute_update)
SepAuto.lim_set_gen
WithTerm lim (?h(| lim := ?l |))
GetFact (lim (?h(| lim := ?l |)) = ?l, SepAuto.lim_set_gen)
SepAuto.Array_alloc_def'
WithTerm Array.alloc ?xs ?h
GetFact (Array.alloc ?xs ?h =
(let l = lim ?h; r = Array l in (r, Array.set r ?xs (?h(| lim := l + 1 |)))), SepAuto.Array_alloc_def')
Heap.addr_of_array.simps
WithTerm addr_of_array (Array ?x)
GetFact (addr_of_array (Array ?x) = ?x, Heap.addr_of_array.simps)
Heap.addr_of_ref.simps
WithTerm addr_of_ref (Ref ?x)
GetFact (addr_of_ref (Ref ?x) = ?x, Heap.addr_of_ref.simps)
Ref.alloc_def
WithTerm Ref.alloc ?x ?h
GetFact (Ref.alloc ?x ?h =
(let l = lim ?h; r = Ref l in (r, Ref.set r ?x (?h(| lim := l + 1 |)))), Ref.alloc_def)
SepAuto.refs_on_Array_set
WithTerm refs (Array.set ?p ?xs ?h) ?t ?i
GetFact (refs (Array.set ?p ?xs ?h) ?t ?i = refs ?h ?t ?i, SepAuto.refs_on_Array_set)
SepAuto.arrays_on_Ref_set
WithTerm arrays (Ref.set ?p ?x ?h) ?t ?i
GetFact (arrays (Ref.set ?p ?x ?h) ?t ?i = arrays ?h ?t ?i, SepAuto.arrays_on_Ref_set)
SepAuto.refs_on_Array_alloc
WithTerm refs (snd (Array.alloc ?xs ?h)) ?t ?i
GetFact (refs (snd (Array.alloc ?xs ?h)) ?t ?i = refs ?h ?t ?i, SepAuto.refs_on_Array_alloc)
SepAuto.arrays_on_Ref_alloc
WithTerm arrays (snd (Ref.alloc ?x ?h)) ?t ?i
GetFact (arrays (snd (Ref.alloc ?x ?h)) ?t ?i = arrays ?h ?t ?i, SepAuto.arrays_on_Ref_alloc)
SepAuto.arrays_on_Array_alloc
WithTerm arrays (snd (Array.alloc ?xs ?h)) ?t ?i
WithFact ?i < lim ?h
GetFact (arrays (snd (Array.alloc ?xs ?h)) ?t ?i = arrays ?h ?t ?i, SepAuto.arrays_on_Array_alloc)
SepAuto.refs_on_Ref_alloc
WithTerm refs (snd (Ref.alloc ?x ?h)) ?t ?i
WithFact ?i < lim ?h
GetFact (refs (snd (Ref.alloc ?x ?h)) ?t ?i = refs ?h ?t ?i, SepAuto.refs_on_Ref_alloc)
Array.execute_new
WithTerm execute (Array.new ?n ?x) ?h
GetFact (execute (Array.new ?n ?x) ?h = Some (Array.alloc (replicate ?n ?x) ?h), Array.execute_new)
Array.execute_of_list
WithTerm execute (Array.of_list ?xs) ?h
GetFact (execute (Array.of_list ?xs) ?h = Some (Array.alloc ?xs ?h), Array.execute_of_list)
Ref.execute_ref
WithTerm execute (ref ?v) ?h
GetFact (execute (ref ?v) ?h = Some (Ref.alloc ?v ?h), Ref.execute_ref)
Found termination order: "size <*mlex*> {}"
Delete SepAuto.sngr_assn_rule@eqforward
Delete SepAuto.sngr_assn_rule@invbackward
Delete SepAuto.snga_assn_rule@eqforward
Delete SepAuto.snga_assn_rule@invbackward
Delete SepAuto.pure_assn_rule@eqforward
Delete SepAuto.pure_assn_rule@invbackward
Delete SepAuto.top_assn_rule@eqforward
Delete SepAuto.top_assn_rule@invbackward
Delete SepAuto.mod_pure_star_dist@eqforward
Delete SepAuto.mod_pure_star_dist@invbackward
Delete SepAuto.one_assn_rule@eqforward
Delete SepAuto.one_assn_rule@invbackward
Delete SepAuto.hoare_triple_def@invbackward
Delete SepAuto.mod_ex_dist@eqforward
Delete SepAuto.mod_ex_dist@invbackward
Delete SepAuto.pheap.collapse@sym
Delete SepAuto.pheap.case
Delete SepAuto.pheap.simps_1@eqforward
Delete SepAuto.pheap.sel_1
Delete SepAuto.pheap.sel_2
BST.tree_sorted.simps_1@eqforward
WithFact tree_sorted Tip
GetFact (True, BST.tree_sorted.simps_1@eqforward)
BST.tree_sorted.simps_1@invbackward
WithGoal tree_sorted Tip
GetGoal (True, BST.tree_sorted.simps_1@invbackward)
BST.tree_sorted.simps_2@eqforward
WithFact tree_sorted (Node ?l ?k ?v ?r)
GetFact ((ALL x:tree_set ?l. x < ?k) &
Ball (tree_set ?r) ((<) ?k) & tree_sorted ?l & tree_sorted ?r, BST.tree_sorted.simps_2@eqforward)
BST.tree_sorted.simps_2@invbackward
WithGoal tree_sorted (Node ?l ?k ?v ?r)
GetGoal ((ALL x:tree_set ?l. x < ?k) &
Ball (tree_set ?r) ((<) ?k) & tree_sorted ?l & tree_sorted ?r, BST.tree_sorted.simps_2@invbackward)
BST.tree_sorted_lr
WithFact tree_sorted (Node ?l ?k ?v ?r)
GetFact (tree_sorted ?l & tree_sorted ?r, BST.tree_sorted_lr)
BST.inorder_preserve_set
WithTerm tree_set ?t
GetFact (tree_set ?t = set (in_traverse ?t), BST.inorder_preserve_set)
BST.inorder_pairs_sorted@eqforward
WithFact tree_sorted ?t
GetFact (strict_sorted (map fst (in_traverse_pairs ?t)), BST.inorder_pairs_sorted@eqforward)
BST.inorder_pairs_sorted@invbackward
WithGoal tree_sorted ?t
GetGoal (strict_sorted (map fst (in_traverse_pairs ?t)), BST.inorder_pairs_sorted@invbackward)
Delete BST.tree_set.simps_1
Delete BST.tree_set.simps_2
Delete BST.tree_sorted.simps_1@eqforward
Delete BST.tree_sorted.simps_1@invbackward
Delete BST.tree_sorted.simps_2@eqforward
Delete BST.tree_sorted.simps_2@invbackward
BST.rotateL_def
WithTerm rotateL ?t
GetFact (rotateL ?t =
(if ?t = Tip then ?t
 else if rsub ?t = Tip then ?t
      else let rt = rsub ?t
           in Node (Node (lsub ?t) (key ?t) (nval ?t) (lsub rt)) (key rt)
               (nval rt) (rsub rt)), BST.rotateL_def)
BST.rotateR_def
WithTerm rotateR ?t
GetFact (rotateR ?t =
(if ?t = Tip then ?t
 else if lsub ?t = Tip then ?t
      else let lt = lsub ?t
           in Node (lsub lt) (key lt) (nval lt)
               (Node (rsub lt) (key ?t) (nval ?t) (rsub ?t))), BST.rotateR_def)
BST.rotateL_in_trav
WithTerm in_traverse (rotateL ?t)
GetFact (in_traverse (rotateL ?t) = in_traverse ?t, BST.rotateL_in_trav)
BST.rotateR_in_trav
WithTerm in_traverse (rotateR ?t)
GetFact (in_traverse (rotateR ?t) = in_traverse ?t, BST.rotateR_in_trav)
Add property rule for function BST.rotateL
Add property rule for function BST.rotateR
structure SepUtil: SEP_UTIL
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
BST.tree_insert.simps_1
WithTerm tree_insert ?x ?v Tip
GetFact (tree_insert ?x ?v Tip = Node Tip ?x ?v Tip, BST.tree_insert.simps_1)
BST.tree_insert.simps_2
WithTerm tree_insert ?x ?v (Node ?l ?y ?w ?r)
GetFact (tree_insert ?x ?v (Node ?l ?y ?w ?r) =
(if ?x = ?y then Node ?l ?x ?v ?r
 else if ?x < ?y then Node (tree_insert ?x ?v ?l) ?y ?w ?r
      else Node ?l ?y ?w (tree_insert ?x ?v ?r)), BST.tree_insert.simps_2)
BST.insert_in_traverse_pairs
WithProperty tree_sorted ?t
WithTerm in_traverse_pairs (tree_insert ?x ?v ?t)
GetFact (in_traverse_pairs (tree_insert ?x ?v ?t) =
ordered_insert_pairs ?x ?v (in_traverse_pairs ?t), BST.insert_in_traverse_pairs)
Add property rule for function BST.tree_insert
structure AssnMatcher: ASSN_MATCHER
structure SepLogic: SEP_LOGIC
val add_assn_matcher = fn: assn_matcher -> theory -> theory
val add_entail_matcher = fn: thm -> theory -> theory
val add_forward_ent_prfstep = fn: thm -> theory -> theory
val add_rewrite_ent_rule = fn: thm -> theory -> theory
val add_hoare_triple_prfstep = fn: thm -> theory -> theory
val test_normalize_assn =
   [(), (), (), (), (), (), (), (), (), (), (), (), (), (), ()]: unit list
val test_contract_hoare = [(), (), (), (), ()]: unit list
val test_normalize_hoare_goal = [(), (), (), (), (), (), ()]: unit list
val test_normalize_entail_goal = [(), (), (), ()]: unit list
Add Hoare triple SepAuto.assert_rule
<\<up> (?R ?x)> assert ?R ?x <%r. \<up> (r = ?x)>
Add Hoare triple SepAuto.update_rule
<?p \<mapsto>\<^sub>r ?y> ?p := ?x <%r. ?p \<mapsto>\<^sub>r ?x>
Add Hoare triple SepAuto.nth_rule
<?a \<mapsto>\<^sub>a ?xs * \<up> (?i < length ?xs)> Array.nth ?a ?i
<%r. ?a \<mapsto>\<^sub>a ?xs * \<up> (r = ?xs ! ?i)>
Add Hoare triple SepAuto.upd_rule
<?a \<mapsto>\<^sub>a ?xs * \<up> (?i < length ?xs)> Array.upd ?i ?x ?a
<%r. ?a \<mapsto>\<^sub>a ?xs[?i := ?x] * \<up> (r = ?a)>
Add Hoare triple SepAuto.return_rule
<emp> return ?x <%r. \<up> (r = ?x)>
Add Hoare triple SepAuto.ref_rule
<emp> ref ?x <%r. r \<mapsto>\<^sub>r ?x>
Add Hoare triple SepAuto.lookup_rule
<?p \<mapsto>\<^sub>r ?x> !?p <%r. ?p \<mapsto>\<^sub>r ?x * \<up> (r = ?x)>
Add Hoare triple SepAuto.new_rule
<emp> Array.new ?n ?x <%r. r \<mapsto>\<^sub>a replicate ?n ?x>
Add Hoare triple SepAuto.of_list_rule
<emp> Array.of_list ?xs <%r. r \<mapsto>\<^sub>a ?xs>
Add Hoare triple SepAuto.length_rule
<?a \<mapsto>\<^sub>a ?xs> Array.len ?a
<%r. ?a \<mapsto>\<^sub>a ?xs * \<up> (r = length ?xs)>
Add Hoare triple SepAuto.freeze_rule
<?a \<mapsto>\<^sub>a ?xs> Array.freeze ?a
<%r. ?a \<mapsto>\<^sub>a ?xs * \<up> (r = ?xs)>
Found termination order: "size <*mlex*> {}"
### theory "Draft.SepAuto"
### 2.248s elapsed time, 8.909s cpu time, 0.813s GC time
Loading theory "Draft.Arrays_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
BST.del_min.simps_2
WithTerm del_min (Node ?lt ?x ?v ?rt)
GetFact (del_min (Node ?lt ?x ?v ?rt) =
(if ?lt = Tip then ((?x, ?v), ?rt)
 else (fst (del_min ?lt), Node (snd (del_min ?lt)) ?x ?v ?rt)), BST.del_min.simps_2)
BST.delete_min_del_hd_pairs
WithTerm fst (del_min ?t) # in_traverse_pairs (snd (del_min ?t))
WithGoal ?t = Tip
GetFact (fst (del_min ?t) # in_traverse_pairs (snd (del_min ?t)) =
in_traverse_pairs ?t, BST.delete_min_del_hd_pairs)
Interval_Tree.interval_tree.distinct_1@res
WithFact Tip = Node ?x21.0 ?x22.0 ?x23.0 ?x24.0
GetResolve Interval_Tree.interval_tree.distinct_1@res
Interval_Tree.interval_tree.sel_1
WithTerm lsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0)
GetFact (lsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0) = ?x21.0, Interval_Tree.interval_tree.sel_1)
Interval_Tree.interval_tree.sel_2
WithTerm val (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0)
GetFact (val (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0) = ?x22.0, Interval_Tree.interval_tree.sel_2)
Interval_Tree.interval_tree.sel_3
WithTerm tmax Tip
GetFact (tmax Tip = 0, Interval_Tree.interval_tree.sel_3)
Interval_Tree.interval_tree.sel_4
WithTerm tmax (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0)
GetFact (tmax (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0) = ?x23.0, Interval_Tree.interval_tree.sel_4)
Interval_Tree.interval_tree.sel_5
WithTerm rsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0)
GetFact (rsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0) = ?x24.0, Interval_Tree.interval_tree.sel_5)
Interval_Tree.interval_tree.collapse
WithGoal ?interval_tree = Tip
GetFact (Node (lsub ?interval_tree) (val ?interval_tree) (tmax ?interval_tree)
 (rsub ?interval_tree) =
?interval_tree, Interval_Tree.interval_tree.collapse)
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Interval_Tree.in_traverse.simps_1
WithTerm in_traverse Tip
GetFact (in_traverse Tip = [], Interval_Tree.in_traverse.simps_1)
Interval_Tree.in_traverse.simps_2
WithTerm in_traverse (Node ?l ?it ?m ?r)
GetFact (in_traverse (Node ?l ?it ?m ?r) = in_traverse ?l @ ?it # in_traverse ?r, Interval_Tree.in_traverse.simps_2)
BST.delete_elt_tree.simps_2
WithTerm delete_elt_tree (Node ?lt ?x ?v ?rt)
GetFact (delete_elt_tree (Node ?lt ?x ?v ?rt) =
(if ?lt = Tip then ?rt
 else if ?rt = Tip then ?lt
      else Node ?lt (fst (fst (del_min ?rt))) (snd (fst (del_min ?rt)))
            (snd (del_min ?rt))), BST.delete_elt_tree.simps_2)
BST.delete_elt_in_traverse_pairs
WithTerm in_traverse_pairs (delete_elt_tree (Node ?lt ?x ?v ?rt))
GetFact (in_traverse_pairs (delete_elt_tree (Node ?lt ?x ?v ?rt)) =
in_traverse_pairs ?lt @ in_traverse_pairs ?rt, BST.delete_elt_in_traverse_pairs)
Found termination order: "size <*mlex*> {}"
Interval_Tree.tree_set.simps_1
WithTerm tree_set Tip
GetFact (tree_set Tip = {}, Interval_Tree.tree_set.simps_1)
Interval_Tree.tree_set.simps_2
WithTerm tree_set (Node ?l ?it ?m ?r)
GetFact (tree_set (Node ?l ?it ?m ?r) = {?it} Un tree_set ?l Un tree_set ?r, Interval_Tree.tree_set.simps_2)
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
BST.tree_delete.simps_1
WithTerm tree_delete ?x Tip
GetFact (tree_delete ?x Tip = Tip, BST.tree_delete.simps_1)
BST.tree_delete.simps_2
WithTerm tree_delete ?x (Node ?l ?y ?w ?r)
GetFact (tree_delete ?x (Node ?l ?y ?w ?r) =
(if ?x = ?y then delete_elt_tree (Node ?l ?y ?w ?r)
 else if ?x < ?y then Node (tree_delete ?x ?l) ?y ?w ?r
      else Node ?l ?y ?w (tree_delete ?x ?r)), BST.tree_delete.simps_2)
Interval_Tree.tree_sorted.simps_1@eqforward
WithFact tree_sorted Tip
GetFact (True, Interval_Tree.tree_sorted.simps_1@eqforward)
Interval_Tree.tree_sorted.simps_1@invbackward
WithGoal tree_sorted Tip
GetGoal (True, Interval_Tree.tree_sorted.simps_1@invbackward)
Interval_Tree.tree_sorted.simps_2@eqforward
WithFact tree_sorted (Node ?l ?it ?m ?r)
GetFact ((ALL x:tree_set ?l. x < ?it) &
Ball (tree_set ?r) ((<) ?it) & tree_sorted ?l & tree_sorted ?r, Interval_Tree.tree_sorted.simps_2@eqforward)
Interval_Tree.tree_sorted.simps_2@invbackward
WithGoal tree_sorted (Node ?l ?it ?m ?r)
GetGoal ((ALL x:tree_set ?l. x < ?it) &
Ball (tree_set ?r) ((<) ?it) & tree_sorted ?l & tree_sorted ?r, Interval_Tree.tree_sorted.simps_2@invbackward)
BST.tree_delete_in_traverse_pairs
WithProperty tree_sorted ?t
WithTerm in_traverse_pairs (tree_delete ?x ?t)
GetFact (in_traverse_pairs (tree_delete ?x ?t) =
remove_elt_pairs ?x (in_traverse_pairs ?t), BST.tree_delete_in_traverse_pairs)
Interval_Tree.tree_sorted_lr
WithFact tree_sorted (Node ?l ?it ?m ?r)
GetFact (tree_sorted ?l & tree_sorted ?r, Interval_Tree.tree_sorted_lr)
Add property rule for function BST.tree_delete
Interval_Tree.tree_sortedD1
WithFact tree_sorted (Node ?l ?it ?m ?r)
WithFact ?x : tree_set ?l
GetFact (?x < ?it, Interval_Tree.tree_sortedD1)
Interval_Tree.tree_sortedD2
WithFact tree_sorted (Node ?l ?it ?m ?r)
WithFact ?x : tree_set ?r
GetFact (?it < ?x, Interval_Tree.tree_sortedD2)
BST.tree_delete_map
WithProperty tree_sorted ?t
WithTerm tree_map (tree_delete ?x ?t)
GetFact (tree_map (tree_delete ?x ?t) = delete_map ?x (tree_map ?t), BST.tree_delete_map)
Interval_Tree.inorder_preserve_set
WithTerm tree_set ?t
GetFact (tree_set ?t = set (in_traverse ?t), Interval_Tree.inorder_preserve_set)
Add property rule for function Interval_Tree.in_traverse
Interval_Tree.inorder_sorted@invbackward
WithGoal tree_sorted ?t
GetGoal (strict_sorted (in_traverse ?t), Interval_Tree.inorder_sorted@invbackward)
Delete Interval_Tree.tree_set.simps_1
Delete Interval_Tree.tree_set.simps_2
Delete Interval_Tree.tree_sorted.simps_1@eqforward
Delete Interval_Tree.tree_sorted.simps_1@invbackward
Delete Interval_Tree.tree_sorted.simps_2@eqforward
Delete Interval_Tree.tree_sorted.simps_2@invbackward
Interval_Tree.max3_def
WithTerm max3 ?it ?b ?c
GetFact (max3 ?it ?b ?c = max (high (idx_interval.int ?it)) (max ?b ?c), Interval_Tree.max3_def)
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Add Hoare triple Arrays_Impl.array_copy_rule
<?a \<mapsto>\<^sub>a ?as * ?b \<mapsto>\<^sub>a ?bs *
 \<up> (?n <= length ?bs) *
 \<up> (?n <= length ?as)>
Arrays_Impl.array_copy ?a ?b ?n
<%_. ?a \<mapsto>\<^sub>a ?as *
     ?b \<mapsto>\<^sub>a Arrays_Ex.array_copy ?as ?bs ?n>
Found termination order: "size <*mlex*> {}"
Add Hoare triple Arrays_Impl.swap_rule
<?p \<mapsto>\<^sub>a ?xs * \<up> (?j < length ?xs) *
 \<up> (?i < length ?xs)>
swap ?p ?i ?j <%_. ?p \<mapsto>\<^sub>a list_swap ?xs ?i ?j>
Interval_Tree.tree_max_inv.simps_1@eqforward
WithFact tree_max_inv Tip
GetFact (True, Interval_Tree.tree_max_inv.simps_1@eqforward)
Interval_Tree.tree_max_inv.simps_1@invbackward
WithGoal tree_max_inv Tip
GetGoal (True, Interval_Tree.tree_max_inv.simps_1@invbackward)
Interval_Tree.tree_max_inv.simps_2@eqforward
WithFact tree_max_inv (Node ?l ?it ?m ?r)
GetFact (tree_max_inv ?l & tree_max_inv ?r & ?m = max3 ?it (tmax ?l) (tmax ?r), Interval_Tree.tree_max_inv.simps_2@eqforward)
Interval_Tree.tree_max_inv.simps_2@invbackward
WithGoal tree_max_inv (Node ?l ?it ?m ?r)
GetGoal (tree_max_inv ?l & tree_max_inv ?r & ?m = max3 ?it (tmax ?l) (tmax ?r), Interval_Tree.tree_max_inv.simps_2@invbackward)
Interval_Tree.tree_max_is_max@res
WithProperty tree_max_inv ?t
WithGoal high (idx_interval.int ?it) <= tmax ?t
WithFact ?it : tree_set ?t
GetResolve Interval_Tree.tree_max_is_max@res
Interval_Tree.tmax_exists@back
WithProperty tree_max_inv ?t
WithGoal EX p:tree_set ?t. high (idx_interval.int p) = tmax ?t
GetFact (?t = Tip, Interval_Tree.tmax_exists@back)
Interval_Tree.max3_insert
WithTerm max3 ?it 0 0
GetFact (max3 ?it 0 0 = high (idx_interval.int ?it), Interval_Tree.max3_insert)
Delete Interval_Tree.max3_def
Interval_Tree.tree_interval_inv_def@eqforward
WithFact tree_interval_inv ?t
GetFact (ALL p:tree_set ?t. is_interval (idx_interval.int p), Interval_Tree.tree_interval_inv_def@eqforward)
Interval_Tree.tree_interval_inv_def@invbackward
WithGoal tree_interval_inv ?t
GetGoal (ALL p:tree_set ?t. is_interval (idx_interval.int p), Interval_Tree.tree_interval_inv_def@invbackward)
Interval_Tree.is_interval_tree_def@eqforward
WithFact is_interval_tree ?t
GetFact (tree_sorted ?t & tree_max_inv ?t & tree_interval_inv ?t, Interval_Tree.is_interval_tree_def@eqforward)
Interval_Tree.is_interval_tree_def@invbackward
WithGoal is_interval_tree ?t
GetGoal (tree_sorted ?t & tree_max_inv ?t & tree_interval_inv ?t, Interval_Tree.is_interval_tree_def@invbackward)
Interval_Tree.is_interval_tree_lr
WithFact is_interval_tree (Node ?l ?x ?m ?r)
GetFact (is_interval_tree ?l & is_interval_tree ?r, Interval_Tree.is_interval_tree_lr)
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
BST.tree_search.simps_1
WithTerm tree_search Tip ?x
GetFact (tree_search Tip ?x = None, BST.tree_search.simps_1)
BST.tree_search.simps_2
WithTerm tree_search (Node ?l ?k ?v ?r) ?x
GetFact (tree_search (Node ?l ?k ?v ?r) ?x =
(if ?x = ?k then Some ?v
 else if ?x < ?k then tree_search ?l ?x else tree_search ?r ?x), BST.tree_search.simps_2)
BST.tree_search_correct
WithProperty tree_sorted ?t
WithTerm tree_search ?t ?x
GetFact (tree_search ?t ?x = tree_map ?t\<langle>?x\<rangle>, BST.tree_search_correct)
### theory "Draft.BST"
### 1.990s elapsed time, 7.889s cpu time, 0.748s GC time
Loading theory "Draft.BST_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Add Hoare triple Arrays_Impl.rev_to_fun
<?p \<mapsto>\<^sub>a ?xs * \<up> (?j < length ?xs)>
Arrays_Impl.rev ?p ?i ?j <%_. ?p \<mapsto>\<^sub>a rev_swap ?xs ?i ?j>
Add Hoare triple Arrays_Impl.rev_is_rev
<?p \<mapsto>\<^sub>a ?xs * \<up> (?xs ~= [])>
Arrays_Impl.rev ?p 0 (length ?xs - 1)
<%_. ?p \<mapsto>\<^sub>a List.rev ?xs>
### theory "Draft.Arrays_Impl"
### 0.470s elapsed time, 1.856s cpu time, 0.223s GC time
Loading theory "Draft.DynamicArray" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Interval_Tree.insert.simps_1
WithTerm Interval_Tree.insert ?x Tip
GetFact (Interval_Tree.insert ?x Tip = Node Tip ?x (high (idx_interval.int ?x)) Tip, Interval_Tree.insert.simps_1)
Interval_Tree.insert.simps_2
WithTerm Interval_Tree.insert ?x (Node ?l ?y ?m ?r)
GetFact (Interval_Tree.insert ?x (Node ?l ?y ?m ?r) =
(if ?x = ?y then Node ?l ?y ?m ?r
 else if ?x < ?y
      then let l' = Interval_Tree.insert ?x ?l
           in Node l' ?y (max3 ?y (tmax l') (tmax ?r)) ?r
      else let r' = Interval_Tree.insert ?x ?r
           in Node ?l ?y (max3 ?y (tmax ?l) (tmax r')) r'), Interval_Tree.insert.simps_2)
Interval_Tree.tree_insert_in_traverse
WithProperty tree_sorted ?t
WithTerm in_traverse (Interval_Tree.insert ?x ?t)
GetFact (in_traverse (Interval_Tree.insert ?x ?t) =
ordered_insert ?x (in_traverse ?t), Interval_Tree.tree_insert_in_traverse)
Add property rule for function Interval_Tree.insert
Interval_Tree.tree_insert_all_inv
WithProperty is_interval_tree ?t
WithFact is_interval (idx_interval.int ?it)
GetFact (is_interval_tree (Interval_Tree.insert ?it ?t), Interval_Tree.tree_insert_all_inv)
Interval_Tree.tree_insert_on_set
WithProperty tree_sorted ?t
WithTerm tree_set (Interval_Tree.insert ?it ?t)
GetFact (tree_set (Interval_Tree.insert ?it ?t) = {?it} Un tree_set ?t, Interval_Tree.tree_insert_on_set)
RBTree.color.distinct_1@res
WithFact R = B
GetResolve RBTree.color.distinct_1@res
RBTree.rbt.distinct_1@res
WithFact Leaf = Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0
GetResolve RBTree.rbt.distinct_1@res
RBTree.rbt.sel_1
WithTerm lsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (lsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x21.0, RBTree.rbt.sel_1)
RBTree.rbt.sel_2
WithTerm cl Leaf
GetFact (cl Leaf = B, RBTree.rbt.sel_2)
RBTree.rbt.sel_3
WithTerm cl (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (cl (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x22.0, RBTree.rbt.sel_3)
RBTree.rbt.sel_4
WithTerm key (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (key (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x23.0, RBTree.rbt.sel_4)
RBTree.rbt.sel_5
WithTerm val (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (val (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x24.0, RBTree.rbt.sel_5)
RBTree.rbt.sel_6
WithTerm rsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (rsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x25.0, RBTree.rbt.sel_6)
RBTree.rbt.collapse
WithGoal ?rbt = Leaf
GetFact (Node (lsub ?rbt) (cl ?rbt) (key ?rbt) (val ?rbt) (rsub ?rbt) = ?rbt, RBTree.rbt.collapse)
RBTree.not_R
WithGoal ?c = R
GetFact (?c = B, RBTree.not_R)
RBTree.not_B
WithGoal ?c = B
GetFact (?c = R, RBTree.not_B)
RBTree.red_not_leaf
WithFact cl ?t = R
GetGoal (?t = Leaf, RBTree.red_not_leaf)
Found termination order: "size <*mlex*> {}"
Interval_Tree.del_min.simps_2
WithTerm del_min (Node ?lt ?v ?m ?rt)
GetFact (del_min (Node ?lt ?v ?m ?rt) =
(if ?lt = Tip then (?v, ?rt)
 else let lt' = snd (del_min ?lt)
      in (fst (del_min ?lt),
          Node lt' ?v (max3 ?v (tmax lt') (tmax ?rt)) ?rt)), Interval_Tree.del_min.simps_2)
Interval_Tree.delete_min_del_hd
WithWellForm ?t ~= Tip
WithTerm in_traverse (snd (del_min ?t))
GetFact (fst (del_min ?t) # in_traverse (snd (del_min ?t)) = in_traverse ?t, Interval_Tree.delete_min_del_hd)
Interval_Tree.delete_min_max_inv
WithProperty tree_max_inv ?t
WithWellForm ?t ~= Tip
WithTerm snd (del_min ?t)
GetFact (tree_max_inv (snd (del_min ?t)), Interval_Tree.delete_min_max_inv)
Interval_Tree.delete_min_on_set
WithWellForm ?t ~= Tip
WithTerm tree_set (snd (del_min ?t))
GetFact ({fst (del_min ?t)} Un tree_set (snd (del_min ?t)) = tree_set ?t, Interval_Tree.delete_min_on_set)
Interval_Tree.delete_min_interval_inv
WithProperty tree_interval_inv ?t
WithWellForm ?t ~= Tip
WithTerm snd (del_min ?t)
GetFact (tree_interval_inv (snd (del_min ?t)), Interval_Tree.delete_min_interval_inv)
Interval_Tree.delete_min_all_inv
WithProperty is_interval_tree ?t
WithWellForm ?t ~= Tip
WithTerm snd (del_min ?t)
GetFact (is_interval_tree (snd (del_min ?t)), Interval_Tree.delete_min_all_inv)
Found termination order: "size <*mlex*> {}"
RBTree.black_depth.simps_1
WithTerm black_depth Leaf
GetFact (black_depth Leaf = 0, RBTree.black_depth.simps_1)
RBTree.black_depth.simps_2
WithTerm black_depth (Node ?l R ?k ?v ?r)
GetFact (black_depth (Node ?l R ?k ?v ?r) = black_depth ?l, RBTree.black_depth.simps_2)
RBTree.black_depth.simps_3
WithTerm black_depth (Node ?l B ?k ?v ?r)
GetFact (black_depth (Node ?l B ?k ?v ?r) = black_depth ?l + 1, RBTree.black_depth.simps_3)
Found termination order: "{}"
Interval_Tree.delete_elt_tree.simps_2
WithTerm delete_elt_tree (Node ?lt ?x ?m ?rt)
GetFact (delete_elt_tree (Node ?lt ?x ?m ?rt) =
(if ?lt = Tip then ?rt
 else if ?rt = Tip then ?lt
      else let x' = fst (del_min ?rt); rt' = snd (del_min ?rt);
               m' = max3 x' (tmax ?lt) (tmax rt')
           in Node ?lt (fst (del_min ?rt)) m' rt'), Interval_Tree.delete_elt_tree.simps_2)
Interval_Tree.delete_elt_in_traverse
WithTerm in_traverse (delete_elt_tree (Node ?lt ?x ?m ?rt))
GetFact (in_traverse (delete_elt_tree (Node ?lt ?x ?m ?rt)) =
in_traverse ?lt @ in_traverse ?rt, Interval_Tree.delete_elt_in_traverse)
Interval_Tree.delete_elt_max_inv
WithProperty tree_max_inv ?t
WithTerm delete_elt_tree ?t
WithGoal ?t = Tip
GetFact (tree_max_inv (delete_elt_tree ?t), Interval_Tree.delete_elt_max_inv)
Interval_Tree.delete_elt_on_set
WithTerm tree_set (delete_elt_tree (Node ?lt ?x ?m ?rt))
WithGoal ?t = Tip
GetFact (tree_set (delete_elt_tree (Node ?lt ?x ?m ?rt)) =
tree_set ?lt Un tree_set ?rt, Interval_Tree.delete_elt_on_set)
Interval_Tree.delete_elt_interval_inv
WithProperty tree_interval_inv ?t
WithTerm delete_elt_tree ?t
WithGoal ?t = Tip
GetFact (tree_interval_inv (delete_elt_tree ?t), Interval_Tree.delete_elt_interval_inv)
Interval_Tree.delete_elt_all_inv
WithProperty is_interval_tree ?t
WithTerm delete_elt_tree ?t
WithGoal ?t = Tip
GetFact (is_interval_tree (delete_elt_tree ?t), Interval_Tree.delete_elt_all_inv)
Found termination order: "size <*mlex*> {}"
RBTree.cl_inv.simps_1@eqforward
WithFact cl_inv Leaf
GetFact (True, RBTree.cl_inv.simps_1@eqforward)
RBTree.cl_inv.simps_1@invbackward
WithGoal cl_inv Leaf
GetGoal (True, RBTree.cl_inv.simps_1@invbackward)
RBTree.cl_inv.simps_2@eqforward
WithFact cl_inv (Node ?l R ?k ?v ?r)
GetFact (cl_inv ?l & cl_inv ?r & cl ?l = B & cl ?r = B, RBTree.cl_inv.simps_2@eqforward)
RBTree.cl_inv.simps_2@invbackward
WithGoal cl_inv (Node ?l R ?k ?v ?r)
GetGoal (cl_inv ?l & cl_inv ?r & cl ?l = B & cl ?r = B, RBTree.cl_inv.simps_2@invbackward)
RBTree.cl_inv.simps_3@eqforward
WithFact cl_inv (Node ?l B ?k ?v ?r)
GetFact (cl_inv ?l & cl_inv ?r, RBTree.cl_inv.simps_3@eqforward)
RBTree.cl_inv.simps_3@invbackward
WithGoal cl_inv (Node ?l B ?k ?v ?r)
GetGoal (cl_inv ?l & cl_inv ?r, RBTree.cl_inv.simps_3@invbackward)
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Interval_Tree.delete.simps_1
WithTerm delete ?x Tip
GetFact (delete ?x Tip = Tip, Interval_Tree.delete.simps_1)
Interval_Tree.delete.simps_2
WithTerm delete ?x (Node ?l ?y ?m ?r)
GetFact (delete ?x (Node ?l ?y ?m ?r) =
(if ?x = ?y then delete_elt_tree (Node ?l ?y ?m ?r)
 else if ?x < ?y
      then let l' = delete ?x ?l; m' = max3 ?y (tmax l') (tmax ?r)
           in Node l' ?y m' ?r
      else let r' = delete ?x ?r; m' = max3 ?y (tmax ?l) (tmax r')
           in Node ?l ?y m' r'), Interval_Tree.delete.simps_2)
Interval_Tree.tree_delete_in_traverse
WithProperty tree_sorted ?t
WithTerm in_traverse (delete ?x ?t)
GetFact (in_traverse (delete ?x ?t) = remove_elt_list ?x (in_traverse ?t), Interval_Tree.tree_delete_in_traverse)
Add property rule for function Interval_Tree.delete
Add property rule for function Interval_Tree.delete
Interval_Tree.tree_delete_on_set
WithProperty tree_sorted ?t
WithTerm tree_set (delete ?x ?t)
GetFact (tree_set (delete ?x ?t) = tree_set ?t - {?x}, Interval_Tree.tree_delete_on_set)
Found termination order: "size <*mlex*> {}"
RBTree.bd_inv.simps_1@eqforward
WithFact bd_inv Leaf
GetFact (True, RBTree.bd_inv.simps_1@eqforward)
RBTree.bd_inv.simps_1@invbackward
WithGoal bd_inv Leaf
GetGoal (True, RBTree.bd_inv.simps_1@invbackward)
RBTree.bd_inv.simps_2@eqforward
WithFact bd_inv (Node ?l ?c ?k ?v ?r)
GetFact (bd_inv ?l & bd_inv ?r & black_depth ?l = black_depth ?r, RBTree.bd_inv.simps_2@eqforward)
RBTree.bd_inv.simps_2@invbackward
WithGoal bd_inv (Node ?l ?c ?k ?v ?r)
GetGoal (bd_inv ?l & bd_inv ?r & black_depth ?l = black_depth ?r, RBTree.bd_inv.simps_2@invbackward)
RBTree.is_rbt_def@eqforward
WithFact is_rbt ?t
GetFact (cl_inv ?t & bd_inv ?t, RBTree.is_rbt_def@eqforward)
RBTree.is_rbt_def@invbackward
WithGoal is_rbt ?t
GetGoal (cl_inv ?t & bd_inv ?t, RBTree.is_rbt_def@invbackward)
RBTree.cl_invI
WithProperty cl_inv ?l
WithProperty cl_inv ?r
WithTerm Node ?l B ?k ?v ?r
GetFact (cl_inv (Node ?l B ?k ?v ?r), RBTree.cl_invI)
RBTree.bd_invI
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithTerm Node ?l ?c ?k ?v ?r
WithFact black_depth ?l = black_depth ?r
GetFact (bd_inv (Node ?l ?c ?k ?v ?r), RBTree.bd_invI)
RBTree.is_rbt_rec
WithFact is_rbt (Node ?l ?c ?k ?v ?r)
GetFact (is_rbt ?l & is_rbt ?r, RBTree.is_rbt_rec)
RBTree.two_distrib
WithTerm 2 * (?a + 1)
GetFact (2 * (?a + 1) = 2 * ?a + 2, RBTree.two_distrib)
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
RBTree.min_depth.simps_1
WithTerm min_depth Leaf
GetFact (min_depth Leaf = 0, RBTree.min_depth.simps_1)
RBTree.min_depth.simps_2
WithTerm min_depth (Node ?l ?c ?k ?v ?r)
GetFact (min_depth (Node ?l ?c ?k ?v ?r) = min (min_depth ?l) (min_depth ?r) + 1, RBTree.min_depth.simps_2)
Interval_Tree.search.simps_1@eqforward
WithFact search Tip ?x
GetResolve Interval_Tree.search.simps_1@eqforward
Interval_Tree.search.simps_1@invbackward
WithGoal search Tip ?x
GetGoal (False, Interval_Tree.search.simps_1@invbackward)
Interval_Tree.search.simps_2@eqforward
WithFact search (Node ?l ?y ?m ?r) ?x
GetFact (if is_overlap (idx_interval.int ?y) ?x then True
else if ?l ~= Tip & low ?x <= tmax ?l then search ?l ?x else search ?r ?x, Interval_Tree.search.simps_2@eqforward)
Interval_Tree.search.simps_2@invbackward
WithGoal search (Node ?l ?y ?m ?r) ?x
GetGoal (if is_overlap (idx_interval.int ?y) ?x then True
else if ?l ~= Tip & low ?x <= tmax ?l then search ?l ?x else search ?r ?x, Interval_Tree.search.simps_2@invbackward)
Interval_Tree.search_correct@eqforward
WithProperty is_interval_tree ?t
WithProperty is_interval ?x
WithFact search ?t ?x
GetFact (has_overlap (tree_set ?t) ?x, Interval_Tree.search_correct@eqforward)
Interval_Tree.search_correct@invbackward
WithProperty is_interval_tree ?t
WithProperty is_interval ?x
WithGoal search ?t ?x
GetGoal (has_overlap (tree_set ?t) ?x, Interval_Tree.search_correct@invbackward)
### theory "Draft.Interval_Tree"
### 1.822s elapsed time, 7.228s cpu time, 0.656s GC time
Loading theory "Draft.Rect_Intersect" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Rect_Intersect_Impl")
Found termination order: "size <*mlex*> {}"
DynamicArray.dynamic_array.collapse@sym
WithTerm ?dynamic_array
GetFact (?dynamic_array = Dyn_Array (alen ?dynamic_array) (aref ?dynamic_array), DynamicArray.dynamic_array.collapse@sym) + 1 filters
DynamicArray.dynamic_array.case
WithTerm case Dyn_Array ?x1.0 ?x2.0 of Dyn_Array x xa => ?f x xa
GetFact ((case Dyn_Array ?x1.0 ?x2.0 of Dyn_Array x xa => ?f x xa) = ?f ?x1.0 ?x2.0, DynamicArray.dynamic_array.case)
DynamicArray.dynamic_array.sel_1
WithTerm alen (Dyn_Array ?x1.0 ?x2.0)
GetFact (alen (Dyn_Array ?x1.0 ?x2.0) = ?x1.0, DynamicArray.dynamic_array.sel_1)
DynamicArray.dynamic_array.sel_2
WithTerm aref (Dyn_Array ?x1.0 ?x2.0)
GetFact (aref (Dyn_Array ?x1.0 ?x2.0) = ?x2.0, DynamicArray.dynamic_array.sel_2)
DynamicArray.dynamic_array.simps_1@eqforward
WithFact Dyn_Array ?x1.0 ?x2.0 = Dyn_Array ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, DynamicArray.dynamic_array.simps_1@eqforward)
RBTree.max_depth.simps_1
WithTerm max_depth Leaf
GetFact (max_depth Leaf = 0, RBTree.max_depth.simps_1)
RBTree.max_depth.simps_2
WithTerm max_depth (Node ?l ?c ?k ?v ?r)
GetFact (max_depth (Node ?l ?c ?k ?v ?r) = max (max_depth ?l) (max_depth ?r) + 1, RBTree.max_depth.simps_2)
Found termination order: "{}"
Found termination order: "{}"
Add forward entailment DynamicArray.dyn_array_raw.simps@forward
dyn_array_raw (?xs, ?n) (Dyn_Array ?m ?a) \<Longrightarrow>\<^sub>A
?a \<mapsto>\<^sub>a ?xs * \<up> (?m = ?n)
Add backward entailment DynamicArray.dyn_array_raw.simps@backward
?a \<mapsto>\<^sub>a ?xs * \<up> (?m = ?n) \<Longrightarrow>\<^sub>A
dyn_array_raw (?xs, ?n) (Dyn_Array ?m ?a)
RBTree.cl_inv'.simps_1@eqforward
WithFact cl_inv' Leaf
GetFact (True, RBTree.cl_inv'.simps_1@eqforward)
RBTree.cl_inv'.simps_1@invbackward
WithGoal cl_inv' Leaf
GetGoal (True, RBTree.cl_inv'.simps_1@invbackward)
RBTree.cl_inv'.simps_2@eqforward
WithFact cl_inv' (Node ?l ?c ?k ?v ?r)
GetFact (cl_inv ?l & cl_inv ?r, RBTree.cl_inv'.simps_2@eqforward)
RBTree.cl_inv'.simps_2@invbackward
WithGoal cl_inv' (Node ?l ?c ?k ?v ?r)
GetGoal (cl_inv ?l & cl_inv ?r, RBTree.cl_inv'.simps_2@invbackward)
RBTree.cl_inv'B
WithProperty cl_inv' ?t
WithFact cl ?t = B
GetFact (cl_inv ?t, RBTree.cl_inv'B)
RBTree.cl_inv'B@back1
WithGoal cl_inv ?t
WithFact cl ?t = B
GetGoal (cl_inv' ?t, RBTree.cl_inv'B@back1)
Add Hoare triple DynamicArray.dyn_array_new_rule'
<emp> dyn_array_new <dyn_array_raw (replicate 5 undefined, 0)>
RBTree.cl_inv'R
WithFact cl_inv' (Node ?l R ?k ?v ?r)
WithFact cl ?l = B
GetFact (cl ?r = B --> cl_inv (Node ?l R ?k ?v ?r), RBTree.cl_inv'R)
Add property rule for [RBTree.cl_inv]
RBTree.cl_inv'I
WithProperty cl_inv ?l
WithProperty cl_inv ?r
WithTerm Node ?l ?c ?k ?v ?r
GetFact (cl_inv' (Node ?l ?c ?k ?v ?r), RBTree.cl_inv'I)
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
RBTree.rbt_in_traverse.simps_1
WithTerm rbt_in_traverse Leaf
GetFact (rbt_in_traverse Leaf = [], RBTree.rbt_in_traverse.simps_1)
RBTree.rbt_in_traverse.simps_2
WithTerm rbt_in_traverse (Node ?l ?c ?k ?v ?r)
GetFact (rbt_in_traverse (Node ?l ?c ?k ?v ?r) =
rbt_in_traverse ?l @ ?k # rbt_in_traverse ?r, RBTree.rbt_in_traverse.simps_2)
Found termination order: "{}"
DynamicArray.double_length_fun.simps
WithTerm double_length_fun (?xs, ?n)
GetFact (double_length_fun (?xs, ?n) =
(Arrays_Ex.array_copy ?xs (replicate (2 * ?n + 1) undefined) ?n, ?n), DynamicArray.double_length_fun.simps)
Add Hoare triple DynamicArray.double_length_rule'
<dyn_array_raw (?xs, ?n) ?p *
 \<up>
  (length ?xs =
   ?n)> double_length
         ?p <dyn_array_raw (double_length_fun (?xs, ?n))>\<^sub>t
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
RBTree.rbt_set.simps_1
WithTerm rbt_set Leaf
GetFact (rbt_set Leaf = {}, RBTree.rbt_set.simps_1)
RBTree.rbt_set.simps_2
WithTerm rbt_set (Node ?l ?c ?k ?v ?r)
GetFact (rbt_set (Node ?l ?c ?k ?v ?r) = {?k} Un rbt_set ?l Un rbt_set ?r, RBTree.rbt_set.simps_2)
Found termination order: "{}"
DynamicArray.push_array_basic_fun.simps
WithTerm push_array_basic_fun ?x (?xs, ?n)
GetFact (push_array_basic_fun ?x (?xs, ?n) = (?xs[?n := ?x], ?n + 1), DynamicArray.push_array_basic_fun.simps)
Add Hoare triple DynamicArray.push_array_basic_rule'
<dyn_array_raw (?xs, ?n) ?p * \<up> (?n < length ?xs)>
push_array_basic ?x ?p <dyn_array_raw (push_array_basic_fun ?x (?xs, ?n))>
Add Hoare triple DynamicArray.array_length_rule'
<dyn_array_raw (?xs, ?n) ?p> array_length ?p
<%r. dyn_array_raw (?xs, ?n) ?p * \<up> (r = ?n)>
Add Hoare triple DynamicArray.array_max_rule'
<dyn_array_raw (?xs, ?n) ?p> array_max ?p
<%r. dyn_array_raw (?xs, ?n) ?p * \<up> (r = length ?xs)>
Add Hoare triple DynamicArray.array_nth_rule'
<dyn_array_raw (?xs, ?n) ?p * \<up> (?n <= length ?xs) * \<up> (?i < ?n)>
array_nth ?p ?i <%r. dyn_array_raw (?xs, ?n) ?p * \<up> (r = ?xs ! ?i)>
Found termination order: "size <*mlex*> {}"
Add Hoare triple DynamicArray.array_upd_rule'
<dyn_array_raw (?xs, ?n) ?p * \<up> (?n <= length ?xs) * \<up> (?i < ?n)>
array_upd ?i ?x ?p <%_. dyn_array_raw (?xs[?i := ?x], ?n) ?p>
RBTree.rbt_in_traverse_pairs.simps_1
WithTerm rbt_in_traverse_pairs Leaf
GetFact (rbt_in_traverse_pairs Leaf = [], RBTree.rbt_in_traverse_pairs.simps_1)
RBTree.rbt_in_traverse_pairs.simps_2
WithTerm rbt_in_traverse_pairs (Node ?l ?c ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (Node ?l ?c ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.rbt_in_traverse_pairs.simps_2)
RBTree.rbt_in_traverse_fst
WithTerm map fst (rbt_in_traverse_pairs ?t)
GetFact (map fst (rbt_in_traverse_pairs ?t) = rbt_in_traverse ?t, RBTree.rbt_in_traverse_fst)
RBTree.rbt_map_def
WithTerm rbt_map ?t
GetFact (rbt_map ?t = map_of_alist (rbt_in_traverse_pairs ?t), RBTree.rbt_map_def)
Add Hoare triple DynamicArray.pop_array_rule'
<dyn_array_raw (?xs, ?n) ?p * \<up> (?n <= length ?xs) * \<up> (0 < ?n)>
pop_array ?p
<%(x, r). dyn_array_raw (?xs, ?n - 1) r * \<up> (x = ?xs ! (?n - 1))>
Delete DynamicArray.dyn_array_raw.simps@forward@ent
Delete DynamicArray.dyn_array_raw.simps@forward@hoare_ent
Delete DynamicArray.dyn_array_raw.simps@backward@entback
Delete DynamicArray.dynamic_array.collapse@sym
Delete DynamicArray.dynamic_array.case
Delete DynamicArray.dynamic_array.simps_1@eqforward
Delete DynamicArray.dynamic_array.sel_1
Delete DynamicArray.dynamic_array.sel_2
Found termination order: "{}"
DynamicArray.push_array_fun.simps
WithTerm push_array_fun ?x (?xs, ?n)
GetFact (push_array_fun ?x (?xs, ?n) =
(if ?n < length ?xs then push_array_basic_fun ?x (?xs, ?n)
 else push_array_basic_fun ?x (double_length_fun (?xs, ?n))), DynamicArray.push_array_fun.simps)
Add Hoare triple DynamicArray.push_array_rule'
<dyn_array_raw (?xs, ?n) ?p *
 \<up>
  (?n <= length
          ?xs)> push_array ?x
                 ?p <dyn_array_raw (push_array_fun ?x (?xs, ?n))>\<^sub>t
Found termination order: "size <*mlex*> {}"
Rect_Intersect.rectangle.collapse@sym
WithTerm ?rectangle
GetFact (?rectangle = Rectangle (xint ?rectangle) (yint ?rectangle), Rect_Intersect.rectangle.collapse@sym) + 1 filters
Rect_Intersect.rectangle.case
WithTerm case Rectangle ?x1.0 ?x2.0 of Rectangle x xa => ?f x xa
GetFact ((case Rectangle ?x1.0 ?x2.0 of Rectangle x xa => ?f x xa) = ?f ?x1.0 ?x2.0, Rect_Intersect.rectangle.case)
Rect_Intersect.rectangle.sel_1
WithTerm xint (Rectangle ?x1.0 ?x2.0)
GetFact (xint (Rectangle ?x1.0 ?x2.0) = ?x1.0, Rect_Intersect.rectangle.sel_1)
Rect_Intersect.rectangle.sel_2
WithTerm yint (Rectangle ?x1.0 ?x2.0)
GetFact (yint (Rectangle ?x1.0 ?x2.0) = ?x2.0, Rect_Intersect.rectangle.sel_2)
Rect_Intersect.rectangle.simps_1@eqforward
WithFact Rectangle ?x1.0 ?x2.0 = Rectangle ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Rect_Intersect.rectangle.simps_1@eqforward)
Rect_Intersect.is_rect_def@eqforward
WithFact is_rect ?rect
GetFact (is_interval (xint ?rect) & is_interval (yint ?rect), Rect_Intersect.is_rect_def@eqforward)
Rect_Intersect.is_rect_def@invbackward
WithGoal is_rect ?rect
GetGoal (is_interval (xint ?rect) & is_interval (yint ?rect), Rect_Intersect.is_rect_def@invbackward)
RBTree.rbt_sorted.simps_1@eqforward
WithFact rbt_sorted Leaf
GetFact (True, RBTree.rbt_sorted.simps_1@eqforward)
RBTree.rbt_sorted.simps_1@invbackward
WithGoal rbt_sorted Leaf
GetGoal (True, RBTree.rbt_sorted.simps_1@invbackward)
RBTree.rbt_sorted.simps_2@eqforward
WithFact rbt_sorted (Node ?l ?c ?k ?v ?r)
GetFact ((ALL x:rbt_set ?l. x < ?k) &
Ball (rbt_set ?r) ((<) ?k) & rbt_sorted ?l & rbt_sorted ?r, RBTree.rbt_sorted.simps_2@eqforward)
RBTree.rbt_sorted.simps_2@invbackward
WithGoal rbt_sorted (Node ?l ?c ?k ?v ?r)
GetGoal ((ALL x:rbt_set ?l. x < ?k) &
Ball (rbt_set ?r) ((<) ?k) & rbt_sorted ?l & rbt_sorted ?r, RBTree.rbt_sorted.simps_2@invbackward)
RBTree.rbt_sorted_lr
WithFact rbt_sorted (Node ?l ?c ?k ?v ?r)
GetFact (rbt_sorted ?l & rbt_sorted ?r, RBTree.rbt_sorted_lr)
Rect_Intersect.is_rect_list_def@eqforward
WithFact is_rect_list ?rects
GetFact (ALL i<length ?rects. is_rect (?rects ! i), Rect_Intersect.is_rect_list_def@eqforward)
Rect_Intersect.is_rect_list_def@invbackward
WithGoal is_rect_list ?rects
GetGoal (ALL i<length ?rects. is_rect (?rects ! i), Rect_Intersect.is_rect_list_def@invbackward)
RBTree.rbt_inorder_preserve_set
WithTerm rbt_set ?t
GetFact (rbt_set ?t = set (rbt_in_traverse ?t), RBTree.rbt_inorder_preserve_set)
RBTree.rbt_inorder_sorted@eqforward
WithFact rbt_sorted ?t
GetFact (strict_sorted (map fst (rbt_in_traverse_pairs ?t)), RBTree.rbt_inorder_sorted@eqforward)
RBTree.rbt_inorder_sorted@invbackward
WithGoal rbt_sorted ?t
GetGoal (strict_sorted (map fst (rbt_in_traverse_pairs ?t)), RBTree.rbt_inorder_sorted@invbackward)
Rect_Intersect.is_rect_listD
WithProperty is_rect_list ?rects
WithWellForm ?i < length ?rects
WithTerm ?rects ! ?i
GetFact (is_rect (?rects ! ?i), Rect_Intersect.is_rect_listD)
Delete RBTree.rbt_set.simps_1
Delete RBTree.rbt_set.simps_2
Delete RBTree.rbt_sorted.simps_1@eqforward
Delete RBTree.rbt_sorted.simps_1@invbackward
Delete RBTree.rbt_sorted.simps_2@eqforward
Delete RBTree.rbt_sorted.simps_2@invbackward
Delete Rect_Intersect.is_rect_list_def@eqforward
Found termination order: "{}"
Rect_Intersect.is_rect_overlap_def@eqforward
WithFact is_rect_overlap ?A ?B
GetFact (is_overlap (xint ?A) (xint ?B) & is_overlap (yint ?A) (yint ?B), Rect_Intersect.is_rect_overlap_def@eqforward)
Rect_Intersect.is_rect_overlap_def@invbackward
WithGoal is_rect_overlap ?A ?B
GetGoal (is_overlap (xint ?A) (xint ?B) & is_overlap (yint ?A) (yint ?B), Rect_Intersect.is_rect_overlap_def@invbackward)
DynamicArray.abs_array.simps
WithTerm abs_array (?xs, ?n)
GetFact (abs_array (?xs, ?n) = take ?n ?xs, DynamicArray.abs_array.simps)
DynamicArray.double_length_abs
WithTerm abs_array (double_length_fun (?xs, ?n))
WithFact length ?xs = ?n
GetFact (abs_array (double_length_fun (?xs, ?n)) = abs_array (?xs, ?n), DynamicArray.double_length_abs)
DynamicArray.push_array_basic_abs
WithTerm abs_array (push_array_basic_fun ?x (?xs, ?n))
WithFact ?n < length ?xs
GetFact (abs_array (push_array_basic_fun ?x (?xs, ?n)) = abs_array (?xs, ?n) @ [?x], DynamicArray.push_array_basic_abs)
Rect_Intersect.has_rect_overlap_def@eqforward
WithFact has_rect_overlap ?As
GetFact (EX i<length ?As.
   EX j<length ?As. i ~= j & is_rect_overlap (?As ! i) (?As ! j), Rect_Intersect.has_rect_overlap_def@eqforward)
Rect_Intersect.has_rect_overlap_def@invbackward
WithGoal has_rect_overlap ?As
GetGoal (EX i<length ?As.
   EX j<length ?As. i ~= j & is_rect_overlap (?As ! i) (?As ! j), Rect_Intersect.has_rect_overlap_def@invbackward)
DynamicArray.push_array_fun_abs
WithTerm abs_array (push_array_fun ?x (?xs, ?n))
WithFact ?n <= length ?xs
GetFact (abs_array (push_array_fun ?x (?xs, ?n)) = abs_array (?xs, ?n) @ [?x], DynamicArray.push_array_fun_abs)
RBTree.balanceR_def
WithTerm balanceR ?l ?k ?v ?r
GetFact (balanceR ?l ?k ?v ?r =
(if cl ?r = R
 then let lr = lsub ?r; rr = rsub ?r
      in if cl lr = R
         then Node (Node ?l B ?k ?v (lsub lr)) R (key lr) (val lr)
               (Node (rsub lr) B (key ?r) (val ?r) rr)
         else if cl rr = R
              then Node (Node ?l B ?k ?v lr) R (key ?r) (val ?r)
                    (Node (lsub rr) B (key rr) (val rr) (rsub rr))
              else Node ?l B ?k ?v ?r
 else Node ?l B ?k ?v ?r), RBTree.balanceR_def)
Add forward entailment DynamicArray.dyn_array_def@forward
dyn_array ?xs ?a \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Ap.
   dyn_array_raw p ?a * \<up> (?xs = abs_array p) *
   \<up> (snd p <= length (fst p))
Add backward entailment DynamicArray.dyn_array_def@backward
\<exists>\<^sub>Ap.
   dyn_array_raw p ?a * \<up> (?xs = abs_array p) *
   \<up> (snd p <= length (fst p)) \<Longrightarrow>\<^sub>A
dyn_array ?xs ?a
Add Hoare triple DynamicArray.dyn_array_new_rule
<emp> dyn_array_new <dyn_array []>
Add Hoare triple DynamicArray.array_length_rule
<dyn_array ?xs ?p> array_length ?p
<%r. dyn_array ?xs ?p * \<up> (r = length ?xs)>
Add Hoare triple DynamicArray.array_nth_rule
<dyn_array ?xs ?p * \<up> (?i < length ?xs)> array_nth ?p ?i
<%r. dyn_array ?xs ?p * \<up> (r = ?xs ! ?i)>
Add Hoare triple DynamicArray.array_upd_rule
<dyn_array ?xs ?p * \<up> (?i < length ?xs)> array_upd ?i ?x ?p
<%_. dyn_array (?xs[?i := ?x]) ?p>
Add Hoare triple DynamicArray.push_array_rule
<dyn_array ?xs ?p> push_array ?x ?p <dyn_array (?xs @ [?x])>\<^sub>t
Add Hoare triple DynamicArray.pop_array_rule
<dyn_array ?xs ?p * \<up> (?xs ~= [])> pop_array ?p
<%(x, r). dyn_array (butlast ?xs) r * \<up> (x = last ?xs)>
BST_Impl.node.sel_1
WithTerm node.lsub (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0)
GetFact (node.lsub (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0) = ?x1.0, BST_Impl.node.sel_1)
BST_Impl.node.sel_2
WithTerm node.key (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0)
GetFact (node.key (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0) = ?x2.0, BST_Impl.node.sel_2)
BST_Impl.node.sel_3
WithTerm val (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0)
GetFact (val (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0) = ?x3.0, BST_Impl.node.sel_3)
BST_Impl.node.sel_4
WithTerm node.rsub (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0)
GetFact (node.rsub (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0) = ?x4.0, BST_Impl.node.sel_4)
Delete DynamicArray.dyn_array_def@forward@ent
Delete DynamicArray.dyn_array_def@forward@hoare_ent
Delete DynamicArray.dyn_array_def@backward@entback
RBTree.balance_def
WithTerm balance ?l ?k ?v ?r
GetFact (balance ?l ?k ?v ?r =
(if cl ?l = R
 then let ll = lsub ?l; rl = rsub ?l
      in if cl ll = R
         then Node (Node (lsub ll) B (key ll) (val ll) (rsub ll)) R (key ?l)
               (val ?l) (Node (rsub ?l) B ?k ?v ?r)
         else if cl rl = R
              then Node (Node (lsub ?l) B (key ?l) (val ?l) (lsub rl)) R
                    (key rl) (val rl) (Node (rsub rl) B ?k ?v ?r)
              else balanceR ?l ?k ?v ?r
 else balanceR ?l ?k ?v ?r), RBTree.balance_def)
RBTree.balance_case
WithTerm balance ?l ?k ?v ?r
CreateConcl black_depth ?l = black_depth ?r
RBTree.balance_non_Leaf@res
WithFact balance ?l ?k ?v ?r = Leaf
GetResolve RBTree.balance_non_Leaf@res
RBTree.balance_bdinv
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithWellForm black_depth ?l = black_depth ?r
WithTerm balance ?l ?k ?v ?r
GetFact (bd_inv (balance ?l ?k ?v ?r), RBTree.balance_bdinv)
RBTree.balance_bd
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithWellForm black_depth ?l = black_depth ?r
WithTerm black_depth (balance ?l ?k ?v ?r)
GetFact (black_depth (balance ?l ?k ?v ?r) = black_depth ?l + 1, RBTree.balance_bd)
Add Hoare triple DynamicArray.array_swap_rule
<dyn_array ?xs ?p * \<up> (?j < length ?xs) * \<up> (?i < length ?xs)>
array_swap ?p ?i ?j <%_. dyn_array (list_swap ?xs ?i ?j) ?p>
Add property rule for function RBTree.balance
### theory "Draft.DynamicArray"
### 1.250s elapsed time, 4.964s cpu time, 0.446s GC time
Loading theory "Draft.Indexed_PQueue_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Add property rule for function RBTree.balance
RBTree.balanceR_inorder_pairs
WithTerm rbt_in_traverse_pairs (balanceR ?l ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (balanceR ?l ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.balanceR_inorder_pairs)
RBTree.balance_inorder_pairs
WithTerm rbt_in_traverse_pairs (balance ?l ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (balance ?l ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.balance_inorder_pairs)
Delete RBTree.balanceR_def
Delete RBTree.balance_def
Found termination order: "{}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Add forward entailment BST_Impl.btree.simps_1@forward
btree Tip ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add backward entailment BST_Impl.btree.simps_1@backward
\<up> (?p = None) \<Longrightarrow>\<^sub>A btree Tip ?p
Add forward entailment BST_Impl.btree.simps_2@forward
btree (tree.Node ?lt ?k ?v ?rt) (Some ?p) \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Alp rp.
   ?p \<mapsto>\<^sub>r node.Node lp ?k ?v rp * btree ?lt lp * btree ?rt rp
Add backward entailment BST_Impl.btree.simps_2@backward
\<exists>\<^sub>Alp rp.
   ?p \<mapsto>\<^sub>r node.Node lp ?k ?v rp * btree ?lt lp *
   btree ?rt rp \<Longrightarrow>\<^sub>A
btree (tree.Node ?lt ?k ?v ?rt) (Some ?p)
Add forward entailment BST_Impl.btree.simps_3@forward
btree (tree.Node ?lt ?k ?v ?rt) None \<Longrightarrow>\<^sub>A false
Add backward entailment BST_Impl.btree.simps_3@backward
false \<Longrightarrow>\<^sub>A btree (tree.Node ?lt ?k ?v ?rt) None
Add forward entailment BST_Impl.btree_Tip
btree Tip ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add forward entailment BST_Impl.btree_Node
btree (tree.Node ?lt ?k ?v ?rt) ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Alp rp.
   the ?p \<mapsto>\<^sub>r node.Node lp ?k ?v rp * btree ?lt lp *
   btree ?rt rp *
   \<up> (?p ~= None)
Delete BST_Impl.btree.simps_1@forward@ent
Delete BST_Impl.btree.simps_1@forward@hoare_ent
Delete BST_Impl.btree.simps_1@backward@entback
Delete BST_Impl.btree.simps_2@forward@ent
Delete BST_Impl.btree.simps_2@forward@hoare_ent
Delete BST_Impl.btree.simps_2@backward@entback
Delete BST_Impl.btree.simps_3@forward@ent
Delete BST_Impl.btree.simps_3@forward@hoare_ent
Delete BST_Impl.btree.simps_3@backward@entback
Add Hoare triple BST_Impl.tree_empty_rule
<emp> tree_empty <btree Tip>
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Add Hoare triple BST_Impl.btree_constr_rule
<btree ?lt ?lp * btree ?rt ?rp> btree_constr ?lp ?k ?v ?rp
<btree (tree.Node ?lt ?k ?v ?rt)>
RBTree.ins.simps_1
WithTerm ins ?x ?v Leaf
GetFact (ins ?x ?v Leaf = Node Leaf R ?x ?v Leaf, RBTree.ins.simps_1)
RBTree.ins.simps_2
WithTerm ins ?x ?v (Node ?l ?c ?y ?w ?r)
GetFact (ins ?x ?v (Node ?l ?c ?y ?w ?r) =
(if ?c = B
 then if ?x = ?y then Node ?l B ?x ?v ?r
      else if ?x < ?y then balance (ins ?x ?v ?l) ?y ?w ?r
           else balance ?l ?y ?w (ins ?x ?v ?r)
 else if ?x = ?y then Node ?l R ?x ?v ?r
      else if ?x < ?y then Node (ins ?x ?v ?l) R ?y ?w ?r
           else Node ?l R ?y ?w (ins ?x ?v ?r)), RBTree.ins.simps_2)
RBTree.ins_non_Leaf@res
WithFact ins ?x ?v ?t = Leaf
GetResolve RBTree.ins_non_Leaf@res
Add property rule for function RBTree.ins
RBTree.bd_inv_ins@left
WithProperty bd_inv ?t
WithTerm ins ?x ?v ?t
GetFact (bd_inv (ins ?x ?v ?t), RBTree.bd_inv_ins@left)
RBTree.ins_inorder_pairs
WithProperty rbt_sorted ?t
WithTerm rbt_in_traverse_pairs (ins ?x ?v ?t)
GetFact (rbt_in_traverse_pairs (ins ?x ?v ?t) =
ordered_insert_pairs ?x ?v (rbt_in_traverse_pairs ?t), RBTree.ins_inorder_pairs)
Add Hoare triple BST_Impl.btree_insert_to_fun
<btree ?t ?b> btree_insert ?k ?v ?b <btree (tree_insert ?k ?v ?t)>
Found termination order: "{}"
Add Hoare triple BST_Impl.btree_del_min_to_fun
<btree ?t ?b *
 \<up>
  (?b ~=
   None)> btree_del_min
           ?b <%r. case r of
                   (r, p) =>
                     btree (snd (del_min ?t)) p *
                     \<up> (r = fst (del_min ?t))>\<^sub>t
RBTree.paint.simps_1
WithTerm paint ?c Leaf
GetFact (paint ?c Leaf = Leaf, RBTree.paint.simps_1)
RBTree.paint.simps_2
WithTerm paint ?c (Node ?l ?c' ?x ?v ?r)
GetFact (paint ?c (Node ?l ?c' ?x ?v ?r) = Node ?l ?c ?x ?v ?r, RBTree.paint.simps_2)
RBTree.paint_case
WithTerm paint ?c ?t
CreateConcl ?t ~= Leaf
Add property rule for function RBTree.paint
Add property rule for function RBTree.paint
RBTree.paint_bd
WithProperty bd_inv ?t
WithWellForm ?t ~= Leaf
WithTerm black_depth (paint R ?t)
WithFact cl ?t = B
GetFact (black_depth (paint R ?t) = black_depth ?t - 1, RBTree.paint_bd)
RBTree.paint_in_traverse_pairs
WithTerm rbt_in_traverse_pairs (paint ?c ?t)
GetFact (rbt_in_traverse_pairs (paint ?c ?t) = rbt_in_traverse_pairs ?t, RBTree.paint_in_traverse_pairs)
RBTree.rbt_insert_def
WithTerm rbt_insert ?x ?v ?t
GetFact (rbt_insert ?x ?v ?t = paint B (ins ?x ?v ?t), RBTree.rbt_insert_def)
Add property rule for function RBTree.rbt_insert
Add property rule for function RBTree.rbt_insert
Add Hoare triple BST_Impl.btree_del_elt_to_fun
<btree (tree.Node ?lt ?x ?v ?rt)
  ?b> btree_del_elt
       ?b <btree (delete_elt_tree (tree.Node ?lt ?x ?v ?rt))>\<^sub>t
RBTree.insert_rbt_map
WithProperty rbt_sorted ?t
WithTerm rbt_map (rbt_insert ?x ?v ?t)
GetFact (rbt_map (rbt_insert ?x ?v ?t) =  rbt_map ?t { ?x \<rightarrow> ?v }, RBTree.insert_rbt_map)
Add Hoare triple BST_Impl.btree_delete_to_fun
<btree ?t ?b> btree_delete ?x ?b <btree (tree_delete ?x ?t)>\<^sub>t
Add Hoare triple BST_Impl.btree_search_correct
<btree ?t ?b * \<up> (tree_sorted ?t)> btree_search ?x ?b
<%r. btree ?t ?b * \<up> (r = tree_search ?t ?x)>
Add forward entailment BST_Impl.btree_map_def@forward
btree_map ?M ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>At.
   btree t ?p * \<up> (tree_sorted t) * \<up> (?M = tree_map t)
Add backward entailment BST_Impl.btree_map_def@backward
\<exists>\<^sub>At.
   btree t ?p * \<up> (tree_sorted t) *
   \<up> (?M = tree_map t) \<Longrightarrow>\<^sub>A
btree_map ?M ?p
Add Hoare triple BST_Impl.btree_empty_rule_map
<emp> tree_empty <btree_map empty_map>
Add Hoare triple BST_Impl.btree_insert_rule_map
<btree_map ?M ?b> btree_insert ?k ?v ?b
<btree_map ( ?M { ?k \<rightarrow> ?v })>
Add Hoare triple BST_Impl.btree_delete_rule_map
<btree_map ?M ?b> btree_delete ?x ?b <btree_map (delete_map ?x ?M)>\<^sub>t
Add Hoare triple BST_Impl.btree_search_rule_map
<btree_map ?M ?b> btree_search ?x ?b
<%r. btree_map ?M ?b * \<up> (r = ?M\<langle>?x\<rangle>)>
### theory "Draft.BST_Impl"
### 1.830s elapsed time, 7.258s cpu time, 0.673s GC time
Loading theory "Draft.Quicksort_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
RBTree.rbt_search.simps_1
WithTerm rbt_search Leaf ?x
GetFact (rbt_search Leaf ?x = None, RBTree.rbt_search.simps_1)
RBTree.rbt_search.simps_2
WithTerm rbt_search (Node ?l ?c ?y ?w ?r) ?x
GetFact (rbt_search (Node ?l ?c ?y ?w ?r) ?x =
(if ?x = ?y then Some ?w
 else if ?x < ?y then rbt_search ?l ?x else rbt_search ?r ?x), RBTree.rbt_search.simps_2)
RBTree.rbt_search_correct
WithProperty rbt_sorted ?t
WithTerm rbt_search ?t ?x
GetFact (rbt_search ?t ?x = rbt_map ?t\<langle>?x\<rangle>, RBTree.rbt_search_correct)
RBTree.balL_def
WithTerm balL ?l ?k ?v ?r
GetFact (balL ?l ?k ?v ?r =
(let lr = lsub ?r
 in if cl ?l = R
    then Node (Node (lsub ?l) B (key ?l) (val ?l) (rsub ?l)) R ?k ?v ?r
    else if ?r = Leaf then Node ?l R ?k ?v ?r
         else if cl ?r = B
              then balance ?l ?k ?v
                    (Node (lsub ?r) R (key ?r) (val ?r) (rsub ?r))
              else if lr = Leaf then Node ?l R ?k ?v ?r
                   else if cl lr = B
                        then Node (Node ?l B ?k ?v (lsub lr)) R (key lr)
                              (val lr)
                              (balance (rsub lr) (key ?r) (val ?r)
                                (paint R (rsub ?r)))
                        else Node ?l R ?k ?v ?r), RBTree.balL_def)
RBTree.balL_case
WithTerm balL ?l ?k ?v ?r
CreateConcl black_depth ?l + 1 = black_depth ?r
RBTree.balR_def
WithTerm balR ?l ?k ?v ?r
GetFact (balR ?l ?k ?v ?r =
(let rl = rsub ?l
 in if cl ?r = R
    then Node ?l R ?k ?v (Node (lsub ?r) B (key ?r) (val ?r) (rsub ?r))
    else if ?l = Leaf then Node ?l R ?k ?v ?r
         else if cl ?l = B
              then balance (Node (lsub ?l) R (key ?l) (val ?l) (rsub ?l)) ?k
                    ?v ?r
              else if rl = Leaf then Node ?l R ?k ?v ?r
                   else if cl rl = B
                        then Node
                              (balance (paint R (lsub ?l)) (key ?l) (val ?l)
                                (lsub rl))
                              R (key rl) (val rl)
                              (Node (rsub rl) B ?k ?v ?r)
                        else Node ?l R ?k ?v ?r), RBTree.balR_def)
RBTree.balR_case
WithTerm balR ?l ?k ?v ?r
CreateConcl black_depth ?l = black_depth ?r + 1
RBTree.balL_bd
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithTerm balL ?l ?k ?v ?r
WithFact cl ?r = B
GetFact (black_depth ?l + 1 = black_depth ?r -->
bd_inv (balL ?l ?k ?v ?r) &
black_depth (balL ?l ?k ?v ?r) = black_depth ?l + 1, RBTree.balL_bd)
RBTree.balL_bd'
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithProperty cl_inv ?r
WithWellForm black_depth ?l + 1 = black_depth ?r
WithTerm balL ?l ?k ?v ?r
GetFact (bd_inv (balL ?l ?k ?v ?r) &
black_depth (balL ?l ?k ?v ?r) = black_depth ?l + 1, RBTree.balL_bd')
RBTree.balL_cl
WithProperty cl_inv' ?l
WithProperty cl_inv ?r
WithTerm balL ?l ?k ?v ?r
WithFact cl ?r = B
GetFact (cl_inv (balL ?l ?k ?v ?r), RBTree.balL_cl)
Add property rule for function RBTree.balL
RBTree.balR_bd
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithProperty cl_inv ?l
WithWellForm black_depth ?l = black_depth ?r + 1
WithTerm balR ?l ?k ?v ?r
GetFact (bd_inv (balR ?l ?k ?v ?r) & black_depth (balR ?l ?k ?v ?r) = black_depth ?l, RBTree.balR_bd)
RBTree.balR_cl
WithProperty cl_inv ?l
WithProperty cl_inv' ?r
WithTerm balR ?l ?k ?v ?r
WithFact cl ?l = B
GetFact (cl_inv (balR ?l ?k ?v ?r), RBTree.balR_cl)
Add property rule for function RBTree.balR
RBTree.balL_in_traverse_pairs
WithTerm rbt_in_traverse_pairs (balL ?l ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (balL ?l ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.balL_in_traverse_pairs)
RBTree.balR_in_traverse_pairs
WithTerm rbt_in_traverse_pairs (balR ?l ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (balR ?l ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.balR_in_traverse_pairs)
Delete RBTree.balL_def
Delete RBTree.balR_def
Rect_Intersect.operation.collapse_1@sym
WithProperty is_INS ?operation
WithTerm ?operation
GetFact (?operation = INS (pos ?operation) (op_idx ?operation) (op_int ?operation), Rect_Intersect.operation.collapse_1@sym)
Rect_Intersect.operation.collapse_2@sym
WithTerm ?operation
WithGoal is_INS ?operation
GetFact (?operation = DEL (pos ?operation) (op_idx ?operation) (op_int ?operation), Rect_Intersect.operation.collapse_2@sym)
Rect_Intersect.operation.sel_1
WithTerm pos (INS ?x11.0 ?x12.0 ?x13.0)
GetFact (pos (INS ?x11.0 ?x12.0 ?x13.0) = ?x11.0, Rect_Intersect.operation.sel_1)
Rect_Intersect.operation.sel_2
WithTerm pos (DEL ?x21.0 ?x22.0 ?x23.0)
GetFact (pos (DEL ?x21.0 ?x22.0 ?x23.0) = ?x21.0, Rect_Intersect.operation.sel_2)
Rect_Intersect.operation.sel_3
WithTerm op_idx (INS ?x11.0 ?x12.0 ?x13.0)
GetFact (op_idx (INS ?x11.0 ?x12.0 ?x13.0) = ?x12.0, Rect_Intersect.operation.sel_3)
Rect_Intersect.operation.sel_4
WithTerm op_idx (DEL ?x21.0 ?x22.0 ?x23.0)
GetFact (op_idx (DEL ?x21.0 ?x22.0 ?x23.0) = ?x22.0, Rect_Intersect.operation.sel_4)
Rect_Intersect.operation.sel_5
WithTerm op_int (INS ?x11.0 ?x12.0 ?x13.0)
GetFact (op_int (INS ?x11.0 ?x12.0 ?x13.0) = ?x13.0, Rect_Intersect.operation.sel_5)
Rect_Intersect.operation.sel_6
WithTerm op_int (DEL ?x21.0 ?x22.0 ?x23.0)
GetFact (op_int (DEL ?x21.0 ?x22.0 ?x23.0) = ?x23.0, Rect_Intersect.operation.sel_6)
Rect_Intersect.operation.case_1
WithTerm case INS ?x11.0 ?x12.0 ?x13.0 of INS x xa xb => ?f1.0 x xa xb
| DEL x xa xb => ?f2.0 x xa xb
GetFact ((case INS ?x11.0 ?x12.0 ?x13.0 of INS x xa xb => ?f1.0 x xa xb
 | DEL x xa xb => ?f2.0 x xa xb) =
?f1.0 ?x11.0 ?x12.0 ?x13.0, Rect_Intersect.operation.case_1)
Rect_Intersect.operation.case_2
WithTerm case DEL ?x21.0 ?x22.0 ?x23.0 of INS x xa xb => ?f1.0 x xa xb
| DEL x xa xb => ?f2.0 x xa xb
GetFact ((case DEL ?x21.0 ?x22.0 ?x23.0 of INS x xa xb => ?f1.0 x xa xb
 | DEL x xa xb => ?f2.0 x xa xb) =
?f2.0 ?x21.0 ?x22.0 ?x23.0, Rect_Intersect.operation.case_2)
Rect_Intersect.operation.distinct_1@res
WithFact INS ?x11.0 ?x12.0 ?x13.0 = DEL ?x21.0 ?x22.0 ?x23.0
GetResolve Rect_Intersect.operation.distinct_1@res
Rect_Intersect.operation.disc_1
WithTerm INS ?x11.0 ?x12.0 ?x13.0
GetFact (is_INS (INS ?x11.0 ?x12.0 ?x13.0), Rect_Intersect.operation.disc_1)
Rect_Intersect.operation.disc_2
WithTerm DEL ?x21.0 ?x22.0 ?x23.0
GetGoal (is_INS (DEL ?x21.0 ?x22.0 ?x23.0), Rect_Intersect.operation.disc_2)
instantiation
  operation :: (linorder) linorder
  less_eq_operation == less_eq :: 'a operation => 'a operation => bool
  less_operation == less :: 'a operation => 'a operation => bool
Add Hoare triple Quicksort_Impl.part1_to_fun
<?p \<mapsto>\<^sub>a ?xs * \<up> (?r < length ?xs)>
Quicksort_Impl.part1 ?p ?l ?r ?a
<%rs. ?p \<mapsto>\<^sub>a snd (Quicksort.part1 ?xs ?l ?r ?a) *
      \<up> (rs = fst (Quicksort.part1 ?xs ?l ?r ?a))>
Rect_Intersect.less_eq@eqforward
WithFact ?a <= ?b
GetFact (if pos ?a ~= pos ?b then pos ?a < pos ?b
else if is_INS ?a ~= is_INS ?b then is_INS ?a & ~ is_INS ?b
     else if op_idx ?a ~= op_idx ?b then op_idx ?a < op_idx ?b
          else op_int ?a <= op_int ?b, Rect_Intersect.less_eq@eqforward)
Rect_Intersect.less_eq@invbackward
WithGoal ?a <= ?b
GetGoal (if pos ?a ~= pos ?b then pos ?a < pos ?b
else if is_INS ?a ~= is_INS ?b then is_INS ?a & ~ is_INS ?b
     else if op_idx ?a ~= op_idx ?b then op_idx ?a < op_idx ?b
          else op_int ?a <= op_int ?b, Rect_Intersect.less_eq@invbackward)
Add Hoare triple Quicksort_Impl.partition_to_fun
<?a \<mapsto>\<^sub>a ?xs * \<up> (?r < length ?xs) * \<up> (?l < ?r)>
Quicksort_Impl.partition ?a ?l ?r
<%rs. ?a \<mapsto>\<^sub>a snd (Quicksort.partition ?xs ?l ?r) *
      \<up> (rs = fst (Quicksort.partition ?xs ?l ?r))>
Rect_Intersect.less@eqforward
WithFact ?a < ?b
GetFact (if pos ?a ~= pos ?b then pos ?a < pos ?b
else if is_INS ?a ~= is_INS ?b then is_INS ?a & ~ is_INS ?b
     else if op_idx ?a ~= op_idx ?b then op_idx ?a < op_idx ?b
          else op_int ?a < op_int ?b, Rect_Intersect.less@eqforward)
Rect_Intersect.less@invbackward
WithGoal ?a < ?b
GetGoal (if pos ?a ~= pos ?b then pos ?a < pos ?b
else if is_INS ?a ~= is_INS ?b then is_INS ?a & ~ is_INS ?b
     else if op_idx ?a ~= op_idx ?b then op_idx ?a < op_idx ?b
          else op_int ?a < op_int ?b, Rect_Intersect.less@invbackward)
Rect_Intersect.operation_leD
WithFact ?a <= ?b
GetFact (pos ?a <= pos ?b, Rect_Intersect.operation_leD)
Rect_Intersect.operation_lessI@back
WithGoal INS ?p1.0 ?n1.0 ?i1.0 < DEL ?p2.0 ?n2.0 ?i2.0
GetGoal (?p1.0 <= ?p2.0, Rect_Intersect.operation_lessI@back)
Delete Rect_Intersect.less_eq@eqforward
Delete Rect_Intersect.less_eq@invbackward
Delete Rect_Intersect.less@eqforward
Delete Rect_Intersect.less@invbackward
Add Hoare triple Quicksort_Impl.quicksort_to_fun
<?a \<mapsto>\<^sub>a ?xs * \<up> (?r < length ?xs)>
Quicksort_Impl.quicksort ?a ?l ?r
<%_. ?a \<mapsto>\<^sub>a Quicksort.quicksort ?xs ?l ?r>
Add Hoare triple Quicksort_Impl.quicksort_sorts_basic
<?a \<mapsto>\<^sub>a ?xs> quicksort_all ?a
<%_. ?a \<mapsto>\<^sub>a sort ?xs>
### theory "Draft.Quicksort_Impl"
### 0.316s elapsed time, 1.253s cpu time, 0.079s GC time
Loading theory "Draft.GCD_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Found termination order: "{}"
Rect_Intersect.ins_op.simps
WithTerm ins_op ?rects ?i
GetFact (ins_op ?rects ?i = INS (low (yint (?rects ! ?i))) ?i (xint (?rects ! ?i)), Rect_Intersect.ins_op.simps)
GCD.gcd_red_nat@sym
WithTerm gcd ?y (?x mod ?y)
GetFact (gcd ?y (?x mod ?y) = gcd ?x ?y, GCD.gcd_red_nat@sym)
Found termination order: "{}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Rect_Intersect.del_op.simps
WithTerm del_op ?rects ?i
GetFact (del_op ?rects ?i = DEL (high (yint (?rects ! ?i))) ?i (xint (?rects ! ?i)), Rect_Intersect.del_op.simps)
Rect_Intersect.ins_ops_def
WithTerm ins_ops ?rects
GetFact (ins_ops ?rects = list (ins_op ?rects) (length ?rects), Rect_Intersect.ins_ops_def)
Rect_Intersect.del_ops_def
WithTerm del_ops ?rects
GetFact (del_ops ?rects = list (del_op ?rects) (length ?rects), Rect_Intersect.del_ops_def)
Add property rule for function Rect_Intersect.ins_ops
Add property rule for function Rect_Intersect.del_ops
### theory "Draft.GCD_Impl"
### 0.108s elapsed time, 0.432s cpu time, 0.000s GC time
Loading theory "Draft.IntervalTree_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples" via "Draft.Rect_Intersect_Impl")
Rect_Intersect.set_ins_ops@eqforward
WithFact ?oper : set (ins_ops ?rects)
GetFact (op_idx ?oper < length ?rects & ?oper = ins_op ?rects (op_idx ?oper), Rect_Intersect.set_ins_ops@eqforward)
Rect_Intersect.set_ins_ops@invbackward
WithGoal ?oper : set (ins_ops ?rects)
GetGoal (op_idx ?oper < length ?rects & ?oper = ins_op ?rects (op_idx ?oper), Rect_Intersect.set_ins_ops@invbackward)
Rect_Intersect.set_del_ops@eqforward
WithFact ?oper : set (del_ops ?rects)
GetFact (op_idx ?oper < length ?rects & ?oper = del_op ?rects (op_idx ?oper), Rect_Intersect.set_del_ops@eqforward)
Rect_Intersect.set_del_ops@invbackward
WithGoal ?oper : set (del_ops ?rects)
GetGoal (op_idx ?oper < length ?rects & ?oper = del_op ?rects (op_idx ?oper), Rect_Intersect.set_del_ops@invbackward)
Rect_Intersect.all_ops_def
WithTerm all_ops ?rects
GetFact (all_ops ?rects = sort (ins_ops ?rects @ del_ops ?rects), Rect_Intersect.all_ops_def)
Add property rule for function Rect_Intersect.all_ops
Rect_Intersect.set_all_ops_idx
WithFact ?oper : set (all_ops ?rects)
GetFact (op_idx ?oper < length ?rects, Rect_Intersect.set_all_ops_idx)
Rect_Intersect.set_all_ops_ins
WithFact INS ?p ?n ?i : set (all_ops ?rects)
GetFact (INS ?p ?n ?i = ins_op ?rects ?n, Rect_Intersect.set_all_ops_ins)
Rect_Intersect.set_all_ops_del
WithFact DEL ?p ?n ?i : set (all_ops ?rects)
GetFact (DEL ?p ?n ?i = del_op ?rects ?n, Rect_Intersect.set_all_ops_del)
Rect_Intersect.ins_in_set_all_ops
WithTerm ins_op ?rects ?i
WithFact ?i < length ?rects
GetFact (ins_op ?rects ?i : set (all_ops ?rects), Rect_Intersect.ins_in_set_all_ops)
Rect_Intersect.del_in_set_all_ops
WithTerm del_op ?rects ?i
WithFact ?i < length ?rects
GetFact (del_op ?rects ?i : set (all_ops ?rects), Rect_Intersect.del_in_set_all_ops)
Add property rule for function Rect_Intersect.all_ops
Rect_Intersect.all_ops_nonempty@back
WithFact all_ops ?rects = []
GetFact (?rects = [], Rect_Intersect.all_ops_nonempty@back)
Delete Rect_Intersect.all_ops_def
Rect_Intersect.apply_ops_k_def
WithTerm apply_ops_k ?rects ?k
GetFact (apply_ops_k ?rects ?k =
(let ops = all_ops ?rects
 in {i. i < length ?rects &
        (EX j<?k. ins_op ?rects i = ops ! j) &
        ~ (EX j<?k. del_op ?rects i = ops ! j)}), Rect_Intersect.apply_ops_k_def)
Apply def ?ops = all_ops ?rects
Rect_Intersect.apply_ops_set_mem@eqforward
WithFact ?i : apply_ops_k ?rects ?k
GetFact (?i < length ?rects &
(EX j<?k. ins_op ?rects ?i = all_ops ?rects ! j) &
~ (EX j<?k. del_op ?rects ?i = all_ops ?rects ! j), Rect_Intersect.apply_ops_set_mem@eqforward)
Apply def ?ops = all_ops ?rects
Rect_Intersect.apply_ops_set_mem@invbackward
WithGoal ?i : apply_ops_k ?rects ?k
GetGoal (?i < length ?rects &
(EX j<?k. ins_op ?rects ?i = all_ops ?rects ! j) &
~ (EX j<?k. del_op ?rects ?i = all_ops ?rects ! j), Rect_Intersect.apply_ops_set_mem@invbackward)
Delete Rect_Intersect.apply_ops_k_def
Rect_Intersect.xints_of_def
WithTerm xints_of ?rect ?is
GetFact (xints_of ?rect ?is = (%i. IdxInterval (xint (?rect ! i)) i) ` ?is, Rect_Intersect.xints_of_def)
Rect_Intersect.xints_of_mem@eqforward
WithFact IdxInterval ?it ?i : xints_of ?rect ?is
GetFact (?i : ?is & xint (?rect ! ?i) = ?it, Rect_Intersect.xints_of_mem@eqforward)
Rect_Intersect.xints_of_mem@invbackward
WithGoal IdxInterval ?it ?i : xints_of ?rect ?is
GetGoal (?i : ?is & xint (?rect ! ?i) = ?it, Rect_Intersect.xints_of_mem@invbackward)
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Rect_Intersect.xints_diff
WithTerm xints_of ?rects (?A - ?B)
GetFact (xints_of ?rects (?A - ?B) = xints_of ?rects ?A - xints_of ?rects ?B, Rect_Intersect.xints_diff)
Rect_Intersect.has_overlap_at_k_def@eqforward
WithFact has_overlap_at_k ?rects ?k
GetFact (let S = apply_ops_k ?rects ?k; ops = all_ops ?rects
in is_INS (ops ! ?k) & has_overlap (xints_of ?rects S) (op_int (ops ! ?k)), Rect_Intersect.has_overlap_at_k_def@eqforward)
Rect_Intersect.has_overlap_at_k_def@invbackward
WithGoal has_overlap_at_k ?rects ?k
GetGoal (let S = apply_ops_k ?rects ?k; ops = all_ops ?rects
in is_INS (ops ! ?k) & has_overlap (xints_of ?rects S) (op_int (ops ! ?k)), Rect_Intersect.has_overlap_at_k_def@invbackward)
Apply def ?ops = all_ops ?rects
Rect_Intersect.has_overlap_at_k_equiv
WithProperty is_rect_list ?rects
WithWellForm ?k < length (all_ops ?rects)
WithFact has_overlap_at_k ?rects ?k
GetFact (has_rect_overlap ?rects, Rect_Intersect.has_overlap_at_k_equiv)
Indexed_PQueue_Impl.indexed_pqueue.collapse@sym
WithTerm ?indexed_pqueue
GetFact (?indexed_pqueue =
Indexed_PQueue (pqueue ?indexed_pqueue) (index ?indexed_pqueue), Indexed_PQueue_Impl.indexed_pqueue.collapse@sym) + 1 filters
Indexed_PQueue_Impl.indexed_pqueue.case
WithTerm case Indexed_PQueue ?x1.0 ?x2.0 of Indexed_PQueue x xa => ?f x xa
GetFact ((case Indexed_PQueue ?x1.0 ?x2.0 of Indexed_PQueue x xa => ?f x xa) =
?f ?x1.0 ?x2.0, Indexed_PQueue_Impl.indexed_pqueue.case)
Indexed_PQueue_Impl.indexed_pqueue.sel_1
WithTerm pqueue (Indexed_PQueue ?x1.0 ?x2.0)
GetFact (pqueue (Indexed_PQueue ?x1.0 ?x2.0) = ?x1.0, Indexed_PQueue_Impl.indexed_pqueue.sel_1)
Indexed_PQueue_Impl.indexed_pqueue.sel_2
WithTerm index (Indexed_PQueue ?x1.0 ?x2.0)
GetFact (index (Indexed_PQueue ?x1.0 ?x2.0) = ?x2.0, Indexed_PQueue_Impl.indexed_pqueue.sel_2)
Indexed_PQueue_Impl.indexed_pqueue.simps_1@eqforward
WithFact Indexed_PQueue ?x1.0 ?x2.0 = Indexed_PQueue ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Indexed_PQueue_Impl.indexed_pqueue.simps_1@eqforward)
Apply def ?ops = all_ops ?rects
Rect_Intersect.has_overlap_at_k_equiv2@res
WithProperty is_rect_list ?rects
WithProperty has_rect_overlap ?rects
WithGoal EX k<length (all_ops ?rects). has_overlap_at_k ?rects k
GetResolve Rect_Intersect.has_overlap_at_k_equiv2@res
Rect_Intersect.has_overlap_lst_def@eqforward
WithFact has_overlap_lst ?rects
GetFact (let ops = all_ops ?rects in EX k<length ops. has_overlap_at_k ?rects k, Rect_Intersect.has_overlap_lst_def@eqforward)
Rect_Intersect.has_overlap_lst_def@invbackward
WithGoal has_overlap_lst ?rects
GetGoal (let ops = all_ops ?rects in EX k<length ops. has_overlap_at_k ?rects k, Rect_Intersect.has_overlap_lst_def@invbackward)
RBTree.combine.simps_1
WithTerm combine Leaf ?t
GetFact (combine Leaf ?t = ?t, RBTree.combine.simps_1)
RBTree.combine.simps_2
WithTerm combine (Node ?v ?va ?vb ?vc ?vd) Leaf
GetFact (combine (Node ?v ?va ?vb ?vc ?vd) Leaf = Node ?v ?va ?vb ?vc ?vd, RBTree.combine.simps_2)
Add property rule for [Rect_Intersect.is_rect_list, Rect_Intersect.has_overlap_lst]
Rect_Intersect.has_overlap_equiv@invbackward
WithProperty is_rect_list ?rects
WithGoal has_overlap_lst ?rects
GetGoal (has_rect_overlap ?rects, Rect_Intersect.has_overlap_equiv@invbackward)
RBTree.combine_bd
WithProperty bd_inv ?lt
WithProperty bd_inv ?rt
WithTerm combine ?lt ?rt
WithFact black_depth ?lt = black_depth ?rt
GetFact (bd_inv (combine ?lt ?rt) & black_depth (combine ?lt ?rt) = black_depth ?lt, RBTree.combine_bd)
Apply def ?ops = all_ops ?rects
Rect_Intersect.apply_ops_k_next1
WithProperty is_rect_list ?rects
WithWellForm ?n < length (all_ops ?rects)
WithTerm apply_ops_k ?rects (?n + 1)
WithFact is_INS (all_ops ?rects ! ?n)
GetFact (apply_ops_k ?rects (?n + 1) =
apply_ops_k ?rects ?n Un {op_idx (all_ops ?rects ! ?n)}, Rect_Intersect.apply_ops_k_next1)
Apply def ?ops = all_ops ?rects
RBTree.combine_cl
WithProperty cl_inv ?lt
WithProperty cl_inv ?rt
WithTerm combine ?lt ?rt
GetFact ((cl ?lt = B --> cl ?rt = B --> cl_inv (combine ?lt ?rt)) &
cl_inv' (combine ?lt ?rt), RBTree.combine_cl)
Rect_Intersect.apply_ops_k_next2
WithProperty is_rect_list ?rects
WithWellForm ?n < length (all_ops ?rects)
WithTerm apply_ops_k ?rects (?n + 1)
WithGoal is_INS (all_ops ?rects ! ?n)
GetFact (apply_ops_k ?rects (?n + 1) =
apply_ops_k ?rects ?n - {op_idx (all_ops ?rects ! ?n)}, Rect_Intersect.apply_ops_k_next2)
RBTree.combine_in_traverse_pairs
WithTerm rbt_in_traverse_pairs (combine ?lt ?rt)
GetFact (rbt_in_traverse_pairs (combine ?lt ?rt) =
rbt_in_traverse_pairs ?lt @ rbt_in_traverse_pairs ?rt, RBTree.combine_in_traverse_pairs)
Rect_Intersect.apply_ops_k_next_def
WithTerm apply_ops_k_next ?rects ?S ?k
GetFact (apply_ops_k_next ?rects ?S ?k =
(let ops = all_ops ?rects
 in case ops ! ?k of INS p n i => ?S Un {IdxInterval i n}
    | DEL p n i => ?S - {IdxInterval i n}), Rect_Intersect.apply_ops_k_next_def)
Apply def ?ops = all_ops ?rects
Apply def ?S = xints_of ?rects (apply_ops_k ?rects ?n)
Rect_Intersect.apply_ops_k_next_is_correct
WithProperty is_rect_list ?rects
WithTerm xints_of ?rects (apply_ops_k ?rects (?n + 1))
WithFact ?n < length (all_ops ?rects)
GetFact (xints_of ?rects (apply_ops_k ?rects (?n + 1)) =
apply_ops_k_next ?rects (xints_of ?rects (apply_ops_k ?rects ?n)) ?n, Rect_Intersect.apply_ops_k_next_is_correct)
Found termination order: "{}"
Add forward entailment Indexed_PQueue_Impl.idx_pqueue.simps@forward
idx_pqueue (?xs, ?m) (Indexed_PQueue ?pq ?idx) \<Longrightarrow>\<^sub>A
dyn_array ?xs ?pq * ?idx \<mapsto>\<^sub>a ?m
Add backward entailment Indexed_PQueue_Impl.idx_pqueue.simps@backward
dyn_array ?xs ?pq * ?idx \<mapsto>\<^sub>a ?m \<Longrightarrow>\<^sub>A
idx_pqueue (?xs, ?m) (Indexed_PQueue ?pq ?idx)
Add Hoare triple Indexed_PQueue_Impl.idx_pqueue_empty_rule
<emp> idx_pqueue_empty ?n <idx_pqueue ([], replicate ?n None)>
Add Hoare triple Indexed_PQueue_Impl.idx_pqueue_nth_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (?i < length ?xs)> idx_pqueue_nth ?p ?i
<%r. idx_pqueue (?xs, ?m) ?p * \<up> (r = ?xs ! ?i)>
Add Hoare triple Indexed_PQueue_Impl.idx_nth_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (?i < length ?m)> idx_nth ?p ?i
<%r. idx_pqueue (?xs, ?m) ?p * \<up> (r = ?m ! ?i)>
Add Hoare triple Indexed_PQueue_Impl.idx_pqueue_length_rule
<idx_pqueue (?xs, ?m) ?p> idx_pqueue_length ?p
<%r. idx_pqueue (?xs, ?m) ?p * \<up> (r = length ?xs)>
Add Hoare triple Indexed_PQueue_Impl.idx_pqueue_swap_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (index_of_pqueue (?xs, ?m)) *
 \<up> (?j < length ?xs) *
 \<up> (?i < length ?xs)>
idx_pqueue_swap ?p ?i ?j
<%_. idx_pqueue (idx_pqueue_swap_fun (?xs, ?m) ?i ?j) ?p>
Add Hoare triple Indexed_PQueue_Impl.idx_pqueue_push_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (~ has_key_alist ?xs ?k) *
 \<up>
  (?k < length
         ?m)> idx_pqueue_push ?k ?v
               ?p <idx_pqueue (idx_pqueue_push_fun ?k ?v (?xs, ?m))>\<^sub>t
Add Hoare triple Indexed_PQueue_Impl.idx_pqueue_pop_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (index_of_pqueue (?xs, ?m)) *
 \<up> (?xs ~= [])>
idx_pqueue_pop ?p
<%(x, r).
    idx_pqueue (idx_pqueue_pop_fun (?xs, ?m)) r * \<up> (x = last ?xs)>
Apply def ?ops = all_ops ?rects
Rect_Intersect.rect_inter_correct_ind@eqforward
WithProperty is_rect_list ?rects
WithWellForm ?n < length (all_ops ?rects)
WithFact rect_inter ?rects (xints_of ?rects (apply_ops_k ?rects ?n)) ?n
GetFact (EX k<length (all_ops ?rects). ?n <= k & has_overlap_at_k ?rects k, Rect_Intersect.rect_inter_correct_ind@eqforward)
Apply def ?ops = all_ops ?rects
Rect_Intersect.rect_inter_correct_ind@invbackward
WithProperty is_rect_list ?rects
WithWellForm ?n < length (all_ops ?rects)
WithGoal rect_inter ?rects (xints_of ?rects (apply_ops_k ?rects ?n)) ?n
GetGoal (EX k<length (all_ops ?rects). ?n <= k & has_overlap_at_k ?rects k, Rect_Intersect.rect_inter_correct_ind@invbackward)
Rect_Intersect.rect_inter_correct@eqforward
WithProperty is_rect_list ?rects
WithFact rect_inter ?rects {} 0
GetFact (has_rect_overlap ?rects, Rect_Intersect.rect_inter_correct@eqforward)
Rect_Intersect.rect_inter_correct@invbackward
WithProperty is_rect_list ?rects
WithGoal rect_inter ?rects {} 0
GetGoal (has_rect_overlap ?rects, Rect_Intersect.rect_inter_correct@invbackward)
### theory "Draft.Rect_Intersect"
### 1.966s elapsed time, 7.797s cpu time, 0.631s GC time
Loading theory "Draft.LinkedList" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Add Hoare triple Indexed_PQueue_Impl.array_upd_idx_pqueue_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (?k = fst (?xs ! ?i)) *
 \<up> (?i < length ?xs)>
idx_pqueue_array_upd ?i (?k, ?v) (pqueue ?p)
<%_. idx_pqueue (?xs[?i := (?k, ?v)], ?m) ?p>
Add Hoare triple Indexed_PQueue_Impl.has_key_idx_pqueue_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (index_of_pqueue (?xs, ?m)) *
 \<up> (?k < length ?m)>
has_key_idx_pqueue ?k ?p
<%r. idx_pqueue (?xs, ?m) ?p * \<up> (r = has_key_alist ?xs ?k)>
Delete Indexed_PQueue_Impl.idx_pqueue.simps@forward@ent
Delete Indexed_PQueue_Impl.idx_pqueue.simps@forward@hoare_ent
Delete Indexed_PQueue_Impl.idx_pqueue.simps@backward@entback
Delete Indexed_PQueue_Impl.indexed_pqueue.collapse@sym
Delete Indexed_PQueue_Impl.indexed_pqueue.case
Delete Indexed_PQueue_Impl.indexed_pqueue.simps_1@eqforward
Delete Indexed_PQueue_Impl.indexed_pqueue.sel_1
Delete Indexed_PQueue_Impl.indexed_pqueue.sel_2
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
RBTree.del.simps_1
WithTerm del ?x Leaf
GetFact (del ?x Leaf = Leaf, RBTree.del.simps_1)
RBTree.del_bd
WithProperty bd_inv ?t
WithProperty cl_inv ?t
WithTerm del ?x ?t
GetFact (bd_inv (del ?x ?t) &
(if cl ?t = R then black_depth (del ?x ?t) = black_depth ?t
 else black_depth (del ?x ?t) = black_depth ?t - 1), RBTree.del_bd)
Add Hoare triple Indexed_PQueue_Impl.idx_bubble_down_rule
<idx_pqueue ?x ?a * \<up> (index_of_pqueue ?x)> idx_bubble_down ?a ?k
<%_. idx_pqueue (idx_bubble_down_fun ?x ?k) ?a>
RBTree.del_cl
WithProperty cl_inv ?t
WithTerm del ?x ?t
GetFact (if cl ?t = R then cl_inv (del ?x ?t) else cl_inv' (del ?x ?t), RBTree.del_cl)
RBTree.del_in_traverse_pairs
WithProperty rbt_sorted ?t
WithTerm rbt_in_traverse_pairs (del ?x ?t)
GetFact (rbt_in_traverse_pairs (del ?x ?t) =
remove_elt_pairs ?x (rbt_in_traverse_pairs ?t), RBTree.del_in_traverse_pairs)
RBTree.delete_def
WithTerm delete ?x ?t
GetFact (delete ?x ?t = paint B (del ?x ?t), RBTree.delete_def)
Add property rule for function RBTree.delete
Add property rule for function RBTree.delete
Found termination order: "{}"
RBTree.delete_rbt_map
WithProperty rbt_sorted ?t
WithTerm rbt_map (delete ?x ?t)
GetFact (rbt_map (delete ?x ?t) = delete_map ?x (rbt_map ?t), RBTree.delete_rbt_map)
Delete RBTree.balance_case
Delete RBTree.balL_case
Delete RBTree.balR_case
Delete RBTree.paint_case
### theory "Draft.RBTree"
### 3.848s elapsed time, 15.244s cpu time, 1.380s GC time
Loading theory "Draft.RBTree_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Add Hoare triple Indexed_PQueue_Impl.idx_bubble_up_rule
<idx_pqueue ?x ?a * \<up> (index_of_pqueue ?x)> idx_bubble_up ?a ?k
<%_. idx_pqueue (idx_bubble_up_fun ?x ?k) ?a>
Add Hoare triple Indexed_PQueue_Impl.delete_min_idx_pqueue_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (index_of_pqueue (?xs, ?m)) *
 \<up> (?xs ~= [])>
delete_min_idx_pqueue ?p
<%(x, r).
    idx_pqueue (snd (delete_min_idx_pqueue_fun (?xs, ?m))) r *
    \<up> (x = fst (delete_min_idx_pqueue_fun (?xs, ?m)))>
Found termination order: "{}"
Add Hoare triple Indexed_PQueue_Impl.insert_idx_pqueue_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (index_of_pqueue (?xs, ?m)) *
 \<up> (~ has_key_alist ?xs ?k) *
 \<up>
  (?k < length
         ?m)> insert_idx_pqueue ?k ?v
               ?p <idx_pqueue
                    (insert_idx_pqueue_fun ?k ?v (?xs, ?m))>\<^sub>t
Add Hoare triple Indexed_PQueue_Impl.update_idx_pqueue_rule
<idx_pqueue (?xs, ?m) ?p * \<up> (index_of_pqueue (?xs, ?m)) *
 \<up>
  (?k < length
         ?m)> update_idx_pqueue ?k ?v
               ?p <idx_pqueue
                    (update_idx_pqueue_fun ?k ?v (?xs, ?m))>\<^sub>t
Add forward entailment Indexed_PQueue_Impl.idx_pqueue_map_def@forward
idx_pqueue_map ?M ?n ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Axs m.
   idx_pqueue (xs, m) ?p * \<up> (index_of_pqueue (xs, m)) *
   \<up> (is_heap xs) *
   \<up> (?M = map_of_alist xs) *
   \<up> (?n = length m)
Add backward entailment Indexed_PQueue_Impl.idx_pqueue_map_def@backward
\<exists>\<^sub>Axs m.
   idx_pqueue (xs, m) ?p * \<up> (index_of_pqueue (xs, m)) *
   \<up> (is_heap xs) *
   \<up> (?M = map_of_alist xs) *
   \<up> (?n = length m) \<Longrightarrow>\<^sub>A
idx_pqueue_map ?M ?n ?p
Indexed_PQueue_Impl.heap_implies_hd_min2@res
WithProperty is_heap ?xs
WithWellForm ?xs ~= []
WithGoal snd (hd ?xs) <= ?v
WithFact map_of_alist ?xs\<langle>?k\<rangle> = Some ?v
GetResolve Indexed_PQueue_Impl.heap_implies_hd_min2@res
Add Hoare triple Indexed_PQueue_Impl.idx_pqueue_empty_map
<emp> idx_pqueue_empty ?n <idx_pqueue_map empty_map ?n>
Add Hoare triple Indexed_PQueue_Impl.delete_min_idx_pqueue_map
<idx_pqueue_map ?M ?n ?p * \<up> (?M ~= empty_map)> delete_min_idx_pqueue ?p
<%(x, r).
    idx_pqueue_map (delete_map (fst x) ?M) ?n r * \<up> (fst x < ?n) *
    \<up> (is_heap_min (fst x) ?M) *
    \<up> (?M\<langle>fst x\<rangle> = Some (snd x))>
Add Hoare triple Indexed_PQueue_Impl.insert_idx_pqueue_map
<idx_pqueue_map ?M ?n ?p * \<up> (?k ~: keys_of ?M) *
 \<up>
  (?k < ?n)> insert_idx_pqueue ?k ?v
              ?p <idx_pqueue_map ( ?M { ?k \<rightarrow> ?v }) ?n>\<^sub>t
Add Hoare triple Indexed_PQueue_Impl.has_key_idx_pqueue_map
<idx_pqueue_map ?M ?n ?p * \<up> (?k < ?n)> has_key_idx_pqueue ?k ?p
<%r. idx_pqueue_map ?M ?n ?p * \<up> (r = (?k : keys_of ?M))>
Add Hoare triple Indexed_PQueue_Impl.update_idx_pqueue_map
<idx_pqueue_map ?M ?n ?p *
 \<up>
  (?k < ?n)> update_idx_pqueue ?k ?v
              ?p <idx_pqueue_map ( ?M { ?k \<rightarrow> ?v }) ?n>\<^sub>t
Delete Indexed_PQueue_Impl.idx_pqueue_map_def@forward@ent
Delete Indexed_PQueue_Impl.idx_pqueue_map_def@forward@hoare_ent
Delete Indexed_PQueue_Impl.idx_pqueue_map_def@backward@entback
### theory "Draft.Indexed_PQueue_Impl"
### 1.518s elapsed time, 6.013s cpu time, 0.490s GC time
Loading theory "Draft.Dijkstra_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
LinkedList.node.sel_1
WithTerm val (Node ?x1.0 ?x2.0)
GetFact (val (Node ?x1.0 ?x2.0) = ?x1.0, LinkedList.node.sel_1)
LinkedList.node.sel_2
WithTerm nxt (Node ?x1.0 ?x2.0)
GetFact (nxt (Node ?x1.0 ?x2.0) = ?x2.0, LinkedList.node.sel_2)
Found termination order: "{}"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
Add forward entailment LinkedList.os_list.simps_1@forward
os_list [] ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add backward entailment LinkedList.os_list.simps_1@backward
\<up> (?p = None) \<Longrightarrow>\<^sub>A os_list [] ?p
Add forward entailment LinkedList.os_list.simps_2@forward
os_list (?x # ?l) (Some ?p) \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Aq. ?p \<mapsto>\<^sub>r Node ?x q * os_list ?l q
Add backward entailment LinkedList.os_list.simps_2@backward
\<exists>\<^sub>Aq.
   ?p \<mapsto>\<^sub>r Node ?x q * os_list ?l q \<Longrightarrow>\<^sub>A
os_list (?x # ?l) (Some ?p)
Add forward entailment LinkedList.os_list.simps_3@forward
os_list (?x # ?l) None \<Longrightarrow>\<^sub>A false
Add backward entailment LinkedList.os_list.simps_3@backward
false \<Longrightarrow>\<^sub>A os_list (?x # ?l) None
Add forward entailment LinkedList.os_list_empty
os_list [] ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add forward entailment LinkedList.os_list_Cons
os_list (?x # ?l) ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Aq.
   the ?p \<mapsto>\<^sub>r Node ?x q * os_list ?l q * \<up> (?p ~= None)
Delete LinkedList.os_list.simps_1@forward@ent
Delete LinkedList.os_list.simps_1@forward@hoare_ent
Delete LinkedList.os_list.simps_1@backward@entback
Delete LinkedList.os_list.simps_2@forward@ent
Delete LinkedList.os_list.simps_2@forward@hoare_ent
Delete LinkedList.os_list.simps_2@backward@entback
Delete LinkedList.os_list.simps_3@forward@ent
Delete LinkedList.os_list.simps_3@forward@hoare_ent
Delete LinkedList.os_list.simps_3@backward@entback
val test = fn:
   (Proof.context ->
      term * cterm ->
        'a list * (Type.tyenv * Envir.tenv) ->
          ((BoxID.box_id * 'b) * thm) list)
     -> string -> string * string * (BoxID.box_id * string) list -> unit
val test_assn_term_matcher = [(), (), (), (), (), (), ()]: unit list
val test_list_prop_matcher = [(), (), (), (), (), ()]: unit list
Add Hoare triple LinkedList.os_empty_rule
<emp> os_empty <os_list []>
Add Hoare triple LinkedList.os_is_empty_rule
<os_list ?xs ?b> os_is_empty ?b
<%r. os_list ?xs ?b * \<up> (r = (?xs = []))>
Add Hoare triple LinkedList.os_prepend_rule
<os_list ?xs ?n> os_prepend ?x ?n <os_list (?x # ?xs)>
Add Hoare triple LinkedList.os_pop_rule
<os_list ?xs (Some ?p)> os_pop (Some ?p)
<%(x, r').
    os_list (tl ?xs) r' * ?p \<mapsto>\<^sub>r Node x r' *
    \<up> (x = hd ?xs)>
Add Hoare triple LinkedList.os_reverse_aux_rule
<os_list ?xs ?p * os_list ?ys ?q> os_reverse_aux ?q ?p
<os_list (rev ?xs @ ?ys)>
List.removeAll.simps_1
WithTerm removeAll ?x []
GetFact (removeAll ?x [] = [], List.removeAll.simps_1)
List.removeAll.simps_2
WithTerm removeAll ?x (?y # ?xs)
GetFact (removeAll ?x (?y # ?xs) =
(if ?x = ?y then removeAll ?x ?xs else ?y # removeAll ?x ?xs), List.removeAll.simps_2)
Dijkstra_Impl.dijkstra_state.collapse@sym
WithTerm ?dijkstra_state
GetFact (?dijkstra_state =
Dijkstra_State (est_a ?dijkstra_state) (heap_pq ?dijkstra_state), Dijkstra_Impl.dijkstra_state.collapse@sym) + 1 filters
Dijkstra_Impl.dijkstra_state.case
WithTerm case Dijkstra_State ?x1.0 ?x2.0 of Dijkstra_State x xa => ?f x xa
GetFact ((case Dijkstra_State ?x1.0 ?x2.0 of Dijkstra_State x xa => ?f x xa) =
?f ?x1.0 ?x2.0, Dijkstra_Impl.dijkstra_state.case)
Dijkstra_Impl.dijkstra_state.sel_1
WithTerm est_a (Dijkstra_State ?x1.0 ?x2.0)
GetFact (est_a (Dijkstra_State ?x1.0 ?x2.0) = ?x1.0, Dijkstra_Impl.dijkstra_state.sel_1)
Dijkstra_Impl.dijkstra_state.sel_2
WithTerm heap_pq (Dijkstra_State ?x1.0 ?x2.0)
GetFact (heap_pq (Dijkstra_State ?x1.0 ?x2.0) = ?x2.0, Dijkstra_Impl.dijkstra_state.sel_2)
Dijkstra_Impl.dijkstra_state.simps_1@eqforward
WithFact Dijkstra_State ?x1.0 ?x2.0 = Dijkstra_State ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Dijkstra_Impl.dijkstra_state.simps_1@eqforward)
Add Hoare triple LinkedList.os_rem_rule
<os_list ?xs ?b> os_rem ?x ?b <os_list (removeAll ?x ?xs)>\<^sub>t
IntervalTree_Impl.node.sel_1
WithTerm node.lsub (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0)
GetFact (node.lsub (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0) = ?x1.0, IntervalTree_Impl.node.sel_1)
IntervalTree_Impl.node.sel_2
WithTerm node.val (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0)
GetFact (node.val (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0) = ?x2.0, IntervalTree_Impl.node.sel_2)
IntervalTree_Impl.node.sel_3
WithTerm node.tmax (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0)
GetFact (node.tmax (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0) = ?x3.0, IntervalTree_Impl.node.sel_3)
IntervalTree_Impl.node.sel_4
WithTerm node.rsub (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0)
GetFact (node.rsub (node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0) = ?x4.0, IntervalTree_Impl.node.sel_4)
Add Hoare triple LinkedList.extract_list_rule
<os_list ?l ?p> extract_list ?p <%r. os_list ?l ?p * \<up> (r = ?l)>
Found termination order: "{}"
Add forward entailment Dijkstra_Impl.dstate.simps@forward
dstate (State ?e ?M) (Dijkstra_State ?a ?pq) \<Longrightarrow>\<^sub>A
?a \<mapsto>\<^sub>a ?e * idx_pqueue_map ?M (length ?e) ?pq
Add backward entailment Dijkstra_Impl.dstate.simps@backward
?a \<mapsto>\<^sub>a ?e *
idx_pqueue_map ?M (length ?e) ?pq \<Longrightarrow>\<^sub>A
dstate (State ?e ?M) (Dijkstra_State ?a ?pq)
Found termination order: "{}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
LinkedList.list_insert.simps_1
WithTerm list_insert ?x []
GetFact (list_insert ?x [] = [?x], LinkedList.list_insert.simps_1)
LinkedList.list_insert.simps_2
WithTerm list_insert ?x (?y # ?ys)
GetFact (list_insert ?x (?y # ?ys) =
(if ?x <= ?y then ?x # ?y # ?ys else ?y # list_insert ?x ?ys), LinkedList.list_insert.simps_2)
LinkedList.list_insert_length
WithTerm list_insert ?x ?xs
GetFact (length (list_insert ?x ?xs) = length ?xs + 1, LinkedList.list_insert_length)
LinkedList.list_insert_mset
WithTerm mset (list_insert ?x ?xs)
GetFact (mset (list_insert ?x ?xs) = {#?x#} + mset ?xs, LinkedList.list_insert_mset)
LinkedList.list_insert_set
WithTerm set (list_insert ?x ?xs)
GetFact (set (list_insert ?x ?xs) = {?x} Un set ?xs, LinkedList.list_insert_set)
Add property rule for function LinkedList.list_insert
Found termination order: "(%p. size_class.size (snd p)) <*mlex*> {}"
Add Hoare triple Dijkstra_Impl.dstate_pq_init_to_fun
<\<up>
  (?k <= Dijkstra.size
          ?G)> dstate_pq_init ?G
                ?k <idx_pqueue_map (map_constr ((<) 0) (weight ?G 0) ?k)
                     (Dijkstra.size ?G)>\<^sub>t
Add Hoare triple LinkedList.os_insert_to_fun
<os_list ?xs ?b> os_insert ?x ?b <os_list (list_insert ?x ?xs)>
Add Hoare triple Dijkstra_Impl.dstate_init_to_fun
<emp> dstate_init ?G <dstate (dijkstra_start_state ?G)>\<^sub>t
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Add forward entailment IntervalTree_Impl.int_tree.simps_1@forward
int_tree Tip ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add backward entailment IntervalTree_Impl.int_tree.simps_1@backward
\<up> (?p = None) \<Longrightarrow>\<^sub>A int_tree Tip ?p
Add forward entailment IntervalTree_Impl.int_tree.simps_2@forward
int_tree (interval_tree.Node ?lt ?v ?m ?rt)
 (Some ?p) \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Alp rp.
   ?p \<mapsto>\<^sub>r node.Node lp ?v ?m rp * int_tree ?lt lp *
   int_tree ?rt rp
Add backward entailment IntervalTree_Impl.int_tree.simps_2@backward
\<exists>\<^sub>Alp rp.
   ?p \<mapsto>\<^sub>r node.Node lp ?v ?m rp * int_tree ?lt lp *
   int_tree ?rt rp \<Longrightarrow>\<^sub>A
int_tree (interval_tree.Node ?lt ?v ?m ?rt) (Some ?p)
Add forward entailment IntervalTree_Impl.int_tree.simps_3@forward
int_tree (interval_tree.Node ?lt ?v ?m ?rt) None \<Longrightarrow>\<^sub>A
false
Add backward entailment IntervalTree_Impl.int_tree.simps_3@backward
false \<Longrightarrow>\<^sub>A
int_tree (interval_tree.Node ?lt ?v ?m ?rt) None
Add forward entailment IntervalTree_Impl.int_tree_Tip
int_tree Tip ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Found termination order: "length <*mlex*> {}"
Add forward entailment IntervalTree_Impl.int_tree_Node
int_tree (interval_tree.Node ?lt ?v ?m ?rt) ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Alp rp.
   the ?p \<mapsto>\<^sub>r node.Node lp ?v ?m rp * int_tree ?lt lp *
   int_tree ?rt rp *
   \<up> (?p ~= None)
LinkedList.insert_sort.simps_1
WithTerm insert_sort []
GetFact (insert_sort [] = [], LinkedList.insert_sort.simps_1)
LinkedList.insert_sort.simps_2
WithTerm insert_sort (?x # ?xs)
GetFact (insert_sort (?x # ?xs) = list_insert ?x (insert_sort ?xs), LinkedList.insert_sort.simps_2)
Delete IntervalTree_Impl.int_tree.simps_1@forward@ent
Delete IntervalTree_Impl.int_tree.simps_1@forward@hoare_ent
Delete IntervalTree_Impl.int_tree.simps_1@backward@entback
LinkedList.insert_sort_mset
WithTerm mset (insert_sort ?xs)
GetFact (mset (insert_sort ?xs) = mset ?xs, LinkedList.insert_sort_mset)
Delete IntervalTree_Impl.int_tree.simps_2@forward@ent
Delete IntervalTree_Impl.int_tree.simps_2@forward@hoare_ent
Delete IntervalTree_Impl.int_tree.simps_2@backward@entback
Delete IntervalTree_Impl.int_tree.simps_3@forward@ent
Delete IntervalTree_Impl.int_tree.simps_3@forward@hoare_ent
Delete IntervalTree_Impl.int_tree.simps_3@backward@entback
Add property rule for function LinkedList.insert_sort
LinkedList.insert_sort_is_sort
WithTerm insert_sort ?xs
GetFact (insert_sort ?xs = sort ?xs, LinkedList.insert_sort_is_sort)
Add Hoare triple IntervalTree_Impl.int_tree_empty_to_fun
<emp> int_tree_empty <int_tree Tip>
Add Hoare triple IntervalTree_Impl.int_tree_is_empty_rule
<int_tree ?t ?b> int_tree_is_empty ?b
<%r. int_tree ?t ?b * \<up> (r = (?t = Tip))>
Add Hoare triple IntervalTree_Impl.get_tmax_rule
<int_tree ?t ?b> get_tmax ?b
<%r. int_tree ?t ?b * \<up> (r = interval_tree.tmax ?t)>
Add Hoare triple IntervalTree_Impl.compute_tmax_rule
<int_tree ?t1.0 ?b1.0 * int_tree ?t2.0 ?b2.0> compute_tmax ?it ?b1.0 ?b2.0
<%r. int_tree ?t1.0 ?b1.0 * int_tree ?t2.0 ?b2.0 *
     \<up>
      (r = max3 ?it (interval_tree.tmax ?t1.0) (interval_tree.tmax ?t2.0))>
Add Hoare triple IntervalTree_Impl.int_tree_constr_rule
<int_tree ?lt ?lp * int_tree ?rt ?rp> int_tree_constr ?lp ?v ?rp
<int_tree
  (interval_tree.Node ?lt ?v
    (max3 ?v (interval_tree.tmax ?lt) (interval_tree.tmax ?rt)) ?rt)>
Found termination order: "length <*mlex*> {}"
Add Hoare triple IntervalTree_Impl.int_tree_insert_to_fun
<int_tree ?t ?b> insert_impl ?v ?b <int_tree (Interval_Tree.insert ?v ?t)>
Add Hoare triple LinkedList.os_insert_sort_aux_correct
<emp> os_insert_sort_aux ?xs <os_list (insert_sort ?xs)>
Add Hoare triple LinkedList.insertion_sort_rule
<emp> os_insert_sort ?xs <%r. \<up> (r = sort ?xs)>\<^sub>t
Add Hoare triple IntervalTree_Impl.int_tree_del_min_to_fun
<int_tree ?t ?b *
 \<up>
  (?b ~=
   None)> int_tree_del_min
           ?b <%r. int_tree (snd (del_min ?t)) (snd r) *
                   \<up> (fst r = fst (del_min ?t))>\<^sub>t
Found termination order:
  "(%p. size_class.size (fst (snd (snd p)))) <*mlex*> {}"
Add Hoare triple IntervalTree_Impl.int_tree_del_elt_to_fun
<int_tree (interval_tree.Node ?lt ?v ?m ?rt)
  ?b> int_tree_del_elt
       ?b <int_tree
            (delete_elt_tree (interval_tree.Node ?lt ?v ?m ?rt))>\<^sub>t
Add Hoare triple Dijkstra_Impl.dstate_update_est_ind
<?a \<mapsto>\<^sub>a ?e * idx_pqueue_map ?M (length ?e) ?pq *
 \<up> (?m < length ?e) *
 \<up>
  (?k <= length
          ?e)> dstate_update_est ?G ?m ?k ?pq
                ?a <%r. dstate
                         (State
                           (list_update_set_impl (%i. i : keys_of ?M)
                             (%i. min (?e ! ?m + weight ?G ?m i) (?e ! i))
                             ?e ?k)
                           ?M)
                         (Dijkstra_State r ?pq)>\<^sub>t
Add Hoare triple Dijkstra_Impl.dstate_update_est_to_fun
<dstate (State ?e ?M) (Dijkstra_State ?a ?pq) *
 \<up>
  (?m < length
         ?e)> dstate_update_est ?G ?m (length ?e) ?pq
               ?a <%r. dstate
                        (State
                          (list_update_set (%i. i : keys_of ?M)
                            (%i. min (?e ! ?m + weight ?G ?m i) (?e ! i))
                            ?e)
                          ?M)
                        (Dijkstra_State r ?pq)>\<^sub>t
Add Hoare triple IntervalTree_Impl.int_tree_delete_to_fun
<int_tree ?t ?b> delete_impl ?x ?b <int_tree (delete ?x ?t)>\<^sub>t
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
LinkedList.merge_list.simps_1
WithTerm merge_list ?xs []
GetFact (merge_list ?xs [] = ?xs, LinkedList.merge_list.simps_1)
LinkedList.merge_list.simps_2
WithTerm merge_list [] (?v # ?va)
GetFact (merge_list [] (?v # ?va) = ?v # ?va, LinkedList.merge_list.simps_2)
LinkedList.merge_list.simps_3
WithTerm merge_list (?x # ?xs) (?y # ?ys)
GetFact (merge_list (?x # ?xs) (?y # ?ys) =
(if ?x <= ?y then ?x # merge_list ?xs (?y # ?ys)
 else ?y # merge_list (?x # ?xs) ?ys), LinkedList.merge_list.simps_3)
LinkedList.merge_list_correct
WithTerm set (merge_list ?xs ?ys)
GetFact (set (merge_list ?xs ?ys) = set ?xs Un set ?ys, LinkedList.merge_list_correct)
Add property rule for function LinkedList.merge_list
Add Hoare triple IntervalTree_Impl.search_impl_correct
<int_tree ?t ?b> search_impl ?x ?b
<%r. int_tree ?t ?b * \<up> (r = search ?t ?x)>
RBTree_Impl.rbt_node.sel_1
WithTerm rbt_node.lsub (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.lsub (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x1.0, RBTree_Impl.rbt_node.sel_1)
RBTree_Impl.rbt_node.sel_2
WithTerm rbt_node.cl (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.cl (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x2.0, RBTree_Impl.rbt_node.sel_2)
RBTree_Impl.rbt_node.sel_3
WithTerm rbt_node.key (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.key (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x3.0, RBTree_Impl.rbt_node.sel_3)
RBTree_Impl.rbt_node.sel_4
WithTerm rbt_node.val (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.val (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x4.0, RBTree_Impl.rbt_node.sel_4)
RBTree_Impl.rbt_node.sel_5
WithTerm rbt_node.rsub (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.rsub (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x5.0, RBTree_Impl.rbt_node.sel_5)
Add forward entailment IntervalTree_Impl.int_tree_set_def@forward
int_tree_set ?S ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>At.
   int_tree t ?p * \<up> (is_interval_tree t) * \<up> (?S = tree_set t)
Add backward entailment IntervalTree_Impl.int_tree_set_def@backward
\<exists>\<^sub>At.
   int_tree t ?p * \<up> (is_interval_tree t) *
   \<up> (?S = tree_set t) \<Longrightarrow>\<^sub>A
int_tree_set ?S ?p
Add Hoare triple IntervalTree_Impl.int_tree_empty_rule
<emp> int_tree_empty <int_tree_set {}>
Add Hoare triple IntervalTree_Impl.int_tree_insert_rule
<int_tree_set ?S ?b * \<up> (is_interval (idx_interval.int ?x))>
insert_impl ?x ?b <int_tree_set (?S Un {?x})>
Add Hoare triple IntervalTree_Impl.int_tree_delete_rule
<int_tree_set ?S ?b *
 \<up>
  (is_interval
    (idx_interval.int
      ?x))> delete_impl ?x ?b <int_tree_set (?S - {?x})>\<^sub>t
Add Hoare triple IntervalTree_Impl.int_tree_search_rule
<int_tree_set ?S ?b * \<up> (is_interval ?x)> search_impl ?x ?b
<%r. int_tree_set ?S ?b * \<up> (r = has_overlap ?S ?x)>
Add Hoare triple LinkedList.merge_os_list_to_fun
<os_list ?xs ?p * os_list ?ys ?q> merge_os_list ?p ?q
<os_list (merge_list ?xs ?ys)>
Delete IntervalTree_Impl.int_tree_set_def@forward@ent
Delete IntervalTree_Impl.int_tree_set_def@forward@hoare_ent
Delete IntervalTree_Impl.int_tree_set_def@backward@entback
### theory "Draft.IntervalTree_Impl"
### 1.812s elapsed time, 7.163s cpu time, 0.643s GC time
Loading theory "Draft.Rect_Intersect_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Found termination order: "{}"
Add Hoare triple LinkedList.copy_os_list_rule
<os_list ?xs ?b> copy_os_list ?b <%r. os_list ?xs ?b * os_list ?xs r>
Add Hoare triple LinkedList.map_os_list_rule
<os_list ?xs ?b> map_os_list ?f ?b <os_list (map ?f ?xs)>
Found termination order: "{}"
Add Hoare triple LinkedList.filter_os_list_rule
<os_list ?xs ?b> filter_os_list ?f ?b <os_list (filter ?f ?xs)>\<^sub>t
Found termination order:
  "(%p. size_class.size (fst (snd (snd p)))) <*mlex*> {}"
Add Hoare triple Dijkstra_Impl.dstate_update_heap_ind
<?a \<mapsto>\<^sub>a ?e * idx_pqueue_map ?M (length ?e) ?pq *
 \<up> (?m < length ?e) *
 \<up>
  (?k <= length
          ?e)> dstate_update_heap ?G ?m ?k ?a
                ?pq <%r. dstate
                          (State ?e (map_update_all_impl ((!) ?e) ?M ?k))
                          (Dijkstra_State ?a r)>\<^sub>t
Add Hoare triple LinkedList.filter_os_list2_rule
<os_list ?xs ?b> filter_os_list2 ?f ?b
<%r. os_list ?xs ?b * os_list (filter ?f ?xs) r>
List.fold_simps_1
WithTerm fold ?f [] ?s
GetFact (fold ?f [] ?s = ?s, List.fold_simps_1)
List.fold_simps_2
WithTerm fold ?f (?x # ?xs) ?s
GetFact (fold ?f (?x # ?xs) ?s = fold ?f ?xs (?f ?x ?s), List.fold_simps_2)
Add Hoare triple Dijkstra_Impl.dstate_update_heap_to_fun
<dstate (State ?e ?M) (Dijkstra_State ?a ?pq) *
 \<up> (ALL i:keys_of ?M. i < length ?e) *
 \<up>
  (?m < length
         ?e)> dstate_update_heap ?G ?m (length ?e) ?a
               ?pq <%r. dstate (State ?e (map_update_all ((!) ?e) ?M))
                         (Dijkstra_State ?a r)>\<^sub>t
Add Hoare triple LinkedList.fold_os_list_rule
<os_list ?xs ?b> fold_os_list ?f ?b ?x
<%r. os_list ?xs ?b * \<up> (r = fold ?f ?xs ?x)>
### theory "Draft.LinkedList"
### 1.618s elapsed time, 6.394s cpu time, 0.553s GC time
Loading theory "Draft.Union_Find_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Found termination order: "{}"
Add Hoare triple Dijkstra_Impl.dijkstra_extract_min_rule
<dstate (State ?e ?M) (Dijkstra_State ?a ?pq) *
 \<up>
  (?M ~=
   empty_map)> dijkstra_extract_min
                (Dijkstra_State ?a
                  ?pq) <%r. case r of
                            (m, r) =>
                              dstate (State ?e (delete_map m ?M)) r *
                              \<up> (m < length ?e) *
                              \<up> (is_heap_min m ?M)>\<^sub>t
Delete Dijkstra_Impl.dstate.simps@forward@ent
Delete Dijkstra_Impl.dstate.simps@forward@hoare_ent
Delete Dijkstra_Impl.dstate.simps@backward@entback
Found termination order: "{}"
Add Hoare triple Dijkstra_Impl.dijkstra_step_impl_to_fun
<dstate ?S (Dijkstra_State ?a ?pq) * \<up> (Dijkstra.inv ?G ?S) *
 \<up>
  (heap ?S ~=
   empty_map)> dijkstra_step_impl ?G
                (Dijkstra_State ?a
                  ?pq) <%r. \<exists>\<^sub>AS'.
                               dstate S' r *
                               \<up> (is_dijkstra_step ?G ?S S')>\<^sub>t
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Add Hoare triple Dijkstra_Impl.dijkstra_step_impl_correct
<dstate ?S ?p * \<up> (Dijkstra.inv ?G ?S) *
 \<up>
  (heap ?S ~=
   empty_map)> dijkstra_step_impl ?G
                ?p <%r. \<exists>\<^sub>AS'.
                           dstate S' r * \<up> (Dijkstra.inv ?G S') *
                           \<up>
                            (card (unknown_set S') =
                             card (unknown_set ?S) - 1)>\<^sub>t
Add forward entailment RBTree_Impl.btree.simps_1@forward
btree Leaf ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add backward entailment RBTree_Impl.btree.simps_1@backward
\<up> (?p = None) \<Longrightarrow>\<^sub>A btree Leaf ?p
Add forward entailment RBTree_Impl.btree.simps_2@forward
btree (rbt.Node ?lt ?c ?k ?v ?rt) (Some ?p) \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Alp rp.
   ?p \<mapsto>\<^sub>r rbt_node.Node lp ?c ?k ?v rp * btree ?lt lp *
   btree ?rt rp
Add backward entailment RBTree_Impl.btree.simps_2@backward
\<exists>\<^sub>Alp rp.
   ?p \<mapsto>\<^sub>r rbt_node.Node lp ?c ?k ?v rp * btree ?lt lp *
   btree ?rt rp \<Longrightarrow>\<^sub>A
btree (rbt.Node ?lt ?c ?k ?v ?rt) (Some ?p)
Add forward entailment RBTree_Impl.btree.simps_3@forward
btree (rbt.Node ?lt ?c ?k ?v ?rt) None \<Longrightarrow>\<^sub>A false
Add backward entailment RBTree_Impl.btree.simps_3@backward
false \<Longrightarrow>\<^sub>A btree (rbt.Node ?lt ?c ?k ?v ?rt) None
Add forward entailment RBTree_Impl.btree_Leaf
btree Leaf ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add forward entailment RBTree_Impl.btree_Node
btree (rbt.Node ?lt ?c ?k ?v ?rt) ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Alp rp.
   the ?p \<mapsto>\<^sub>r rbt_node.Node lp ?c ?k ?v rp * btree ?lt lp *
   btree ?rt rp *
   \<up> (?p ~= None)
Delete RBTree_Impl.btree.simps_1@forward@ent
Delete RBTree_Impl.btree.simps_1@forward@hoare_ent
Delete RBTree_Impl.btree.simps_1@backward@entback
Delete RBTree_Impl.btree.simps_2@forward@ent
Delete RBTree_Impl.btree.simps_2@forward@hoare_ent
Delete RBTree_Impl.btree.simps_2@backward@entback
Delete RBTree_Impl.btree.simps_3@forward@ent
Delete RBTree_Impl.btree.simps_3@forward@hoare_ent
Delete RBTree_Impl.btree.simps_3@backward@entback
Add Hoare triple RBTree_Impl.tree_empty_rule
<emp> tree_empty <btree Leaf>
Add Hoare triple RBTree_Impl.btree_constr_rule
<btree ?lt ?lp * btree ?rt ?rp> btree_constr ?lp ?c ?k ?v ?rp
<btree (rbt.Node ?lt ?c ?k ?v ?rt)>
Found termination order: "(%p. size_class.size (fst (snd p))) <*mlex*> {}"
Add Hoare triple RBTree_Impl.set_color_rule
<btree (rbt.Node ?a ?c ?x ?v ?b) ?p> set_color ?c' ?p
<%_. btree (rbt.Node ?a ?c' ?x ?v ?b) ?p>
Add Hoare triple Dijkstra_Impl.dijkstra_loop_correct
<dstate ?S ?p * \<up> (Dijkstra.inv ?G ?S) *
 \<up>
  (?n <= card
          (unknown_set
            ?S))> dijkstra_loop ?G ?n
                   ?p <%r. \<exists>\<^sub>AS'.
                              dstate S' r * \<up> (Dijkstra.inv ?G S') *
                              \<up>
                               (card (unknown_set S') =
                                card (unknown_set ?S) - ?n)>\<^sub>t
Add Hoare triple RBTree_Impl.get_color_rule
<btree ?t ?p> get_color ?p <%r. btree ?t ?p * \<up> (r = rbt.cl ?t)>
Add Hoare triple Dijkstra_Impl.dijkstra_correct
<\<up>
  (0 < Dijkstra.size
        ?G)> dijkstra
              ?G <%r. \<exists>\<^sub>AS.
                         dstate S r * \<up> (Dijkstra.inv ?G S) *
                         \<up> (unknown_set S = {}) *
                         \<up>
                          (ALL i:verts ?G.
                              has_dist ?G 0 i &
                              est S ! i = dist ?G 0 i)>\<^sub>t
### theory "Draft.Dijkstra_Impl"
### 1.617s elapsed time, 6.406s cpu time, 0.559s GC time
Add Hoare triple RBTree_Impl.paint_rule
<btree ?t ?p> RBTree_Impl.paint ?c ?p <%_. btree (RBTree.paint ?c ?t) ?p>
Add forward entailment Union_Find_Impl.is_uf_def@forward
is_uf ?n ?R ?u \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Al szl.
   snd ?u \<mapsto>\<^sub>a l * fst ?u \<mapsto>\<^sub>a szl *
   \<up> (ufa_invar l) *
   \<up> (ufa_\<alpha> l = ?R) *
   \<up> (length l = ?n) *
   \<up> (length szl = ?n)
Add backward entailment Union_Find_Impl.is_uf_def@backward
\<exists>\<^sub>Al szl.
   snd ?u \<mapsto>\<^sub>a l * fst ?u \<mapsto>\<^sub>a szl *
   \<up> (ufa_invar l) *
   \<up> (ufa_\<alpha> l = ?R) *
   \<up> (length l = ?n) *
   \<up> (length szl = ?n) \<Longrightarrow>\<^sub>A
is_uf ?n ?R ?u
Add Hoare triple Union_Find_Impl.uf_init_rule
<emp> uf_init ?n <is_uf ?n (uf_init_rel ?n)>
Add Hoare triple RBTree_Impl.btree_rotate_l_rule
<btree (rbt.Node ?a ?c1.0 ?x ?v (rbt.Node ?b ?c2.0 ?y ?w ?c)) ?p>
btree_rotate_l ?p
<btree (rbt.Node (rbt.Node ?a ?c1.0 ?x ?v ?b) ?c2.0 ?y ?w ?c)>
Add Hoare triple Union_Find_Impl.uf_rep_of_rule
<?p \<mapsto>\<^sub>a ?l * \<up> (?i < length ?l) * \<up> (ufa_invar ?l)>
uf_rep_of ?p ?i <%r. ?p \<mapsto>\<^sub>a ?l * \<up> (r = rep_of ?l ?i)>
Add Hoare triple Union_Find_Impl.uf_compress_rule
<?p \<mapsto>\<^sub>a ?l * \<up> (?i < length ?l) * \<up> (ufa_invar ?l)>
uf_compress ?i (rep_of ?l ?i) ?p
<%_. \<exists>\<^sub>Al'.
        ?p \<mapsto>\<^sub>a l' *
        \<up>
         (ufa_invar l' &
          length l' = length ?l &
          (ALL i<length ?l. rep_of l' i = rep_of ?l i))>
Add Hoare triple RBTree_Impl.btree_rotate_r_rule
<btree (rbt.Node (rbt.Node ?a ?c1.0 ?x ?v ?b) ?c2.0 ?y ?w ?c) ?p>
btree_rotate_r ?p
<btree (rbt.Node ?a ?c1.0 ?x ?v (rbt.Node ?b ?c2.0 ?y ?w ?c))>
Add Hoare triple Union_Find_Impl.uf_rep_of_c_rule
<?p \<mapsto>\<^sub>a ?l * \<up> (?i < length ?l) * \<up> (ufa_invar ?l)>
uf_rep_of_c ?p ?i
<%r. \<exists>\<^sub>Al'.
        ?p \<mapsto>\<^sub>a l' *
        \<up>
         (r = rep_of ?l ?i &
          ufa_invar l' &
          length l' = length ?l &
          (ALL i<length ?l. rep_of l' i = rep_of ?l i))>
Add Hoare triple Union_Find_Impl.uf_cmp_rule
<is_uf ?n ?R ?u> uf_cmp ?u ?i ?j
<%r. is_uf ?n ?R ?u * \<up> (r = ((?i, ?j) : ?R))>
Add Hoare triple RBTree_Impl.balanceR_to_fun
<btree (rbt.Node ?l B ?k ?v ?r) ?p> btree_balanceR ?p
<btree (balanceR ?l ?k ?v ?r)>
Add Hoare triple Union_Find_Impl.uf_union_rule
<is_uf ?n ?R ?u * \<up> (?j < ?n) * \<up> (?i < ?n)> uf_union ?u ?i ?j
<is_uf ?n (per_union ?R ?i ?j)>
Delete Union_Find_Impl.is_uf_def@forward@ent
Delete Union_Find_Impl.is_uf_def@forward@hoare_ent
Delete Union_Find_Impl.is_uf_def@backward@entback
### theory "Draft.Union_Find_Impl"
### 0.393s elapsed time, 1.531s cpu time, 0.164s GC time
Loading theory "Draft.Connectivity_Impl" (required by "Draft.Sep_ExamplesMoreTemplates" via "Draft.Sep_Examples")
Add Hoare triple RBTree_Impl.balance_to_fun
<btree (rbt.Node ?l B ?k ?v ?r) ?p> btree_balance ?p
<btree (balance ?l ?k ?v ?r)>
Add Hoare triple RBTree_Impl.rbt_ins_to_fun
<btree ?t ?p> rbt_ins ?k ?v ?p <btree (ins ?k ?v ?t)>
Add Hoare triple RBTree_Impl.rbt_insert_to_fun
<btree ?t ?p> RBTree_Impl.rbt_insert ?k ?v ?p
<btree (RBTree.rbt_insert ?k ?v ?t)>
Found termination order: "{}"
Rect_Intersect.all_ops_def
WithTerm all_ops ?rects
GetFact (all_ops ?rects = sort (ins_ops ?rects @ del_ops ?rects), Rect_Intersect.all_ops_def)
Add Hoare triple RBTree_Impl.btree_search_correct
<btree ?t ?b * \<up> (rbt_sorted ?t)> RBTree_Impl.rbt_search ?x ?b
<%r. btree ?t ?b * \<up> (r = RBTree.rbt_search ?t ?x)>
Add Hoare triple Rect_Intersect_Impl.rect_inter_init_rule
<emp> rect_inter_init ?rects <%p. p \<mapsto>\<^sub>a all_ops ?rects>
Delete Rect_Intersect.all_ops_def
Apply def ?ops = all_ops ?rects
Rect_Intersect_Impl.op_int_is_interval
WithProperty is_rect_list ?rects
WithWellForm ?k < length (all_ops ?rects)
WithTerm op_int (all_ops ?rects ! ?k)
GetFact (is_interval (op_int (all_ops ?rects ! ?k)), Rect_Intersect_Impl.op_int_is_interval)
Add Hoare triple Rect_Intersect_Impl.rect_inter_next_rule
<int_tree_set ?S ?b * ?a \<mapsto>\<^sub>a all_ops ?rects *
 \<up> (?k < length (all_ops ?rects)) *
 \<up>
  (is_rect_list
    ?rects)> rect_inter_next ?a ?b
              ?k <%r. ?a \<mapsto>\<^sub>a all_ops ?rects *
                      int_tree_set (apply_ops_k_next ?rects ?S ?k)
                       r>\<^sub>t
Add Hoare triple RBTree_Impl.balL_to_fun
<btree (rbt.Node ?l R ?k ?v ?r) ?p> btree_balL ?p <btree (balL ?l ?k ?v ?r)>
Add Hoare triple Rect_Intersect_Impl.rect_inter_to_fun_ind
<int_tree_set ?S ?b * ?a \<mapsto>\<^sub>a all_ops ?rects *
 \<up> (?k < length (all_ops ?rects)) *
 \<up>
  (is_rect_list
    ?rects)> rect_inter_impl ?a ?b
              ?k <%r. ?a \<mapsto>\<^sub>a all_ops ?rects *
                      \<up> (r = rect_inter ?rects ?S ?k)>\<^sub>t
### theory "Draft.Rect_Intersect_Impl"
### 0.735s elapsed time, 2.677s cpu time, 0.164s GC time
Add Hoare triple RBTree_Impl.balR_to_fun
<btree (rbt.Node ?l R ?k ?v ?r) ?p> btree_balR ?p <btree (balR ?l ?k ?v ?r)>
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Add Hoare triple Connectivity_Impl.connected_rel_imp_to_fun
<\<up> (?k <= length ?es) * \<up> (is_valid_graph ?n (set ?es))>
connected_rel_imp ?n ?es ?k <is_uf ?n (connected_rel_ind ?n ?es ?k)>
Add Hoare triple Connectivity_Impl.connected_rel_imp_correct
<\<up> (is_valid_graph ?n (set ?es))> connected_rel_imp ?n ?es (length ?es)
<is_uf ?n (connected_rel ?n (set ?es))>
Add Hoare triple Connectivity_Impl.uf_cmp_correct
<is_uf ?n (connected_rel ?n ?S) ?p> uf_cmp ?p ?i ?j
<%r. is_uf ?n (connected_rel ?n ?S) ?p * \<up> (r = has_path ?n ?S ?i ?j)>
### theory "Draft.Connectivity_Impl"
### 0.299s elapsed time, 0.850s cpu time, 0.067s GC time
Add Hoare triple RBTree_Impl.combine_to_fun
<btree ?lt ?lp * btree ?rt ?rp> btree_combine ?lp ?rp
<btree (combine ?lt ?rt)>
Add Hoare triple RBTree_Impl.rbt_del_to_fun
<btree ?t ?p> rbt_del ?x ?p <btree (del ?x ?t)>\<^sub>t
Add Hoare triple RBTree_Impl.rbt_delete_to_fun
<btree ?t ?p> rbt_delete ?k ?p <btree (delete ?k ?t)>\<^sub>t
Add forward entailment RBTree_Impl.rbt_map_assn_def@forward
rbt_map_assn ?M ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>At.
   btree t ?p * \<up> (is_rbt t) * \<up> (rbt_sorted t) *
   \<up> (?M = rbt_map t)
Add backward entailment RBTree_Impl.rbt_map_assn_def@backward
\<exists>\<^sub>At.
   btree t ?p * \<up> (is_rbt t) * \<up> (rbt_sorted t) *
   \<up> (?M = rbt_map t) \<Longrightarrow>\<^sub>A
rbt_map_assn ?M ?p
Add Hoare triple RBTree_Impl.rbt_empty_rule
<emp> tree_empty <rbt_map_assn empty_map>
Add Hoare triple RBTree_Impl.rbt_insert_rule
<rbt_map_assn ?M ?b> RBTree_Impl.rbt_insert ?k ?v ?b
<rbt_map_assn ( ?M { ?k \<rightarrow> ?v })>
Add Hoare triple RBTree_Impl.rbt_search
<rbt_map_assn ?M ?b> RBTree_Impl.rbt_search ?x ?b
<%r. rbt_map_assn ?M ?b * \<up> (r = ?M\<langle>?x\<rangle>)>
Add Hoare triple RBTree_Impl.rbt_delete_rule
<rbt_map_assn ?M
  ?b> rbt_delete ?k ?b <rbt_map_assn (delete_map ?k ?M)>\<^sub>t
### theory "Draft.RBTree_Impl"
### 2.307s elapsed time, 8.442s cpu time, 0.691s GC time
Loading theory "Draft.Sep_Examples" (required by "Draft.Sep_ExamplesMoreTemplates")
### theory "Draft.Sep_Examples"
### 0.952s elapsed time, 1.010s cpu time, 0.072s GC time
Loading theory "Draft.Sep_ExamplesMoreTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.Sep_ExamplesMoreTemplates"
### 0.817s elapsed time, 1.041s cpu time, 0.099s GC time
val it = (): unit
