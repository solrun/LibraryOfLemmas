Loading theory "Auto2_HOL.HOL_Base" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms" via "Auto2_HOL.Logic_Thms" via "Auto2_HOL.Auto2_HOL")
Loading theory "HOL-Library.Cancellation" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms" via "Auto2_HOL.Set_Thms" via "HOL-Library.Multiset")
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Library.Monad_Syntax")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "Auto2_HOL.HOL_Base"
### 0.068s elapsed time, 0.298s cpu time, 0.000s GC time
Loading theory "Auto2_HOL.Auto2_HOL" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms" via "Auto2_HOL.Logic_Thms")
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.132s elapsed time, 0.537s cpu time, 0.037s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad")
### theory "HOL-Library.Function_Algebras"
### 0.158s elapsed time, 0.635s cpu time, 0.037s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
### theory "HOL-Library.Monad_Syntax"
### 0.046s elapsed time, 0.182s cpu time, 0.000s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Imperative_HOL.Heap" via "HOL-Library.Countable")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
signature BASIC_UTIL =
  sig
    val apply_to_lhs: conv -> thm -> thm
    val apply_to_rhs: conv -> thm -> thm
    val apply_to_thm: conv -> thm -> thm
    val assert: bool -> string -> unit
    val dest_arg: term -> term
    val dest_arg1: term -> term
    val filter_split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val fo_init: Type.tyenv * Envir.tenv
    val lookup_inst: Type.tyenv * Envir.tenv -> string -> term
    val lookup_instn: Type.tyenv * Envir.tenv -> string * int -> term
    val meta_sym: thm -> thm
    val propT: typ
    val the_pair: 'a list -> 'a * 'a
    val the_triple: 'a list -> 'a * 'a * 'a
    val trace_fullthm: Proof.context -> string -> thm -> unit
    val trace_fullthm_global: string -> thm -> unit
    val trace_t: Proof.context -> string -> term -> unit
    val trace_thm: Proof.context -> string -> thm -> unit
    val trace_thm_global: string -> thm -> unit
    val trace_tlist: Proof.context -> string -> term list -> unit
  end
signature UTIL =
  sig
    val all_pairs: 'a list * 'b list -> ('a * 'b) list
    val all_permutes: 'a list -> 'a list list
    val apply_to_lhs: conv -> thm -> thm
    val apply_to_rhs: conv -> thm -> thm
    val apply_to_thm: conv -> thm -> thm
    val arg_backn_conv: int -> conv -> conv
    val argn_conv: int -> conv -> conv
    val assert: bool -> string -> unit
    val assume_meta_eq: theory -> term * term -> thm
    val assume_thm: Proof.context -> term -> thm
    val comb_equiv: cterm * thm list -> thm
    val concl_conv: conv -> conv
    val concl_conv_n: int -> conv -> conv
    val cterm_pat_setup: theory -> theory
    val declare_free_term: term -> Proof.context -> Proof.context
    val defined_instn: Type.tyenv * Envir.tenv -> string * int -> bool
    val dest_arg: term -> term
    val dest_arg1: term -> term
    val dest_argn: int -> term -> term
    val dest_args: term -> term list
    val dest_binop: term -> term * (term * term)
    val dest_binop_args: term -> term * term
    val dest_binop_cargs: cterm -> cterm * cterm
    val dest_binop_head: term -> term
    val dest_cargs: cterm -> cterm list
    val eq_cong_th: int -> term -> term -> Proof.context -> thm
    val eq_env:
       (Type.tyenv * Envir.tenv) * (Type.tyenv * Envir.tenv) -> bool
    val exn_trace: (unit -> 'a) -> 'a
    val filter_split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val first_order_match_list:
       theory ->
         (term * term) list ->
           Type.tyenv * Envir.tenv -> Type.tyenv * Envir.tenv
    val fo_init: Type.tyenv * Envir.tenv
    val forall_elim_sch: thm -> thm
    val get_head_name: term -> string
    val has_subterm: term list -> term -> bool
    val has_vars: term -> bool
    val is_abs: term -> bool
    val is_head: term -> term -> bool
    val is_implies: term -> bool
    val is_just_internal: string -> bool
    val is_meta_eq: term -> bool
    val is_pattern: term -> bool
    val is_pattern_list: term list -> bool
    val is_prefix_str: string -> string -> bool
    val is_subseq: ('a * 'a -> bool) -> 'a list * 'a list -> bool
    val is_subterm: term -> term -> bool
    val lambda_abstract: term -> term -> term
    val lhs_of: thm -> term
    val list_meta_horn: term list * (term list * term) -> term
    val lookup_inst: Type.tyenv * Envir.tenv -> string -> term
    val lookup_instn: Type.tyenv * Envir.tenv -> string * int -> term
    val lookup_tyinst: Type.tyenv * Envir.tenv -> string -> typ
    val max: ('a * 'a -> order) -> 'a list -> 'a
    val max_partial: ('a -> 'a -> bool) -> 'a list -> 'a list
    val meta_sym: thm -> thm
    val name_of_thm: thm -> string
    val normalize_meta_all_imp: Proof.context -> conv
    val normalize_meta_horn: Proof.context -> conv
    val occurs_free: term -> term -> bool
    val occurs_frees: term list -> term -> bool
    val pattern_rewr_conv: term -> (term * thm) list -> conv
    val print_term_detail: Proof.context -> term -> string
    val propT: typ
    val remove_dup_lists:
       ('a * 'a -> order) -> 'a list * 'a list -> 'a list * 'a list
    val rename_abs_term: term list -> term -> term
    val repeat_n_conv: int -> conv -> conv
    val reverse_eta_conv: Proof.context -> conv
    val rhs_of: thm -> term
    val send_all_to_hyps: thm -> thm
    val send_first_to_hyps: thm -> thm
    val skip_n_conv: int -> conv -> conv
    val string_of_bool: bool -> string
    val string_of_env: Proof.context -> Envir.tenv -> string
    val string_of_list: ('a -> string) -> 'a list -> string
    val string_of_list': ('a -> string) -> 'a list -> string
    val string_of_terms: Proof.context -> term list -> string
    val string_of_terms_global: theory -> term list -> string
    val string_of_tyenv: Proof.context -> Type.tyenv -> string
    val strip_meta_horn: term -> term list * (term list * term)
    val subsets: 'a list -> 'a list list
    val subst_term_norm: Type.tyenv * Envir.tenv -> term -> term
    val subst_thm: Proof.context -> Type.tyenv * Envir.tenv -> thm -> thm
    val subst_thm_atomic: (cterm * cterm) list -> thm -> thm
    val subst_thm_thy: theory -> Type.tyenv * Envir.tenv -> thm -> thm
    val swap_meta_imp_alls: Proof.context -> conv
    val term_pat_setup: theory -> theory
    val test_conv:
       Proof.context -> conv -> string -> string * string -> unit
    val the_pair: 'a list -> 'a * 'a
    val the_triple: 'a list -> 'a * 'a * 'a
    val timer: string * (unit -> 'a) -> 'a
    val to_internal_vars:
       Proof.context -> term list * term -> term list * term
    val trace_fullthm: Proof.context -> string -> thm -> unit
    val trace_fullthm_global: string -> thm -> unit
    val trace_t: Proof.context -> string -> term -> unit
    val trace_thm: Proof.context -> string -> thm -> unit
    val trace_thm_global: string -> thm -> unit
    val trace_tlist: Proof.context -> string -> term list -> unit
    val transitive_list: thm list -> thm
    val type_pat_setup: theory -> theory
    val update_env:
       indexname * term ->
         Type.tyenv * Envir.tenv -> Type.tyenv * Envir.tenv
    val update_name_of_thm: thm -> string -> thm -> thm
  end
structure Util: UTIL
structure Basic_Util: BASIC_UTIL
val dest_arg1 = fn: term -> term
val trace_fullthm = fn: Proof.context -> string -> thm -> unit
val propT = "prop": typ
val apply_to_rhs = fn: conv -> thm -> thm
val lookup_instn = fn: Type.tyenv * Envir.tenv -> string * int -> term
val the_triple = fn: 'a list -> 'a * 'a * 'a
val filter_split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val trace_thm = fn: Proof.context -> string -> thm -> unit
val trace_tlist = fn: Proof.context -> string -> term list -> unit
val the_pair = fn: 'a list -> 'a * 'a
val apply_to_thm = fn: conv -> thm -> thm
val lookup_inst = fn: Type.tyenv * Envir.tenv -> string -> term
val apply_to_lhs = fn: conv -> thm -> thm
val trace_thm_global = fn: string -> thm -> unit
val trace_fullthm_global = fn: string -> thm -> unit
val assert = fn: bool -> string -> unit
val meta_sym = fn: thm -> thm
val trace_t = fn: Proof.context -> string -> term -> unit
val fo_init = ({}, {}): Type.tyenv * Envir.tenv
val dest_arg = fn: term -> term
signature BASIC_UTIL_BASE =
  sig
    val bFalse: term
    val bTrue: term
    val boolT: typ
    val cdest_eq: cterm -> cterm * cterm
    val dest_eq: term -> term * term
    val is_eq_term: term -> bool
    val mk_eq: term * term -> term
    val true_th: thm
  end
signature UTIL_BASE =
  sig
    val All_name: string
    val Ball_def_th: thm
    val Ball_name: string
    val Bex_def_th: thm
    val Bex_name: string
    val Conj_name: string
    val Disj_name: string
    val Ex_name: string
    val Imp_name: string
    val Mem_name: string
    val Not_name: string
    val Trueprop_name: string
    val all_trivial_th: thm
    val atomize_all_th: thm
    val atomize_conjL_th: thm
    val atomize_imp_th: thm
    val bFalse: term
    val bTrue: term
    val backward1_conv_th: thm
    val backward2_conv_th: thm
    val backward_conv_th: thm
    val boolT: typ
    val cConj: cterm
    val cDisj: cterm
    val cNot: cterm
    val cTrueprop: cterm
    val case_split_th: thm
    val cdest_eq: cterm -> cterm * cterm
    val conjI_th: thm
    val conj_assoc_th: thm
    val conj_commute_th: thm
    val conjunct1_th: thm
    val conjunct2_th: thm
    val contra_triv_th: thm
    val de_Morgan_conj_th: thm
    val de_Morgan_disj_th: thm
    val dest_eq: term -> term * term
    val disj_True1_th: thm
    val disj_True2_th: thm
    val disj_assoc_th: thm
    val disj_commute_th: thm
    val eq_True_inv_th: thm
    val eq_True_th: thm
    val exE_th': thm
    val ex_vardef_th: thm
    val iffD1_th: thm
    val iffD2_th: thm
    val iffD_th: thm
    val imp_conv_disj_th: thm
    val inv_back_th: thm
    val is_eq_term: term -> bool
    val is_if: term -> bool
    val mk_eq: term * term -> term
    val mk_setT: typ -> typ
    val nn_cancel_th: thm
    val nn_create_th: thm
    val not_all_th: thm
    val not_ex_th: thm
    val not_imp_th: thm
    val obj_sym_cv: conv
    val or_cancel1_th: thm
    val or_cancel2_th: thm
    val or_intro1_th: thm
    val or_intro2_th: thm
    val resolve_conv_th: thm
    val swap_all_disj_th: thm
    val swap_ex_conj_th: thm
    val sym_th: thm
    val to_contra_form_th: thm
    val to_contra_form_th': thm
    val to_meta_eq_cv: conv
    val to_obj_eq_cv: conv
    val to_obj_eq_iff: thm -> thm
    val true_th: thm
  end
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
structure UtilBase: UTIL_BASE
structure Basic_UtilBase: BASIC_UTIL_BASE
val true_th = "True": thm
val cdest_eq = fn: cterm -> cterm * cterm
val boolT = "bool": typ
val bTrue = Const ("HOL.True", "bool"): term
val is_eq_term = fn: term -> bool
val bFalse = Const ("HOL.False", "bool"): term
val mk_eq = fn: term * term -> term
val dest_eq = fn: term -> term * term
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
Found termination order: "size_list size <*mlex*> {}"
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.471s elapsed time, 1.865s cpu time, 0.142s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms" via "Auto2_HOL.Set_Thms")
signature BASIC_UTIL_LOGIC =
  sig
    val Not: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val apply_to_thm': conv -> thm -> thm
    val assume_eq: theory -> term * term -> thm
    val concl_of': thm -> term
    val conj: term
    val conj_left_th: thm -> thm
    val conj_right_th: thm -> thm
    val cprop_of': thm -> cterm
    val dest_Trueprop: term -> term
    val dest_imp: term -> term * term
    val dest_not: term -> term
    val disj: term
    val equiv_backward_th: thm -> thm
    val equiv_forward_th: thm -> thm
    val get_neg: term -> term
    val get_neg': term -> term
    val imp: term
    val inv_backward_th: thm -> thm
    val is_Trueprop: term -> bool
    val is_ball: term -> bool
    val is_bex: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_ex: term -> bool
    val is_imp: term -> bool
    val is_mem: term -> bool
    val is_neg: term -> bool
    val is_obj_all: term -> bool
    val is_true_th: thm -> bool
    val list_conj: term list -> term
    val list_disj: term list -> term
    val list_obj_imp: term list * term -> term
    val make_trueprop_eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_conj: term * term -> term
    val mk_disj: term * term -> term
    val mk_exists: term -> term -> term
    val mk_imp: term * term -> term
    val mk_mem: term * term -> term
    val mk_not: term -> term
    val mk_obj_all: term -> term -> term
    val obj_sym: thm -> thm
    val obj_sym_th: thm -> thm
    val pFalse: term
    val prop_of': thm -> term
    val rewr_obj_eq: thm -> conv
    val strip_conj: term -> term list
    val strip_disj: term -> term list
    val strip_obj_imp: term -> term list * term
    val to_meta_eq: thm -> thm
    val to_obj_eq: thm -> thm
    val to_obj_eq_iff_th: thm -> thm
    val to_obj_eq_th: thm -> thm
  end
signature UTIL_LOGIC =
  sig
    val Not: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val apply_to_thm': conv -> thm -> thm
    val assume_eq: theory -> term * term -> thm
    val bool_of_term: term -> bool
    val concl_of': thm -> term
    val conj: term
    val conj_left_th: thm -> thm
    val conj_right_th: thm -> thm
    val contra_by_tac:
       (Proof.context -> int -> tactic) -> Proof.context -> thm list -> thm
    val cprop_of': thm -> cterm
    val dest_Trueprop: term -> term
    val dest_imp: term -> term * term
    val dest_not: term -> term
    val disj: term
    val equiv_backward_th: thm -> thm
    val equiv_forward_th: thm -> thm
    val ex_elim: Proof.context -> term -> thm -> thm
    val force_abs_form: term -> term
    val get_all_subterms: term -> term list
    val get_all_subterms_skip_if: term -> term list
    val get_cneg: cterm -> cterm
    val get_neg: term -> term
    val get_neg': term -> term
    val imp: term
    val inv_backward_th: thm -> thm
    val is_Trueprop: term -> bool
    val is_ball: term -> bool
    val is_bex: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_ex: term -> bool
    val is_ex_form_gen: term -> bool
    val is_imp: term -> bool
    val is_mem: term -> bool
    val is_neg: term -> bool
    val is_obj_all: term -> bool
    val is_true_th: thm -> bool
    val list_conj: term list -> term
    val list_disj: term list -> term
    val list_obj_horn: term list * (term list * term) -> term
    val list_obj_imp: term list * term -> term
    val list_subterms: term -> term list
    val make_neg_eq: thm -> thm
    val make_trueprop_eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_conj: term * term -> term
    val mk_conjs_th: thm list -> thm
    val mk_disj: term * term -> term
    val mk_exists: term -> term -> term
    val mk_imp: term * term -> term
    val mk_mem: term * term -> term
    val mk_not: term -> term
    val mk_obj_all: term -> term -> term
    val normalize_exists: Proof.context -> conv
    val obj_sym: thm -> thm
    val obj_sym_th: thm -> thm
    val pFalse: term
    val prop_of': thm -> term
    val prove_by_tac:
       (Proof.context -> int -> tactic) ->
         Proof.context -> thm list -> term -> thm
    val rewr_obj_eq: thm -> conv
    val rewrite_from_contra_form: conv
    val rewrite_to_contra_form: conv
    val split_conj_gen_th: thm -> thm list
    val split_conj_th: thm -> thm list
    val split_not_disj_th: thm -> thm list
    val strip_conj: term -> term list
    val strip_disj: term -> term list
    val strip_exists: term -> term list * term
    val strip_horn': thm -> term list * term
    val strip_obj_horn: term -> term list * (term list * term)
    val strip_obj_imp: term -> term list * term
    val term_of_bool: bool -> term
    val to_meta_conv: Proof.context -> conv
    val to_meta_eq: thm -> thm
    val to_obj_conv: Proof.context -> conv
    val to_obj_conv_on_horn: Proof.context -> conv
    val to_obj_eq: thm -> thm
    val to_obj_eq_iff_th: thm -> thm
    val to_obj_eq_th: thm -> thm
  end
structure UtilLogic: UTIL_LOGIC
structure Basic_UtilLogic: BASIC_UTIL_LOGIC
val mk_obj_all = fn: term -> term -> term
val dest_not = fn: term -> term
val mk_mem = fn: term * term -> term
val apply_to_thm' = fn: conv -> thm -> thm
val mk_not = fn: term -> term
val is_true_th = fn: thm -> bool
val is_ex = fn: term -> bool
val list_conj = fn: term list -> term
val prop_of' = fn: thm -> term
val inv_backward_th = fn: thm -> thm
val assume_eq = fn: theory -> term * term -> thm
val equiv_forward_th = fn: thm -> thm
val dest_imp = fn: term -> term * term
val concl_of' = fn: thm -> term
val mk_imp = fn: term * term -> term
val strip_disj = fn: term -> term list
val pFalse =
   Const ("HOL.Trueprop", "bool => prop") $ Const ("HOL.False", "bool"):
   term
val cprop_of' = fn: thm -> cterm
val Trueprop = Const ("HOL.Trueprop", "bool => prop"): term
val strip_conj = fn: term -> term list
val mk_conj = fn: term * term -> term
val mk_Trueprop = fn: term -> term
val rewr_obj_eq = fn: thm -> conv
val disj = Const ("HOL.disj", "bool => bool => bool"): term
val strip_obj_imp = fn: term -> term list * term
val to_obj_eq = fn: thm -> thm
val Trueprop_conv = fn: conv -> conv
val imp = Const ("HOL.implies", "bool => bool => bool"): term
val is_neg = fn: term -> bool
val dest_Trueprop = fn: term -> term
val make_trueprop_eq = fn: thm -> thm
val is_bex = fn: term -> bool
val conj_left_th = fn: thm -> thm
val is_ball = fn: term -> bool
val is_disj = fn: term -> bool
val obj_sym_th = fn: thm -> thm
val is_obj_all = fn: term -> bool
val list_obj_imp = fn: term list * term -> term
val to_obj_eq_iff_th = fn: thm -> thm
val equiv_backward_th = fn: thm -> thm
val is_mem = fn: term -> bool
val Not = Const ("HOL.Not", "bool => bool"): term
val to_meta_eq = fn: thm -> thm
val get_neg = fn: term -> term
val conj = Const ("HOL.conj", "bool => bool => bool"): term
val to_obj_eq_th = fn: thm -> thm
val mk_exists = fn: term -> term -> term
val conj_right_th = fn: thm -> thm
val is_imp = fn: term -> bool
val obj_sym = fn: thm -> thm
val list_disj = fn: term list -> term
val mk_disj = fn: term * term -> term
val is_conj = fn: term -> bool
val is_Trueprop = fn: term -> bool
val get_neg' = fn: term -> term
### theory "HOL-Library.Nat_Bijection"
### 0.336s elapsed time, 1.316s cpu time, 0.105s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.ExtrEqs")
signature BOXID =
  sig
    val add_incr_id: box_id -> box_id
    val add_prim_id: box_id -> Proof.context -> int * Proof.context
    val add_resolved: box_id -> Proof.context -> Proof.context
    type box_id
    type box_lattice
    val get_all_merges: Proof.context -> box_id list list -> box_id list
    val get_all_merges_info:
       Proof.context -> (box_id * 'a) list list -> (box_id * 'a list) list
    val get_ancestors_prim: Proof.context -> box_id -> int list
    val get_parent_at_i: Proof.context -> box_id -> int -> box_id
    val get_parent_prim: Proof.context -> int -> box_id
    val has_incr_id: box_id -> bool
    val home_id: int
    val id_is_eq_ancestor:
       Proof.context -> box_id * 'a -> box_id * 'a -> bool
    val info_eq_better:
       Proof.context -> box_id * thm -> box_id * thm -> bool
    val is_box_resolved: Proof.context -> box_id -> bool
    val is_box_unresolved: Proof.context -> box_id -> bool
    val is_eq_ancestor: Proof.context -> box_id -> box_id -> bool
    val is_eq_descendent: Proof.context -> box_id -> box_id -> bool
    val merge_box_with_info:
       Proof.context -> box_id -> (box_id * 'a) list -> (box_id * 'a) list
    val merge_boxes: Proof.context -> box_id * box_id -> box_id
    val merge_eq_infos:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val reduce_box_id: Proof.context -> int list -> box_id
    val replace_incr_id: box_id -> box_id
    val string_of_box_id: box_id -> string
  end
type box_id = ?.BoxID.box_id
type id_inst = box_id * (Type.tyenv * Envir.tenv)
type id_inst_th = id_inst * thm
type id_inst_ths = id_inst * thm list
structure BoxID: BOXID
structure Boxidtab: TABLE
signature CONSTS =
  sig
    val add_const_data: string * (term -> bool) -> theory -> theory
    val detect_const: theory -> term -> string option
    val detect_const_ctxt: Proof.context -> term -> string option
    val is_const: theory -> term -> bool
    val is_const_ctxt: Proof.context -> term -> bool
    val neq_const: theory -> term * term -> bool
    val neq_const_ctxt: Proof.context -> term * term -> bool
  end
structure Consts: CONSTS
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.459s elapsed time, 1.798s cpu time, 0.178s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
signature PROPERTY =
  sig
    val add_property_field_const: term -> theory -> theory
    val add_property_update: thm -> theory -> theory
    val can_add_property_update: thm -> theory -> bool
    val get_property_arg: term -> term
    val get_property_arg_th: thm -> cterm
    val get_property_name: term -> string
    val get_property_names: term list -> string list
    val instantiate_property_update:
       Proof.context -> term -> thm -> thm option
    val is_property: term -> bool
    val is_property_field: theory -> term -> bool
    val is_property_prem: theory -> term -> bool
    val lookup_property_update: theory -> string -> thm list
    val lookup_property_update_fun: theory -> string -> thm list
    val strip_property_field: theory -> term -> term list
  end
structure Property: PROPERTY
val add_property_field_const = fn: term -> theory -> theory
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
signature WELLFORM =
  sig
    val is_subterm_wellform_data:
       theory -> term -> term list -> (term * term) option
    val is_subterm_wellform_data':
       theory -> term -> term -> (term * term) option
    val lookup_wellform_data: theory -> term -> term list
    val lookup_wellform_pattern:
       theory -> term * term -> (term * term) option
    val register_wellform_data: string * string list -> theory -> theory
  end
structure WellForm: WELLFORM
val register_wellform_data = fn: string * string list -> theory -> theory
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
infix 1 then_wfconv
infix 0 else_wfconv
datatype wfterm = WfComb of cterm * wfterm list * thm list | WfTerm of cterm
type wfconv = wfterm -> wfterm * thm
signature WFTERM =
  sig
    val all_conv: wfconv
    val arg1_conv: wfconv -> wfconv
    val arg_conv: wfconv -> wfconv
    val argn_conv: int -> wfconv -> wfconv
    val binop_conv: wfconv -> wfconv
    val conv_of: conv -> wfconv
    val cterm_of: wfterm -> cterm
    val cterm_to_wfterm_assume: term list -> cterm -> wfterm
    val cterm_to_wfterm_on_ths: thm list -> term list -> cterm -> wfterm
    val else_wfconv: wfconv * wfconv -> wfconv
    val every_conv: wfconv list -> wfconv
    val find_target_on_ths: thm list -> term -> thm
    val first_conv: wfconv list -> wfconv
    val no_conv: wfconv
    val repeat_conv: wfconv -> wfconv
    val rewr_obj_eq: term list -> thm -> wfconv
    val rewrite_on_eqs: term list -> (wfterm * thm) list -> wfconv
    val string_of_wfterm: Proof.context -> wfterm -> string
    val strip_comb: wfterm -> cterm * wfterm list
    val term_of: wfterm -> term
    val test_wfconv:
       Proof.context ->
         term list -> wfconv -> string -> string * string -> unit
    val then_wfconv: wfconv * wfconv -> wfconv
    val theory_of_wft: wfterm -> theory
    val try_conv: wfconv -> wfconv
    val wellform_ths_of: wfterm -> thm list
  end
constructor WfComb: cterm * wfterm list * thm list -> wfterm
constructor WfTerm: cterm -> wfterm
structure WfTerm: WFTERM
val then_wfconv = fn: wfconv * wfconv -> wfconv
val else_wfconv = fn: wfconv * wfconv -> wfconv
### theory "HOL-Library.Set_Algebras"
### 0.226s elapsed time, 0.883s cpu time, 0.060s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
type rewrite_table =
   {all_equiv: (box_id * thm) list Termtab.table,
    contain: cterm list Termtab.table,
    equiv: (box_id * thm) list Termtab.table,
    reps: (box_id * thm) list Termtab.table,
    simp: (box_id * thm) list Termtab.table,
    subsimp: (box_id * thm) list Termtab.table,
    terms: (box_id list * cterm) Termtab.table}
signature REWRITE_TABLE =
  sig
    val add_contain: cterm -> term -> Proof.context -> Proof.context
    val add_equiv: box_id * thm -> Proof.context -> Proof.context
    val add_rewrite:
       box_id * thm -> Proof.context -> (box_id * thm) list * Proof.context
    val add_rewrite_raw: box_id -> thm -> Proof.context -> Proof.context
    val add_term:
       box_id * cterm ->
         Proof.context -> (box_id * thm) list * Proof.context
    val add_term_list:
       (box_id * cterm) list ->
         Proof.context -> (box_id * thm) list * Proof.context
    val add_term_raw: box_id * cterm -> Proof.context -> Proof.context
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val complete_table: Proof.context -> (box_id * thm) list * Proof.context
    val equiv_info:
       Proof.context -> box_id -> cterm * cterm -> (box_id * thm) list
    val equiv_info_t:
       Proof.context -> box_id -> term * term -> (box_id * thm) list
    val equiv_neighs: Proof.context -> term -> (box_id * thm) list
    val get_all_equiv: Proof.context -> term -> (box_id * thm) list
    val get_all_id_terms: Proof.context -> (box_id * cterm) list
    val get_all_terms: Proof.context -> cterm list
    val get_cached_subterm_rewrite: box_id -> Proof.context -> cterm -> thm
    val get_cached_subterm_rewrite_info:
       Proof.context -> term -> (box_id * thm) list
    val get_head_equiv: Proof.context -> cterm -> (box_id * thm) list
    val get_head_equiv_with_t:
       Proof.context -> box_id * cterm -> term -> (box_id * thm) list
    val get_head_rep: box_id -> Proof.context -> term -> thm option
    val get_head_rep_info: Proof.context -> term -> (box_id * thm) list
    val get_head_rep_with_id_th:
       Proof.context -> box_id * thm -> (box_id * thm) list
    val get_new_terms:
       Proof.context * Proof.context -> (box_id * cterm) list
    val get_reachable_terms: bool -> Proof.context -> term list -> term list
    val get_rewrite: box_id -> Proof.context -> cterm -> thm
    val get_rewrite_info: Proof.context -> cterm -> (box_id * thm) list
    val get_subterm_rewrite_info:
       Proof.context -> cterm -> (box_id * thm) list
    val head_simplify: box_id -> Proof.context -> cterm -> thm
    val immediate_contains: Proof.context -> term -> cterm list
    val in_table_raw: Proof.context -> term -> bool
    val in_table_raw_for_id: Proof.context -> box_id * term -> bool
    val in_table_raw_ids: Proof.context -> term -> box_id list
    val is_equiv: box_id -> Proof.context -> cterm * cterm -> bool
    val is_equiv_t: box_id -> Proof.context -> term * term -> bool
    val process_update_simp:
       (box_id * thm) list -> Proof.context -> Proof.context
    val remove_rep: box_id * thm -> Proof.context -> Proof.context
    val simp_val: box_id -> Proof.context -> cterm -> cterm
    val simp_val_t: box_id -> Proof.context -> term -> term
    val simplify: box_id -> Proof.context -> cterm -> thm
    val simplify_info: Proof.context -> cterm -> (box_id * thm) list
    val subequiv_info:
       Proof.context -> box_id -> cterm * cterm -> (box_id * thm) list
    val subterm_simplify: box_id -> Proof.context -> cterm -> thm
    val subterm_simplify_info: Proof.context -> cterm -> (box_id * thm) list
    val update_simp: box_id * thm -> Proof.context -> Proof.context
    val update_subsimp: box_id * thm -> Proof.context -> Proof.context
  end
val simp_ord = fn: thm * thm -> order
val eq_info = fn: (''a * thm) * (''a * thm) -> bool
val print_info = fn: Proof.context -> BoxID.box_id * thm -> string
val print_infos = fn: Proof.context -> (BoxID.box_id * thm) list -> string
val print_info' = fn: Proof.context -> BoxID.box_id * thm list -> string
val print_infos' = fn:
   Proof.context -> (BoxID.box_id * thm list) list -> string
structure RewriteTable: REWRITE_TABLE
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
signature PROPERTY_DATA =
  sig
    val add_property: box_id * thm -> Proof.context -> Proof.context
    val add_property_raw: box_id * thm -> Proof.context -> Proof.context
    val apply_property_update_on_term:
       Proof.context -> box_id -> term -> (box_id * thm) list
    val apply_property_update_rule:
       Proof.context -> box_id -> thm option -> (box_id * thm) list
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val convert_property:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val get_new_property: Proof.context -> (box_id * thm) list
    val get_property: Proof.context -> box_id * cterm -> (box_id * thm) list
    val get_property_for_term: Proof.context -> term -> (box_id * thm) list
    val get_property_t:
       Proof.context -> box_id * term -> (box_id * thm) list
    val process_rewrite_property:
       box_id * thm -> Proof.context -> Proof.context
    val process_update_property:
       (box_id * thm) list -> Proof.context -> Proof.context
  end
structure PropertyData: PROPERTY_DATA
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
signature MATCHER =
  sig
    val check_type: theory -> typ * typ -> id_inst -> id_inst option
    val check_type_term:
       theory -> term * term -> id_inst -> (id_inst * term) option
    val match:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_all_head:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_comb:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_head:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_list:
       Proof.context ->
         term list -> term list * cterm list -> id_inst -> id_inst_ths list
    val pre_match: Proof.context -> term * cterm -> bool
    val pre_match_all_head: Proof.context -> term * cterm -> bool
    val pre_match_comb: Proof.context -> term * cterm -> bool
    val pre_match_head: Proof.context -> term * cterm -> bool
    val pre_match_head': Proof.context -> term * cterm -> bool
    val pre_match_type: Proof.context -> typ * typ -> bool
    val rewrite_match:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val rewrite_match_head:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val rewrite_match_list:
       Proof.context ->
         (bool * (term * cterm)) list -> id_inst -> id_inst_ths list
    val rewrite_match_subset:
       Proof.context ->
         term list -> term list * cterm list -> id_inst -> id_inst_ths list
    val update_inst:
       term list -> indexname -> cterm -> id_inst -> id_inst_th list
  end
structure Matcher: MATCHER
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
datatype raw_item
= Fact of string * term list * thm | Handler of term list * term * thm
type box_item =
   {id: box_id,
    prop: thm, sc: int, tname: cterm list, ty_str: string, uid: int}
signature BOXITEM =
  sig
    val dest_handler_raw: raw_item -> term list * term * thm
    val eq_item: box_item * box_item -> bool
    val eq_ritem: raw_item * raw_item -> bool
    val get_thm_raw: raw_item -> thm
    val get_tname_raw: raw_item -> term list
    val instantiate: (cterm * cterm) list -> raw_item -> raw_item
    val is_fact_raw: raw_item -> bool
    val is_handler_raw: raw_item -> bool
    val item_replace_incr: box_item -> box_item
    val item_with_id: box_id -> box_item -> box_item
    val item_with_incr: box_item -> box_item
    val match_ty_str: string -> box_item -> bool
    val match_ty_str_raw: string -> raw_item -> bool
    val match_ty_strs: string list -> box_item -> bool
    val match_ty_strs_raw: string list -> raw_item -> bool
    val merged_id: Proof.context -> box_item list -> box_id
    val mk_box_item:
       Proof.context -> int * box_id * int * raw_item -> box_item
    val null_item: box_item
    val obtain_variant_frees:
       Proof.context * raw_item list -> Proof.context * (cterm * cterm) list
    val term_to_fact: term -> raw_item
    val var_to_fact: term -> raw_item
  end
val TY_NULL = "NULL": string
val TY_EQ = "EQ": string
val TY_VAR = "VAR": string
val TY_PROP = "PROP": string
val TY_TERM = "TERM": string
val TY_PROPERTY = "PROPERTY": string
constructor Fact: string * term list * thm -> raw_item
constructor Handler: term list * term * thm -> raw_item
type item_matcher =
   {match: term -> box_item -> Proof.context -> id_inst -> id_inst_th list,
    pre_match: term -> box_item -> Proof.context -> bool}
type item_output = Proof.context -> term list * thm -> string
type item_io_info =
   {output_fn: (item_output * serial) option,
    prop_matchers: (item_matcher * serial) list,
    shadow_fn:
    ((Proof.context -> box_id -> term list * cterm list -> bool) * serial)
    option
    ,
    term_fn: ((term list -> term list) * serial) option,
    typed_matchers: (item_matcher * serial) list}
datatype match_arg
=
     PropMatch of term
   | PropertyMatch of term
   | TypedMatch of string * term
   | TypedUniv of string
   | WellFormMatch of term * term
type prfstep_filter = Proof.context -> id_inst -> bool
signature ITEM_IO =
  sig
    val add_basic_item_io: theory -> theory
    val add_item_type:
       string * (term list -> term list) option * item_output option *
       (Proof.context -> box_id -> term list * cterm list -> bool) option
         -> theory -> theory
    val add_prop_matcher: string * item_matcher -> theory -> theory
    val add_typed_matcher: string * item_matcher -> theory -> theory
    val assert_valid_arg: match_arg -> unit
    val check_ty_str: string -> match_arg -> bool
    val eq_tname_typed_matcher: item_matcher
    val get_io_info: theory -> string -> item_io_info
    val get_prop_matchers: theory -> string -> item_matcher list
    val get_typed_matchers: theory -> string -> item_matcher list
    val is_ordinary_match: match_arg -> bool
    val is_side_match: match_arg -> bool
    val match_arg:
       Proof.context -> match_arg -> box_item -> id_inst -> id_inst_th list
    val no_rewr_terms: term list -> term list
    val null_eq_matcher: item_matcher
    val null_property_matcher: item_matcher
    val output_prop_fn: item_output
    val pat_of_match_arg: match_arg -> term
    val pre_match_arg: Proof.context -> match_arg -> box_item -> bool
    val prop_matcher: item_matcher
    val rewr_terms_of_item: Proof.context -> string * term list -> term list
    val string_of_item: Proof.context -> box_item -> string
    val string_of_item_info:
       Proof.context -> string * term list * thm -> string
    val string_of_raw_item: Proof.context -> raw_item -> string
    val subst_arg: Type.tyenv * Envir.tenv -> match_arg -> match_arg
    val term_prop_matcher: item_matcher
    val term_property_matcher: item_matcher
    val term_typed_matcher: item_matcher
    val trace_item: Proof.context -> string -> box_item -> unit
    val trace_items: Proof.context -> string -> box_item list -> unit
    val trace_ritem: Proof.context -> string -> raw_item -> unit
    val trace_ritems: Proof.context -> string -> raw_item list -> unit
  end
structure BoxItem: BOXITEM
constructor PropMatch: term -> match_arg
constructor PropertyMatch: term -> match_arg
constructor TypedMatch: string * term -> match_arg
constructor TypedUniv: string -> match_arg
constructor WellFormMatch: term * term -> match_arg
structure ItemIO: ITEM_IO
consts
  flat :: "'a list stream => 'a stream"
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
signature WELLFORM_DATA =
  sig
    val add_wellform_data_raw:
       term * (box_id * thm) -> Proof.context -> Proof.context
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val complete_wellform_data:
       box_item list -> Proof.context -> Proof.context
    val complete_wellform_data_for_terms:
       box_item list -> term list -> Proof.context -> Proof.context
    val convert_wellform:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val cterm_to_wfterm:
       Proof.context ->
         term list -> box_id * cterm -> (box_id * wfterm) list
    val find_fact:
       Proof.context ->
         box_item list -> box_id * cterm -> (box_id * thm) list
    val get_complete_wellform:
       Proof.context -> box_id * cterm -> (box_id * thm list) list
    val get_head_equiv:
       Proof.context ->
         term list -> box_id * cterm -> (box_id * (wfterm * thm)) list
    val get_new_wellform_data: Proof.context -> (term * (box_id * thm)) list
    val get_wellform: Proof.context -> box_id * cterm -> (box_id * thm) list
    val get_wellform_for_term:
       Proof.context -> term -> (cterm * (box_id * thm) list) list
    val get_wellform_infos_for_term:
       Proof.context -> term -> (box_id * thm) list
    val get_wellform_t:
       Proof.context -> box_id * term -> (box_id * thm) list
    val initialize_wellform_data: term -> Proof.context -> Proof.context
    val simplify:
       Proof.context ->
         term list ->
           cterm list -> box_id * wfterm -> (box_id * (wfterm * thm)) list
    val simplify_info:
       Proof.context -> term list -> cterm -> (box_id * (wfterm * thm)) list
    val term_to_wfterm:
       Proof.context -> term list -> box_id * term -> (box_id * wfterm) list
  end
structure WellformData: WELLFORM_DATA
signature AUTO2_DATA =
  sig
    val add_terms:
       box_item list ->
         (box_id * cterm) list -> Proof.context -> Proof.context
    val get_incr_type:
       box_item list -> box_item list -> Proof.context -> Proof.context
    val get_single_type: Proof.context -> Proof.context
    val relevant_terms_single: box_item -> term list
  end
structure Auto2Data: AUTO2_DATA
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
datatype raw_update
=
     AddBoxes of {id: box_id, init_assum: term, sc: int option}
   | AddItems of {id: box_id, raw_items: raw_item list, sc: int option}
   | ResolveBox of {id: box_id, th: thm}
   | ShadowItem of {id: box_id, item: box_item}
type update =
   {prfstep_name: string,
    raw_updt: raw_update, sc: int, source: box_item list}
signature UPDATE =
  sig
    val apply_exists_ritems: Proof.context -> thm -> raw_item list * thm
    val replace_id_of_update: raw_update -> raw_update
    val source_info: update -> string
    val string_of_raw_update: Proof.context -> raw_update -> string
    val target_of_update: raw_update -> box_id
    val thm_to_ritem: thm -> raw_item
    val thm_update: box_id * thm -> raw_update
    val thm_update_sc: int -> box_id * thm -> raw_update
    val update_info: Proof.context -> box_id -> raw_item list -> string
  end
constructor AddBoxes:
   {id: box_id, init_assum: term, sc: int option} -> raw_update
constructor AddItems:
   {id: box_id, raw_items: raw_item list, sc: int option} -> raw_update
constructor ResolveBox: {id: box_id, th: thm} -> raw_update
constructor ShadowItem: {id: box_id, item: box_item} -> raw_update
type status =
   {assums: term list,
    ctxt: Proof.context,
    handlers: (box_id * (term list * term * thm)) list,
    items: (box_item * box_id list) Inttab.table,
    queue: Updates_Heap.T, resolve_th: thm option}
signature STATUS =
  sig
    val add_handler: box_id * (term list * term * thm) -> status -> status
    val add_item: box_item -> status -> status
    val add_prim_box: box_id -> term -> status -> int * status
    val add_resolved: box_id -> status -> status
    val add_shadowed: box_id * box_item -> status -> status
    val add_to_queue: update -> status -> status
    val clear_incr: status -> status
    val delmin_from_queue: status -> status
    val empty_status: Proof.context -> status
    val find_fact: status -> box_id -> term -> thm option
    val find_prim_box: status -> box_id -> term -> int option
    val find_ritem_exact: status -> box_id -> raw_item -> bool
    val get_all_items_at_id: status -> box_id -> box_item list
    val get_handlers: status -> (box_id * (term list * term * thm)) list
    val get_init_assum: status -> int -> term
    val get_init_assums: status -> box_id -> term list
    val get_items: status -> box_item list
    val get_num_items: status -> int
    val get_on_resolve: status -> box_id -> int -> thm -> thm
    val get_resolve_th: status -> thm
    val invoke_handler:
       Proof.context -> term list * term * thm -> thm -> thm
    val lookup_item: status -> int -> (box_item * box_id list) option
    val map_context: (Proof.context -> Proof.context) -> status -> status
    val map_queue: (Updates_Heap.T -> Updates_Heap.T) -> status -> status
    val query_removed: status -> box_item -> bool
    val query_shadowed: status -> box_id -> box_item -> bool
    val set_resolve_th: thm -> status -> status
  end
structure Update: UPDATE
structure Updates_Heap: HEAP
structure Status: STATUS
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
### theory "HOL-Library.Stream"
### 1.159s elapsed time, 4.393s cpu time, 0.815s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad" via "HOL-Imperative_HOL.Heap")
signature NORMALIZER =
  sig
    val add_inj_struct_data: thm -> theory -> theory
    val add_normalizer: string * normalizer -> theory -> theory
    val add_rewr_normalizer: string * thm -> theory -> theory
    val add_th_normalizer:
       string * (Proof.context -> thm -> thm list) -> theory -> theory
    val def_subst: (term * term) list -> term -> term
    val get_normalizers: theory -> (string * normalizer) list
    val is_def_eq: theory -> term -> bool
    val meta_use_vardef: thm -> (term * term) list * thm
    val meta_use_vardefs: thm -> (term * term) list * thm
    val normalize: Proof.context -> raw_item -> raw_item list
    val normalize_keep: Proof.context -> raw_item -> raw_item list
    type normalizer = Proof.context -> raw_item -> raw_item list
    val swap_eq_to_front: conv
  end
structure Normalizer: NORMALIZER
Found termination order: "size <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
datatype proofstep_fn
=
     OneStep of Proof.context -> box_item -> raw_update list
   | TwoStep of Proof.context -> box_item -> box_item -> raw_update list
type proofstep = {args: match_arg list, func: proofstep_fn, name: string}
datatype prfstep_descriptor
=
     CreateCase of term
   | CreateConcl of term
   | Filter of prfstep_filter
   | GetFact of term * thm
   | ShadowFirst
   | ShadowSecond
   | WithFact of term
   | WithItem of string * term
   | WithProperty of term
   | WithScore of int
   | WithWellForm of term * term
signature PROOFSTEP =
  sig
    val WithGoal: term -> prfstep_descriptor
    val WithProp: term -> prfstep_descriptor
    val WithTerm: term -> prfstep_descriptor
    val all_insts: prfstep_filter
    val apply_pat_r: Proof.context -> id_inst_ths -> term * thm -> thm
    val apply_prfstep:
       Proof.context -> box_item list -> proofstep -> raw_update list
    val eq_prfstep: proofstep * proofstep -> bool
    val gen_prfstep: string -> prfstep_descriptor list -> proofstep
    val get_side_ths:
       Proof.context ->
         id_inst -> match_arg list -> (box_id * thm list) list
    val neq_filter: term -> prfstep_filter
    val not_type_filter: string -> typ -> prfstep_filter
    val order_filter: string -> string -> prfstep_filter
    val prfstep_conv: string -> prfstep_descriptor list -> conv -> proofstep
    val prfstep_custom:
       string ->
         prfstep_descriptor list ->
           (id_inst_ths ->
              box_item list -> Proof.context -> raw_update list)
             -> proofstep
    val prfstep_pre_conv:
       string ->
         prfstep_descriptor list -> (Proof.context -> conv) -> proofstep
    val retrieve_args: prfstep_descriptor list -> match_arg list
    val retrieve_cases: prfstep_descriptor list -> term list
    val retrieve_filts: prfstep_descriptor list -> prfstep_filter
    val retrieve_pats_r: prfstep_descriptor list -> (term * thm) list
    val retrieve_shadows: prfstep_descriptor list -> int list
    val size1_filter: string -> prfstep_filter
    val string_of_desc: theory -> prfstep_descriptor -> string
    val string_of_descs: theory -> prfstep_descriptor list -> string
  end
constructor OneStep:
   (Proof.context -> box_item -> raw_update list) -> proofstep_fn
constructor TwoStep:
   (Proof.context -> box_item -> box_item -> raw_update list) ->
     proofstep_fn
constructor CreateCase: term -> prfstep_descriptor
constructor CreateConcl: term -> prfstep_descriptor
constructor Filter: prfstep_filter -> prfstep_descriptor
constructor GetFact: term * thm -> prfstep_descriptor
constructor ShadowFirst: prfstep_descriptor
constructor ShadowSecond: prfstep_descriptor
constructor WithFact: term -> prfstep_descriptor
constructor WithItem: string * term -> prfstep_descriptor
constructor WithProperty: term -> prfstep_descriptor
constructor WithScore: int -> prfstep_descriptor
constructor WithWellForm: term * term -> prfstep_descriptor
signature PROOFSTEP_DATA =
  sig
    val add_backward1_prfstep: thm -> theory -> theory
    val add_backward1_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_backward2_prfstep: thm -> theory -> theory
    val add_backward2_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_backward_prfstep: thm -> theory -> theory
    val add_backward_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward'_prfstep: thm -> theory -> theory
    val add_forward'_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward_prfstep: thm -> theory -> theory
    val add_forward_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_gen_prfstep:
       string * prfstep_descriptor list -> theory -> theory
    val add_prfstep: proofstep -> theory -> theory
    val add_prfstep_check_req: string * string -> theory -> theory
    val add_prfstep_conv:
       string * prfstep_descriptor list * conv -> theory -> theory
    val add_prfstep_custom:
       string * prfstep_descriptor list *
       (id_inst_ths -> box_item list -> Proof.context -> raw_update list)
         -> theory -> theory
    val add_prfstep_pre_conv:
       string * prfstep_descriptor list * (Proof.context -> conv) ->
         theory -> theory
    val add_resolve_prfstep: thm -> theory -> theory
    val add_resolve_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule: thm -> theory -> theory
    val add_rewrite_rule_back: thm -> theory -> theory
    val add_rewrite_rule_back_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule_bidir: thm -> theory -> theory
    val add_rewrite_rule_bidir_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val del_prfstep: string -> theory -> theory
    val del_prfstep_pred: (string -> bool) -> theory -> theory
    val del_prfstep_thm: thm -> theory -> theory
    val del_prfstep_thm_eqforward: thm -> theory -> theory
    val del_prfstep_thm_str: string -> thm -> theory -> theory
    val get_prfsteps: theory -> proofstep list
    type pre_prfstep_descriptor = Proof.context -> prfstep_descriptor
    datatype prfstep_mode
    =
         MODE_BACKWARD
       | MODE_BACKWARD1
       | MODE_BACKWARD2
       | MODE_FORWARD
       | MODE_FORWARD'
       | MODE_RESOLVE
    val setup_attrib: (thm -> theory -> theory) -> attribute context_parser
    val with_cond: string -> pre_prfstep_descriptor
    val with_conds: string list -> pre_prfstep_descriptor list
    val with_filt: prfstep_filter -> pre_prfstep_descriptor
    val with_filts: prfstep_filter list -> pre_prfstep_descriptor list
    val with_score: int -> pre_prfstep_descriptor
    val with_term: string -> pre_prfstep_descriptor
  end
structure ProofStep: PROOFSTEP
val WithTerm = fn: term -> prfstep_descriptor
val WithGoal = fn: term -> prfstep_descriptor
val WithProp = fn: term -> prfstep_descriptor
val neq_filter = fn: term -> prfstep_filter
val order_filter = fn: string -> string -> prfstep_filter
val size1_filter = fn: string -> prfstep_filter
val not_type_filter = fn: string -> typ -> prfstep_filter
datatype prfstep_mode
=
     MODE_BACKWARD
   | MODE_BACKWARD1
   | MODE_BACKWARD2
   | MODE_FORWARD
   | MODE_FORWARD'
   | MODE_RESOLVE
type pre_prfstep_descriptor = Proof.context -> prfstep_descriptor
structure ProofStepData: PROOFSTEP_DATA
constructor MODE_FORWARD': prfstep_mode
constructor MODE_BACKWARD1: prfstep_mode
val del_prfstep_thm_eqforward = fn: thm -> theory -> theory
val get_prfsteps = fn: theory -> proofstep list
val del_prfstep_thm = fn: thm -> theory -> theory
val add_forward'_prfstep = fn: thm -> theory -> theory
val with_conds = fn: string list -> pre_prfstep_descriptor list
val add_prfstep_custom = fn:
   string * prfstep_descriptor list *
   (id_inst_ths -> box_item list -> Proof.context -> raw_update list)
     -> theory -> theory
val add_rewrite_rule_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward'_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val del_prfstep_thm_str = fn: string -> thm -> theory -> theory
val add_rewrite_rule = fn: thm -> theory -> theory
val with_cond = fn: string -> pre_prfstep_descriptor
val add_gen_prfstep = fn:
   string * prfstep_descriptor list -> theory -> theory
val add_backward_prfstep = fn: thm -> theory -> theory
val add_resolve_prfstep = fn: thm -> theory -> theory
constructor MODE_RESOLVE: prfstep_mode
val with_filts = fn: prfstep_filter list -> pre_prfstep_descriptor list
val add_prfstep_check_req = fn: string * string -> theory -> theory
val add_backward_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val with_score = fn: int -> pre_prfstep_descriptor
val add_rewrite_rule_back = fn: thm -> theory -> theory
val add_backward1_prfstep = fn: thm -> theory -> theory
val add_rewrite_rule_bidir_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val with_filt = fn: prfstep_filter -> pre_prfstep_descriptor
constructor MODE_BACKWARD2: prfstep_mode
val add_resolve_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep_pre_conv = fn:
   string * prfstep_descriptor list * (Proof.context -> conv) ->
     theory -> theory
val add_forward_prfstep = fn: thm -> theory -> theory
val add_backward2_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep = fn: proofstep -> theory -> theory
val setup_attrib = fn: (thm -> theory -> theory) -> attribute context_parser
val del_prfstep = fn: string -> theory -> theory
constructor MODE_FORWARD: prfstep_mode
constructor MODE_BACKWARD: prfstep_mode
val add_rewrite_rule_bidir = fn: thm -> theory -> theory
val del_prfstep_pred = fn: (string -> bool) -> theory -> theory
val add_rewrite_rule_back_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep_conv = fn:
   string * prfstep_descriptor list * conv -> theory -> theory
val add_backward1_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_backward2_prfstep = fn: thm -> theory -> theory
val with_term = fn: string -> pre_prfstep_descriptor
type auto2_frame =
   {after_qed: (term list * (thm list -> thm -> thm)) option,
    goals: (term * thm) list,
    induct_stmt: term option, prem_only: term list, selected: int option}
type auto2_state = auto2_frame list
signature AUTO2_STATE =
  sig
    val add_prem_only: term -> Proof.context -> Proof.context
    val get_last_induct_stmt: Proof.context -> term option
    val get_num_frame: Proof.context -> int
    val get_selected: Proof.context -> thm
    val get_subgoal: Proof.context -> term
    val get_top_frame: Proof.context -> auto2_frame
    val lookup_prem_only: Proof.context -> term -> bool
    val map_head_th: (thm -> thm) -> Proof.context -> Proof.context
    val multiple_frame:
       (term * cterm) list * (term list * (thm list -> thm -> thm)) option
         -> auto2_frame
    val pop_head: Proof.context -> Proof.context
    val print_state: Proof.context -> unit
    val push_head: auto2_frame -> Proof.context -> Proof.context
    val set_induct_stmt: term -> Proof.context -> Proof.context
    val set_selected: int option -> Proof.context -> Proof.context
    val simple_frame:
       cterm * (term list * (thm list -> thm -> thm)) option -> auto2_frame
  end
structure Auto2_State: AUTO2_STATE
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
Found termination order: "size <*mlex*> {}"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
Found termination order: "size <*mlex*> {}"
### Additional type variable(s) in locale specification "countable": 'a
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
consts
  mset :: "'a list => 'a multiset"
Found termination order: "size <*mlex*> {}"
signature LOGIC_PROOFSTEPS =
  sig
    val TY_DISJ: string
    val add_disj_normalizers: theory -> theory
    val add_disj_proofsteps: theory -> theory
    val add_logic_proofsteps: theory -> theory
    val analyze_disj_th: Proof.context -> thm -> term * thm
    val dest_tname_of_disj: cterm list -> term * cterm list
    val disj_create_case_prfstep: proofstep
    val disj_match_iff_prfstep: proofstep
    val disj_normalizer: Normalizer.normalizer
    val disj_prop_match:
       Proof.context ->
         id_inst ->
           term * (term list * term list) *
           ((indexname * typ) list * cterm list)
             -> id_inst_th list
    val disj_prop_matcher: item_matcher
    val disj_rewr_terms: term list -> term list
    val disj_shadow_prfstep: proofstep
    val disj_to_ritems: bool -> term -> thm -> raw_item list
    val disj_to_update:
       bool -> term -> box_id * int option * thm -> raw_update
    val eq_normalizer: Normalizer.normalizer
    val exists_elim_prfstep: proofstep
    val is_match_prem_only: box_item -> bool
    val logic_thm_update: Proof.context -> box_id * thm -> raw_update
    val match_one_sch_prfstep: proofstep
    val match_update_prfstep: proofstep
    val mk_all_disj: term list * term list -> term
    val norm_all_disj: Proof.context -> conv
    val norm_conj: conv
    val output_disj_fn: item_output
    val property_normalizer: Normalizer.normalizer
    val reduce_disj_True: conv
    val replace_disj_vars:
       Proof.context -> term list * term list -> term list * term list
    val shadow_prop_item: proofstep
    val shadow_term_item: proofstep
    val split_conj_gen_th: Proof.context -> thm -> thm list
    val split_not_imp_th: thm -> thm list
    val strip_all_disj: term -> term list * term list
  end
structure Logic_ProofSteps: LOGIC_PROOFSTEPS
val TY_DISJ = "DISJ": string
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size <*mlex*> {}"
signature SCORES =
  sig
    val get_score: raw_update -> int
    val item_score: raw_item -> int
    val items_score: raw_item list -> int
  end
signature PROOFSTATUS =
  sig
    val apply_update: update -> status -> status
    val apply_update_instant: update -> status -> status
    val check_hyps: box_id -> thm -> status -> unit
    val init_status: Proof.context -> term -> status
    val process_add_boxes: update -> status -> status
    val process_add_items: update -> status -> status
    val process_fact_all: box_id -> int -> box_item list -> status -> status
    val process_resolve: update -> status -> status
    val process_shadow: update -> status -> status
    val scoring:
       proofstep ->
         int ->
           box_item list ->
             status -> (box_item -> raw_update list) -> update list
    val solve_root: int * status -> int * status
  end
structure Scores: SCORES
val print_trace =
   Config
    {get_value = fn, map_value = fn, name = "print_trace", pos =
     {line=41, offset=1042, end_offset=1053, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_intended =
   Config
    {get_value = fn, map_value = fn, name = "print_intended", pos =
     {line=43, offset=1127, end_offset=1141, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_term =
   Config
    {get_value = fn, map_value = fn, name = "print_term", pos =
     {line=45, offset=1211, end_offset=1221, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_shadow =
   Config
    {get_value = fn, map_value = fn, name = "print_shadow", pos =
     {line=47, offset=1293, end_offset=1305, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_score =
   Config
    {get_value = fn, map_value = fn, name = "print_score", pos =
     {line=49, offset=1376, end_offset=1387, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val max_steps =
   Config
    {get_value = fn, map_value = fn, name = "max_steps", pos =
     {line=53, offset=1507, end_offset=1516, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   int Config.T
signature AUTO2 = sig val auto2_tac: Proof.context -> tactic end
structure ProofStatus: PROOFSTATUS
structure Auto2: AUTO2
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
Found termination order: "size <*mlex*> {}"
signature AUTO2_OUTER =
  sig
    val auto2_solve: Proof.context -> cterm -> thm
    val case_after_qed: Proof.context -> thm list -> thm -> thm
    val case_cmd: string * bool -> Proof.state -> Proof.state
    val case_resolve: Proof.context -> term list -> thm -> thm
    val contra_after_qed: Proof.context -> thm -> thm
    val contra_cmd: Proof.state -> Proof.state
    val contra_resolve:
       Proof.context -> term list -> term list -> term -> thm
    val end_cmd: Proof.state -> Proof.state
    val endgoal_cmd: Proof.state -> Proof.state
    val have_after_qed: Proof.context -> thm -> thm -> thm
    val have_cmd: bool * string * bool -> Proof.state -> Proof.state
    val have_resolve: Proof.context -> term list -> thm -> term -> thm
    val init_state: Proof.state -> Proof.state
    val let_after_qed: Proof.context -> term list -> thm -> thm
    val let_cmd: string list -> Proof.state -> Proof.state
    val let_resolve:
       Proof.context -> term list -> term -> term list -> term -> thm
    val obtain_after_qed: Proof.context -> thm list -> thm -> thm
    val obtain_cmd:
       string list * string list * bool -> Proof.state -> Proof.state
    val obtain_resolve: Proof.context -> term list -> thm -> term -> thm
    val qed_cmd: Proof.state -> Proof.context
    val refine_subgoal_th: thm -> thm -> thm
    val subgoal_cmd: string -> Proof.state -> Proof.state
  end
structure Auto2_Outer: AUTO2_OUTER
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
type ac_info =
   {assoc_th: thm,
    cfhead: cterm,
    comm_th: thm, unit: cterm option, unitl_th: thm, unitr_th: thm}
signature ACUTIL =
  sig
    val ac_last_conv: ac_info -> conv -> conv
    val add_ac_data: ac_info -> theory -> theory
    val assoc_cv: ac_info -> conv
    val assoc_sym_cv: ac_info -> conv
    val cdest_ac: ac_info -> cterm -> cterm list
    val comb_ac_equiv: ac_info -> thm list -> thm
    val comm_cv: ac_info -> conv
    val dest_ac: ac_info -> term -> term list
    val eq_unit: ac_info -> term -> bool
    val get_head_ac_info: theory -> term -> ac_info option
    val has_assoc_th: ac_info -> bool
    val has_comm_th: ac_info -> bool
    val has_unit_th: ac_info -> bool
    val head_agrees: ac_info -> term -> bool
    val inst_ac_info: theory -> typ -> ac_info -> ac_info option
    val move_outmost: ac_info -> term -> conv
    val norm_combine: ac_info -> (term -> bool) -> conv -> conv
    val normalize_all_ac: ac_info -> conv
    val normalize_assoc: ac_info -> conv
    val normalize_au: ac_info -> conv
    val normalize_comm: ac_info -> conv
    val normalize_comm_gen: ac_info -> (term * term -> bool) -> conv
    val normalize_unit: ac_info -> conv
    val swap_cv: ac_info -> conv
    val swap_r_cv: ac_info -> conv
  end
structure ACUtil: ACUTIL
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
signature AC_PROOFSTEPS =
  sig
    val ac_expand:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val ac_expand_equiv: proofstep
    val ac_expand_once:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val ac_expand_unit: proofstep
    val add_ac_proofsteps: theory -> theory
    val get_ac_head_equiv:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val max_ac: int Config.T
    val simp_ac_expr:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
  end
structure AC_ProofSteps: AC_PROOFSTEPS
signature UNFOLDING =
  sig
    val get_unfold_thms: theory -> term -> thm list
    val get_unfold_thms_by_name: theory -> string -> thm list
    val unfold: theory -> conv
    val unfold_cmd: string -> Proof.state -> Proof.state
  end
structure Unfolding: UNFOLDING
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
signature INDUCT_PROOFSTEPS =
  sig
    val add_case_induct_rule: thm -> theory -> theory
    val add_cases_rule: thm -> theory -> theory
    val add_fun_induct_rule: term * thm -> theory -> theory
    val add_induct_data: string -> term * thm -> theory -> theory
    val add_prop_induct_rule: thm -> theory -> theory
    val add_strong_induct_rule: thm -> theory -> theory
    val add_typed_induct_data: string -> typ * thm -> theory -> theory
    val add_var_induct_rule: thm -> theory -> theory
    val apply_induct_hyp_cmd: string list -> Proof.state -> Proof.state
    val case_induct_cmd: string -> Proof.state -> Proof.state
    val check_strong_ind_prop: term -> term list * term
    val fun_induct_cmd:
       string * string list * string option -> Proof.state -> Proof.state
    val get_term_ind_th: theory -> string -> term -> thm
    val get_typed_ind_th: theory -> string -> typ -> thm
    val induct_cmd:
       string ->
         string * string option * string list * string option ->
           Proof.state -> Proof.state
    val is_simple_fun_induct: thm -> bool
    val prop_induct_cmd:
       string * string option -> Proof.state -> Proof.state
    val strong_induct_cmd:
       string * string list -> Proof.state -> Proof.state
  end
structure Induct_ProofSteps: INDUCT_PROOFSTEPS
val add_strong_induct_rule = fn: thm -> theory -> theory
val add_case_induct_rule = fn: thm -> theory -> theory
val add_prop_induct_rule = fn: thm -> theory -> theory
val add_var_induct_rule = fn: thm -> theory -> theory
val add_fun_induct_rule = fn: term * thm -> theory -> theory
val add_cases_rule = fn: thm -> theory -> theory
signature EXTRA_HOL =
  sig
    val add_forward_arg1_prfstep: thm -> theory -> theory
    val add_forward_arg1_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward_arg_prfstep: thm -> theory -> theory
    val add_forward_arg_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_arg_rule: thm -> theory -> theory
    val add_rewrite_arg_rule_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_simple_datatype: string -> theory -> theory
    val del_simple_datatype: string -> theory -> theory
  end
structure Extra_HOL: EXTRA_HOL
val add_forward_arg_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward_arg1_prfstep = fn: thm -> theory -> theory
val add_forward_arg_prfstep = fn: thm -> theory -> theory
val add_simple_datatype = fn: string -> theory -> theory
val del_simple_datatype = fn: string -> theory -> theory
val add_rewrite_arg_rule_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_rewrite_arg_rule = fn: thm -> theory -> theory
val add_forward_arg1_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
### theory "HOL-Library.Countable"
### 1.566s elapsed time, 5.942s cpu time, 1.406s GC time
Loading theory "HOL-Imperative_HOL.Heap" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array" via "HOL-Imperative_HOL.Heap_Monad")
### theory "Auto2_HOL.Auto2_HOL"
### 3.188s elapsed time, 12.126s cpu time, 2.381s GC time
Loading theory "Auto2_HOL.Logic_Thms" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms")
HOL.refl@res
WithGoal ?t = ?t
GetResolve HOL.refl@res
HOL_Base.contra_triv
WithGoal ?A
WithFact ?A
GetResolve HOL_Base.contra_triv
HOL.TrueI@res
WithGoal True
GetResolve HOL.TrueI@res
Logic_Thms.FalseD@res
WithFact False
GetResolve Logic_Thms.FalseD@res
Logic_Thms.exists_triv_eq@res
WithGoal EX x. x = x
GetResolve Logic_Thms.exists_triv_eq@res
HOL.not_sym
WithGoal ?t = ?s
GetGoal (?s = ?t, HOL.not_sym) + 1 filters
Logic_Thms.iff_goal_1
WithGoal ?A = ?B
WithFact ?A
WithScore 1
GetGoal (?B, Logic_Thms.iff_goal_1)
Logic_Thms.iff_goal_2
WithGoal ?A = ?B
WithFact ?B
WithScore 1
GetGoal (?A, Logic_Thms.iff_goal_2)
Logic_Thms.iff_goal_3
WithGoal ?A = ?B
WithGoal ?A
WithScore 1
GetFact (?B, Logic_Thms.iff_goal_3)
Logic_Thms.iff_goal_4
WithGoal ?A = ?B
WithGoal ?B
WithScore 1
GetFact (?A, Logic_Thms.iff_goal_4)
Logic_Thms.iff_goal_5
WithGoal (~ ?A) = ?B
WithFact ?A
WithScore 1
GetFact (?B, Logic_Thms.iff_goal_5)
Logic_Thms.iff_goal_6
WithGoal ?A = (~ ?B)
WithFact ?B
WithScore 1
GetFact (?A, Logic_Thms.iff_goal_6)
Logic_Thms.exists_split@eqbackward@back
WithGoal EX x y. ?P x & ?Q y
GetGoal ((EX x. ?P x) & (EX y. ?Q y), Logic_Thms.exists_split@eqbackward@back)
Found termination order: "size <*mlex*> {}"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
HOL.if_P
WithTerm if ?P then ?x else ?y
WithFact ?P
WithScore 1
GetFact ((if ?P then ?x else ?y) = ?x, HOL.if_P)
HOL.if_not_P
WithTerm if ?P then ?x else ?y
WithGoal ?P
WithScore 1
GetFact ((if ?P then ?x else ?y) = ?y, HOL.if_not_P)
Logic_Thms.if_eval'
WithTerm if ~ ?P then ?x else ?y
WithFact ?P
WithScore 1
GetFact ((if ~ ?P then ?x else ?y) = ?y, Logic_Thms.if_eval')
Logic_Thms.ifb_eval_1@eqforward
WithFact if ?Pa then ?P else ?y
WithFact ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_1@eqforward)
Logic_Thms.ifb_eval_1@invbackward
WithGoal if ?P then ?B else ?y
WithFact ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_1@invbackward)
Logic_Thms.ifb_eval_2@eqforward
WithFact if ?Pa then ?x else ?P
WithGoal ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_2@eqforward)
Logic_Thms.ifb_eval_2@invbackward
WithGoal if ?P then ?x else ?B
WithGoal ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_2@invbackward)
Logic_Thms.ifb_eval_3@eqforward
WithFact if ~ ?Pa then ?x else ?P
WithFact ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_3@eqforward)
Logic_Thms.ifb_eval_3@invbackward
WithGoal if ~ ?P then ?x else ?B
WithFact ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_3@invbackward)
HOL.theI'
WithTerm THE x. ?P x
WithFact EX! x. ?P x
GetFact (?P (THE x. ?P x), HOL.theI')
Logic_Thms.ex_ex1I'@back1
WithGoal EX! x. ?P x
WithFact ?P ?x
GetGoal (ALL y. ?P y --> ?x = y, Logic_Thms.ex_ex1I'@back1)
Logic_Thms.the1_equality'
WithTerm THE x. ?P x
WithFact ?P ?a
GetFact ((EX! x. ?P x) --> (THE x. ?P x) = ?a, Logic_Thms.the1_equality')
Hilbert_Choice.someI
WithTerm SOME x. ?P x
WithFact ?P ?x
GetFact (?P (Eps ?P), Hilbert_Choice.someI)
Hilbert_Choice.someI_ex
WithTerm SOME x. ?P x
WithFact EX x. ?P x
GetFact (?P (SOME x. ?P x), Hilbert_Choice.someI_ex)
Logic_Thms.Least_equality'@back1
WithGoal Least ?P = ?x
WithFact ALL y. ?P y --> ?x <= y
GetGoal (?P ?x, Logic_Thms.Least_equality'@back1)
Product_Type.fst_conv
WithTerm fst (?x1.0, ?x2.0)
GetFact (fst (?x1.0, ?x2.0) = ?x1.0, Product_Type.fst_conv)
Product_Type.snd_conv
WithTerm snd (?x1.0, ?x2.0)
GetFact (snd (?x1.0, ?x2.0) = ?x2.0, Product_Type.snd_conv)
Product_Type.prod.simps_1@eqforward
WithFact (?x1.0, ?x2.0) = (?y1.0, ?y2.0)
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Product_Type.prod.simps_1@eqforward)
Product_Type.surjective_pairing
WithTerm ?t
GetFact (?t = (fst ?t, snd ?t), Product_Type.surjective_pairing) + 1 filters
Relation.symD
WithProperty sym ?r
WithFact (?b, ?a) : ?r
GetFact ((?a, ?b) : ?r, Relation.symD)
Relation.symI@back
WithGoal sym ?r
GetGoal (ALL a b. (a, b) : ?r --> (b, a) : ?r, Relation.symI@back)
Relation.transD
WithProperty trans ?r
WithFact (?x, ?y) : ?r
WithFact (?y, ?z) : ?r
GetFact ((?x, ?z) : ?r, Relation.transD)
Relation.transI@back
WithGoal trans ?r
GetGoal (ALL x y z. (x, y) : ?r --> (y, z) : ?r --> (x, z) : ?r, Relation.transI@back)
Option.option.distinct_1@res
WithFact None = Some ?x2.0
GetResolve Option.option.distinct_1@res
Option.option.sel
WithTerm the (Some ?x2.0)
GetFact (the (Some ?x2.0) = ?x2.0, Option.option.sel)
Option.option.collapse
WithGoal ?option = None
GetFact (Some (the ?option) = ?option, Option.option.collapse)
Option.option.simps_1@eqforward
WithFact Some ?x2.0 = Some ?y2.0
GetFact (?x2.0 = ?y2.0, Option.option.simps_1@eqforward)
Option.option.case_1
WithTerm case None of None => ?f1.0 | Some x => ?f2.0 x
WithScore 1
GetFact ((case None of None => ?f1.0 | Some x => ?f2.0 x) = ?f1.0, Option.option.case_1)
Option.option.case_2
WithTerm case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x
WithScore 1
GetFact ((case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x) = ?f2.0 ?x2.0, Option.option.case_2)
### theory "Auto2_HOL.Logic_Thms"
### 0.177s elapsed time, 0.691s cpu time, 0.046s GC time
Loading theory "Auto2_HOL.Order_Thms" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms")
### theory "HOL-Library.Tree"
### 2.648s elapsed time, 10.024s cpu time, 2.151s GC time
Loading theory "Draft.Templates" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.087s elapsed time, 0.329s cpu time, 0.072s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.ExtrEqs")
signature UTIL_ARITH =
  sig
    val contra_by_arith: Proof.context -> thm list -> thm
    val dest_numc: term -> int
    val dest_numc_rat: term -> Rat.rat
    val intT: typ
    val is_divide: term -> bool
    val is_linorder: Proof.context -> term -> bool
    val is_minus: term -> bool
    val is_numc: term -> bool
    val is_one: term -> bool
    val is_order: term -> bool
    val is_plus: term -> bool
    val is_times: term -> bool
    val is_zero: term -> bool
    val natT: typ
    val neg_ineq_back_cv: conv
    val neg_ineq_cv: conv
    val prove_by_arith: Proof.context -> thm list -> term -> thm
    val ratT: typ
    val rat_zero: Rat.rat
  end
structure UtilArith: UTIL_ARITH
val natT = "nat": typ
val intT = "int": typ
Orderings.preorder_class.order.trans
WithFact ?a <= ?b
WithFact ?b <= ?c
GetFact (?a <= ?c, Orderings.preorder_class.order.trans) + 1 filters
Orderings.preorder_class.order.strict_trans
WithFact ?a < ?b
WithFact ?b < ?c
GetFact (?a < ?c, Orderings.preorder_class.order.strict_trans) + 1 filters
Orderings.order_le_less_trans
WithFact ?x <= ?y
WithFact ?y < ?z
GetFact (?x < ?z, Orderings.order_le_less_trans) + 1 filters
Orderings.order_less_le_trans
WithFact ?x < ?y
WithFact ?y <= ?z
GetFact (?x < ?z, Orderings.order_less_le_trans) + 1 filters
Orderings.preorder_class.order.irrefl@res
WithFact ?a < ?a
GetResolve Orderings.preorder_class.order.irrefl@res
Orderings.order_class.le_neq_trans
WithFact ?a <= ?b
WithGoal ?a = ?b
GetFact (?a < ?b, Orderings.order_class.le_neq_trans) + 1 filters
Orderings.order_class.order_antisym
WithFact ?x <= ?y
WithFact ?y <= ?x
GetFact (?x = ?y, Orderings.order_class.order_antisym) + 2 filters
Lattices.linorder_class.min.commute
WithTerm min ?a ?b
GetFact (min ?a ?b = min ?b ?a, Lattices.linorder_class.min.commute)
Lattices.linorder_class.min.idem
WithTerm min ?a ?a
GetFact (min ?a ?a = ?a, Lattices.linorder_class.min.idem)
Lattices.linorder_class.min.cobounded1
WithTerm min ?a ?b
GetFact (min ?a ?b <= ?a, Lattices.linorder_class.min.cobounded1)
Lattices.linorder_class.min.cobounded2
WithTerm min ?a ?b
GetFact (min ?a ?b <= ?b, Lattices.linorder_class.min.cobounded2)
Lattices.linorder_class.min.boundedI@back2
WithGoal ?a <= min ?b ?c
WithFact ?a <= ?b
GetGoal (?a <= ?c, Lattices.linorder_class.min.boundedI@back2)
Lattices.linorder_class.min.mono@back2
WithGoal min ?a ?b <= min ?c ?d
WithFact ?a <= ?c
GetGoal (?b <= ?d, Lattices.linorder_class.min.mono@back2)
Lattices.linorder_class.min.absorb1
WithTerm min ?a ?b
WithFact ?a <= ?b
GetFact (min ?a ?b = ?a, Lattices.linorder_class.min.absorb1)
Lattices.linorder_class.min.absorb2
WithTerm min ?a ?b
WithFact ?b <= ?a
GetFact (min ?a ?b = ?b, Lattices.linorder_class.min.absorb2)
Lattices.linorder_class.max.commute
WithTerm max ?a ?b
GetFact (max ?a ?b = max ?b ?a, Lattices.linorder_class.max.commute)
Lattices.linorder_class.max.idem
WithTerm max ?a ?a
GetFact (max ?a ?a = ?a, Lattices.linorder_class.max.idem)
Lattices.linorder_class.max.cobounded1
WithTerm max ?a ?b
GetFact (?a <= max ?a ?b, Lattices.linorder_class.max.cobounded1)
Lattices.linorder_class.max.cobounded2
WithTerm max ?a ?b
GetFact (?b <= max ?a ?b, Lattices.linorder_class.max.cobounded2)
Lattices.linorder_class.max.boundedI@back2
WithGoal max ?b ?c <= ?a
WithFact ?b <= ?a
GetGoal (?c <= ?a, Lattices.linorder_class.max.boundedI@back2)
Lattices.linorder_class.max.mono@back2
WithGoal max ?c ?d <= max ?a ?b
WithFact ?c <= ?a
GetGoal (?d <= ?b, Lattices.linorder_class.max.mono@back2)
Lattices.linorder_class.max.absorb1
WithTerm max ?a ?b
WithFact ?b <= ?a
GetFact (max ?a ?b = ?a, Lattices.linorder_class.max.absorb1)
Lattices.linorder_class.max.absorb2
WithTerm max ?a ?b
WithFact ?a <= ?b
GetFact (max ?a ?b = ?b, Lattices.linorder_class.max.absorb2)
Lattices_Big.linorder_class.Min_in@back
WithProperty finite ?A
WithGoal Min ?A : ?A
GetFact (?A = {}, Lattices_Big.linorder_class.Min_in@back)
Lattices_Big.linorder_class.Min_le@back
WithProperty finite ?A
WithGoal Min ?A <= ?x
GetGoal (?x : ?A, Lattices_Big.linorder_class.Min_le@back)
Lattices_Big.linorder_class.Min_eqI@back2
WithProperty finite ?A
WithGoal Min ?A = ?x
WithFact ALL y. y : ?A --> ?x <= y
GetGoal (?x : ?A, Lattices_Big.linorder_class.Min_eqI@back2)
Order_Thms.exists_ge@res
WithGoal EX k. ?i <= k
GetResolve Order_Thms.exists_ge@res
Orderings.no_bot_class.lt_ex@res
WithGoal EX y. y < ?x
GetResolve Orderings.no_bot_class.lt_ex@res
Orderings.no_top_class.gt_ex@res
WithGoal EX y. ?x < y
GetResolve Orderings.no_top_class.gt_ex@res
Orderings.dense_order_class.dense@back
WithGoal EX z>?x. z < ?y
GetGoal (?x < ?y, Orderings.dense_order_class.dense@back)
### theory "Auto2_HOL.Order_Thms"
### 0.370s elapsed time, 1.461s cpu time, 0.124s GC time
Loading theory "Auto2_HOL.Arith_Thms" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main")
Add ac data for function Groups.plus_class.plus
Add ac data for function Groups.times_class.times
Add ac data for function GCD.gcd_class.gcd
signature NAT_UTIL =
  sig
    val add_arith_ac_data: theory -> theory
    val add_arith_proofsteps: theory -> theory
    val cnat0: cterm
    val lookup_numc: Type.tyenv * Envir.tenv -> int -> int
    val lookup_numc0: Type.tyenv * Envir.tenv -> int
    val lookup_numc1: Type.tyenv * Envir.tenv -> int
    val lookup_numc2: Type.tyenv * Envir.tenv -> int
    val mk_int: int -> term
    val mk_le: term * term -> term
    val mk_less: term * term -> term
    val mk_nat: int -> term
    val nat0: term
    val nat_fold_conv: conv
    val nat_fold_reduce: term -> term
    val nat_le_th: int -> int -> thm
    val nat_less_th: int -> int -> thm
    val nat_neq_th: int -> int -> thm
    val plus_ac_on_typ: theory -> typ -> ac_info
    val times_ac_on_typ: theory -> typ -> ac_info
  end
structure Nat_Util: NAT_UTIL
val mk_nat = fn: int -> term
val mk_int = fn: int -> term
val plus_ac_on_typ = fn: theory -> typ -> ac_info
val times_ac_on_typ = fn: theory -> typ -> ac_info
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
signature NAT_ORDER =
  sig
    val add_nat_order_proofsteps: theory -> theory
    val convert_const_x: thm -> thm
    val convert_const_y: thm -> thm
    val dest_ineq: term -> term * term * int
    val dest_ineq_th: thm -> term * term * int
    val fold_double_plus: conv
    val get_nat_order_info: box_item -> order_info
    val is_minus_const: term -> bool
    val is_order: term -> bool
    val is_plus_const: term -> bool
    val is_standard_ineq: term -> bool
    val nat_eq_diff_prfstep: proofstep
    val nat_order_match:
       term -> box_item -> Proof.context -> id_inst -> id_inst_th list
    val nat_order_matcher: item_matcher
    val nat_order_normalizer: Normalizer.normalizer
    val nat_order_noteq_matcher: item_matcher
    val nat_order_single_match:
       term -> box_item -> Proof.context -> id_inst -> id_inst_th list
    val nat_order_single_matcher: item_matcher
    val nat_order_typed_matcher: item_matcher
    val norm_ineq_minus_th: thm -> thm option
    val norm_ineq_minus_th': thm -> thm option
    val norm_ineq_th: thm -> thm
    val norm_ineq_th': thm -> thm
    type order_info
    datatype order_type
    =
         LE
       | LESS
       | LESS_LMINUS
       | LESS_LPLUS
       | LESS_RMINUS
       | LESS_RPLUS
       | LE_LMINUS
       | LE_LPLUS
       | LE_RMINUS
       | LE_RPLUS
    val output_nat_order: Proof.context -> term list * thm -> string
    val shadow_nat_order:
       Proof.context -> box_id -> term list * cterm list -> bool
    val shadow_nat_order_prfstep: proofstep
    val shadow_nat_order_single: proofstep
    val single_resolve: proofstep
    val single_resolve_zero: proofstep
    val string_of_nat_order:
       Proof.context -> term * term * int * thm -> string
    val th_to_normed_ritems: thm -> raw_item list
    val th_to_ritem: thm -> raw_item
    val to_normal_th: order_type -> thm -> thm
    val transitive: proofstep
    val transitive_resolve: proofstep
  end
val TY_NAT_ORDER = "NAT_ORDER": string
structure Nat_Order: NAT_ORDER
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
### theory "HOL-Library.BigO"
### 1.155s elapsed time, 4.371s cpu time, 1.327s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.RBTree_ImplMoreTemplates")
val test_fold_double_plus = [(), (), (), ()]: unit list
val convert_prop_to_nat_order = fn: term -> raw_item list
val test_parse_prop = (): unit
val test_nat_order_match = (): unit
val test_nat_order_single_match = (): unit
Groups.minus_class.minus_case
WithTerm ?a - ?b
CreateConcl ?b <= ?a
consts
  addr_of_array :: "'a array => nat"
consts
  addr_of_ref :: "'a ref => nat"
### theory "HOL-Imperative_HOL.Heap"
### 1.581s elapsed time, 6.045s cpu time, 1.463s GC time
Loading theory "HOL-Imperative_HOL.Heap_Monad" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL" via "HOL-Imperative_HOL.Array")
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
signature NAT_SUB =
  sig
    val add_nat_sub_proofsteps: theory -> theory
    val add_polynomial_list: monomial list * monomial list -> monomial list
    val cancel_terms: wfconv
    val fheads: term list
    val get_sub_head_equiv:
       Proof.context -> box_id * cterm -> (box_id * (wfterm * thm)) list
    type monomial = cterm list * int
    val move_outmost: term -> wfconv
    val nat_sub_expand:
       Proof.context -> box_id * cterm -> (box_id * (wfterm * thm)) list
    val nat_sub_expand_equiv: proofstep
    val nat_sub_expand_once:
       Proof.context -> box_id * wfterm -> (box_id * (wfterm * thm)) list
    val nat_sub_expand_unit: proofstep
    val norm_minus: wfconv
    val norm_minus': wfconv
    val norm_minus_ct: cterm -> monomial list
    val norm_plus: wfconv
    val norm_plus1: wfconv
    val norm_ring_term: cterm -> term
    val reduce_monomial_list: monomial list -> monomial list
  end
structure NatSub: NAT_SUB
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
val test_term = fn:
   Proof.context -> (cterm -> term) -> string -> string * string -> unit
val test =
   [(), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (),
    (), (), ...]:
   unit list
### theory "HOL-Library.Multiset"
### 4.723s elapsed time, 18.012s cpu time, 3.839s GC time
Loading theory "Auto2_HOL.Set_Thms" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms")
Arith_Thms.le_neq_implies_less'
WithGoal ?m = ?n
WithFact ?m <= ?n
GetFact (?m < ?n, Arith_Thms.le_neq_implies_less')
Arith_Thms.le_zero_to_equal_zero
WithFact ?n <= 0
GetFact (?n = 0, Arith_Thms.le_zero_to_equal_zero)
Arith_Thms.less_one_to_equal_zero
WithFact ?n < 1
GetFact (?n = 0, Arith_Thms.less_one_to_equal_zero)
Nat.mult_le_mono1@back
WithGoal ?i * ?k <= ?j * ?k
GetGoal (?i <= ?j, Nat.mult_le_mono1@back) + 1 filters
Nat.not_add_less1@res
WithFact ?i + ?j < ?i
GetResolve Nat.not_add_less1@res
Arith_Thms.not_minus_less@res
WithFact ?i < ?i - ?j
GetResolve Arith_Thms.not_minus_less@res
Arith_Thms.nat_le_prod_with_same@back
WithGoal ?n <= ?m * ?n
GetFact (?m = 0, Arith_Thms.nat_le_prod_with_same@back)
Arith_Thms.nat_le_prod_with_le@back1
WithGoal ?n <= ?k * ?m
WithFact ?n <= ?m
GetFact (?k = 0, Arith_Thms.nat_le_prod_with_le@back1)
Arith_Thms.nat_plus_le_to_less@back1
WithGoal ?a < ?c
WithFact ?a + ?b <= ?c
GetFact (?b = 0, Arith_Thms.nat_plus_le_to_less@back1)
Arith_Thms.nat_plus_le_to_less2@back1
WithGoal ?b < ?c
WithFact ?a + ?b <= ?c
GetFact (?a = 0, Arith_Thms.nat_plus_le_to_less2@back1)
Groups.cancel_semigroup_add_class.add_right_imp_eq
WithFact ?b + ?a = ?c + ?a
GetFact (?b = ?c, Groups.cancel_semigroup_add_class.add_right_imp_eq)
Groups.cancel_semigroup_add_class.add_left_imp_eq
WithFact ?a + ?b = ?a + ?c
GetFact (?b = ?c, Groups.cancel_semigroup_add_class.add_left_imp_eq)
Nat.le_diff_conv2@eqforward
WithWellForm ?k <= ?j
WithTerm ?i + ?k
WithFact ?i <= ?j - ?k
GetFact (?i + ?k <= ?j, Nat.le_diff_conv2@eqforward)
Nat.le_diff_conv2@invbackward
WithWellForm ?k <= ?j
WithTerm ?i + ?k
WithGoal ?i <= ?j - ?k
GetGoal (?i + ?k <= ?j, Nat.le_diff_conv2@invbackward)
Arith_Thms.nat_less_diff_conv
WithTerm ?i + ?k
WithFact ?i < ?j - ?k
GetFact (?i + ?k < ?j, Arith_Thms.nat_less_diff_conv) + 1 filters
Arith_Thms.Nat_le_diff_conv2_same
WithWellForm ?j <= ?i
WithFact ?i <= ?i - ?j
GetFact (?j = 0, Arith_Thms.Nat_le_diff_conv2_same)
Arith_Thms.nat_gt_zero
WithFact 0 < ?b - ?a
GetFact (?a < ?b, Arith_Thms.nat_gt_zero)
Arith_Thms.n_minus_1_less_n
WithWellForm 1 <= ?n
WithTerm ?n - 1
GetFact (?n - 1 < ?n, Arith_Thms.n_minus_1_less_n)
Nat.diff_le_mono@back
WithGoal ?m - ?l <= ?n - ?l
GetGoal (?m <= ?n, Nat.diff_le_mono@back)
Nat.diff_less_mono@back2
WithGoal ?a - ?c < ?b - ?c
WithFact ?a < ?b
GetGoal (?c <= ?a, Nat.diff_less_mono@back2)
Nat.mult_le_mono2@back
WithGoal ?k * ?i <= ?k * ?j
GetGoal (?i <= ?j, Nat.mult_le_mono2@back)
Nat.le_add1@res
WithGoal ?n <= ?n + ?m
GetResolve Nat.le_add1@res
Nat.le_add2@res
WithGoal ?n <= ?m + ?n
GetResolve Nat.le_add2@res
Groups.ordered_ab_semigroup_add_class.add_left_mono@back
WithGoal ?c + ?a <= ?c + ?b
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_left_mono@back)
Groups.ordered_ab_semigroup_add_class.add_right_mono@back
WithGoal ?a + ?c <= ?b + ?c
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_right_mono@back)
Arith_Thms.add_mono_neutr@back
WithGoal ?a <= ?a + ?b
GetGoal ((0::?'a) <= ?b, Arith_Thms.add_mono_neutr@back)
Arith_Thms.add_mono_neutl@back
WithGoal ?a <= ?b + ?a
GetGoal ((0::?'a) <= ?b, Arith_Thms.add_mono_neutl@back)
Groups.ordered_ab_semigroup_add_imp_le_class.add_less_imp_less_left
WithFact ?c + ?a < ?c + ?b
GetFact (?a < ?b, Groups.ordered_ab_semigroup_add_imp_le_class.add_less_imp_less_left)
Arith_Thms.sum_le_zero1
WithFact ?a + ?b < (0::?'a)
WithFact (0::?'a) <= ?a
GetFact (?b < (0::?'a), Arith_Thms.sum_le_zero1)
Arith_Thms.less_sum1@back
WithGoal ?a < ?a + ?b
GetGoal (0 < ?b, Arith_Thms.less_sum1@back)
Nat.trans_less_add2@back
WithGoal ?i < ?m + ?j
GetGoal (?i < ?j, Nat.trans_less_add2@back)
Nat.add_less_mono1@back
WithGoal ?i + ?k < ?j + ?k
GetGoal (?i < ?j, Nat.add_less_mono1@back)
Nat.add_less_mono@back1
WithGoal ?i + ?k < ?j + ?l
WithFact ?k < ?l
GetGoal (?i < ?j, Nat.add_less_mono@back1)
Nat.add_le_mono@back1
WithGoal ?i + ?k <= ?j + ?l
WithFact ?k <= ?l
GetGoal (?i <= ?j, Nat.add_le_mono@back1)
Groups.ordered_comm_monoid_add_class.add_increasing2@back1
WithGoal ?b <= ?a + ?c
WithFact ?b <= ?a
GetGoal ((0::?'a) <= ?c, Groups.ordered_comm_monoid_add_class.add_increasing2@back1)
Groups.ordered_ab_semigroup_add_class.add_mono@back1
WithGoal ?a + ?c <= ?b + ?d
WithFact ?c <= ?d
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_mono@back1)
Groups.ordered_cancel_ab_semigroup_add_class.add_strict_left_mono@back
WithGoal ?c + ?a < ?c + ?b
GetGoal (?a < ?b, Groups.ordered_cancel_ab_semigroup_add_class.add_strict_left_mono@back)
Nat.mult_le_mono@back1
WithGoal ?i * ?k <= ?j * ?l
WithFact ?k <= ?l
GetGoal (?i <= ?j, Nat.mult_le_mono@back1)
Arith_Thms.nat_add_eq_self_zero
WithFact ?m = ?m + ?n
GetFact (?n = 0, Arith_Thms.nat_add_eq_self_zero)
Arith_Thms.nat_add_eq_self_zero'
WithFact ?m = ?n + ?m
GetFact (?n = 0, Arith_Thms.nat_add_eq_self_zero')
Arith_Thms.nat_mult_2
WithTerm ?a + ?a
GetFact (?a + ?a = 2 * ?a, Arith_Thms.nat_mult_2) + 1 filters
Arith_Thms.plus_one_non_zero@res
WithFact ?n + 1 = 0
GetResolve Arith_Thms.plus_one_non_zero@res
Arith_Thms.nat_same_minus_ge
WithFact ?c - ?b <= ?c - ?a
WithFact ?a <= ?c
GetFact (?a <= ?b, Arith_Thms.nat_same_minus_ge)
Arith_Thms.diff_eq_zero
WithWellForm ?k <= ?j
WithFact ?j - ?k = 0
GetFact (?j = ?k, Arith_Thms.diff_eq_zero)
Arith_Thms.diff_eq_zero'
WithWellForm ?k <= ?j
WithFact ?j - ?k + ?i = ?j
GetFact (?k = ?i, Arith_Thms.diff_eq_zero')
Arith_Thms.dvd_defD1@res
WithGoal EX k. ?b = ?a * k
WithFact ?a dvd ?b
GetResolve Arith_Thms.dvd_defD1@res
Arith_Thms.dvd_defD2@res
WithGoal EX k. ?b = k * ?a
WithFact ?a dvd ?b
GetResolve Arith_Thms.dvd_defD2@res
Nat.dvd_imp_le
WithFact ?k dvd ?n
WithFact 0 < ?n
GetFact (?k <= ?n, Nat.dvd_imp_le)
Arith_Thms.dvd_ineq2
WithFact ?k dvd ?n
WithFact 0 < ?n
GetFact (1 <= ?k, Arith_Thms.dvd_ineq2)
Rings.comm_monoid_mult_class.dvd_trans
WithFact ?a dvd ?b
WithFact ?b dvd ?c
GetFact (?a dvd ?c, Rings.comm_monoid_mult_class.dvd_trans) + 3 filters
Nat.dvd_antisym
WithFact ?m dvd ?n
WithFact ?n dvd ?m
GetFact (?m = ?n, Nat.dvd_antisym) + 1 filters
Arith_Thms.dvd_cancel@back1
WithGoal ?a dvd ?b
WithFact ?a * ?c dvd ?b * ?c
GetGoal (0 < ?c, Arith_Thms.dvd_cancel@back1)
Rings.comm_semiring_1_cancel_class.dvd_add_right_iff@eqforward
WithFact ?a dvd ?b
WithFact ?a dvd ?b + ?c
GetFact (?a dvd ?c, Rings.comm_semiring_1_cancel_class.dvd_add_right_iff@eqforward)
Rings.comm_monoid_mult_class.dvd_refl@res
WithGoal ?a dvd ?a
GetResolve Rings.comm_monoid_mult_class.dvd_refl@res
Arith_Thms.exists_n_dvd_n@back
WithGoal EX k. k dvd ?n & ?P k
GetGoal (?P ?n, Arith_Thms.exists_n_dvd_n@back)
Rings.comm_monoid_mult_class.one_dvd@res
WithGoal (1::?'a) dvd ?a
GetResolve Rings.comm_monoid_mult_class.one_dvd@res
Arith_Thms.any_n_dvd_0
WithGoal EX k. k dvd 0 & ?P k
GetGoal (EX k. ?P k, Arith_Thms.any_n_dvd_0)
Arith_Thms.n_dvd_one
WithFact is_unit ?n
GetFact (?n = 1, Arith_Thms.n_dvd_one) + 1 filters
Rings.mult_zero_class.mult_zero_left
WithTerm (0::?'a) * ?a
GetFact ((0::?'a) * ?a = (0::?'a), Rings.mult_zero_class.mult_zero_left)
Arith_Thms.prod_ineqs1
WithFact 0 < ?m * ?k
GetFact (0 < ?m & 0 < ?k, Arith_Thms.prod_ineqs1)
Arith_Thms.prod_ineqs2@back
WithGoal ?m <= ?m * ?k
GetGoal (0 < ?k, Arith_Thms.prod_ineqs2@back)
Arith_Thms.prod_cancel
WithFact ?a * ?b = ?a * ?c
WithFact 0 < ?a
GetFact (?b = ?c, Arith_Thms.prod_cancel) + 1 filters
Arith_Thms.mult_n1n
WithFact ?n = ?m * ?n
WithFact 0 < ?n
GetFact (?m = 1, Arith_Thms.mult_n1n) + 1 filters
Arith_Thms.prod_is_one
WithFact ?x * ?y = 1
GetFact (?x = 1, Arith_Thms.prod_is_one)
Arith_Thms.prod_dvd_intro@back
WithGoal ?k dvd ?m * ?n
GetGoal (?k dvd ?m | ?k dvd ?n, Arith_Thms.prod_dvd_intro@back)
GCD.semiring_gcd_class.gcd_dvd1
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b dvd ?a, GCD.semiring_gcd_class.gcd_dvd1)
GCD.semiring_gcd_class.gcd_dvd2
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b dvd ?b, GCD.semiring_gcd_class.gcd_dvd2)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@eqforward
WithFact coprime ?a ?b
GetFact (gcd ?a ?b = (1::?'a), GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@eqforward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@invbackward
WithGoal coprime ?a ?b
GetGoal (gcd ?a ?b = (1::?'a), GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@invbackward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@eqforward
WithFact gcd ?a ?b = (1::?'a)
GetFact (coprime ?a ?b, GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@eqforward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@invbackward
WithGoal gcd ?a ?b = (1::?'a)
GetGoal (coprime ?a ?b, GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@invbackward)
Arith_Thms.coprime_exp@back
WithGoal coprime ?d (?a ^ ?n)
GetGoal (coprime ?d ?a, Arith_Thms.coprime_exp@back)
Arith_Thms.coprime_exp@back
WithGoal coprime ?d (?a ^ ?n)
GetGoal (coprime ?d ?a, Arith_Thms.coprime_exp@back)
GCD.semiring_gcd_class.gcd.commute
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b = gcd ?b ?a, GCD.semiring_gcd_class.gcd.commute)
Fun.injI@back
WithGoal inj ?f
GetGoal (ALL x y. ?f x = ?f y --> x = y, Fun.injI@back)
Arith_Thms.coprime_dvd_mult@back1
WithGoal ?a dvd ?c
WithFact ?a dvd ?c * ?b
GetGoal (coprime ?a ?b, Arith_Thms.coprime_dvd_mult@back1)
Arith_Thms.coprime_dvd_mult'@back1
WithGoal ?a dvd ?c
WithFact ?a dvd ?b * ?c
GetGoal (coprime ?a ?b, Arith_Thms.coprime_dvd_mult'@back1)
Arith_Thms.coprime_dvd
WithFact coprime ?a ?b
WithFact ?p dvd ?a
GetFact (1 < ?p --> ~ ?p dvd ?b, Arith_Thms.coprime_dvd)
Power.power_class.power.power_0
WithTerm ?a ^ 0
GetFact (?a ^ 0 = (1::?'a), Power.power_class.power.power_0)
Add ac data for function Lattices.inf_class.inf
Add ac data for function Lattices.sup_class.sup
Arith_Thms.power_ge_0
WithTerm ?p ^ ?m
WithGoal ?m = 0
GetFact (?p ^ ?m = ?p * ?p ^ (?m - 1), Arith_Thms.power_ge_0)
Set.mem_Collect_eq@eqforward
WithFact ?a : Collect ?P
GetFact (?P ?a, Set.mem_Collect_eq@eqforward)
Set.mem_Collect_eq@invbackward
WithGoal ?a : Collect ?P
GetGoal (?P ?a, Set.mem_Collect_eq@invbackward)
Power.monoid_mult_class.power_one
WithTerm (1::?'a) ^ ?n
GetFact ((1::?'a) ^ ?n = (1::?'a), Power.monoid_mult_class.power_one) + 1 filters
Set_Thms.ball_single@eqforward
WithFact ALL x:{?x}. ?P x
GetFact (?P ?x, Set_Thms.ball_single@eqforward)
Set_Thms.ball_single@invbackward
WithGoal ALL x:{?x}. ?P x
GetGoal (?P ?x, Set_Thms.ball_single@invbackward)
Power.monoid_mult_class.power_one_right
WithTerm ?a ^ 1
GetFact (?a ^ 1 = ?a, Power.monoid_mult_class.power_one_right) + 1 filters
Set.singleton_iff@eqforward
WithFact ?b : {?a}
GetFact (?b = ?a, Set.singleton_iff@eqforward)
Set.singleton_iff@invbackward
WithGoal ?b : {?a}
GetGoal (?b = ?a, Set.singleton_iff@invbackward)
Set.empty_iff@eqforward
WithFact ?c : {}
GetResolve Set.empty_iff@eqforward
Arith_Thms.one_is_power_of_any@res
WithGoal EX i. 1 = ?a ^ i
GetResolve Arith_Thms.one_is_power_of_any@res
Set_Thms.set_membership_distinct
WithFact ?x : ?s
WithGoal ?y : ?s
GetGoal (?x = ?y, Set_Thms.set_membership_distinct)
Power.power_class.power.power_Suc
WithTerm ?a ^ Suc ?n
GetFact (?a ^ Suc ?n = ?a * ?a ^ ?n, Power.power_class.power.power_Suc)
Set_Thms.non_empty_exist_elt@back
WithGoal EX x. x : ?U
GetFact (?U = {}, Set_Thms.non_empty_exist_elt@back)
Set_Thms.non_univ_exist_compl@back
WithGoal EX x. x ~: ?U
GetFact (?U = UNIV, Set_Thms.non_univ_exist_compl@back)
Arith_Thms.power_dvd
WithFact ?p ^ ?n dvd ?a
WithGoal ?n = 0
GetFact (?p dvd ?a, Arith_Thms.power_dvd)
Set.UNIV_I@res
WithGoal ?x : UNIV
GetResolve Set.UNIV_I@res
Arith_Thms.power_eq_one
WithFact ?b ^ ?n = 1
GetFact (?b = 1 | ?n = 0, Arith_Thms.power_eq_one) + 2 filters
Set.insert_iff@eqbackward@back
WithGoal ?a : insert ?b ?A
GetGoal (?a = ?b | ?a : ?A, Set.insert_iff@eqbackward@back) + 1 filters
Arith_Thms.fact_ge_1_nat
WithTerm fact ?n
GetFact (1 <= fact ?n, Arith_Thms.fact_ge_1_nat)
Set.insert_iff@eqforward
WithFact ?a : insert ?b ?A
WithScore 500
GetFact (?a = ?b | ?a : ?A, Set.insert_iff@eqforward) + 1 filters
Factorial.dvd_fact@back1
WithGoal ?m dvd fact ?n
WithFact ?m <= ?n
GetGoal (1 <= ?m, Factorial.dvd_fact@back1)
Nat.Suc_eq_plus1
WithTerm Suc ?n
GetFact (Suc ?n = ?n + 1, Nat.Suc_eq_plus1)
Set.insert_subset@eqforward
WithFact insert ?x ?A <= ?B
GetFact (?x : ?B & ?A <= ?B, Set.insert_subset@eqforward) + 1 filters
Nat.gr0_implies_Suc@back
WithGoal EX m. ?n = Suc m
GetGoal (0 < ?n, Nat.gr0_implies_Suc@back)
Set.insert_subset@eqbackward@back
WithGoal insert ?x ?A <= ?B
WithScore 500
GetGoal (?x : ?B & ?A <= ?B, Set.insert_subset@eqbackward@back) + 1 filters
Nat.nat.case_1
WithTerm case 0 of 0 => ?f1.0 | Suc x => ?f2.0 x
GetFact ((case 0 of 0 => ?f1.0 | Suc x => ?f2.0 x) = ?f1.0, Nat.nat.case_1)
Nat.nat.case_2
WithTerm case Suc ?x2.0 of 0 => ?f1.0 | Suc x => ?f2.0 x
GetFact ((case Suc ?x2.0 of 0 => ?f1.0 | Suc x => ?f2.0 x) = ?f2.0 ?x2.0, Nat.nat.case_2)
Set_Thms.set_ext
WithFact ALL a. (a : ?S) = (a : ?T)
GetFact (?S = ?T, Set_Thms.set_ext)
Euclidean_Division.times_div_less_eq_dividend@res
WithGoal ?n * (?m div ?n) <= ?m
GetResolve Euclidean_Division.times_div_less_eq_dividend@res
Nat.nat_less_induct
Substitution: ?n, ALL m<?n. ?P m
Set_Thms.set_ext@back
WithGoal ?S = ?T
WithScore 500
GetGoal (ALL a. (a : ?S) = (a : ?T), Set_Thms.set_ext@back) + 1 filters
### theory "Auto2_HOL.Arith_Thms"
### 1.735s elapsed time, 6.810s cpu time, 1.535s GC time
Set_Thms.set_pair_ext
WithFact ALL a b. ((a, b) : ?S) = ((a, b) : ?T)
GetFact (?S = ?T, Set_Thms.set_pair_ext)
Set.Un_iff@eqforward
WithFact ?c : ?A Un ?B
WithScore 500
GetFact (?c : ?A | ?c : ?B, Set.Un_iff@eqforward)
Set.Un_iff@eqbackward@back
WithGoal ?c : ?A Un ?B
GetGoal (?c : ?A | ?c : ?B, Set.Un_iff@eqbackward@back)
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
Set_Thms.UnD1
WithFact ?c : ?A Un ?B
WithGoal ?c : ?A
GetFact (?c : ?B, Set_Thms.UnD1)
### theory "Draft.ExtrEqs"
### 0.804s elapsed time, 3.301s cpu time, 0.336s GC time
Set_Thms.UnD2
WithFact ?c : ?A Un ?B
WithGoal ?c : ?B
GetFact (?c : ?A, Set_Thms.UnD2)
Set_Thms.UnD1_single
WithFact ?c : {?a} Un ?B
WithGoal ?c = ?a
GetFact (?c : ?B, Set_Thms.UnD1_single)
Set_Thms.UnD2_single
WithFact ?c : ?A Un {?b}
WithGoal ?c = ?b
GetFact (?c : ?A, Set_Thms.UnD2_single)
Set.UnI1
WithTerm ?A Un ?B
WithFact ?c : ?A
GetFact (?c : ?A Un ?B, Set.UnI1)
Set.UnI2
WithTerm ?A Un ?B
WithFact ?c : ?B
GetFact (?c : ?A Un ?B, Set.UnI2)
Set_Thms.UnI1_single
WithTerm {?a} Un ?B
GetFact (?a : {?a} Un ?B, Set_Thms.UnI1_single)
Set_Thms.UnI2_single
WithTerm ?A Un {?b}
GetFact (?b : ?A Un {?b}, Set_Thms.UnI2_single)
Set_Thms.union_single_eq
WithTerm {?x} Un ?p
WithFact ?x : ?p
GetFact ({?x} Un ?p = ?p, Set_Thms.union_single_eq)
Set_Thms.union_single_eq@back
WithGoal {?x} Un ?p = ?p
GetGoal (?x : ?p, Set_Thms.union_single_eq@back)
Set.Int_iff@eqforward
WithFact ?c : ?A Int ?B
GetFact (?c : ?A & ?c : ?B, Set.Int_iff@eqforward)
Set.Int_iff@eqbackward@back
WithGoal ?c : ?A Int ?B
WithScore 500
GetGoal (?c : ?A & ?c : ?B, Set.Int_iff@eqbackward@back)
Set.Int_empty_left
WithTerm {} Int ?B
GetFact ({} Int ?B = {}, Set.Int_empty_left)
Set.Int_empty_right
WithTerm ?A Int {}
GetFact (?A Int {} = {}, Set.Int_empty_right)
Set.Int_absorb
WithTerm ?A Int ?A
GetFact (?A Int ?A = ?A, Set.Int_absorb)
Set_Thms.set_disjoint_mp
WithFact ?A Int ?B = {}
WithFact ?p : ?A
GetGoal (?p : ?B, Set_Thms.set_disjoint_mp)
Set_Thms.set_disjoint_mp@back2
WithFact ?p : ?B
WithFact ?A Int ?B = {}
GetGoal (?p : ?A, Set_Thms.set_disjoint_mp@back2)
Set_Thms.set_disjoint_single@eqforward
WithFact {?x} Int ?B = {}
GetGoal (?x : ?B, Set_Thms.set_disjoint_single@eqforward)
Set_Thms.set_disjoint_single@invbackward
WithGoal {?x} Int ?B = {}
GetFact (?x : ?B, Set_Thms.set_disjoint_single@invbackward)
Set.subsetI
WithFact ALL x. x : ?A --> x : ?B
GetFact (?A <= ?B, Set.subsetI)
Set.subsetI@back
WithGoal ?A <= ?B
WithScore 500
GetGoal (ALL x. x : ?A --> x : ?B, Set.subsetI@back)
Set.empty_subsetI@res
WithGoal {} <= ?A
GetResolve Set.empty_subsetI@res
Set.subsetD
WithFact ?A <= ?B
WithFact ?c : ?A
GetFact (?c : ?B, Set.subsetD)
Set_Thms.subset_single@eqforward
WithFact {?a} <= ?B
GetFact (?a : ?B, Set_Thms.subset_single@eqforward)
Set_Thms.subset_single@invbackward
WithGoal {?a} <= ?B
GetGoal (?a : ?B, Set_Thms.subset_single@invbackward)
Set.basic_monos_1@res
WithGoal ?A <= ?A
GetResolve Set.basic_monos_1@res
Set.Un_upper1@res
WithGoal ?A <= ?A Un ?B
GetResolve Set.Un_upper1@res
Set.Un_upper2@res
WithGoal ?B <= ?A Un ?B
GetResolve Set.Un_upper2@res
Set_Thms.union_is_subset
WithFact ?A Un ?B <= ?C
GetFact (?A <= ?C & ?B <= ?C, Set_Thms.union_is_subset)
Set.Un_least@back1
WithGoal ?A Un ?B <= ?C
WithFact ?B <= ?C
GetGoal (?A <= ?C, Set.Un_least@back1)
Set.Un_least@back2
WithGoal ?A Un ?B <= ?C
WithFact ?A <= ?C
GetGoal (?B <= ?C, Set.Un_least@back2)
Set_Thms.subset_union_same1@back
WithGoal ?A Un ?B <= ?A Un ?C
GetGoal (?B <= ?C, Set_Thms.subset_union_same1@back)
Set_Thms.subset_union_same2@back
WithGoal ?A Un ?C <= ?B Un ?C
GetGoal (?A <= ?B, Set_Thms.subset_union_same2@back)
Set.Diff_iff@eqforward
WithFact ?c : ?A - ?B
GetFact (?c : ?A & ?c ~: ?B, Set.Diff_iff@eqforward)
Set.Diff_iff@eqbackward@back
WithGoal ?c : ?A - ?B
WithScore 500
GetGoal (?c : ?A & ?c ~: ?B, Set.Diff_iff@eqbackward@back)
Set.empty_Diff
WithTerm {} - ?A
GetFact ({} - ?A = {}, Set.empty_Diff)
Set_Thms.mem_diff@eqforward
WithFact ?x : ?A - ?B
GetFact (?x : ?A & ?x ~: ?B, Set_Thms.mem_diff@eqforward)
Set_Thms.mem_diff@invbackward
WithGoal ?x : ?A - ?B
GetGoal (?x : ?A & ?x ~: ?B, Set_Thms.mem_diff@invbackward)
Set_Thms.set_union_minus_same1
WithTerm ?A Un ?B - ?B
GetFact (?A Un ?B - ?B = ?A - ?B, Set_Thms.set_union_minus_same1)
Set_Thms.set_union_minus_same2
WithTerm ?B Un ?A - ?B
GetFact (?B Un ?A - ?B = ?A - ?B, Set_Thms.set_union_minus_same2)
Set_Thms.set_union_minus_distinct
WithTerm {?a} Un (?B - {?c})
WithGoal ?a = ?c
GetFact ({?a} Un (?B - {?c}) = {?a} Un ?B - {?c}, Set_Thms.set_union_minus_distinct)
Set.Diff_subset
WithTerm ?A - ?B
GetFact (?A - ?B <= ?A, Set.Diff_subset)
Set_Thms.union_subtract_elt1
WithTerm {?x} Un ?B - {?x}
WithGoal ?x : ?B
GetFact ({?x} Un ?B - {?x} = ?B, Set_Thms.union_subtract_elt1)
Set_Thms.union_subtract_elt2
WithTerm ?B Un {?x} - {?x}
WithGoal ?x : ?B
GetFact (?B Un {?x} - {?x} = ?B, Set_Thms.union_subtract_elt2)
Set_Thms.subset_sub1@back
WithGoal ?A - {?x} < ?A
GetGoal (?x : ?A, Set_Thms.subset_sub1@back)
Set_Thms.member_notin
WithFact ?x : ?S - {?y}
GetGoal (?x = ?y, Set_Thms.member_notin)
Set_Thms.member_notin_contra
WithTerm ?S - {?y}
WithFact ?x : ?S
GetFact (?x ~= ?y --> ?x : ?S - {?y}, Set_Thms.member_notin_contra)
Finite_Set.finite.emptyI@res
WithGoal finite {}
GetResolve Finite_Set.finite.emptyI@res
Set_Thms.set_finite_single@res
WithGoal finite {?x}
GetResolve Set_Thms.set_finite_single@res
Finite_Set.finite_Un@eqforward
WithFact finite (?F Un ?G)
GetFact (finite ?F & finite ?G, Finite_Set.finite_Un@eqforward)
Finite_Set.finite_Un@invbackward
WithGoal finite (?F Un ?G)
GetGoal (finite ?F & finite ?G, Finite_Set.finite_Un@invbackward)
Set_Thms.Max_ge'
WithProperty finite ?A
WithFact Max ?A < ?x
GetGoal (?x : ?A, Set_Thms.Max_ge')
Finite_Set.finite_image_set@back
WithGoal finite {?f x |x. ?P x}
GetGoal (finite {x. ?P x}, Finite_Set.finite_image_set@back)
Add property rule for function Set_Interval.ord_class.atLeastAtMost
Finite_Set.rev_finite_subset
WithProperty finite ?B
WithFact ?A <= ?B
GetFact (finite ?A, Finite_Set.rev_finite_subset)
Finite_Set.rev_finite_subset@back1
WithGoal finite ?A
WithFact ?A <= ?B
GetGoal (finite ?B, Finite_Set.rev_finite_subset@back1)
Finite_Set.card.empty
WithTerm card {}
GetFact (card {} = 0, Finite_Set.card.empty)
Set_Thms.card_emptyD
WithProperty finite ?S
WithTerm ?S
WithFact card ?S = 0
GetFact (?S = {}, Set_Thms.card_emptyD)
Set_Thms.card_minus1
WithTerm card (?S - {?x})
WithFact ?x : ?S
GetFact (card (?S - {?x}) = card ?S - 1, Set_Thms.card_minus1)
Add property rule for function Groups.minus_class.minus
Finite_Set.card_mono@res
WithProperty finite ?B
WithGoal card ?A <= card ?B
WithFact ?A <= ?B
GetResolve Finite_Set.card_mono@res
Set.image_Un
WithTerm ?f ` (?A Un ?B)
GetFact (?f ` (?A Un ?B) = ?f ` ?A Un ?f ` ?B, Set.image_Un)
Fun.image_set_diff
WithTerm ?f ` (?A - ?B)
WithFact inj ?f
GetFact (?f ` (?A - ?B) = ?f ` ?A - ?f ` ?B, Fun.image_set_diff)
Set_Thms.mset_member_empty@res
WithFact ?p :# {#}
GetResolve Set_Thms.mset_member_empty@res
Set_Thms.mem_multiset_single@eqforward
WithFact ?x :# {#?y#}
GetFact (?x = ?y, Set_Thms.mem_multiset_single@eqforward)
Set_Thms.mem_multiset_single@invbackward
WithGoal ?x :# {#?y#}
GetGoal (?x = ?y, Set_Thms.mem_multiset_single@invbackward)
Multiset.subset_mset.antisym@back2
WithGoal ?a = ?b
WithFact ?a <=# ?b
GetGoal (?b <=# ?a, Multiset.subset_mset.antisym@back2)
Multiset.empty_le@res
WithGoal {#} <=# ?A
GetResolve Multiset.empty_le@res
Multiset.mset_subsetD
WithFact ?A <# ?B
WithFact ?x :# ?A
GetFact (?x :# ?B, Multiset.mset_subsetD)
Set_Thms.multi_contain_add_self1@res
WithGoal ?A <# {#?x#} + ?A
GetResolve Set_Thms.multi_contain_add_self1@res
Set_Thms.multi_contain_add_self2@res
WithGoal ?A <# ?A + {#?x#}
GetResolve Set_Thms.multi_contain_add_self2@res
Multiset.multi_member_this
WithTerm {#?x#} + ?XS
GetFact (?x :# {#?x#} + ?XS, Multiset.multi_member_this)
Set_Thms.multi_member_this2
WithTerm ?XS + {#?x#}
GetFact (?x :# ?XS + {#?x#}, Set_Thms.multi_member_this2)
Multiset.subset_mset.add_left_mono@back
WithGoal ?c + ?a <=# ?c + ?b
GetGoal (?a <=# ?b, Multiset.subset_mset.add_left_mono@back)
Multiset.subset_mset.add_right_mono@back
WithGoal ?a + ?c <=# ?b + ?c
GetGoal (?a <=# ?b, Multiset.subset_mset.add_right_mono@back)
Set_Thms.multi_nonempty_split'@res
WithGoal EX M' m. ?M = M' + {#m#}
WithGoal ?M = {#}
GetResolve Set_Thms.multi_nonempty_split'@res
Set_Thms.multi_member_split'@back
WithGoal EX M'. ?M = M' + {#?x#}
GetGoal (?x :# ?M, Set_Thms.multi_member_split'@back)
Multiset.full_multiset_induct
Substitution: ?B, ALL A. A <# ?B --> ?P A
Multiset.set_mset_empty
WithTerm set_mset {#}
GetFact (set_mset {#} = {}, Multiset.set_mset_empty)
Multiset.set_mset_single
WithTerm set_mset {#?b#}
GetFact (set_mset {#?b#} = {?b}, Multiset.set_mset_single)
Multiset.set_mset_union
WithTerm set_mset (?M + ?N)
GetFact (set_mset (?M + ?N) = set_mset ?M Un set_mset ?N, Multiset.set_mset_union)
Multiset.image_mset_empty
WithTerm image_mset ?f {#}
GetFact (image_mset ?f {#} = {#}, Multiset.image_mset_empty)
Multiset.image_mset_single
WithTerm image_mset ?f {#?x#}
GetFact (image_mset ?f {#?x#} = {#?f ?x#}, Multiset.image_mset_single)
Multiset.image_mset_union
WithTerm image_mset ?f (?M + ?N)
GetFact (image_mset ?f (?M + ?N) = image_mset ?f ?M + image_mset ?f ?N, Multiset.image_mset_union)
consts
  execute :: "'a Heap => heap => ('a * heap) option"
Multiset.comm_monoid_mult_class.prod_mset_empty
WithTerm \<Prod>\<^sub># {#}
GetFact (\<Prod>\<^sub># {#} = (1::?'a), Multiset.comm_monoid_mult_class.prod_mset_empty)
Multiset.comm_monoid_mult_class.prod_mset_singleton
WithTerm \<Prod>\<^sub># {#?x#}
GetFact (\<Prod>\<^sub># {#?x#} = ?x, Multiset.comm_monoid_mult_class.prod_mset_singleton)
Multiset.comm_monoid_mult_class.prod_mset_Un
WithTerm \<Prod>\<^sub># (?A + ?B)
GetFact (\<Prod>\<^sub># (?A + ?B) = \<Prod>\<^sub># ?A * \<Prod>\<^sub># ?B, Multiset.comm_monoid_mult_class.prod_mset_Un)
Set_Interval.ord_class.lessThan_iff@eqforward
WithFact ?i : {..<?k}
GetFact (?i < ?k, Set_Interval.ord_class.lessThan_iff@eqforward)
Set_Interval.ord_class.lessThan_iff@invbackward
WithGoal ?i : {..<?k}
GetGoal (?i < ?k, Set_Interval.ord_class.lessThan_iff@invbackward)
Set_Interval.ord_class.atLeastAtMost_iff@eqforward
WithFact ?i : {?l..?u}
GetFact (?l <= ?i & ?i <= ?u, Set_Interval.ord_class.atLeastAtMost_iff@eqforward)
Set_Interval.ord_class.atLeastAtMost_iff@invbackward
WithGoal ?i : {?l..?u}
GetGoal (?l <= ?i & ?i <= ?u, Set_Interval.ord_class.atLeastAtMost_iff@invbackward)
### theory "Auto2_HOL.Set_Thms"
### 0.528s elapsed time, 1.849s cpu time, 0.180s GC time
Loading theory "Auto2_HOL.Lists_Thms" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base" via "Auto2_HOL.Auto2_Main")
List.list.distinct_2@res
WithFact ?x21.0 # ?x22.0 = []
GetResolve List.list.distinct_2@res
List.list.simps_1@eqforward
WithFact ?x21.0 # ?x22.0 = ?y21.0 # ?y22.0
GetFact (?x21.0 = ?y21.0 & ?x22.0 = ?y22.0, List.list.simps_1@eqforward)
List.list.sel_1
WithTerm hd (?x21.0 # ?x22.0)
GetFact (hd (?x21.0 # ?x22.0) = ?x21.0, List.list.sel_1)
List.list.sel_2
WithTerm tl []
GetFact (tl [] = [], List.list.sel_2)
List.list.sel_3
WithTerm tl (?x21.0 # ?x22.0)
GetFact (tl (?x21.0 # ?x22.0) = ?x22.0, List.list.sel_3)
List.list.collapse
WithTerm hd ?list # tl ?list
WithGoal ?list = []
GetFact (hd ?list # tl ?list = ?list, List.list.collapse)
List.list.size_3
WithTerm length []
GetFact (length [] = 0, List.list.size_3)
Lists_Thms.length_one
WithTerm length [?x]
GetFact (length [?x] = 1, Lists_Thms.length_one)
Lists_Thms.length_Cons
WithTerm length (?a # ?b)
GetFact (length (?a # ?b) = length ?b + 1, Lists_Thms.length_Cons)
Lists_Thms.length_snoc
WithTerm length (?xs @ [?x])
GetFact (length (?xs @ [?x]) = length ?xs + 1, Lists_Thms.length_snoc)
Lists_Thms.length_zero_is_nil
WithFact length ?xs = 0
GetFact (?xs = [], Lists_Thms.length_zero_is_nil)
Lists_Thms.length_gt_zero
WithFact 0 < length ?xs
GetGoal (?xs = [], Lists_Thms.length_gt_zero)
List.length_append
WithTerm length (?xs @ ?ys)
GetFact (length (?xs @ ?ys) = length ?xs + length ?ys, List.length_append)
List.append.simps_2
WithTerm (?x # ?xs) @ ?ys
GetFact ((?x # ?xs) @ ?ys = ?x # ?xs @ ?ys, List.append.simps_2) + 1 filters
List.hd_append2
WithTerm hd (?xs @ ?ys)
WithGoal ?xs = []
GetFact (hd (?xs @ ?ys) = hd ?xs, List.hd_append2)
Lists_Thms.append_is_empty
WithFact ?xs @ ?ys = []
GetFact (?xs = [] & ?ys = [], Lists_Thms.append_is_empty)
Lists_Thms.cons_to_append@sym
WithTerm [?a] @ ?b
GetFact ([?a] @ ?b = ?a # ?b, Lists_Thms.cons_to_append@sym)
signature LIST_AC =
  sig
    val add_list_proofsteps: theory -> theory
    val append_const: typ -> term
    val case_head: typ -> term -> heads
    val dest_list_full: Proof.context -> typ -> cterm -> cterm list
    val get_list_head_equiv:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val get_list_ty: term -> typ option
    datatype heads = LIST_APPEND | LIST_CONS | LIST_NIL | LIST_OTHER
    val is_list_head: typ -> term -> bool
    val list_expand:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val list_expand_equiv: proofstep
    val list_expand_once:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val list_expand_unit: proofstep
    val normalize_list: typ -> conv
    val normalize_list_assoc: typ -> conv
    val rewrite_on_eqs: typ -> thm list -> cterm -> thm
    val simp_list_expr:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
  end
structure List_AC: LIST_AC
val test_norm_t = fn: string -> string * string -> unit
val test = [(), (), (), (), (), (), (), (), (), (), (), ()]: unit list
List.nth_equalityI@back2
WithGoal ?xs = ?ys
WithFact length ?xs = length ?ys
GetGoal (ALL i<length ?xs. ?xs ! i = ?ys ! i, List.nth_equalityI@back2) + 1 filters
List.set_simps_1
WithTerm set []
GetFact (set [] = {}, List.set_simps_1)
Lists_Thms.set_one
WithTerm set [?u]
GetFact (set [?u] = {?u}, Lists_Thms.set_one)
Lists_Thms.set_two
WithTerm set [?u, ?v]
GetFact (set [?u, ?v] = {?u, ?v}, Lists_Thms.set_two)
Lists_Thms.set_simps2
WithTerm set (?x # ?xs)
GetFact (set (?x # ?xs) = {?x} Un set ?xs, Lists_Thms.set_simps2) + 2 filters
List.set_append
WithTerm set (?xs @ ?ys)
GetFact (set (?xs @ ?ys) = set ?xs Un set ?ys, List.set_append)
List.set_rev
WithTerm set (rev ?xs)
GetFact (set (rev ?xs) = set ?xs, List.set_rev)
List.finite_set@res
WithGoal finite (set ?xs)
GetResolve List.finite_set@res
List.in_set_conv_nth@eqforward@back
WithGoal EX i<length ?xs. ?xs ! i = ?x
GetGoal (?x : set ?xs, List.in_set_conv_nth@eqforward@back)
List.hd_in_set
WithWellForm ?xs ~= []
WithTerm hd ?xs
GetFact (hd ?xs : set ?xs, List.hd_in_set)
List.length_tl
WithTerm length (tl ?xs)
GetFact (length (tl ?xs) = length ?xs - 1, List.length_tl)
Lists_Thms.nth_tl'
WithTerm tl ?xs ! ?i
WithFact ?i < length (tl ?xs)
GetFact (tl ?xs ! ?i = ?xs ! (?i + 1), Lists_Thms.nth_tl')
Lists_Thms.set_tl_subset
WithTerm set (tl ?xs)
GetFact (set (tl ?xs) <= set ?xs, Lists_Thms.set_tl_subset)
List.nth_case
WithTerm ?xs ! ?i
CreateConcl ?i < length ?xs
List.hd_conv_nth@sym
WithTerm ?xs ! 0
WithGoal ?xs = []
GetFact (?xs ! 0 = hd ?xs, List.hd_conv_nth@sym)
List.nth_Cons'
WithTerm (?x # ?xs) ! ?n
GetFact ((?x # ?xs) ! ?n = (if ?n = 0 then ?x else ?xs ! (?n - 1)), List.nth_Cons')
List.nth_append
WithTerm (?xs @ ?ys) ! ?n
GetFact ((?xs @ ?ys) ! ?n =
(if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs)), List.nth_append)
List.nth_mem
WithWellForm ?n < length ?xs
WithTerm ?xs ! ?n
GetFact (?xs ! ?n : set ?xs, List.nth_mem)
Lists_Thms.sorted_Nil@res
WithGoal Lists_Thms.sorted []
GetResolve Lists_Thms.sorted_Nil@res
Lists_Thms.sorted_single@res
WithGoal Lists_Thms.sorted [?x]
GetResolve Lists_Thms.sorted_single@res
Lists_Thms.sorted_simps2@eqbackward@back
WithGoal Lists_Thms.sorted (?x # ?ys)
GetGoal (Ball (set ?ys) ((<=) ?x) & Lists_Thms.sorted ?ys, Lists_Thms.sorted_simps2@eqbackward@back)
Lists_Thms.sorted_ConsD1
WithFact Lists_Thms.sorted (?x # ?xs)
GetFact (Lists_Thms.sorted ?xs, Lists_Thms.sorted_ConsD1)
Lists_Thms.sorted_ConsD2
WithFact Lists_Thms.sorted (?x # ?xs)
WithFact ?y : set ?xs
GetFact (?x <= ?y, Lists_Thms.sorted_ConsD2)
Lists_Thms.sorted_ConsD2@back2
WithGoal ?x <= ?y
WithFact Lists_Thms.sorted (?x # ?xs)
GetGoal (?y : set ?xs, Lists_Thms.sorted_ConsD2@back2)
Lists_Thms.sorted_appendI@back
WithGoal Lists_Thms.sorted (?xs @ ?ys)
GetGoal (Lists_Thms.sorted ?xs &
Lists_Thms.sorted ?ys & (ALL x:set ?xs. ALL y:set ?ys. x <= y), Lists_Thms.sorted_appendI@back)
Lists_Thms.sorted_appendE
WithFact Lists_Thms.sorted (?xs @ ?ys)
GetFact (Lists_Thms.sorted ?xs & Lists_Thms.sorted ?ys, Lists_Thms.sorted_appendE)
Lists_Thms.sorted_appendE2
WithFact Lists_Thms.sorted (?xs @ ?ys)
WithFact ?x : set ?xs
GetFact (ALL y:set ?ys. ?x <= y, Lists_Thms.sorted_appendE2)
Lists_Thms.sorted_nth_mono'@back
WithProperty Lists_Thms.sorted ?xs
WithWellForm ?j < length ?xs
WithGoal ?xs ! ?i <= ?xs ! ?j
GetGoal (?i <= ?j, Lists_Thms.sorted_nth_mono'@back)
Lists_Thms.sorted_nth_mono_less
WithProperty Lists_Thms.sorted ?xs
WithWellForm ?i < length ?xs
WithFact ?xs ! ?i < ?xs ! ?j
GetFact (?i < ?j, Lists_Thms.sorted_nth_mono_less)
Lists_Thms.sorted_sort
WithTerm sort ?xs
GetFact (Lists_Thms.sorted (sort ?xs), Lists_Thms.sorted_sort)
List.linorder_class.length_sort
WithTerm length (sort_key ?f ?xs)
GetFact (length (sort_key ?f ?xs) = length ?xs, List.linorder_class.length_sort)
Multiset.linorder_class.mset_sort
WithTerm mset (sort_key ?k ?xs)
GetFact (mset (sort_key ?k ?xs) = mset ?xs, Multiset.linorder_class.mset_sort)
List.linorder_class.set_sort
WithTerm set (sort_key ?f ?xs)
GetFact (set (sort_key ?f ?xs) = set ?xs, List.linorder_class.set_sort)
Lists_Thms.properties_for_sort@back
WithGoal sort ?xs = ?ys
GetGoal (mset ?ys = mset ?xs & Lists_Thms.sorted ?ys, Lists_Thms.properties_for_sort@back)
Lists_Thms.sort_Nil
WithTerm sort []
GetFact (sort [] = [], Lists_Thms.sort_Nil)
Lists_Thms.sort_singleton
WithTerm sort [?a]
GetFact (sort [?a] = [?a], Lists_Thms.sort_singleton)
Lists_Thms.distinct_Nil@res
WithGoal distinct []
GetResolve Lists_Thms.distinct_Nil@res
List.distinct_singleton@res
WithGoal distinct [?x]
GetResolve List.distinct_singleton@res
List.distinct.simps_2@eqforward
WithFact distinct (?x # ?xs)
GetFact (?x ~: set ?xs & distinct ?xs, List.distinct.simps_2@eqforward) + 1 filters
List.distinct.simps_2@invbackward
WithGoal distinct (?x # ?xs)
GetGoal (?x ~: set ?xs & distinct ?xs, List.distinct.simps_2@invbackward) + 1 filters
List.distinct_append@eqforward
WithFact distinct (?xs @ ?ys)
GetFact (distinct ?xs & distinct ?ys & set ?xs Int set ?ys = {}, List.distinct_append@eqforward)
List.distinct_append@invbackward
WithGoal distinct (?xs @ ?ys)
GetGoal (distinct ?xs & distinct ?ys & set ?xs Int set ?ys = {}, List.distinct_append@invbackward)
List.distinct_rev@eqforward
WithFact distinct (rev ?xs)
GetFact (distinct ?xs, List.distinct_rev@eqforward)
List.distinct_rev@invbackward
WithGoal distinct (rev ?xs)
GetGoal (distinct ?xs, List.distinct_rev@invbackward)
List.linorder_class.distinct_sort@eqforward
WithFact distinct (sort_key ?f ?xs)
GetFact (distinct ?xs, List.linorder_class.distinct_sort@eqforward)
List.linorder_class.distinct_sort@invbackward
WithGoal distinct (sort_key ?f ?xs)
GetGoal (distinct ?xs, List.linorder_class.distinct_sort@invbackward)
List.distinct_conv_nth@eqbackward@res
WithGoal distinct ?xs
WithFact ALL i<length ?xs. ALL j<length ?xs. i ~= j --> ?xs ! i ~= ?xs ! j
GetResolve List.distinct_conv_nth@eqbackward@res
Lists_Thms.distinct_nthE
WithProperty distinct ?xs
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithFact ?xs ! ?i = ?xs ! ?j
GetFact (?i = ?j, Lists_Thms.distinct_nthE)
List.list.map_1
WithTerm map ?f []
GetFact (map ?f [] = [], List.list.map_1)
List.list.map_2
WithTerm map ?f (?x21.0 # ?x22.0)
GetFact (map ?f (?x21.0 # ?x22.0) = ?f ?x21.0 # map ?f ?x22.0, List.list.map_2)
List.length_map
WithTerm length (map ?f ?xs)
GetFact (length (map ?f ?xs) = length ?xs, List.length_map)
List.nth_map
WithTerm map ?f ?xs ! ?n
WithFact ?n < length ?xs
GetFact (map ?f ?xs ! ?n = ?f (?xs ! ?n), List.nth_map)
List.map_append
WithTerm map ?f (?xs @ ?ys)
GetFact (map ?f (?xs @ ?ys) = map ?f ?xs @ map ?f ?ys, List.map_append)
List.length_replicate
WithTerm replicate ?n ?x
GetFact (length (replicate ?n ?x) = ?n, List.length_replicate)
List.nth_replicate
WithTerm replicate ?n ?x ! ?i
WithFact ?i < ?n
GetFact (replicate ?n ?x ! ?i = ?x, List.nth_replicate)
Lists_Thms.last_eval1
WithTerm last [?x]
GetFact (last [?x] = ?x, Lists_Thms.last_eval1)
Lists_Thms.last_eval2
WithTerm last [?u, ?v]
GetFact (last [?u, ?v] = ?v, Lists_Thms.last_eval2)
List.last_ConsR
WithTerm last (?x # ?xs)
WithGoal ?xs = []
GetFact (last (?x # ?xs) = last ?xs, List.last_ConsR)
List.last_appendR
WithTerm last (?xs @ ?ys)
WithGoal ?ys = []
GetFact (last (?xs @ ?ys) = last ?ys, List.last_appendR)
List.last_snoc
WithTerm last (?xs @ [?x])
GetFact (last (?xs @ [?x]) = ?x, List.last_snoc)
List.last_conv_nth@sym
WithTerm ?xs ! (length ?xs - 1)
WithGoal ?xs = []
GetFact (?xs ! (length ?xs - 1) = last ?xs, List.last_conv_nth@sym)
List.last_in_set
WithWellForm ?as ~= []
WithTerm last ?as
GetFact (last ?as : set ?as, List.last_in_set)
List.length_butlast
WithTerm butlast ?xs
GetFact (length (butlast ?xs) = length ?xs - 1, List.length_butlast)
List.nth_butlast
WithWellForm ?n < length (butlast ?xs)
WithTerm butlast ?xs ! ?n
GetFact (butlast ?xs ! ?n = ?xs ! ?n, List.nth_butlast)
List.butlast_conv_take@sym
WithTerm take (length ?xs - 1) ?xs
GetFact (take (length ?xs - 1) ?xs = butlast ?xs, List.butlast_conv_take@sym)
List.butlast_snoc
WithTerm butlast (?xs @ [?x])
GetFact (butlast (?xs @ [?x]) = ?xs, List.butlast_snoc)
Lists_Thms.butlast_eval1
WithTerm butlast [?x]
GetFact (butlast [?x] = [], Lists_Thms.butlast_eval1)
Lists_Thms.butlast_eval2
WithTerm butlast [?x, ?y]
GetFact (butlast [?x, ?y] = [?x], Lists_Thms.butlast_eval2)
Lists_Thms.butlast_cons
WithTerm butlast (?a # ?as)
WithGoal ?as = []
GetFact (butlast (?a # ?as) = ?a # butlast ?as, Lists_Thms.butlast_cons)
Lists_Thms.butlast_append'
WithTerm butlast (?as @ ?bs)
WithGoal ?bs = []
GetFact (butlast (?as @ ?bs) = ?as @ butlast ?bs, Lists_Thms.butlast_append')
List.append_butlast_last_id
WithWellForm ?xs ~= []
WithTerm butlast ?xs @ [last ?xs]
GetFact (butlast ?xs @ [last ?xs] = ?xs, List.append_butlast_last_id)
Lists_Thms.set_butlast_is_subset
WithTerm set (butlast ?xs)
GetFact (set (butlast ?xs) <= set ?xs, Lists_Thms.set_butlast_is_subset)
List.length_list_update
WithTerm ?xs[?i := ?x]
GetFact (length (?xs[?i := ?x]) = length ?xs, List.length_list_update)
List.nth_list_update_eq
WithWellForm ?i < length ?xs
WithTerm ?xs[?i := ?x] ! ?i
GetFact (?xs[?i := ?x] ! ?i = ?x, List.nth_list_update_eq)
List.nth_list_update_neq
WithTerm ?xs[?i := ?x] ! ?j
WithGoal ?i = ?j
GetFact (?xs[?i := ?x] ! ?j = ?xs ! ?j, List.nth_list_update_neq)
List.nth_list_update
WithWellForm ?i < length ?xs
WithTerm ?xs[?i := ?x] ! ?j
GetFact (?xs[?i := ?x] ! ?j = (if ?i = ?j then ?x else ?xs ! ?j), List.nth_list_update)
List.take_case
WithTerm take ?n ?xs
CreateConcl ?n <= length ?xs
Lists_Thms.length_take
WithWellForm ?n <= length ?xs
WithTerm take ?n ?xs
GetFact (length (take ?n ?xs) = ?n, Lists_Thms.length_take)
Lists_Thms.nth_take
WithWellForm ?i < length (take ?n ?xs)
WithTerm take ?n ?xs ! ?i
GetFact (take ?n ?xs ! ?i = ?xs ! ?i, Lists_Thms.nth_take)
List.take_0
WithTerm take 0 ?xs
GetFact (take 0 ?xs = [], List.take_0)
List.take_Suc_conv_app_nth
WithTerm take (Suc ?i) ?xs
WithFact ?i < length ?xs
GetFact (take (Suc ?i) ?xs = take ?i ?xs @ [?xs ! ?i], List.take_Suc_conv_app_nth)
Lists_Thms.take_length
WithTerm take (length ?xs) ?xs
GetFact (take (length ?xs) ?xs = ?xs, Lists_Thms.take_length)
List.set_take_subset
WithTerm set (take ?n ?xs)
GetFact (set (take ?n ?xs) <= set ?xs, List.set_take_subset)
Lists_Thms.take_Suc
WithWellForm Suc ?n <= length ?xs
WithTerm take (Suc ?n) ?xs
GetFact (take (Suc ?n) ?xs = take ?n ?xs @ [?xs ! ?n], Lists_Thms.take_Suc)
List.take_update_cancel
WithTerm take ?n (?xs[?m := ?y])
WithFact ?n <= ?m
GetFact (take ?n (?xs[?m := ?y]) = take ?n ?xs, List.take_update_cancel)
List.append_take_drop_id
WithTerm take ?n ?xs @ drop ?n ?xs
GetFact (take ?n ?xs @ drop ?n ?xs = ?xs, List.append_take_drop_id)
List.take_all
WithTerm take ?n ?xs
WithFact length ?xs <= ?n
GetFact (take ?n ?xs = ?xs, List.take_all)
List.length_drop
WithTerm drop ?n ?xs
GetFact (length (drop ?n ?xs) = length ?xs - ?n, List.length_drop)
Lists_Thms.nth_drop
WithWellForm ?i < length (drop ?n ?xs)
WithTerm drop ?n ?xs ! ?i
GetFact (drop ?n ?xs ! ?i = ?xs ! (?n + ?i), Lists_Thms.nth_drop)
List.drop_0
WithTerm drop 0 ?xs
GetFact (drop 0 ?xs = ?xs, List.drop_0)
List.drop_all
WithTerm drop ?n ?xs
WithFact length ?xs <= ?n
GetFact (drop ?n ?xs = [], List.drop_all)
List.take_drop@sym
WithTerm drop ?m (take (?n + ?m) ?xs)
GetFact (drop ?m (take (?n + ?m) ?xs) = take ?n (drop ?m ?xs), List.take_drop@sym)
List.drop_drop
WithTerm drop ?n (drop ?m ?xs)
GetFact (drop ?n (drop ?m ?xs) = drop (?n + ?m) ?xs, List.drop_drop)
List.length_rev
WithTerm rev ?xs
GetFact (length (rev ?xs) = length ?xs, List.length_rev)
List.rev.simps_1
WithTerm rev []
GetFact (rev [] = [], List.rev.simps_1)
List.rev.simps_2
WithTerm rev (?x # ?xs)
GetFact (rev (?x # ?xs) = rev ?xs @ [?x], List.rev.simps_2)
List.rev_append
WithTerm rev (?xs @ ?ys)
GetFact (rev (?xs @ ?ys) = rev ?ys @ rev ?xs, List.rev_append)
List.rev_rev_ident
WithTerm rev (rev ?xs)
GetFact (rev (rev ?xs) = ?xs, List.rev_rev_ident)
List.filter.simps_1
WithTerm filter ?P []
GetFact (filter ?P [] = [], List.filter.simps_1)
List.filter.simps_2
WithTerm filter ?P (?x # ?xs)
GetFact (filter ?P (?x # ?xs) = (if ?P ?x then ?x # filter ?P ?xs else filter ?P ?xs), List.filter.simps_2)
List.filter_append
WithTerm filter ?P (?xs @ ?ys)
GetFact (filter ?P (?xs @ ?ys) = filter ?P ?xs @ filter ?P ?ys, List.filter_append)
List.rev_filter
WithTerm rev (filter ?P ?xs)
GetFact (rev (filter ?P ?xs) = filter ?P (rev ?xs), List.rev_filter)
List.rev_filter@sym
WithTerm filter ?P (rev ?xs)
GetFact (filter ?P (rev ?xs) = rev (filter ?P ?xs), List.rev_filter@sym)
List.concat.simps_1
WithTerm concat []
GetFact (concat [] = [], List.concat.simps_1)
List.concat.simps_2
WithTerm concat (?x # ?xs)
GetFact (concat (?x # ?xs) = ?x @ concat ?xs, List.concat.simps_2)
Multiset.mset.simps_1
WithTerm mset []
GetFact (mset [] = {#}, Multiset.mset.simps_1)
Lists_Thms.mset_simps_2
WithTerm mset (?a # ?x)
GetFact (mset (?a # ?x) = mset ?x + {#?a#}, Lists_Thms.mset_simps_2)
Multiset.mset_append
WithTerm mset (?xs @ ?ys)
GetFact (mset (?xs @ ?ys) = mset ?xs + mset ?ys, Multiset.mset_append)
Multiset.mset_eq_setD
WithTerm set ?xs
WithFact mset ?xs = mset ?ys
GetFact (set ?xs = set ?ys, Multiset.mset_eq_setD)
Multiset.in_multiset_in_set@eqforward
WithTerm set ?xs
WithFact ?x :# mset ?xs
GetFact (?x : set ?xs, Multiset.in_multiset_in_set@eqforward)
Multiset.in_multiset_in_set@invbackward
WithTerm set ?xs
WithGoal ?x :# mset ?xs
GetGoal (?x : set ?xs, Multiset.in_multiset_in_set@invbackward)
Multiset.in_multiset_in_set@sym@eqforward
WithTerm mset ?xs
WithFact ?x : set ?xs
GetFact (?x :# mset ?xs, Multiset.in_multiset_in_set@sym@eqforward)
Multiset.in_multiset_in_set@sym@invbackward
WithTerm mset ?xs
WithGoal ?x : set ?xs
GetGoal (?x :# mset ?xs, Multiset.in_multiset_in_set@sym@invbackward)
Multiset.nth_mem_mset@back
WithGoal ?ls ! ?i :# mset ?ls
GetGoal (?i < length ?ls, Multiset.nth_mem_mset@back)
Lists_Thms.in_mset_conv_nth@res
WithGoal EX i<length ?xs. ?x = ?xs ! i
WithFact ?x :# mset ?xs
GetResolve Lists_Thms.in_mset_conv_nth@res
Lists_Thms.hd_in_mset
WithWellForm ?xs ~= []
WithTerm hd ?xs
WithTerm mset ?xs
GetFact (hd ?xs :# mset ?xs, Lists_Thms.hd_in_mset)
Lists_Thms.last_in_mset
WithWellForm ?xs ~= []
WithTerm last ?xs
WithTerm mset ?xs
GetFact (last ?xs :# mset ?xs, Lists_Thms.last_in_mset)
Lists_Thms.mset_butlast
WithTerm mset (butlast ?xs)
WithGoal ?xs = []
GetFact (mset (butlast ?xs) = mset ?xs - {#last ?xs#}, Lists_Thms.mset_butlast)
Lists_Thms.insert_mset_to_set
WithTerm set ?xs'
WithFact mset ?xs' = mset ?xs + {#?x#}
GetFact (set ?xs' = set ?xs Un {?x}, Lists_Thms.insert_mset_to_set)
Lists_Thms.delete_mset_to_set
WithProperty distinct ?xs
WithTerm set ?xs'
WithFact mset ?xs' = mset ?xs - {#?x#}
GetFact (set ?xs' = set ?xs - {?x}, Lists_Thms.delete_mset_to_set)
Lists_Thms.update_mset_to_set
WithProperty distinct ?xs
WithTerm set ?xs'
WithFact mset ?xs' = {#?y#} + (mset ?xs - {#?x#})
GetFact (set ?xs' = set ?xs - {?x} Un {?y}, Lists_Thms.update_mset_to_set)
Lists_Thms.mset_update'
WithWellForm ?i < length ?ls
WithTerm mset (?ls[?i := ?v])
GetFact (mset (?ls[?i := ?v]) = {#?v#} + (mset ?ls - {#?ls ! ?i#}), Lists_Thms.mset_update')
Multiset.mset_swap
WithWellForm ?i < length ?ls
WithWellForm ?j < length ?ls
WithTerm mset (?ls[?j := ?ls ! ?i, ?i := ?ls ! ?j])
GetFact (mset (?ls[?j := ?ls ! ?i, ?i := ?ls ! ?j]) = mset ?ls, Multiset.mset_swap)
List.set_swap
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithTerm set (?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i])
GetFact (set (?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i]) = set ?xs, List.set_swap)
Lists_Thms.upt_zero_length
WithTerm length [0..<?n]
GetFact (length [0..<?n] = ?n, Lists_Thms.upt_zero_length)
Lists_Thms.nth_upt_zero
WithWellForm ?i < length [0..<?n]
WithTerm [0..<?n] ! ?i
GetFact ([0..<?n] ! ?i = ?i, Lists_Thms.nth_upt_zero)
Lists_Thms.list_length
WithTerm list ?s ?n
GetFact (length (list ?s ?n) = ?n, Lists_Thms.list_length)
Lists_Thms.list_nth
WithWellForm ?i < length (list ?s ?n)
WithTerm list ?s ?n ! ?i
GetFact (list ?s ?n ! ?i = ?s ?i, Lists_Thms.list_nth)
List.split_list@res
WithGoal EX ys zs. ?xs = ys @ ?x # zs
WithFact ?x : set ?xs
GetResolve List.split_list@res
List.not_distinct_decomp@back
WithGoal EX xs ys zs y. ?ws = xs @ [y] @ ys @ [y] @ zs
GetFact (distinct ?ws, List.not_distinct_decomp@back)
List.finite_lists_length_le@res
WithProperty finite ?A
WithGoal finite {xs. set xs <= ?A & length xs <= ?n}
GetResolve List.finite_lists_length_le@res
List.distinct_card
WithProperty distinct ?xs
WithTerm card (set ?xs)
GetFact (card (set ?xs) = length ?xs, List.distinct_card)
### theory "Auto2_HOL.Lists_Thms"
### 0.436s elapsed time, 0.889s cpu time, 0.043s GC time
Loading theory "Auto2_HOL.Auto2_Main" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "Draft.SepLogic_Base")
consts
  fold_map :: "('a => 'b Heap) => 'a list => 'b list Heap"
### Cannot skip proof of schematic goal statement
### theory "HOL-Imperative_HOL.Heap_Monad"
### 1.621s elapsed time, 4.892s cpu time, 0.434s GC time
Loading theory "HOL-Imperative_HOL.Array" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL")
### theory "Auto2_HOL.Auto2_Main"
### 0.247s elapsed time, 0.542s cpu time, 0.055s GC time
Loading theory "Draft.Mapping_Str" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.RBTree" via "Draft.Lists_Ex")
Loading theory "Draft.SepLogic_Base" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto")
signature SEP_UTIL =
  sig
    val apply_to_entail_r: conv -> thm -> thm
    val assnT: typ
    val assn_ac_info: ac_info
    val assn_rewr_terms: term -> term list
    val assn_true: term
    val bind_rule_th': thm
    val cdest_entail: cterm -> cterm * cterm
    val dest_entail: term -> term * term
    val dest_hoare_triple: term -> term * term * term
    val emp: term
    val entail_t: term
    val entail_triv_th: Proof.context -> term -> thm
    val entail_true_th: Proof.context -> term -> thm
    val entails_equiv_backward_th: thm
    val entails_equiv_forward_th: thm
    val entails_ex_post_th: thm
    val entails_ex_th: thm
    val entails_frame_th': thm
    val entails_frame_th'': thm
    val entails_pure_post_th: thm
    val entails_pure_th: thm
    val entails_pure_th': thm
    val entails_trans2_th: thm
    val has_pure_assn: term -> bool
    val heap_eq_pat: term
    val hoare_triple_pat: term
    val is_bind_cmd: term -> bool
    val is_entail: term -> bool
    val is_ex_assn: term -> bool
    val is_hoare_triple: term -> bool
    val is_pure_assn: term -> bool
    val is_true_assn: term -> bool
    val mult_emp_left: conv
    val mult_emp_right: conv
    val norm_pre_pure_iff2_th: thm
    val norm_pre_pure_iff_th: thm
    val normalize_assn_cv: Proof.context -> conv
    val normalize_times_cv: Proof.context -> conv
    val post_rule_th': thm
    val pre_ex_rule_th: thm
    val pre_pure_rule_th: thm
    val pre_pure_rule_th': thm
    val pre_rule_th': thm
    val pre_rule_th'': thm
    val pure_conj_th: thm
    val pure_ord: term * term -> bool
    val reduce_emp_right: conv
    val strip_pure_assn: term -> term
  end
type assn_matcher =
   Proof.context -> term * cterm -> id_inst -> id_inst_th list
signature ASSN_MATCHER =
  sig
    val add_assn_matcher: assn_matcher -> theory -> theory
    val add_assn_matcher_proofsteps: theory -> theory
    val add_entail_matcher: thm -> theory -> theory
    val assn_match_all:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val assn_match_single:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val assn_match_strict:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val assn_match_term:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val emp_assn_matcher: assn_matcher
    val triv_assn_matcher: assn_matcher
    val true_assn_matcher: assn_matcher
  end
structure MatchData: THEORY_DATA
functor AssnMatcher (SepUtil: SEP_UTIL): ASSN_MATCHER
signature SEP_LOGIC =
  sig
    val TY_CODE_POS: string
    val TY_ENTAIL: string
    val add_backward_ent_prfstep: thm -> theory -> theory
    val add_forward_ent_prfstep: thm -> theory -> theory
    val add_hoare_triple_prfstep: thm -> theory -> theory
    val add_rewrite_ent_rule: thm -> theory -> theory
    val add_sep_logic_proofsteps: theory -> theory
    val contract_hoare_cv: Proof.context -> conv
    val entail_create_case: proofstep
    val entail_goal_update: Proof.context -> box_id * thm -> raw_update
    val entail_pure: proofstep
    val entails_resolve: proofstep
    val extract_pure_hoare_cv: conv
    val get_first_cmd: term -> term
    val get_hoare_triples: theory -> string -> thm list
    val get_proc_def: theory -> term -> thm list
    val hoare_create_case: proofstep
    val hoare_goal_update: Proof.context -> box_id * thm -> raw_update
    val hoare_triple: proofstep
    val init_entail: proofstep
    val init_pos: proofstep
    val is_bind_cmd: term -> bool
    val is_implies_item: box_item -> bool
    val is_neg_entail: term -> bool
    val is_neg_hoare_triple: term -> bool
    val match_assn_pure: proofstep
    val match_hoare_disj: proofstep
    val match_hoare_prop: proofstep
    val match_hoare_th:
       box_id -> Proof.context -> thm -> thm -> box_item -> raw_update list
    val norm_entail_conds: Proof.context -> conv
    val norm_precond: Proof.context -> conv
    val normalize_entail_goal_cv: Proof.context -> conv
    val normalize_hoare_goal_cv: Proof.context -> conv
    val rewrite_pos: proofstep
    val update_hoare_triple: thm -> theory -> theory
  end
functor SepLogic (SepUtil: SEP_UTIL): SEP_LOGIC
### theory "Draft.SepLogic_Base"
### 0.131s elapsed time, 0.389s cpu time, 0.000s GC time
### theory "HOL-Imperative_HOL.Array"
### 0.322s elapsed time, 0.803s cpu time, 0.073s GC time
Loading theory "HOL-Imperative_HOL.Ref" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto" via "HOL-Imperative_HOL.Imperative_HOL")
Found termination order: "{}"
Mapping_Str.meval.simps
WithTerm Map ?f\<langle>?h\<rangle>
GetFact (Map ?f\<langle>?h\<rangle> = ?f ?h, Mapping_Str.meval.simps)
Mapping_Str.meval_ext@back
WithGoal ?M = ?N
GetGoal (ALL x. ?M\<langle>x\<rangle> = ?N\<langle>x\<rangle>, Mapping_Str.meval_ext@back) + 1 filters
Mapping_Str.empty_map_def
WithTerm empty_map
GetFact (empty_map = Map Map.empty, Mapping_Str.empty_map_def)
Mapping_Str.update_map_def
WithTerm  ?M { ?k \<rightarrow> ?v }
GetFact ( ?M { ?k \<rightarrow> ?v } =
Map (%x. if x = ?k then Some ?v else ?M\<langle>x\<rangle>), Mapping_Str.update_map_def)
Mapping_Str.delete_map_def
WithTerm delete_map ?k ?M
GetFact (delete_map ?k ?M = Map (%x. if x = ?k then None else ?M\<langle>x\<rangle>), Mapping_Str.delete_map_def)
### Ambiguous input (line 211 of "~~/src/HOL/Imperative_HOL/Ref.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Ref.lookup" ("_thenM" ("_position" r) ("_position" f)))
###     ("_position" f)))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_thenM" ("\<^const>Ref.lookup" ("_position" r)) ("_position" f))
###     ("_position" f)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 215 of "~~/src/HOL/Imperative_HOL/Ref.thy") produces 3 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Ref.update" ("_position" r)
###     ("\<^const>HOL.eq" ("_position" e)
###       ("_thenM"
###         ("_applC" ("_position" change)
###           ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###             ("_position" r)))
###         ("_applC" ("_position" return) ("\<^const>Product_Type.Unity"))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("\<^const>Ref.update" ("_position" r) ("_position" e))
###     ("_thenM"
###       ("_applC" ("_position" change)
###         ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###           ("_position" r)))
###       ("_applC" ("_position" return) ("\<^const>Product_Type.Unity")))))
### ("\<^const>HOL.Trueprop"
###   ("_thenM"
###     ("\<^const>Ref.update" ("_position" r)
###       ("\<^const>HOL.eq" ("_position" e)
###         ("_applC" ("_position" change)
###           ("_cargs" ("_lambda" ("_idtdummy") ("_position" e))
###             ("_position" r)))))
###     ("_applC" ("_position" return) ("\<^const>Product_Type.Unity"))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Imperative_HOL.Ref"
### 0.165s elapsed time, 0.330s cpu time, 0.000s GC time
Loading theory "HOL-Imperative_HOL.Imperative_HOL" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.SepAuto")
Mapping_Str.map_of_alist.simps_1
WithTerm map_of_alist []
GetFact (map_of_alist [] = empty_map, Mapping_Str.map_of_alist.simps_1)
Mapping_Str.map_of_alist.simps_2
WithTerm map_of_alist (?x # ?xs)
GetFact (map_of_alist (?x # ?xs) =  map_of_alist ?xs { fst ?x \<rightarrow> snd ?x }, Mapping_Str.map_of_alist.simps_2)
Mapping_Str.has_key_alist_def@eqforward
WithFact has_key_alist ?xs ?a
GetFact (EX p:set ?xs. fst p = ?a, Mapping_Str.has_key_alist_def@eqforward)
Mapping_Str.has_key_alist_def@invbackward
WithGoal has_key_alist ?xs ?a
GetGoal (EX p:set ?xs. fst p = ?a, Mapping_Str.has_key_alist_def@invbackward)
Mapping_Str.map_of_alist_nil@sym@eqforward
WithGoal map_of_alist ?ys\<langle>?x\<rangle> = None
GetFact (has_key_alist ?ys ?x, Mapping_Str.map_of_alist_nil@sym@eqforward)
Mapping_Str.map_of_alist_nil@sym@invbackward
WithFact map_of_alist ?ys\<langle>?x\<rangle> = None
GetGoal (has_key_alist ?ys ?x, Mapping_Str.map_of_alist_nil@sym@invbackward)
Mapping_Str.map_of_alist_nil@eqforward
WithTerm map_of_alist ?ys\<langle>?x\<rangle>
WithFact has_key_alist ?ys ?x
GetGoal (map_of_alist ?ys\<langle>?x\<rangle> = None, Mapping_Str.map_of_alist_nil@eqforward)
Mapping_Str.map_of_alist_nil@invbackward
WithTerm map_of_alist ?ys\<langle>?x\<rangle>
WithGoal has_key_alist ?ys ?x
GetFact (map_of_alist ?ys\<langle>?x\<rangle> = None, Mapping_Str.map_of_alist_nil@invbackward)
Mapping_Str.map_of_alist_some
WithFact map_of_alist ?xs\<langle>?k\<rangle> = Some ?v
GetFact ((?k, ?v) : set ?xs, Mapping_Str.map_of_alist_some)
Mapping_Str.map_of_alist_nil'@eqforward
WithTerm map_of_alist ?ys\<langle>?x\<rangle>
WithFact ?x : set (map fst ?ys)
GetGoal (map_of_alist ?ys\<langle>?x\<rangle> = None, Mapping_Str.map_of_alist_nil'@eqforward)
Mapping_Str.map_of_alist_nil'@invbackward
WithTerm map_of_alist ?ys\<langle>?x\<rangle>
WithGoal ?x : set (map fst ?ys)
GetFact (map_of_alist ?ys\<langle>?x\<rangle> = None, Mapping_Str.map_of_alist_nil'@invbackward)
### theory "HOL-Imperative_HOL.Imperative_HOL"
### 0.026s elapsed time, 0.054s cpu time, 0.000s GC time
Loading theory "Draft.SepAuto" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl")
Mapping_Str.unique_keys_set_def@eqforward
WithFact unique_keys_set ?S
GetFact (ALL i x y. (i, x) : ?S --> (i, y) : ?S --> x = y, Mapping_Str.unique_keys_set_def@eqforward)
Mapping_Str.unique_keys_set_def@invbackward
WithGoal unique_keys_set ?S
GetGoal (ALL i x y. (i, x) : ?S --> (i, y) : ?S --> x = y, Mapping_Str.unique_keys_set_def@invbackward)
Mapping_Str.unique_keys_setD
WithProperty unique_keys_set ?S
WithFact (?i, ?x) : ?S
WithFact (?i, ?y) : ?S
GetFact (?x = ?y, Mapping_Str.unique_keys_setD)
Delete Mapping_Str.unique_keys_set_def@eqforward
Mapping_Str.map_of_aset_def
WithTerm map_of_aset ?S
GetFact (map_of_aset ?S =
Map (%a. if EX b. (a, b) : ?S then Some (THE b. (a, b) : ?S) else None), Mapping_Str.map_of_aset_def)
Mapping_Str.map_of_aset_case
WithTerm map_of_aset ?S
CreateConcl unique_keys_set ?S
Mapping_Str.map_of_asetI1
WithProperty unique_keys_set ?S
WithTerm map_of_aset ?S\<langle>?a\<rangle>
WithFact (?a, ?b) : ?S
GetFact (map_of_aset ?S\<langle>?a\<rangle> = Some ?b, Mapping_Str.map_of_asetI1)
Mapping_Str.map_of_asetI2
WithTerm map_of_aset ?S\<langle>?a\<rangle>
WithFact ALL b. (?a, b) ~: ?S
GetFact (map_of_aset ?S\<langle>?a\<rangle> = None, Mapping_Str.map_of_asetI2)
Mapping_Str.map_of_asetD1
WithFact map_of_aset ?S\<langle>?a\<rangle> = None
GetFact (ALL b. (?a, b) ~: ?S, Mapping_Str.map_of_asetD1)
Mapping_Str.map_of_asetD2
WithProperty unique_keys_set ?S
WithFact map_of_aset ?S\<langle>?a\<rangle> = Some ?b
GetFact ((?a, ?b) : ?S, Mapping_Str.map_of_asetD2)
Delete Mapping_Str.map_of_aset_def
Mapping_Str.map_of_aset_insert
WithTerm map_of_aset (?S Un {(?k, ?v)})
WithFact unique_keys_set (?S Un {(?k, ?v)})
GetFact (map_of_aset (?S Un {(?k, ?v)}) =  map_of_aset ?S { ?k \<rightarrow> ?v }, Mapping_Str.map_of_aset_insert)
Mapping_Str.map_of_alist_to_aset
WithTerm map_of_aset (set ?xs)
WithFact unique_keys_set (set ?xs)
GetFact (map_of_aset (set ?xs) = map_of_alist ?xs, Mapping_Str.map_of_alist_to_aset)
Mapping_Str.map_of_aset_delete
WithProperty unique_keys_set ?S
WithTerm map_of_aset (?S - {(?k, ?v)})
WithFact (?k, ?v) : ?S
GetFact (map_of_aset (?S - {(?k, ?v)}) = delete_map ?k (map_of_aset ?S), Mapping_Str.map_of_aset_delete)
Mapping_Str.map_of_aset_update
WithProperty unique_keys_set ?S
WithTerm map_of_aset (?S - {(?k, ?v)} Un {(?k, ?v')})
WithFact (?k, ?v) : ?S
GetFact (map_of_aset (?S - {(?k, ?v)} Un {(?k, ?v')}) =
 map_of_aset ?S { ?k \<rightarrow> ?v' }, Mapping_Str.map_of_aset_update)
Mapping_Str.map_of_alist_delete
WithTerm map_of_alist ?xs'
WithFact set ?xs' = set ?xs - {?x}
GetFact (unique_keys_set (set ?xs) -->
?x : set ?xs --> map_of_alist ?xs' = delete_map (fst ?x) (map_of_alist ?xs), Mapping_Str.map_of_alist_delete)
Mapping_Str.map_of_alist_insert
WithTerm map_of_alist ?xs'
WithFact set ?xs' = set ?xs Un {?x}
GetFact (unique_keys_set (set ?xs') -->
map_of_alist ?xs' =  map_of_alist ?xs { fst ?x \<rightarrow> snd ?x }, Mapping_Str.map_of_alist_insert)
Mapping_Str.map_of_alist_update
WithTerm map_of_alist ?xs'
WithFact set ?xs' = set ?xs - {(?k, ?v)} Un {(?k, ?v')}
GetFact (unique_keys_set (set ?xs) -->
(?k, ?v) : set ?xs -->
map_of_alist ?xs' =  map_of_alist ?xs { ?k \<rightarrow> ?v' }, Mapping_Str.map_of_alist_update)
Mapping_Str.keys_of_def
WithTerm keys_of ?M
GetFact (keys_of ?M = {x. ?M\<langle>x\<rangle> ~= None}, Mapping_Str.keys_of_def)
Mapping_Str.keys_of_iff@eqforward
WithFact ?x : keys_of ?M
GetGoal (?M\<langle>?x\<rangle> = None, Mapping_Str.keys_of_iff@eqforward)
Mapping_Str.keys_of_iff@invbackward
WithGoal ?x : keys_of ?M
GetFact (?M\<langle>?x\<rangle> = None, Mapping_Str.keys_of_iff@invbackward)
Mapping_Str.keys_of_iff@sym@eqforward
WithGoal ?M\<langle>?x\<rangle> = None
GetFact (?x : keys_of ?M, Mapping_Str.keys_of_iff@sym@eqforward)
Mapping_Str.keys_of_iff@sym@invbackward
WithFact ?M\<langle>?x\<rangle> = None
GetGoal (?x : keys_of ?M, Mapping_Str.keys_of_iff@sym@invbackward)
Delete Mapping_Str.keys_of_def
Mapping_Str.keys_of_empty
WithTerm keys_of empty_map
GetFact (keys_of empty_map = {}, Mapping_Str.keys_of_empty)
Mapping_Str.keys_of_delete
WithTerm keys_of (delete_map ?x ?M)
GetFact (keys_of (delete_map ?x ?M) = keys_of ?M - {?x}, Mapping_Str.keys_of_delete)
Mapping_Str.is_heap_min_def@eqforward
WithFact is_heap_min ?x ?M
GetFact (?x : keys_of ?M &
(ALL k:keys_of ?M. the ?M\<langle>?x\<rangle> <= the ?M\<langle>k\<rangle>), Mapping_Str.is_heap_min_def@eqforward)
Mapping_Str.is_heap_min_def@invbackward
WithGoal is_heap_min ?x ?M
GetGoal (?x : keys_of ?M &
(ALL k:keys_of ?M. the ?M\<langle>?x\<rangle> <= the ?M\<langle>k\<rangle>), Mapping_Str.is_heap_min_def@invbackward)
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Mapping_Str.map_constr.simps_1
WithTerm map_constr ?S ?f 0
GetFact (map_constr ?S ?f 0 = empty_map, Mapping_Str.map_constr.simps_1)
Mapping_Str.map_constr.simps_2
WithTerm map_constr ?S ?f (Suc ?k)
GetFact (map_constr ?S ?f (Suc ?k) =
(let M = map_constr ?S ?f ?k
 in if ?S ?k then  M { ?k \<rightarrow> ?f ?k } else M), Mapping_Str.map_constr.simps_2)
Mapping_Str.map_constr_eval
WithTerm map_constr ?S ?f ?n
GetFact (map_constr ?S ?f ?n =
Map (%i. if i < ?n then if ?S i then Some (?f i) else None else None), Mapping_Str.map_constr_eval)
Mapping_Str.keys_of_map_constr@eqforward
WithFact ?i : keys_of (map_constr ?S ?f ?n)
GetFact (?S ?i & ?i < ?n, Mapping_Str.keys_of_map_constr@eqforward)
Mapping_Str.keys_of_map_constr@invbackward
WithGoal ?i : keys_of (map_constr ?S ?f ?n)
GetGoal (?S ?i & ?i < ?n, Mapping_Str.keys_of_map_constr@invbackward)
Mapping_Str.map_update_all_def
WithTerm map_update_all ?f ?M
GetFact (map_update_all ?f ?M =
Map (%i. if i : keys_of ?M then Some (?f i) else ?M\<langle>i\<rangle>), Mapping_Str.map_update_all_def)
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
Mapping_Str.map_update_all_impl.simps_1
WithTerm map_update_all_impl ?f ?M 0
GetFact (map_update_all_impl ?f ?M 0 = ?M, Mapping_Str.map_update_all_impl.simps_1)
Mapping_Str.map_update_all_impl.simps_2
WithTerm map_update_all_impl ?f ?M (Suc ?k)
GetFact (map_update_all_impl ?f ?M (Suc ?k) =
(let M' = map_update_all_impl ?f ?M ?k
 in if ?k : keys_of ?M then  M' { ?k \<rightarrow> ?f ?k } else M'), Mapping_Str.map_update_all_impl.simps_2)
Mapping_Str.map_update_all_impl_ind
WithTerm map_update_all_impl ?f ?M ?n
GetFact (map_update_all_impl ?f ?M ?n =
Map (%i. if i < ?n then if i : keys_of ?M then Some (?f i) else None
         else ?M\<langle>i\<rangle>), Mapping_Str.map_update_all_impl_ind)
Mapping_Str.map_update_all_impl_correct
WithTerm map_update_all_impl ?f ?M ?n
WithFact ALL i:keys_of ?M. i < ?n
GetFact (map_update_all_impl ?f ?M ?n = map_update_all ?f ?M, Mapping_Str.map_update_all_impl_correct)
Mapping_Str.keys_of_map_update_all
WithTerm keys_of (map_update_all ?f ?M)
GetFact (keys_of (map_update_all ?f ?M) = keys_of ?M, Mapping_Str.keys_of_map_update_all)
### theory "Draft.Mapping_Str"
### 0.783s elapsed time, 1.770s cpu time, 0.148s GC time
Loading theory "Draft.Lists_Ex" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl" via "Draft.RBTree")
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
Lists_Ex.itrev.simps_1
WithTerm itrev [] ?ys
GetFact (itrev [] ?ys = ?ys, Lists_Ex.itrev.simps_1)
Lists_Ex.itrev.simps_2
WithTerm itrev (?x # ?xs) ?ys
GetFact (itrev (?x # ?xs) ?ys = itrev ?xs (?x # ?ys), Lists_Ex.itrev.simps_2)
Found termination order: "length <*mlex*> {}"
Lists_Ex.strict_sorted.simps_1@eqforward
WithFact strict_sorted []
GetFact (True, Lists_Ex.strict_sorted.simps_1@eqforward)
Lists_Ex.strict_sorted.simps_1@invbackward
WithGoal strict_sorted []
GetGoal (True, Lists_Ex.strict_sorted.simps_1@invbackward)
Lists_Ex.strict_sorted.simps_2@eqforward
WithFact strict_sorted (?x # ?ys)
GetFact (Ball (set ?ys) ((<) ?x) & strict_sorted ?ys, Lists_Ex.strict_sorted.simps_2@eqforward)
Lists_Ex.strict_sorted.simps_2@invbackward
WithGoal strict_sorted (?x # ?ys)
GetGoal (Ball (set ?ys) ((<) ?x) & strict_sorted ?ys, Lists_Ex.strict_sorted.simps_2@invbackward)
Lists_Ex.strict_sorted_appendI@back
WithGoal strict_sorted (?xs @ ?ys)
GetGoal (strict_sorted ?xs &
strict_sorted ?ys & (ALL x:set ?xs. ALL y:set ?ys. x < y), Lists_Ex.strict_sorted_appendI@back)
Lists_Ex.strict_sorted_appendE1
WithFact strict_sorted (?xs @ ?ys)
GetFact (strict_sorted ?xs & strict_sorted ?ys, Lists_Ex.strict_sorted_appendE1)
Lists_Ex.strict_sorted_appendE2
WithFact strict_sorted (?xs @ ?ys)
WithFact ?x : set ?xs
GetFact (ALL y:set ?ys. ?x < y, Lists_Ex.strict_sorted_appendE2)
Add property rule for [Lists_Ex.strict_sorted]
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Lists_Ex.ordered_insert.simps_1
WithTerm ordered_insert ?x []
GetFact (ordered_insert ?x [] = [?x], Lists_Ex.ordered_insert.simps_1)
Lists_Ex.ordered_insert.simps_2
WithTerm ordered_insert ?x (?y # ?ys)
GetFact (ordered_insert ?x (?y # ?ys) =
(if ?x = ?y then ?y # ?ys
 else if ?x < ?y then ?x # ?y # ?ys else ?y # ordered_insert ?x ?ys), Lists_Ex.ordered_insert.simps_2)
Lists_Ex.ordered_insert_set
WithTerm set (ordered_insert ?x ?ys)
GetFact (set (ordered_insert ?x ?ys) = {?x} Un set ?ys, Lists_Ex.ordered_insert_set)
Add property rule for function Lists_Ex.ordered_insert
Lists_Ex.ordered_insert_binary
WithTerm ordered_insert ?x (?xs @ ?a # ?ys)
WithFact strict_sorted (?xs @ ?a # ?ys)
GetFact (ordered_insert ?x (?xs @ ?a # ?ys) =
(if ?x < ?a then ordered_insert ?x ?xs @ ?a # ?ys
 else if ?a < ?x then ?xs @ ?a # ordered_insert ?x ?ys else ?xs @ ?a # ?ys), Lists_Ex.ordered_insert_binary)
SepAuto.pheap.collapse@sym
WithTerm ?pheap
GetFact (?pheap = pHeap (heapOf ?pheap) (addrOf ?pheap), SepAuto.pheap.collapse@sym) + 1 filters
SepAuto.pheap.case
WithTerm case pHeap ?x1.0 ?x2.0 of pHeap x xa => ?f x xa
GetFact ((case pHeap ?x1.0 ?x2.0 of pHeap x xa => ?f x xa) = ?f ?x1.0 ?x2.0, SepAuto.pheap.case)
SepAuto.pheap.sel_1
WithTerm heapOf (pHeap ?x1.0 ?x2.0)
GetFact (heapOf (pHeap ?x1.0 ?x2.0) = ?x1.0, SepAuto.pheap.sel_1)
SepAuto.pheap.sel_2
WithTerm addrOf (pHeap ?x1.0 ?x2.0)
GetFact (addrOf (pHeap ?x1.0 ?x2.0) = ?x2.0, SepAuto.pheap.sel_2)
SepAuto.pheap.simps_1@eqforward
WithFact pHeap ?x1.0 ?x2.0 = pHeap ?y1.0 ?y2.0
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, SepAuto.pheap.simps_1@eqforward)
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Lists_Ex.remove_elt_list.simps_1
WithTerm remove_elt_list ?x []
GetFact (remove_elt_list ?x [] = [], Lists_Ex.remove_elt_list.simps_1)
Lists_Ex.remove_elt_list.simps_2
WithTerm remove_elt_list ?x (?y # ?ys)
GetFact (remove_elt_list ?x (?y # ?ys) =
(if ?y = ?x then remove_elt_list ?x ?ys else ?y # remove_elt_list ?x ?ys), Lists_Ex.remove_elt_list.simps_2)
Lists_Ex.remove_elt_list_set
WithTerm set (remove_elt_list ?x ?ys)
GetFact (set (remove_elt_list ?x ?ys) = set ?ys - {?x}, Lists_Ex.remove_elt_list_set)
Add property rule for function Lists_Ex.remove_elt_list
Lists_Ex.remove_elt_idem
WithTerm remove_elt_list ?x ?ys
WithGoal ?x : set ?ys
GetFact (remove_elt_list ?x ?ys = ?ys, Lists_Ex.remove_elt_idem)
Found termination order: "{}"
Lists_Ex.remove_elt_list_binary
WithTerm remove_elt_list ?x (?xs @ ?a # ?ys)
WithFact strict_sorted (?xs @ ?a # ?ys)
GetFact (remove_elt_list ?x (?xs @ ?a # ?ys) =
(if ?x < ?a then remove_elt_list ?x ?xs @ ?a # ?ys
 else if ?a < ?x then ?xs @ ?a # remove_elt_list ?x ?ys else ?xs @ ?ys), Lists_Ex.remove_elt_list_binary)
SepAuto.in_range.simps@eqforward
WithFact in_range (?h, ?as)
GetFact (ALL a:?as. a < lim ?h, SepAuto.in_range.simps@eqforward)
SepAuto.in_range.simps@invbackward
WithGoal in_range (?h, ?as)
GetGoal (ALL a:?as. a < lim ?h, SepAuto.in_range.simps@invbackward)
SepAuto.relH_def@eqforward
WithFact relH ?as ?h ?h'
GetFact (in_range (?h, ?as) &
in_range (?h', ?as) &
(ALL t.
    ALL a:?as. refs ?h t a = refs ?h' t a & arrays ?h t a = arrays ?h' t a), SepAuto.relH_def@eqforward)
SepAuto.relH_def@invbackward
WithGoal relH ?as ?h ?h'
GetGoal (in_range (?h, ?as) &
in_range (?h', ?as) &
(ALL t.
    ALL a:?as. refs ?h t a = refs ?h' t a & arrays ?h t a = arrays ?h' t a), SepAuto.relH_def@invbackward)
SepAuto.relH_D
WithFact relH ?as ?h ?h'
GetFact (in_range (?h, ?as) & in_range (?h', ?as), SepAuto.relH_D)
SepAuto.relH_D2_1
WithTerm refs ?h ?t ?a
WithFact relH ?as ?h ?h'
GetFact (?a : ?as --> refs ?h ?t ?a = refs ?h' ?t ?a, SepAuto.relH_D2_1)
SepAuto.relH_D2_2
WithTerm arrays ?h ?t ?a
WithFact relH ?as ?h ?h'
GetFact (?a : ?as --> arrays ?h ?t ?a = arrays ?h' ?t ?a, SepAuto.relH_D2_2)
Delete SepAuto.relH_def@eqforward
SepAuto.relH_dist_union
WithFact relH (?as Un ?as') ?h ?h'
GetFact (relH ?as ?h ?h' & relH ?as' ?h ?h', SepAuto.relH_dist_union)
SepAuto.relH_ref
WithTerm Ref.get ?h ?r
WithFact relH ?as ?h ?h'
GetFact (addr_of_ref ?r : ?as --> Ref.get ?h ?r = Ref.get ?h' ?r, SepAuto.relH_ref)
SepAuto.relH_array
WithTerm Array.get ?h ?r
WithFact relH ?as ?h ?h'
GetFact (addr_of_array ?r : ?as --> Array.get ?h ?r = Array.get ?h' ?r, SepAuto.relH_array)
SepAuto.relH_set_ref@res
WithGoal relH {a. a < lim ?h & a ~: {addr_of_ref ?r}} ?h (Ref.set ?r ?x ?h)
GetResolve SepAuto.relH_set_ref@res
SepAuto.relH_set_array@res
WithGoal relH {a. a < lim ?h & a ~: {addr_of_array ?r}} ?h (Array.set ?r ?x ?h)
GetResolve SepAuto.relH_set_array@res
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
Lists_Ex.ordered_insert_pairs.simps_1
WithTerm ordered_insert_pairs ?x ?v []
GetFact (ordered_insert_pairs ?x ?v [] = [(?x, ?v)], Lists_Ex.ordered_insert_pairs.simps_1)
Lists_Ex.ordered_insert_pairs.simps_2
WithTerm ordered_insert_pairs ?x ?v (?y # ?ys)
GetFact (ordered_insert_pairs ?x ?v (?y # ?ys) =
(if ?x = fst ?y then (?x, ?v) # ?ys
 else if ?x < fst ?y then (?x, ?v) # ?y # ?ys
      else ?y # ordered_insert_pairs ?x ?v ?ys), Lists_Ex.ordered_insert_pairs.simps_2)
Lists_Ex.ordered_insert_pairs_map
WithTerm map_of_alist (ordered_insert_pairs ?x ?v ?ys)
GetFact (map_of_alist (ordered_insert_pairs ?x ?v ?ys) =
 map_of_alist ?ys { ?x \<rightarrow> ?v }, Lists_Ex.ordered_insert_pairs_map)
Lists_Ex.ordered_insert_pairs_set
WithTerm set (map fst (ordered_insert_pairs ?x ?v ?ys))
GetFact (set (map fst (ordered_insert_pairs ?x ?v ?ys)) = {?x} Un set (map fst ?ys), Lists_Ex.ordered_insert_pairs_set)
Lists_Ex.ordered_insert_pairs_sorted@back
WithGoal strict_sorted (map fst (ordered_insert_pairs ?x ?v ?ys))
GetGoal (strict_sorted (map fst ?ys), Lists_Ex.ordered_insert_pairs_sorted@back)
Lists_Ex.ordered_insert_pairs_binary
WithTerm ordered_insert_pairs ?x ?v (?xs @ ?a # ?ys)
WithFact strict_sorted (map fst (?xs @ ?a # ?ys))
GetFact (ordered_insert_pairs ?x ?v (?xs @ ?a # ?ys) =
(if ?x < fst ?a then ordered_insert_pairs ?x ?v ?xs @ ?a # ?ys
 else if fst ?a < ?x then ?xs @ ?a # ordered_insert_pairs ?x ?v ?ys
      else ?xs @ (?x, ?v) # ?ys), Lists_Ex.ordered_insert_pairs_binary)
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Lists_Ex.remove_elt_pairs.simps_1
WithTerm remove_elt_pairs ?x []
GetFact (remove_elt_pairs ?x [] = [], Lists_Ex.remove_elt_pairs.simps_1)
Lists_Ex.remove_elt_pairs.simps_2
WithTerm remove_elt_pairs ?x (?y # ?ys)
GetFact (remove_elt_pairs ?x (?y # ?ys) =
(if fst ?y = ?x then ?ys else ?y # remove_elt_pairs ?x ?ys), Lists_Ex.remove_elt_pairs.simps_2)
Lists_Ex.remove_elt_pairs_map
WithTerm map_of_alist (remove_elt_pairs ?x ?ys)
WithFact strict_sorted (map fst ?ys)
GetFact (map_of_alist (remove_elt_pairs ?x ?ys) = delete_map ?x (map_of_alist ?ys), Lists_Ex.remove_elt_pairs_map)
Lists_Ex.remove_elt_pairs_on_set
WithTerm set (map fst (remove_elt_pairs ?x ?ys))
WithFact strict_sorted (map fst ?ys)
GetFact (set (map fst (remove_elt_pairs ?x ?ys)) = set (map fst ?ys) - {?x}, Lists_Ex.remove_elt_pairs_on_set)
Lists_Ex.remove_elt_pairs_sorted@back
WithGoal strict_sorted (map fst (remove_elt_pairs ?x ?ys))
GetGoal (strict_sorted (map fst ?ys), Lists_Ex.remove_elt_pairs_sorted@back)
Lists_Ex.remove_elt_pairs_idem
WithTerm remove_elt_pairs ?x ?ys
WithGoal ?x : set (map fst ?ys)
GetFact (remove_elt_pairs ?x ?ys = ?ys, Lists_Ex.remove_elt_pairs_idem)
Lists_Ex.remove_elt_pairs_binary
WithTerm remove_elt_pairs ?x (?xs @ ?a # ?ys)
WithFact strict_sorted (map fst (?xs @ ?a # ?ys))
GetFact (remove_elt_pairs ?x (?xs @ ?a # ?ys) =
(if ?x < fst ?a then remove_elt_pairs ?x ?xs @ ?a # ?ys
 else if fst ?a < ?x then ?xs @ ?a # remove_elt_pairs ?x ?ys else ?xs @ ?ys), Lists_Ex.remove_elt_pairs_binary)
Lists_Ex.map_of_alist_binary
WithTerm map_of_alist (?xs @ ?a # ?ys)\<langle>?x\<rangle>
WithFact strict_sorted (map fst (?xs @ ?a # ?ys))
GetFact (map_of_alist (?xs @ ?a # ?ys)\<langle>?x\<rangle> =
(if ?x < fst ?a then map_of_alist ?xs\<langle>?x\<rangle>
 else if fst ?a < ?x then map_of_alist ?ys\<langle>?x\<rangle>
      else Some (snd ?a)), Lists_Ex.map_of_alist_binary)
### theory "Draft.Lists_Ex"
### 0.527s elapsed time, 1.101s cpu time, 0.082s GC time
Loading theory "Draft.RBTree" (required by "Draft.RBTree_ImplMoreTemplates" via "Draft.RBTree_Impl")
Found termination order: "{}"
SepAuto.aseval.simps@eqforward
WithFact aseval (Assn ?f) ?h
GetFact (?f ?h, SepAuto.aseval.simps@eqforward)
SepAuto.aseval.simps@invbackward
WithGoal aseval (Assn ?f) ?h
GetGoal (?f ?h, SepAuto.aseval.simps@invbackward)
SepAuto.proper_def@eqforward
WithFact proper ?P
GetFact ((ALL h as. aseval ?P (pHeap h as) --> in_range (h, as)) &
(ALL h h' as.
    aseval ?P (pHeap h as) -->
    relH as h h' --> in_range (h', as) --> aseval ?P (pHeap h' as)), SepAuto.proper_def@eqforward)
SepAuto.proper_def@invbackward
WithGoal proper ?P
GetGoal ((ALL h as. aseval ?P (pHeap h as) --> in_range (h, as)) &
(ALL h h' as.
    aseval ?P (pHeap h as) -->
    relH as h h' --> in_range (h', as) --> aseval ?P (pHeap h' as)), SepAuto.proper_def@invbackward)
Found termination order: "{}"
SepAuto.in_range_assn.simps@eqforward
WithFact in_range_assn (pHeap ?h ?as)
GetFact (ALL a:?as. a < lim ?h, SepAuto.in_range_assn.simps@eqforward)
SepAuto.in_range_assn.simps@invbackward
WithGoal in_range_assn (pHeap ?h ?as)
GetGoal (ALL a:?as. a < lim ?h, SepAuto.in_range_assn.simps@invbackward)
SepAuto.assn.Rep_assn_inject@eqforward
WithFact Rep_assn ?x = Rep_assn ?y
GetFact (?x = ?y, SepAuto.assn.Rep_assn_inject@eqforward)
SepAuto.assn.Rep_assn_inject@invbackward
WithGoal Rep_assn ?x = Rep_assn ?y
GetGoal (?x = ?y, SepAuto.assn.Rep_assn_inject@invbackward)
SepAuto.assn.Abs_assn_case
WithTerm Abs_assn ?P
CreateConcl proper ?P
SepAuto.Abs_assn_inverse'
WithWellForm proper ?y
WithTerm Rep_assn (Abs_assn ?y)
GetFact (Rep_assn (Abs_assn ?y) = ?y, SepAuto.Abs_assn_inverse')
Add property rule for function SepAuto.assn.Rep_assn
SepAuto.models_def@eqforward
WithFact ?h \<Turnstile> ?P
GetFact (aseval (Rep_assn ?P) ?h, SepAuto.models_def@eqforward)
SepAuto.models_def@invbackward
WithGoal ?h \<Turnstile> ?P
GetGoal (aseval (Rep_assn ?P) ?h, SepAuto.models_def@invbackward)
SepAuto.models_def@sym@eqforward
WithFact aseval (Rep_assn ?P) ?h
GetFact (?h \<Turnstile> ?P, SepAuto.models_def@sym@eqforward)
SepAuto.models_def@sym@invbackward
WithGoal aseval (Rep_assn ?P) ?h
GetGoal (?h \<Turnstile> ?P, SepAuto.models_def@sym@invbackward)
SepAuto.models_in_range@res
WithGoal in_range (?h, ?as)
WithFact pHeap ?h ?as \<Turnstile> ?P
GetResolve SepAuto.models_in_range@res
SepAuto.mod_relH
WithFact relH ?as ?h ?h'
WithFact pHeap ?h ?as \<Turnstile> ?P
GetFact (pHeap ?h' ?as \<Turnstile> ?P, SepAuto.mod_relH)
instantiation
  assn :: one
  one_assn == one_class.one :: assn
SepAuto.one_assn_def@obj_eq
WithTerm 1
GetFact (1 = Abs_assn (Assn (%h. addrOf h = {})), SepAuto.one_assn_def@obj_eq)
SepAuto.one_assn_rule@eqforward
WithFact ?h \<Turnstile> emp
GetFact (addrOf ?h = {}, SepAuto.one_assn_rule@eqforward)
SepAuto.one_assn_rule@invbackward
WithGoal ?h \<Turnstile> emp
GetGoal (addrOf ?h = {}, SepAuto.one_assn_rule@invbackward)
Delete SepAuto.one_assn_def@obj_eq
instantiation
  assn :: times
  times_assn == times :: assn => assn => assn
SepAuto.times_assn_def
WithTerm ?P * ?Q
GetFact (?P * ?Q =
Abs_assn
 (Assn
   (%h. EX as1 as2.
           addrOf h = as1 Un as2 &
           as1 Int as2 = {} &
           aseval (Rep_assn ?P) (pHeap (heapOf h) as1) &
           aseval (Rep_assn ?Q) (pHeap (heapOf h) as2))), SepAuto.times_assn_def)
SepAuto.mod_star_conv@eqforward
WithFact pHeap ?h ?as \<Turnstile> ?A * ?B
GetFact (EX as1 as2.
   ?as = as1 Un as2 &
   as1 Int as2 = {} &
   pHeap ?h as1 \<Turnstile> ?A & pHeap ?h as2 \<Turnstile> ?B, SepAuto.mod_star_conv@eqforward)
SepAuto.mod_star_conv@invbackward
WithGoal pHeap ?h ?as \<Turnstile> ?A * ?B
GetGoal (EX as1 as2.
   ?as = as1 Un as2 &
   as1 Int as2 = {} &
   pHeap ?h as1 \<Turnstile> ?A & pHeap ?h as2 \<Turnstile> ?B, SepAuto.mod_star_conv@invbackward)
Delete SepAuto.times_assn_def
SepAuto.aseval_ext@back
WithGoal ?P = ?P'
GetGoal (ALL h. aseval ?P h = aseval ?P' h, SepAuto.aseval_ext@back)
SepAuto.assn_ext@back
WithGoal ?P = ?Q
GetGoal (ALL h as. (pHeap h as \<Turnstile> ?P) = (pHeap h as \<Turnstile> ?Q), SepAuto.assn_ext@back) + 1 filters
Delete SepAuto.aseval_ext@back
instantiation
  assn :: comm_monoid_mult
SepAuto.ex_assn_def
WithTerm \<exists>\<^sub>Ax. ?P x
GetFact ((\<exists>\<^sub>Ax. ?P x) = Abs_assn (Assn (%h. EX x. h \<Turnstile> ?P x)), SepAuto.ex_assn_def)
SepAuto.mod_ex_dist@eqforward
WithFact ?h \<Turnstile> (\<exists>\<^sub>Ax. ?P x)
GetFact (EX x. ?h \<Turnstile> ?P x, SepAuto.mod_ex_dist@eqforward)
SepAuto.mod_ex_dist@invbackward
WithGoal ?h \<Turnstile> (\<exists>\<^sub>Ax. ?P x)
GetGoal (EX x. ?h \<Turnstile> ?P x, SepAuto.mod_ex_dist@invbackward)
Delete SepAuto.ex_assn_def
SepAuto.sngr_assn_def
WithTerm ?r \<mapsto>\<^sub>r ?x
GetFact (?r \<mapsto>\<^sub>r ?x =
Abs_assn
 (Assn
   (%h. Ref.get (heapOf h) ?r = ?x &
        addrOf h = {addr_of_ref ?r} & addr_of_ref ?r < lim (heapOf h))), SepAuto.sngr_assn_def)
SepAuto.sngr_assn_rule@eqforward
WithFact pHeap ?h ?as \<Turnstile> ?r \<mapsto>\<^sub>r ?x
GetFact (Ref.get ?h ?r = ?x & ?as = {addr_of_ref ?r} & addr_of_ref ?r < lim ?h, SepAuto.sngr_assn_rule@eqforward)
SepAuto.sngr_assn_rule@invbackward
WithGoal pHeap ?h ?as \<Turnstile> ?r \<mapsto>\<^sub>r ?x
GetGoal (Ref.get ?h ?r = ?x & ?as = {addr_of_ref ?r} & addr_of_ref ?r < lim ?h, SepAuto.sngr_assn_rule@invbackward)
Delete SepAuto.sngr_assn_def
SepAuto.snga_assn_def
WithTerm ?r \<mapsto>\<^sub>a ?x
GetFact (?r \<mapsto>\<^sub>a ?x =
Abs_assn
 (Assn
   (%h. Array.get (heapOf h) ?r = ?x &
        addrOf h = {addr_of_array ?r} & addr_of_array ?r < lim (heapOf h))), SepAuto.snga_assn_def)
SepAuto.snga_assn_rule@eqforward
WithFact pHeap ?h ?as \<Turnstile> ?r \<mapsto>\<^sub>a ?x
GetFact (Array.get ?h ?r = ?x & ?as = {addr_of_array ?r} & addr_of_array ?r < lim ?h, SepAuto.snga_assn_rule@eqforward)
SepAuto.snga_assn_rule@invbackward
WithGoal pHeap ?h ?as \<Turnstile> ?r \<mapsto>\<^sub>a ?x
GetGoal (Array.get ?h ?r = ?x & ?as = {addr_of_array ?r} & addr_of_array ?r < lim ?h, SepAuto.snga_assn_rule@invbackward)
Delete SepAuto.snga_assn_def
SepAuto.pure_assn_def
WithTerm \<up> ?b
GetFact (\<up> ?b = Abs_assn (Assn (%h. addrOf h = {} & ?b)), SepAuto.pure_assn_def)
SepAuto.pure_assn_rule@eqforward
WithFact ?h \<Turnstile> \<up> ?b
GetFact (addrOf ?h = {} & ?b, SepAuto.pure_assn_rule@eqforward)
SepAuto.pure_assn_rule@invbackward
WithGoal ?h \<Turnstile> \<up> ?b
GetGoal (addrOf ?h = {} & ?b, SepAuto.pure_assn_rule@invbackward)
Delete SepAuto.pure_assn_def
SepAuto.top_assn_def
WithTerm true
GetFact (true = Abs_assn (Assn in_range_assn), SepAuto.top_assn_def)
SepAuto.top_assn_rule@eqforward
WithFact pHeap ?h ?as \<Turnstile> true
GetFact (in_range (?h, ?as), SepAuto.top_assn_rule@eqforward)
SepAuto.top_assn_rule@invbackward
WithGoal pHeap ?h ?as \<Turnstile> true
GetGoal (in_range (?h, ?as), SepAuto.top_assn_rule@invbackward)
Delete SepAuto.top_assn_def
Delete SepAuto.models_def@eqforward
Delete SepAuto.models_def@invbackward
Delete SepAuto.models_def@sym@eqforward
Delete SepAuto.models_def@sym@invbackward
SepAuto.mod_pure_star_dist@eqforward
WithFact ?h \<Turnstile> ?P * \<up> ?b
GetFact (?h \<Turnstile> ?P & ?b, SepAuto.mod_pure_star_dist@eqforward)
SepAuto.mod_pure_star_dist@invbackward
WithGoal ?h \<Turnstile> ?P * \<up> ?b
GetGoal (?h \<Turnstile> ?P & ?b, SepAuto.mod_pure_star_dist@invbackward)
SepAuto.entails_def@eqforward
WithFact ?P \<Longrightarrow>\<^sub>A ?Q
GetFact (ALL h. h \<Turnstile> ?P --> h \<Turnstile> ?Q, SepAuto.entails_def@eqforward)
SepAuto.entails_def@invbackward
WithGoal ?P \<Longrightarrow>\<^sub>A ?Q
GetGoal (ALL h. h \<Turnstile> ?P --> h \<Turnstile> ?Q, SepAuto.entails_def@invbackward)
SepAuto.entails_frame@back
WithGoal ?P * ?R \<Longrightarrow>\<^sub>A ?Q * ?R
GetGoal (?P \<Longrightarrow>\<^sub>A ?Q, SepAuto.entails_frame@back)
SepAuto.entailsD
WithFact ?P \<Longrightarrow>\<^sub>A ?Q
WithFact ?h \<Turnstile> ?P
GetFact (?h \<Turnstile> ?Q, SepAuto.entailsD)
Delete SepAuto.entails_def@eqforward
Delete SepAuto.entails_def@invbackward
Proofs for inductive predicate(s) "run"
  Proving monotonicity ...
SepAuto.run.intros_1@res
WithGoal run ?c None None ?r
GetResolve SepAuto.run.intros_1@res
SepAuto.run.intros_2@res
WithGoal run ?c (Some ?h) None ?r
WithFact execute ?c ?h = None
GetResolve SepAuto.run.intros_2@res
SepAuto.run.intros_3
WithFact execute ?c ?h = Some (?r, ?h')
GetFact (run ?c (Some ?h) (Some ?h') ?r, SepAuto.run.intros_3)
SepAuto.run_complete@res
WithGoal EX \<sigma>' r. run ?c ?\<sigma> \<sigma>' r
GetResolve SepAuto.run_complete@res
SepAuto.run_to_execute
WithFact run ?c (Some ?h) ?\<sigma>' ?r
GetFact (if ?\<sigma>' = None then execute ?c ?h = None
else execute ?c ?h = Some (?r, the ?\<sigma>'), SepAuto.run_to_execute)
Heap_Monad.execute_bind_1
WithTerm execute (?f >>= ?g) ?h
WithFact execute ?f ?h = Some (?x, ?h')
GetFact (execute (?f >>= ?g) ?h = execute (?g ?x) ?h', Heap_Monad.execute_bind_1)
SepAuto.runE
WithFact run ?f (Some ?h) (Some ?h') ?r'
WithFact run (?f >>= ?g) (Some ?h) ?\<sigma> ?r
GetFact (run (?g ?r') (Some ?h') ?\<sigma> ?r, SepAuto.runE)
Array.get_alloc
WithTerm Array.get (snd (Array.alloc ?xs ?h)) (fst (Array.alloc ?ys ?h))
GetFact (Array.get (snd (Array.alloc ?xs ?h)) (fst (Array.alloc ?ys ?h)) = ?xs, Array.get_alloc)
Ref.get_alloc
WithTerm Ref.get (snd (Ref.alloc ?x ?h)) (fst (Ref.alloc ?x' ?h))
GetFact (Ref.get (snd (Ref.alloc ?x ?h)) (fst (Ref.alloc ?x' ?h)) = ?x, Ref.get_alloc)
Array.length_def
WithTerm Array.length ?h ?a
GetFact (Array.length ?h ?a = length (Array.get ?h ?a), Array.length_def)
Array.length_def@sym
WithTerm length (Array.get ?h ?a)
GetFact (length (Array.get ?h ?a) = Array.length ?h ?a, Array.length_def@sym)
SepAuto.new_addrs_def
WithTerm new_addrs ?h ?as ?h'
GetFact (new_addrs ?h ?as ?h' = ?as Un {a. lim ?h <= a & a < lim ?h'}, SepAuto.new_addrs_def)
SepAuto.hoare_triple_def@eqforward
WithFact <?P> ?c <?Q>
GetFact (ALL h as \<sigma> r.
   pHeap h as \<Turnstile> ?P -->
   run ?c (Some h) \<sigma> r -->
   \<sigma> ~= None &
   pHeap (the \<sigma>) (new_addrs h as (the \<sigma>)) \<Turnstile> ?Q r &
   relH {a. a < lim h & a ~: as} h (the \<sigma>) &
   lim h <= lim (the \<sigma>), SepAuto.hoare_triple_def@eqforward)
SepAuto.hoare_triple_def@invbackward
WithGoal <?P> ?c <?Q>
GetGoal (ALL h as \<sigma> r.
   pHeap h as \<Turnstile> ?P -->
   run ?c (Some h) \<sigma> r -->
   \<sigma> ~= None &
   pHeap (the \<sigma>) (new_addrs h as (the \<sigma>)) \<Turnstile> ?Q r &
   relH {a. a < lim h & a ~: as} h (the \<sigma>) &
   lim h <= lim (the \<sigma>), SepAuto.hoare_triple_def@invbackward)
SepAuto.hoare_tripleD
WithFact <?P> ?c <?Q>
WithFact run ?c (Some ?h) ?\<sigma> ?r
GetFact (ALL as.
   pHeap ?h as \<Turnstile> ?P -->
   ?\<sigma> ~= None &
   pHeap (the ?\<sigma>) (new_addrs ?h as (the ?\<sigma>)) \<Turnstile>
   ?Q ?r &
   relH {a. a < lim ?h & a ~: as} ?h (the ?\<sigma>) &
   lim ?h <= lim (the ?\<sigma>), SepAuto.hoare_tripleD)
Delete SepAuto.hoare_triple_def@eqforward
SepAuto.frame_rule@back
WithGoal <?P * ?R> ?c <%x. ?Q x * ?R>
GetGoal (<?P> ?c <?Q>, SepAuto.frame_rule@back)
Delete SepAuto.mod_star_conv@eqforward
Delete SepAuto.mod_star_conv@invbackward
Delete SepAuto.entailsD
Delete SepAuto.entails_frame@back
Delete SepAuto.frame_rule@back
Heap_Monad.execute_assert_1
WithTerm execute (assert ?P ?x) ?h
WithFact ?P ?x
GetFact (execute (assert ?P ?x) ?h = Some (?x, ?h), Heap_Monad.execute_assert_1)
SepAuto.execute_return'
WithTerm execute (return ?x) ?h
GetFact (execute (return ?x) ?h = Some (?x, ?h), SepAuto.execute_return')
Array.execute_nth_1
WithTerm execute (Array.nth ?a ?i) ?h
WithFact ?i < Array.length ?h ?a
GetFact (execute (Array.nth ?a ?i) ?h = Some (Array.get ?h ?a ! ?i, ?h), Array.execute_nth_1)
Array.execute_len
WithTerm execute (Array.len ?a) ?h
GetFact (execute (Array.len ?a) ?h = Some (Array.length ?h ?a, ?h), Array.execute_len)
Ref.execute_lookup
WithTerm execute (!?r) ?h
GetFact (execute (!?r) ?h = Some (Ref.get ?h ?r, ?h), Ref.execute_lookup)
Array.execute_freeze
WithTerm execute (Array.freeze ?a) ?h
GetFact (execute (Array.freeze ?a) ?h = Some (Array.get ?h ?a, ?h), Array.execute_freeze)
Ref.lim_set
WithTerm lim (Ref.set ?r ?v ?h)
GetFact (lim (Ref.set ?r ?v ?h) = lim ?h, Ref.lim_set)
SepAuto.Array_lim_set
WithTerm lim (Array.set ?p ?xs ?h)
GetFact (lim (Array.set ?p ?xs ?h) = lim ?h, SepAuto.Array_lim_set)
Ref.get_set_eq
WithTerm Ref.get (Ref.set ?r ?x ?h) ?r
GetFact (Ref.get (Ref.set ?r ?x ?h) ?r = ?x, Ref.get_set_eq)
Array.get_set_eq
WithTerm Array.get (Array.set ?r ?x ?h) ?r
GetFact (Array.get (Array.set ?r ?x ?h) ?r = ?x, Array.get_set_eq)
Array.update_def
WithTerm Array.update ?a ?i ?x ?h
GetFact (Array.update ?a ?i ?x ?h = Array.set ?a ((Array.get ?h ?a)[?i := ?x]) ?h, Array.update_def)
Array.execute_upd_1
WithTerm execute (Array.upd ?i ?x ?a) ?h
WithFact ?i < Array.length ?h ?a
GetFact (execute (Array.upd ?i ?x ?a) ?h = Some (?a, Array.update ?a ?i ?x ?h), Array.execute_upd_1)
Ref.execute_update
WithTerm execute (?r := ?v) ?h
GetFact (execute (?r := ?v) ?h = Some ((), Ref.set ?r ?v ?h), Ref.execute_update)
SepAuto.lim_set_gen
WithTerm lim (?h(| lim := ?l |))
GetFact (lim (?h(| lim := ?l |)) = ?l, SepAuto.lim_set_gen)
SepAuto.Array_alloc_def'
WithTerm Array.alloc ?xs ?h
GetFact (Array.alloc ?xs ?h =
(let l = lim ?h; r = Array l in (r, Array.set r ?xs (?h(| lim := l + 1 |)))), SepAuto.Array_alloc_def')
Heap.addr_of_array.simps
WithTerm addr_of_array (Array ?x)
GetFact (addr_of_array (Array ?x) = ?x, Heap.addr_of_array.simps)
Heap.addr_of_ref.simps
WithTerm addr_of_ref (Ref ?x)
GetFact (addr_of_ref (Ref ?x) = ?x, Heap.addr_of_ref.simps)
Ref.alloc_def
WithTerm Ref.alloc ?x ?h
GetFact (Ref.alloc ?x ?h =
(let l = lim ?h; r = Ref l in (r, Ref.set r ?x (?h(| lim := l + 1 |)))), Ref.alloc_def)
SepAuto.refs_on_Array_set
WithTerm refs (Array.set ?p ?xs ?h) ?t ?i
GetFact (refs (Array.set ?p ?xs ?h) ?t ?i = refs ?h ?t ?i, SepAuto.refs_on_Array_set)
SepAuto.arrays_on_Ref_set
WithTerm arrays (Ref.set ?p ?x ?h) ?t ?i
GetFact (arrays (Ref.set ?p ?x ?h) ?t ?i = arrays ?h ?t ?i, SepAuto.arrays_on_Ref_set)
SepAuto.refs_on_Array_alloc
WithTerm refs (snd (Array.alloc ?xs ?h)) ?t ?i
GetFact (refs (snd (Array.alloc ?xs ?h)) ?t ?i = refs ?h ?t ?i, SepAuto.refs_on_Array_alloc)
SepAuto.arrays_on_Ref_alloc
WithTerm arrays (snd (Ref.alloc ?x ?h)) ?t ?i
GetFact (arrays (snd (Ref.alloc ?x ?h)) ?t ?i = arrays ?h ?t ?i, SepAuto.arrays_on_Ref_alloc)
SepAuto.arrays_on_Array_alloc
WithTerm arrays (snd (Array.alloc ?xs ?h)) ?t ?i
WithFact ?i < lim ?h
GetFact (arrays (snd (Array.alloc ?xs ?h)) ?t ?i = arrays ?h ?t ?i, SepAuto.arrays_on_Array_alloc)
SepAuto.refs_on_Ref_alloc
WithTerm refs (snd (Ref.alloc ?x ?h)) ?t ?i
WithFact ?i < lim ?h
GetFact (refs (snd (Ref.alloc ?x ?h)) ?t ?i = refs ?h ?t ?i, SepAuto.refs_on_Ref_alloc)
Array.execute_new
WithTerm execute (Array.new ?n ?x) ?h
GetFact (execute (Array.new ?n ?x) ?h = Some (Array.alloc (replicate ?n ?x) ?h), Array.execute_new)
Array.execute_of_list
WithTerm execute (Array.of_list ?xs) ?h
GetFact (execute (Array.of_list ?xs) ?h = Some (Array.alloc ?xs ?h), Array.execute_of_list)
Ref.execute_ref
WithTerm execute (ref ?v) ?h
GetFact (execute (ref ?v) ?h = Some (Ref.alloc ?v ?h), Ref.execute_ref)
Delete SepAuto.sngr_assn_rule@eqforward
Delete SepAuto.sngr_assn_rule@invbackward
Delete SepAuto.snga_assn_rule@eqforward
Delete SepAuto.snga_assn_rule@invbackward
Delete SepAuto.pure_assn_rule@eqforward
Delete SepAuto.pure_assn_rule@invbackward
Delete SepAuto.top_assn_rule@eqforward
Delete SepAuto.top_assn_rule@invbackward
Delete SepAuto.mod_pure_star_dist@eqforward
Delete SepAuto.mod_pure_star_dist@invbackward
Delete SepAuto.one_assn_rule@eqforward
Delete SepAuto.one_assn_rule@invbackward
Delete SepAuto.hoare_triple_def@invbackward
Delete SepAuto.mod_ex_dist@eqforward
Delete SepAuto.mod_ex_dist@invbackward
Delete SepAuto.pheap.collapse@sym
Delete SepAuto.pheap.case
Delete SepAuto.pheap.simps_1@eqforward
Delete SepAuto.pheap.sel_1
Delete SepAuto.pheap.sel_2
structure SepUtil: SEP_UTIL
structure AssnMatcher: ASSN_MATCHER
structure SepLogic: SEP_LOGIC
val add_assn_matcher = fn: assn_matcher -> theory -> theory
val add_entail_matcher = fn: thm -> theory -> theory
val add_forward_ent_prfstep = fn: thm -> theory -> theory
val add_rewrite_ent_rule = fn: thm -> theory -> theory
val add_hoare_triple_prfstep = fn: thm -> theory -> theory
val test_normalize_assn =
   [(), (), (), (), (), (), (), (), (), (), (), (), (), (), ()]: unit list
val test_contract_hoare = [(), (), (), (), ()]: unit list
val test_normalize_hoare_goal = [(), (), (), (), (), (), ()]: unit list
val test_normalize_entail_goal = [(), (), (), ()]: unit list
Add Hoare triple SepAuto.assert_rule
<\<up> (?R ?x)> assert ?R ?x <%r. \<up> (r = ?x)>
Add Hoare triple SepAuto.update_rule
<?p \<mapsto>\<^sub>r ?y> ?p := ?x <%r. ?p \<mapsto>\<^sub>r ?x>
Add Hoare triple SepAuto.nth_rule
<?a \<mapsto>\<^sub>a ?xs * \<up> (?i < length ?xs)> Array.nth ?a ?i
<%r. ?a \<mapsto>\<^sub>a ?xs * \<up> (r = ?xs ! ?i)>
Add Hoare triple SepAuto.upd_rule
<?a \<mapsto>\<^sub>a ?xs * \<up> (?i < length ?xs)> Array.upd ?i ?x ?a
<%r. ?a \<mapsto>\<^sub>a ?xs[?i := ?x] * \<up> (r = ?a)>
Add Hoare triple SepAuto.return_rule
<emp> return ?x <%r. \<up> (r = ?x)>
Add Hoare triple SepAuto.ref_rule
<emp> ref ?x <%r. r \<mapsto>\<^sub>r ?x>
Add Hoare triple SepAuto.lookup_rule
<?p \<mapsto>\<^sub>r ?x> !?p <%r. ?p \<mapsto>\<^sub>r ?x * \<up> (r = ?x)>
Add Hoare triple SepAuto.new_rule
<emp> Array.new ?n ?x <%r. r \<mapsto>\<^sub>a replicate ?n ?x>
Add Hoare triple SepAuto.of_list_rule
<emp> Array.of_list ?xs <%r. r \<mapsto>\<^sub>a ?xs>
Add Hoare triple SepAuto.length_rule
<?a \<mapsto>\<^sub>a ?xs> Array.len ?a
<%r. ?a \<mapsto>\<^sub>a ?xs * \<up> (r = length ?xs)>
Add Hoare triple SepAuto.freeze_rule
<?a \<mapsto>\<^sub>a ?xs> Array.freeze ?a
<%r. ?a \<mapsto>\<^sub>a ?xs * \<up> (r = ?xs)>
### theory "Draft.SepAuto"
### 1.582s elapsed time, 3.323s cpu time, 0.323s GC time
RBTree.color.distinct_1@res
WithFact R = B
GetResolve RBTree.color.distinct_1@res
RBTree.rbt.distinct_1@res
WithFact Leaf = Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0
GetResolve RBTree.rbt.distinct_1@res
RBTree.rbt.sel_1
WithTerm lsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (lsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x21.0, RBTree.rbt.sel_1)
RBTree.rbt.sel_2
WithTerm cl Leaf
GetFact (cl Leaf = B, RBTree.rbt.sel_2)
RBTree.rbt.sel_3
WithTerm cl (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (cl (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x22.0, RBTree.rbt.sel_3)
RBTree.rbt.sel_4
WithTerm key (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (key (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x23.0, RBTree.rbt.sel_4)
RBTree.rbt.sel_5
WithTerm val (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (val (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x24.0, RBTree.rbt.sel_5)
RBTree.rbt.sel_6
WithTerm rsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0)
GetFact (rsub (Node ?x21.0 ?x22.0 ?x23.0 ?x24.0 ?x25.0) = ?x25.0, RBTree.rbt.sel_6)
RBTree.rbt.collapse
WithGoal ?rbt = Leaf
GetFact (Node (lsub ?rbt) (cl ?rbt) (key ?rbt) (val ?rbt) (rsub ?rbt) = ?rbt, RBTree.rbt.collapse)
RBTree.not_R
WithGoal ?c = R
GetFact (?c = B, RBTree.not_R)
RBTree.not_B
WithGoal ?c = B
GetFact (?c = R, RBTree.not_B)
RBTree.red_not_leaf
WithFact cl ?t = R
GetGoal (?t = Leaf, RBTree.red_not_leaf)
Found termination order: "size <*mlex*> {}"
RBTree.black_depth.simps_1
WithTerm black_depth Leaf
GetFact (black_depth Leaf = 0, RBTree.black_depth.simps_1)
RBTree.black_depth.simps_2
WithTerm black_depth (Node ?l R ?k ?v ?r)
GetFact (black_depth (Node ?l R ?k ?v ?r) = black_depth ?l, RBTree.black_depth.simps_2)
RBTree.black_depth.simps_3
WithTerm black_depth (Node ?l B ?k ?v ?r)
GetFact (black_depth (Node ?l B ?k ?v ?r) = black_depth ?l + 1, RBTree.black_depth.simps_3)
Found termination order: "size <*mlex*> {}"
RBTree.cl_inv.simps_1@eqforward
WithFact cl_inv Leaf
GetFact (True, RBTree.cl_inv.simps_1@eqforward)
RBTree.cl_inv.simps_1@invbackward
WithGoal cl_inv Leaf
GetGoal (True, RBTree.cl_inv.simps_1@invbackward)
RBTree.cl_inv.simps_2@eqforward
WithFact cl_inv (Node ?l R ?k ?v ?r)
GetFact (cl_inv ?l & cl_inv ?r & cl ?l = B & cl ?r = B, RBTree.cl_inv.simps_2@eqforward)
RBTree.cl_inv.simps_2@invbackward
WithGoal cl_inv (Node ?l R ?k ?v ?r)
GetGoal (cl_inv ?l & cl_inv ?r & cl ?l = B & cl ?r = B, RBTree.cl_inv.simps_2@invbackward)
RBTree.cl_inv.simps_3@eqforward
WithFact cl_inv (Node ?l B ?k ?v ?r)
GetFact (cl_inv ?l & cl_inv ?r, RBTree.cl_inv.simps_3@eqforward)
RBTree.cl_inv.simps_3@invbackward
WithGoal cl_inv (Node ?l B ?k ?v ?r)
GetGoal (cl_inv ?l & cl_inv ?r, RBTree.cl_inv.simps_3@invbackward)
Found termination order: "size <*mlex*> {}"
RBTree.bd_inv.simps_1@eqforward
WithFact bd_inv Leaf
GetFact (True, RBTree.bd_inv.simps_1@eqforward)
RBTree.bd_inv.simps_1@invbackward
WithGoal bd_inv Leaf
GetGoal (True, RBTree.bd_inv.simps_1@invbackward)
RBTree.bd_inv.simps_2@eqforward
WithFact bd_inv (Node ?l ?c ?k ?v ?r)
GetFact (bd_inv ?l & bd_inv ?r & black_depth ?l = black_depth ?r, RBTree.bd_inv.simps_2@eqforward)
RBTree.bd_inv.simps_2@invbackward
WithGoal bd_inv (Node ?l ?c ?k ?v ?r)
GetGoal (bd_inv ?l & bd_inv ?r & black_depth ?l = black_depth ?r, RBTree.bd_inv.simps_2@invbackward)
RBTree.is_rbt_def@eqforward
WithFact is_rbt ?t
GetFact (cl_inv ?t & bd_inv ?t, RBTree.is_rbt_def@eqforward)
RBTree.is_rbt_def@invbackward
WithGoal is_rbt ?t
GetGoal (cl_inv ?t & bd_inv ?t, RBTree.is_rbt_def@invbackward)
RBTree.cl_invI
WithProperty cl_inv ?l
WithProperty cl_inv ?r
WithTerm Node ?l B ?k ?v ?r
GetFact (cl_inv (Node ?l B ?k ?v ?r), RBTree.cl_invI)
RBTree.bd_invI
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithTerm Node ?l ?c ?k ?v ?r
WithFact black_depth ?l = black_depth ?r
GetFact (bd_inv (Node ?l ?c ?k ?v ?r), RBTree.bd_invI)
RBTree.is_rbt_rec
WithFact is_rbt (Node ?l ?c ?k ?v ?r)
GetFact (is_rbt ?l & is_rbt ?r, RBTree.is_rbt_rec)
RBTree.two_distrib
WithTerm 2 * (?a + 1)
GetFact (2 * (?a + 1) = 2 * ?a + 2, RBTree.two_distrib)
Found termination order: "size <*mlex*> {}"
RBTree.min_depth.simps_1
WithTerm min_depth Leaf
GetFact (min_depth Leaf = 0, RBTree.min_depth.simps_1)
RBTree.min_depth.simps_2
WithTerm min_depth (Node ?l ?c ?k ?v ?r)
GetFact (min_depth (Node ?l ?c ?k ?v ?r) = min (min_depth ?l) (min_depth ?r) + 1, RBTree.min_depth.simps_2)
Found termination order: "size <*mlex*> {}"
RBTree.max_depth.simps_1
WithTerm max_depth Leaf
GetFact (max_depth Leaf = 0, RBTree.max_depth.simps_1)
RBTree.max_depth.simps_2
WithTerm max_depth (Node ?l ?c ?k ?v ?r)
GetFact (max_depth (Node ?l ?c ?k ?v ?r) = max (max_depth ?l) (max_depth ?r) + 1, RBTree.max_depth.simps_2)
Found termination order: "{}"
RBTree.cl_inv'.simps_1@eqforward
WithFact cl_inv' Leaf
GetFact (True, RBTree.cl_inv'.simps_1@eqforward)
RBTree.cl_inv'.simps_1@invbackward
WithGoal cl_inv' Leaf
GetGoal (True, RBTree.cl_inv'.simps_1@invbackward)
RBTree.cl_inv'.simps_2@eqforward
WithFact cl_inv' (Node ?l ?c ?k ?v ?r)
GetFact (cl_inv ?l & cl_inv ?r, RBTree.cl_inv'.simps_2@eqforward)
RBTree.cl_inv'.simps_2@invbackward
WithGoal cl_inv' (Node ?l ?c ?k ?v ?r)
GetGoal (cl_inv ?l & cl_inv ?r, RBTree.cl_inv'.simps_2@invbackward)
RBTree.cl_inv'B
WithProperty cl_inv' ?t
WithFact cl ?t = B
GetFact (cl_inv ?t, RBTree.cl_inv'B)
RBTree.cl_inv'B@back1
WithGoal cl_inv ?t
WithFact cl ?t = B
GetGoal (cl_inv' ?t, RBTree.cl_inv'B@back1)
RBTree.cl_inv'R
WithFact cl_inv' (Node ?l R ?k ?v ?r)
WithFact cl ?l = B
GetFact (cl ?r = B --> cl_inv (Node ?l R ?k ?v ?r), RBTree.cl_inv'R)
Add property rule for [RBTree.cl_inv]
RBTree.cl_inv'I
WithProperty cl_inv ?l
WithProperty cl_inv ?r
WithTerm Node ?l ?c ?k ?v ?r
GetFact (cl_inv' (Node ?l ?c ?k ?v ?r), RBTree.cl_inv'I)
Found termination order: "size <*mlex*> {}"
RBTree.rbt_in_traverse.simps_1
WithTerm rbt_in_traverse Leaf
GetFact (rbt_in_traverse Leaf = [], RBTree.rbt_in_traverse.simps_1)
RBTree.rbt_in_traverse.simps_2
WithTerm rbt_in_traverse (Node ?l ?c ?k ?v ?r)
GetFact (rbt_in_traverse (Node ?l ?c ?k ?v ?r) =
rbt_in_traverse ?l @ ?k # rbt_in_traverse ?r, RBTree.rbt_in_traverse.simps_2)
Found termination order: "size <*mlex*> {}"
RBTree.rbt_set.simps_1
WithTerm rbt_set Leaf
GetFact (rbt_set Leaf = {}, RBTree.rbt_set.simps_1)
RBTree.rbt_set.simps_2
WithTerm rbt_set (Node ?l ?c ?k ?v ?r)
GetFact (rbt_set (Node ?l ?c ?k ?v ?r) = {?k} Un rbt_set ?l Un rbt_set ?r, RBTree.rbt_set.simps_2)
Found termination order: "size <*mlex*> {}"
RBTree.rbt_in_traverse_pairs.simps_1
WithTerm rbt_in_traverse_pairs Leaf
GetFact (rbt_in_traverse_pairs Leaf = [], RBTree.rbt_in_traverse_pairs.simps_1)
RBTree.rbt_in_traverse_pairs.simps_2
WithTerm rbt_in_traverse_pairs (Node ?l ?c ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (Node ?l ?c ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.rbt_in_traverse_pairs.simps_2)
RBTree.rbt_in_traverse_fst
WithTerm map fst (rbt_in_traverse_pairs ?t)
GetFact (map fst (rbt_in_traverse_pairs ?t) = rbt_in_traverse ?t, RBTree.rbt_in_traverse_fst)
RBTree.rbt_map_def
WithTerm rbt_map ?t
GetFact (rbt_map ?t = map_of_alist (rbt_in_traverse_pairs ?t), RBTree.rbt_map_def)
Found termination order: "size <*mlex*> {}"
RBTree.rbt_sorted.simps_1@eqforward
WithFact rbt_sorted Leaf
GetFact (True, RBTree.rbt_sorted.simps_1@eqforward)
RBTree.rbt_sorted.simps_1@invbackward
WithGoal rbt_sorted Leaf
GetGoal (True, RBTree.rbt_sorted.simps_1@invbackward)
RBTree.rbt_sorted.simps_2@eqforward
WithFact rbt_sorted (Node ?l ?c ?k ?v ?r)
GetFact ((ALL x:rbt_set ?l. x < ?k) &
Ball (rbt_set ?r) ((<) ?k) & rbt_sorted ?l & rbt_sorted ?r, RBTree.rbt_sorted.simps_2@eqforward)
RBTree.rbt_sorted.simps_2@invbackward
WithGoal rbt_sorted (Node ?l ?c ?k ?v ?r)
GetGoal ((ALL x:rbt_set ?l. x < ?k) &
Ball (rbt_set ?r) ((<) ?k) & rbt_sorted ?l & rbt_sorted ?r, RBTree.rbt_sorted.simps_2@invbackward)
RBTree.rbt_sorted_lr
WithFact rbt_sorted (Node ?l ?c ?k ?v ?r)
GetFact (rbt_sorted ?l & rbt_sorted ?r, RBTree.rbt_sorted_lr)
RBTree.rbt_inorder_preserve_set
WithTerm rbt_set ?t
GetFact (rbt_set ?t = set (rbt_in_traverse ?t), RBTree.rbt_inorder_preserve_set)
RBTree.rbt_inorder_sorted@eqforward
WithFact rbt_sorted ?t
GetFact (strict_sorted (map fst (rbt_in_traverse_pairs ?t)), RBTree.rbt_inorder_sorted@eqforward)
RBTree.rbt_inorder_sorted@invbackward
WithGoal rbt_sorted ?t
GetGoal (strict_sorted (map fst (rbt_in_traverse_pairs ?t)), RBTree.rbt_inorder_sorted@invbackward)
Delete RBTree.rbt_set.simps_1
Delete RBTree.rbt_set.simps_2
Delete RBTree.rbt_sorted.simps_1@eqforward
Delete RBTree.rbt_sorted.simps_1@invbackward
Delete RBTree.rbt_sorted.simps_2@eqforward
Delete RBTree.rbt_sorted.simps_2@invbackward
RBTree.balanceR_def
WithTerm balanceR ?l ?k ?v ?r
GetFact (balanceR ?l ?k ?v ?r =
(if cl ?r = R
 then let lr = lsub ?r; rr = rsub ?r
      in if cl lr = R
         then Node (Node ?l B ?k ?v (lsub lr)) R (key lr) (val lr)
               (Node (rsub lr) B (key ?r) (val ?r) rr)
         else if cl rr = R
              then Node (Node ?l B ?k ?v lr) R (key ?r) (val ?r)
                    (Node (lsub rr) B (key rr) (val rr) (rsub rr))
              else Node ?l B ?k ?v ?r
 else Node ?l B ?k ?v ?r), RBTree.balanceR_def)
RBTree.balance_def
WithTerm balance ?l ?k ?v ?r
GetFact (balance ?l ?k ?v ?r =
(if cl ?l = R
 then let ll = lsub ?l; rl = rsub ?l
      in if cl ll = R
         then Node (Node (lsub ll) B (key ll) (val ll) (rsub ll)) R (key ?l)
               (val ?l) (Node (rsub ?l) B ?k ?v ?r)
         else if cl rl = R
              then Node (Node (lsub ?l) B (key ?l) (val ?l) (lsub rl)) R
                    (key rl) (val rl) (Node (rsub rl) B ?k ?v ?r)
              else balanceR ?l ?k ?v ?r
 else balanceR ?l ?k ?v ?r), RBTree.balance_def)
RBTree.balance_case
WithTerm balance ?l ?k ?v ?r
CreateConcl black_depth ?l = black_depth ?r
RBTree.balance_non_Leaf@res
WithFact balance ?l ?k ?v ?r = Leaf
GetResolve RBTree.balance_non_Leaf@res
RBTree.balance_bdinv
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithWellForm black_depth ?l = black_depth ?r
WithTerm balance ?l ?k ?v ?r
GetFact (bd_inv (balance ?l ?k ?v ?r), RBTree.balance_bdinv)
RBTree.balance_bd
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithWellForm black_depth ?l = black_depth ?r
WithTerm black_depth (balance ?l ?k ?v ?r)
GetFact (black_depth (balance ?l ?k ?v ?r) = black_depth ?l + 1, RBTree.balance_bd)
Add property rule for function RBTree.balance
Add property rule for function RBTree.balance
RBTree.balanceR_inorder_pairs
WithTerm rbt_in_traverse_pairs (balanceR ?l ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (balanceR ?l ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.balanceR_inorder_pairs)
RBTree.balance_inorder_pairs
WithTerm rbt_in_traverse_pairs (balance ?l ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (balance ?l ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.balance_inorder_pairs)
Delete RBTree.balanceR_def
Delete RBTree.balance_def
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
RBTree.ins.simps_1
WithTerm ins ?x ?v Leaf
GetFact (ins ?x ?v Leaf = Node Leaf R ?x ?v Leaf, RBTree.ins.simps_1)
RBTree.ins.simps_2
WithTerm ins ?x ?v (Node ?l ?c ?y ?w ?r)
GetFact (ins ?x ?v (Node ?l ?c ?y ?w ?r) =
(if ?c = B
 then if ?x = ?y then Node ?l B ?x ?v ?r
      else if ?x < ?y then balance (ins ?x ?v ?l) ?y ?w ?r
           else balance ?l ?y ?w (ins ?x ?v ?r)
 else if ?x = ?y then Node ?l R ?x ?v ?r
      else if ?x < ?y then Node (ins ?x ?v ?l) R ?y ?w ?r
           else Node ?l R ?y ?w (ins ?x ?v ?r)), RBTree.ins.simps_2)
RBTree.ins_non_Leaf@res
WithFact ins ?x ?v ?t = Leaf
GetResolve RBTree.ins_non_Leaf@res
Add property rule for function RBTree.ins
RBTree.bd_inv_ins@left
WithProperty bd_inv ?t
WithTerm ins ?x ?v ?t
GetFact (bd_inv (ins ?x ?v ?t), RBTree.bd_inv_ins@left)
RBTree.ins_inorder_pairs
WithProperty rbt_sorted ?t
WithTerm rbt_in_traverse_pairs (ins ?x ?v ?t)
GetFact (rbt_in_traverse_pairs (ins ?x ?v ?t) =
ordered_insert_pairs ?x ?v (rbt_in_traverse_pairs ?t), RBTree.ins_inorder_pairs)
Found termination order: "{}"
RBTree.paint.simps_1
WithTerm paint ?c Leaf
GetFact (paint ?c Leaf = Leaf, RBTree.paint.simps_1)
RBTree.paint.simps_2
WithTerm paint ?c (Node ?l ?c' ?x ?v ?r)
GetFact (paint ?c (Node ?l ?c' ?x ?v ?r) = Node ?l ?c ?x ?v ?r, RBTree.paint.simps_2)
RBTree.paint_case
WithTerm paint ?c ?t
CreateConcl ?t ~= Leaf
Add property rule for function RBTree.paint
Add property rule for function RBTree.paint
RBTree.paint_bd
WithProperty bd_inv ?t
WithWellForm ?t ~= Leaf
WithTerm black_depth (paint R ?t)
WithFact cl ?t = B
GetFact (black_depth (paint R ?t) = black_depth ?t - 1, RBTree.paint_bd)
RBTree.paint_in_traverse_pairs
WithTerm rbt_in_traverse_pairs (paint ?c ?t)
GetFact (rbt_in_traverse_pairs (paint ?c ?t) = rbt_in_traverse_pairs ?t, RBTree.paint_in_traverse_pairs)
RBTree.rbt_insert_def
WithTerm rbt_insert ?x ?v ?t
GetFact (rbt_insert ?x ?v ?t = paint B (ins ?x ?v ?t), RBTree.rbt_insert_def)
Add property rule for function RBTree.rbt_insert
Add property rule for function RBTree.rbt_insert
RBTree.insert_rbt_map
WithProperty rbt_sorted ?t
WithTerm rbt_map (rbt_insert ?x ?v ?t)
GetFact (rbt_map (rbt_insert ?x ?v ?t) =  rbt_map ?t { ?x \<rightarrow> ?v }, RBTree.insert_rbt_map)
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
RBTree.rbt_search.simps_1
WithTerm rbt_search Leaf ?x
GetFact (rbt_search Leaf ?x = None, RBTree.rbt_search.simps_1)
RBTree.rbt_search.simps_2
WithTerm rbt_search (Node ?l ?c ?y ?w ?r) ?x
GetFact (rbt_search (Node ?l ?c ?y ?w ?r) ?x =
(if ?x = ?y then Some ?w
 else if ?x < ?y then rbt_search ?l ?x else rbt_search ?r ?x), RBTree.rbt_search.simps_2)
RBTree.rbt_search_correct
WithProperty rbt_sorted ?t
WithTerm rbt_search ?t ?x
GetFact (rbt_search ?t ?x = rbt_map ?t\<langle>?x\<rangle>, RBTree.rbt_search_correct)
RBTree.balL_def
WithTerm balL ?l ?k ?v ?r
GetFact (balL ?l ?k ?v ?r =
(let lr = lsub ?r
 in if cl ?l = R
    then Node (Node (lsub ?l) B (key ?l) (val ?l) (rsub ?l)) R ?k ?v ?r
    else if ?r = Leaf then Node ?l R ?k ?v ?r
         else if cl ?r = B
              then balance ?l ?k ?v
                    (Node (lsub ?r) R (key ?r) (val ?r) (rsub ?r))
              else if lr = Leaf then Node ?l R ?k ?v ?r
                   else if cl lr = B
                        then Node (Node ?l B ?k ?v (lsub lr)) R (key lr)
                              (val lr)
                              (balance (rsub lr) (key ?r) (val ?r)
                                (paint R (rsub ?r)))
                        else Node ?l R ?k ?v ?r), RBTree.balL_def)
RBTree.balL_case
WithTerm balL ?l ?k ?v ?r
CreateConcl black_depth ?l + 1 = black_depth ?r
RBTree.balR_def
WithTerm balR ?l ?k ?v ?r
GetFact (balR ?l ?k ?v ?r =
(let rl = rsub ?l
 in if cl ?r = R
    then Node ?l R ?k ?v (Node (lsub ?r) B (key ?r) (val ?r) (rsub ?r))
    else if ?l = Leaf then Node ?l R ?k ?v ?r
         else if cl ?l = B
              then balance (Node (lsub ?l) R (key ?l) (val ?l) (rsub ?l)) ?k
                    ?v ?r
              else if rl = Leaf then Node ?l R ?k ?v ?r
                   else if cl rl = B
                        then Node
                              (balance (paint R (lsub ?l)) (key ?l) (val ?l)
                                (lsub rl))
                              R (key rl) (val rl)
                              (Node (rsub rl) B ?k ?v ?r)
                        else Node ?l R ?k ?v ?r), RBTree.balR_def)
RBTree.balR_case
WithTerm balR ?l ?k ?v ?r
CreateConcl black_depth ?l = black_depth ?r + 1
RBTree.balL_bd
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithTerm balL ?l ?k ?v ?r
WithFact cl ?r = B
GetFact (black_depth ?l + 1 = black_depth ?r -->
bd_inv (balL ?l ?k ?v ?r) &
black_depth (balL ?l ?k ?v ?r) = black_depth ?l + 1, RBTree.balL_bd)
RBTree.balL_bd'
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithProperty cl_inv ?r
WithWellForm black_depth ?l + 1 = black_depth ?r
WithTerm balL ?l ?k ?v ?r
GetFact (bd_inv (balL ?l ?k ?v ?r) &
black_depth (balL ?l ?k ?v ?r) = black_depth ?l + 1, RBTree.balL_bd')
RBTree.balL_cl
WithProperty cl_inv' ?l
WithProperty cl_inv ?r
WithTerm balL ?l ?k ?v ?r
WithFact cl ?r = B
GetFact (cl_inv (balL ?l ?k ?v ?r), RBTree.balL_cl)
Add property rule for function RBTree.balL
RBTree.balR_bd
WithProperty bd_inv ?l
WithProperty bd_inv ?r
WithProperty cl_inv ?l
WithWellForm black_depth ?l = black_depth ?r + 1
WithTerm balR ?l ?k ?v ?r
GetFact (bd_inv (balR ?l ?k ?v ?r) & black_depth (balR ?l ?k ?v ?r) = black_depth ?l, RBTree.balR_bd)
RBTree.balR_cl
WithProperty cl_inv ?l
WithProperty cl_inv' ?r
WithTerm balR ?l ?k ?v ?r
WithFact cl ?l = B
GetFact (cl_inv (balR ?l ?k ?v ?r), RBTree.balR_cl)
Add property rule for function RBTree.balR
RBTree.balL_in_traverse_pairs
WithTerm rbt_in_traverse_pairs (balL ?l ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (balL ?l ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.balL_in_traverse_pairs)
RBTree.balR_in_traverse_pairs
WithTerm rbt_in_traverse_pairs (balR ?l ?k ?v ?r)
GetFact (rbt_in_traverse_pairs (balR ?l ?k ?v ?r) =
rbt_in_traverse_pairs ?l @ (?k, ?v) # rbt_in_traverse_pairs ?r, RBTree.balR_in_traverse_pairs)
Delete RBTree.balL_def
Delete RBTree.balR_def
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
RBTree.combine.simps_1
WithTerm combine Leaf ?t
GetFact (combine Leaf ?t = ?t, RBTree.combine.simps_1)
RBTree.combine.simps_2
WithTerm combine (Node ?v ?va ?vb ?vc ?vd) Leaf
GetFact (combine (Node ?v ?va ?vb ?vc ?vd) Leaf = Node ?v ?va ?vb ?vc ?vd, RBTree.combine.simps_2)
RBTree.combine_bd
WithProperty bd_inv ?lt
WithProperty bd_inv ?rt
WithTerm combine ?lt ?rt
WithFact black_depth ?lt = black_depth ?rt
GetFact (bd_inv (combine ?lt ?rt) & black_depth (combine ?lt ?rt) = black_depth ?lt, RBTree.combine_bd)
RBTree.combine_cl
WithProperty cl_inv ?lt
WithProperty cl_inv ?rt
WithTerm combine ?lt ?rt
GetFact ((cl ?lt = B --> cl ?rt = B --> cl_inv (combine ?lt ?rt)) &
cl_inv' (combine ?lt ?rt), RBTree.combine_cl)
RBTree.combine_in_traverse_pairs
WithTerm rbt_in_traverse_pairs (combine ?lt ?rt)
GetFact (rbt_in_traverse_pairs (combine ?lt ?rt) =
rbt_in_traverse_pairs ?lt @ rbt_in_traverse_pairs ?rt, RBTree.combine_in_traverse_pairs)
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
RBTree.del.simps_1
WithTerm del ?x Leaf
GetFact (del ?x Leaf = Leaf, RBTree.del.simps_1)
RBTree.del_bd
WithProperty bd_inv ?t
WithProperty cl_inv ?t
WithTerm del ?x ?t
GetFact (bd_inv (del ?x ?t) &
(if cl ?t = R then black_depth (del ?x ?t) = black_depth ?t
 else black_depth (del ?x ?t) = black_depth ?t - 1), RBTree.del_bd)
RBTree.del_cl
WithProperty cl_inv ?t
WithTerm del ?x ?t
GetFact (if cl ?t = R then cl_inv (del ?x ?t) else cl_inv' (del ?x ?t), RBTree.del_cl)
RBTree.del_in_traverse_pairs
WithProperty rbt_sorted ?t
WithTerm rbt_in_traverse_pairs (del ?x ?t)
GetFact (rbt_in_traverse_pairs (del ?x ?t) =
remove_elt_pairs ?x (rbt_in_traverse_pairs ?t), RBTree.del_in_traverse_pairs)
RBTree.delete_def
WithTerm delete ?x ?t
GetFact (delete ?x ?t = paint B (del ?x ?t), RBTree.delete_def)
Add property rule for function RBTree.delete
Add property rule for function RBTree.delete
RBTree.delete_rbt_map
WithProperty rbt_sorted ?t
WithTerm rbt_map (delete ?x ?t)
GetFact (rbt_map (delete ?x ?t) = delete_map ?x (rbt_map ?t), RBTree.delete_rbt_map)
Delete RBTree.balance_case
Delete RBTree.balL_case
Delete RBTree.balR_case
Delete RBTree.paint_case
### theory "Draft.RBTree"
### 2.441s elapsed time, 3.457s cpu time, 0.350s GC time
Loading theory "Draft.RBTree_Impl" (required by "Draft.RBTree_ImplMoreTemplates")
RBTree_Impl.rbt_node.sel_1
WithTerm rbt_node.lsub (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.lsub (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x1.0, RBTree_Impl.rbt_node.sel_1)
RBTree_Impl.rbt_node.sel_2
WithTerm rbt_node.cl (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.cl (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x2.0, RBTree_Impl.rbt_node.sel_2)
RBTree_Impl.rbt_node.sel_3
WithTerm rbt_node.key (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.key (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x3.0, RBTree_Impl.rbt_node.sel_3)
RBTree_Impl.rbt_node.sel_4
WithTerm rbt_node.val (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.val (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x4.0, RBTree_Impl.rbt_node.sel_4)
RBTree_Impl.rbt_node.sel_5
WithTerm rbt_node.rsub (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0)
GetFact (rbt_node.rsub (rbt_node.Node ?x1.0 ?x2.0 ?x3.0 ?x4.0 ?x5.0) = ?x5.0, RBTree_Impl.rbt_node.sel_5)
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Add forward entailment RBTree_Impl.btree.simps_1@forward
btree Leaf ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add backward entailment RBTree_Impl.btree.simps_1@backward
\<up> (?p = None) \<Longrightarrow>\<^sub>A btree Leaf ?p
Add forward entailment RBTree_Impl.btree.simps_2@forward
btree (rbt.Node ?lt ?c ?k ?v ?rt) (Some ?p) \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Alp rp.
   ?p \<mapsto>\<^sub>r rbt_node.Node lp ?c ?k ?v rp * btree ?lt lp *
   btree ?rt rp
Add backward entailment RBTree_Impl.btree.simps_2@backward
\<exists>\<^sub>Alp rp.
   ?p \<mapsto>\<^sub>r rbt_node.Node lp ?c ?k ?v rp * btree ?lt lp *
   btree ?rt rp \<Longrightarrow>\<^sub>A
btree (rbt.Node ?lt ?c ?k ?v ?rt) (Some ?p)
Add forward entailment RBTree_Impl.btree.simps_3@forward
btree (rbt.Node ?lt ?c ?k ?v ?rt) None \<Longrightarrow>\<^sub>A false
Add backward entailment RBTree_Impl.btree.simps_3@backward
false \<Longrightarrow>\<^sub>A btree (rbt.Node ?lt ?c ?k ?v ?rt) None
Add forward entailment RBTree_Impl.btree_Leaf
btree Leaf ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)
Add forward entailment RBTree_Impl.btree_Node
btree (rbt.Node ?lt ?c ?k ?v ?rt) ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>Alp rp.
   the ?p \<mapsto>\<^sub>r rbt_node.Node lp ?c ?k ?v rp * btree ?lt lp *
   btree ?rt rp *
   \<up> (?p ~= None)
Delete RBTree_Impl.btree.simps_1@forward@ent
Delete RBTree_Impl.btree.simps_1@forward@hoare_ent
Delete RBTree_Impl.btree.simps_1@backward@entback
Delete RBTree_Impl.btree.simps_2@forward@ent
Delete RBTree_Impl.btree.simps_2@forward@hoare_ent
Delete RBTree_Impl.btree.simps_2@backward@entback
Delete RBTree_Impl.btree.simps_3@forward@ent
Delete RBTree_Impl.btree.simps_3@forward@hoare_ent
Delete RBTree_Impl.btree.simps_3@backward@entback
Add Hoare triple RBTree_Impl.tree_empty_rule
<emp> tree_empty <btree Leaf>
Add Hoare triple RBTree_Impl.btree_constr_rule
<btree ?lt ?lp * btree ?rt ?rp> btree_constr ?lp ?c ?k ?v ?rp
<btree (rbt.Node ?lt ?c ?k ?v ?rt)>
Add Hoare triple RBTree_Impl.set_color_rule
<btree (rbt.Node ?a ?c ?x ?v ?b) ?p> set_color ?c' ?p
<%_. btree (rbt.Node ?a ?c' ?x ?v ?b) ?p>
Add Hoare triple RBTree_Impl.get_color_rule
<btree ?t ?p> get_color ?p <%r. btree ?t ?p * \<up> (r = rbt.cl ?t)>
Add Hoare triple RBTree_Impl.paint_rule
<btree ?t ?p> RBTree_Impl.paint ?c ?p <%_. btree (RBTree.paint ?c ?t) ?p>
Add Hoare triple RBTree_Impl.btree_rotate_l_rule
<btree (rbt.Node ?a ?c1.0 ?x ?v (rbt.Node ?b ?c2.0 ?y ?w ?c)) ?p>
btree_rotate_l ?p
<btree (rbt.Node (rbt.Node ?a ?c1.0 ?x ?v ?b) ?c2.0 ?y ?w ?c)>
Add Hoare triple RBTree_Impl.btree_rotate_r_rule
<btree (rbt.Node (rbt.Node ?a ?c1.0 ?x ?v ?b) ?c2.0 ?y ?w ?c) ?p>
btree_rotate_r ?p
<btree (rbt.Node ?a ?c1.0 ?x ?v (rbt.Node ?b ?c2.0 ?y ?w ?c))>
Add Hoare triple RBTree_Impl.balanceR_to_fun
<btree (rbt.Node ?l B ?k ?v ?r) ?p> btree_balanceR ?p
<btree (balanceR ?l ?k ?v ?r)>
Add Hoare triple RBTree_Impl.balance_to_fun
<btree (rbt.Node ?l B ?k ?v ?r) ?p> btree_balance ?p
<btree (balance ?l ?k ?v ?r)>
Add Hoare triple RBTree_Impl.rbt_ins_to_fun
<btree ?t ?p> rbt_ins ?k ?v ?p <btree (ins ?k ?v ?t)>
Add Hoare triple RBTree_Impl.rbt_insert_to_fun
<btree ?t ?p> RBTree_Impl.rbt_insert ?k ?v ?p
<btree (RBTree.rbt_insert ?k ?v ?t)>
Add Hoare triple RBTree_Impl.btree_search_correct
<btree ?t ?b * \<up> (rbt_sorted ?t)> RBTree_Impl.rbt_search ?x ?b
<%r. btree ?t ?b * \<up> (r = RBTree.rbt_search ?t ?x)>
Add Hoare triple RBTree_Impl.balL_to_fun
<btree (rbt.Node ?l R ?k ?v ?r) ?p> btree_balL ?p <btree (balL ?l ?k ?v ?r)>
Add Hoare triple RBTree_Impl.balR_to_fun
<btree (rbt.Node ?l R ?k ?v ?r) ?p> btree_balR ?p <btree (balR ?l ?k ?v ?r)>
Add Hoare triple RBTree_Impl.combine_to_fun
<btree ?lt ?lp * btree ?rt ?rp> btree_combine ?lp ?rp
<btree (combine ?lt ?rt)>
Add Hoare triple RBTree_Impl.rbt_del_to_fun
<btree ?t ?p> rbt_del ?x ?p <btree (del ?x ?t)>\<^sub>t
Add Hoare triple RBTree_Impl.rbt_delete_to_fun
<btree ?t ?p> rbt_delete ?k ?p <btree (delete ?k ?t)>\<^sub>t
Add forward entailment RBTree_Impl.rbt_map_assn_def@forward
rbt_map_assn ?M ?p \<Longrightarrow>\<^sub>A
\<exists>\<^sub>At.
   btree t ?p * \<up> (is_rbt t) * \<up> (rbt_sorted t) *
   \<up> (?M = rbt_map t)
Add backward entailment RBTree_Impl.rbt_map_assn_def@backward
\<exists>\<^sub>At.
   btree t ?p * \<up> (is_rbt t) * \<up> (rbt_sorted t) *
   \<up> (?M = rbt_map t) \<Longrightarrow>\<^sub>A
rbt_map_assn ?M ?p
Add Hoare triple RBTree_Impl.rbt_empty_rule
<emp> tree_empty <rbt_map_assn empty_map>
Add Hoare triple RBTree_Impl.rbt_insert_rule
<rbt_map_assn ?M ?b> RBTree_Impl.rbt_insert ?k ?v ?b
<rbt_map_assn ( ?M { ?k \<rightarrow> ?v })>
Add Hoare triple RBTree_Impl.rbt_search
<rbt_map_assn ?M ?b> RBTree_Impl.rbt_search ?x ?b
<%r. rbt_map_assn ?M ?b * \<up> (r = ?M\<langle>?x\<rangle>)>
Add Hoare triple RBTree_Impl.rbt_delete_rule
<rbt_map_assn ?M
  ?b> rbt_delete ?k ?b <rbt_map_assn (delete_map ?k ?M)>\<^sub>t
### theory "Draft.RBTree_Impl"
### 1.510s elapsed time, 1.670s cpu time, 0.185s GC time
Loading theory "Draft.RBTree_ImplMoreTemplates"
val templateLemmas =
   [("RBTree_Impl.btree_Leaf",
     "btree rbt.Leaf ?p \<Longrightarrow>\<^sub>A \<up> (?p = None)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 4, template_hole 3),
               template_var 0)),
           template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 0),
               template_hole 0)))
         )),
    ("RBTree_Impl.rbt_ins_to_fun",
     "<btree ?t ?p> rbt_ins ?k ?v ?p <btree (ins ?k ?v ?t)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 2, template_var 3),
                 template_var 2)),
             template_app
              (template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0),
               template_var 2)),
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 0),
               template_var 3)))
         )),
    ("RBTree_Impl.rbt_insert_to_fun",
     "<btree ?t ?p> RBTree_Impl.rbt_insert ?k ?v ?p
      <btree (RBTree.rbt_insert ?k ?v ?t)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 2, template_var 3),
                 template_var 2)),
             template_app
              (template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0),
               template_var 2)),
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_app (template_hole 0, template_var 1),
                 template_var 0),
               template_var 3)))
         )),
    ("RBTree_Impl.rbt_insert_rule",
     "<rbt_map_assn ?M ?b> RBTree_Impl.rbt_insert ?k ?v ?b
      <rbt_map_assn ( ?M { ?k \<rightarrow> ?v })>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 2, template_var 3),
                 template_var 2)),
             template_app
              (template_app
                (template_app (template_hole 1, template_var 1),
                 template_var 0),
               template_var 2)),
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_app (template_hole 0, template_var 3),
                 template_var 1),
               template_var 0)))
         )),
    ("RBTree_Impl.paint_rule",
     "<btree ?t ?p> RBTree_Impl.paint ?c ?p
      <%_. btree (RBTree.paint ?c ?t) ?p>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 2, template_var 2),
                 template_var 1)),
             template_app
              (template_app (template_hole 1, template_var 0),
               template_var 1)),
           t_empty)
         )),
    ("RBTree_Impl.combine_to_fun",
     "<btree ?lt ?lp * btree ?rt ?rp> btree_combine ?lp ?rp
      <btree (combine ?lt ?rt)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 2, template_var 3),
                     template_var 2)),
                 template_app
                  (template_app (template_hole 2, template_var 1),
                   template_var 0))),
             template_app
              (template_app (template_hole 1, template_var 2),
               template_var 0)),
           template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 0, template_var 3),
               template_var 1)))
         )),
    ("RBTree_Impl.rbt_del_to_fun",
     "<btree ?t ?p> rbt_del ?x ?p <btree (del ?x ?t)>\<^sub>t",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_var 2),
                 template_var 1)),
             template_app
              (template_app (template_hole 3, template_var 0),
               template_var 1)),
           t_empty)
         )),
    ("RBTree_Impl.rbt_delete_to_fun",
     "<btree ?t ?p> rbt_delete ?k ?p <btree (delete ?k ?t)>\<^sub>t",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_var 2),
                 template_var 1)),
             template_app
              (template_app (template_hole 3, template_var 0),
               template_var 1)),
           t_empty)
         )),
    ("RBTree_Impl.rbt_delete_rule",
     "<rbt_map_assn ?M
        ?b> rbt_delete ?k ?b <rbt_map_assn (delete_map ?k ?M)>\<^sub>t",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app (template_hole 4, template_var 2),
                 template_var 1)),
             template_app
              (template_app (template_hole 3, template_var 0),
               template_var 1)),
           t_empty)
         )),
    ("RBTree_Impl.get_color_rule",
     "<btree ?t ?p> get_color ?p <%r. btree ?t ?p * \<up> (r = rbt.cl ?t)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_var 1),
                 template_var 0)),
             template_app (template_hole 4, template_var 0)),
           t_empty)
         )),
    ("RBTree_Impl.tree_is_empty_rule",
     "<btree ?t ?b> tree_is_empty ?b
      <%r. btree ?t ?b * \<up> (r = (?t = rbt.Leaf))>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app (template_hole 6, template_var 1),
                 template_var 0)),
             template_app (template_hole 5, template_var 0)),
           t_empty)
         )),
    ("RBTree_Impl.balance_to_fun",
     "<btree (rbt.Node ?l B ?k ?v ?r) ?p> btree_balance ?p
      <btree (balance ?l ?k ?v ?r)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app (template_hole 3, template_var 4),
                           template_hole 2),
                         template_var 3),
                       template_var 2),
                     template_var 1)),
                 template_var 0)),
             template_app (template_hole 1, template_var 0)),
           template_app
            (template_hole 4,
             template_app
              (template_app
                (template_app
                  (template_app (template_hole 0, template_var 4),
                   template_var 3),
                 template_var 2),
               template_var 1)))
         )),
    ("RBTree_Impl.balanceR_to_fun",
     "<btree (rbt.Node ?l B ?k ?v ?r) ?p> btree_balanceR ?p
      <btree (balanceR ?l ?k ?v ?r)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app (template_hole 3, template_var 4),
                           template_hole 2),
                         template_var 3),
                       template_var 2),
                     template_var 1)),
                 template_var 0)),
             template_app (template_hole 1, template_var 0)),
           template_app
            (template_hole 4,
             template_app
              (template_app
                (template_app
                  (template_app (template_hole 0, template_var 4),
                   template_var 3),
                 template_var 2),
               template_var 1)))
         )),
    ("RBTree_Impl.balL_to_fun",
     "<btree (rbt.Node ?l R ?k ?v ?r) ?p> btree_balL ?p
      <btree (balL ?l ?k ?v ?r)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app (template_hole 3, template_var 4),
                           template_hole 2),
                         template_var 3),
                       template_var 2),
                     template_var 1)),
                 template_var 0)),
             template_app (template_hole 1, template_var 0)),
           template_app
            (template_hole 4,
             template_app
              (template_app
                (template_app
                  (template_app (template_hole 0, template_var 4),
                   template_var 3),
                 template_var 2),
               template_var 1)))
         )),
    ("RBTree_Impl.balR_to_fun",
     "<btree (rbt.Node ?l R ?k ?v ?r) ?p> btree_balR ?p
      <btree (balR ?l ?k ?v ?r)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 5,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app (template_hole 3, template_var 4),
                           template_hole 2),
                         template_var 3),
                       template_var 2),
                     template_var 1)),
                 template_var 0)),
             template_app (template_hole 1, template_var 0)),
           template_app
            (template_hole 4,
             template_app
              (template_app
                (template_app
                  (template_app (template_hole 0, template_var 4),
                   template_var 3),
                 template_var 2),
               template_var 1)))
         )),
    ("RBTree_Impl.rbt_search",
     "<rbt_map_assn ?M ?b> RBTree_Impl.rbt_search ?x ?b
      <%r. rbt_map_assn ?M ?b * \<up> (r = ?M\<langle>?x\<rangle>)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 6,
               template_app
                (template_app (template_hole 5, template_var 2),
                 template_var 1)),
             template_app
              (template_app (template_hole 4, template_var 0),
               template_var 1)),
           t_empty)
         )),
    ("RBTree_Impl.btree_constr_rule",
     "<btree ?lt ?lp * btree ?rt ?rp> btree_constr ?lp ?c ?k ?v ?rp
      <btree (rbt.Node ?lt ?c ?k ?v ?rt)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 4,
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 2, template_var 6),
                     template_var 5)),
                 template_app
                  (template_app (template_hole 2, template_var 4),
                   template_var 3))),
             template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 1, template_var 5),
                     template_var 2),
                   template_var 1),
                 template_var 0),
               template_var 3)),
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 0, template_var 6),
                     template_var 2),
                   template_var 1),
                 template_var 0),
               template_var 4)))
         )),
    ("RBTree_Impl.set_color_rule",
     "<btree (rbt.Node ?a ?c ?x ?v ?b) ?p> set_color ?c' ?p
      <%_. btree (rbt.Node ?a ?c' ?x ?v ?b) ?p>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app (template_hole 1, template_var 6),
                           template_var 5),
                         template_var 4),
                       template_var 3),
                     template_var 2)),
                 template_var 1)),
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 1)),
           t_empty)
         )),
    ("RBTree_Impl.btree_search_correct",
     "<btree ?t ?b * \<up> (rbt_sorted ?t)> RBTree_Impl.rbt_search ?x ?b
      <%r. btree ?t ?b * \<up> (r = RBTree.rbt_search ?t ?x)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 7,
               template_app
                (template_app
                  (template_hole 6,
                   template_app
                    (template_app (template_hole 5, template_var 2),
                     template_var 1)),
                 template_app
                  (template_hole 4,
                   template_app (template_hole 3, template_var 2)))),
             template_app
              (template_app (template_hole 2, template_var 0),
               template_var 1)),
           t_empty)
         )),
    ("RBTree_Impl.btree_constr_ent",
     "?p \<mapsto>\<^sub>r rbt_node.Node ?lp ?c ?k ?v ?rp * btree ?lt ?lp *
      btree ?rt ?rp \<Longrightarrow>\<^sub>A
      btree (rbt.Node ?lt ?c ?k ?v ?rt) (Some ?p)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 6,
             template_app
              (template_app
                (template_hole 5,
                 template_app
                  (template_app
                    (template_hole 5,
                     template_app
                      (template_app (template_hole 4, template_var 7),
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_hole 3, template_var 6),
                               template_var 5),
                             template_var 4),
                           template_var 3),
                         template_var 2))),
                   template_app
                    (template_app (template_hole 2, template_var 1),
                     template_var 6))),
               template_app
                (template_app (template_hole 2, template_var 0),
                 template_var 2))),
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 1, template_var 1),
                       template_var 5),
                     template_var 4),
                   template_var 3),
                 template_var 0)),
             template_app (template_hole 0, template_var 7)))
         )),
    ("RBTree_Impl.btree_rotate_l_rule",
     "<btree (rbt.Node ?a ?c1.0 ?x ?v (rbt.Node ?b ?c2.0 ?y ?w ?c)) ?p>
      btree_rotate_l ?p
      <btree (rbt.Node (rbt.Node ?a ?c1.0 ?x ?v ?b) ?c2.0 ?y ?w ?c)>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app (template_hole 1, template_var 9),
                           template_var 8),
                         template_var 7),
                       template_var 6),
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app (template_hole 1, template_var 5),
                             template_var 4),
                           template_var 3),
                         template_var 2),
                       template_var 1))),
                 template_var 0)),
             template_app (template_hole 0, template_var 0)),
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_app
                  (template_app
                    (template_app
                      (template_hole 1,
                       template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_hole 1, template_var 9),
                               template_var 8),
                             template_var 7),
                           template_var 6),
                         template_var 5)),
                     template_var 4),
                   template_var 3),
                 template_var 2),
               template_var 1)))
         )),
    ("RBTree_Impl.btree_rotate_r_rule",
     "<btree (rbt.Node (rbt.Node ?a ?c1.0 ?x ?v ?b) ?c2.0 ?y ?w ?c) ?p>
      btree_rotate_r ?p
      <btree (rbt.Node ?a ?c1.0 ?x ?v (rbt.Node ?b ?c2.0 ?y ?w ?c))>",
     template_predicate
      (
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_hole 2,
                   template_app
                    (template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_hole 1,
                             template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_app
(template_hole 1, template_var 9),
                                     template_var 8),
                                   template_var 7),
                                 template_var 6),
                               template_var 5)),
                           template_var 4),
                         template_var 3),
                       template_var 2),
                     template_var 1)),
                 template_var 0)),
             template_app (template_hole 0, template_var 0)),
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 1, template_var 9),
                     template_var 8),
                   template_var 7),
                 template_var 6),
               template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app (template_hole 1, template_var 5),
                       template_var 4),
                     template_var 3),
                   template_var 2),
                 template_var 1))))
         )),
    ("RBTree_Impl.btree_Node",
     "btree (rbt.Node ?lt ?c ?k ?v ?rt) ?p \<Longrightarrow>\<^sub>A
      \<exists>\<^sub>Alp rp.
         the ?p \<mapsto>\<^sub>r rbt_node.Node lp ?c ?k ?v rp *
         btree ?lt lp *
         btree ?rt rp *
         \<up> (?p ~= None)",
     template_predicate
      (
         template_app
          (template_app
            (template_hole 11,
             template_app
              (template_app
                (template_hole 10,
                 template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 9, template_var 5),
                         template_var 4),
                       template_var 3),
                     template_var 2),
                   template_var 1)),
               template_var 0)),
           template_app (template_hole 8, t_empty))
         ))]:
   (string * thm * template) list
### theory "Draft.RBTree_ImplMoreTemplates"
### 0.520s elapsed time, 0.731s cpu time, 0.085s GC time
val it = (): unit
