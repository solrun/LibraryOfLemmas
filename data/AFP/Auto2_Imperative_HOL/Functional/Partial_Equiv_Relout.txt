Loading theory "Auto2_HOL.HOL_Base" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms" via "Auto2_HOL.Logic_Thms" via "Auto2_HOL.Auto2_HOL")
Loading theory "HOL-Library.Cancellation" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms" via "Auto2_HOL.Set_Thms" via "HOL-Library.Multiset")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### theory "Auto2_HOL.HOL_Base"
### 0.058s elapsed time, 0.268s cpu time, 0.000s GC time
Loading theory "Auto2_HOL.Auto2_HOL" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms" via "Auto2_HOL.Logic_Thms")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.145s elapsed time, 0.599s cpu time, 0.040s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "size_list size <*mlex*> {}"
signature BASIC_UTIL =
  sig
    val apply_to_lhs: conv -> thm -> thm
    val apply_to_rhs: conv -> thm -> thm
    val apply_to_thm: conv -> thm -> thm
    val assert: bool -> string -> unit
    val dest_arg: term -> term
    val dest_arg1: term -> term
    val filter_split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val fo_init: Type.tyenv * Envir.tenv
    val lookup_inst: Type.tyenv * Envir.tenv -> string -> term
    val lookup_instn: Type.tyenv * Envir.tenv -> string * int -> term
    val meta_sym: thm -> thm
    val propT: typ
    val the_pair: 'a list -> 'a * 'a
    val the_triple: 'a list -> 'a * 'a * 'a
    val trace_fullthm: Proof.context -> string -> thm -> unit
    val trace_fullthm_global: string -> thm -> unit
    val trace_t: Proof.context -> string -> term -> unit
    val trace_thm: Proof.context -> string -> thm -> unit
    val trace_thm_global: string -> thm -> unit
    val trace_tlist: Proof.context -> string -> term list -> unit
  end
signature UTIL =
  sig
    val all_pairs: 'a list * 'b list -> ('a * 'b) list
    val all_permutes: 'a list -> 'a list list
    val apply_to_lhs: conv -> thm -> thm
    val apply_to_rhs: conv -> thm -> thm
    val apply_to_thm: conv -> thm -> thm
    val arg_backn_conv: int -> conv -> conv
    val argn_conv: int -> conv -> conv
    val assert: bool -> string -> unit
    val assume_meta_eq: theory -> term * term -> thm
    val assume_thm: Proof.context -> term -> thm
    val comb_equiv: cterm * thm list -> thm
    val concl_conv: conv -> conv
    val concl_conv_n: int -> conv -> conv
    val cterm_pat_setup: theory -> theory
    val declare_free_term: term -> Proof.context -> Proof.context
    val defined_instn: Type.tyenv * Envir.tenv -> string * int -> bool
    val dest_arg: term -> term
    val dest_arg1: term -> term
    val dest_argn: int -> term -> term
    val dest_args: term -> term list
    val dest_binop: term -> term * (term * term)
    val dest_binop_args: term -> term * term
    val dest_binop_cargs: cterm -> cterm * cterm
    val dest_binop_head: term -> term
    val dest_cargs: cterm -> cterm list
    val eq_cong_th: int -> term -> term -> Proof.context -> thm
    val eq_env:
       (Type.tyenv * Envir.tenv) * (Type.tyenv * Envir.tenv) -> bool
    val exn_trace: (unit -> 'a) -> 'a
    val filter_split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val first_order_match_list:
       theory ->
         (term * term) list ->
           Type.tyenv * Envir.tenv -> Type.tyenv * Envir.tenv
    val fo_init: Type.tyenv * Envir.tenv
    val forall_elim_sch: thm -> thm
    val get_head_name: term -> string
    val has_subterm: term list -> term -> bool
    val has_vars: term -> bool
    val is_abs: term -> bool
    val is_head: term -> term -> bool
    val is_implies: term -> bool
    val is_just_internal: string -> bool
    val is_meta_eq: term -> bool
    val is_pattern: term -> bool
    val is_pattern_list: term list -> bool
    val is_prefix_str: string -> string -> bool
    val is_subseq: ('a * 'a -> bool) -> 'a list * 'a list -> bool
    val is_subterm: term -> term -> bool
    val lambda_abstract: term -> term -> term
    val lhs_of: thm -> term
    val list_meta_horn: term list * (term list * term) -> term
    val lookup_inst: Type.tyenv * Envir.tenv -> string -> term
    val lookup_instn: Type.tyenv * Envir.tenv -> string * int -> term
    val lookup_tyinst: Type.tyenv * Envir.tenv -> string -> typ
    val max: ('a * 'a -> order) -> 'a list -> 'a
    val max_partial: ('a -> 'a -> bool) -> 'a list -> 'a list
    val meta_sym: thm -> thm
    val name_of_thm: thm -> string
    val normalize_meta_all_imp: Proof.context -> conv
    val normalize_meta_horn: Proof.context -> conv
    val occurs_free: term -> term -> bool
    val occurs_frees: term list -> term -> bool
    val pattern_rewr_conv: term -> (term * thm) list -> conv
    val print_term_detail: Proof.context -> term -> string
    val propT: typ
    val remove_dup_lists:
       ('a * 'a -> order) -> 'a list * 'a list -> 'a list * 'a list
    val rename_abs_term: term list -> term -> term
    val repeat_n_conv: int -> conv -> conv
    val reverse_eta_conv: Proof.context -> conv
    val rhs_of: thm -> term
    val send_all_to_hyps: thm -> thm
    val send_first_to_hyps: thm -> thm
    val skip_n_conv: int -> conv -> conv
    val string_of_bool: bool -> string
    val string_of_env: Proof.context -> Envir.tenv -> string
    val string_of_list: ('a -> string) -> 'a list -> string
    val string_of_list': ('a -> string) -> 'a list -> string
    val string_of_terms: Proof.context -> term list -> string
    val string_of_terms_global: theory -> term list -> string
    val string_of_tyenv: Proof.context -> Type.tyenv -> string
    val strip_meta_horn: term -> term list * (term list * term)
    val subsets: 'a list -> 'a list list
    val subst_term_norm: Type.tyenv * Envir.tenv -> term -> term
    val subst_thm: Proof.context -> Type.tyenv * Envir.tenv -> thm -> thm
    val subst_thm_atomic: (cterm * cterm) list -> thm -> thm
    val subst_thm_thy: theory -> Type.tyenv * Envir.tenv -> thm -> thm
    val swap_meta_imp_alls: Proof.context -> conv
    val term_pat_setup: theory -> theory
    val test_conv:
       Proof.context -> conv -> string -> string * string -> unit
    val the_pair: 'a list -> 'a * 'a
    val the_triple: 'a list -> 'a * 'a * 'a
    val timer: string * (unit -> 'a) -> 'a
    val to_internal_vars:
       Proof.context -> term list * term -> term list * term
    val trace_fullthm: Proof.context -> string -> thm -> unit
    val trace_fullthm_global: string -> thm -> unit
    val trace_t: Proof.context -> string -> term -> unit
    val trace_thm: Proof.context -> string -> thm -> unit
    val trace_thm_global: string -> thm -> unit
    val trace_tlist: Proof.context -> string -> term list -> unit
    val transitive_list: thm list -> thm
    val type_pat_setup: theory -> theory
    val update_env:
       indexname * term ->
         Type.tyenv * Envir.tenv -> Type.tyenv * Envir.tenv
    val update_name_of_thm: thm -> string -> thm -> thm
  end
structure Util: UTIL
structure Basic_Util: BASIC_UTIL
val dest_arg1 = fn: term -> term
val trace_fullthm = fn: Proof.context -> string -> thm -> unit
val propT = "prop": typ
val apply_to_rhs = fn: conv -> thm -> thm
val lookup_instn = fn: Type.tyenv * Envir.tenv -> string * int -> term
val the_triple = fn: 'a list -> 'a * 'a * 'a
val filter_split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val trace_thm = fn: Proof.context -> string -> thm -> unit
val trace_tlist = fn: Proof.context -> string -> term list -> unit
val the_pair = fn: 'a list -> 'a * 'a
val apply_to_thm = fn: conv -> thm -> thm
val lookup_inst = fn: Type.tyenv * Envir.tenv -> string -> term
val apply_to_lhs = fn: conv -> thm -> thm
val trace_thm_global = fn: string -> thm -> unit
val trace_fullthm_global = fn: string -> thm -> unit
val assert = fn: bool -> string -> unit
val meta_sym = fn: thm -> thm
val trace_t = fn: Proof.context -> string -> term -> unit
val fo_init = ({}, {}): Type.tyenv * Envir.tenv
val dest_arg = fn: term -> term
signature BASIC_UTIL_BASE =
  sig
    val bFalse: term
    val bTrue: term
    val boolT: typ
    val cdest_eq: cterm -> cterm * cterm
    val dest_eq: term -> term * term
    val is_eq_term: term -> bool
    val mk_eq: term * term -> term
    val true_th: thm
  end
signature UTIL_BASE =
  sig
    val All_name: string
    val Ball_def_th: thm
    val Ball_name: string
    val Bex_def_th: thm
    val Bex_name: string
    val Conj_name: string
    val Disj_name: string
    val Ex_name: string
    val Imp_name: string
    val Mem_name: string
    val Not_name: string
    val Trueprop_name: string
    val all_trivial_th: thm
    val atomize_all_th: thm
    val atomize_conjL_th: thm
    val atomize_imp_th: thm
    val bFalse: term
    val bTrue: term
    val backward1_conv_th: thm
    val backward2_conv_th: thm
    val backward_conv_th: thm
    val boolT: typ
    val cConj: cterm
    val cDisj: cterm
    val cNot: cterm
    val cTrueprop: cterm
    val case_split_th: thm
    val cdest_eq: cterm -> cterm * cterm
    val conjI_th: thm
    val conj_assoc_th: thm
    val conj_commute_th: thm
    val conjunct1_th: thm
    val conjunct2_th: thm
    val contra_triv_th: thm
    val de_Morgan_conj_th: thm
    val de_Morgan_disj_th: thm
    val dest_eq: term -> term * term
    val disj_True1_th: thm
    val disj_True2_th: thm
    val disj_assoc_th: thm
    val disj_commute_th: thm
    val eq_True_inv_th: thm
    val eq_True_th: thm
    val exE_th': thm
    val ex_vardef_th: thm
    val iffD1_th: thm
    val iffD2_th: thm
    val iffD_th: thm
    val imp_conv_disj_th: thm
    val inv_back_th: thm
    val is_eq_term: term -> bool
    val is_if: term -> bool
    val mk_eq: term * term -> term
    val mk_setT: typ -> typ
    val nn_cancel_th: thm
    val nn_create_th: thm
    val not_all_th: thm
    val not_ex_th: thm
    val not_imp_th: thm
    val obj_sym_cv: conv
    val or_cancel1_th: thm
    val or_cancel2_th: thm
    val or_intro1_th: thm
    val or_intro2_th: thm
    val resolve_conv_th: thm
    val swap_all_disj_th: thm
    val swap_ex_conj_th: thm
    val sym_th: thm
    val to_contra_form_th: thm
    val to_contra_form_th': thm
    val to_meta_eq_cv: conv
    val to_obj_eq_cv: conv
    val to_obj_eq_iff: thm -> thm
    val true_th: thm
  end
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
### theory "HOL-Library.Nat_Bijection"
### 0.344s elapsed time, 1.382s cpu time, 0.085s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.ExtrEqs")
structure UtilBase: UTIL_BASE
structure Basic_UtilBase: BASIC_UTIL_BASE
val true_th = "True": thm
val cdest_eq = fn: cterm -> cterm * cterm
val boolT = "bool": typ
val bTrue = Const ("HOL.True", "bool"): term
val is_eq_term = fn: term -> bool
val bFalse = Const ("HOL.False", "bool"): term
val mk_eq = fn: term * term -> term
val dest_eq = fn: term -> term * term
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
### theory "HOL-Library.Set_Algebras"
### 0.228s elapsed time, 0.895s cpu time, 0.045s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.454s elapsed time, 1.800s cpu time, 0.145s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms" via "Auto2_HOL.Set_Thms")
signature BASIC_UTIL_LOGIC =
  sig
    val Not: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val apply_to_thm': conv -> thm -> thm
    val assume_eq: theory -> term * term -> thm
    val concl_of': thm -> term
    val conj: term
    val conj_left_th: thm -> thm
    val conj_right_th: thm -> thm
    val cprop_of': thm -> cterm
    val dest_Trueprop: term -> term
    val dest_imp: term -> term * term
    val dest_not: term -> term
    val disj: term
    val equiv_backward_th: thm -> thm
    val equiv_forward_th: thm -> thm
    val get_neg: term -> term
    val get_neg': term -> term
    val imp: term
    val inv_backward_th: thm -> thm
    val is_Trueprop: term -> bool
    val is_ball: term -> bool
    val is_bex: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_ex: term -> bool
    val is_imp: term -> bool
    val is_mem: term -> bool
    val is_neg: term -> bool
    val is_obj_all: term -> bool
    val is_true_th: thm -> bool
    val list_conj: term list -> term
    val list_disj: term list -> term
    val list_obj_imp: term list * term -> term
    val make_trueprop_eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_conj: term * term -> term
    val mk_disj: term * term -> term
    val mk_exists: term -> term -> term
    val mk_imp: term * term -> term
    val mk_mem: term * term -> term
    val mk_not: term -> term
    val mk_obj_all: term -> term -> term
    val obj_sym: thm -> thm
    val obj_sym_th: thm -> thm
    val pFalse: term
    val prop_of': thm -> term
    val rewr_obj_eq: thm -> conv
    val strip_conj: term -> term list
    val strip_disj: term -> term list
    val strip_obj_imp: term -> term list * term
    val to_meta_eq: thm -> thm
    val to_obj_eq: thm -> thm
    val to_obj_eq_iff_th: thm -> thm
    val to_obj_eq_th: thm -> thm
  end
signature UTIL_LOGIC =
  sig
    val Not: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val apply_to_thm': conv -> thm -> thm
    val assume_eq: theory -> term * term -> thm
    val bool_of_term: term -> bool
    val concl_of': thm -> term
    val conj: term
    val conj_left_th: thm -> thm
    val conj_right_th: thm -> thm
    val contra_by_tac:
       (Proof.context -> int -> tactic) -> Proof.context -> thm list -> thm
    val cprop_of': thm -> cterm
    val dest_Trueprop: term -> term
    val dest_imp: term -> term * term
    val dest_not: term -> term
    val disj: term
    val equiv_backward_th: thm -> thm
    val equiv_forward_th: thm -> thm
    val ex_elim: Proof.context -> term -> thm -> thm
    val force_abs_form: term -> term
    val get_all_subterms: term -> term list
    val get_all_subterms_skip_if: term -> term list
    val get_cneg: cterm -> cterm
    val get_neg: term -> term
    val get_neg': term -> term
    val imp: term
    val inv_backward_th: thm -> thm
    val is_Trueprop: term -> bool
    val is_ball: term -> bool
    val is_bex: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_ex: term -> bool
    val is_ex_form_gen: term -> bool
    val is_imp: term -> bool
    val is_mem: term -> bool
    val is_neg: term -> bool
    val is_obj_all: term -> bool
    val is_true_th: thm -> bool
    val list_conj: term list -> term
    val list_disj: term list -> term
    val list_obj_horn: term list * (term list * term) -> term
    val list_obj_imp: term list * term -> term
    val list_subterms: term -> term list
    val make_neg_eq: thm -> thm
    val make_trueprop_eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_conj: term * term -> term
    val mk_conjs_th: thm list -> thm
    val mk_disj: term * term -> term
    val mk_exists: term -> term -> term
    val mk_imp: term * term -> term
    val mk_mem: term * term -> term
    val mk_not: term -> term
    val mk_obj_all: term -> term -> term
    val normalize_exists: Proof.context -> conv
    val obj_sym: thm -> thm
    val obj_sym_th: thm -> thm
    val pFalse: term
    val prop_of': thm -> term
    val prove_by_tac:
       (Proof.context -> int -> tactic) ->
         Proof.context -> thm list -> term -> thm
    val rewr_obj_eq: thm -> conv
    val rewrite_from_contra_form: conv
    val rewrite_to_contra_form: conv
    val split_conj_gen_th: thm -> thm list
    val split_conj_th: thm -> thm list
    val split_not_disj_th: thm -> thm list
    val strip_conj: term -> term list
    val strip_disj: term -> term list
    val strip_exists: term -> term list * term
    val strip_horn': thm -> term list * term
    val strip_obj_horn: term -> term list * (term list * term)
    val strip_obj_imp: term -> term list * term
    val term_of_bool: bool -> term
    val to_meta_conv: Proof.context -> conv
    val to_meta_eq: thm -> thm
    val to_obj_conv: Proof.context -> conv
    val to_obj_conv_on_horn: Proof.context -> conv
    val to_obj_eq: thm -> thm
    val to_obj_eq_iff_th: thm -> thm
    val to_obj_eq_th: thm -> thm
  end
structure UtilLogic: UTIL_LOGIC
structure Basic_UtilLogic: BASIC_UTIL_LOGIC
val mk_obj_all = fn: term -> term -> term
val dest_not = fn: term -> term
val mk_mem = fn: term * term -> term
val apply_to_thm' = fn: conv -> thm -> thm
val mk_not = fn: term -> term
val is_true_th = fn: thm -> bool
val is_ex = fn: term -> bool
val list_conj = fn: term list -> term
val prop_of' = fn: thm -> term
val inv_backward_th = fn: thm -> thm
val assume_eq = fn: theory -> term * term -> thm
val equiv_forward_th = fn: thm -> thm
val dest_imp = fn: term -> term * term
val concl_of' = fn: thm -> term
val mk_imp = fn: term * term -> term
val strip_disj = fn: term -> term list
val pFalse =
   Const ("HOL.Trueprop", "bool => prop") $ Const ("HOL.False", "bool"):
   term
val cprop_of' = fn: thm -> cterm
val Trueprop = Const ("HOL.Trueprop", "bool => prop"): term
val strip_conj = fn: term -> term list
val mk_conj = fn: term * term -> term
val mk_Trueprop = fn: term -> term
val rewr_obj_eq = fn: thm -> conv
val disj = Const ("HOL.disj", "bool => bool => bool"): term
val strip_obj_imp = fn: term -> term list * term
val to_obj_eq = fn: thm -> thm
val Trueprop_conv = fn: conv -> conv
val imp = Const ("HOL.implies", "bool => bool => bool"): term
val is_neg = fn: term -> bool
val dest_Trueprop = fn: term -> term
val make_trueprop_eq = fn: thm -> thm
val is_bex = fn: term -> bool
val conj_left_th = fn: thm -> thm
val is_ball = fn: term -> bool
val is_disj = fn: term -> bool
val obj_sym_th = fn: thm -> thm
val is_obj_all = fn: term -> bool
val list_obj_imp = fn: term list * term -> term
val to_obj_eq_iff_th = fn: thm -> thm
val equiv_backward_th = fn: thm -> thm
val is_mem = fn: term -> bool
val Not = Const ("HOL.Not", "bool => bool"): term
val to_meta_eq = fn: thm -> thm
val get_neg = fn: term -> term
val conj = Const ("HOL.conj", "bool => bool => bool"): term
val to_obj_eq_th = fn: thm -> thm
val mk_exists = fn: term -> term -> term
val conj_right_th = fn: thm -> thm
val is_imp = fn: term -> bool
val obj_sym = fn: thm -> thm
val list_disj = fn: term list -> term
val mk_disj = fn: term * term -> term
val is_conj = fn: term -> bool
val is_Trueprop = fn: term -> bool
val get_neg' = fn: term -> term
signature BOXID =
  sig
    val add_incr_id: box_id -> box_id
    val add_prim_id: box_id -> Proof.context -> int * Proof.context
    val add_resolved: box_id -> Proof.context -> Proof.context
    type box_id
    type box_lattice
    val get_all_merges: Proof.context -> box_id list list -> box_id list
    val get_all_merges_info:
       Proof.context -> (box_id * 'a) list list -> (box_id * 'a list) list
    val get_ancestors_prim: Proof.context -> box_id -> int list
    val get_parent_at_i: Proof.context -> box_id -> int -> box_id
    val get_parent_prim: Proof.context -> int -> box_id
    val has_incr_id: box_id -> bool
    val home_id: int
    val id_is_eq_ancestor:
       Proof.context -> box_id * 'a -> box_id * 'a -> bool
    val info_eq_better:
       Proof.context -> box_id * thm -> box_id * thm -> bool
    val is_box_resolved: Proof.context -> box_id -> bool
    val is_box_unresolved: Proof.context -> box_id -> bool
    val is_eq_ancestor: Proof.context -> box_id -> box_id -> bool
    val is_eq_descendent: Proof.context -> box_id -> box_id -> bool
    val merge_box_with_info:
       Proof.context -> box_id -> (box_id * 'a) list -> (box_id * 'a) list
    val merge_boxes: Proof.context -> box_id * box_id -> box_id
    val merge_eq_infos:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val reduce_box_id: Proof.context -> int list -> box_id
    val replace_incr_id: box_id -> box_id
    val string_of_box_id: box_id -> string
  end
type box_id = ?.BoxID.box_id
type id_inst = box_id * (Type.tyenv * Envir.tenv)
type id_inst_th = id_inst * thm
type id_inst_ths = id_inst * thm list
structure BoxID: BOXID
structure Boxidtab: TABLE
signature CONSTS =
  sig
    val add_const_data: string * (term -> bool) -> theory -> theory
    val detect_const: theory -> term -> string option
    val detect_const_ctxt: Proof.context -> term -> string option
    val is_const: theory -> term -> bool
    val is_const_ctxt: Proof.context -> term -> bool
    val neq_const: theory -> term * term -> bool
    val neq_const_ctxt: Proof.context -> term * term -> bool
  end
structure Consts: CONSTS
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
signature PROPERTY =
  sig
    val add_property_field_const: term -> theory -> theory
    val add_property_update: thm -> theory -> theory
    val can_add_property_update: thm -> theory -> bool
    val get_property_arg: term -> term
    val get_property_arg_th: thm -> cterm
    val get_property_name: term -> string
    val get_property_names: term list -> string list
    val instantiate_property_update:
       Proof.context -> term -> thm -> thm option
    val is_property: term -> bool
    val is_property_field: theory -> term -> bool
    val is_property_prem: theory -> term -> bool
    val lookup_property_update: theory -> string -> thm list
    val lookup_property_update_fun: theory -> string -> thm list
    val strip_property_field: theory -> term -> term list
  end
structure Property: PROPERTY
val add_property_field_const = fn: term -> theory -> theory
signature WELLFORM =
  sig
    val is_subterm_wellform_data:
       theory -> term -> term list -> (term * term) option
    val is_subterm_wellform_data':
       theory -> term -> term -> (term * term) option
    val lookup_wellform_data: theory -> term -> term list
    val lookup_wellform_pattern:
       theory -> term * term -> (term * term) option
    val register_wellform_data: string * string list -> theory -> theory
  end
structure WellForm: WELLFORM
val register_wellform_data = fn: string * string list -> theory -> theory
infix 1 then_wfconv
infix 0 else_wfconv
datatype wfterm = WfComb of cterm * wfterm list * thm list | WfTerm of cterm
type wfconv = wfterm -> wfterm * thm
signature WFTERM =
  sig
    val all_conv: wfconv
    val arg1_conv: wfconv -> wfconv
    val arg_conv: wfconv -> wfconv
    val argn_conv: int -> wfconv -> wfconv
    val binop_conv: wfconv -> wfconv
    val conv_of: conv -> wfconv
    val cterm_of: wfterm -> cterm
    val cterm_to_wfterm_assume: term list -> cterm -> wfterm
    val cterm_to_wfterm_on_ths: thm list -> term list -> cterm -> wfterm
    val else_wfconv: wfconv * wfconv -> wfconv
    val every_conv: wfconv list -> wfconv
    val find_target_on_ths: thm list -> term -> thm
    val first_conv: wfconv list -> wfconv
    val no_conv: wfconv
    val repeat_conv: wfconv -> wfconv
    val rewr_obj_eq: term list -> thm -> wfconv
    val rewrite_on_eqs: term list -> (wfterm * thm) list -> wfconv
    val string_of_wfterm: Proof.context -> wfterm -> string
    val strip_comb: wfterm -> cterm * wfterm list
    val term_of: wfterm -> term
    val test_wfconv:
       Proof.context ->
         term list -> wfconv -> string -> string * string -> unit
    val then_wfconv: wfconv * wfconv -> wfconv
    val theory_of_wft: wfterm -> theory
    val try_conv: wfconv -> wfconv
    val wellform_ths_of: wfterm -> thm list
  end
constructor WfComb: cterm * wfterm list * thm list -> wfterm
constructor WfTerm: cterm -> wfterm
structure WfTerm: WFTERM
val then_wfconv = fn: wfconv * wfconv -> wfconv
val else_wfconv = fn: wfconv * wfconv -> wfconv
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
consts
  snth :: "'a stream => nat => 'a"
type rewrite_table =
   {all_equiv: (box_id * thm) list Termtab.table,
    contain: cterm list Termtab.table,
    equiv: (box_id * thm) list Termtab.table,
    reps: (box_id * thm) list Termtab.table,
    simp: (box_id * thm) list Termtab.table,
    subsimp: (box_id * thm) list Termtab.table,
    terms: (box_id list * cterm) Termtab.table}
signature REWRITE_TABLE =
  sig
    val add_contain: cterm -> term -> Proof.context -> Proof.context
    val add_equiv: box_id * thm -> Proof.context -> Proof.context
    val add_rewrite:
       box_id * thm -> Proof.context -> (box_id * thm) list * Proof.context
    val add_rewrite_raw: box_id -> thm -> Proof.context -> Proof.context
    val add_term:
       box_id * cterm ->
         Proof.context -> (box_id * thm) list * Proof.context
    val add_term_list:
       (box_id * cterm) list ->
         Proof.context -> (box_id * thm) list * Proof.context
    val add_term_raw: box_id * cterm -> Proof.context -> Proof.context
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val complete_table: Proof.context -> (box_id * thm) list * Proof.context
    val equiv_info:
       Proof.context -> box_id -> cterm * cterm -> (box_id * thm) list
    val equiv_info_t:
       Proof.context -> box_id -> term * term -> (box_id * thm) list
    val equiv_neighs: Proof.context -> term -> (box_id * thm) list
    val get_all_equiv: Proof.context -> term -> (box_id * thm) list
    val get_all_id_terms: Proof.context -> (box_id * cterm) list
    val get_all_terms: Proof.context -> cterm list
    val get_cached_subterm_rewrite: box_id -> Proof.context -> cterm -> thm
    val get_cached_subterm_rewrite_info:
       Proof.context -> term -> (box_id * thm) list
    val get_head_equiv: Proof.context -> cterm -> (box_id * thm) list
    val get_head_equiv_with_t:
       Proof.context -> box_id * cterm -> term -> (box_id * thm) list
    val get_head_rep: box_id -> Proof.context -> term -> thm option
    val get_head_rep_info: Proof.context -> term -> (box_id * thm) list
    val get_head_rep_with_id_th:
       Proof.context -> box_id * thm -> (box_id * thm) list
    val get_new_terms:
       Proof.context * Proof.context -> (box_id * cterm) list
    val get_reachable_terms: bool -> Proof.context -> term list -> term list
    val get_rewrite: box_id -> Proof.context -> cterm -> thm
    val get_rewrite_info: Proof.context -> cterm -> (box_id * thm) list
    val get_subterm_rewrite_info:
       Proof.context -> cterm -> (box_id * thm) list
    val head_simplify: box_id -> Proof.context -> cterm -> thm
    val immediate_contains: Proof.context -> term -> cterm list
    val in_table_raw: Proof.context -> term -> bool
    val in_table_raw_for_id: Proof.context -> box_id * term -> bool
    val in_table_raw_ids: Proof.context -> term -> box_id list
    val is_equiv: box_id -> Proof.context -> cterm * cterm -> bool
    val is_equiv_t: box_id -> Proof.context -> term * term -> bool
    val process_update_simp:
       (box_id * thm) list -> Proof.context -> Proof.context
    val remove_rep: box_id * thm -> Proof.context -> Proof.context
    val simp_val: box_id -> Proof.context -> cterm -> cterm
    val simp_val_t: box_id -> Proof.context -> term -> term
    val simplify: box_id -> Proof.context -> cterm -> thm
    val simplify_info: Proof.context -> cterm -> (box_id * thm) list
    val subequiv_info:
       Proof.context -> box_id -> cterm * cterm -> (box_id * thm) list
    val subterm_simplify: box_id -> Proof.context -> cterm -> thm
    val subterm_simplify_info: Proof.context -> cterm -> (box_id * thm) list
    val update_simp: box_id * thm -> Proof.context -> Proof.context
    val update_subsimp: box_id * thm -> Proof.context -> Proof.context
  end
val simp_ord = fn: thm * thm -> order
val eq_info = fn: (''a * thm) * (''a * thm) -> bool
val print_info = fn: Proof.context -> BoxID.box_id * thm -> string
val print_infos = fn: Proof.context -> (BoxID.box_id * thm) list -> string
val print_info' = fn: Proof.context -> BoxID.box_id * thm list -> string
val print_infos' = fn:
   Proof.context -> (BoxID.box_id * thm list) list -> string
structure RewriteTable: REWRITE_TABLE
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
signature PROPERTY_DATA =
  sig
    val add_property: box_id * thm -> Proof.context -> Proof.context
    val add_property_raw: box_id * thm -> Proof.context -> Proof.context
    val apply_property_update_on_term:
       Proof.context -> box_id -> term -> (box_id * thm) list
    val apply_property_update_rule:
       Proof.context -> box_id -> thm option -> (box_id * thm) list
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val convert_property:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val get_new_property: Proof.context -> (box_id * thm) list
    val get_property: Proof.context -> box_id * cterm -> (box_id * thm) list
    val get_property_for_term: Proof.context -> term -> (box_id * thm) list
    val get_property_t:
       Proof.context -> box_id * term -> (box_id * thm) list
    val process_rewrite_property:
       box_id * thm -> Proof.context -> Proof.context
    val process_update_property:
       (box_id * thm) list -> Proof.context -> Proof.context
  end
structure PropertyData: PROPERTY_DATA
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
signature MATCHER =
  sig
    val check_type: theory -> typ * typ -> id_inst -> id_inst option
    val check_type_term:
       theory -> term * term -> id_inst -> (id_inst * term) option
    val match:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_all_head:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_comb:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_head:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_list:
       Proof.context ->
         term list -> term list * cterm list -> id_inst -> id_inst_ths list
    val pre_match: Proof.context -> term * cterm -> bool
    val pre_match_all_head: Proof.context -> term * cterm -> bool
    val pre_match_comb: Proof.context -> term * cterm -> bool
    val pre_match_head: Proof.context -> term * cterm -> bool
    val pre_match_head': Proof.context -> term * cterm -> bool
    val pre_match_type: Proof.context -> typ * typ -> bool
    val rewrite_match:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val rewrite_match_head:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val rewrite_match_list:
       Proof.context ->
         (bool * (term * cterm)) list -> id_inst -> id_inst_ths list
    val rewrite_match_subset:
       Proof.context ->
         term list -> term list * cterm list -> id_inst -> id_inst_ths list
    val update_inst:
       term list -> indexname -> cterm -> id_inst -> id_inst_th list
  end
structure Matcher: MATCHER
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
Found termination order: "size <*mlex*> {}"
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
### theory "HOL-Library.Stream"
### 1.126s elapsed time, 4.286s cpu time, 0.801s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.ExtrEqs")
datatype raw_item
= Fact of string * term list * thm | Handler of term list * term * thm
type box_item =
   {id: box_id,
    prop: thm, sc: int, tname: cterm list, ty_str: string, uid: int}
signature BOXITEM =
  sig
    val dest_handler_raw: raw_item -> term list * term * thm
    val eq_item: box_item * box_item -> bool
    val eq_ritem: raw_item * raw_item -> bool
    val get_thm_raw: raw_item -> thm
    val get_tname_raw: raw_item -> term list
    val instantiate: (cterm * cterm) list -> raw_item -> raw_item
    val is_fact_raw: raw_item -> bool
    val is_handler_raw: raw_item -> bool
    val item_replace_incr: box_item -> box_item
    val item_with_id: box_id -> box_item -> box_item
    val item_with_incr: box_item -> box_item
    val match_ty_str: string -> box_item -> bool
    val match_ty_str_raw: string -> raw_item -> bool
    val match_ty_strs: string list -> box_item -> bool
    val match_ty_strs_raw: string list -> raw_item -> bool
    val merged_id: Proof.context -> box_item list -> box_id
    val mk_box_item:
       Proof.context -> int * box_id * int * raw_item -> box_item
    val null_item: box_item
    val obtain_variant_frees:
       Proof.context * raw_item list -> Proof.context * (cterm * cterm) list
    val term_to_fact: term -> raw_item
    val var_to_fact: term -> raw_item
  end
val TY_NULL = "NULL": string
val TY_EQ = "EQ": string
val TY_VAR = "VAR": string
val TY_PROP = "PROP": string
val TY_TERM = "TERM": string
val TY_PROPERTY = "PROPERTY": string
constructor Fact: string * term list * thm -> raw_item
constructor Handler: term list * term * thm -> raw_item
type item_matcher =
   {match: term -> box_item -> Proof.context -> id_inst -> id_inst_th list,
    pre_match: term -> box_item -> Proof.context -> bool}
type item_output = Proof.context -> term list * thm -> string
type item_io_info =
   {output_fn: (item_output * serial) option,
    prop_matchers: (item_matcher * serial) list,
    shadow_fn:
    ((Proof.context -> box_id -> term list * cterm list -> bool) * serial)
    option
    ,
    term_fn: ((term list -> term list) * serial) option,
    typed_matchers: (item_matcher * serial) list}
datatype match_arg
=
     PropMatch of term
   | PropertyMatch of term
   | TypedMatch of string * term
   | TypedUniv of string
   | WellFormMatch of term * term
type prfstep_filter = Proof.context -> id_inst -> bool
signature ITEM_IO =
  sig
    val add_basic_item_io: theory -> theory
    val add_item_type:
       string * (term list -> term list) option * item_output option *
       (Proof.context -> box_id -> term list * cterm list -> bool) option
         -> theory -> theory
    val add_prop_matcher: string * item_matcher -> theory -> theory
    val add_typed_matcher: string * item_matcher -> theory -> theory
    val assert_valid_arg: match_arg -> unit
    val check_ty_str: string -> match_arg -> bool
    val eq_tname_typed_matcher: item_matcher
    val get_io_info: theory -> string -> item_io_info
    val get_prop_matchers: theory -> string -> item_matcher list
    val get_typed_matchers: theory -> string -> item_matcher list
    val is_ordinary_match: match_arg -> bool
    val is_side_match: match_arg -> bool
    val match_arg:
       Proof.context -> match_arg -> box_item -> id_inst -> id_inst_th list
    val no_rewr_terms: term list -> term list
    val null_eq_matcher: item_matcher
    val null_property_matcher: item_matcher
    val output_prop_fn: item_output
    val pat_of_match_arg: match_arg -> term
    val pre_match_arg: Proof.context -> match_arg -> box_item -> bool
    val prop_matcher: item_matcher
    val rewr_terms_of_item: Proof.context -> string * term list -> term list
    val string_of_item: Proof.context -> box_item -> string
    val string_of_item_info:
       Proof.context -> string * term list * thm -> string
    val string_of_raw_item: Proof.context -> raw_item -> string
    val subst_arg: Type.tyenv * Envir.tenv -> match_arg -> match_arg
    val term_prop_matcher: item_matcher
    val term_property_matcher: item_matcher
    val term_typed_matcher: item_matcher
    val trace_item: Proof.context -> string -> box_item -> unit
    val trace_items: Proof.context -> string -> box_item list -> unit
    val trace_ritem: Proof.context -> string -> raw_item -> unit
    val trace_ritems: Proof.context -> string -> raw_item list -> unit
  end
structure BoxItem: BOXITEM
constructor PropMatch: term -> match_arg
constructor PropertyMatch: term -> match_arg
constructor TypedMatch: string * term -> match_arg
constructor TypedUniv: string -> match_arg
constructor WellFormMatch: term * term -> match_arg
structure ItemIO: ITEM_IO
Found termination order: "size <*mlex*> {}"
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
signature WELLFORM_DATA =
  sig
    val add_wellform_data_raw:
       term * (box_id * thm) -> Proof.context -> Proof.context
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val complete_wellform_data:
       box_item list -> Proof.context -> Proof.context
    val complete_wellform_data_for_terms:
       box_item list -> term list -> Proof.context -> Proof.context
    val convert_wellform:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val cterm_to_wfterm:
       Proof.context ->
         term list -> box_id * cterm -> (box_id * wfterm) list
    val find_fact:
       Proof.context ->
         box_item list -> box_id * cterm -> (box_id * thm) list
    val get_complete_wellform:
       Proof.context -> box_id * cterm -> (box_id * thm list) list
    val get_head_equiv:
       Proof.context ->
         term list -> box_id * cterm -> (box_id * (wfterm * thm)) list
    val get_new_wellform_data: Proof.context -> (term * (box_id * thm)) list
    val get_wellform: Proof.context -> box_id * cterm -> (box_id * thm) list
    val get_wellform_for_term:
       Proof.context -> term -> (cterm * (box_id * thm) list) list
    val get_wellform_infos_for_term:
       Proof.context -> term -> (box_id * thm) list
    val get_wellform_t:
       Proof.context -> box_id * term -> (box_id * thm) list
    val initialize_wellform_data: term -> Proof.context -> Proof.context
    val simplify:
       Proof.context ->
         term list ->
           cterm list -> box_id * wfterm -> (box_id * (wfterm * thm)) list
    val simplify_info:
       Proof.context -> term list -> cterm -> (box_id * (wfterm * thm)) list
    val term_to_wfterm:
       Proof.context -> term list -> box_id * term -> (box_id * wfterm) list
  end
structure WellformData: WELLFORM_DATA
signature AUTO2_DATA =
  sig
    val add_terms:
       box_item list ->
         (box_id * cterm) list -> Proof.context -> Proof.context
    val get_incr_type:
       box_item list -> box_item list -> Proof.context -> Proof.context
    val get_single_type: Proof.context -> Proof.context
    val relevant_terms_single: box_item -> term list
  end
structure Auto2Data: AUTO2_DATA
Found termination order: "size <*mlex*> {}"
datatype raw_update
=
     AddBoxes of {id: box_id, init_assum: term, sc: int option}
   | AddItems of {id: box_id, raw_items: raw_item list, sc: int option}
   | ResolveBox of {id: box_id, th: thm}
   | ShadowItem of {id: box_id, item: box_item}
type update =
   {prfstep_name: string,
    raw_updt: raw_update, sc: int, source: box_item list}
signature UPDATE =
  sig
    val apply_exists_ritems: Proof.context -> thm -> raw_item list * thm
    val replace_id_of_update: raw_update -> raw_update
    val source_info: update -> string
    val string_of_raw_update: Proof.context -> raw_update -> string
    val target_of_update: raw_update -> box_id
    val thm_to_ritem: thm -> raw_item
    val thm_update: box_id * thm -> raw_update
    val thm_update_sc: int -> box_id * thm -> raw_update
    val update_info: Proof.context -> box_id -> raw_item list -> string
  end
constructor AddBoxes:
   {id: box_id, init_assum: term, sc: int option} -> raw_update
constructor AddItems:
   {id: box_id, raw_items: raw_item list, sc: int option} -> raw_update
constructor ResolveBox: {id: box_id, th: thm} -> raw_update
constructor ShadowItem: {id: box_id, item: box_item} -> raw_update
type status =
   {assums: term list,
    ctxt: Proof.context,
    handlers: (box_id * (term list * term * thm)) list,
    items: (box_item * box_id list) Inttab.table,
    queue: Updates_Heap.T, resolve_th: thm option}
signature STATUS =
  sig
    val add_handler: box_id * (term list * term * thm) -> status -> status
    val add_item: box_item -> status -> status
    val add_prim_box: box_id -> term -> status -> int * status
    val add_resolved: box_id -> status -> status
    val add_shadowed: box_id * box_item -> status -> status
    val add_to_queue: update -> status -> status
    val clear_incr: status -> status
    val delmin_from_queue: status -> status
    val empty_status: Proof.context -> status
    val find_fact: status -> box_id -> term -> thm option
    val find_prim_box: status -> box_id -> term -> int option
    val find_ritem_exact: status -> box_id -> raw_item -> bool
    val get_all_items_at_id: status -> box_id -> box_item list
    val get_handlers: status -> (box_id * (term list * term * thm)) list
    val get_init_assum: status -> int -> term
    val get_init_assums: status -> box_id -> term list
    val get_items: status -> box_item list
    val get_num_items: status -> int
    val get_on_resolve: status -> box_id -> int -> thm -> thm
    val get_resolve_th: status -> thm
    val invoke_handler:
       Proof.context -> term list * term * thm -> thm -> thm
    val lookup_item: status -> int -> (box_item * box_id list) option
    val map_context: (Proof.context -> Proof.context) -> status -> status
    val map_queue: (Updates_Heap.T -> Updates_Heap.T) -> status -> status
    val query_removed: status -> box_item -> bool
    val query_shadowed: status -> box_id -> box_item -> bool
    val set_resolve_th: thm -> status -> status
  end
structure Update: UPDATE
structure Updates_Heap: HEAP
structure Status: STATUS
Found termination order: "size <*mlex*> {}"
signature NORMALIZER =
  sig
    val add_inj_struct_data: thm -> theory -> theory
    val add_normalizer: string * normalizer -> theory -> theory
    val add_rewr_normalizer: string * thm -> theory -> theory
    val add_th_normalizer:
       string * (Proof.context -> thm -> thm list) -> theory -> theory
    val def_subst: (term * term) list -> term -> term
    val get_normalizers: theory -> (string * normalizer) list
    val is_def_eq: theory -> term -> bool
    val meta_use_vardef: thm -> (term * term) list * thm
    val meta_use_vardefs: thm -> (term * term) list * thm
    val normalize: Proof.context -> raw_item -> raw_item list
    val normalize_keep: Proof.context -> raw_item -> raw_item list
    type normalizer = Proof.context -> raw_item -> raw_item list
    val swap_eq_to_front: conv
  end
structure Normalizer: NORMALIZER
Found termination order: "size <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
datatype proofstep_fn
=
     OneStep of Proof.context -> box_item -> raw_update list
   | TwoStep of Proof.context -> box_item -> box_item -> raw_update list
type proofstep = {args: match_arg list, func: proofstep_fn, name: string}
datatype prfstep_descriptor
=
     CreateCase of term
   | CreateConcl of term
   | Filter of prfstep_filter
   | GetFact of term * thm
   | ShadowFirst
   | ShadowSecond
   | WithFact of term
   | WithItem of string * term
   | WithProperty of term
   | WithScore of int
   | WithWellForm of term * term
signature PROOFSTEP =
  sig
    val WithGoal: term -> prfstep_descriptor
    val WithProp: term -> prfstep_descriptor
    val WithTerm: term -> prfstep_descriptor
    val all_insts: prfstep_filter
    val apply_pat_r: Proof.context -> id_inst_ths -> term * thm -> thm
    val apply_prfstep:
       Proof.context -> box_item list -> proofstep -> raw_update list
    val eq_prfstep: proofstep * proofstep -> bool
    val gen_prfstep: string -> prfstep_descriptor list -> proofstep
    val get_side_ths:
       Proof.context ->
         id_inst -> match_arg list -> (box_id * thm list) list
    val neq_filter: term -> prfstep_filter
    val not_type_filter: string -> typ -> prfstep_filter
    val order_filter: string -> string -> prfstep_filter
    val prfstep_conv: string -> prfstep_descriptor list -> conv -> proofstep
    val prfstep_custom:
       string ->
         prfstep_descriptor list ->
           (id_inst_ths ->
              box_item list -> Proof.context -> raw_update list)
             -> proofstep
    val prfstep_pre_conv:
       string ->
         prfstep_descriptor list -> (Proof.context -> conv) -> proofstep
    val retrieve_args: prfstep_descriptor list -> match_arg list
    val retrieve_cases: prfstep_descriptor list -> term list
    val retrieve_filts: prfstep_descriptor list -> prfstep_filter
    val retrieve_pats_r: prfstep_descriptor list -> (term * thm) list
    val retrieve_shadows: prfstep_descriptor list -> int list
    val size1_filter: string -> prfstep_filter
    val string_of_desc: theory -> prfstep_descriptor -> string
    val string_of_descs: theory -> prfstep_descriptor list -> string
  end
constructor OneStep:
   (Proof.context -> box_item -> raw_update list) -> proofstep_fn
constructor TwoStep:
   (Proof.context -> box_item -> box_item -> raw_update list) ->
     proofstep_fn
constructor CreateCase: term -> prfstep_descriptor
constructor CreateConcl: term -> prfstep_descriptor
constructor Filter: prfstep_filter -> prfstep_descriptor
constructor GetFact: term * thm -> prfstep_descriptor
constructor ShadowFirst: prfstep_descriptor
constructor ShadowSecond: prfstep_descriptor
constructor WithFact: term -> prfstep_descriptor
constructor WithItem: string * term -> prfstep_descriptor
constructor WithProperty: term -> prfstep_descriptor
constructor WithScore: int -> prfstep_descriptor
constructor WithWellForm: term * term -> prfstep_descriptor
signature PROOFSTEP_DATA =
  sig
    val add_backward1_prfstep: thm -> theory -> theory
    val add_backward1_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_backward2_prfstep: thm -> theory -> theory
    val add_backward2_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_backward_prfstep: thm -> theory -> theory
    val add_backward_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward'_prfstep: thm -> theory -> theory
    val add_forward'_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward_prfstep: thm -> theory -> theory
    val add_forward_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_gen_prfstep:
       string * prfstep_descriptor list -> theory -> theory
    val add_prfstep: proofstep -> theory -> theory
    val add_prfstep_check_req: string * string -> theory -> theory
    val add_prfstep_conv:
       string * prfstep_descriptor list * conv -> theory -> theory
    val add_prfstep_custom:
       string * prfstep_descriptor list *
       (id_inst_ths -> box_item list -> Proof.context -> raw_update list)
         -> theory -> theory
    val add_prfstep_pre_conv:
       string * prfstep_descriptor list * (Proof.context -> conv) ->
         theory -> theory
    val add_resolve_prfstep: thm -> theory -> theory
    val add_resolve_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule: thm -> theory -> theory
    val add_rewrite_rule_back: thm -> theory -> theory
    val add_rewrite_rule_back_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule_bidir: thm -> theory -> theory
    val add_rewrite_rule_bidir_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val del_prfstep: string -> theory -> theory
    val del_prfstep_pred: (string -> bool) -> theory -> theory
    val del_prfstep_thm: thm -> theory -> theory
    val del_prfstep_thm_eqforward: thm -> theory -> theory
    val del_prfstep_thm_str: string -> thm -> theory -> theory
    val get_prfsteps: theory -> proofstep list
    type pre_prfstep_descriptor = Proof.context -> prfstep_descriptor
    datatype prfstep_mode
    =
         MODE_BACKWARD
       | MODE_BACKWARD1
       | MODE_BACKWARD2
       | MODE_FORWARD
       | MODE_FORWARD'
       | MODE_RESOLVE
    val setup_attrib: (thm -> theory -> theory) -> attribute context_parser
    val with_cond: string -> pre_prfstep_descriptor
    val with_conds: string list -> pre_prfstep_descriptor list
    val with_filt: prfstep_filter -> pre_prfstep_descriptor
    val with_filts: prfstep_filter list -> pre_prfstep_descriptor list
    val with_score: int -> pre_prfstep_descriptor
    val with_term: string -> pre_prfstep_descriptor
  end
structure ProofStep: PROOFSTEP
val WithTerm = fn: term -> prfstep_descriptor
val WithGoal = fn: term -> prfstep_descriptor
val WithProp = fn: term -> prfstep_descriptor
val neq_filter = fn: term -> prfstep_filter
val order_filter = fn: string -> string -> prfstep_filter
val size1_filter = fn: string -> prfstep_filter
val not_type_filter = fn: string -> typ -> prfstep_filter
datatype prfstep_mode
=
     MODE_BACKWARD
   | MODE_BACKWARD1
   | MODE_BACKWARD2
   | MODE_FORWARD
   | MODE_FORWARD'
   | MODE_RESOLVE
type pre_prfstep_descriptor = Proof.context -> prfstep_descriptor
structure ProofStepData: PROOFSTEP_DATA
constructor MODE_FORWARD': prfstep_mode
constructor MODE_BACKWARD1: prfstep_mode
val del_prfstep_thm_eqforward = fn: thm -> theory -> theory
val get_prfsteps = fn: theory -> proofstep list
val del_prfstep_thm = fn: thm -> theory -> theory
val add_forward'_prfstep = fn: thm -> theory -> theory
val with_conds = fn: string list -> pre_prfstep_descriptor list
val add_prfstep_custom = fn:
   string * prfstep_descriptor list *
   (id_inst_ths -> box_item list -> Proof.context -> raw_update list)
     -> theory -> theory
val add_rewrite_rule_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward'_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val del_prfstep_thm_str = fn: string -> thm -> theory -> theory
val add_rewrite_rule = fn: thm -> theory -> theory
val with_cond = fn: string -> pre_prfstep_descriptor
val add_gen_prfstep = fn:
   string * prfstep_descriptor list -> theory -> theory
val add_backward_prfstep = fn: thm -> theory -> theory
val add_resolve_prfstep = fn: thm -> theory -> theory
constructor MODE_RESOLVE: prfstep_mode
val with_filts = fn: prfstep_filter list -> pre_prfstep_descriptor list
val add_prfstep_check_req = fn: string * string -> theory -> theory
val add_backward_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val with_score = fn: int -> pre_prfstep_descriptor
val add_rewrite_rule_back = fn: thm -> theory -> theory
val add_backward1_prfstep = fn: thm -> theory -> theory
val add_rewrite_rule_bidir_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val with_filt = fn: prfstep_filter -> pre_prfstep_descriptor
constructor MODE_BACKWARD2: prfstep_mode
val add_resolve_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep_pre_conv = fn:
   string * prfstep_descriptor list * (Proof.context -> conv) ->
     theory -> theory
val add_forward_prfstep = fn: thm -> theory -> theory
val add_backward2_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep = fn: proofstep -> theory -> theory
val setup_attrib = fn: (thm -> theory -> theory) -> attribute context_parser
val del_prfstep = fn: string -> theory -> theory
constructor MODE_FORWARD: prfstep_mode
constructor MODE_BACKWARD: prfstep_mode
val add_rewrite_rule_bidir = fn: thm -> theory -> theory
val del_prfstep_pred = fn: (string -> bool) -> theory -> theory
val add_rewrite_rule_back_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep_conv = fn:
   string * prfstep_descriptor list * conv -> theory -> theory
val add_backward1_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_backward2_prfstep = fn: thm -> theory -> theory
val with_term = fn: string -> pre_prfstep_descriptor
type auto2_frame =
   {after_qed: (term list * (thm list -> thm -> thm)) option,
    goals: (term * thm) list,
    induct_stmt: term option, prem_only: term list, selected: int option}
type auto2_state = auto2_frame list
signature AUTO2_STATE =
  sig
    val add_prem_only: term -> Proof.context -> Proof.context
    val get_last_induct_stmt: Proof.context -> term option
    val get_num_frame: Proof.context -> int
    val get_selected: Proof.context -> thm
    val get_subgoal: Proof.context -> term
    val get_top_frame: Proof.context -> auto2_frame
    val lookup_prem_only: Proof.context -> term -> bool
    val map_head_th: (thm -> thm) -> Proof.context -> Proof.context
    val multiple_frame:
       (term * cterm) list * (term list * (thm list -> thm -> thm)) option
         -> auto2_frame
    val pop_head: Proof.context -> Proof.context
    val print_state: Proof.context -> unit
    val push_head: auto2_frame -> Proof.context -> Proof.context
    val set_induct_stmt: term -> Proof.context -> Proof.context
    val set_selected: int option -> Proof.context -> Proof.context
    val simple_frame:
       cterm * (term list * (thm list -> thm -> thm)) option -> auto2_frame
  end
structure Auto2_State: AUTO2_STATE
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
Found termination order: "size <*mlex*> {}"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  mset :: "'a list => 'a multiset"
signature LOGIC_PROOFSTEPS =
  sig
    val TY_DISJ: string
    val add_disj_normalizers: theory -> theory
    val add_disj_proofsteps: theory -> theory
    val add_logic_proofsteps: theory -> theory
    val analyze_disj_th: Proof.context -> thm -> term * thm
    val dest_tname_of_disj: cterm list -> term * cterm list
    val disj_create_case_prfstep: proofstep
    val disj_match_iff_prfstep: proofstep
    val disj_normalizer: Normalizer.normalizer
    val disj_prop_match:
       Proof.context ->
         id_inst ->
           term * (term list * term list) *
           ((indexname * typ) list * cterm list)
             -> id_inst_th list
    val disj_prop_matcher: item_matcher
    val disj_rewr_terms: term list -> term list
    val disj_shadow_prfstep: proofstep
    val disj_to_ritems: bool -> term -> thm -> raw_item list
    val disj_to_update:
       bool -> term -> box_id * int option * thm -> raw_update
    val eq_normalizer: Normalizer.normalizer
    val exists_elim_prfstep: proofstep
    val is_match_prem_only: box_item -> bool
    val logic_thm_update: Proof.context -> box_id * thm -> raw_update
    val match_one_sch_prfstep: proofstep
    val match_update_prfstep: proofstep
    val mk_all_disj: term list * term list -> term
    val norm_all_disj: Proof.context -> conv
    val norm_conj: conv
    val output_disj_fn: item_output
    val property_normalizer: Normalizer.normalizer
    val reduce_disj_True: conv
    val replace_disj_vars:
       Proof.context -> term list * term list -> term list * term list
    val shadow_prop_item: proofstep
    val shadow_term_item: proofstep
    val split_conj_gen_th: Proof.context -> thm -> thm list
    val split_not_imp_th: thm -> thm list
    val strip_all_disj: term -> term list * term list
  end
structure Logic_ProofSteps: LOGIC_PROOFSTEPS
val TY_DISJ = "DISJ": string
### theory "HOL-Library.BigO"
### 1.144s elapsed time, 4.320s cpu time, 1.098s GC time
signature SCORES =
  sig
    val get_score: raw_update -> int
    val item_score: raw_item -> int
    val items_score: raw_item list -> int
  end
signature PROOFSTATUS =
  sig
    val apply_update: update -> status -> status
    val apply_update_instant: update -> status -> status
    val check_hyps: box_id -> thm -> status -> unit
    val init_status: Proof.context -> term -> status
    val process_add_boxes: update -> status -> status
    val process_add_items: update -> status -> status
    val process_fact_all: box_id -> int -> box_item list -> status -> status
    val process_resolve: update -> status -> status
    val process_shadow: update -> status -> status
    val scoring:
       proofstep ->
         int ->
           box_item list ->
             status -> (box_item -> raw_update list) -> update list
    val solve_root: int * status -> int * status
  end
structure Scores: SCORES
val print_trace =
   Config
    {get_value = fn, map_value = fn, name = "print_trace", pos =
     {line=41, offset=1042, end_offset=1053, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_intended =
   Config
    {get_value = fn, map_value = fn, name = "print_intended", pos =
     {line=43, offset=1127, end_offset=1141, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_term =
   Config
    {get_value = fn, map_value = fn, name = "print_term", pos =
     {line=45, offset=1211, end_offset=1221, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_shadow =
   Config
    {get_value = fn, map_value = fn, name = "print_shadow", pos =
     {line=47, offset=1293, end_offset=1305, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_score =
   Config
    {get_value = fn, map_value = fn, name = "print_score", pos =
     {line=49, offset=1376, end_offset=1387, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val max_steps =
   Config
    {get_value = fn, map_value = fn, name = "max_steps", pos =
     {line=53, offset=1507, end_offset=1516, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   int Config.T
signature AUTO2 = sig val auto2_tac: Proof.context -> tactic end
structure ProofStatus: PROOFSTATUS
structure Auto2: AUTO2
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size <*mlex*> {}"
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
signature AUTO2_OUTER =
  sig
    val auto2_solve: Proof.context -> cterm -> thm
    val case_after_qed: Proof.context -> thm list -> thm -> thm
    val case_cmd: string * bool -> Proof.state -> Proof.state
    val case_resolve: Proof.context -> term list -> thm -> thm
    val contra_after_qed: Proof.context -> thm -> thm
    val contra_cmd: Proof.state -> Proof.state
    val contra_resolve:
       Proof.context -> term list -> term list -> term -> thm
    val end_cmd: Proof.state -> Proof.state
    val endgoal_cmd: Proof.state -> Proof.state
    val have_after_qed: Proof.context -> thm -> thm -> thm
    val have_cmd: bool * string * bool -> Proof.state -> Proof.state
    val have_resolve: Proof.context -> term list -> thm -> term -> thm
    val init_state: Proof.state -> Proof.state
    val let_after_qed: Proof.context -> term list -> thm -> thm
    val let_cmd: string list -> Proof.state -> Proof.state
    val let_resolve:
       Proof.context -> term list -> term -> term list -> term -> thm
    val obtain_after_qed: Proof.context -> thm list -> thm -> thm
    val obtain_cmd:
       string list * string list * bool -> Proof.state -> Proof.state
    val obtain_resolve: Proof.context -> term list -> thm -> term -> thm
    val qed_cmd: Proof.state -> Proof.context
    val refine_subgoal_th: thm -> thm -> thm
    val subgoal_cmd: string -> Proof.state -> Proof.state
  end
structure Auto2_Outer: AUTO2_OUTER
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
type ac_info =
   {assoc_th: thm,
    cfhead: cterm,
    comm_th: thm, unit: cterm option, unitl_th: thm, unitr_th: thm}
signature ACUTIL =
  sig
    val ac_last_conv: ac_info -> conv -> conv
    val add_ac_data: ac_info -> theory -> theory
    val assoc_cv: ac_info -> conv
    val assoc_sym_cv: ac_info -> conv
    val cdest_ac: ac_info -> cterm -> cterm list
    val comb_ac_equiv: ac_info -> thm list -> thm
    val comm_cv: ac_info -> conv
    val dest_ac: ac_info -> term -> term list
    val eq_unit: ac_info -> term -> bool
    val get_head_ac_info: theory -> term -> ac_info option
    val has_assoc_th: ac_info -> bool
    val has_comm_th: ac_info -> bool
    val has_unit_th: ac_info -> bool
    val head_agrees: ac_info -> term -> bool
    val inst_ac_info: theory -> typ -> ac_info -> ac_info option
    val move_outmost: ac_info -> term -> conv
    val norm_combine: ac_info -> (term -> bool) -> conv -> conv
    val normalize_all_ac: ac_info -> conv
    val normalize_assoc: ac_info -> conv
    val normalize_au: ac_info -> conv
    val normalize_comm: ac_info -> conv
    val normalize_comm_gen: ac_info -> (term * term -> bool) -> conv
    val normalize_unit: ac_info -> conv
    val swap_cv: ac_info -> conv
    val swap_r_cv: ac_info -> conv
  end
structure ACUtil: ACUTIL
### theory "HOL-Library.Tree"
### 2.522s elapsed time, 9.330s cpu time, 1.988s GC time
Loading theory "Draft.Templates" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.ExtrEqs")
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
signature AC_PROOFSTEPS =
  sig
    val ac_expand:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val ac_expand_equiv: proofstep
    val ac_expand_once:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val ac_expand_unit: proofstep
    val add_ac_proofsteps: theory -> theory
    val get_ac_head_equiv:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val max_ac: int Config.T
    val simp_ac_expr:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
  end
structure AC_ProofSteps: AC_PROOFSTEPS
signature UNFOLDING =
  sig
    val get_unfold_thms: theory -> term -> thm list
    val get_unfold_thms_by_name: theory -> string -> thm list
    val unfold: theory -> conv
    val unfold_cmd: string -> Proof.state -> Proof.state
  end
structure Unfolding: UNFOLDING
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.064s elapsed time, 0.192s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Partial_Equiv_RelMoreTemplates")
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
signature INDUCT_PROOFSTEPS =
  sig
    val add_case_induct_rule: thm -> theory -> theory
    val add_cases_rule: thm -> theory -> theory
    val add_fun_induct_rule: term * thm -> theory -> theory
    val add_induct_data: string -> term * thm -> theory -> theory
    val add_prop_induct_rule: thm -> theory -> theory
    val add_strong_induct_rule: thm -> theory -> theory
    val add_typed_induct_data: string -> typ * thm -> theory -> theory
    val add_var_induct_rule: thm -> theory -> theory
    val apply_induct_hyp_cmd: string list -> Proof.state -> Proof.state
    val case_induct_cmd: string -> Proof.state -> Proof.state
    val check_strong_ind_prop: term -> term list * term
    val fun_induct_cmd:
       string * string list * string option -> Proof.state -> Proof.state
    val get_term_ind_th: theory -> string -> term -> thm
    val get_typed_ind_th: theory -> string -> typ -> thm
    val induct_cmd:
       string ->
         string * string option * string list * string option ->
           Proof.state -> Proof.state
    val is_simple_fun_induct: thm -> bool
    val prop_induct_cmd:
       string * string option -> Proof.state -> Proof.state
    val strong_induct_cmd:
       string * string list -> Proof.state -> Proof.state
  end
structure Induct_ProofSteps: INDUCT_PROOFSTEPS
val add_strong_induct_rule = fn: thm -> theory -> theory
val add_case_induct_rule = fn: thm -> theory -> theory
val add_prop_induct_rule = fn: thm -> theory -> theory
val add_var_induct_rule = fn: thm -> theory -> theory
val add_fun_induct_rule = fn: term * thm -> theory -> theory
val add_cases_rule = fn: thm -> theory -> theory
signature EXTRA_HOL =
  sig
    val add_forward_arg1_prfstep: thm -> theory -> theory
    val add_forward_arg1_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward_arg_prfstep: thm -> theory -> theory
    val add_forward_arg_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_arg_rule: thm -> theory -> theory
    val add_rewrite_arg_rule_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_simple_datatype: string -> theory -> theory
    val del_simple_datatype: string -> theory -> theory
  end
structure Extra_HOL: EXTRA_HOL
val add_forward_arg_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward_arg1_prfstep = fn: thm -> theory -> theory
val add_forward_arg_prfstep = fn: thm -> theory -> theory
val add_simple_datatype = fn: string -> theory -> theory
val del_simple_datatype = fn: string -> theory -> theory
val add_rewrite_arg_rule_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_rewrite_arg_rule = fn: thm -> theory -> theory
val add_forward_arg1_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
### theory "Auto2_HOL.Auto2_HOL"
### 3.070s elapsed time, 11.274s cpu time, 2.119s GC time
Loading theory "Auto2_HOL.Logic_Thms" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms" via "Auto2_HOL.Order_Thms")
HOL.refl@res
WithGoal ?t = ?t
GetResolve HOL.refl@res
HOL_Base.contra_triv
WithGoal ?A
WithFact ?A
GetResolve HOL_Base.contra_triv
HOL.TrueI@res
WithGoal True
GetResolve HOL.TrueI@res
Logic_Thms.FalseD@res
WithFact False
GetResolve Logic_Thms.FalseD@res
Logic_Thms.exists_triv_eq@res
WithGoal EX x. x = x
GetResolve Logic_Thms.exists_triv_eq@res
HOL.not_sym
WithGoal ?t = ?s
GetGoal (?s = ?t, HOL.not_sym) + 1 filters
Logic_Thms.iff_goal_1
WithGoal ?A = ?B
WithFact ?A
WithScore 1
GetGoal (?B, Logic_Thms.iff_goal_1)
Logic_Thms.iff_goal_2
WithGoal ?A = ?B
WithFact ?B
WithScore 1
GetGoal (?A, Logic_Thms.iff_goal_2)
Logic_Thms.iff_goal_3
WithGoal ?A = ?B
WithGoal ?A
WithScore 1
GetFact (?B, Logic_Thms.iff_goal_3)
Logic_Thms.iff_goal_4
WithGoal ?A = ?B
WithGoal ?B
WithScore 1
GetFact (?A, Logic_Thms.iff_goal_4)
Logic_Thms.iff_goal_5
WithGoal (~ ?A) = ?B
WithFact ?A
WithScore 1
GetFact (?B, Logic_Thms.iff_goal_5)
Logic_Thms.iff_goal_6
WithGoal ?A = (~ ?B)
WithFact ?B
WithScore 1
GetFact (?A, Logic_Thms.iff_goal_6)
Logic_Thms.exists_split@eqbackward@back
WithGoal EX x y. ?P x & ?Q y
GetGoal ((EX x. ?P x) & (EX y. ?Q y), Logic_Thms.exists_split@eqbackward@back)
HOL.if_P
WithTerm if ?P then ?x else ?y
WithFact ?P
WithScore 1
GetFact ((if ?P then ?x else ?y) = ?x, HOL.if_P)
HOL.if_not_P
WithTerm if ?P then ?x else ?y
WithGoal ?P
WithScore 1
GetFact ((if ?P then ?x else ?y) = ?y, HOL.if_not_P)
Logic_Thms.if_eval'
WithTerm if ~ ?P then ?x else ?y
WithFact ?P
WithScore 1
GetFact ((if ~ ?P then ?x else ?y) = ?y, Logic_Thms.if_eval')
Logic_Thms.ifb_eval_1@eqforward
WithFact if ?Pa then ?P else ?y
WithFact ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_1@eqforward)
Logic_Thms.ifb_eval_1@invbackward
WithGoal if ?P then ?B else ?y
WithFact ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_1@invbackward)
Logic_Thms.ifb_eval_2@eqforward
WithFact if ?Pa then ?x else ?P
WithGoal ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_2@eqforward)
Logic_Thms.ifb_eval_2@invbackward
WithGoal if ?P then ?x else ?B
WithGoal ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_2@invbackward)
Logic_Thms.ifb_eval_3@eqforward
WithFact if ~ ?Pa then ?x else ?P
WithFact ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_3@eqforward)
Logic_Thms.ifb_eval_3@invbackward
WithGoal if ~ ?P then ?x else ?B
WithFact ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_3@invbackward)
HOL.theI'
WithTerm THE x. ?P x
WithFact EX! x. ?P x
GetFact (?P (THE x. ?P x), HOL.theI')
Logic_Thms.ex_ex1I'@back1
WithGoal EX! x. ?P x
WithFact ?P ?x
GetGoal (ALL y. ?P y --> ?x = y, Logic_Thms.ex_ex1I'@back1)
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
Logic_Thms.the1_equality'
WithTerm THE x. ?P x
WithFact ?P ?a
GetFact ((EX! x. ?P x) --> (THE x. ?P x) = ?a, Logic_Thms.the1_equality')
Hilbert_Choice.someI
WithTerm SOME x. ?P x
WithFact ?P ?x
GetFact (?P (Eps ?P), Hilbert_Choice.someI)
Hilbert_Choice.someI_ex
WithTerm SOME x. ?P x
WithFact EX x. ?P x
GetFact (?P (SOME x. ?P x), Hilbert_Choice.someI_ex)
Logic_Thms.Least_equality'@back1
WithGoal Least ?P = ?x
WithFact ALL y. ?P y --> ?x <= y
GetGoal (?P ?x, Logic_Thms.Least_equality'@back1)
Product_Type.fst_conv
WithTerm fst (?x1.0, ?x2.0)
GetFact (fst (?x1.0, ?x2.0) = ?x1.0, Product_Type.fst_conv)
Product_Type.snd_conv
WithTerm snd (?x1.0, ?x2.0)
GetFact (snd (?x1.0, ?x2.0) = ?x2.0, Product_Type.snd_conv)
Product_Type.prod.simps_1@eqforward
WithFact (?x1.0, ?x2.0) = (?y1.0, ?y2.0)
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Product_Type.prod.simps_1@eqforward)
Product_Type.surjective_pairing
WithTerm ?t
GetFact (?t = (fst ?t, snd ?t), Product_Type.surjective_pairing) + 1 filters
Relation.symD
WithProperty sym ?r
WithFact (?b, ?a) : ?r
GetFact ((?a, ?b) : ?r, Relation.symD)
Relation.symI@back
WithGoal sym ?r
GetGoal (ALL a b. (a, b) : ?r --> (b, a) : ?r, Relation.symI@back)
Relation.transD
WithProperty trans ?r
WithFact (?x, ?y) : ?r
WithFact (?y, ?z) : ?r
GetFact ((?x, ?z) : ?r, Relation.transD)
Relation.transI@back
WithGoal trans ?r
GetGoal (ALL x y z. (x, y) : ?r --> (y, z) : ?r --> (x, z) : ?r, Relation.transI@back)
Option.option.distinct_1@res
WithFact None = Some ?x2.0
GetResolve Option.option.distinct_1@res
Option.option.sel
WithTerm the (Some ?x2.0)
GetFact (the (Some ?x2.0) = ?x2.0, Option.option.sel)
Option.option.collapse
WithGoal ?option = None
GetFact (Some (the ?option) = ?option, Option.option.collapse)
Option.option.simps_1@eqforward
WithFact Some ?x2.0 = Some ?y2.0
GetFact (?x2.0 = ?y2.0, Option.option.simps_1@eqforward)
Option.option.case_1
WithTerm case None of None => ?f1.0 | Some x => ?f2.0 x
WithScore 1
GetFact ((case None of None => ?f1.0 | Some x => ?f2.0 x) = ?f1.0, Option.option.case_1)
Option.option.case_2
WithTerm case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x
WithScore 1
GetFact ((case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x) = ?f2.0 ?x2.0, Option.option.case_2)
### theory "Auto2_HOL.Logic_Thms"
### 0.155s elapsed time, 0.471s cpu time, 0.042s GC time
Loading theory "Auto2_HOL.Order_Thms" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Arith_Thms")
signature UTIL_ARITH =
  sig
    val contra_by_arith: Proof.context -> thm list -> thm
    val dest_numc: term -> int
    val dest_numc_rat: term -> Rat.rat
    val intT: typ
    val is_divide: term -> bool
    val is_linorder: Proof.context -> term -> bool
    val is_minus: term -> bool
    val is_numc: term -> bool
    val is_one: term -> bool
    val is_order: term -> bool
    val is_plus: term -> bool
    val is_times: term -> bool
    val is_zero: term -> bool
    val natT: typ
    val neg_ineq_back_cv: conv
    val neg_ineq_cv: conv
    val prove_by_arith: Proof.context -> thm list -> term -> thm
    val ratT: typ
    val rat_zero: Rat.rat
  end
structure UtilArith: UTIL_ARITH
val natT = "nat": typ
val intT = "int": typ
Orderings.preorder_class.order.trans
WithFact ?a <= ?b
WithFact ?b <= ?c
GetFact (?a <= ?c, Orderings.preorder_class.order.trans) + 1 filters
Orderings.preorder_class.order.strict_trans
WithFact ?a < ?b
WithFact ?b < ?c
GetFact (?a < ?c, Orderings.preorder_class.order.strict_trans) + 1 filters
Orderings.order_le_less_trans
WithFact ?x <= ?y
WithFact ?y < ?z
GetFact (?x < ?z, Orderings.order_le_less_trans) + 1 filters
Orderings.order_less_le_trans
WithFact ?x < ?y
WithFact ?y <= ?z
GetFact (?x < ?z, Orderings.order_less_le_trans) + 1 filters
Orderings.preorder_class.order.irrefl@res
WithFact ?a < ?a
GetResolve Orderings.preorder_class.order.irrefl@res
Orderings.order_class.le_neq_trans
WithFact ?a <= ?b
WithGoal ?a = ?b
GetFact (?a < ?b, Orderings.order_class.le_neq_trans) + 1 filters
Orderings.order_class.order_antisym
WithFact ?x <= ?y
WithFact ?y <= ?x
GetFact (?x = ?y, Orderings.order_class.order_antisym) + 2 filters
Lattices.linorder_class.min.commute
WithTerm min ?a ?b
GetFact (min ?a ?b = min ?b ?a, Lattices.linorder_class.min.commute)
Lattices.linorder_class.min.idem
WithTerm min ?a ?a
GetFact (min ?a ?a = ?a, Lattices.linorder_class.min.idem)
Lattices.linorder_class.min.cobounded1
WithTerm min ?a ?b
GetFact (min ?a ?b <= ?a, Lattices.linorder_class.min.cobounded1)
Lattices.linorder_class.min.cobounded2
WithTerm min ?a ?b
GetFact (min ?a ?b <= ?b, Lattices.linorder_class.min.cobounded2)
Lattices.linorder_class.min.boundedI@back2
WithGoal ?a <= min ?b ?c
WithFact ?a <= ?b
GetGoal (?a <= ?c, Lattices.linorder_class.min.boundedI@back2)
Lattices.linorder_class.min.mono@back2
WithGoal min ?a ?b <= min ?c ?d
WithFact ?a <= ?c
GetGoal (?b <= ?d, Lattices.linorder_class.min.mono@back2)
Lattices.linorder_class.min.absorb1
WithTerm min ?a ?b
WithFact ?a <= ?b
GetFact (min ?a ?b = ?a, Lattices.linorder_class.min.absorb1)
Lattices.linorder_class.min.absorb2
WithTerm min ?a ?b
WithFact ?b <= ?a
GetFact (min ?a ?b = ?b, Lattices.linorder_class.min.absorb2)
Lattices.linorder_class.max.commute
WithTerm max ?a ?b
GetFact (max ?a ?b = max ?b ?a, Lattices.linorder_class.max.commute)
Lattices.linorder_class.max.idem
WithTerm max ?a ?a
GetFact (max ?a ?a = ?a, Lattices.linorder_class.max.idem)
Lattices.linorder_class.max.cobounded1
WithTerm max ?a ?b
GetFact (?a <= max ?a ?b, Lattices.linorder_class.max.cobounded1)
Lattices.linorder_class.max.cobounded2
WithTerm max ?a ?b
GetFact (?b <= max ?a ?b, Lattices.linorder_class.max.cobounded2)
Lattices.linorder_class.max.boundedI@back2
WithGoal max ?b ?c <= ?a
WithFact ?b <= ?a
GetGoal (?c <= ?a, Lattices.linorder_class.max.boundedI@back2)
Lattices.linorder_class.max.mono@back2
WithGoal max ?c ?d <= max ?a ?b
WithFact ?c <= ?a
GetGoal (?d <= ?b, Lattices.linorder_class.max.mono@back2)
Lattices.linorder_class.max.absorb1
WithTerm max ?a ?b
WithFact ?b <= ?a
GetFact (max ?a ?b = ?a, Lattices.linorder_class.max.absorb1)
Lattices.linorder_class.max.absorb2
WithTerm max ?a ?b
WithFact ?a <= ?b
GetFact (max ?a ?b = ?b, Lattices.linorder_class.max.absorb2)
Lattices_Big.linorder_class.Min_in@back
WithProperty finite ?A
WithGoal Min ?A : ?A
GetFact (?A = {}, Lattices_Big.linorder_class.Min_in@back)
Lattices_Big.linorder_class.Min_le@back
WithProperty finite ?A
WithGoal Min ?A <= ?x
GetGoal (?x : ?A, Lattices_Big.linorder_class.Min_le@back)
Lattices_Big.linorder_class.Min_eqI@back2
WithProperty finite ?A
WithGoal Min ?A = ?x
WithFact ALL y. y : ?A --> ?x <= y
GetGoal (?x : ?A, Lattices_Big.linorder_class.Min_eqI@back2)
Order_Thms.exists_ge@res
WithGoal EX k. ?i <= k
GetResolve Order_Thms.exists_ge@res
Orderings.no_bot_class.lt_ex@res
WithGoal EX y. y < ?x
GetResolve Orderings.no_bot_class.lt_ex@res
Orderings.no_top_class.gt_ex@res
WithGoal EX y. ?x < y
GetResolve Orderings.no_top_class.gt_ex@res
Orderings.dense_order_class.dense@back
WithGoal EX z>?x. z < ?y
GetGoal (?x < ?y, Orderings.dense_order_class.dense@back)
### theory "Auto2_HOL.Order_Thms"
### 0.313s elapsed time, 0.951s cpu time, 0.050s GC time
Loading theory "Auto2_HOL.Arith_Thms" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.659s elapsed time, 1.995s cpu time, 0.138s GC time
Add ac data for function Groups.plus_class.plus
Add ac data for function Groups.times_class.times
Add ac data for function GCD.gcd_class.gcd
signature NAT_UTIL =
  sig
    val add_arith_ac_data: theory -> theory
    val add_arith_proofsteps: theory -> theory
    val cnat0: cterm
    val lookup_numc: Type.tyenv * Envir.tenv -> int -> int
    val lookup_numc0: Type.tyenv * Envir.tenv -> int
    val lookup_numc1: Type.tyenv * Envir.tenv -> int
    val lookup_numc2: Type.tyenv * Envir.tenv -> int
    val mk_int: int -> term
    val mk_le: term * term -> term
    val mk_less: term * term -> term
    val mk_nat: int -> term
    val nat0: term
    val nat_fold_conv: conv
    val nat_fold_reduce: term -> term
    val nat_le_th: int -> int -> thm
    val nat_less_th: int -> int -> thm
    val nat_neq_th: int -> int -> thm
    val plus_ac_on_typ: theory -> typ -> ac_info
    val times_ac_on_typ: theory -> typ -> ac_info
  end
structure Nat_Util: NAT_UTIL
val mk_nat = fn: int -> term
val mk_int = fn: int -> term
val plus_ac_on_typ = fn: theory -> typ -> ac_info
val times_ac_on_typ = fn: theory -> typ -> ac_info
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
signature NAT_ORDER =
  sig
    val add_nat_order_proofsteps: theory -> theory
    val convert_const_x: thm -> thm
    val convert_const_y: thm -> thm
    val dest_ineq: term -> term * term * int
    val dest_ineq_th: thm -> term * term * int
    val fold_double_plus: conv
    val get_nat_order_info: box_item -> order_info
    val is_minus_const: term -> bool
    val is_order: term -> bool
    val is_plus_const: term -> bool
    val is_standard_ineq: term -> bool
    val nat_eq_diff_prfstep: proofstep
    val nat_order_match:
       term -> box_item -> Proof.context -> id_inst -> id_inst_th list
    val nat_order_matcher: item_matcher
    val nat_order_normalizer: Normalizer.normalizer
    val nat_order_noteq_matcher: item_matcher
    val nat_order_single_match:
       term -> box_item -> Proof.context -> id_inst -> id_inst_th list
    val nat_order_single_matcher: item_matcher
    val nat_order_typed_matcher: item_matcher
    val norm_ineq_minus_th: thm -> thm option
    val norm_ineq_minus_th': thm -> thm option
    val norm_ineq_th: thm -> thm
    val norm_ineq_th': thm -> thm
    type order_info
    datatype order_type
    =
         LE
       | LESS
       | LESS_LMINUS
       | LESS_LPLUS
       | LESS_RMINUS
       | LESS_RPLUS
       | LE_LMINUS
       | LE_LPLUS
       | LE_RMINUS
       | LE_RPLUS
    val output_nat_order: Proof.context -> term list * thm -> string
    val shadow_nat_order:
       Proof.context -> box_id -> term list * cterm list -> bool
    val shadow_nat_order_prfstep: proofstep
    val shadow_nat_order_single: proofstep
    val single_resolve: proofstep
    val single_resolve_zero: proofstep
    val string_of_nat_order:
       Proof.context -> term * term * int * thm -> string
    val th_to_normed_ritems: thm -> raw_item list
    val th_to_ritem: thm -> raw_item
    val to_normal_th: order_type -> thm -> thm
    val transitive: proofstep
    val transitive_resolve: proofstep
  end
val TY_NAT_ORDER = "NAT_ORDER": string
structure Nat_Order: NAT_ORDER
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
val test_fold_double_plus = [(), (), (), ()]: unit list
val convert_prop_to_nat_order = fn: term -> raw_item list
val test_parse_prop = (): unit
val test_nat_order_match = (): unit
val test_nat_order_single_match = (): unit
Groups.minus_class.minus_case
WithTerm ?a - ?b
CreateConcl ?b <= ?a
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
signature NAT_SUB =
  sig
    val add_nat_sub_proofsteps: theory -> theory
    val add_polynomial_list: monomial list * monomial list -> monomial list
    val cancel_terms: wfconv
    val fheads: term list
    val get_sub_head_equiv:
       Proof.context -> box_id * cterm -> (box_id * (wfterm * thm)) list
    type monomial = cterm list * int
    val move_outmost: term -> wfconv
    val nat_sub_expand:
       Proof.context -> box_id * cterm -> (box_id * (wfterm * thm)) list
    val nat_sub_expand_equiv: proofstep
    val nat_sub_expand_once:
       Proof.context -> box_id * wfterm -> (box_id * (wfterm * thm)) list
    val nat_sub_expand_unit: proofstep
    val norm_minus: wfconv
    val norm_minus': wfconv
    val norm_minus_ct: cterm -> monomial list
    val norm_plus: wfconv
    val norm_plus1: wfconv
    val norm_ring_term: cterm -> term
    val reduce_monomial_list: monomial list -> monomial list
  end
structure NatSub: NAT_SUB
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
### theory "HOL-Library.Multiset"
### 3.957s elapsed time, 12.800s cpu time, 2.237s GC time
Loading theory "Auto2_HOL.Set_Thms" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main" via "Auto2_HOL.Lists_Thms")
val test_term = fn:
   Proof.context -> (cterm -> term) -> string -> string * string -> unit
val test =
   [(), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (), (),
    (), (), ...]:
   unit list
Arith_Thms.le_neq_implies_less'
WithGoal ?m = ?n
WithFact ?m <= ?n
GetFact (?m < ?n, Arith_Thms.le_neq_implies_less')
Arith_Thms.le_zero_to_equal_zero
WithFact ?n <= 0
GetFact (?n = 0, Arith_Thms.le_zero_to_equal_zero)
Arith_Thms.less_one_to_equal_zero
WithFact ?n < 1
GetFact (?n = 0, Arith_Thms.less_one_to_equal_zero)
Nat.mult_le_mono1@back
WithGoal ?i * ?k <= ?j * ?k
GetGoal (?i <= ?j, Nat.mult_le_mono1@back) + 1 filters
Nat.not_add_less1@res
WithFact ?i + ?j < ?i
GetResolve Nat.not_add_less1@res
Arith_Thms.not_minus_less@res
WithFact ?i < ?i - ?j
GetResolve Arith_Thms.not_minus_less@res
Arith_Thms.nat_le_prod_with_same@back
WithGoal ?n <= ?m * ?n
GetFact (?m = 0, Arith_Thms.nat_le_prod_with_same@back)
Arith_Thms.nat_le_prod_with_le@back1
WithGoal ?n <= ?k * ?m
WithFact ?n <= ?m
GetFact (?k = 0, Arith_Thms.nat_le_prod_with_le@back1)
Arith_Thms.nat_plus_le_to_less@back1
WithGoal ?a < ?c
WithFact ?a + ?b <= ?c
GetFact (?b = 0, Arith_Thms.nat_plus_le_to_less@back1)
Arith_Thms.nat_plus_le_to_less2@back1
WithGoal ?b < ?c
WithFact ?a + ?b <= ?c
GetFact (?a = 0, Arith_Thms.nat_plus_le_to_less2@back1)
Groups.cancel_semigroup_add_class.add_right_imp_eq
WithFact ?b + ?a = ?c + ?a
GetFact (?b = ?c, Groups.cancel_semigroup_add_class.add_right_imp_eq)
Groups.cancel_semigroup_add_class.add_left_imp_eq
WithFact ?a + ?b = ?a + ?c
GetFact (?b = ?c, Groups.cancel_semigroup_add_class.add_left_imp_eq)
Nat.le_diff_conv2@eqforward
WithWellForm ?k <= ?j
WithTerm ?i + ?k
WithFact ?i <= ?j - ?k
GetFact (?i + ?k <= ?j, Nat.le_diff_conv2@eqforward)
Nat.le_diff_conv2@invbackward
WithWellForm ?k <= ?j
WithTerm ?i + ?k
WithGoal ?i <= ?j - ?k
GetGoal (?i + ?k <= ?j, Nat.le_diff_conv2@invbackward)
Arith_Thms.nat_less_diff_conv
WithTerm ?i + ?k
WithFact ?i < ?j - ?k
GetFact (?i + ?k < ?j, Arith_Thms.nat_less_diff_conv) + 1 filters
Arith_Thms.Nat_le_diff_conv2_same
WithWellForm ?j <= ?i
WithFact ?i <= ?i - ?j
GetFact (?j = 0, Arith_Thms.Nat_le_diff_conv2_same)
Arith_Thms.nat_gt_zero
WithFact 0 < ?b - ?a
GetFact (?a < ?b, Arith_Thms.nat_gt_zero)
Arith_Thms.n_minus_1_less_n
WithWellForm 1 <= ?n
WithTerm ?n - 1
GetFact (?n - 1 < ?n, Arith_Thms.n_minus_1_less_n)
Nat.diff_le_mono@back
WithGoal ?m - ?l <= ?n - ?l
GetGoal (?m <= ?n, Nat.diff_le_mono@back)
Nat.diff_less_mono@back2
WithGoal ?a - ?c < ?b - ?c
WithFact ?a < ?b
GetGoal (?c <= ?a, Nat.diff_less_mono@back2)
Nat.mult_le_mono2@back
WithGoal ?k * ?i <= ?k * ?j
GetGoal (?i <= ?j, Nat.mult_le_mono2@back)
Nat.le_add1@res
WithGoal ?n <= ?n + ?m
GetResolve Nat.le_add1@res
Nat.le_add2@res
WithGoal ?n <= ?m + ?n
GetResolve Nat.le_add2@res
Groups.ordered_ab_semigroup_add_class.add_left_mono@back
WithGoal ?c + ?a <= ?c + ?b
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_left_mono@back)
Groups.ordered_ab_semigroup_add_class.add_right_mono@back
WithGoal ?a + ?c <= ?b + ?c
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_right_mono@back)
Arith_Thms.add_mono_neutr@back
WithGoal ?a <= ?a + ?b
GetGoal ((0::?'a) <= ?b, Arith_Thms.add_mono_neutr@back)
Arith_Thms.add_mono_neutl@back
WithGoal ?a <= ?b + ?a
GetGoal ((0::?'a) <= ?b, Arith_Thms.add_mono_neutl@back)
Groups.ordered_ab_semigroup_add_imp_le_class.add_less_imp_less_left
WithFact ?c + ?a < ?c + ?b
GetFact (?a < ?b, Groups.ordered_ab_semigroup_add_imp_le_class.add_less_imp_less_left)
Arith_Thms.sum_le_zero1
WithFact ?a + ?b < (0::?'a)
WithFact (0::?'a) <= ?a
GetFact (?b < (0::?'a), Arith_Thms.sum_le_zero1)
Arith_Thms.less_sum1@back
WithGoal ?a < ?a + ?b
GetGoal (0 < ?b, Arith_Thms.less_sum1@back)
Nat.trans_less_add2@back
WithGoal ?i < ?m + ?j
GetGoal (?i < ?j, Nat.trans_less_add2@back)
Nat.add_less_mono1@back
WithGoal ?i + ?k < ?j + ?k
GetGoal (?i < ?j, Nat.add_less_mono1@back)
Nat.add_less_mono@back1
WithGoal ?i + ?k < ?j + ?l
WithFact ?k < ?l
GetGoal (?i < ?j, Nat.add_less_mono@back1)
Nat.add_le_mono@back1
WithGoal ?i + ?k <= ?j + ?l
WithFact ?k <= ?l
GetGoal (?i <= ?j, Nat.add_le_mono@back1)
Groups.ordered_comm_monoid_add_class.add_increasing2@back1
WithGoal ?b <= ?a + ?c
WithFact ?b <= ?a
GetGoal ((0::?'a) <= ?c, Groups.ordered_comm_monoid_add_class.add_increasing2@back1)
Groups.ordered_ab_semigroup_add_class.add_mono@back1
WithGoal ?a + ?c <= ?b + ?d
WithFact ?c <= ?d
GetGoal (?a <= ?b, Groups.ordered_ab_semigroup_add_class.add_mono@back1)
Groups.ordered_cancel_ab_semigroup_add_class.add_strict_left_mono@back
WithGoal ?c + ?a < ?c + ?b
GetGoal (?a < ?b, Groups.ordered_cancel_ab_semigroup_add_class.add_strict_left_mono@back)
Nat.mult_le_mono@back1
WithGoal ?i * ?k <= ?j * ?l
WithFact ?k <= ?l
GetGoal (?i <= ?j, Nat.mult_le_mono@back1)
Arith_Thms.nat_add_eq_self_zero
WithFact ?m = ?m + ?n
GetFact (?n = 0, Arith_Thms.nat_add_eq_self_zero)
Arith_Thms.nat_add_eq_self_zero'
WithFact ?m = ?n + ?m
GetFact (?n = 0, Arith_Thms.nat_add_eq_self_zero')
Arith_Thms.nat_mult_2
WithTerm ?a + ?a
GetFact (?a + ?a = 2 * ?a, Arith_Thms.nat_mult_2) + 1 filters
Arith_Thms.plus_one_non_zero@res
WithFact ?n + 1 = 0
GetResolve Arith_Thms.plus_one_non_zero@res
Arith_Thms.nat_same_minus_ge
WithFact ?c - ?b <= ?c - ?a
WithFact ?a <= ?c
GetFact (?a <= ?b, Arith_Thms.nat_same_minus_ge)
Arith_Thms.diff_eq_zero
WithWellForm ?k <= ?j
WithFact ?j - ?k = 0
GetFact (?j = ?k, Arith_Thms.diff_eq_zero)
Arith_Thms.diff_eq_zero'
WithWellForm ?k <= ?j
WithFact ?j - ?k + ?i = ?j
GetFact (?k = ?i, Arith_Thms.diff_eq_zero')
Arith_Thms.dvd_defD1@res
WithGoal EX k. ?b = ?a * k
WithFact ?a dvd ?b
GetResolve Arith_Thms.dvd_defD1@res
Arith_Thms.dvd_defD2@res
WithGoal EX k. ?b = k * ?a
WithFact ?a dvd ?b
GetResolve Arith_Thms.dvd_defD2@res
Nat.dvd_imp_le
WithFact ?k dvd ?n
WithFact 0 < ?n
GetFact (?k <= ?n, Nat.dvd_imp_le)
Arith_Thms.dvd_ineq2
WithFact ?k dvd ?n
WithFact 0 < ?n
GetFact (1 <= ?k, Arith_Thms.dvd_ineq2)
Rings.comm_monoid_mult_class.dvd_trans
WithFact ?a dvd ?b
WithFact ?b dvd ?c
GetFact (?a dvd ?c, Rings.comm_monoid_mult_class.dvd_trans) + 3 filters
Nat.dvd_antisym
WithFact ?m dvd ?n
WithFact ?n dvd ?m
GetFact (?m = ?n, Nat.dvd_antisym) + 1 filters
Arith_Thms.dvd_cancel@back1
WithGoal ?a dvd ?b
WithFact ?a * ?c dvd ?b * ?c
GetGoal (0 < ?c, Arith_Thms.dvd_cancel@back1)
Rings.comm_semiring_1_cancel_class.dvd_add_right_iff@eqforward
WithFact ?a dvd ?b
WithFact ?a dvd ?b + ?c
GetFact (?a dvd ?c, Rings.comm_semiring_1_cancel_class.dvd_add_right_iff@eqforward)
Rings.comm_monoid_mult_class.dvd_refl@res
WithGoal ?a dvd ?a
GetResolve Rings.comm_monoid_mult_class.dvd_refl@res
Arith_Thms.exists_n_dvd_n@back
WithGoal EX k. k dvd ?n & ?P k
GetGoal (?P ?n, Arith_Thms.exists_n_dvd_n@back)
Rings.comm_monoid_mult_class.one_dvd@res
WithGoal (1::?'a) dvd ?a
GetResolve Rings.comm_monoid_mult_class.one_dvd@res
Arith_Thms.any_n_dvd_0
WithGoal EX k. k dvd 0 & ?P k
GetGoal (EX k. ?P k, Arith_Thms.any_n_dvd_0)
Arith_Thms.n_dvd_one
WithFact is_unit ?n
GetFact (?n = 1, Arith_Thms.n_dvd_one) + 1 filters
Rings.mult_zero_class.mult_zero_left
WithTerm (0::?'a) * ?a
GetFact ((0::?'a) * ?a = (0::?'a), Rings.mult_zero_class.mult_zero_left)
Arith_Thms.prod_ineqs1
WithFact 0 < ?m * ?k
GetFact (0 < ?m & 0 < ?k, Arith_Thms.prod_ineqs1)
Arith_Thms.prod_ineqs2@back
WithGoal ?m <= ?m * ?k
GetGoal (0 < ?k, Arith_Thms.prod_ineqs2@back)
Arith_Thms.prod_cancel
WithFact ?a * ?b = ?a * ?c
WithFact 0 < ?a
GetFact (?b = ?c, Arith_Thms.prod_cancel) + 1 filters
Fun.injI@back
WithGoal inj ?f
GetGoal (ALL x y. ?f x = ?f y --> x = y, Fun.injI@back)
Arith_Thms.mult_n1n
WithFact ?n = ?m * ?n
WithFact 0 < ?n
GetFact (?m = 1, Arith_Thms.mult_n1n) + 1 filters
Arith_Thms.prod_is_one
WithFact ?x * ?y = 1
GetFact (?x = 1, Arith_Thms.prod_is_one)
Arith_Thms.prod_dvd_intro@back
WithGoal ?k dvd ?m * ?n
GetGoal (?k dvd ?m | ?k dvd ?n, Arith_Thms.prod_dvd_intro@back)
GCD.semiring_gcd_class.gcd_dvd1
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b dvd ?a, GCD.semiring_gcd_class.gcd_dvd1)
Add ac data for function Lattices.inf_class.inf
Add ac data for function Lattices.sup_class.sup
GCD.semiring_gcd_class.gcd_dvd2
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b dvd ?b, GCD.semiring_gcd_class.gcd_dvd2)
Set.mem_Collect_eq@eqforward
WithFact ?a : Collect ?P
GetFact (?P ?a, Set.mem_Collect_eq@eqforward)
Set.mem_Collect_eq@invbackward
WithGoal ?a : Collect ?P
GetGoal (?P ?a, Set.mem_Collect_eq@invbackward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@eqforward
WithFact coprime ?a ?b
GetFact (gcd ?a ?b = (1::?'a), GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@eqforward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@invbackward
WithGoal coprime ?a ?b
GetGoal (gcd ?a ?b = (1::?'a), GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@invbackward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@eqforward
WithFact gcd ?a ?b = (1::?'a)
GetFact (coprime ?a ?b, GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@eqforward)
GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@invbackward
WithGoal gcd ?a ?b = (1::?'a)
GetGoal (coprime ?a ?b, GCD.semiring_gcd_class.coprime_iff_gcd_eq_1@sym@invbackward)
Arith_Thms.coprime_exp@back
WithGoal coprime ?d (?a ^ ?n)
GetGoal (coprime ?d ?a, Arith_Thms.coprime_exp@back)
Set_Thms.ball_single@eqforward
WithFact ALL x:{?x}. ?P x
GetFact (?P ?x, Set_Thms.ball_single@eqforward)
Set_Thms.ball_single@invbackward
WithGoal ALL x:{?x}. ?P x
GetGoal (?P ?x, Set_Thms.ball_single@invbackward)
Arith_Thms.coprime_exp@back
WithGoal coprime ?d (?a ^ ?n)
GetGoal (coprime ?d ?a, Arith_Thms.coprime_exp@back)
Set.singleton_iff@eqforward
WithFact ?b : {?a}
GetFact (?b = ?a, Set.singleton_iff@eqforward)
Set.singleton_iff@invbackward
WithGoal ?b : {?a}
GetGoal (?b = ?a, Set.singleton_iff@invbackward)
GCD.semiring_gcd_class.gcd.commute
WithTerm gcd ?a ?b
GetFact (gcd ?a ?b = gcd ?b ?a, GCD.semiring_gcd_class.gcd.commute)
Set.empty_iff@eqforward
WithFact ?c : {}
GetResolve Set.empty_iff@eqforward
Arith_Thms.coprime_dvd_mult@back1
WithGoal ?a dvd ?c
WithFact ?a dvd ?c * ?b
GetGoal (coprime ?a ?b, Arith_Thms.coprime_dvd_mult@back1)
Set_Thms.set_membership_distinct
WithFact ?x : ?s
WithGoal ?y : ?s
GetGoal (?x = ?y, Set_Thms.set_membership_distinct)
Arith_Thms.coprime_dvd_mult'@back1
WithGoal ?a dvd ?c
WithFact ?a dvd ?b * ?c
GetGoal (coprime ?a ?b, Arith_Thms.coprime_dvd_mult'@back1)
Set_Thms.non_empty_exist_elt@back
WithGoal EX x. x : ?U
GetFact (?U = {}, Set_Thms.non_empty_exist_elt@back)
Set_Thms.non_univ_exist_compl@back
WithGoal EX x. x ~: ?U
GetFact (?U = UNIV, Set_Thms.non_univ_exist_compl@back)
Arith_Thms.coprime_dvd
WithFact coprime ?a ?b
WithFact ?p dvd ?a
GetFact (1 < ?p --> ~ ?p dvd ?b, Arith_Thms.coprime_dvd)
Set.UNIV_I@res
WithGoal ?x : UNIV
GetResolve Set.UNIV_I@res
Power.power_class.power.power_0
WithTerm ?a ^ 0
GetFact (?a ^ 0 = (1::?'a), Power.power_class.power.power_0)
Arith_Thms.power_ge_0
WithTerm ?p ^ ?m
WithGoal ?m = 0
GetFact (?p ^ ?m = ?p * ?p ^ (?m - 1), Arith_Thms.power_ge_0)
Set.insert_iff@eqbackward@back
WithGoal ?a : insert ?b ?A
GetGoal (?a = ?b | ?a : ?A, Set.insert_iff@eqbackward@back) + 1 filters
Power.monoid_mult_class.power_one
WithTerm (1::?'a) ^ ?n
GetFact ((1::?'a) ^ ?n = (1::?'a), Power.monoid_mult_class.power_one) + 1 filters
Set.insert_iff@eqforward
WithFact ?a : insert ?b ?A
WithScore 500
GetFact (?a = ?b | ?a : ?A, Set.insert_iff@eqforward) + 1 filters
Power.monoid_mult_class.power_one_right
WithTerm ?a ^ 1
GetFact (?a ^ 1 = ?a, Power.monoid_mult_class.power_one_right) + 1 filters
Set.insert_subset@eqforward
WithFact insert ?x ?A <= ?B
GetFact (?x : ?B & ?A <= ?B, Set.insert_subset@eqforward) + 1 filters
Arith_Thms.one_is_power_of_any@res
WithGoal EX i. 1 = ?a ^ i
GetResolve Arith_Thms.one_is_power_of_any@res
Set.insert_subset@eqbackward@back
WithGoal insert ?x ?A <= ?B
WithScore 500
GetGoal (?x : ?B & ?A <= ?B, Set.insert_subset@eqbackward@back) + 1 filters
Power.power_class.power.power_Suc
WithTerm ?a ^ Suc ?n
GetFact (?a ^ Suc ?n = ?a * ?a ^ ?n, Power.power_class.power.power_Suc)
Set_Thms.set_ext
WithFact ALL a. (a : ?S) = (a : ?T)
GetFact (?S = ?T, Set_Thms.set_ext)
Arith_Thms.power_dvd
WithFact ?p ^ ?n dvd ?a
WithGoal ?n = 0
GetFact (?p dvd ?a, Arith_Thms.power_dvd)
Set_Thms.set_ext@back
WithGoal ?S = ?T
WithScore 500
GetGoal (ALL a. (a : ?S) = (a : ?T), Set_Thms.set_ext@back) + 1 filters
Set_Thms.set_pair_ext
WithFact ALL a b. ((a, b) : ?S) = ((a, b) : ?T)
GetFact (?S = ?T, Set_Thms.set_pair_ext)
Arith_Thms.power_eq_one
WithFact ?b ^ ?n = 1
GetFact (?b = 1 | ?n = 0, Arith_Thms.power_eq_one) + 2 filters
Set.Un_iff@eqforward
WithFact ?c : ?A Un ?B
WithScore 500
GetFact (?c : ?A | ?c : ?B, Set.Un_iff@eqforward)
Arith_Thms.fact_ge_1_nat
WithTerm fact ?n
GetFact (1 <= fact ?n, Arith_Thms.fact_ge_1_nat)
Set.Un_iff@eqbackward@back
WithGoal ?c : ?A Un ?B
GetGoal (?c : ?A | ?c : ?B, Set.Un_iff@eqbackward@back)
Factorial.dvd_fact@back1
WithGoal ?m dvd fact ?n
WithFact ?m <= ?n
GetGoal (1 <= ?m, Factorial.dvd_fact@back1)
Set_Thms.UnD1
WithFact ?c : ?A Un ?B
WithGoal ?c : ?A
GetFact (?c : ?B, Set_Thms.UnD1)
Nat.Suc_eq_plus1
WithTerm Suc ?n
GetFact (Suc ?n = ?n + 1, Nat.Suc_eq_plus1)
Set_Thms.UnD2
WithFact ?c : ?A Un ?B
WithGoal ?c : ?B
GetFact (?c : ?A, Set_Thms.UnD2)
Nat.gr0_implies_Suc@back
WithGoal EX m. ?n = Suc m
GetGoal (0 < ?n, Nat.gr0_implies_Suc@back)
Set_Thms.UnD1_single
WithFact ?c : {?a} Un ?B
WithGoal ?c = ?a
GetFact (?c : ?B, Set_Thms.UnD1_single)
Nat.nat.case_1
WithTerm case 0 of 0 => ?f1.0 | Suc x => ?f2.0 x
GetFact ((case 0 of 0 => ?f1.0 | Suc x => ?f2.0 x) = ?f1.0, Nat.nat.case_1)
Nat.nat.case_2
WithTerm case Suc ?x2.0 of 0 => ?f1.0 | Suc x => ?f2.0 x
GetFact ((case Suc ?x2.0 of 0 => ?f1.0 | Suc x => ?f2.0 x) = ?f2.0 ?x2.0, Nat.nat.case_2)
Set_Thms.UnD2_single
WithFact ?c : ?A Un {?b}
WithGoal ?c = ?b
GetFact (?c : ?A, Set_Thms.UnD2_single)
Euclidean_Division.times_div_less_eq_dividend@res
WithGoal ?n * (?m div ?n) <= ?m
GetResolve Euclidean_Division.times_div_less_eq_dividend@res
Set.UnI1
WithTerm ?A Un ?B
WithFact ?c : ?A
GetFact (?c : ?A Un ?B, Set.UnI1)
Nat.nat_less_induct
Substitution: ?n, ALL m<?n. ?P m
Set.UnI2
WithTerm ?A Un ?B
WithFact ?c : ?B
GetFact (?c : ?A Un ?B, Set.UnI2)
### theory "Auto2_HOL.Arith_Thms"
### 1.081s elapsed time, 2.345s cpu time, 0.171s GC time
Set_Thms.UnI1_single
WithTerm {?a} Un ?B
GetFact (?a : {?a} Un ?B, Set_Thms.UnI1_single)
Set_Thms.UnI2_single
WithTerm ?A Un {?b}
GetFact (?b : ?A Un {?b}, Set_Thms.UnI2_single)
Set_Thms.union_single_eq
WithTerm {?x} Un ?p
WithFact ?x : ?p
GetFact ({?x} Un ?p = ?p, Set_Thms.union_single_eq)
Set_Thms.union_single_eq@back
WithGoal {?x} Un ?p = ?p
GetGoal (?x : ?p, Set_Thms.union_single_eq@back)
Set.Int_iff@eqforward
WithFact ?c : ?A Int ?B
GetFact (?c : ?A & ?c : ?B, Set.Int_iff@eqforward)
Set.Int_iff@eqbackward@back
WithGoal ?c : ?A Int ?B
WithScore 500
GetGoal (?c : ?A & ?c : ?B, Set.Int_iff@eqbackward@back)
Set.Int_empty_left
WithTerm {} Int ?B
GetFact ({} Int ?B = {}, Set.Int_empty_left)
Set.Int_empty_right
WithTerm ?A Int {}
GetFact (?A Int {} = {}, Set.Int_empty_right)
Set.Int_absorb
WithTerm ?A Int ?A
GetFact (?A Int ?A = ?A, Set.Int_absorb)
Set_Thms.set_disjoint_mp
WithFact ?A Int ?B = {}
WithFact ?p : ?A
GetGoal (?p : ?B, Set_Thms.set_disjoint_mp)
Set_Thms.set_disjoint_mp@back2
WithFact ?p : ?B
WithFact ?A Int ?B = {}
GetGoal (?p : ?A, Set_Thms.set_disjoint_mp@back2)
Set_Thms.set_disjoint_single@eqforward
WithFact {?x} Int ?B = {}
GetGoal (?x : ?B, Set_Thms.set_disjoint_single@eqforward)
Set_Thms.set_disjoint_single@invbackward
WithGoal {?x} Int ?B = {}
GetFact (?x : ?B, Set_Thms.set_disjoint_single@invbackward)
Set.subsetI
WithFact ALL x. x : ?A --> x : ?B
GetFact (?A <= ?B, Set.subsetI)
Set.subsetI@back
WithGoal ?A <= ?B
WithScore 500
GetGoal (ALL x. x : ?A --> x : ?B, Set.subsetI@back)
Set.empty_subsetI@res
WithGoal {} <= ?A
GetResolve Set.empty_subsetI@res
Set.subsetD
WithFact ?A <= ?B
WithFact ?c : ?A
GetFact (?c : ?B, Set.subsetD)
Set_Thms.subset_single@eqforward
WithFact {?a} <= ?B
GetFact (?a : ?B, Set_Thms.subset_single@eqforward)
Set_Thms.subset_single@invbackward
WithGoal {?a} <= ?B
GetGoal (?a : ?B, Set_Thms.subset_single@invbackward)
Set.basic_monos_1@res
WithGoal ?A <= ?A
GetResolve Set.basic_monos_1@res
Set.Un_upper1@res
WithGoal ?A <= ?A Un ?B
GetResolve Set.Un_upper1@res
Set.Un_upper2@res
WithGoal ?B <= ?A Un ?B
GetResolve Set.Un_upper2@res
Set_Thms.union_is_subset
WithFact ?A Un ?B <= ?C
GetFact (?A <= ?C & ?B <= ?C, Set_Thms.union_is_subset)
Set.Un_least@back1
WithGoal ?A Un ?B <= ?C
WithFact ?B <= ?C
GetGoal (?A <= ?C, Set.Un_least@back1)
Set.Un_least@back2
WithGoal ?A Un ?B <= ?C
WithFact ?A <= ?C
GetGoal (?B <= ?C, Set.Un_least@back2)
Set_Thms.subset_union_same1@back
WithGoal ?A Un ?B <= ?A Un ?C
GetGoal (?B <= ?C, Set_Thms.subset_union_same1@back)
Set_Thms.subset_union_same2@back
WithGoal ?A Un ?C <= ?B Un ?C
GetGoal (?A <= ?B, Set_Thms.subset_union_same2@back)
Set.Diff_iff@eqforward
WithFact ?c : ?A - ?B
GetFact (?c : ?A & ?c ~: ?B, Set.Diff_iff@eqforward)
Set.Diff_iff@eqbackward@back
WithGoal ?c : ?A - ?B
WithScore 500
GetGoal (?c : ?A & ?c ~: ?B, Set.Diff_iff@eqbackward@back)
Set.empty_Diff
WithTerm {} - ?A
GetFact ({} - ?A = {}, Set.empty_Diff)
Set_Thms.mem_diff@eqforward
WithFact ?x : ?A - ?B
GetFact (?x : ?A & ?x ~: ?B, Set_Thms.mem_diff@eqforward)
Set_Thms.mem_diff@invbackward
WithGoal ?x : ?A - ?B
GetGoal (?x : ?A & ?x ~: ?B, Set_Thms.mem_diff@invbackward)
Set_Thms.set_union_minus_same1
WithTerm ?A Un ?B - ?B
GetFact (?A Un ?B - ?B = ?A - ?B, Set_Thms.set_union_minus_same1)
Set_Thms.set_union_minus_same2
WithTerm ?B Un ?A - ?B
GetFact (?B Un ?A - ?B = ?A - ?B, Set_Thms.set_union_minus_same2)
Set_Thms.set_union_minus_distinct
WithTerm {?a} Un (?B - {?c})
WithGoal ?a = ?c
GetFact ({?a} Un (?B - {?c}) = {?a} Un ?B - {?c}, Set_Thms.set_union_minus_distinct)
Set.Diff_subset
WithTerm ?A - ?B
GetFact (?A - ?B <= ?A, Set.Diff_subset)
Set_Thms.union_subtract_elt1
WithTerm {?x} Un ?B - {?x}
WithGoal ?x : ?B
GetFact ({?x} Un ?B - {?x} = ?B, Set_Thms.union_subtract_elt1)
Set_Thms.union_subtract_elt2
WithTerm ?B Un {?x} - {?x}
WithGoal ?x : ?B
GetFact (?B Un {?x} - {?x} = ?B, Set_Thms.union_subtract_elt2)
Set_Thms.subset_sub1@back
WithGoal ?A - {?x} < ?A
GetGoal (?x : ?A, Set_Thms.subset_sub1@back)
Set_Thms.member_notin
WithFact ?x : ?S - {?y}
GetGoal (?x = ?y, Set_Thms.member_notin)
Set_Thms.member_notin_contra
WithTerm ?S - {?y}
WithFact ?x : ?S
GetFact (?x ~= ?y --> ?x : ?S - {?y}, Set_Thms.member_notin_contra)
Finite_Set.finite.emptyI@res
WithGoal finite {}
GetResolve Finite_Set.finite.emptyI@res
Set_Thms.set_finite_single@res
WithGoal finite {?x}
GetResolve Set_Thms.set_finite_single@res
Finite_Set.finite_Un@eqforward
WithFact finite (?F Un ?G)
GetFact (finite ?F & finite ?G, Finite_Set.finite_Un@eqforward)
Finite_Set.finite_Un@invbackward
WithGoal finite (?F Un ?G)
GetGoal (finite ?F & finite ?G, Finite_Set.finite_Un@invbackward)
Set_Thms.Max_ge'
WithProperty finite ?A
WithFact Max ?A < ?x
GetGoal (?x : ?A, Set_Thms.Max_ge')
Finite_Set.finite_image_set@back
WithGoal finite {?f x |x. ?P x}
GetGoal (finite {x. ?P x}, Finite_Set.finite_image_set@back)
Add property rule for function Set_Interval.ord_class.atLeastAtMost
Finite_Set.rev_finite_subset
WithProperty finite ?B
WithFact ?A <= ?B
GetFact (finite ?A, Finite_Set.rev_finite_subset)
Finite_Set.rev_finite_subset@back1
WithGoal finite ?A
WithFact ?A <= ?B
GetGoal (finite ?B, Finite_Set.rev_finite_subset@back1)
Finite_Set.card.empty
WithTerm card {}
GetFact (card {} = 0, Finite_Set.card.empty)
Set_Thms.card_emptyD
WithProperty finite ?S
WithTerm ?S
WithFact card ?S = 0
GetFact (?S = {}, Set_Thms.card_emptyD)
Set_Thms.card_minus1
WithTerm card (?S - {?x})
WithFact ?x : ?S
GetFact (card (?S - {?x}) = card ?S - 1, Set_Thms.card_minus1)
Add property rule for function Groups.minus_class.minus
Finite_Set.card_mono@res
WithProperty finite ?B
WithGoal card ?A <= card ?B
WithFact ?A <= ?B
GetResolve Finite_Set.card_mono@res
Set.image_Un
WithTerm ?f ` (?A Un ?B)
GetFact (?f ` (?A Un ?B) = ?f ` ?A Un ?f ` ?B, Set.image_Un)
Fun.image_set_diff
WithTerm ?f ` (?A - ?B)
WithFact inj ?f
GetFact (?f ` (?A - ?B) = ?f ` ?A - ?f ` ?B, Fun.image_set_diff)
Set_Thms.mset_member_empty@res
WithFact ?p :# {#}
GetResolve Set_Thms.mset_member_empty@res
Set_Thms.mem_multiset_single@eqforward
WithFact ?x :# {#?y#}
GetFact (?x = ?y, Set_Thms.mem_multiset_single@eqforward)
Set_Thms.mem_multiset_single@invbackward
WithGoal ?x :# {#?y#}
GetGoal (?x = ?y, Set_Thms.mem_multiset_single@invbackward)
Multiset.subset_mset.antisym@back2
WithGoal ?a = ?b
WithFact ?a <=# ?b
GetGoal (?b <=# ?a, Multiset.subset_mset.antisym@back2)
Multiset.empty_le@res
WithGoal {#} <=# ?A
GetResolve Multiset.empty_le@res
Multiset.mset_subsetD
WithFact ?A <# ?B
WithFact ?x :# ?A
GetFact (?x :# ?B, Multiset.mset_subsetD)
Set_Thms.multi_contain_add_self1@res
WithGoal ?A <# {#?x#} + ?A
GetResolve Set_Thms.multi_contain_add_self1@res
Set_Thms.multi_contain_add_self2@res
WithGoal ?A <# ?A + {#?x#}
GetResolve Set_Thms.multi_contain_add_self2@res
Multiset.multi_member_this
WithTerm {#?x#} + ?XS
GetFact (?x :# {#?x#} + ?XS, Multiset.multi_member_this)
Set_Thms.multi_member_this2
WithTerm ?XS + {#?x#}
GetFact (?x :# ?XS + {#?x#}, Set_Thms.multi_member_this2)
Multiset.subset_mset.add_left_mono@back
WithGoal ?c + ?a <=# ?c + ?b
GetGoal (?a <=# ?b, Multiset.subset_mset.add_left_mono@back)
Multiset.subset_mset.add_right_mono@back
WithGoal ?a + ?c <=# ?b + ?c
GetGoal (?a <=# ?b, Multiset.subset_mset.add_right_mono@back)
Set_Thms.multi_nonempty_split'@res
WithGoal EX M' m. ?M = M' + {#m#}
WithGoal ?M = {#}
GetResolve Set_Thms.multi_nonempty_split'@res
Set_Thms.multi_member_split'@back
WithGoal EX M'. ?M = M' + {#?x#}
GetGoal (?x :# ?M, Set_Thms.multi_member_split'@back)
Multiset.full_multiset_induct
Substitution: ?B, ALL A. A <# ?B --> ?P A
Multiset.set_mset_empty
WithTerm set_mset {#}
GetFact (set_mset {#} = {}, Multiset.set_mset_empty)
Multiset.set_mset_single
WithTerm set_mset {#?b#}
GetFact (set_mset {#?b#} = {?b}, Multiset.set_mset_single)
Multiset.set_mset_union
WithTerm set_mset (?M + ?N)
GetFact (set_mset (?M + ?N) = set_mset ?M Un set_mset ?N, Multiset.set_mset_union)
Multiset.image_mset_empty
WithTerm image_mset ?f {#}
GetFact (image_mset ?f {#} = {#}, Multiset.image_mset_empty)
Multiset.image_mset_single
WithTerm image_mset ?f {#?x#}
GetFact (image_mset ?f {#?x#} = {#?f ?x#}, Multiset.image_mset_single)
Multiset.image_mset_union
WithTerm image_mset ?f (?M + ?N)
GetFact (image_mset ?f (?M + ?N) = image_mset ?f ?M + image_mset ?f ?N, Multiset.image_mset_union)
Multiset.comm_monoid_mult_class.prod_mset_empty
WithTerm \<Prod>\<^sub># {#}
GetFact (\<Prod>\<^sub># {#} = (1::?'a), Multiset.comm_monoid_mult_class.prod_mset_empty)
Multiset.comm_monoid_mult_class.prod_mset_singleton
WithTerm \<Prod>\<^sub># {#?x#}
GetFact (\<Prod>\<^sub># {#?x#} = ?x, Multiset.comm_monoid_mult_class.prod_mset_singleton)
Multiset.comm_monoid_mult_class.prod_mset_Un
WithTerm \<Prod>\<^sub># (?A + ?B)
GetFact (\<Prod>\<^sub># (?A + ?B) = \<Prod>\<^sub># ?A * \<Prod>\<^sub># ?B, Multiset.comm_monoid_mult_class.prod_mset_Un)
Set_Interval.ord_class.lessThan_iff@eqforward
WithFact ?i : {..<?k}
GetFact (?i < ?k, Set_Interval.ord_class.lessThan_iff@eqforward)
Set_Interval.ord_class.lessThan_iff@invbackward
WithGoal ?i : {..<?k}
GetGoal (?i < ?k, Set_Interval.ord_class.lessThan_iff@invbackward)
Set_Interval.ord_class.atLeastAtMost_iff@eqforward
WithFact ?i : {?l..?u}
GetFact (?l <= ?i & ?i <= ?u, Set_Interval.ord_class.atLeastAtMost_iff@eqforward)
Set_Interval.ord_class.atLeastAtMost_iff@invbackward
WithGoal ?i : {?l..?u}
GetGoal (?l <= ?i & ?i <= ?u, Set_Interval.ord_class.atLeastAtMost_iff@invbackward)
### theory "Auto2_HOL.Set_Thms"
### 0.412s elapsed time, 0.771s cpu time, 0.075s GC time
Loading theory "Auto2_HOL.Lists_Thms" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel" via "Auto2_HOL.Auto2_Main")
List.list.distinct_2@res
WithFact ?x21.0 # ?x22.0 = []
GetResolve List.list.distinct_2@res
List.list.simps_1@eqforward
WithFact ?x21.0 # ?x22.0 = ?y21.0 # ?y22.0
GetFact (?x21.0 = ?y21.0 & ?x22.0 = ?y22.0, List.list.simps_1@eqforward)
List.list.sel_1
WithTerm hd (?x21.0 # ?x22.0)
GetFact (hd (?x21.0 # ?x22.0) = ?x21.0, List.list.sel_1)
List.list.sel_2
WithTerm tl []
GetFact (tl [] = [], List.list.sel_2)
List.list.sel_3
WithTerm tl (?x21.0 # ?x22.0)
GetFact (tl (?x21.0 # ?x22.0) = ?x22.0, List.list.sel_3)
List.list.collapse
WithTerm hd ?list # tl ?list
WithGoal ?list = []
GetFact (hd ?list # tl ?list = ?list, List.list.collapse)
List.list.size_3
WithTerm length []
GetFact (length [] = 0, List.list.size_3)
Lists_Thms.length_one
WithTerm length [?x]
GetFact (length [?x] = 1, Lists_Thms.length_one)
Lists_Thms.length_Cons
WithTerm length (?a # ?b)
GetFact (length (?a # ?b) = length ?b + 1, Lists_Thms.length_Cons)
Lists_Thms.length_snoc
WithTerm length (?xs @ [?x])
GetFact (length (?xs @ [?x]) = length ?xs + 1, Lists_Thms.length_snoc)
Lists_Thms.length_zero_is_nil
WithFact length ?xs = 0
GetFact (?xs = [], Lists_Thms.length_zero_is_nil)
Lists_Thms.length_gt_zero
WithFact 0 < length ?xs
GetGoal (?xs = [], Lists_Thms.length_gt_zero)
List.length_append
WithTerm length (?xs @ ?ys)
GetFact (length (?xs @ ?ys) = length ?xs + length ?ys, List.length_append)
List.append.simps_2
WithTerm (?x # ?xs) @ ?ys
GetFact ((?x # ?xs) @ ?ys = ?x # ?xs @ ?ys, List.append.simps_2) + 1 filters
List.hd_append2
WithTerm hd (?xs @ ?ys)
WithGoal ?xs = []
GetFact (hd (?xs @ ?ys) = hd ?xs, List.hd_append2)
Lists_Thms.append_is_empty
WithFact ?xs @ ?ys = []
GetFact (?xs = [] & ?ys = [], Lists_Thms.append_is_empty)
Lists_Thms.cons_to_append@sym
WithTerm [?a] @ ?b
GetFact ([?a] @ ?b = ?a # ?b, Lists_Thms.cons_to_append@sym)
signature LIST_AC =
  sig
    val add_list_proofsteps: theory -> theory
    val append_const: typ -> term
    val case_head: typ -> term -> heads
    val dest_list_full: Proof.context -> typ -> cterm -> cterm list
    val get_list_head_equiv:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val get_list_ty: term -> typ option
    datatype heads = LIST_APPEND | LIST_CONS | LIST_NIL | LIST_OTHER
    val is_list_head: typ -> term -> bool
    val list_expand:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val list_expand_equiv: proofstep
    val list_expand_once:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
    val list_expand_unit: proofstep
    val normalize_list: typ -> conv
    val normalize_list_assoc: typ -> conv
    val rewrite_on_eqs: typ -> thm list -> cterm -> thm
    val simp_list_expr:
       Proof.context -> typ -> box_id * cterm -> (box_id * thm) list
  end
structure List_AC: LIST_AC
val test_norm_t = fn: string -> string * string -> unit
val test = [(), (), (), (), (), (), (), (), (), (), (), ()]: unit list
List.nth_equalityI@back2
WithGoal ?xs = ?ys
WithFact length ?xs = length ?ys
GetGoal (ALL i<length ?xs. ?xs ! i = ?ys ! i, List.nth_equalityI@back2) + 1 filters
List.set_simps_1
WithTerm set []
GetFact (set [] = {}, List.set_simps_1)
Lists_Thms.set_one
WithTerm set [?u]
GetFact (set [?u] = {?u}, Lists_Thms.set_one)
Lists_Thms.set_two
WithTerm set [?u, ?v]
GetFact (set [?u, ?v] = {?u, ?v}, Lists_Thms.set_two)
Lists_Thms.set_simps2
WithTerm set (?x # ?xs)
GetFact (set (?x # ?xs) = {?x} Un set ?xs, Lists_Thms.set_simps2) + 2 filters
List.set_append
WithTerm set (?xs @ ?ys)
GetFact (set (?xs @ ?ys) = set ?xs Un set ?ys, List.set_append)
List.set_rev
WithTerm set (rev ?xs)
GetFact (set (rev ?xs) = set ?xs, List.set_rev)
List.finite_set@res
WithGoal finite (set ?xs)
GetResolve List.finite_set@res
List.in_set_conv_nth@eqforward@back
WithGoal EX i<length ?xs. ?xs ! i = ?x
GetGoal (?x : set ?xs, List.in_set_conv_nth@eqforward@back)
List.hd_in_set
WithWellForm ?xs ~= []
WithTerm hd ?xs
GetFact (hd ?xs : set ?xs, List.hd_in_set)
List.length_tl
WithTerm length (tl ?xs)
GetFact (length (tl ?xs) = length ?xs - 1, List.length_tl)
Lists_Thms.nth_tl'
WithTerm tl ?xs ! ?i
WithFact ?i < length (tl ?xs)
GetFact (tl ?xs ! ?i = ?xs ! (?i + 1), Lists_Thms.nth_tl')
Lists_Thms.set_tl_subset
WithTerm set (tl ?xs)
GetFact (set (tl ?xs) <= set ?xs, Lists_Thms.set_tl_subset)
List.nth_case
WithTerm ?xs ! ?i
CreateConcl ?i < length ?xs
List.hd_conv_nth@sym
WithTerm ?xs ! 0
WithGoal ?xs = []
GetFact (?xs ! 0 = hd ?xs, List.hd_conv_nth@sym)
List.nth_Cons'
WithTerm (?x # ?xs) ! ?n
GetFact ((?x # ?xs) ! ?n = (if ?n = 0 then ?x else ?xs ! (?n - 1)), List.nth_Cons')
List.nth_append
WithTerm (?xs @ ?ys) ! ?n
GetFact ((?xs @ ?ys) ! ?n =
(if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs)), List.nth_append)
List.nth_mem
WithWellForm ?n < length ?xs
WithTerm ?xs ! ?n
GetFact (?xs ! ?n : set ?xs, List.nth_mem)
Lists_Thms.sorted_Nil@res
WithGoal Lists_Thms.sorted []
GetResolve Lists_Thms.sorted_Nil@res
Lists_Thms.sorted_single@res
WithGoal Lists_Thms.sorted [?x]
GetResolve Lists_Thms.sorted_single@res
Lists_Thms.sorted_simps2@eqbackward@back
WithGoal Lists_Thms.sorted (?x # ?ys)
GetGoal (Ball (set ?ys) ((<=) ?x) & Lists_Thms.sorted ?ys, Lists_Thms.sorted_simps2@eqbackward@back)
Lists_Thms.sorted_ConsD1
WithFact Lists_Thms.sorted (?x # ?xs)
GetFact (Lists_Thms.sorted ?xs, Lists_Thms.sorted_ConsD1)
Lists_Thms.sorted_ConsD2
WithFact Lists_Thms.sorted (?x # ?xs)
WithFact ?y : set ?xs
GetFact (?x <= ?y, Lists_Thms.sorted_ConsD2)
Lists_Thms.sorted_ConsD2@back2
WithGoal ?x <= ?y
WithFact Lists_Thms.sorted (?x # ?xs)
GetGoal (?y : set ?xs, Lists_Thms.sorted_ConsD2@back2)
Lists_Thms.sorted_appendI@back
WithGoal Lists_Thms.sorted (?xs @ ?ys)
GetGoal (Lists_Thms.sorted ?xs &
Lists_Thms.sorted ?ys & (ALL x:set ?xs. ALL y:set ?ys. x <= y), Lists_Thms.sorted_appendI@back)
Lists_Thms.sorted_appendE
WithFact Lists_Thms.sorted (?xs @ ?ys)
GetFact (Lists_Thms.sorted ?xs & Lists_Thms.sorted ?ys, Lists_Thms.sorted_appendE)
Lists_Thms.sorted_appendE2
WithFact Lists_Thms.sorted (?xs @ ?ys)
WithFact ?x : set ?xs
GetFact (ALL y:set ?ys. ?x <= y, Lists_Thms.sorted_appendE2)
Lists_Thms.sorted_nth_mono'@back
WithProperty Lists_Thms.sorted ?xs
WithWellForm ?j < length ?xs
WithGoal ?xs ! ?i <= ?xs ! ?j
GetGoal (?i <= ?j, Lists_Thms.sorted_nth_mono'@back)
Lists_Thms.sorted_nth_mono_less
WithProperty Lists_Thms.sorted ?xs
WithWellForm ?i < length ?xs
WithFact ?xs ! ?i < ?xs ! ?j
GetFact (?i < ?j, Lists_Thms.sorted_nth_mono_less)
Lists_Thms.sorted_sort
WithTerm sort ?xs
GetFact (Lists_Thms.sorted (sort ?xs), Lists_Thms.sorted_sort)
List.linorder_class.length_sort
WithTerm length (sort_key ?f ?xs)
GetFact (length (sort_key ?f ?xs) = length ?xs, List.linorder_class.length_sort)
Multiset.linorder_class.mset_sort
WithTerm mset (sort_key ?k ?xs)
GetFact (mset (sort_key ?k ?xs) = mset ?xs, Multiset.linorder_class.mset_sort)
List.linorder_class.set_sort
WithTerm set (sort_key ?f ?xs)
GetFact (set (sort_key ?f ?xs) = set ?xs, List.linorder_class.set_sort)
Lists_Thms.properties_for_sort@back
WithGoal sort ?xs = ?ys
GetGoal (mset ?ys = mset ?xs & Lists_Thms.sorted ?ys, Lists_Thms.properties_for_sort@back)
Lists_Thms.sort_Nil
WithTerm sort []
GetFact (sort [] = [], Lists_Thms.sort_Nil)
Lists_Thms.sort_singleton
WithTerm sort [?a]
GetFact (sort [?a] = [?a], Lists_Thms.sort_singleton)
Lists_Thms.distinct_Nil@res
WithGoal distinct []
GetResolve Lists_Thms.distinct_Nil@res
List.distinct_singleton@res
WithGoal distinct [?x]
GetResolve List.distinct_singleton@res
List.distinct.simps_2@eqforward
WithFact distinct (?x # ?xs)
GetFact (?x ~: set ?xs & distinct ?xs, List.distinct.simps_2@eqforward) + 1 filters
List.distinct.simps_2@invbackward
WithGoal distinct (?x # ?xs)
GetGoal (?x ~: set ?xs & distinct ?xs, List.distinct.simps_2@invbackward) + 1 filters
List.distinct_append@eqforward
WithFact distinct (?xs @ ?ys)
GetFact (distinct ?xs & distinct ?ys & set ?xs Int set ?ys = {}, List.distinct_append@eqforward)
List.distinct_append@invbackward
WithGoal distinct (?xs @ ?ys)
GetGoal (distinct ?xs & distinct ?ys & set ?xs Int set ?ys = {}, List.distinct_append@invbackward)
List.distinct_rev@eqforward
WithFact distinct (rev ?xs)
GetFact (distinct ?xs, List.distinct_rev@eqforward)
List.distinct_rev@invbackward
WithGoal distinct (rev ?xs)
GetGoal (distinct ?xs, List.distinct_rev@invbackward)
List.linorder_class.distinct_sort@eqforward
WithFact distinct (sort_key ?f ?xs)
GetFact (distinct ?xs, List.linorder_class.distinct_sort@eqforward)
List.linorder_class.distinct_sort@invbackward
WithGoal distinct (sort_key ?f ?xs)
GetGoal (distinct ?xs, List.linorder_class.distinct_sort@invbackward)
List.distinct_conv_nth@eqbackward@res
WithGoal distinct ?xs
WithFact ALL i<length ?xs. ALL j<length ?xs. i ~= j --> ?xs ! i ~= ?xs ! j
GetResolve List.distinct_conv_nth@eqbackward@res
Lists_Thms.distinct_nthE
WithProperty distinct ?xs
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithFact ?xs ! ?i = ?xs ! ?j
GetFact (?i = ?j, Lists_Thms.distinct_nthE)
List.list.map_1
WithTerm map ?f []
GetFact (map ?f [] = [], List.list.map_1)
List.list.map_2
WithTerm map ?f (?x21.0 # ?x22.0)
GetFact (map ?f (?x21.0 # ?x22.0) = ?f ?x21.0 # map ?f ?x22.0, List.list.map_2)
List.length_map
WithTerm length (map ?f ?xs)
GetFact (length (map ?f ?xs) = length ?xs, List.length_map)
List.nth_map
WithTerm map ?f ?xs ! ?n
WithFact ?n < length ?xs
GetFact (map ?f ?xs ! ?n = ?f (?xs ! ?n), List.nth_map)
List.map_append
WithTerm map ?f (?xs @ ?ys)
GetFact (map ?f (?xs @ ?ys) = map ?f ?xs @ map ?f ?ys, List.map_append)
List.length_replicate
WithTerm replicate ?n ?x
GetFact (length (replicate ?n ?x) = ?n, List.length_replicate)
List.nth_replicate
WithTerm replicate ?n ?x ! ?i
WithFact ?i < ?n
GetFact (replicate ?n ?x ! ?i = ?x, List.nth_replicate)
Lists_Thms.last_eval1
WithTerm last [?x]
GetFact (last [?x] = ?x, Lists_Thms.last_eval1)
Lists_Thms.last_eval2
WithTerm last [?u, ?v]
GetFact (last [?u, ?v] = ?v, Lists_Thms.last_eval2)
List.last_ConsR
WithTerm last (?x # ?xs)
WithGoal ?xs = []
GetFact (last (?x # ?xs) = last ?xs, List.last_ConsR)
List.last_appendR
WithTerm last (?xs @ ?ys)
WithGoal ?ys = []
GetFact (last (?xs @ ?ys) = last ?ys, List.last_appendR)
List.last_snoc
WithTerm last (?xs @ [?x])
GetFact (last (?xs @ [?x]) = ?x, List.last_snoc)
List.last_conv_nth@sym
WithTerm ?xs ! (length ?xs - 1)
WithGoal ?xs = []
GetFact (?xs ! (length ?xs - 1) = last ?xs, List.last_conv_nth@sym)
List.last_in_set
WithWellForm ?as ~= []
WithTerm last ?as
GetFact (last ?as : set ?as, List.last_in_set)
List.length_butlast
WithTerm butlast ?xs
GetFact (length (butlast ?xs) = length ?xs - 1, List.length_butlast)
List.nth_butlast
WithWellForm ?n < length (butlast ?xs)
WithTerm butlast ?xs ! ?n
GetFact (butlast ?xs ! ?n = ?xs ! ?n, List.nth_butlast)
List.butlast_conv_take@sym
WithTerm take (length ?xs - 1) ?xs
GetFact (take (length ?xs - 1) ?xs = butlast ?xs, List.butlast_conv_take@sym)
List.butlast_snoc
WithTerm butlast (?xs @ [?x])
GetFact (butlast (?xs @ [?x]) = ?xs, List.butlast_snoc)
Lists_Thms.butlast_eval1
WithTerm butlast [?x]
GetFact (butlast [?x] = [], Lists_Thms.butlast_eval1)
Lists_Thms.butlast_eval2
WithTerm butlast [?x, ?y]
GetFact (butlast [?x, ?y] = [?x], Lists_Thms.butlast_eval2)
Lists_Thms.butlast_cons
WithTerm butlast (?a # ?as)
WithGoal ?as = []
GetFact (butlast (?a # ?as) = ?a # butlast ?as, Lists_Thms.butlast_cons)
Lists_Thms.butlast_append'
WithTerm butlast (?as @ ?bs)
WithGoal ?bs = []
GetFact (butlast (?as @ ?bs) = ?as @ butlast ?bs, Lists_Thms.butlast_append')
List.append_butlast_last_id
WithWellForm ?xs ~= []
WithTerm butlast ?xs @ [last ?xs]
GetFact (butlast ?xs @ [last ?xs] = ?xs, List.append_butlast_last_id)
Lists_Thms.set_butlast_is_subset
WithTerm set (butlast ?xs)
GetFact (set (butlast ?xs) <= set ?xs, Lists_Thms.set_butlast_is_subset)
List.length_list_update
WithTerm ?xs[?i := ?x]
GetFact (length (?xs[?i := ?x]) = length ?xs, List.length_list_update)
List.nth_list_update_eq
WithWellForm ?i < length ?xs
WithTerm ?xs[?i := ?x] ! ?i
GetFact (?xs[?i := ?x] ! ?i = ?x, List.nth_list_update_eq)
List.nth_list_update_neq
WithTerm ?xs[?i := ?x] ! ?j
WithGoal ?i = ?j
GetFact (?xs[?i := ?x] ! ?j = ?xs ! ?j, List.nth_list_update_neq)
List.nth_list_update
WithWellForm ?i < length ?xs
WithTerm ?xs[?i := ?x] ! ?j
GetFact (?xs[?i := ?x] ! ?j = (if ?i = ?j then ?x else ?xs ! ?j), List.nth_list_update)
List.take_case
WithTerm take ?n ?xs
CreateConcl ?n <= length ?xs
Lists_Thms.length_take
WithWellForm ?n <= length ?xs
WithTerm take ?n ?xs
GetFact (length (take ?n ?xs) = ?n, Lists_Thms.length_take)
Lists_Thms.nth_take
WithWellForm ?i < length (take ?n ?xs)
WithTerm take ?n ?xs ! ?i
GetFact (take ?n ?xs ! ?i = ?xs ! ?i, Lists_Thms.nth_take)
List.take_0
WithTerm take 0 ?xs
GetFact (take 0 ?xs = [], List.take_0)
List.take_Suc_conv_app_nth
WithTerm take (Suc ?i) ?xs
WithFact ?i < length ?xs
GetFact (take (Suc ?i) ?xs = take ?i ?xs @ [?xs ! ?i], List.take_Suc_conv_app_nth)
Lists_Thms.take_length
WithTerm take (length ?xs) ?xs
GetFact (take (length ?xs) ?xs = ?xs, Lists_Thms.take_length)
List.set_take_subset
WithTerm set (take ?n ?xs)
GetFact (set (take ?n ?xs) <= set ?xs, List.set_take_subset)
Lists_Thms.take_Suc
WithWellForm Suc ?n <= length ?xs
WithTerm take (Suc ?n) ?xs
GetFact (take (Suc ?n) ?xs = take ?n ?xs @ [?xs ! ?n], Lists_Thms.take_Suc)
List.take_update_cancel
WithTerm take ?n (?xs[?m := ?y])
WithFact ?n <= ?m
GetFact (take ?n (?xs[?m := ?y]) = take ?n ?xs, List.take_update_cancel)
List.append_take_drop_id
WithTerm take ?n ?xs @ drop ?n ?xs
GetFact (take ?n ?xs @ drop ?n ?xs = ?xs, List.append_take_drop_id)
List.take_all
WithTerm take ?n ?xs
WithFact length ?xs <= ?n
GetFact (take ?n ?xs = ?xs, List.take_all)
List.length_drop
WithTerm drop ?n ?xs
GetFact (length (drop ?n ?xs) = length ?xs - ?n, List.length_drop)
Lists_Thms.nth_drop
WithWellForm ?i < length (drop ?n ?xs)
WithTerm drop ?n ?xs ! ?i
GetFact (drop ?n ?xs ! ?i = ?xs ! (?n + ?i), Lists_Thms.nth_drop)
List.drop_0
WithTerm drop 0 ?xs
GetFact (drop 0 ?xs = ?xs, List.drop_0)
List.drop_all
WithTerm drop ?n ?xs
WithFact length ?xs <= ?n
GetFact (drop ?n ?xs = [], List.drop_all)
List.take_drop@sym
WithTerm drop ?m (take (?n + ?m) ?xs)
GetFact (drop ?m (take (?n + ?m) ?xs) = take ?n (drop ?m ?xs), List.take_drop@sym)
List.drop_drop
WithTerm drop ?n (drop ?m ?xs)
GetFact (drop ?n (drop ?m ?xs) = drop (?n + ?m) ?xs, List.drop_drop)
List.length_rev
WithTerm rev ?xs
GetFact (length (rev ?xs) = length ?xs, List.length_rev)
List.rev.simps_1
WithTerm rev []
GetFact (rev [] = [], List.rev.simps_1)
List.rev.simps_2
WithTerm rev (?x # ?xs)
GetFact (rev (?x # ?xs) = rev ?xs @ [?x], List.rev.simps_2)
List.rev_append
WithTerm rev (?xs @ ?ys)
GetFact (rev (?xs @ ?ys) = rev ?ys @ rev ?xs, List.rev_append)
List.rev_rev_ident
WithTerm rev (rev ?xs)
GetFact (rev (rev ?xs) = ?xs, List.rev_rev_ident)
List.filter.simps_1
WithTerm filter ?P []
GetFact (filter ?P [] = [], List.filter.simps_1)
List.filter.simps_2
WithTerm filter ?P (?x # ?xs)
GetFact (filter ?P (?x # ?xs) = (if ?P ?x then ?x # filter ?P ?xs else filter ?P ?xs), List.filter.simps_2)
List.filter_append
WithTerm filter ?P (?xs @ ?ys)
GetFact (filter ?P (?xs @ ?ys) = filter ?P ?xs @ filter ?P ?ys, List.filter_append)
List.rev_filter
WithTerm rev (filter ?P ?xs)
GetFact (rev (filter ?P ?xs) = filter ?P (rev ?xs), List.rev_filter)
List.rev_filter@sym
WithTerm filter ?P (rev ?xs)
GetFact (filter ?P (rev ?xs) = rev (filter ?P ?xs), List.rev_filter@sym)
List.concat.simps_1
WithTerm concat []
GetFact (concat [] = [], List.concat.simps_1)
List.concat.simps_2
WithTerm concat (?x # ?xs)
GetFact (concat (?x # ?xs) = ?x @ concat ?xs, List.concat.simps_2)
Multiset.mset.simps_1
WithTerm mset []
GetFact (mset [] = {#}, Multiset.mset.simps_1)
Lists_Thms.mset_simps_2
WithTerm mset (?a # ?x)
GetFact (mset (?a # ?x) = mset ?x + {#?a#}, Lists_Thms.mset_simps_2)
Multiset.mset_append
WithTerm mset (?xs @ ?ys)
GetFact (mset (?xs @ ?ys) = mset ?xs + mset ?ys, Multiset.mset_append)
Multiset.mset_eq_setD
WithTerm set ?xs
WithFact mset ?xs = mset ?ys
GetFact (set ?xs = set ?ys, Multiset.mset_eq_setD)
Multiset.in_multiset_in_set@eqforward
WithTerm set ?xs
WithFact ?x :# mset ?xs
GetFact (?x : set ?xs, Multiset.in_multiset_in_set@eqforward)
Multiset.in_multiset_in_set@invbackward
WithTerm set ?xs
WithGoal ?x :# mset ?xs
GetGoal (?x : set ?xs, Multiset.in_multiset_in_set@invbackward)
Multiset.in_multiset_in_set@sym@eqforward
WithTerm mset ?xs
WithFact ?x : set ?xs
GetFact (?x :# mset ?xs, Multiset.in_multiset_in_set@sym@eqforward)
Multiset.in_multiset_in_set@sym@invbackward
WithTerm mset ?xs
WithGoal ?x : set ?xs
GetGoal (?x :# mset ?xs, Multiset.in_multiset_in_set@sym@invbackward)
Multiset.nth_mem_mset@back
WithGoal ?ls ! ?i :# mset ?ls
GetGoal (?i < length ?ls, Multiset.nth_mem_mset@back)
Lists_Thms.in_mset_conv_nth@res
WithGoal EX i<length ?xs. ?x = ?xs ! i
WithFact ?x :# mset ?xs
GetResolve Lists_Thms.in_mset_conv_nth@res
Lists_Thms.hd_in_mset
WithWellForm ?xs ~= []
WithTerm hd ?xs
WithTerm mset ?xs
GetFact (hd ?xs :# mset ?xs, Lists_Thms.hd_in_mset)
Lists_Thms.last_in_mset
WithWellForm ?xs ~= []
WithTerm last ?xs
WithTerm mset ?xs
GetFact (last ?xs :# mset ?xs, Lists_Thms.last_in_mset)
Lists_Thms.mset_butlast
WithTerm mset (butlast ?xs)
WithGoal ?xs = []
GetFact (mset (butlast ?xs) = mset ?xs - {#last ?xs#}, Lists_Thms.mset_butlast)
Lists_Thms.insert_mset_to_set
WithTerm set ?xs'
WithFact mset ?xs' = mset ?xs + {#?x#}
GetFact (set ?xs' = set ?xs Un {?x}, Lists_Thms.insert_mset_to_set)
Lists_Thms.delete_mset_to_set
WithProperty distinct ?xs
WithTerm set ?xs'
WithFact mset ?xs' = mset ?xs - {#?x#}
GetFact (set ?xs' = set ?xs - {?x}, Lists_Thms.delete_mset_to_set)
Lists_Thms.update_mset_to_set
WithProperty distinct ?xs
WithTerm set ?xs'
WithFact mset ?xs' = {#?y#} + (mset ?xs - {#?x#})
GetFact (set ?xs' = set ?xs - {?x} Un {?y}, Lists_Thms.update_mset_to_set)
Lists_Thms.mset_update'
WithWellForm ?i < length ?ls
WithTerm mset (?ls[?i := ?v])
GetFact (mset (?ls[?i := ?v]) = {#?v#} + (mset ?ls - {#?ls ! ?i#}), Lists_Thms.mset_update')
Multiset.mset_swap
WithWellForm ?i < length ?ls
WithWellForm ?j < length ?ls
WithTerm mset (?ls[?j := ?ls ! ?i, ?i := ?ls ! ?j])
GetFact (mset (?ls[?j := ?ls ! ?i, ?i := ?ls ! ?j]) = mset ?ls, Multiset.mset_swap)
List.set_swap
WithWellForm ?i < length ?xs
WithWellForm ?j < length ?xs
WithTerm set (?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i])
GetFact (set (?xs[?i := ?xs ! ?j, ?j := ?xs ! ?i]) = set ?xs, List.set_swap)
Lists_Thms.upt_zero_length
WithTerm length [0..<?n]
GetFact (length [0..<?n] = ?n, Lists_Thms.upt_zero_length)
Lists_Thms.nth_upt_zero
WithWellForm ?i < length [0..<?n]
WithTerm [0..<?n] ! ?i
GetFact ([0..<?n] ! ?i = ?i, Lists_Thms.nth_upt_zero)
Lists_Thms.list_length
WithTerm list ?s ?n
GetFact (length (list ?s ?n) = ?n, Lists_Thms.list_length)
Lists_Thms.list_nth
WithWellForm ?i < length (list ?s ?n)
WithTerm list ?s ?n ! ?i
GetFact (list ?s ?n ! ?i = ?s ?i, Lists_Thms.list_nth)
List.split_list@res
WithGoal EX ys zs. ?xs = ys @ ?x # zs
WithFact ?x : set ?xs
GetResolve List.split_list@res
List.not_distinct_decomp@back
WithGoal EX xs ys zs y. ?ws = xs @ [y] @ ys @ [y] @ zs
GetFact (distinct ?ws, List.not_distinct_decomp@back)
List.finite_lists_length_le@res
WithProperty finite ?A
WithGoal finite {xs. set xs <= ?A & length xs <= ?n}
GetResolve List.finite_lists_length_le@res
List.distinct_card
WithProperty distinct ?xs
WithTerm card (set ?xs)
GetFact (card (set ?xs) = length ?xs, List.distinct_card)
### theory "Auto2_HOL.Lists_Thms"
### 0.361s elapsed time, 0.361s cpu time, 0.000s GC time
Loading theory "Auto2_HOL.Auto2_Main" (required by "Draft.Partial_Equiv_RelMoreTemplates" via "Draft.Partial_Equiv_Rel")
### theory "Auto2_HOL.Auto2_Main"
### 0.542s elapsed time, 1.308s cpu time, 1.036s GC time
Loading theory "Draft.Partial_Equiv_Rel" (required by "Draft.Partial_Equiv_RelMoreTemplates")
Partial_Equiv_Rel.part_equiv_def@eqforward
WithFact part_equiv ?R
GetFact (sym ?R & trans ?R, Partial_Equiv_Rel.part_equiv_def@eqforward)
Partial_Equiv_Rel.part_equiv_def@invbackward
WithGoal part_equiv ?R
GetGoal (sym ?R & trans ?R, Partial_Equiv_Rel.part_equiv_def@invbackward)
Add property rule for [Relation.sym, Relation.trans]
Add property rule for [Partial_Equiv_Rel.part_equiv]
Add property rule for [Partial_Equiv_Rel.part_equiv]
Delete Partial_Equiv_Rel.part_equiv_def@eqforward
Partial_Equiv_Rel.per_union_def
WithTerm per_union ?R ?a ?b
GetFact (per_union ?R ?a ?b =
?R Un {(x, y). (x, ?a) : ?R & (?b, y) : ?R} Un
{(x, y). (x, ?b) : ?R & (?a, y) : ?R}, Partial_Equiv_Rel.per_union_def)
Partial_Equiv_Rel.per_union_memI1@back
WithGoal (?x, ?y) : per_union ?R ?a ?b
GetGoal ((?x, ?y) : ?R, Partial_Equiv_Rel.per_union_memI1@back)
Partial_Equiv_Rel.per_union_memI1
WithTerm per_union ?R ?a ?b
WithFact (?x, ?y) : ?R
GetFact ((?x, ?y) : per_union ?R ?a ?b, Partial_Equiv_Rel.per_union_memI1)
Partial_Equiv_Rel.per_union_memI2@back
WithGoal (?x, ?y) : per_union ?R ?a ?b
GetGoal ((?x, ?a) : ?R & (?b, ?y) : ?R, Partial_Equiv_Rel.per_union_memI2@back)
Partial_Equiv_Rel.per_union_memI3@back
WithGoal (?x, ?y) : per_union ?R ?a ?b
GetGoal ((?x, ?b) : ?R & (?a, ?y) : ?R, Partial_Equiv_Rel.per_union_memI3@back)
Partial_Equiv_Rel.per_union_memD
WithFact (?x, ?y) : per_union ?R ?a ?b
GetFact ((?x, ?y) : ?R |
(?x, ?a) : ?R & (?b, ?y) : ?R | (?x, ?b) : ?R & (?a, ?y) : ?R, Partial_Equiv_Rel.per_union_memD) + 2 filters
Delete Partial_Equiv_Rel.per_union_def
Add property rule for function Partial_Equiv_Rel.per_union
Add property rule for function Partial_Equiv_Rel.per_union
### theory "Draft.Partial_Equiv_Rel"
### 0.080s elapsed time, 0.080s cpu time, 0.000s GC time
Loading theory "Draft.Partial_Equiv_RelMoreTemplates"
val templateLemmas =
   [("Partial_Equiv_Rel.part_equivD1", "part_equiv ?R ==> sym ?R",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (template_app (template_hole 0, template_var 0)))),
    ("Partial_Equiv_Rel.part_equivD2", "part_equiv ?R ==> trans ?R",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (template_app (template_hole 0, template_var 0)))),
    ("Partial_Equiv_Rel.per_union_is_part_equiv",
     "part_equiv ?R ==> part_equiv (per_union ?R ?a ?b)",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 2))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0))
           ))),
    ("Partial_Equiv_Rel.per_union_is_trans",
     "trans ?R ==> trans (per_union ?R ?a ?b)",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 2))],
       template_predicate
        (
           template_app
            (template_hole 1,
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0))
           ))),
    ("Partial_Equiv_Rel.part_equivI",
     "[| sym ?R; trans ?R |] ==> part_equiv ?R",
     template_implication
      ([template_predicate (template_app (template_hole 2, template_var 0)),
        template_predicate
         (template_app (template_hole 1, template_var 0))],
       template_predicate
        (template_app (template_hole 0, template_var 0)))),
    ("Partial_Equiv_Rel.per_union_memI1",
     "(?x, ?y) : ?R ==> (?x, ?y) : per_union ?R ?a ?b",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 4),
                  template_var 3)),
              template_var 2)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 3)),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0))
           ))),
    ("Partial_Equiv_Rel.per_union_memI2",
     "[| (?x, ?a) : ?R; (?b, ?y) : ?R |] ==> (?x, ?y) : per_union ?R ?a ?b",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 4),
                  template_var 3)),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 1),
                  template_var 0)),
              template_var 2)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 0)),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 3),
               template_var 1))
           ))),
    ("Partial_Equiv_Rel.per_union_memI3",
     "[| (?x, ?b) : ?R; (?a, ?y) : ?R |] ==> (?x, ?y) : per_union ?R ?a ?b",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 4),
                  template_var 3)),
              template_var 2)
            ),
        template_predicate
         (
            template_app
             (template_app
               (template_hole 2,
                template_app
                 (template_app (template_hole 1, template_var 1),
                  template_var 0)),
              template_var 2)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 4),
                 template_var 0)),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 3))
           ))),
    ("Partial_Equiv_Rel.per_union_memD",
     "(?x, ?y) : per_union ?R ?a ?b ==>
      (?x, ?y) : ?R |
      (?x, ?a) : ?R & (?b, ?y) : ?R | (?x, ?b) : ?R & (?a, ?y) : ?R",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_hole 4,
                template_app
                 (template_app (template_hole 3, template_var 4),
                  template_var 3)),
              template_app
               (template_app
                 (template_app (template_hole 2, template_var 2),
                  template_var 1),
                template_var 0))
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app
                  (template_hole 4,
                   template_app
                    (template_app (template_hole 3, template_var 4),
                     template_var 3)),
                 template_var 2)),
             template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app
                    (template_hole 0,
                     template_app
                      (template_app
                        (template_hole 4,
                         template_app
                          (template_app (template_hole 3, template_var 4),
                           template_var 1)),
                       template_var 2)),
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, template_var 0),
                         template_var 3)),
                     template_var 2))),
               template_app
                (template_app
                  (template_hole 0,
                   template_app
                    (template_app
                      (template_hole 4,
                       template_app
                        (template_app (template_hole 3, template_var 4),
                         template_var 0)),
                     template_var 2)),
                 template_app
                  (template_app
                    (template_hole 4,
                     template_app
                      (template_app (template_hole 3, template_var 1),
                       template_var 3)),
                   template_var 2))))
           )))]:
   (string * thm * template) list
### theory "Draft.Partial_Equiv_RelMoreTemplates"
### 0.383s elapsed time, 0.535s cpu time, 0.037s GC time
val it = (): unit
