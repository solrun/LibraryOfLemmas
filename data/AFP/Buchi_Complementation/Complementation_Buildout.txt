Loading theory "Automatic_Refinement.Foldi" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
Loading theory "Automatic_Refinement.Prio_List" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
Loading theory "HOL-Eisbach.Eisbach" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Misc")
Loading theory "Automatic_Refinement.Refine_Util_Bootstrap1" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Refine_Util")
signature PARSE_TOOLS =
  sig
    val is_real_val: ('a, 'b) parse_val -> bool
    val name_term: (term, string) parse_val parser
    val parse_term_val: 'a parser -> (term, 'a) parse_val parser
    val parse_thm_val: 'a parser -> (thm, 'a) parse_val parser
    datatype ('a, 'b) parse_val
    = Parse_Val of 'b * ('a -> unit) | Real_Val of 'a
    val parse_val_cases:
       ('a -> 'b) -> ('b, 'a) parse_val -> 'b * ('b -> unit)
    val the_parse_fun: ('a, 'b) parse_val -> 'a -> unit
    val the_parse_val: ('a, 'b) parse_val -> 'b
    val the_real_val: ('a, 'b) parse_val -> 'a
  end
structure Parse_Tools: PARSE_TOOLS
signature PRIO_LIST =
  sig
    type T
    val add_after: T -> item -> item -> T
    val add_before: T -> item -> item -> T
    val add_first: T -> item -> T
    val add_last: T -> item -> T
    val contains: T -> item -> bool
    val delete: item -> T -> T
    val dest: T -> item list
    val empty: T
    type item
    val merge: T * T -> T
    val merge': T * T -> item list * T
    val prio_of: (item -> bool) -> (item * item -> bool) -> T -> int
  end
functor Prio_List (sig val eq: item * item -> bool type item end): PRIO_LIST
### theory "Automatic_Refinement.Prio_List"
### 0.038s elapsed time, 0.150s cpu time, 0.000s GC time
Loading theory "CAVA_Base.Statistics" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base")
infix 1 ##
signature BASIC_REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
structure Basic_Refine_Util: BASIC_REFINE_UTIL
val map_option = fn: ('a -> 'b) -> 'a option -> 'b option
val split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val map_fold = fn: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
val split_matching = fn:
   ('a -> 'b -> bool) -> 'a list -> 'b list -> ('b list * 'b list) option
val seq_is_empty = fn: 'a Seq.seq -> bool * 'a Seq.seq
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val yield_singleton2 = fn:
   ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
### theory "Automatic_Refinement.Refine_Util_Bootstrap1"
### 0.042s elapsed time, 0.164s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Mk_Term_Antiquot" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Refine_Util")
consts
  foldli :: "'b list => ('a => bool) => ('b => 'a => 'a) => 'a => 'a"
### theory "CAVA_Base.Statistics"
### 0.034s elapsed time, 0.121s cpu time, 0.025s GC time
Loading theory "Automatic_Refinement.Mpat_Antiquot" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Refine_Util")
signature METHOD_CLOSURE =
  sig
    val apply_method:
       Proof.context ->
         string ->
           term list ->
             thm list list ->
               (Proof.context -> Method.method) list ->
                 Proof.context -> thm list -> context_tactic
    val method:
       binding ->
         (binding * typ option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
    val method_cmd:
       binding ->
         (binding * string option * mixfix) list ->
           binding list ->
             binding list ->
               binding list ->
                 Token.src -> local_theory -> string * local_theory
  end
structure Method_Closure: METHOD_CLOSURE
structure Eisbach_Rule_Insts: sig end
val mk_term_antiquot = fn:
   Context.generic * Token.T list ->
     string * (Context.generic * Token.T list)
### theory "Automatic_Refinement.Foldi"
### 0.160s elapsed time, 0.619s cpu time, 0.025s GC time
Loading theory "Collections.ICF_Tools" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetSpec" via "Collections.ICF_Spec_Base" via "Collections.Record_Intf")
### theory "Automatic_Refinement.Mk_Term_Antiquot"
### 0.109s elapsed time, 0.435s cpu time, 0.000s GC time
Loading theory "Draft.Alternate" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Draft.Complementation" via "Draft.Ranking")
val mpat_antiquot = fn:
   Context.generic * Token.T list ->
     string * (Context.generic * Token.T list)
### theory "Automatic_Refinement.Mpat_Antiquot"
### 0.106s elapsed time, 0.426s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Refine_Util" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
consts
  alternate :: "('a => 'a) => ('a => 'a) => nat => 'a => 'a"
### theory "Draft.Alternate"
### 0.054s elapsed time, 0.206s cpu time, 0.032s GC time
Loading theory "Draft.Formula" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final")
infix 0 ##
signature ICF_TOOLS =
  sig
    val changed_conv: conv -> conv
    val chead_of: cterm -> cterm
    val chead_of_thm: thm -> cterm
    val define_simple:
       string -> term -> local_theory -> (term * thm) * local_theory
    val define_simple_global:
       string -> term -> theory -> (term * thm) * theory
    val define_simple_local:
       string -> term -> local_theory -> (term * thm) * local_theory
    val dest_def_eq: term -> term * term
    val dt_head: term -> term
    val dt_lhs: term -> term
    val dt_params: term -> term list
    val dt_rhs: term -> term
    val dthm_head: thm -> term
    val dthm_lhs: thm -> term
    val dthm_params: thm -> term list
    val dthm_rhs: thm -> term
    val gen_variant: (string -> bool) -> string -> string
    val import_cterm: cterm -> Proof.context -> cterm * Proof.context
    val inst_meta_cong: Proof.context -> cterm -> thm
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val norm_def_thm: thm -> thm
    val parse_cpat: cterm context_parser
    val rem_dup_prems: Proof.context -> thm -> thm
    val rename_cterm: cterm * cterm -> ctyp TVars.table * cterm Vars.table
    val renames_cterm: cterm * cterm -> bool
    val repeat_top_sweep_conv:
       (Proof.context -> conv) -> Proof.context -> conv
    val revert_abbrevs: string -> theory -> theory
    val sss_add: thm list -> Proof.context -> Proof.context
    val wrap_lthy_global: (local_theory -> local_theory) -> theory -> theory
    val wrap_lthy_local:
       (local_theory -> local_theory) -> local_theory -> local_theory
    val wrap_lthy_result_global:
       (local_theory -> 'a * local_theory) ->
         (morphism -> 'a -> 'b) -> theory -> 'b * theory
    val wrap_lthy_result_local:
       (local_theory -> 'a * local_theory) ->
         (morphism -> 'a -> 'b) -> local_theory -> 'b * local_theory
  end
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
structure ICF_Tools: ICF_TOOLS
### theory "Collections.ICF_Tools"
### 0.083s elapsed time, 0.317s cpu time, 0.032s GC time
Loading theory "Collections.Ord_Code_Preproc" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetSpec" via "Collections.ICF_Spec_Base" via "Collections.Record_Intf")
### ML warning (line 26 of "$AFP/Collections/ICF/tools/Ord_Code_Preproc.thy"):
### (=) has infix status but was not preceded by op.
### ML warning (line 37 of "$AFP/Collections/ICF/tools/Ord_Code_Preproc.thy"):
### Value identifier (trace_ft) has not been referenced.
### ML warning (line 50 of "$AFP/Collections/ICF/tools/Ord_Code_Preproc.thy"):
### Value identifier (process) has not been referenced.
signature ORD_CODE_PREPROC =
  sig
    val add: int * string * (theory -> thm -> thm) -> theory -> theory
    val get: theory -> (int * string * (theory -> thm -> thm)) list
    val rem: string -> theory -> theory
    val setup: theory -> theory
    val trace_enabled: bool ref
  end
signature OC_SIMPSET =
  sig
    val get: theory -> simpset
    val map: (simpset -> simpset) -> theory -> theory
    val setup: theory -> theory
  end
structure Ord_Code_Preproc: ORD_CODE_PREPROC
functor Oc_Simpset (sig val name: string val prio: int end): OC_SIMPSET
### theory "Collections.Ord_Code_Preproc"
### 0.042s elapsed time, 0.174s cpu time, 0.000s GC time
Loading theory "Collections.Locale_Code" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetSpec" via "Collections.ICF_Spec_Base")
### ML warning (line 170 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 187 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
### ML warning (line 309 of "~~/src/HOL/Eisbach/match_method.ML"):
### Pattern is not exhaustive.
signature MATCH_METHOD =
  sig
    val focus_params: Proof.context -> term list
    val focus_schematics: Proof.context -> Envir.tenv
  end
structure Match_Method: MATCH_METHOD
val method_evaluate = fn: Method.text -> Proof.context -> thm list -> tactic
### ML warning (line 343 of "$AFP/Collections/ICF/tools/Locale_Code.thy"):
### Pattern is not exhaustive.
signature LOCALE_CODE =
  sig
    val add_pat_eq: cterm -> thm list -> theory -> theory
    val close_block: theory -> theory
    val del_pat: cterm -> theory -> theory
    val get_unf_ss: theory -> simpset
    val lc_decl_del: term -> local_theory -> local_theory
    val lc_decl_eq: thm list -> local_theory -> local_theory
    val open_block: theory -> theory
    type pat_eq = cterm * thm list
    val setup: theory -> theory
    val tracing_enabled: bool ref
  end
structure Locale_Code: LOCALE_CODE
### theory "HOL-Eisbach.Eisbach"
### 0.410s elapsed time, 1.592s cpu time, 0.113s GC time
Loading theory "Collections.Record_Intf" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetSpec" via "Collections.ICF_Spec_Base")
### theory "Collections.Locale_Code"
### 0.123s elapsed time, 0.469s cpu time, 0.056s GC time
Loading theory "Finger-Trees.FingerTree" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.FTAnnotatedListImpl")
signature RECORD_INTF =
  sig
    val add_unf_thms: thm list -> Context.generic -> Context.generic
    val add_unf_thms_global: thm list -> theory -> theory
    val get_unf_ss: Context.generic -> simpset
    val get_unf_thms: Context.generic -> thm list
    val icf_locales_tac: Proof.context -> tactic
    val icf_rec_def: thm -> Context.generic -> Context.generic
    val icf_rec_def_attr: attribute context_parser
    val setup: theory -> theory
  end
structure Record_Intf: RECORD_INTF
locale FingerTreeStruc_loc
### theory "Collections.Record_Intf"
### 0.058s elapsed time, 0.267s cpu time, 0.000s GC time
Loading theory "HOL-Library.AList" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Map" via "Collections.Diff_Array" via "Collections.Assoc_List")
consts
  update :: "'key => 'val => ('key * 'val) list => ('key * 'val) list"
### ML warning (line 563 of "$AFP/Automatic_Refinement/Lib/Refine_Util.thy"):
### Handler catches all exceptions.
infix 0 THEN_ELSE'
infix 0 THEN_ELSE_COMB'
infix 1 THEN_ALL_NEW_FWD
infix 1 THEN_INTERVAL
infix 2 ORELSE_INTERVAL
infix 3 ->>
type itactic = int -> int -> tactic
type tactic' = int -> tactic
signature BASIC_REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val ->> :
       'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
         'b context_parser
    val ALL_GOALS_FWD: tactic' -> tactic
    val ALL_GOALS_FWD': tactic' -> tactic'
    val APPEND_LIST': tactic' list -> tactic'
    val CAN': tactic' -> tactic'
    val CASES': (tactic' * tactic) list -> tactic'
    val CONCL_COND': (term -> bool) -> tactic'
    val COND': (term -> bool) -> tactic'
    val IF_EXGOAL: (int -> tactic) -> tactic'
    val INTERVAL_FWD: tactic' -> int -> int -> tactic
    val NTIMES': tactic' -> int -> tactic'
    val ORELSE_INTERVAL: itactic * itactic -> itactic
    val REPEAT': tactic' -> tactic'
    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'
    val REPEAT_DETERM': tactic' -> tactic'
    val RSm: Proof.context -> thm -> thm -> thm
    val SINGLE_INTERVAL: itactic -> tactic'
    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'
    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'
    val THEN_ELSE_COMB':
       tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') ->
         tactic'
    val THEN_INTERVAL: itactic * itactic -> itactic
    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'
    val TRY_SOLVED': tactic' -> tactic'
    val WITH_concl: (term -> tactic') -> tactic'
    val WITH_subgoal: (term -> tactic') -> tactic'
    val elim_all_tac: Proof.context -> thm list -> tactic
    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser
    val eqsubst_inst_tac:
       Proof.context ->
         bool ->
           int list ->
             ((indexname * Position.T) * string) list ->
               thm -> int -> tactic
    val fo_resolve_tac: thm list -> Proof.context -> tactic'
    val fo_rtac: thm -> Proof.context -> tactic'
    val has_Var: term -> bool
    val insert_subgoal_tac: cterm -> tactic'
    val insert_subgoals_tac: cterm list -> tactic'
    val is_Abs: term -> bool
    val is_Comb: term -> bool
    val is_TFree: typ -> bool
    val is_def_thm: thm -> bool
    type itactic = int -> int -> tactic
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val prefer_tac: int -> tactic
    val rprem_tac: int -> Proof.context -> tactic'
    val rprems_tac: Proof.context -> tactic'
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    type tactic' = int -> tactic
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
signature REFINE_UTIL =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val ->> :
       'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
         'b context_parser
    val ALL_GOALS_FWD: tactic' -> tactic
    val ALL_GOALS_FWD': tactic' -> tactic'
    val APPEND_LIST': tactic' list -> tactic'
    val CAN': tactic' -> tactic'
    val CASES': (tactic' * tactic) list -> tactic'
    val CONCL_COND': (term -> bool) -> tactic'
    val COND': (term -> bool) -> tactic'
    val HOL_concl_conv: (Proof.context -> conv) -> Proof.context -> conv
    val IF_EXGOAL: (int -> tactic) -> tactic'
    val INTERVAL_FWD: tactic' -> int -> int -> tactic
    val NTIMES': tactic' -> int -> tactic'
    val OF_fst: thm list -> thm list -> thm
    val ORELSE_INTERVAL: itactic * itactic -> itactic
    val REPEAT': tactic' -> tactic'
    val REPEAT_ALL_NEW_FWD: tactic' -> tactic'
    val REPEAT_DETERM': tactic' -> tactic'
    val RS_fst: thm -> thm list -> thm
    val RSm: Proof.context -> thm -> thm -> thm
    val SINGLE_INTERVAL: itactic -> tactic'
    val THEN_ALL_NEW_FWD: tactic' * tactic' -> tactic'
    val THEN_ELSE': tactic' * (tactic' * tactic') -> tactic'
    val THEN_ELSE_COMB':
       tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') ->
         tactic'
    val THEN_INTERVAL: itactic * itactic -> itactic
    val TRADE: (Proof.context -> tactic') -> Proof.context -> tactic'
    val TRY_SOLVED': tactic' -> tactic'
    val WITH_concl: (term -> tactic') -> tactic'
    val WITH_subgoal: (term -> tactic') -> tactic'
    val abs_def: Proof.context -> thm -> thm
    val anorm_term: term -> term
    val anorm_typ: typ -> typ
    val apply_configs:
       ('a Config.T * 'a) list -> Proof.context -> Proof.context
    val build_res_net: thm list -> (int * thm) Net.net
    val cfg_trace_f_tac_conv: bool Config.T
    val changed_rule: (thm -> thm) -> thm -> thm
    val dest_itselfT: typ -> typ
    val dummify_tvars: term -> term
    val elim_all_tac: Proof.context -> thm list -> tactic
    val eqsubst_inst_meth: (Proof.context -> Proof.method) context_parser
    val eqsubst_inst_tac:
       Proof.context ->
         bool ->
           int list ->
             ((indexname * Position.T) * string) list ->
               thm -> int -> tactic
    val f_tac_conv:
       Proof.context -> (term -> term) -> (Proof.context -> tactic) -> conv
    val fcomb_conv: conv -> conv
    val fix_conv: Proof.context -> conv -> conv
    val fix_left_tuple_from_Ts:
       string -> typ list -> Proof.context -> term * Proof.context
    val fixup_vars: cterm -> thm -> thm
    val fixup_vars_conv: conv -> conv
    val fixup_vars_conv': (Proof.context -> conv) -> Proof.context -> conv
    val fo_matches: theory -> cterm -> term -> bool
    val fo_matchp: theory -> cterm -> term -> term list option
    val fo_resolve_tac: thm list -> Proof.context -> tactic'
    val fo_rtac: thm -> Proof.context -> tactic'
    val fold_binop_left:
       ('a -> 'b * 'a) ->
         ('c -> 'a -> 'b * 'a) ->
           ('b * 'b -> 'b) -> 'c list -> 'a -> 'b * 'a
    val fsub_conv: (Proof.context -> conv) -> Proof.context -> conv
    val ftop_conv: (Proof.context -> conv) -> Proof.context -> conv
    val has_Var: term -> bool
    val import_conv: (Proof.context -> conv) -> Proof.context -> conv
    val import_cterms:
       bool -> cterm list -> Proof.context -> cterm list * Proof.context
    val insert_subgoal_tac: cterm -> tactic'
    val insert_subgoals_tac: cterm list -> tactic'
    val instantiate_tuples:
       Proof.context -> (indexname * typ) list -> thm -> thm
    val instantiate_tuples_from_term_tac: Proof.context -> term -> tactic
    val instantiate_tuples_subgoal_tac: Proof.context -> tactic'
    val is_Abs: term -> bool
    val is_Comb: term -> bool
    val is_TFree: typ -> bool
    val is_def_thm: thm -> bool
    type itactic = int -> int -> tactic
    val ite_conv: conv -> conv -> conv -> conv
    val lambda_tuple: term list -> term -> term
    val list_binop_left: 'a -> ('a * 'a -> 'a) -> 'a list -> 'a
    val list_prodT_left: typ list -> typ
    val map_fold: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val map_option: ('a -> 'b) -> 'a option -> 'b option
    val mk_compN: int -> term -> term -> term
    val mk_compN1: typ list -> int -> term -> term -> term
    val mk_ltuple: term list -> term
    val monitor_conv: string -> conv -> conv
    val monitor_conv':
       string -> (Proof.context -> conv) -> Proof.context -> conv
    val order_by: ('a * 'a -> order) -> ('b -> 'a) -> 'b list -> 'b list
    val parse_bool_config: string -> bool Config.T -> bool context_parser
    val parse_bool_config':
       string ->
         bool Config.T ->
           Token.T list -> (bool Config.T * bool) * Token.T list
    val parse_paren_list: 'a context_parser -> 'a list context_parser
    val parse_paren_list':
       'a parser -> Token.T list -> 'a list * Token.T list
    val parse_paren_lists: 'a context_parser -> 'a list list context_parser
    val pat_conv: cterm -> (Proof.context -> conv) -> Proof.context -> conv
    val pat_conv':
       cterm -> (string -> Proof.context -> conv) -> Proof.context -> conv
    val prefer_tac: int -> tactic
    val repeat_rule: (thm -> thm) -> thm -> thm
    val rprem_tac: int -> Proof.context -> tactic'
    val rprems_tac: Proof.context -> tactic'
    val seq_is_empty: 'a Seq.seq -> bool * 'a Seq.seq
    val shift_lambda_left: thm -> thm
    val shift_lambda_leftN: int -> thm -> thm
    val split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val split_matching:
       ('a -> 'b -> bool) ->
         'a list -> 'b list -> ('b list * 'b list) option
    val strip_prodT_left: typ -> typ list
    val subsume_sort: ('a -> term) -> theory -> 'a list -> 'a list
    val subsume_sort_gen:
       ('a -> term) -> Context.generic -> 'a list -> 'a list
    type tactic' = int -> tactic
    val trace_conv: conv
    val trade_rule:
       (Proof.context -> thm -> thm) -> Proof.context -> thm -> thm
    val try_rule: (thm -> thm) -> thm -> thm
    val yield_singleton2:
       ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
  end
structure Refine_Util: REFINE_UTIL
structure Basic_Refine_Util: BASIC_REFINE_UTIL
val map_option = fn: ('a -> 'b) -> 'a option -> 'b option
val split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val REPEAT_DETERM' = fn: tactic' -> tactic'
val RSm = fn: Proof.context -> thm -> thm -> thm
val NTIMES' = fn: tactic' -> int -> tactic'
val fo_resolve_tac = fn: thm list -> Proof.context -> tactic'
val SINGLE_INTERVAL = fn: itactic -> tactic'
val insert_subgoals_tac = fn: cterm list -> tactic'
val insert_subgoal_tac = fn: cterm -> tactic'
val THEN_ALL_NEW_FWD = fn: tactic' * tactic' -> tactic'
val TRY_SOLVED' = fn: tactic' -> tactic'
val INTERVAL_FWD = fn: tactic' -> int -> int -> tactic
val IF_EXGOAL = fn: (int -> tactic) -> tactic'
val eqsubst_inst_tac = fn:
   Proof.context ->
     bool ->
       int list ->
         ((indexname * Position.T) * string) list -> thm -> int -> tactic
val fo_rtac = fn: thm -> Proof.context -> tactic'
val TRADE = fn: (Proof.context -> tactic') -> Proof.context -> tactic'
val is_TFree = fn: typ -> bool
val ALL_GOALS_FWD = fn: tactic' -> tactic
val yield_singleton2 = fn:
   ('a list -> 'b -> ('c * 'd list) * 'e) -> 'a -> 'b -> ('c * 'd) * 'e
val ## = fn: ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
val CAN' = fn: tactic' -> tactic'
val WITH_concl = fn: (term -> tactic') -> tactic'
val is_Abs = fn: term -> bool
val COND' = fn: (term -> bool) -> tactic'
val split_matching = fn:
   ('a -> 'b -> bool) -> 'a list -> 'b list -> ('b list * 'b list) option
val REPEAT_ALL_NEW_FWD = fn: tactic' -> tactic'
val CASES' = fn: (tactic' * tactic) list -> tactic'
val APPEND_LIST' = fn: tactic' list -> tactic'
val map_fold = fn: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
val is_def_thm = fn: thm -> bool
val THEN_INTERVAL = fn: itactic * itactic -> itactic
val rprems_tac = fn: Proof.context -> tactic'
val WITH_subgoal = fn: (term -> tactic') -> tactic'
val is_Comb = fn: term -> bool
val THEN_ELSE_COMB' = fn:
   tactic' * ((tactic' * tactic' -> tactic') * tactic' * tactic') -> tactic'
val eqsubst_inst_meth = fn: (Proof.context -> Proof.method) context_parser
val elim_all_tac = fn: Proof.context -> thm list -> tactic
val ->> = fn:
   'a context_parser * ('a * Context.generic -> 'b * Context.generic) ->
     'b context_parser
val ALL_GOALS_FWD' = fn: tactic' -> tactic'
val prefer_tac = fn: int -> tactic
val rprem_tac = fn: int -> Proof.context -> tactic'
val has_Var = fn: term -> bool
val REPEAT' = fn: tactic' -> tactic'
val THEN_ELSE' = fn: tactic' * (tactic' * tactic') -> tactic'
val CONCL_COND' = fn: (term -> bool) -> tactic'
val ORELSE_INTERVAL = fn: itactic * itactic -> itactic
val seq_is_empty = fn: 'a Seq.seq -> bool * 'a Seq.seq
### theory "Automatic_Refinement.Refine_Util"
### 0.346s elapsed time, 1.365s cpu time, 0.146s GC time
Loading theory "Automatic_Refinement.Anti_Unification" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
signature ANTI_UNIFICATION =
  sig
    val anti_unify: term * term -> term
    val anti_unifyT: typ * typ -> typ_env -> typ * typ_env
    val anti_unify_env: term * term -> env -> term * env
    val anti_unify_list: term list -> term
    val empty: env
    val empty_term: term_env
    val empty_typ: typ_env
    type env = typ_env * term_env
    val specialize_net_tac: Proof.context -> (int * thm) Net.net -> tactic'
    val specialize_tac: Proof.context -> thm list -> tactic'
    type term_env
    type typ_env
  end
structure Anti_Unification: ANTI_UNIFICATION
### theory "Automatic_Refinement.Anti_Unification"
### 0.061s elapsed time, 0.241s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Attr_Comb" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
infixr 5 THEN_ATTR
infixr 4 ELSE_ATTR
signature ATTR_COMB =
  sig
    exception ATTR_EXC of string
    val CHECK_PREPARE:
       (Context.generic * thm -> bool) -> attribute -> attribute
    val COND_attr: (Context.generic * thm -> bool) -> attribute
    val EFF_ATTR: (Context.generic * thm -> 'a) -> attribute
    val ELSE_ATTR: attribute * attribute -> attribute
    val ID_ATTR: attribute
    val IGNORE_THM: attribute -> attribute
    val ITE_ATTR: attribute -> attribute -> attribute -> attribute
    val ITE_ATTR': attribute -> attribute -> (exn -> attribute) -> attribute
    val NO_ATTR: attribute
    val RPT1_ATTR: attribute -> attribute
    val RPT_ATTR: attribute -> attribute
    val RS_attr: thm -> attribute
    val RSm_attr: thm -> attribute
    val THEN_ATTR: attribute * attribute -> attribute
    val TRACE_ATTR: string -> attribute -> attribute
    val TRY_ATTR: attribute -> attribute
    val WARN_ATTR: Context.generic -> string -> attribute
  end
structure Attr_Comb: ATTR_COMB
### theory "Automatic_Refinement.Attr_Comb"
### 0.065s elapsed time, 0.246s cpu time, 0.064s GC time
Loading theory "Automatic_Refinement.Named_Sorted_Thms" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
consts
  update_with_aux ::
    "'val
     => 'key => ('val => 'val) => ('key * 'val) list => ('key * 'val) list"
signature NAMED_SORTED_THMS =
  sig
    val add: attribute
    val add_thm: thm -> Context.generic -> Context.generic
    val del: attribute
    val del_thm: thm -> Context.generic -> Context.generic
    val get: Proof.context -> thm list
    val member: Proof.context -> thm -> bool
    val setup: theory -> theory
  end
functor Named_Sorted_Thms (
  sig
    val description: string
    val name: binding
    val sort: Context.generic -> thm list -> thm list
    val transform: Context.generic -> thm -> thm list
  end
  ): 
  NAMED_SORTED_THMS
### theory "Automatic_Refinement.Named_Sorted_Thms"
### 0.026s elapsed time, 0.110s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Autoref_Data" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops")
signature AUTOREF_DATA =
  sig
    type T
    exception exCIRCULAR
    exception exNULL
    val get: Proof.context -> T
    val init: Proof.context -> Proof.context
  end
functor Autoref_Data (
  sig
    type T
    val compute: Proof.context -> T
    val prereq: (Proof.context -> Proof.context) list
  end
  ): 
  AUTOREF_DATA
### theory "Automatic_Refinement.Autoref_Data"
### 0.025s elapsed time, 0.097s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Indep_Vars" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
signature INDEP_VARS = sig val indep_tac: Proof.context -> tactic' end
structure Indep_Vars: INDEP_VARS
### theory "Automatic_Refinement.Indep_Vars"
### 0.036s elapsed time, 0.147s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Mk_Record_Simp" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
val mk_record_simp = fn: Context.generic -> thm -> thm
### theory "Automatic_Refinement.Mk_Record_Simp"
### 0.179s elapsed time, 0.559s cpu time, 0.406s GC time
Loading theory "Automatic_Refinement.Tagged_Solver" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
signature TAGGED_SOLVER =
  sig
    val add_triggers:
       string -> thm list -> morphism -> Context.generic -> Context.generic
    val cfg_full: bool Config.T
    val cfg_keep: bool Config.T
    val cfg_step: bool Config.T
    val cfg_trace: bool Config.T
    val declare_solver:
       thm list ->
         binding ->
           string ->
             (Proof.context -> tactic') ->
               morphism -> Context.generic -> Context.generic
    val delete_solver:
       string -> morphism -> Context.generic -> Context.generic
    val get_potential_solvers: Proof.context -> int -> thm -> solver list
    val get_potential_tacs: Proof.context -> int -> thm -> tactic' list
    val get_solvers: Proof.context -> solver list
    val lookup_solver: string -> Context.generic -> solver option
    val pretty_solvers: Proof.context -> Pretty.T
    val solve_full_keep_tac: Proof.context -> tactic'
    val solve_full_step_tac: Proof.context -> tactic'
    val solve_full_tac: Proof.context -> tactic'
    val solve_greedy_keep_tac: Proof.context -> tactic'
    val solve_greedy_step_tac: Proof.context -> tactic'
    val solve_greedy_tac: Proof.context -> tactic'
    val solve_tac: Proof.context -> tactic'
    type solver = thm list * string * string * (Proof.context -> tactic')
    val tac_of_solver: Proof.context -> solver -> tactic'
  end
structure Tagged_Solver: TAGGED_SOLVER
### theory "Automatic_Refinement.Tagged_Solver"
### 0.105s elapsed time, 0.404s cpu time, 0.034s GC time
Loading theory "Automatic_Refinement.Select_Solve" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
signature SELECT_SOLVE =
  sig
    val AS_FIRSTGOAL: tactic -> tactic'
    val IF_SUBGOAL_SOLVED: tactic -> tactic -> tactic -> tactic
    val PREFER_SOLVED: tactic -> tactic
    val REPEAT_SOLVE_FWD_SELECT: Proof.context -> int -> tactic' -> tactic'
    val SELECT_FIRST: Proof.context -> tactic -> tactic
    val TRY_SOLVE_FWD: int -> tactic -> tactic
  end
structure Select_Solve: SELECT_SOLVE
### theory "Automatic_Refinement.Select_Solve"
### 0.062s elapsed time, 0.257s cpu time, 0.000s GC time
Loading theory "HOL-Library.Adhoc_Overloading" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System" via "Transition_Systems_and_Automata.Sequence" via "HOL-Library.Monad_Syntax")
signature ADHOC_OVERLOADING =
  sig
    val generic_add_overloaded: string -> Context.generic -> Context.generic
    val generic_add_variant:
       string -> term -> Context.generic -> Context.generic
    val generic_remove_overloaded:
       string -> Context.generic -> Context.generic
    val generic_remove_variant:
       string -> term -> Context.generic -> Context.generic
    val is_overloaded: Proof.context -> string -> bool
    val show_variants: bool Config.T
  end
structure Adhoc_Overloading: ADHOC_OVERLOADING
### theory "HOL-Library.Adhoc_Overloading"
### 0.116s elapsed time, 0.449s cpu time, 0.067s GC time
Loading theory "HOL-Library.Monad_Syntax" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System" via "Transition_Systems_and_Automata.Sequence")
### theory "HOL-Library.Monad_Syntax"
### 0.045s elapsed time, 0.177s cpu time, 0.000s GC time
Loading theory "HOL-Library.Cancellation" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Misc" via "HOL-Library.Multiset")
consts
  satisfies :: "'a set => 'a formula => bool"
### theory "Draft.Formula"
### 1.093s elapsed time, 4.166s cpu time, 0.685s GC time
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Map" via "Collections.Diff_Array" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
### theory "HOL-Library.Code_Abstract_Nat"
### 0.079s elapsed time, 0.308s cpu time, 0.073s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Map" via "Collections.Diff_Array" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### if ?n = 0 | ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### Suc ?m <= ?n == ?m < ?n
### Code generator: dropping subsumed code equation
### 0 <= ?n == True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n == ?m <= ?n
### Code generator: dropping subsumed code equation
### ?n < 0 == False
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
### Code generator: dropping subsumed code equation
### of_nat ?n == semiring_1_class.of_nat_aux (%i. i + (1::?'a)) ?n (0::?'a)
### theory "HOL-Library.Code_Target_Nat"
### 0.132s elapsed time, 0.528s cpu time, 0.000s GC time
Loading theory "HOL-Library.Code_Target_Int" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Map" via "Collections.Diff_Array" via "HOL-Library.Code_Target_Numeral")
### Code generator: dropping subsumed code equation
### 1 == Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l == ?l
### Code generator: dropping subsumed code equation
### ?k + 0 == ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m == Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m == Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l == - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 == ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) == Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) == Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l == 0
### Code generator: dropping subsumed code equation
### ?k * 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One == - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One == ?k
### Code generator: dropping subsumed code equation
### 0 div ?k == 0
### Code generator: dropping subsumed code equation
### ?k div 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n == - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n ==
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n ==
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n == snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One == 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One == 0
### Code generator: dropping subsumed code equation
### 0 mod ?k == 0
### Code generator: dropping subsumed code equation
### ?k mod 0 == ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k == True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Neg ?l == ?l <= ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Pos ?l == ?k <= ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= 0 == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l == ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l == ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 == False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 < 0 == False
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) == numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 == 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) == - numeral ?k
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) == nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 == 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) == 0
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
Found termination order:
  "(%p. size_list size (snd (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Library.Code_Target_Int"
### 0.169s elapsed time, 0.660s cpu time, 0.070s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Map" via "Collections.Diff_Array")
### theory "HOL-Library.AList"
### 1.233s elapsed time, 4.705s cpu time, 0.713s GC time
Loading theory "Trie.Trie" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.TrieSetImpl" via "Collections.TrieMapImpl" via "Collections.Trie2" via "Collections.Trie_Impl")
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
### theory "HOL-Library.Code_Target_Numeral"
### 0.144s elapsed time, 0.561s cpu time, 0.078s GC time
Loading theory "HOL-Library.Confluence" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.ListSetImpl" via "Collections.Dlist_add" via "HOL-Library.Dlist" via "HOL-Library.Confluent_Quotient")
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.588s elapsed time, 2.314s cpu time, 0.221s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Misc")
### theory "HOL-Library.Confluence"
### 0.077s elapsed time, 0.305s cpu time, 0.000s GC time
Loading theory "HOL-Library.Confluent_Quotient" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.ListSetImpl" via "Collections.Dlist_add" via "HOL-Library.Dlist")
locale wide_intersection_finite
  fixes E :: "'Fa => 'Fa => bool"
    and mapFa :: "('a => 'a) => 'Fa => 'Fa"
    and setFa :: "'Fa => 'a set"
  assumes "wide_intersection_finite E mapFa setFa"
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
locale confluent_quotient
  fixes Rb :: "'Fb => 'Fb => bool"
    and Ea :: "'Fa => 'Fa => bool"
    and Eb :: "'Fb => 'Fb => bool"
    and Ec :: "'Fc => 'Fc => bool"
    and Eab :: "'Fab => 'Fab => bool"
    and Ebc :: "'Fbc => 'Fbc => bool"
    and \<pi>_Faba :: "'Fab => 'Fa"
    and \<pi>_Fabb :: "'Fab => 'Fb"
    and \<pi>_Fbcb :: "'Fbc => 'Fb"
    and \<pi>_Fbcc :: "'Fbc => 'Fc"
    and rel_Fab :: "('a => 'b => bool) => 'Fa => 'Fb => bool"
    and rel_Fbc :: "('b => 'c => bool) => 'Fb => 'Fc => bool"
    and rel_Fac :: "('a => 'c => bool) => 'Fa => 'Fc => bool"
    and set_Fab :: "'Fab => ('a * 'b) set"
    and set_Fbc :: "'Fbc => ('b * 'c) set"
  assumes
    "confluent_quotient Rb Ea Eb Ec Eab Ebc \<pi>_Faba \<pi>_Fabb \<pi>_Fbcb
      \<pi>_Fbcc rel_Fab rel_Fbc rel_Fac set_Fab set_Fbc"
### theory "HOL-Library.Confluent_Quotient"
### 0.157s elapsed time, 0.608s cpu time, 0.121s GC time
Loading theory "HOL-Library.Dlist" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.ListSetImpl" via "Collections.Dlist_add")
locale Quotient_dlist
instantiation
  dlist :: (equal) equal
  equal_dlist == equal_class.equal :: 'a dlist => 'a dlist => bool
Found termination order: "{}"
Proofs for inductive predicate(s) "double"
  Proving monotonicity ...
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "HOL-Library.Dlist"
### 0.789s elapsed time, 2.919s cpu time, 1.086s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
### theory "HOL-Library.Function_Algebras"
### 0.115s elapsed time, 0.451s cpu time, 0.000s GC time
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL" via "HOL-Library.Linear_Temporal_Logic_on_Streams" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity" via "HOL-Library.Countable_Complete_Lattices" via "HOL-Library.Countable_Set")
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
consts
  enumerate :: "'a set => nat => 'a"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
### theory "HOL-Library.Infinite_Set"
### 0.328s elapsed time, 1.297s cpu time, 0.236s GC time
Loading theory "HOL-Library.Omega_Words_Fun" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Automata.Digraph_Basic")
### theory "Trie.Trie"
### 1.976s elapsed time, 7.408s cpu time, 2.546s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
### Ambiguous input (line 137 of "~~/src/HOL/Library/Omega_Words_Fun.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" drop)
###       ("_cargs" ("_position" i)
###         ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###           ("_position" j) ("_position" k))))
###     ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###       ("\<^const>Groups.plus_class.plus" ("_position" j) ("_position" i))
###       ("_position" k))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Omega_Words_Fun.subsequence"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" drop)
###         ("_cargs" ("_position" i)
###           ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###             ("_position" j) ("_position" k))))
###       ("_position" w))
###     ("\<^const>Groups.plus_class.plus" ("_position" j) ("_position" i))
###     ("_position" k)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 156 of "~~/src/HOL/Library/Omega_Words_Fun.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less_eq" ("_position" i)
###       ("_position" j)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###         ("_position" i) ("_applC" ("_position" Suc) ("_position" j)))
###       ("\<^const>List.append"
###         ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###           ("_position" i) ("_position" j))
###         ("_list" ("_applC" ("_position" w) ("_position" j)))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Orderings.ord_class.less_eq" ("_position" i)
###       ("_position" j)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>List.append"
###       ("\<^const>Omega_Words_Fun.subsequence"
###         ("\<^const>HOL.eq"
###           ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###             ("_position" i) ("_applC" ("_position" Suc) ("_position" j)))
###           ("_position" w))
###         ("_position" i) ("_position" j))
###       ("_list" ("_applC" ("_position" w) ("_position" j))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 163 of "~~/src/HOL/Library/Omega_Words_Fun.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" prefix)
###       ("_cargs"
###         ("\<^const>Groups.minus_class.minus" ("_position" j)
###           ("_position" i))
###         ("_applC" ("_position" suffix)
###           ("_cargs" ("_position" i) ("_position" w)))))
###     ("\<^const>Omega_Words_Fun.subsequence" ("_position" w) ("_position" i)
###       ("_position" j))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Omega_Words_Fun.subsequence"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" prefix)
###         ("_cargs"
###           ("\<^const>Groups.minus_class.minus" ("_position" j)
###             ("_position" i))
###           ("_applC" ("_position" suffix)
###             ("_cargs" ("_position" i) ("_position" w)))))
###       ("_position" w))
###     ("_position" i) ("_position" j)))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 199 of "~~/src/HOL/Library/Omega_Words_Fun.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" take)
###       ("_cargs" ("_position" i)
###         ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###           ("_position" j) ("_position" k))))
###     ("\<^const>Omega_Words_Fun.subsequence" ("_position" w) ("_position" j)
###       ("_applC" ("_position" min)
###         ("_cargs"
###           ("\<^const>Groups.plus_class.plus" ("_position" j)
###             ("_position" i))
###           ("_position" k))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Omega_Words_Fun.subsequence"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" take)
###         ("_cargs" ("_position" i)
###           ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###             ("_position" j) ("_position" k))))
###       ("_position" w))
###     ("_position" j)
###     ("_applC" ("_position" min)
###       ("_cargs"
###         ("\<^const>Groups.plus_class.plus" ("_position" j) ("_position" i))
###         ("_position" k)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 202 of "~~/src/HOL/Library/Omega_Words_Fun.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Omega_Words_Fun.subsequence"
###       ("_applC" ("_position" suffix)
###         ("_cargs" ("_position" i) ("_position" w)))
###       ("_position" j) ("_position" k))
###     ("\<^const>Omega_Words_Fun.subsequence" ("_position" w)
###       ("\<^const>Groups.plus_class.plus" ("_position" i) ("_position" j))
###       ("\<^const>Groups.plus_class.plus" ("_position" i) ("_position" k)))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Omega_Words_Fun.subsequence"
###     ("\<^const>HOL.eq"
###       ("\<^const>Omega_Words_Fun.subsequence"
###         ("_applC" ("_position" suffix)
###           ("_cargs" ("_position" i) ("_position" w)))
###         ("_position" j) ("_position" k))
###       ("_position" w))
###     ("\<^const>Groups.plus_class.plus" ("_position" i) ("_position" j))
###     ("\<^const>Groups.plus_class.plus" ("_position" i) ("_position" k))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
consts
  build :: "'a => (nat => 'a) => nat => 'a"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Omega_Words_Fun"
### 0.657s elapsed time, 2.394s cpu time, 1.199s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL" via "HOL-Library.Linear_Temporal_Logic_on_Streams" via "HOL-Library.Extended_Nat" via "HOL-Library.Countable")
consts
  mset :: "'a list => 'a multiset"
### theory "HOL-Library.Nat_Bijection"
### 0.391s elapsed time, 1.533s cpu time, 0.280s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.ExtrEqs")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.458s elapsed time, 1.797s cpu time, 0.284s GC time
Loading theory "HOL-Library.Option_ord" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Misc")
instantiation
  option :: (preorder) preorder
  less_eq_option == less_eq :: 'a option => 'a option => bool
  less_option == less :: 'a option => 'a option => bool
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
instantiation
  option :: (order) order_bot
  bot_option == bot :: 'a option
instantiation
  option :: (order_top) order_top
  top_option == top :: 'a option
instantiation
  option :: (inf) inf
  inf_option == inf :: 'a option => 'a option => 'a option
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
instantiation
  option :: (sup) sup
  sup_option == sup :: 'a option => 'a option => 'a option
locale FingerTreeStruc_loc
consts
  shift :: "'a list => 'a stream => 'a stream"
consts
  gmn :: "('e, 'a) Node => 'a"
instantiation
  option :: (complete_lattice) complete_lattice
  Inf_option == Inf :: 'a option set => 'a option
  Sup_option == Sup :: 'a option set => 'a option
Proofs for coinductive predicate(s) "streamsp"
consts
  gmd :: "('e, 'a) Digit => 'a"
  Proving monotonicity ...
consts
  gmft :: "('e, 'a) FingerTreeStruc => 'a"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
### theory "HOL-Library.Option_ord"
### 0.361s elapsed time, 1.431s cpu time, 0.188s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word" via "HOL-Library.Type_Length" via "HOL-Library.Numeral_Type" via "HOL-Library.Cardinality")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
consts
  is_leveln_digit :: "nat => ('e, 'a) Digit => bool"
consts
  is_leveln_ftree :: "nat => ('e, 'a) FingerTreeStruc => bool"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  is_measured_node :: "('e, 'a) Node => bool"
consts
  is_measured_digit :: "('e, 'a) Digit => bool"
consts
  is_measured_ftree :: "('e, 'a) FingerTreeStruc => bool"
consts
  nodeToList :: "('e, 'a) Node => ('e * 'a) list"
consts
  flat :: "'a list stream => 'a stream"
consts
  digitToList :: "('e, 'a) Digit => ('e * 'a) list"
consts
  toList :: "('e, 'a) FingerTreeStruc => ('e * 'a) list"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.002s elapsed time, 3.962s cpu time, 0.470s GC time
Loading theory "HOL-Library.Product_Lexorder" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Gen_Comp")
instantiation
  prod :: (ord, ord) ord
  less_eq_prod == less_eq :: 'a * 'b => 'a * 'b => bool
  less_prod == less :: 'a * 'b => 'a * 'b => bool
instantiation
  prod :: (linorder, linorder) distrib_lattice
  inf_prod == inf :: 'a * 'b => 'a * 'b => 'a * 'b
  sup_prod == sup :: 'a * 'b => 'a * 'b => 'a * 'b
instantiation
  prod :: (bot, bot) bot
  bot_prod == bot :: 'a * 'b
instantiation
  prod :: (top, top) top
  top_prod == top :: 'a * 'b
### theory "HOL-Library.Product_Lexorder"
### 0.120s elapsed time, 0.468s cpu time, 0.110s GC time
Loading theory "HOL-Library.RBT_Impl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_RBT_Map")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Phantom_Type"
### 0.622s elapsed time, 2.454s cpu time, 0.323s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word" via "HOL-Library.Type_Length" via "HOL-Library.Numeral_Type")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### Additional type variable(s) in locale specification "CARD_1": 'a
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
consts
  toTree :: "('e * 'a) list => ('e, 'a) FingerTreeStruc"
consts
  digitToTree :: "('e, 'a) Digit => ('e, 'a) FingerTreeStruc"
consts
  nodeToDigit :: "('e, 'a) Node => ('e, 'a) Digit"
### Missing patterns in function definition:
### nlistToDigit [] = undefined
### !!v vb va vc vd vf. nlistToDigit (v # vb # va # vc # vd # vf) = undefined
### Additional type variable(s) in locale specification "card2": 'a
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
Found termination order: "{}"
consts
  digitToNlist :: "('e, 'a) Digit => ('e, 'a) Node list"
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
consts
  n_unwrap :: "('e, 'a) Node => 'e * 'a"
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
Found termination order: "size <*mlex*> {}"
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Cardinality"
### 0.853s elapsed time, 3.372s cpu time, 0.397s GC time
Loading theory "HOL-Library.Numeral_Type" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word" via "HOL-Library.Type_Length")
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
consts
  entries :: "('a, 'b) rbt => ('a * 'b) list"
### theory "HOL-Library.Multiset"
### 4.532s elapsed time, 17.509s cpu time, 3.835s GC time
Loading theory "Binomial-Heaps.BinomialHeap" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.BinoPrioImpl")
instantiation
  num1 :: CARD_1
instantiation
  num1 :: {comm_monoid_mult,numeral,comm_ring}
  uminus_num1 == uminus :: num1 => num1
  zero_num1 == zero_class.zero :: num1
  minus_num1 == minus :: num1 => num1 => num1
  plus_num1 == plus :: num1 => num1 => num1
  one_num1 == one_class.one :: num1
  times_num1 == times :: num1 => num1 => num1
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
consts
  lconsNlist ::
    "('e, 'a) Node list
     => ('e, 'a) FingerTreeStruc => ('e, 'a) FingerTreeStruc"
instantiation
  num1 :: linorder
  less_eq_num1 == less_eq :: num1 => num1 => bool
  less_num1 == less :: num1 => num1 => bool
consts
  rconsNlist ::
    "('e, 'a) FingerTreeStruc
     => ('e, 'a) Node list => ('e, 'a) FingerTreeStruc"
locale BinomialHeapStruc_loc
### Missing patterns in function definition:
### nodes [] = undefined
### !!v. nodes [v] = undefined
locale mod_type
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_type n Rep Abs"
locale mod_ring
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_ring n Rep Abs"
instantiation
  bit0 :: (finite) {minus,one,plus,times,uminus,zero}
  bit1 :: (finite) {minus,one,plus,times,uminus,zero}
  zero_bit0 == zero_class.zero :: 'a bit0
  uminus_bit0 == uminus :: 'a bit0 => 'a bit0
  times_bit0 == times :: 'a bit0 => 'a bit0 => 'a bit0
  plus_bit0 == plus :: 'a bit0 => 'a bit0 => 'a bit0
  one_bit0 == one_class.one :: 'a bit0
  minus_bit0 == minus :: 'a bit0 => 'a bit0 => 'a bit0
  zero_bit1 == zero_class.zero :: 'a bit1
  uminus_bit1 == uminus :: 'a bit1 => 'a bit1
  times_bit1 == times :: 'a bit1 => 'a bit1 => 'a bit1
  plus_bit1 == plus :: 'a bit1 => 'a bit1 => 'a bit1
  one_bit1 == one_class.one :: 'a bit1
  minus_bit1 == minus :: 'a bit1 => 'a bit1 => 'a bit1
consts
  rbt_sorted :: "('a, 'b) rbt => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size_list size <*mlex*> {}"
consts
  rbt_lookup :: "('a, 'b) rbt => 'a => 'b option"
instantiation
  bit0 :: (finite) linorder
  bit1 :: (finite) linorder
  less_eq_bit0 == less_eq :: 'a bit0 => 'a bit0 => bool
  less_bit0 == less :: 'a bit0 => 'a bit0 => bool
  less_eq_bit1 == less_eq :: 'a bit1 => 'a bit1 => bool
  less_bit1 == less :: 'a bit1 => 'a bit1 => bool
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  num0 :: equal
  equal_num0 == equal_class.equal :: num0 => num0 => bool
instantiation
  num1 :: equal
  equal_num1 == equal_class.equal :: num1 => num1 => bool
instantiation
  num1 :: enum
  enum_num1 == enum_class.enum :: num1 list
  enum_all_num1 == enum_class.enum_all :: (num1 => bool) => bool
  enum_ex_num1 == enum_class.enum_ex :: (num1 => bool) => bool
instantiation
  num0 :: card_UNIV
  num1 :: card_UNIV
  card_UNIV_num0 == card_UNIV_class.card_UNIV :: (num0, nat) phantom
  finite_UNIV_num0 == finite_UNIV :: (num0, bool) phantom
  card_UNIV_num1 == card_UNIV_class.card_UNIV :: (num1, nat) phantom
  finite_UNIV_num1 == finite_UNIV :: (num1, bool) phantom
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  color_of :: "('a, 'b) rbt => color"
instantiation
  bit0 :: (finite) equal
  bit1 :: (finite) equal
  equal_bit0 == equal_class.equal :: 'a bit0 => 'a bit0 => bool
  equal_bit1 == equal_class.equal :: 'a bit1 => 'a bit1 => bool
consts
  bheight :: "('a, 'b) rbt => nat"
consts
  inv1 :: "('a, 'b) rbt => bool"
instantiation
  bit0 :: (finite) enum
  enum_bit0 == enum_class.enum :: 'a bit0 list
  enum_all_bit0 == enum_class.enum_all :: ('a bit0 => bool) => bool
  enum_ex_bit0 == enum_class.enum_ex :: ('a bit0 => bool) => bool
consts
  inv1l :: "('a, 'b) rbt => bool"
consts
  inv2 :: "('a, 'b) rbt => bool"
instantiation
  bit1 :: (finite) enum
  enum_bit1 == enum_class.enum :: 'a bit1 list
  enum_all_bit1 == enum_class.enum_all :: ('a bit1 => bool) => bool
  enum_ex_bit1 == enum_class.enum_ex :: ('a bit1 => bool) => bool
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
instantiation
  bit0 :: (finite) finite_UNIV
  bit1 :: (finite) finite_UNIV
  finite_UNIV_bit0 == finite_UNIV :: ('a bit0, bool) phantom
  finite_UNIV_bit1 == finite_UNIV :: ('a bit1, bool) phantom
instantiation
  bit0 :: ({card_UNIV,finite}) card_UNIV
  bit1 :: ({card_UNIV,finite}) card_UNIV
  card_UNIV_bit0 == card_UNIV_class.card_UNIV :: ('a bit0, nat) phantom
  card_UNIV_bit1 == card_UNIV_class.card_UNIV :: ('a bit1, nat) phantom
### theory "HOL-Library.Numeral_Type"
### 0.778s elapsed time, 3.094s cpu time, 0.327s GC time
Loading theory "Binomial-Heaps.SkewBinomialHeap" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SkewPrioImpl")
consts
  nlistToList :: "('e, 'a) Node list => ('e * 'a) list"
### Ignoring sort constraints in type variables(s): "'a"
### in type abbreviation "BinomialQueue_inv"
locale SkewBinomialHeapStruc_loc
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
### Missing patterns in function definition:
### !!a b. splitNlist a b [] = undefined
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd (snd p))) <*mlex*> {}"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "{}"
### Ignoring sort constraints in type variables(s): "'a"
### in type abbreviation "SkewBinomialQueue"
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
consts
  gmnl :: "('e, 'a) Node list => 'a"
Found termination order: "{}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order:
  "(%p. size_list size (snd p)) <*mlex*>
   (%p. size_list size (fst p)) <*mlex*> {}"
### Missing patterns in function definition:
### getMinTree [] = undefined
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
consts
  foldl_digit :: "('s => 'e * 'a => 's) => 's => ('e, 'a) Digit => 's"
consts
  foldr_node :: "('e * 'a => 's => 's) => ('e, 'a) Node => 's => 's"
consts
  foldr_digit :: "('e * 'a => 's => 's) => ('e, 'a) Digit => 's => 's"
Found termination order: "size_list size <*mlex*> {}"
consts
  foldl :: "('s => 'e * 'a => 's) => 's => ('e, 'a) FingerTreeStruc => 's"
Found termination order: "size_list size <*mlex*> {}"
consts
  foldr :: "('e * 'a => 's => 's) => ('e, 'a) FingerTreeStruc => 's => 's"
consts
  count_node :: "('e, 'a) Node => nat"
consts
  count_digit :: "('e, 'a) Digit => nat"
consts
  count :: "('e, 'a) FingerTreeStruc => nat"
Found termination order: "{}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
locale BinomialHeap_loc
Found termination order:
  "(%p. size_list size (snd p)) <*mlex*>
   (%p. size_list size (fst p)) <*mlex*> {}"
### theory "Binomial-Heaps.BinomialHeap"
### 2.998s elapsed time, 11.876s cpu time, 1.493s GC time
Loading theory "HOL-ex.Quicksort" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib" via "Automatic_Refinement.Misc")
### Missing patterns in function definition:
### getMinTree [] = undefined
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size_list size <*mlex*> {}"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "length <*mlex*> {}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
### theory "HOL-ex.Quicksort"
### 0.485s elapsed time, 1.907s cpu time, 0.347s GC time
Loading theory "Automatic_Refinement.Misc" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Refine_Lib")
locale FingerTree_loc
### theory "Finger-Trees.FingerTree"
### 9.866s elapsed time, 38.436s cpu time, 6.650s GC time
Loading theory "HOL-Library.Type_Length" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "HOL-Library.Word")
class len0 = type +
  fixes len_of :: "'a itself => nat"
class len = len0 +
  assumes "len_gt_0": "0 < LENGTH('a)"
instantiation
  0 :: len0
  1 :: len0
  len_of_num0 == len_of :: 0 itself => nat
  len_of_num1 == len_of :: 1 itself => nat
instantiation
  bit0 :: (len0) len0
  bit1 :: (len0) len0
  len_of_bit0 == len_of :: 'a bit0 itself => nat
  len_of_bit1 == len_of :: 'a bit1 itself => nat
instantiation
  Enum.finite_1 :: len
  len_of_finite_1 == len_of :: Enum.finite_1 itself => nat
instantiation
  Enum.finite_2 :: len
  len_of_finite_2 == len_of :: Enum.finite_2 itself => nat
instantiation
  Enum.finite_3 :: len
  len_of_finite_3 == len_of :: Enum.finite_3 itself => nat
locale Assoc
  fixes f :: "'a => 'a => 'a"
  assumes "Assoc f"
locale AC
  fixes f :: "'a => 'a => 'a"
  assumes "AC f"
locale su_rel_fun
  fixes F :: "('a * 'b) set"
    and f :: "'a => 'b"
  assumes "su_rel_fun F f"
locale Bootstrapped
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "HOL-Library.Type_Length"
### 0.588s elapsed time, 2.319s cpu time, 0.315s GC time
Loading theory "HOL-Library.Word" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
instantiation
  word :: (len) comm_ring_1
  uminus_word == uminus :: 'a word => 'a word
  one_word == one_class.one :: 'a word
  times_word == times :: 'a word => 'a word => 'a word
  zero_word == zero_class.zero :: 'a word
  minus_word == minus :: 'a word => 'a word => 'a word
  plus_word == plus :: 'a word => 'a word => 'a word
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
signature WORD_LIB =
  sig
    val dest_binT: typ -> int
    val dest_wordT: typ -> int
    val is_wordT: typ -> bool
    val mk_wordT: int -> typ
  end
structure Word_Lib: WORD_LIB
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
instantiation
  word :: (len) equal
  equal_word == equal_class.equal :: 'a word => 'a word => bool
### Ignoring duplicate rewrite rule:
### dom (%x. Some (?f1 x)) == UNIV
consts
  filter_rev_aux :: "'a list => ('a => bool) => 'a list => 'a list"
### Missing patterns in function definition:
### !!a v va. zipf a (v # va) [] = undefined
### !!a v va. zipf a [] (v # va) = undefined
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
instantiation
  word :: (len) linorder
  less_eq_word == less_eq :: 'a word => 'a word => bool
  less_word == less :: 'a word => 'a word => bool
instantiation
  word :: (len) enum
  enum_word == enum_class.enum :: 'a word list
  enum_all_word == enum_class.enum_all :: ('a word => bool) => bool
  enum_ex_word == enum_class.enum_ex :: ('a word => bool) => bool
instantiation
  word :: (len) semiring_modulo
  modulo_word == modulo :: 'a word => 'a word => 'a word
  divide_word == divide :: 'a word => 'a word => 'a word
instantiation
  word :: (len) semiring_bits
  bit_word == bit :: 'a word => nat => bool
instantiation
  word :: (len) ring_bit_operations
  not_word == not :: 'a word => 'a word
  and_word == and :: 'a word => 'a word => 'a word
  or_word == or :: 'a word => 'a word => 'a word
  xor_word == xor :: 'a word => 'a word => 'a word
  mask_word == mask :: nat => 'a word
  set_bit_word == set_bit :: nat => 'a word => 'a word
  unset_bit_word == unset_bit :: nat => 'a word => 'a word
  flip_bit_word == flip_bit :: nat => 'a word => 'a word
  push_bit_word == push_bit :: nat => 'a word => 'a word
  drop_bit_word == drop_bit :: nat => 'a word => 'a word
  take_bit_word == take_bit :: nat => 'a word => 'a word
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  prio :: "('e, 'a) BsSkewBinomialTree => 'a"
### Code generator: dropping subsumed code equation
### quicksort (?x # ?xs) ==
### quicksort (filter (%y. y < ?x) ?xs) @
### [?x] @ quicksort (filter ((<=) ?x) ?xs)
### Code generator: dropping subsumed code equation
### quicksort [] == []
Found termination order: "{}"
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order:
  "(%p. length (snd (snd p))) <*mlex*>
   (%p. length (fst (snd p))) <*mlex*> {}"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. size_list size (snd p)) <*mlex*>
   (%p. size_list size (fst p)) <*mlex*> {}"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### getMinTree [] = undefined
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
Found termination order: "size_list size <*mlex*> {}"
consts
  findMin' :: "('a, 'b) BsSkewElem => 'a * 'b"
Found termination order: "{}"
consts
  the_default :: "'a => 'a option => 'a"
Found termination order: "{}"
Found termination order: "{}"
class unique_euclidean_semiring_numeral =
  unique_euclidean_semiring_with_nat + linordered_semidom +
  fixes divmod :: "num => num => 'a * 'a"
    and divmod_step :: "num => 'a * 'a => 'a * 'a"
  assumes
    "div_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a div b = (0::'a)"
    and "mod_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a mod b = a"
    and
    "div_positive": "!!b a. [| (0::'a) < b; b <= a |] ==> (0::'a) < a div b"
    and "mod_less_eq_dividend": "!!a b. (0::'a) <= a ==> a mod b <= a"
    and "pos_mod_bound": "!!b a. (0::'a) < b ==> a mod b < b"
    and "pos_mod_sign": "!!b a. (0::'a) < b ==> (0::'a) <= a mod b"
    and
    "mod_mult2_eq":
      "!!c a b.
          (0::'a) <= c ==> a mod (b * c) = b * (a div b mod c) + a mod b"
    and
    "div_mult2_eq":
      "!!c a b. (0::'a) <= c ==> a div (b * c) = a div b div c"
  assumes "discrete": "!!a b. (a < b) = (a + (1::'a) <= b)"
  assumes
    "divmod_def":
      "!!m n.
          divmod m n = (numeral m div numeral n, numeral m mod numeral n)"
    and
    "divmod_step_def":
      "!!l qr.
          divmod_step l qr =
          (let (q, r) = qr
           in if numeral l <= r then ((2::'a) * q + (1::'a), r - numeral l)
              else ((2::'a) * q, r))"
Found termination order: "case_sum size (size_list size) <*mlex*> {}"
Found termination order: "{}"
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x.
          [| Complete_Partial_Order.chain (<=) A; x : A |] ==> x <= Sup A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| Complete_Partial_Order.chain (<=) A; !!x. x : A ==> x <= z |]
          ==> Sup A <= z"
### theory "Automatic_Refinement.Misc"
### 4.307s elapsed time, 16.904s cpu time, 2.112s GC time
Loading theory "Automatic_Refinement.Refine_Lib" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops")
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
### No equation for constructor "Inl"
consts
  bs_findMin :: "'c + ('a, 'b) BsSkewElem => 'a * 'b"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
Found termination order: "{}"
consts
  bs_insert ::
    "'e => 'a => unit + ('e, 'a) BsSkewElem => unit + ('e, 'a) BsSkewElem"
### Missing patterns in function definition:
### !!v. bs_deleteMin (Inl v) = undefined
Found termination order: "{}"
consts
  bs_invar :: "unit + ('e, 'a) BsSkewElem => bool"
consts
  bs_to_mset :: "unit + ('e, 'a) BsSkewElem => ('e * 'a) multiset"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
instantiation
  word :: (len) size
  size_word == size :: 'a word => nat
signature COND_REWR_CONV =
  sig
    val cond_rewr_conv:
       (Proof.context -> tactic) -> thm -> Proof.context -> conv
    val cond_rewrs_conv:
       (Proof.context -> tactic) -> thm list -> Proof.context -> conv
  end
structure Cond_Rewr_Conv: COND_REWR_CONV
signature REVERT_ABBREV =
  sig
    val revert_abbrev: string -> theory -> theory
    val revert_abbrev_matching: (string -> bool) -> theory -> theory
  end
structure Revert_Abbrev: REVERT_ABBREV
### theory "Automatic_Refinement.Refine_Lib"
### 1.085s elapsed time, 4.256s cpu time, 0.539s GC time
Loading theory "Automatic_Refinement.Autoref_Phases" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops")
signature AUTOREF_PHASES =
  sig
    val all_phases_tac: Proof.context -> tactic'
    val cfg_debug: bool Config.T
    val cfg_keep_goal: bool Config.T
    val cfg_trace: bool Config.T
    val declare_solver:
       thm list ->
         binding ->
           string ->
             (Proof.context -> tactic') ->
               morphism -> Context.generic -> Context.generic
    val delete_phase:
       string -> morphism -> Context.generic -> Context.generic
    val get_phase: string -> Proof.context -> (string * int * phase) option
    val get_phases: Proof.context -> (string * int * phase) list
    val init_data: Proof.context -> Proof.context
    val init_phase: string * int * phase -> Proof.context -> Proof.context
    val init_phases:
       (string * int * phase) list -> Proof.context -> Proof.context
    type phase =
       {analyze: Proof.context -> int -> int -> thm -> bool,
        init: Proof.context -> Proof.context,
        pretty_failure: Proof.context -> int -> int -> thm -> Pretty.T,
        tac: Proof.context -> int -> int -> tactic}
    val phase_tac: string * int * phase -> Proof.context -> tactic'
    val phase_tacN: string -> Proof.context -> tactic'
    val phases_tac: (string * int * phase) list -> Proof.context -> tactic'
    val phases_tacN: string list -> Proof.context -> tactic'
    val register_phase:
       string ->
         int -> phase -> morphism -> Context.generic -> Context.generic
  end
structure Autoref_Phases: AUTOREF_PHASES
### theory "Automatic_Refinement.Autoref_Phases"
### 0.095s elapsed time, 0.370s cpu time, 0.056s GC time
Loading theory "Automatic_Refinement.Autoref_Tagging" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops")
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Min (\<le>s) (set (?x # ?xs)) == fold signed.min ?xs ?x
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### linorder.Max (\<le>s) (set (?x # ?xs)) == fold signed.max ?xs ?x
structure Autoref_Tag_Defs: NAMED_THMS
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted [?x] == True
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted (?x # ?y # ?zs) == ?x \<le>s ?y & signed.sorted (?y # ?zs)
### Partially applied constant "Word.word_sle" on left hand side of equation, in theorem:
### signed.sorted_list_of_set (set ?xs) == signed.sort (remdups ?xs)
signature AUTOREF_TAGGING =
  sig
    val ABS_beta_conv: Proof.context -> conv
    val is_valid_tagged: term -> bool
    val lambda': string * typ -> term -> term
    val list_APP: term * term list -> term
    val mk_ABS_conv: Proof.context -> conv
    val mk_ANNOT_conv: cterm -> conv
    val mk_APP: term -> term -> term
    val mk_APP_conv: conv
    val mk_OP: term -> term
    val mk_OP_conv: conv
    val mk_rel_ANNOT_conv: Proof.context -> cterm -> conv
    val rhs_conv: (Proof.context -> conv) -> Proof.context -> conv
    val strip_app: term -> term * term list
    val term_of_tagged: term -> term
    val untag_conv: Proof.context -> conv
  end
structure Autoref_Tagging: AUTOREF_TAGGING
### theory "Automatic_Refinement.Autoref_Tagging"
### 0.135s elapsed time, 0.529s cpu time, 0.091s GC time
Loading theory "Automatic_Refinement.Relators" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Parametricity" via "Automatic_Refinement.Param_Tool")
structure Refine_Relators_Thms:
  sig structure rel_comb_def_rules: NAMED_THMS end
structure relator_props: NAMED_THMS
structure solve_relator_props: NAMED_THMS
locale SkewBinomialHeap_loc
### ML warning (line 560 of "$AFP/Automatic_Refinement/Parametricity/Relators.thy"):
### Handler catches all exceptions.
signature RELATORS =
  sig
    val declare_natural_relator:
       string * string -> Context.generic -> Context.generic
    val dest_prodrel: term -> term * term
    val dest_relT: typ -> typ * typ
    val is_prodrel: term -> bool
    val list_prodrel_left: term list -> term
    val list_rel: term list -> term -> term
    val list_relAPP: term list -> term -> term
    val mk_fun_rel: term -> term -> term
    val mk_natural_relator:
       Proof.context -> term list -> string -> term option
    val mk_prodrel: term * term -> term
    val mk_relAPP: term -> term -> term
    val mk_relT: typ * typ -> typ
    val natural_relator_of: Proof.context -> string -> string option
    val rel_absT: term -> typ
    val rel_concT: term -> typ
    val remove_natural_relator: string -> Context.generic -> Context.generic
    val setup: theory -> theory
    val strip_prodrel_left: term -> term list
    val strip_relAPP: term -> term list * term
  end
structure Relators: RELATORS
Found termination order: "{}"
### theory "Binomial-Heaps.SkewBinomialHeap"
### 9.046s elapsed time, 35.584s cpu time, 4.674s GC time
Loading theory "CAVA_Automata.Digraph_Basic" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph")
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 Empty == Branch B Empty ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty ==
### Branch B (Branch B ?va1 ?vb1 ?vc1 ?vd1) ?s1 ?t1 Empty
### Ignoring duplicate rewrite rule:
### balance Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1) ==
### Branch B Empty ?s1 ?t1 (Branch B ?va1 ?vb1 ?vc1 ?vd1)
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
val unat_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?v1 ... ?w1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.unat_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val unat_arith_tacs = fn: Proof.context -> tactic list
val unat_arith_tac = fn: Proof.context -> int -> tactic
val uint_arith_simpset =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms =
           {("Int.Pos",
              Leaf
               [{elhs = "Int.Pos", extra = false, fo = true, lhs =
                 Const ("Int.Pos", "num => int"), name = "Int.Pos_def",
                 perm = false, thm = "Int.Pos == numeral"}]),
             ("Word.Word",
               Leaf
                [{elhs = "Word.Word", extra = false, fo = true, lhs =
                  Const ("Word.Word", "int => ?'a1 word"), name =
                  "Word.Word_eq_word_of_int", perm = false, thm =
                  "Word.Word == word_of_int"}]),
             ("Word.cast",
               Leaf
                [{elhs = "Word.cast", extra = false, fo = true, lhs =
                  Const ("Word.cast", "?'a1 word => ?'b1 word"), name =
                  "??.unknown", perm = false, thm = "Word.cast == ucast"}]),
             ("Word.of_int",
               Leaf
                [{elhs = "Word.of_int", extra = false, fo = true, lhs =
                  Const ("Word.of_int", "int => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_int == word_of_int"}]),
             ("Word.of_nat",
               Leaf
                [{elhs = "Word.of_nat", extra = false, fo = true, lhs =
                  Const ("Word.of_nat", "nat => ?'a1 word"), name =
                  "??.unknown", perm = false, thm =
                  "Word.of_nat == word_of_nat"}]),
             ("Word.the_int",
               Leaf
                [{elhs = "Word.the_int", extra = false, fo = true, lhs =
                  Const ("Word.the_int", "?'a1 word => int"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_int == uint"}]),
             ("Word.the_nat",
               Leaf
                [{elhs = "Word.the_nat", extra = false, fo = true, lhs =
                  Const ("Word.the_nat", "?'a1 word ... nat"), name =
                  "??.unknown", perm = false, thm =
                  "Word.the_nat == unat"}]),
             ("String.Literal'",
               Leaf
                [{elhs = "String.Literal'", extra = false, fo = true, lhs =
                  Const ("String.Literal'", "... ... ..."), name =
                  "String.Literal'_def", perm = false, thm =
                  "String.Literal' ... String.Literal"}]),
             ("Code_Numeral.Pos",
               Leaf
                [{elhs = "Code_Numeral.Pos", extra = false, fo = true, lhs =
                  Const ("Code_Numeral.Pos", "..."), name =
                  "Code_Numeral.Pos_def", perm = false, thm =
                  "... ... ..."}]),
             ("Word.signed_cast",
               Leaf
                [{elhs = "Word.signed_cast", extra = false, fo = true, lhs =
                  Const ("Word.signed_cast", "..."), name = "??.unknown",
                  ...}]),
             ("Word.the_signed_int",
               Leaf
                [{elhs = "...", extra = false, fo = true, lhs =
                  Const ("...", ...), ...}]),
             ("Groups.abs_class.abs",
               Leaf [{elhs = "...", extra = false, fo = true, ...}]),
             ("Groups.one_class.one",
               Leaf [{elhs = ..., extra = false, ...}, ...]),
             ("Groups.sgn_class.sgn", Leaf [...]),
             ("Code_Numeral.negative", ...), ...},
           comb =
           Net {atoms =
                {("Fun.id",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [{elhs = "id ?y", extra = false, fo = true, lhs =
                           Const ("Fun.id", "?'a => ?'a") $
                             Var (("y", 0), "?'a"),
                           name = "Fun.id_apply", perm = false, thm =
                           "id ?y == ?y"}]}),
                  ("HOL.Ex",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "(?'d1 => bool) => bool") $ ..., ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "1",
                                Var ((...), "1 => bool") $ ...),
                            name = "Numeral_Type.ex_1", perm = false, thm =
                            "EX x. ?P1 x == ?P1 1"},
                           {elhs = "Ex ?P1", extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "Product_Type.split_paired_Ex", perm =
                            false, thm =
                            "... x... ... ... == ... a b... ... ..."},
                           {elhs = "EX x y. ?p1 ... ......... ......",
                            extra = false, fo = true, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                            name = "Product_Type.surj_pair", perm = false,
                            thm = "... ... ...... ... ... True"},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                            name = "Set.ex_image_cong_iff_2", perm = false,
                            thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.ex_image_cong_iff_1", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("i", "...", ... $ ...),
                            name = "Numeral_Type.forall_1", perm = false,
                            thm = "... i... ... ... == ?P1 ..."},
                           {elhs = "ALL y. ?x1 ... ... ...", extra = false,
                            fo = true, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("y", "...", ...),
                            name = "Option.not_Some_eq", perm = false, thm =
                            "... ...... ... ... ... ... ..."},
                           {elhs = "All ?P1", extra = false, fo = true,
                            lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "Product_Type.split_paired_All", perm =
                            false, thm = "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a1", ...),
                            name = "Set.all_not_in_conv", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'d1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = true, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Ex1",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "EX! x. x ... ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.Ex1", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.ex1_eq_1", perm = false, thm =
                            "... ...... ... ... True"}]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "... True", extra = false, fo = true,
                               lhs =
                               Const ("...", ...) $ Const ("...", "bool"),
                               name = "HOL.simp_thms_7", ...}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "... ...", extra = false, fo = true,
                                lhs = Const ("...", "bool => bool") $ ...,
                                ...}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = ..., var = ...}),
                                ("HOL.Not", Net {atoms = {}, ...}),
                                ("Finite_Set.finite", ...)},
                              comb =
                              Net {atoms =
                                   {("HOL.eq", Net {atoms = {...}, ...}),
                                     ("Set.Bex", ...), ...},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Product_Type.prod.case_prod",
                                  Net {atoms = {}, ...})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.the_eq_trivial", ...}]}),
                  ("Int.Neg",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "num => int") $ ..., ...}]}),
                  ("Int.dup",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...", extra = false, fo = true, ...}]}),
                  ("Int.nat",
                    Net {atoms =
                         {("Groups.one_class.one", Leaf [...]),
                           ("Groups.zero_class.zero", ...)},
                         comb = Net {atoms = {...}, comb = ..., var = ...},
                         var = Leaf [{elhs = ..., extra = false, ...}]}),
                  ("Map.dom",
                    Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
                         Leaf [...]}),
                  ("Map.ran", Net {atoms = {}, comb = ..., var = ...}),
                  ("Nat.Suc", Net {atoms = {...}, ...}), ("Num.inc", ...),
                  ...},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms =
                                     {("HOL.False",
  Leaf
   [{elhs = "...", extra = false, fo = true, lhs =
     Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                     comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms =
{("HOL.True", Leaf [{elhs = "...", extra = false, fo = true, ...}])}, comb =
Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                               ("Num.num.One",
                                 Net {atoms = {}, comb =
Net {atoms = {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var =
     Leaf [...]},
var = Leaf []}),
                               ("Filter.at_bot",
                                 Net {atoms =
{("Orderings.bot_class.bot", Leaf [...])}, comb = Leaf [], var = Leaf []}),
                               ("Filter.at_top",
                                 Net {atoms =
{("Orderings.bot_class.bot", ...)}, comb = Leaf [...], var = Leaf [...]}),
                               ("List.list.Nil",
                                 Net {atoms = {}, comb = ..., var = ...}),
                               ("Filter.cofinite",
                                 Net {atoms = {...}, ...}),
                               ("Option.option.None", ...), ...},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}}),
                                    ("Int.nat",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {...}, comb = ..., var = ...}}),
                                    ("Map.dom",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {...}, ...}}),
                                    ("Nat.Suc",
Net {atoms = {...}, comb = ..., var = ...}),
                                    ("Set.Pow", Net {atoms = {}, ...}),
                                    ("List.rev", ...), ...},
                                  comb =
                                  Net {atoms =
 {("List.upt",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("List.zip", Net {atoms = {}, comb = ..., var = ...}),
   ("List.drop", Net {atoms = {}, ...}), ("List.take", ...), ...},
 comb =
 Net {atoms =
      {("Fun.fun_upd", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
 var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                    ("Groups.one_class.one",
Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Map.map_of", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, ...})},
 comb =
 Net {atoms =
      {("List.append", Net {atoms = {}, ...}), ("Map.map_add", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?a1 ... ?b1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1 word"),
                                     name = "local.uint_arith_simps_3",
                                     perm = false, thm = "... ... ..."},
                                    {elhs = "... ... ...", extra = false,
                                     fo = true, lhs =
                                     Const ("...", ...) $
 Var ((...), "?'a1") $ ...,
                                     name = "HOL.simp_thms_6", ...}]}}),
                       ("HOL.Let",
                         Net {atoms =
                              {("Groups.one_class.one",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "?'b1 => (?'b1 => ?'a) => ?'a") $ ... $ ..., ...}]}),
                                ("Groups.zero_class.zero",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("Nat.Suc",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                     ("Num.numeral_class.numeral",
 Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("Groups.uminus_class.uminus",
 Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Int.sub",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "num => num => int") $ ... $ ..., ...}]}}),
                       ("Num.pow",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms =
                                   {("Num.num.One",
Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("Num.num.Bit0", ...), ...}, comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("Set.Bex",
                         Net {atoms =
                              {("Orderings.bot_class.bot",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("Orderings.top_class.top",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms =
                                   {("Set.Collect", Net {atoms = {}, ...}),
                                     ("List.list.set", ...), ...},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...},
                                     ...]}}),
                       ("Fun.comp",
                         Net {atoms =
                              {("Fun.id",
                                 Net {atoms = {}, comb = ..., var = ...}),
                                ("Option.option.the",
                                  Net {atoms = {...}, ...}),
                                ("Product_Type.prod.fst", ...), ...},
                              comb =
                              Net {atoms = {("List.list.map", ...), ...},
                                   comb = Net {atoms = {...}, ...}, var =
                                   Leaf [...]},
                              var =
                              Net {atoms = {("Fun.id", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}}),
                       ("GCD.bezw",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {...}, comb = ..., var = ...}}),
                       ("HOL.conj",
                         Net {atoms = {("HOL.True", ...), ...}, comb =
                              Net {atoms = {...}, ...}, var =
                              Net {atoms = {...}, ...}}),
                       ("HOL.disj",
                         Net {atoms = {...}, comb = ..., var = ...}),
                       ("List.nth", Net {atoms = {}, ...}),
                       ("List.upt", ...), ...},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}}),
                            ("Fun.comp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}}),
                            ("Fun.fcomp",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}}),
                            ("List.foldl",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {...}, ...}}}),
                            ("List.foldr",
                              Net {atoms = {}, comb = Leaf [], var =
                                   Net {atoms = {}, comb = ..., var =
  ...}}),
                            ("Nat.compow",
                              Net {atoms =
                                   {("Groups.zero_class.zero", ...)}, comb =
                                   Leaf [...], var = Leaf [...]}),
                            ("Fun.fun_upd",
                              Net {atoms = {}, comb = ..., var = ...}),
                            ("Map.map_add", Net {atoms = {}, ...}),
                            ("Fun.bij_betw", ...), ...},
                          comb =
                          Net {atoms =
                               {("Fun.fun_upd",
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}}),
                                 ("Fun.map_fun",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}}),
                                 ("Map.map_upds",
                                   Net {atoms = {}, comb = Leaf [], var =
  Net {atoms = {}, comb = ..., var = ...}}),
                                 ("BNF_Def.rel_sum",
                                   Net {atoms = {}, comb = Leaf [...], var =
  Net {atoms = {}, ...}}),
                                 ("Fun.override_on",
                                   Net {atoms = {}, comb = ..., var = ...}),
                                 ("Num.num.rec_num", Net {atoms = {}, ...}),
                                 ("Num.num.case_num", ...), ...},
                               comb =
                               Net {atoms =
                                    {("Enum.finite_4.rec_finite_4",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = ..., var = ...}}),
("Enum.finite_4.case_finite_4",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                    comb =
                                    Net {atoms =
   {("Enum.finite_5.rec_finite_5", Net {atoms = {}, comb = ..., var = ...}),
     ("Enum.finite_5.case_finite_5", Net {atoms = {}, ...})},
   comb =
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]},
   var = Leaf []},
                                    var = Leaf []},
                               var = Leaf []},
                          var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [{elhs = "%u. EX x y. u = (x, y) & ?P1 x y", extra = false, fo =
              false, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 => bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", "...", ...))),
              name = "Product_Type.split_eta_SetCompr2", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?P1 x y == %(x, y). ?P1 x y"},
             {elhs = "%u. EX x y. u = (x, y) & ?y (x, y)", extra = false,
              fo = true, lhs =
              Abs ("u", "?'a1 * ?'b1",
                Const ("HOL.Ex", "(?'a1 ... bool) => bool") $
                  Abs ("x", "?'a1",
                    Const ("HOL.Ex", "...") $ Abs ("y", ..., ...))),
              name = "Product_Type.split_eta_SetCompr", perm = false, thm =
              "%u. EX x y. u = (x, y) & ?y (x, y) == ?y"},
             {elhs = "%a. ?y ()", extra = false, fo = true, lhs =
              Abs ("", "unit",
                Var (("y", 0), "unit => ?'a1") $
                  Const ("Product_Type.Unity", "unit")),
              name = "Product_Type.unit_abs_eta_conv", perm = false, thm =
              "%a. ?y () == ?y"},
             {elhs = "%A f. Inf (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 => bool",
                  Const ("Complete_Lattices.Inf_class.Inf", "...") $
                    (Const ("...",
                            "(?'a1 => bool) => ?'a1 set => bool set") $
                      ... $ ...))),
              name = "Complete_Lattices.INF_bool_eq", perm = false, thm =
              "%A f. Inf (f ` A) == Ball"},
             {elhs = "%A f. Sup (f ` A)", extra = false, fo = true, lhs =
              Abs ("A", "?'a1 set",
                Abs ("f", "?'a1 ... bool",
                  Const ("...", ...) $ (... $ ... $ ...))),
              name = "Complete_Lattices.SUP_bool_eq", perm = false, thm =
              "%A f. Sup (f ... A) == Bex"}]}},
     {congs =
      ({((true, "HOL.If"),
          "?b == ?c ==> if ?b then ?x else ?y == if ?c then ?x else ?y"),
         ((true, "Set.Bex"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> EX x:?A. ?P x == EX x:?B. ?Q x"),
         ((true, "Set.Ball"),
           "[| ?A == ?B; !!x. x : ?B =simp=> ?P x == ?Q x |]
            ==> ALL x:?A. ?P x == ALL x:?B. ?Q x"),
         ((true, "Set.image"),
           "[| ?M == ?N; !!x. x : ?N =simp=> ?f x == ?g x |]
            ==> ?f ` ?M == ?g ` ?N"),
         ((true, "HOL.implies"),
           "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
            ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.NO_MATCH"),
           "NO_MATCH ?pat ?val == NO_MATCH ?pat ?val"),
         ((true, "HOL.ASSUMPTION"), "ASSUMPTION ?A == ASSUMPTION ?A"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q ... PROP ?Q' |]
            ==> (PROP ?P ... PROP ?Q) == (PROP ?P' ... PROP ?Q')"),
         ((true, "Nat.nat.case_nat"),
           "?M == ?M' ==>
            case ?M of ... ... ... | ... ... ... ==
            case ?M' of ... ... ... | ... ... ..."),
         ((true, "Num.num.case_num"),
           "?num ... ?num' ==>
            ... ... ... ... ... ... ... ... ...
            ... ... ... ... ... ... ... ..."),
         ((true, "List.successively"),
           "... ...... ... ... ==> ... ... ..."),
         ((true, "List.list.case_list"), "... ... ..."),
         ((true, "String.char.case_char"), "..."),
         ((true, "Sum_Type.sum.case_sum"), "..."),
         ((true, "Nitpick.word.case_word"), ...), ((true, "..."), ...),
         ...},
       [(true, "Power.power_class.power"),
        (true, "Phantom_Type.phantom.case_phantom"),
        (true, "Nitpick.word.case_word"),
        (true, "Nitpick.pair_box.case_pair_box"),
        (true, "Nitpick.fun_box.case_fun_box"),
        (true, "Record.tuple_isomorphism.case_tuple_isomorphism"),
        (true, "Extraction.sumbool.case_sumbool"),
        (true, "Quickcheck_Exhaustive.three_valued.case_three_valued"),
        (true, "Quickcheck_Exhaustive.unknown.case_unknown"),
        (true, "Quickcheck_Narrowing.cfun.case_cfun"),
        (true, "Quickcheck_Narrowing.ffun.case_ffun"),
        (true, "Quickcheck_Narrowing.property.case_property"),
        (true, "Quickcheck_Narrowing.narrowing_cons.case_narrowing_cons"),
        (true, "Quickcheck_Narrowing.narrowing_term.case_narrowing_term"),
        (true, "Quickcheck_Narrowing.narrowing_type.case_narrowing_type"),
        (true, "..."), ...]),
      loop_tacs =
      [("split asm HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn),
       ("split asm Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun",
        fn),
       ("split Rings.zero_neq_one_class.of_bool :: (HOL.bool, _)fun", fn),
       ("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)],
      mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 91198}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 91244}]}),
                  ("HOL.Not",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Orderings.ord_class.less",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Nat.Suc",
                    Net {atoms = {}, comb =
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("Groups.plus_class.plus",
Net {atoms = {}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", ...) $ Abs ("...", "?'a", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 91290}]}),
                  ("Set.Collect",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("...", "(?'a => bool) => ?'a set") $
                               ...,
                             name = "Product_Type.Collect_mem", proc = fn,
                             stamp = Stamp 616364},
                           Proc
                            {lhs = ... $ ..., name = "Set.defined_Collect",
                             proc = fn, stamp = Stamp 299868}]}),
                  ("List.list.set",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs = ... $ ..., name =
                             "List.list_to_set_comprehension", proc = fn,
                             stamp = Stamp 2625594}]}),
                  ("Product_Type.prod.case_prod",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf [Proc {lhs = ..., name = "...", ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("Groups.one_class.one",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[Proc
  {lhs = Const ("...", "?'a => ?'a => bool") $ ... $ ..., name =
   "Groups.reorient_one", proc = fn, stamp = Stamp 171260}]}),
                               ("Groups.zero_class.zero",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [Proc
   {lhs = ... $ ... $ ..., name = "Groups.reorient_zero", proc = fn, stamp =
    Stamp 171216}]})},
                             comb =
                             Net {atoms =
                                  {("Nat.Suc",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("Num.numeral_class.numeral",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}}),
                                    ("Groups.uminus_class.uminus",
Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
     Net {atoms = {}, ...}})},
                                  comb =
                                  Net {atoms =
 {("Groups.plus_class.plus",
    Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
   ("Groups.minus_class.minus", Net {atoms = {}, comb = ..., var = ...}),
   ("Groups.times_class.times", Net {atoms = {}, ...})},
 comb = Leaf [], var = Leaf []},
                                  var = Leaf []},
                             var =
                             Net {atoms = {}, comb =
                                  Net {atoms =
 {("Nat.Suc", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}),
   ("Groups.uminus_class.uminus", Net {atoms = {}, comb = ..., var = ...})},
 comb =
 Net {atoms =
      {("Groups.plus_class.plus", Net {atoms = {}, ...}),
        ("Groups.minus_class.minus", ...), ...},
      comb = Leaf [], var = Leaf []},
 var = Leaf []},
                                  var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "record_eq", proc =
fn, stamp = Stamp 4153886},
                                    Proc
                                     {lhs =
Const ("...", "?'a list => ?'a list => bool") $ ... $ ..., name =
"List.list_neq", proc = fn, stamp = Stamp 2645062},
                                    Proc
                                     {lhs = ... $ ... $ ..., name =
"List.list_eq", proc = fn, stamp = Stamp 2633172},
                                    Proc {lhs = ..., name = "...", ...},
                                    Proc {lhs = ..., ...}, ...]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 91526}]}}),
                       ("Set.Bex",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = ... $ ... $ ..., name = "Set.defined_Bex", proc = fn, stamp =
 Stamp 303020}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []}),
                       ("Set.Ball",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf [Proc {lhs = ..., ...}]}}),
                       ("HOL.NO_MATCH",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [...], var =
                                   Leaf [...]}}),
                       ("Rings.dvd_class.dvd",
                         Net {atoms = {}, comb =
                              Net {atoms = {}, comb = ..., var = ...}, var =
                              Net {atoms = {}, comb = ..., var = ...}}),
                       ("Groups.plus_class.plus",
                         Net {atoms = {}, comb = Leaf [...], var =
                              Net {atoms = {}, ...}}),
                       ("Lattices.inf_class.inf",
                         Net {atoms = {}, comb = ..., var = ...}),
                       ("Lattices.sup_class.sup", Net {atoms = {}, ...}),
                       ("Groups.minus_class.minus", ...), ...},
                     comb =
                     Net {atoms =
                          {("Fun.fun_upd",
                             Net {atoms = {}, comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
      Leaf []},
 var = Leaf []},
                                  var = Leaf []})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var =
           Leaf
            [Proc
              {lhs = Var (("x", 0), "?'a"), name = "record", proc = fn,
               stamp = Stamp 4153844},
             Proc
              {lhs = Var (("x", 0), "?'a"), name = "record_upd", proc = fn,
               stamp = Stamp 4153854},
             Proc
              {lhs = Var (("x", 0), "unit"), name = "Product_Type.unit_eq",
               proc = fn, stamp = Stamp 562196}]},
      solvers =
      ([Solver {id = Stamp 1038750, name = "Rtranclp", solver = fn},
        Solver {id = Stamp 1038748, name = "Tranclp", solver = fn},
        Solver {id = Stamp 1038746, name = "Rtrancl", solver = fn},
        Solver {id = Stamp 1038744, name = "Trancl", solver = fn},
        Solver {id = Stamp 781564, name = "lin_arith", solver = fn},
        Solver {id = Stamp 132670, name = "Transitivity", solver = fn},
        Solver {id = Stamp 102528, name = "ASSUMPTION", solver = fn},
        Solver {id = Stamp 90936, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 90938, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val uint_arith_tacs = fn: Proof.context -> tactic list
val uint_arith_tac = fn: Proof.context -> int -> tactic
locale digraph
  fixes E :: "('v * 'v) set"
Proofs for inductive predicate(s) "path"
  Proving monotonicity ...
consts
  paint :: "color => ('a, 'b) rbt => ('a, 'b) rbt"
### theory "Automatic_Refinement.Relators"
### 0.987s elapsed time, 3.847s cpu time, 0.604s GC time
Loading theory "Automatic_Refinement.Param_Tool" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Parametricity")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
signature PARAMETRICITY =
  sig
    val add_dflt: thm -> Context.generic -> Context.generic
    val add_dflt_attr: attribute
    val adjust_arity: int -> thm -> thm
    val adjust_arity_tac: int -> Proof.context -> tactic'
    val asm_param_tac: Proof.context -> tactic'
    val cfg_single_step: bool Config.T
    val cfg_use_asm: bool Config.T
    val del_dflt: thm -> Context.generic -> Context.generic
    val del_dflt_attr: attribute
    val dest_param_goal: int -> thm -> param_ruleT
    val dest_param_rule: thm -> param_ruleT
    val dest_param_term: term -> param_ruleT
    val fo_rule: thm -> thm
    val get_dflt: Proof.context -> param_net
    val net_add: thm -> param_net -> param_net
    val net_add_int: Context.generic -> thm -> param_net -> param_net
    val net_del: thm -> param_net -> param_net
    val net_del_int: Context.generic -> thm -> param_net -> param_net
    val net_empty: param_net
    val net_tac: param_net -> Proof.context -> tactic'
    type param_net
    type param_ruleT =
       {R: term, arity: int, lhs: term, rhs: term, rhs_head: term}
    val param_rule_tac: Proof.context -> thm -> tactic'
    val param_rules_tac: Proof.context -> thm list -> tactic'
    val prepare_tac: Proof.context -> tactic'
    val safe_fun_relD_tac: Proof.context -> tactic'
    val setup: theory -> theory
    val unlambda_tac: Proof.context -> tactic'
  end
structure Parametricity: PARAMETRICITY
val cnv_relAPP = fn: term -> term
val to_relAPP_conv = fn: Proof.context -> conv
val to_relAPP_attr = fn: attribute
### theory "Automatic_Refinement.Param_Tool"
### 0.183s elapsed time, 0.704s cpu time, 0.159s GC time
Loading theory "Automatic_Refinement.Param_HOL" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops" via "Automatic_Refinement.Parametricity")
### theory "CAVA_Automata.Digraph_Basic"
### 1.831s elapsed time, 6.876s cpu time, 4.387s GC time
Loading theory "Collections.SetIterator" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set" via "Collections.Iterator" via "Collections.It_to_It" via "Collections.Proper_Iterator" via "Collections.SetIteratorOperations")
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
locale set_iterator_genord
  fixes
    iti ::
      "('\<sigma> => bool)
       => ('x => '\<sigma> => '\<sigma>) => '\<sigma> => '\<sigma>"
    and S0 :: "'x set"
    and R :: "'x => 'x => bool"
  assumes "set_iterator_genord iti S0 R"
consts
  is_Inl :: "'a + 'b => bool"
consts
  is_Inr :: "'b + 'a => bool"
locale word_rotate
consts
  list_all2_alt :: "('a => 'b => bool) => 'a list => 'b list => bool"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
signature SMT_WORD =
  sig
    val add_word_shift': term * string -> Context.generic -> Context.generic
  end
structure SMT_Word: SMT_WORD
### theory "HOL-Library.Word"
### 7.558s elapsed time, 29.315s cpu time, 7.293s GC time
Loading theory "Collections.Sorted_List_Operations" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.ListSetImpl_Sorted")
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
consts
  list_all_rec :: "('a => bool) => 'a list => bool"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  list_ex_rec :: "('a => bool) => 'a list => bool"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
### theory "Automatic_Refinement.Param_HOL"
### 1.937s elapsed time, 7.336s cpu time, 4.246s GC time
Loading theory "Automatic_Refinement.Parametricity" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel" via "Automatic_Refinement.Autoref_Id_Ops")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Automatic_Refinement.Parametricity"
### 0.029s elapsed time, 0.113s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Autoref_Id_Ops" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate" via "Automatic_Refinement.Autoref_Fix_Rel")
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Collections.SetIterator"
### 1.129s elapsed time, 4.447s cpu time, 0.416s GC time
Loading theory "Collections.SetIteratorOperations" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set" via "Collections.Iterator" via "Collections.It_to_It" via "Collections.Proper_Iterator")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "Collections.Sorted_List_Operations"
### 0.729s elapsed time, 2.864s cpu time, 0.322s GC time
Loading theory "DFS_Framework.DFS_Framework_Misc" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "DFS_Framework.Reachable_Nodes" via "DFS_Framework.DFS_Framework" via "DFS_Framework.Param_DFS" via "DFS_Framework.DFS_Framework_Refine_Aux")
### theory "DFS_Framework.DFS_Framework_Misc"
### 0.035s elapsed time, 0.143s cpu time, 0.000s GC time
Loading theory "Word_Lib.Bit_Comprehension" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
val limit_depth = fn: int -> term -> term
val depth_of = fn: term -> int
val depth_of_lhs = fn: thm -> int
val depth_of_rhs = fn: thm -> int
val pretty_rewrite = fn: Proof.context -> thm -> thm -> Pretty.T
val index_rewr_thms = fn: thm list -> thm Item_Net.T
val net_rewr_tac = fn:
   thm Item_Net.T -> (term -> term) -> (conv -> 'a -> conv) -> 'a -> tactic'
signature AUTOREF_ID_OPS =
  sig
    val cfg_ss_id_op: bool Config.T
    val cfg_trace_failed_id: bool Config.T
    val cfg_trace_id_tags: bool Config.T
    val cfg_trace_intf_unif: bool Config.T
    val cfg_trace_patterns: bool Config.T
    val cfg_use_id_tags: bool Config.T
    val decl_derived_typing:
       bool -> term -> term -> Context.generic -> Context.generic
    val dest_const_intf: term -> term * term
    val dest_const_intf_thm: thm -> term * term
    val has_typ_thms: Proof.context -> term -> bool
    val id_phase: Autoref_Phases.phase
    val id_tac: Proof.context -> tactic'
    val mk_const_intf: term -> term -> term
    val mk_const_intf_thm: Proof.context -> term -> term -> thm
    val setup: theory -> theory
    val typ_thms_of_seq: Proof.context -> term -> thm Seq.seq
  end
structure Autoref_Id_Ops: AUTOREF_ID_OPS
Found termination order: "{}"
signature AUTOREF_REL_INF =
  sig
    val cfg_sbias: int Config.T
    val roi_phase: Autoref_Phases.phase
    val roi_step_tac: Proof.context -> tactic'
    val roi_tac: Proof.context -> tactic'
    val setup: theory -> theory
  end
structure Autoref_Rel_Inf: AUTOREF_REL_INF
### theory "Automatic_Refinement.Autoref_Id_Ops"
### 0.820s elapsed time, 3.220s cpu time, 0.340s GC time
Loading theory "Automatic_Refinement.Autoref_Fix_Rel" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool" via "Automatic_Refinement.Autoref_Translate")
structure Autoref_Rules: NAMED_THMS
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
### ML warning (line 350 of "$AFP/Automatic_Refinement/Tool/Autoref_Fix_Rel.thy"):
### Value identifier (phi) has not been referenced.
signature AUTOREF_FIX_REL =
  sig
    val add_hom_rule: thm -> Context.generic -> Context.generic
    val add_tyrel_rule: thm -> Context.generic -> Context.generic
    val analyze: Proof.context -> int -> int -> thm -> bool
    val compute_hom_net: thm_pairs -> Proof.context -> hom_net
    type constraint = (term * term) list * (term * term)
    val constraint_of_thm: Proof.context -> thm -> constraint
    val constraints_of_goal: int -> thm -> (term * term) list
    val constraints_of_term: term -> (term * term) list
    val declare_prio:
       string -> term -> prio_relpos -> local_theory -> local_theory
    val del_hom_rule: thm -> Context.generic -> Context.generic
    val del_tyrel_rule: thm -> Context.generic -> Context.generic
    val delete_prio: string -> local_theory -> local_theory
    val get_hom_rules: Proof.context -> thm list
    val get_tyrel_rules: Proof.context -> thm list
    val guess_relators_tac: Proof.context -> itactic
    type hom_net = (int * thm) Net.net
    val insert_CONSTRAINTS_tac: Proof.context -> tactic'
    val insert_tyrel_tac: Proof.context -> int -> int -> tactic'
    val internal_hom_tac: Proof.context -> itactic
    val internal_solve_tac: Proof.context -> itactic
    val internal_spec_tac: Proof.context -> itactic
    val mk_CONSTRAINT: term * term -> term
    val mk_CONSTRAINT_rl: Proof.context -> constraint -> thm
    val phase: Autoref_Phases.phase
    val pretty_constraint: Proof.context -> constraint -> Pretty.T
    val pretty_constraints: Proof.context -> constraint list -> Pretty.T
    val pretty_failure: Proof.context -> int -> int -> thm -> Pretty.T
    val pretty_thm_pair:
       Proof.context -> constraint option * thm -> Pretty.T
    val pretty_thm_pairs: Proof.context -> thm_pairs -> Pretty.T
    val print_prios: Proof.context -> unit
    datatype prio_relpos
    = PR_AFTER of string | PR_BEFORE of string | PR_FIRST | PR_LAST
    val setup: theory -> theory
    val solve_step_tac: Proof.context -> tactic'
    val solve_tyrel_tac: Proof.context -> tactic'
    type thm_pairs = (constraint option * thm) list
    val thm_pairsD_get: Proof.context -> thm_pairs
    val thm_pairsD_init: Proof.context -> Proof.context
    val try_solve_tac: Proof.context -> tactic'
    val tyrel_tac: Proof.context -> itactic
  end
structure Autoref_Fix_Rel: AUTOREF_FIX_REL
### theory "Automatic_Refinement.Autoref_Fix_Rel"
### 0.392s elapsed time, 1.528s cpu time, 0.173s GC time
Loading theory "Automatic_Refinement.Autoref_Translate" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool")
signature AUTOREF_TACTICALS =
  sig
    val COND'': (int -> thm -> bool) -> tactic' -> tactic' -> tactic'
    val IF_SOLVED: tactic' -> tactic' -> tactic' -> tactic'
    val REPEAT_INTERVAL: tactic' -> itactic
    val REPEAT_ON_SUBGOAL: tactic' -> tactic'
    val is_defer_cond: int -> thm -> bool
    val is_prefer_cond: int -> thm -> bool
  end
signature AUTOREF_TRANSLATE =
  sig
    val add_post_rule: thm -> Context.generic -> Context.generic
    val compute_trans_net:
       Autoref_Fix_Rel.thm_pairs -> Proof.context -> trans_net
    val delete_post_rule: thm -> Context.generic -> Context.generic
    val get_post_rules: Proof.context -> thm list
    val setup: theory -> theory
    val side_dbg_tac: Proof.context -> tactic'
    val side_tac: Proof.context -> tactic'
    val trans_analyze: Proof.context -> int -> int -> thm -> bool
    val trans_dbg_step_tac: Proof.context -> tactic'
    type trans_net = (int * thm) Net.net
    val trans_phase: Autoref_Phases.phase
    val trans_pretty_failure: Proof.context -> int -> int -> thm -> Pretty.T
    val trans_step_only_tac: Proof.context -> tactic'
    val trans_step_tac: Proof.context -> tactic'
    val trans_tac: Proof.context -> itactic
  end
structure Autoref_Tacticals: AUTOREF_TACTICALS
structure Autoref_Translate: AUTOREF_TRANSLATE
### theory "Automatic_Refinement.Autoref_Translate"
### 0.142s elapsed time, 0.560s cpu time, 0.049s GC time
Loading theory "Automatic_Refinement.Autoref_Gen_Algo" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool")
structure Autoref_Gen_Algo:
  sig
    val decl_setup: morphism -> Context.generic -> Context.generic
    structure ga_side_thms: NAMED_SORTED_THMS
    val setup: theory -> theory
    val side_ga_op_tac: Proof.context -> int -> tactic
    val side_ga_tac: Proof.context -> int -> tactic
    val transform_ga_rule: Context.generic -> thm -> thm list
  end
### theory "Automatic_Refinement.Autoref_Gen_Algo"
### 0.062s elapsed time, 0.241s cpu time, 0.000s GC time
Loading theory "Automatic_Refinement.Autoref_Relator_Interface" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement" via "Automatic_Refinement.Autoref_Tool")
signature AUTOREF_RELATOR_INTERFACE =
  sig
    val declare_rel_intf: thm -> Context.generic -> Context.generic
    val delete_rel_intf: thm -> Context.generic -> Context.generic
    val get_rel_intfs: Proof.context -> thm list
    val intf_of_rel: Proof.context -> term -> term
    val itype_of_rule: Proof.context -> thm -> (term * term) option
    val list_invented_intf: term -> term list
    val mk_intfAPP: term -> term -> term
    val setup: theory -> theory
    val warn_invented_intf: Proof.context -> term -> unit
  end
structure Autoref_Relator_Interface: AUTOREF_RELATOR_INTERFACE
### theory "Automatic_Refinement.Autoref_Relator_Interface"
### 0.079s elapsed time, 0.308s cpu time, 0.040s GC time
Loading theory "Automatic_Refinement.Autoref_Tool" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement")
Found termination order: "{}"
class bit_comprehension = ring_bit_operations +
  fixes set_bits :: "(nat => bool) => 'a"
  assumes "set_bits_bit_eq": "!!a. set_bits (bit a) = a"
instantiation
  int :: bit_comprehension
  set_bits_int == set_bits :: (nat => bool) => int
instantiation
  word :: (len) bit_comprehension
  set_bits_word == set_bits :: (nat => bool) => 'a word
structure Autoref_Debug:
  sig
    val print_thm_pairs: Proof.context -> unit
    val print_thm_pairs_matching: Proof.context -> cterm -> unit
  end
locale autoref_syn
Proofs for inductive predicate(s) "wf_set_bits_int"
  Proving monotonicity ...
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
### theory "Word_Lib.Bit_Comprehension"
### 1.259s elapsed time, 4.929s cpu time, 0.461s GC time
Loading theory "Word_Lib.More_Divides" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit" via "Word_Lib.More_Word")
### theory "Word_Lib.More_Divides"
### 0.179s elapsed time, 0.696s cpu time, 0.068s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
### theory "Automatic_Refinement.Autoref_Tool"
### 0.695s elapsed time, 2.722s cpu time, 0.321s GC time
Loading theory "Automatic_Refinement.Autoref_Bindings_HOL" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Automatic_Refinement.Automatic_Refinement")
### theory "HOL-Library.Set_Algebras"
### 0.282s elapsed time, 1.083s cpu time, 0.219s GC time
Loading theory "HOL-Library.Signed_Division" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Word_Lib.Signed_Division_Word")
### theory "Collections.SetIteratorOperations"
### 1.874s elapsed time, 7.321s cpu time, 0.842s GC time
Loading theory "Collections.Assoc_List" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Map" via "Collections.Diff_Array")
structure Autoref_Struct_Expand:
  sig
    structure autoref_struct_expand: NAMED_THMS
    val decl_setup: morphism -> Context.generic -> Context.generic
    val expand_tac: Proof.context -> int -> tactic
    val setup: theory -> theory
  end
### Adding overloaded interface type to constant: ?x ::\<^sub>i i_bool
### Adding overloaded interface type to constant: ?x ::\<^sub>i i_bool
### Adding overloaded interface type to constant: ?x ::\<^sub>i i_bool
class signed_division = type +
  fixes signed_divide :: "'a => 'a => 'a"
    and signed_modulo :: "'a => 'a => 'a"
### Adding overloaded interface type to constant: ?x ::\<^sub>i i_bool
instantiation
  int :: signed_division
  signed_divide_int == signed_divide :: int => int => int
  signed_modulo_int == signed_modulo :: int => int => int
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "HOL-Library.Signed_Division"
### 0.153s elapsed time, 0.599s cpu time, 0.074s GC time
Loading theory "Collections.Dlist_add" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.ListSetImpl")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
instantiation
  assoc_list :: (equal, equal) equal
  equal_assoc_list == equal_class.equal ::
    ('a, 'b) assoc_list => ('a, 'b) assoc_list => bool
consts
  dlist_remove1' :: "'a => 'a list => 'a list => 'a list"
instantiation
  assoc_list :: (type, type) size
  size_assoc_list == size :: ('a, 'b) assoc_list => nat
consts
  map_ran ::
    "('key => 'val => 'val') => ('key * 'val) list => ('key * 'val') list"
### theory "Collections.Dlist_add"
### 0.264s elapsed time, 1.040s cpu time, 0.075s GC time
Loading theory "Collections.Proper_Iterator" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set" via "Collections.Iterator" via "Collections.It_to_It")
### theory "Collections.Assoc_List"
### 0.458s elapsed time, 1.792s cpu time, 0.218s GC time
Loading theory "Collections.Diff_Array" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Map")
### Cannot skip proof of schematic goal statement
structure Icf_Proper_Iterator:
  sig
    val add: attribute
    val add_thm: thm -> Context.generic -> Context.generic
    val del: attribute
    val del_thm: thm -> Context.generic -> Context.generic
    val get: Proof.context -> thm list
    structure icf_proper_iteratorI: NAMED_THMS
    val setup: theory -> theory
  end
### Cannot skip proof of schematic goal statement
### theory "Collections.Proper_Iterator"
### 0.481s elapsed time, 1.874s cpu time, 0.229s GC time
Loading theory "Collections.Trie_Impl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.TrieSetImpl" via "Collections.TrieMapImpl" via "Collections.Trie2")
### Cannot skip proof of schematic goal statement
consts
  array_length :: "'a array => nat"
consts
  array_get :: "'a array => nat => 'a"
consts
  array_set :: "'a array => nat => 'a => 'a array"
consts
  array_grow :: "'a array => nat => 'a => 'a array"
consts
  array_shrink :: "'a array => nat => 'a array"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
consts
  list_of_array :: "'a array => 'a list"
consts
  assoc_list_of_array :: "'a array => (nat * 'a) list"
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### Rewrite rule not in simpset:
### Wellfounded.accp assoc_list_of_array_code_rel (?a1, ?n1) ==>
### assoc_list_of_array_code ?a1 ?n1 ==
### if array_length ?a1 <= ?n1 then []
### else (?n1, array_get ?a1 ?n1) # assoc_list_of_array_code ?a1 (?n1 + 1)
### theory "Collections.Trie_Impl"
### 0.465s elapsed time, 1.824s cpu time, 0.232s GC time
Loading theory "Collections.Trie2" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.TrieSetImpl" via "Collections.TrieMapImpl")
### Cannot skip proof of schematic goal statement
instantiation
  trie :: (equal, equal) equal
  equal_trie == equal_class.equal :: ('a, 'b) trie => ('a, 'b) trie => bool
### theory "Collections.Trie2"
### 0.152s elapsed time, 0.598s cpu time, 0.064s GC time
Loading theory "Collections.It_to_It" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set" via "Collections.Iterator")
locale proper_it_loc
  fixes
    it ::
      "'s => ('x list => bool)
             => ('x => 'x list => 'x list) => 'x list => 'x list"
    and
    it' ::
      "'s => ('\<sigma> => bool)
             => ('x => '\<sigma> => '\<sigma>) => '\<sigma> => '\<sigma>"
  assumes "proper_it_loc it it'"
### Cannot skip proof of schematic goal statement
### theory "Collections.It_to_It"
### 0.116s elapsed time, 0.452s cpu time, 0.048s GC time
Loading theory "Collections.SetIteratorGA" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set" via "Collections.Iterator")
### theory "Collections.Diff_Array"
### 1.296s elapsed time, 5.073s cpu time, 0.561s GC time
Loading theory "Word_Lib.Signed_Division_Word" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
### Cannot skip proof of schematic goal statement
### Adding overloaded interface type to constant: ?a ::\<^sub>i i_of_rel Id
### Cannot skip proof of schematic goal statement
instantiation
  word :: (len) signed_division
  signed_divide_word == signed_divide :: 'a word => 'a word => 'a word
  signed_modulo_word == signed_modulo :: 'a word => 'a word => 'a word
### Cannot skip proof of schematic goal statement
### theory "Word_Lib.Signed_Division_Word"
### 0.474s elapsed time, 1.851s cpu time, 0.193s GC time
Loading theory "HOL-Library.Sublist" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL" via "HOL-Library.Linear_Temporal_Logic_on_Streams")
### Cannot skip proof of schematic goal statement
### theory "Collections.SetIteratorGA"
### 0.706s elapsed time, 2.751s cpu time, 0.301s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
consts
  prefixes :: "'a list => 'a list list"
### theory "Automatic_Refinement.Autoref_Bindings_HOL"
### 2.702s elapsed time, 10.545s cpu time, 1.255s GC time
Loading theory "Automatic_Refinement.Automatic_Refinement" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine")
### theory "Automatic_Refinement.Automatic_Refinement"
### 0.041s elapsed time, 0.163s cpu time, 0.000s GC time
Loading theory "Collections.Intf_Comp" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Map")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  suffixes :: "'a list => 'a list list"
locale linorder_on
  fixes D :: "'a set"
    and cmp :: "'a => 'a => comp_res"
  assumes "linorder_on D cmp"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "list_emb"
  Proving monotonicity ...
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. length (snd (snd p))) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  cmp_lex' :: "('a => 'b => comp_res) => 'a list => 'b list => comp_res"
Found termination order: "size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "size <*mlex*> {}"
locale eq_linorder_on
  fixes D :: "'a set"
    and cmp :: "'a => 'a => comp_res"
  assumes "eq_linorder_on D cmp"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  sublists :: "'a list => 'a list list"
Found termination order:
  "case_sum (%p. size (fst (snd p)))
    (case_sum (%p. size (snd (snd (snd (snd p)))))
      (%p. size (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%x. 0) (case_sum (%x. Suc 0) (%x. 0)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Collections.Intf_Comp"
### 1.387s elapsed time, 5.355s cpu time, 0.809s GC time
Loading theory "Collections.Idx_Iterator" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set" via "Collections.Iterator")
### theory "HOL-Library.Sublist"
### 1.839s elapsed time, 7.117s cpu time, 1.018s GC time
Loading theory "Collections.Gen_Comp" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF")
### theory "Collections.Gen_Comp"
### 0.240s elapsed time, 0.913s cpu time, 0.123s GC time
Loading theory "HOL-Library.While_Combinator" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While" via "Refine_Monadic.RefineG_While")
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
### theory "Collections.Idx_Iterator"
### 1.840s elapsed time, 6.847s cpu time, 5.308s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL" via "HOL-Library.Linear_Temporal_Logic_on_Streams" via "HOL-Library.Extended_Nat")
Found termination order: "{}"
### theory "HOL-Library.Tree"
### 3.654s elapsed time, 13.867s cpu time, 6.275s GC time
Loading theory "Draft.Templates" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.ExtrEqs")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Found termination order: "{}"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.084s elapsed time, 0.326s cpu time, 0.067s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
### theory "HOL-Library.While_Combinator"
### 1.856s elapsed time, 6.930s cpu time, 5.290s GC time
Loading theory "Collections.DatRef" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections")
### Additional type variable(s) in locale specification "countable": 'a
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
locale while_algo
  fixes WA :: "'S while_algo"
  assumes "while_algo WA"
locale wa_refine
  fixes WAC :: "'C while_algo"
    and WAA :: "'A while_algo"
    and \<alpha> :: "'C => 'A"
  assumes "wa_refine WAC WAA \<alpha>"
locale wa_precise_refine
  fixes WAC :: "'C while_algo"
    and WAA :: "'A while_algo"
    and \<alpha> :: "'C => 'A"
  assumes "wa_precise_refine WAC WAA \<alpha>"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
consts
  rbt_map_entry :: "'a => ('b => 'b) => ('a, 'b) rbt => ('a, 'b) rbt"
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
consts
  map :: "('a => 'b => 'c) => ('a, 'b) rbt => ('a, 'c) rbt"
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
locale det_while_algo
  fixes WA :: "'S det_while_algo"
  assumes "det_while_algo WA"
### theory "Collections.DatRef"
### 0.740s elapsed time, 2.902s cpu time, 0.399s GC time
Loading theory "Native_Word.Code_Int_Integer_Conversion" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
### theory "Native_Word.Code_Int_Integer_Conversion"
### 0.034s elapsed time, 0.140s cpu time, 0.000s GC time
Loading theory "Refine_Monadic.Refine_Chapter" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Refine_Monadic.Refine_Monadic")
### theory "HOL-Library.BigO"
### 0.910s elapsed time, 3.562s cpu time, 0.437s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Complementation_BuildMoreTemplates")
### theory "Refine_Monadic.Refine_Chapter"
### 0.027s elapsed time, 0.099s cpu time, 0.000s GC time
Loading theory "Refine_Monadic.Refine_Mono_Prover" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While" via "Refine_Monadic.Refine_Basic" via "Refine_Monadic.Refine_Misc")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
signature REFINE_MONO_PROVER =
  sig
    val add_mono_thm: thm -> Context.generic -> Context.generic
    val decl_setup: morphism -> Context.generic -> Context.generic
    val declare_mono_triggers:
       thm list -> morphism -> Context.generic -> Context.generic
    val del_mono_thm: thm -> Context.generic -> Context.generic
    val gen_split_cases_tac: pat_extractor -> Proof.context -> tactic'
    val get_mono_thms: Proof.context -> thm list
    val mono_tac: Proof.context -> tactic'
    type pat_extractor =
       term ->
         (term * ((Proof.context -> conv) -> Proof.context -> conv)) option
    val setup: theory -> theory
    val split_cases_tac: Proof.context -> tactic'
    val untriggered_mono_tac: Proof.context -> tactic'
  end
structure Refine_Mono_Prover: REFINE_MONO_PROVER
locale mono_setup_loc
  fixes le :: "'a => 'a => bool"
  assumes "mono_setup_loc le"
### theory "Refine_Monadic.Refine_Mono_Prover"
### 0.121s elapsed time, 0.470s cpu time, 0.074s GC time
Loading theory "Refine_Monadic.Refine_Misc" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While" via "Refine_Monadic.Refine_Basic")
### theory "HOL-Library.Countable"
### 1.298s elapsed time, 5.079s cpu time, 0.643s GC time
Loading theory "HOL-Library.Countable_Set" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL" via "HOL-Library.Linear_Temporal_Logic_on_Streams" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity" via "HOL-Library.Countable_Complete_Lattices")
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
locale galois_connection
  fixes \<alpha> :: "'a => 'b"
    and \<gamma> :: "'b => 'a"
  assumes "galois_connection \<alpha> \<gamma>"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
### theory "HOL-Library.Countable_Set"
### 0.500s elapsed time, 1.956s cpu time, 0.272s GC time
Loading theory "HOL-Library.Countable_Complete_Lattices" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL" via "HOL-Library.Linear_Temporal_Logic_on_Streams" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.752s elapsed time, 2.929s cpu time, 0.411s GC time
Loading theory "Transition_Systems_and_Automata.Basic" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System" via "Transition_Systems_and_Automata.Sequence")
### Ignoring duplicate rewrite rule:
### map_to_set Map.empty == {}
### theory "Refine_Monadic.Refine_Misc"
### 0.656s elapsed time, 2.557s cpu time, 0.337s GC time
Loading theory "Refine_Monadic.RefineG_Domain" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While" via "Refine_Monadic.Refine_Basic" via "Refine_Monadic.RefineG_Recursion")
### theory "Transition_Systems_and_Automata.Basic"
### 0.044s elapsed time, 0.177s cpu time, 0.000s GC time
Loading theory "Refine_Monadic.RefineG_Transfer" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While" via "Refine_Monadic.Refine_Basic" via "Refine_Monadic.RefineG_Recursion")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
structure RefineG_Transfer:
  sig
    structure Post_Processors: THEORY_DATA
    structure Post_Simp: GENERIC_DATA
    val add_post_processor:
       Symtab.key -> (Proof.context -> tactic') -> theory -> theory
    val add_post_simps: thm list -> Context.generic -> Context.generic
    val align_tac: Proof.context -> tactic'
    val del_post_simps: thm list -> Context.generic -> Context.generic
    val delete_post_processor: Symtab.key -> theory -> theory
    val get_post_processors:
       theory -> (Symtab.key * (Proof.context -> tactic')) list
    val get_post_simp_rules: Context.generic -> thm list
    val get_post_ss: Proof.context -> Proof.context
    val post_process_tac: Proof.context -> tactic'
    val post_simps_op:
       (Proof.context * 'a -> Proof.context) ->
         'a -> Context.generic -> Context.generic
    structure post_subst: NAMED_THMS
    val post_subst_tac: Proof.context -> int -> tactic
    val post_transfer_tac: thm list -> Proof.context -> int -> tactic
    val setup: theory -> theory
    structure transfer: NAMED_THMS
    val transfer_tac: thm list -> Proof.context -> int -> thm -> thm Seq.seq
  end
locale transfer
  fixes \<alpha> :: "'c => 'a"
locale ordered_transfer
  fixes \<alpha> :: "'c => 'a"
locale dist_transfer
  fixes \<alpha> :: "'c => 'a"
  assumes "dist_transfer \<alpha>"
locale ccpo_transfer
  fixes \<alpha> :: "'c => 'a"
locale dist_ccpo_transfer
  fixes \<alpha> :: "'c => 'a"
  assumes "dist_ccpo_transfer \<alpha>"
### theory "Refine_Monadic.RefineG_Transfer"
### 0.198s elapsed time, 0.774s cpu time, 0.113s GC time
Loading theory "Refine_Monadic.RefineG_Assert" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While" via "Refine_Monadic.Refine_Basic")
locale generic_Assert
  fixes bind :: "'mu => (unit => 'ma) => 'ma"
    and return :: "unit => 'mu"
    and ASSERT :: "bool => 'mu"
    and ASSUME :: "bool => 'mu"
  assumes "generic_Assert bind return ASSERT ASSUME"
locale transfer_generic_Assert
  fixes cbind :: "'muc => (unit => 'mac) => 'mac"
    and creturn :: "unit => 'muc"
    and cASSERT :: "bool => 'muc"
    and cASSUME :: "bool => 'muc"
    and abind :: "'mua => (unit => 'maa) => 'maa"
    and areturn :: "unit => 'mua"
    and aASSERT :: "bool => 'mua"
    and aASSUME :: "bool => 'mua"
    and \<alpha> :: "'mac => 'maa"
  assumes
    "transfer_generic_Assert cbind creturn cASSERT cASSUME abind areturn
      aASSERT aASSUME"
locale transfer_generic_Assert_remove
  fixes abind :: "'mua => (unit => 'maa) => 'maa"
    and areturn :: "unit => 'mua"
    and aASSERT :: "bool => 'mua"
    and aASSUME :: "bool => 'mua"
    and \<alpha> :: "'mac => 'maa"
  assumes "transfer_generic_Assert_remove abind areturn aASSERT aASSUME"
### theory "Refine_Monadic.RefineG_Assert"
### 0.163s elapsed time, 0.633s cpu time, 0.113s GC time
Loading theory "Transition_Systems_and_Automata.Sequence" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System")
class countable_complete_lattice = Inf + Sup + lattice + bot + top +
  assumes "ccInf_lower": "!!A x. [| countable A; x : A |] ==> Inf A <= x"
  assumes
    "ccInf_greatest":
      "!!A z. [| countable A; !!x. x : A ==> z <= x |] ==> z <= Inf A"
  assumes "ccSup_upper": "!!A x. [| countable A; x : A |] ==> x <= Sup A"
  assumes
    "ccSup_least":
      "!!A z. [| countable A; !!x. x : A ==> x <= z |] ==> Sup A <= z"
  assumes "ccInf_empty": "Inf {} = top"
  assumes "ccSup_empty": "Sup {} = bot"
### theory "Refine_Monadic.RefineG_Domain"
### 0.706s elapsed time, 2.744s cpu time, 0.395s GC time
Loading theory "Refine_Monadic.RefineG_Recursion" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While" via "Refine_Monadic.Refine_Basic")
### Ignoring duplicate rewrite rule:
### flat_ord ?b1 ?b1 ?x1 == True
consts
  scan :: "('a => 'b => 'b) => 'a list => 'b => 'b list"
consts
  sscan :: "('a => 'b => 'b) => 'a stream => 'b => 'b stream"
### theory "Refine_Monadic.RefineG_Recursion"
### 0.402s elapsed time, 1.558s cpu time, 0.170s GC time
Loading theory "Refine_Monadic.RefineG_While" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While")
consts
  stranspose :: "'a stream list => 'a list stream"
Proofs for coinductive predicate(s) "sdistinct"
  Proving monotonicity ...
Proofs for coinductive predicate(s) "sascending"
  Proving monotonicity ...
Proofs for coinductive predicate(s) "sdescending"
  Proving monotonicity ...
### theory "Transition_Systems_and_Automata.Sequence"
### 0.974s elapsed time, 3.787s cpu time, 0.429s GC time
Loading theory "Refine_Monadic.Refine_Basic" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While")
locale generic_WHILE
  fixes bind :: "'m => ('a => 'm) => 'm"
    and return :: "'a => 'm"
    and WHILEIT :: "('a => bool) => ('a => bool) => ('a => 'm) => 'a => 'm"
    and WHILEI :: "('a => bool) => ('a => bool) => ('a => 'm) => 'a => 'm"
    and WHILET :: "('a => bool) => ('a => 'm) => 'a => 'm"
    and WHILE :: "('a => bool) => ('a => 'm) => 'a => 'm"
  assumes "generic_WHILE bind return WHILEIT WHILEI WHILET WHILE"
locale transfer_WHILE
  fixes cbind :: "'mc => ('a => 'mc) => 'mc"
    and creturn :: "'a => 'mc"
    and
    cWHILEIT :: "('a => bool) => ('a => bool) => ('a => 'mc) => 'a => 'mc"
    and
    cWHILEI :: "('a => bool) => ('a => bool) => ('a => 'mc) => 'a => 'mc"
    and cWHILET :: "('a => bool) => ('a => 'mc) => 'a => 'mc"
    and cWHILE :: "('a => bool) => ('a => 'mc) => 'a => 'mc"
    and abind :: "'ma => ('a => 'ma) => 'ma"
    and areturn :: "'a => 'ma"
    and
    aWHILEIT :: "('a => bool) => ('a => bool) => ('a => 'ma) => 'a => 'ma"
    and
    aWHILEI :: "('a => bool) => ('a => bool) => ('a => 'ma) => 'a => 'ma"
    and aWHILET :: "('a => bool) => ('a => 'ma) => 'a => 'ma"
    and aWHILE :: "('a => bool) => ('a => 'ma) => 'a => 'ma"
    and \<alpha> :: "'mc => 'ma"
  assumes
    "transfer_WHILE cbind creturn cWHILEIT cWHILEI cWHILET cWHILE abind
      areturn aWHILEIT aWHILEI aWHILET aWHILE \<alpha>"
locale generic_WHILE_rules
  fixes bind :: "'a => ('b => 'a) => 'a"
    and return :: "'b => 'a"
    and SPEC :: "('b => bool) => 'a"
    and WHILEIT :: "('b => bool) => ('b => bool) => ('b => 'a) => 'b => 'a"
    and WHILEI :: "('b => bool) => ('b => bool) => ('b => 'a) => 'b => 'a"
    and WHILET :: "('b => bool) => ('b => 'a) => 'b => 'a"
    and WHILE :: "('b => bool) => ('b => 'a) => 'b => 'a"
  assumes "generic_WHILE_rules bind return SPEC WHILEIT WHILEI WHILET WHILE"
class countable_complete_distrib_lattice = countable_complete_lattice +
  assumes
    "sup_ccInf": "!!B a. countable B ==> sup a (Inf B) = Inf (sup a ` B)"
  assumes
    "inf_ccSup": "!!B a. countable B ==> inf a (Sup B) = Sup (inf a ` B)"
### theory "Refine_Monadic.RefineG_While"
### 0.473s elapsed time, 1.827s cpu time, 0.209s GC time
Loading theory "Refine_Monadic.Refine_Det" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_Pfun")
instantiation
  nres :: (type) complete_lattice
  Inf_nres == Inf :: 'a nres set => 'a nres
  Sup_nres == Sup :: 'a nres set => 'a nres
  bot_nres == bot :: 'a nres
  sup_nres == sup :: 'a nres => 'a nres => 'a nres
  top_nres == top :: 'a nres
  inf_nres == inf :: 'a nres => 'a nres => 'a nres
  less_eq_nres == less_eq :: 'a nres => 'a nres => bool
  less_nres == less :: 'a nres => 'a nres => bool
Found termination order: "{}"
Found termination order: "{}"
### theory "HOL-Library.Countable_Complete_Lattices"
### 2.423s elapsed time, 9.414s cpu time, 1.030s GC time
Loading theory "HOL-Library.Order_Continuity" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL" via "HOL-Library.Linear_Temporal_Logic_on_Streams" via "HOL-Library.Extended_Nat")
Found termination order: "{}"
Found termination order: "{}"
instantiation
  dres :: (type) complete_lattice
  Inf_dres == Inf :: 'a dres set => 'a dres
  Sup_dres == Sup :: 'a dres set => 'a dres
  bot_dres == bot :: 'a dres
  sup_dres == sup :: 'a dres => 'a dres => 'a dres
  top_dres == top :: 'a dres
  inf_dres == inf :: 'a dres => 'a dres => 'a dres
  less_eq_dres == less_eq :: 'a dres => 'a dres => bool
  less_dres == less :: 'a dres => 'a dres => bool
structure refine_pw_simps: NAMED_THMS
Found termination order: "{}"
### No equation for constructor "FAILi"
consts
  the_RES :: "'a nres => 'a set"
Found termination order: "{}"
structure Refine:
  sig
    val no_prod_split: bool Config.T
    val post_tac: Proof.context -> tactic'
    val rcg_tac: thm list -> Proof.context -> tactic'
    structure refine: NAMED_THMS
    structure refine0: NAMED_THMS
    structure refine2: NAMED_THMS
    structure vcg: NAMED_THMS
    structure vcg_cons: NAMED_THMS
  end
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
### theory "HOL-Library.Order_Continuity"
### 0.688s elapsed time, 2.642s cpu time, 0.359s GC time
Loading theory "HOL-Library.Extended_Nat" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL" via "HOL-Library.Linear_Temporal_Logic_on_Streams")
class infinity = type +
  fixes infinity :: "'a"
Found termination order: "size <*mlex*> {}"
instantiation
  enat :: infinity
  infinity_enat == infinity :: enat
Proofs for inductive predicate(s) "rec_set_enat"
### theory "Refine_Monadic.Refine_Det"
### 1.832s elapsed time, 7.029s cpu time, 0.888s GC time
Loading theory "Transition_Systems_and_Automata.Transition_System" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic")
locale transition_system_universal
  fixes execute :: "'transition => 'state => 'state"
locale transition_system
  fixes execute :: "'transition => 'state => 'state"
    and enabled :: "'transition => 'state => bool"
Proofs for inductive predicate(s) "path"
  Proving monotonicity ...
### No equation for constructor "Extended_Nat.infinity_class.infinity"
### in definition of function "the_enat"
Proofs for coinductive predicate(s) "run"
consts
  the_enat :: "enat => nat"
instantiation
  enat :: zero_neq_one
  one_enat == one_class.one :: enat
  zero_enat == zero_class.zero :: enat
  Proving monotonicity ...
Proofs for inductive predicate(s) "reachablep"
  Proving monotonicity ...
instantiation
  enat :: comm_monoid_add
  plus_enat == plus :: enat => enat => enat
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  enat :: {comm_semiring_1,semiring_no_zero_divisors}
  times_enat == times :: enat => enat => enat
instantiation
  enat :: minus
  minus_enat == minus :: enat => enat => enat
instantiation
  enat :: linordered_ab_semigroup_add
  less_eq_enat == less_eq :: enat => enat => bool
  less_enat == less :: enat => enat => bool
locale transition_system_initial
  fixes execute :: "'transition => 'state => 'state"
    and enabled :: "'transition => 'state => bool"
    and initial :: "'state => bool"
Proofs for inductive predicate(s) "nodesp"
  Proving monotonicity ...
Found termination order: "{}"
### theory "Transition_Systems_and_Automata.Transition_System"
### 0.351s elapsed time, 1.308s cpu time, 0.242s GC time
Loading theory "Word_Lib.More_Arithmetic" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit" via "Word_Lib.More_Word")
instantiation
  enat :: {order_bot,order_top}
  top_enat == top :: enat
  bot_enat == bot :: enat
### theory "Word_Lib.More_Arithmetic"
### 0.083s elapsed time, 0.312s cpu time, 0.051s GC time
Loading theory "Word_Lib.More_Word" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Least_significant_bit")
structure Cancel_Enat_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
instantiation
  enat :: complete_lattice
  Inf_enat == Inf :: enat set => enat
  Sup_enat == Sup :: enat set => enat
  sup_enat == sup :: enat => enat => enat
  inf_enat == inf :: enat => enat => enat
### theory "HOL-Library.Extended_Nat"
### 23.523s elapsed time, 79.046s cpu time, 76.190s GC time
Loading theory "HOL-Library.Linear_Temporal_Logic_on_Streams" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra" via "Transition_Systems_and_Automata.Sequence_LTL")
### theory "Refine_Monadic.Refine_Basic"
### 25.362s elapsed time, 86.145s cpu time, 77.010s GC time
Loading theory "Refine_Monadic.Refine_Heuristics" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach")
structure refine_heuristics_simps: NAMED_THMS
### ML warning (line 65 of "$AFP/Refine_Monadic/Refine_Heuristics.thy"):
### Value identifier (ctxt) has not been referenced.
structure Refine_dref_type:
  sig
    structure RELATES_rules: NAMED_THMS
    val has_schematic: term -> bool
    val match_goal_shape_tac:
       (term -> bool) -> Proof.context -> int -> thm -> thm Seq.seq
    val output_failed_msg: Proof.context -> term -> unit
    structure pattern_rules: NAMED_THMS
    val tracing: bool Config.T
    val type_tac: Proof.context -> tactic
  end
### theory "Refine_Monadic.Refine_Heuristics"
### 0.155s elapsed time, 0.620s cpu time, 0.000s GC time
Loading theory "Refine_Monadic.Refine_Leof" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach" via "Refine_Monadic.Refine_While")
### theory "Refine_Monadic.Refine_Leof"
### 0.160s elapsed time, 0.619s cpu time, 0.087s GC time
Loading theory "Refine_Monadic.Refine_More_Comb" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Refine_Monadic.Refine_Monadic")
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Refine_Monadic.Refine_More_Comb"
### 0.244s elapsed time, 0.975s cpu time, 0.088s GC time
Loading theory "Refine_Monadic.Refine_Pfun" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach")
Found termination order: "{}"
Found termination order: "{}"
Proofs for inductive predicate(s) "ev"
  Proving monotonicity ...
Proofs for coinductive predicate(s) "alw"
  Proving monotonicity ...
Proofs for coinductive predicate(s) "UNTIL"
  Proving monotonicity ...
### theory "Refine_Monadic.Refine_Pfun"
### 0.321s elapsed time, 1.264s cpu time, 0.168s GC time
Loading theory "Refine_Monadic.Refine_While" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach")
Proofs for inductive predicate(s) "ev_at"
  Proving monotonicity ...
Proofs for inductive predicate(s) "suntil"
  Proving monotonicity ...
### theory "HOL-Library.Linear_Temporal_Logic_on_Streams"
### 1.337s elapsed time, 5.271s cpu time, 0.508s GC time
Loading theory "Transition_Systems_and_Automata.Sequence_LTL" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Transition_System_Extra")
### theory "Word_Lib.More_Word"
### 1.520s elapsed time, 5.996s cpu time, 0.599s GC time
Loading theory "Word_Lib.Bit_Shifts_Infix_Syntax" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Generic_set_bit" via "Word_Lib.Most_significant_bit")
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Proofs for inductive predicate(s) "rwof"
  Proving monotonicity ...
consts
  bounded_WHILE' ::
    "nat => ('a => bool) => ('a => 'a nres) => 'a nres => 'a nres"
consts
  bounded_WHILE ::
    "nat => ('a => bool) => ('a => 'a nres) => 'a nres => 'a nres"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (and a b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (or a b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (xor a b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = or a (push_bit n (1::'a))"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and
    "flip_bit_eq_xor": "!!n a. flip_bit n a = xor a (push_bit n (1::'a))"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
### theory "Transition_Systems_and_Automata.Sequence_LTL"
### 0.661s elapsed time, 2.596s cpu time, 0.316s GC time
Loading theory "Transition_Systems_and_Automata.Acceptance" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Degeneralization")
### theory "Transition_Systems_and_Automata.Acceptance"
### 0.109s elapsed time, 0.428s cpu time, 0.085s GC time
Loading theory "Transition_Systems_and_Automata.Sequence_Zip" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic" via "Transition_Systems_and_Automata.Degeneralization")
### theory "Refine_Monadic.Refine_While"
### 1.167s elapsed time, 4.586s cpu time, 0.509s GC time
Loading theory "Refine_Monadic.Refine_Transfer" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine" via "Refine_Monadic.Refine_Foreach")
### theory "Transition_Systems_and_Automata.Sequence_Zip"
### 0.198s elapsed time, 0.782s cpu time, 0.124s GC time
Loading theory "Transition_Systems_and_Automata.Degeneralization" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
### Ambiguous input (line 1808 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" map_of)
###                 ("_cargs" ("_position" ys) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" sorted)
###         ("_applC" ("_position" map)
###           ("_cargs" ("_position" fst) ("_position" xs)))))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" sorted)
###           ("_applC" ("_position" map)
###             ("_cargs" ("_position" fst) ("_position" ys)))))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" map_of)
###         ("_cargs"
###           ("_applC" ("_position" sunion_with)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" xs) ("_position" ys))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" map_of)
###           ("_cargs" ("_position" xs) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" map_of)
###               ("_cargs" ("_position" ys) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" map_of)
###                   ("_cargs" ("_position" ys) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Missing patterns in function definition:
### the_res dSUCCEEDi = undefined
### the_res dFAILi = undefined
Found termination order: "{}"
### theory "Transition_Systems_and_Automata.Degeneralization"
### 0.288s elapsed time, 1.144s cpu time, 0.053s GC time
Loading theory "Transition_Systems_and_Automata.Maps" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine")
### theory "Refine_Monadic.Refine_Transfer"
### 0.479s elapsed time, 1.874s cpu time, 0.287s GC time
Loading theory "Refine_Monadic.Autoref_Monadic" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Refine_Monadic.Refine_Monadic")
structure Autoref_Monadic:
  sig
    val autoref_monadic_tac: Proof.context -> int -> tactic
    val cfg_plain: bool Config.T
  end
### theory "Refine_Monadic.Autoref_Monadic"
### 0.051s elapsed time, 0.207s cpu time, 0.000s GC time
Loading theory "Refine_Monadic.Refine_Automation" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Refine_Monadic.Refine_Monadic")
### theory "Transition_Systems_and_Automata.Maps"
### 0.120s elapsed time, 0.465s cpu time, 0.111s GC time
Loading theory "Refine_Monadic.Refine_Foreach" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine" via "Transition_Systems_and_Automata.Refine")
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (not a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = not (a - (1::'a))"
signature REFINE_AUTOMATION =
  sig
    val add_cd_pattern: cterm -> Context.generic -> Context.generic
    val add_extraction: string -> extraction -> theory -> theory
    val add_vc_rec_thm: thm -> Context.generic -> Context.generic
    val add_vc_solve_thm: thm -> Context.generic -> Context.generic
    val define_concrete_fun:
       extraction list option ->
         binding ->
           Token.src list ->
             indexname list ->
               thm ->
                 cterm list -> local_theory -> (thm * thm) * local_theory
    val del_cd_pattern: cterm -> Context.generic -> Context.generic
    val del_vc_rec_thm: thm -> Context.generic -> Context.generic
    val del_vc_solve_thm: thm -> Context.generic -> Context.generic
    val extract_as_def:
       (string * typ) list ->
         string -> term -> local_theory -> (term * thm) * local_theory
    val extract_recursion_eqs:
       extraction list -> string -> thm -> local_theory -> local_theory
    type extraction =
       {gen_tac: local_theory -> tactic', gen_thm: thm, pattern: term}
    val get_cd_patterns: Proof.context -> cterm list
    val get_vc_rec_thms: Proof.context -> thm list
    val get_vc_solve_thms: Proof.context -> thm list
    val mk_qualified: string -> bstring -> binding
    val prepare_cd_pattern: Proof.context -> cterm -> cterm
    val prepare_code_thms_cmd:
       string list -> thm -> local_theory -> local_theory
    val setup: theory -> theory
    val vc_solve_modifiers: Method.modifier parser list
    val vc_solve_tac: Proof.context -> bool -> tactic'
  end
structure Refine_Automation: REFINE_AUTOMATION
### theory "Word_Lib.Bit_Shifts_Infix_Syntax"
### 1.450s elapsed time, 5.701s cpu time, 0.680s GC time
Loading theory "Transition_Systems_and_Automata.Transition_System_Construction" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic")
val it = (): unit
val it = (): unit
### theory "Refine_Monadic.Refine_Automation"
### 0.224s elapsed time, 0.890s cpu time, 0.083s GC time
Loading theory "Transition_Systems_and_Automata.Transition_System_Extra" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA" via "Transition_Systems_and_Automata.Nondeterministic")
locale transition_system
  fixes execute :: "'transition => 'state => 'state"
    and enabled :: "'transition => 'state => bool"
### theory "Transition_Systems_and_Automata.Transition_System_Construction"
### 0.306s elapsed time, 1.207s cpu time, 0.043s GC time
Loading theory "Word_Lib.Least_significant_bit" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int")
Found termination order: "{}"
locale transition_system
  fixes execute :: "'transition => 'state => 'state"
    and enabled :: "'transition => 'state => bool"
locale transition_system_initial
  fixes execute :: "'transition => 'state => 'state"
    and enabled :: "'transition => 'state => bool"
    and initial :: "'state => bool"
### theory "Transition_Systems_and_Automata.Transition_System_Extra"
### 0.379s elapsed time, 1.484s cpu time, 0.122s GC time
Loading theory "Transition_Systems_and_Automata.Nondeterministic" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.NBA")
locale automaton
  fixes
    automaton ::
      "'label set
       => 'state set
          => ('label => 'state => 'state set) => 'condition => 'automaton"
    and alphabet :: "'automaton => 'label set"
    and initial :: "'automaton => 'state set"
    and transition :: "'automaton => 'label => 'state => 'state set"
    and condition :: "'automaton => 'condition"
  assumes "automaton automaton alphabet initial transition condition"
class lsb = semiring_bits +
  fixes lsb :: "'a => bool"
  assumes "lsb_odd": "lsb = odd"
instantiation
  int :: lsb
  lsb_int == lsb :: int => bool
Found termination order: "{}"
locale trimono_spec
instantiation
  word :: (len) lsb
  lsb_word == lsb :: 'a word => bool
### theory "Word_Lib.Least_significant_bit"
### 0.710s elapsed time, 2.793s cpu time, 0.240s GC time
Loading theory "Word_Lib.Most_significant_bit" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int" via "Word_Lib.Generic_set_bit")
class msb = type +
  fixes msb :: "'a => bool"
instantiation
  int :: msb
  msb_int == msb :: int => bool
instantiation
  word :: (len) msb
  msb_word == msb :: 'a word => bool
### theory "Word_Lib.Most_significant_bit"
### 0.190s elapsed time, 0.735s cpu time, 0.142s GC time
Loading theory "Word_Lib.Generic_set_bit" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer" via "Native_Word.Code_Symbolic_Bits_Int")
locale automaton_path
  fixes
    automaton ::
      "'label set
       => 'state set
          => ('label => 'state => 'state set) => 'condition => 'automaton"
    and alphabet :: "'automaton => 'label set"
    and initial :: "'automaton => 'state set"
    and transition :: "'automaton => 'label => 'state => 'state set"
    and condition :: "'automaton => 'condition"
    and test :: "'condition => 'label list => 'state list => 'state => bool"
  assumes "automaton_path automaton alphabet initial transition condition"
locale automaton_run
  fixes
    automaton ::
      "'label set
       => 'state set
          => ('label => 'state => 'state set) => 'condition => 'automaton"
    and alphabet :: "'automaton => 'label set"
    and initial :: "'automaton => 'state set"
    and transition :: "'automaton => 'label => 'state => 'state set"
    and condition :: "'automaton => 'condition"
    and
    test :: "'condition => 'label stream => 'state stream => 'state => bool"
  assumes "automaton_run automaton alphabet initial transition condition"
Found termination order: "{}"
### theory "Refine_Monadic.Refine_Foreach"
### 1.941s elapsed time, 7.637s cpu time, 0.724s GC time
Loading theory "Refine_Monadic.Refine_Monadic" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt")
class set_bit = semiring_bits +
  fixes set_bit :: "'a => nat => bool => 'a"
  assumes
    "bit_set_bit_iff_2n":
      "!!a m b n.
          bit (set_bit_class.set_bit a m b) n =
          ((if m = n then b else bit a n) & (2::'a) ^ n ~= (0::'a))"
instantiation
  int :: set_bit
  set_bit_int == set_bit_class.set_bit :: int => nat => bool => int
instantiation
  word :: (len) set_bit
  set_bit_word == set_bit_class.set_bit :: 'a word => nat => bool => 'a word
### theory "Word_Lib.Generic_set_bit"
### 0.746s elapsed time, 2.931s cpu time, 0.294s GC time
Loading theory "Transition_Systems_and_Automata.Refine" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine" via "Transition_Systems_and_Automata.Transition_System_Refine")
locale automaton_degeneralization
  fixes
    automaton\<^sub>1 ::
      "'label set
       => 'state set
          => ('label => 'state => 'state set)
             => ('item => bool) list => 'automaton\<^sub>1"
    and alphabet\<^sub>1 :: "'automaton\<^sub>1 => 'label set"
    and initial\<^sub>1 :: "'automaton\<^sub>1 => 'state set"
    and
    transition\<^sub>1 ::
      "'automaton\<^sub>1 => 'label => 'state => 'state set"
    and condition\<^sub>1 :: "'automaton\<^sub>1 => ('item => bool) list"
    and
    automaton\<^sub>2 ::
      "'label set
       => ('state * nat) set
          => ('label => 'state * nat => ('state * nat) set)
             => ('item_degen => bool) => 'automaton\<^sub>2"
    and alphabet\<^sub>2 :: "'automaton\<^sub>2 => 'label set"
    and initial\<^sub>2 :: "'automaton\<^sub>2 => ('state * nat) set"
    and
    transition\<^sub>2 ::
      "'automaton\<^sub>2 => 'label => 'state * nat => ('state * nat) set"
    and condition\<^sub>2 :: "'automaton\<^sub>2 => 'item_degen => bool"
    and item :: "'state * 'label * 'state => 'item"
    and translate :: "'item_degen => 'item * nat"
  assumes
    "automaton_degeneralization automaton\<^sub>1 alphabet\<^sub>1
      initial\<^sub>1 transition\<^sub>1 condition\<^sub>1 automaton\<^sub>2
      alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2 condition\<^sub>2"
Found termination order: "{}"
locale automaton_degeneralization_run
  fixes
    automaton\<^sub>1 ::
      "'a set => 'b set => ('a => 'b => 'b set) => ('c => bool) list => 'd"
    and alphabet\<^sub>1 :: "'d => 'a set"
    and initial\<^sub>1 :: "'d => 'b set"
    and transition\<^sub>1 :: "'d => 'a => 'b => 'b set"
    and condition\<^sub>1 :: "'d => ('c => bool) list"
    and
    test\<^sub>1 ::
      "('c => bool) list => 'a stream => 'b stream => 'b => bool"
    and
    automaton\<^sub>2 ::
      "'a set
       => ('b * nat) set
          => ('a => 'b * nat => ('b * nat) set) => ('e => bool) => 'f"
    and alphabet\<^sub>2 :: "'f => 'a set"
    and initial\<^sub>2 :: "'f => ('b * nat) set"
    and transition\<^sub>2 :: "'f => 'a => 'b * nat => ('b * nat) set"
    and condition\<^sub>2 :: "'f => 'e => bool"
    and
    test\<^sub>2 ::
      "('e => bool) => 'a stream => ('b * nat) stream => 'b * nat => bool"
    and item :: "'b * 'a * 'b => 'c"
    and translate :: "'e => 'c * nat"
  assumes
    "automaton_degeneralization_run automaton\<^sub>1 alphabet\<^sub>1
      initial\<^sub>1 transition\<^sub>1 condition\<^sub>1 test\<^sub>1
      automaton\<^sub>2 alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2
      condition\<^sub>2 test\<^sub>2 item translate"
locale Refine_Monadic_Syntax
### theory "Refine_Monadic.Refine_Monadic"
### 0.910s elapsed time, 3.577s cpu time, 0.366s GC time
Loading theory "Collections.Gen_Iterator" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set" via "Collections.Iterator")
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "Transition_Systems_and_Automata.Refine"
### 1.319s elapsed time, 5.180s cpu time, 0.575s GC time
Loading theory "Collections.Intf_Map" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Map" via "Collections.Gen_Map")
### theory "Collections.Gen_Iterator"
### 0.604s elapsed time, 2.364s cpu time, 0.286s GC time
Loading theory "Collections.Iterator" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set")
locale automaton_product
  fixes
    automaton\<^sub>1 ::
      "'label set
       => 'state\<^sub>1 set
          => ('label => 'state\<^sub>1 => 'state\<^sub>1 set)
             => 'condition\<^sub>1 => 'automaton\<^sub>1"
    and alphabet\<^sub>1 :: "'automaton\<^sub>1 => 'label set"
    and initial\<^sub>1 :: "'automaton\<^sub>1 => 'state\<^sub>1 set"
    and
    transition\<^sub>1 ::
      "'automaton\<^sub>1 => 'label => 'state\<^sub>1 => 'state\<^sub>1 set"
    and condition\<^sub>1 :: "'automaton\<^sub>1 => 'condition\<^sub>1"
    and
    automaton\<^sub>2 ::
      "'label set
       => 'state\<^sub>2 set
          => ('label => 'state\<^sub>2 => 'state\<^sub>2 set)
             => 'condition\<^sub>2 => 'automaton\<^sub>2"
    and alphabet\<^sub>2 :: "'automaton\<^sub>2 => 'label set"
    and initial\<^sub>2 :: "'automaton\<^sub>2 => 'state\<^sub>2 set"
    and
    transition\<^sub>2 ::
      "'automaton\<^sub>2 => 'label => 'state\<^sub>2 => 'state\<^sub>2 set"
    and condition\<^sub>2 :: "'automaton\<^sub>2 => 'condition\<^sub>2"
    and
    automaton\<^sub>3 ::
      "'label set
       => ('state\<^sub>1 * 'state\<^sub>2) set
          => ('label
              => 'state\<^sub>1 * 'state\<^sub>2
                 => ('state\<^sub>1 * 'state\<^sub>2) set)
             => 'condition\<^sub>3 => 'automaton\<^sub>3"
    and alphabet\<^sub>3 :: "'automaton\<^sub>3 => 'label set"
    and
    initial\<^sub>3 ::
      "'automaton\<^sub>3 => ('state\<^sub>1 * 'state\<^sub>2) set"
    and
    transition\<^sub>3 ::
      "'automaton\<^sub>3
       => 'label
          => 'state\<^sub>1 * 'state\<^sub>2
             => ('state\<^sub>1 * 'state\<^sub>2) set"
    and condition\<^sub>3 :: "'automaton\<^sub>3 => 'condition\<^sub>3"
    and
    condition ::
      "'condition\<^sub>1 => 'condition\<^sub>2 => 'condition\<^sub>3"
  assumes
    "automaton_product automaton\<^sub>1 alphabet\<^sub>1 initial\<^sub>1
      transition\<^sub>1 condition\<^sub>1 automaton\<^sub>2
      alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2 condition\<^sub>2
      automaton\<^sub>3 alphabet\<^sub>3 initial\<^sub>3 transition\<^sub>3
      condition\<^sub>3"
Found termination order: "{}"
### theory "Collections.Intf_Map"
### 0.325s elapsed time, 1.285s cpu time, 0.107s GC time
Loading theory "Collections.Intf_Set" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Set")
Found termination order: "size <*mlex*> {}"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "Collections.Intf_Set"
### 0.335s elapsed time, 1.306s cpu time, 0.211s GC time
Loading theory "Collections.Impl_Cfun_Set" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF")
### theory "Collections.Iterator"
### 0.623s elapsed time, 2.436s cpu time, 0.318s GC time
Loading theory "Collections.ICF_Spec_Base" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetSpec")
### theory "Collections.Impl_Cfun_Set"
### 0.101s elapsed time, 0.391s cpu time, 0.048s GC time
Loading theory "Collections.Gen_Map" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_List_Map")
### theory "Collections.ICF_Spec_Base"
### 0.339s elapsed time, 1.328s cpu time, 0.138s GC time
Loading theory "Collections.AnnotatedListSpec" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale al
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
locale al_no_invar
  fixes \<alpha> :: "'a => ('b * 'c) list"
    and invar :: "'a => bool"
  assumes "al_no_invar invar"
locale al_empty
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and empty :: "unit => 's"
  assumes "al_empty \<alpha> invar empty"
locale al_isEmpty
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and isEmpty :: "'s => bool"
  assumes "al_isEmpty \<alpha> invar isEmpty"
locale al_count
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and count :: "'s => nat"
  assumes "al_count \<alpha> invar count"
locale al_consl
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and consl :: "'e => 'a => 's => 's"
  assumes "al_consl \<alpha> invar consl"
locale al_consr
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and consr :: "'s => 'e => 'a => 's"
  assumes "al_consr \<alpha> invar consr"
locale al_head
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and head :: "'s => 'e * 'a"
  assumes "al_head \<alpha> invar head"
locale al_tail
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and tail :: "'s => 's"
  assumes "al_tail \<alpha> invar tail"
locale al_headR
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and headR :: "'s => 'e * 'a"
  assumes "al_headR \<alpha> invar headR"
locale automaton_intersection_path
  fixes
    automaton\<^sub>1 ::
      "'a set => 'b set => ('a => 'b => 'b set) => 'c => 'd"
    and alphabet\<^sub>1 :: "'d => 'a set"
    and initial\<^sub>1 :: "'d => 'b set"
    and transition\<^sub>1 :: "'d => 'a => 'b => 'b set"
    and condition\<^sub>1 :: "'d => 'c"
    and test\<^sub>1 :: "'c => 'a list => 'b list => 'b => bool"
    and
    automaton\<^sub>2 ::
      "'a set => 'e set => ('a => 'e => 'e set) => 'f => 'g"
    and alphabet\<^sub>2 :: "'g => 'a set"
    and initial\<^sub>2 :: "'g => 'e set"
    and transition\<^sub>2 :: "'g => 'a => 'e => 'e set"
    and condition\<^sub>2 :: "'g => 'f"
    and test\<^sub>2 :: "'f => 'a list => 'e list => 'e => bool"
    and
    automaton\<^sub>3 ::
      "'a set
       => ('b * 'e) set => ('a => 'b * 'e => ('b * 'e) set) => 'h => 'i"
    and alphabet\<^sub>3 :: "'i => 'a set"
    and initial\<^sub>3 :: "'i => ('b * 'e) set"
    and transition\<^sub>3 :: "'i => 'a => 'b * 'e => ('b * 'e) set"
    and condition\<^sub>3 :: "'i => 'h"
    and test\<^sub>3 :: "'h => 'a list => ('b * 'e) list => 'b * 'e => bool"
    and condition :: "'c => 'f => 'h"
  assumes
    "automaton_intersection_path automaton\<^sub>1 alphabet\<^sub>1
      initial\<^sub>1 transition\<^sub>1 condition\<^sub>1 test\<^sub>1
      automaton\<^sub>2 alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2
      condition\<^sub>2 test\<^sub>2 automaton\<^sub>3 alphabet\<^sub>3
      initial\<^sub>3 transition\<^sub>3 condition\<^sub>3 test\<^sub>3
      condition"
locale al_tailR
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and tailR :: "'s => 's"
  assumes "al_tailR \<alpha> invar tailR"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale al_foldl
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and foldl :: "('z => 'e * 'a => 'z) => 'z => 's => 'z"
  assumes "al_foldl \<alpha> invar foldl"
locale al_foldr
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and foldr :: "('e * 'a => 'z => 'z) => 's => 'z => 'z"
  assumes "al_foldr \<alpha> invar foldr"
locale poly_al_fold
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
locale al_app
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and app :: "'s => 's => 's"
  assumes "al_app \<alpha> invar app"
locale al_annot
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and annot :: "'s => 'a"
  assumes "al_annot \<alpha> invar annot"
locale al_splits
  fixes \<alpha> :: "'s => ('e * 'a) list"
    and invar :: "'s => bool"
    and splits :: "('a => bool) => 'a => 's => 's * ('e * 'a) * 's"
  assumes "al_splits \<alpha> invar splits"
### theory "Collections.Gen_Map"
### 0.645s elapsed time, 2.511s cpu time, 0.283s GC time
Loading theory "Collections.ListSpec" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale list
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
locale list_no_invar
  fixes \<alpha> :: "'a => 'b list"
    and invar :: "'a => bool"
  assumes "list_no_invar invar"
locale list_empty
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and empty :: "unit => 's"
  assumes "list_empty \<alpha> invar empty"
locale list_isEmpty
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and isEmpty :: "'s => bool"
  assumes "list_isEmpty \<alpha> invar isEmpty"
locale poly_list_iteratei
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
locale poly_list_rev_iteratei
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
locale list_size
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and size :: "'s => nat"
  assumes "list_size \<alpha> invar size"
locale list_appendl
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and appendl :: "'x => 's => 's"
  assumes "list_appendl \<alpha> invar appendl"
locale list_removel
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and removel :: "'s => 'x * 's"
  assumes "list_removel \<alpha> invar removel"
locale list_leftmost
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and leftmost :: "'s => 'x"
  assumes "list_leftmost \<alpha> invar leftmost"
locale list_appendr
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and appendr :: "'x => 's => 's"
  assumes "list_appendr \<alpha> invar appendr"
locale list_remover
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and remover :: "'s => 's * 'x"
  assumes "list_remover \<alpha> invar remover"
locale list_rightmost
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and rightmost :: "'s => 'x"
  assumes "list_rightmost \<alpha> invar rightmost"
locale list_get
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and get :: "'s => nat => 'x"
  assumes "list_get \<alpha> invar get"
locale list_set
  fixes \<alpha> :: "'s => 'x list"
    and invar :: "'s => bool"
    and set :: "'s => nat => 'x => 's"
  assumes "list_set \<alpha> invar set"
locale automaton_intersection_run
  fixes
    automaton\<^sub>1 ::
      "'a set => 'b set => ('a => 'b => 'b set) => 'c => 'd"
    and alphabet\<^sub>1 :: "'d => 'a set"
    and initial\<^sub>1 :: "'d => 'b set"
    and transition\<^sub>1 :: "'d => 'a => 'b => 'b set"
    and condition\<^sub>1 :: "'d => 'c"
    and test\<^sub>1 :: "'c => 'a stream => 'b stream => 'b => bool"
    and
    automaton\<^sub>2 ::
      "'a set => 'e set => ('a => 'e => 'e set) => 'f => 'g"
    and alphabet\<^sub>2 :: "'g => 'a set"
    and initial\<^sub>2 :: "'g => 'e set"
    and transition\<^sub>2 :: "'g => 'a => 'e => 'e set"
    and condition\<^sub>2 :: "'g => 'f"
    and test\<^sub>2 :: "'f => 'a stream => 'e stream => 'e => bool"
    and
    automaton\<^sub>3 ::
      "'a set
       => ('b * 'e) set => ('a => 'b * 'e => ('b * 'e) set) => 'h => 'i"
    and alphabet\<^sub>3 :: "'i => 'a set"
    and initial\<^sub>3 :: "'i => ('b * 'e) set"
    and transition\<^sub>3 :: "'i => 'a => 'b * 'e => ('b * 'e) set"
    and condition\<^sub>3 :: "'i => 'h"
    and
    test\<^sub>3 :: "'h => 'a stream => ('b * 'e) stream => 'b * 'e => bool"
    and condition :: "'c => 'f => 'h"
  assumes
    "automaton_intersection_run automaton\<^sub>1 alphabet\<^sub>1
      initial\<^sub>1 transition\<^sub>1 condition\<^sub>1 test\<^sub>1
      automaton\<^sub>2 alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2
      condition\<^sub>2 test\<^sub>2 automaton\<^sub>3 alphabet\<^sub>3
      initial\<^sub>3 transition\<^sub>3 condition\<^sub>3 test\<^sub>3
      condition"
locale StdALDefs
  fixes ops :: "('e, 'a, 's, 'more) alist_ops_scheme"
locale StdListDefs
  fixes ops :: "('a, 's, 'more) list_ops_scheme"
locale StdAL
  fixes ops :: "('a, 'b, 'c, 'd) alist_ops_scheme"
  assumes "StdAL ops"
locale StdList
  fixes ops :: "('a, 's, 'more) list_ops_scheme"
  assumes "StdList ops"
locale StdAL_no_invar
  fixes ops :: "('a, 'b, 'c, 'd) alist_ops_scheme"
  assumes "StdAL_no_invar ops"
### theory "Collections.AnnotatedListSpec"
### 1.848s elapsed time, 7.125s cpu time, 1.080s GC time
Loading theory "Collections.FTAnnotatedListImpl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale StdList_no_invar
  fixes ops :: "('a, 'b, 'c) list_ops_scheme"
  assumes "StdList_no_invar ops"
### theory "Collections.ListSpec"
### 1.459s elapsed time, 5.613s cpu time, 0.888s GC time
Loading theory "Collections.ListGA" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.ArrayHashSet" via "Collections.ArrayHashMap" via "Collections.ArrayHashMap_Impl")
locale automaton_sum
  fixes
    automaton\<^sub>1 ::
      "'label set
       => 'state\<^sub>1 set
          => ('label => 'state\<^sub>1 => 'state\<^sub>1 set)
             => 'condition\<^sub>1 => 'automaton\<^sub>1"
    and alphabet\<^sub>1 :: "'automaton\<^sub>1 => 'label set"
    and initial\<^sub>1 :: "'automaton\<^sub>1 => 'state\<^sub>1 set"
    and
    transition\<^sub>1 ::
      "'automaton\<^sub>1 => 'label => 'state\<^sub>1 => 'state\<^sub>1 set"
    and condition\<^sub>1 :: "'automaton\<^sub>1 => 'condition\<^sub>1"
    and
    automaton\<^sub>2 ::
      "'label set
       => 'state\<^sub>2 set
          => ('label => 'state\<^sub>2 => 'state\<^sub>2 set)
             => 'condition\<^sub>2 => 'automaton\<^sub>2"
    and alphabet\<^sub>2 :: "'automaton\<^sub>2 => 'label set"
    and initial\<^sub>2 :: "'automaton\<^sub>2 => 'state\<^sub>2 set"
    and
    transition\<^sub>2 ::
      "'automaton\<^sub>2 => 'label => 'state\<^sub>2 => 'state\<^sub>2 set"
    and condition\<^sub>2 :: "'automaton\<^sub>2 => 'condition\<^sub>2"
    and
    automaton\<^sub>3 ::
      "'label set
       => ('state\<^sub>1 + 'state\<^sub>2) set
          => ('label
              => 'state\<^sub>1 + 'state\<^sub>2
                 => ('state\<^sub>1 + 'state\<^sub>2) set)
             => 'condition\<^sub>3 => 'automaton\<^sub>3"
    and alphabet\<^sub>3 :: "'automaton\<^sub>3 => 'label set"
    and
    initial\<^sub>3 ::
      "'automaton\<^sub>3 => ('state\<^sub>1 + 'state\<^sub>2) set"
    and
    transition\<^sub>3 ::
      "'automaton\<^sub>3
       => 'label
          => 'state\<^sub>1 + 'state\<^sub>2
             => ('state\<^sub>1 + 'state\<^sub>2) set"
    and condition\<^sub>3 :: "'automaton\<^sub>3 => 'condition\<^sub>3"
    and
    condition ::
      "'condition\<^sub>1 => 'condition\<^sub>2 => 'condition\<^sub>3"
  assumes
    "automaton_sum automaton\<^sub>1 alphabet\<^sub>1 initial\<^sub>1
      transition\<^sub>1 condition\<^sub>1 automaton\<^sub>2
      alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2 condition\<^sub>2
      automaton\<^sub>3 alphabet\<^sub>3 initial\<^sub>3 transition\<^sub>3
      condition\<^sub>3"
locale idx_iteratei_loc
  fixes \<alpha> :: "'s => 'a list"
    and invar :: "'s => bool"
    and size :: "'s => nat"
    and get :: "'s => nat => 'a"
  assumes "idx_iteratei_loc \<alpha> invar size get"
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
locale it_size_loc
  fixes \<alpha> :: "'s => 'a list"
    and invar :: "'s => bool"
locale rev_it_size_loc
  fixes \<alpha> :: "'s => 'a list"
    and invar :: "'s => bool"
locale it_get_loc
  fixes \<alpha> :: "'s => 'a list"
    and invar :: "'s => bool"
### theory "Collections.ListGA"
### 0.596s elapsed time, 2.270s cpu time, 0.361s GC time
Loading theory "Collections.Fifo" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
### theory "Collections.Fifo"
### 0.582s elapsed time, 2.188s cpu time, 0.325s GC time
Loading theory "Collections.MapSpec" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale automaton_union_path
  fixes
    automaton\<^sub>1 ::
      "'a set => 'b set => ('a => 'b => 'b set) => 'c => 'd"
    and alphabet\<^sub>1 :: "'d => 'a set"
    and initial\<^sub>1 :: "'d => 'b set"
    and transition\<^sub>1 :: "'d => 'a => 'b => 'b set"
    and condition\<^sub>1 :: "'d => 'c"
    and test\<^sub>1 :: "'c => 'a list => 'b list => 'b => bool"
    and
    automaton\<^sub>2 ::
      "'a set => 'e set => ('a => 'e => 'e set) => 'f => 'g"
    and alphabet\<^sub>2 :: "'g => 'a set"
    and initial\<^sub>2 :: "'g => 'e set"
    and transition\<^sub>2 :: "'g => 'a => 'e => 'e set"
    and condition\<^sub>2 :: "'g => 'f"
    and test\<^sub>2 :: "'f => 'a list => 'e list => 'e => bool"
    and
    automaton\<^sub>3 ::
      "'a set
       => ('b + 'e) set => ('a => 'b + 'e => ('b + 'e) set) => 'h => 'i"
    and alphabet\<^sub>3 :: "'i => 'a set"
    and initial\<^sub>3 :: "'i => ('b + 'e) set"
    and transition\<^sub>3 :: "'i => 'a => 'b + 'e => ('b + 'e) set"
    and condition\<^sub>3 :: "'i => 'h"
    and test\<^sub>3 :: "'h => 'a list => ('b + 'e) list => 'b + 'e => bool"
    and condition :: "'c => 'f => 'h"
  assumes
    "automaton_union_path automaton\<^sub>1 alphabet\<^sub>1 initial\<^sub>1
      transition\<^sub>1 condition\<^sub>1 test\<^sub>1 automaton\<^sub>2
      alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2 condition\<^sub>2
      test\<^sub>2 automaton\<^sub>3 alphabet\<^sub>3 initial\<^sub>3
      transition\<^sub>3 condition\<^sub>3 test\<^sub>3 condition"
locale map
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
locale map_no_invar
  fixes \<alpha> :: "'a => 'b => 'c option"
    and invar :: "'a => bool"
  assumes "map_no_invar invar"
locale map_empty
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and empty :: "unit => 's"
  assumes "map_empty \<alpha> invar empty"
locale map_lookup
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and lookup :: "'u => 's => 'v option"
  assumes "map_lookup \<alpha> invar lookup"
locale map_update
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and update :: "'u => 'v => 's => 's"
  assumes "map_update \<alpha> invar update"
locale map_update_dj
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and update_dj :: "'u => 'v => 's => 's"
  assumes "map_update_dj \<alpha> invar update_dj"
### theory "Collections.FTAnnotatedListImpl"
### 1.334s elapsed time, 5.036s cpu time, 0.806s GC time
Loading theory "Collections.PrioSpec" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale map_delete
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and delete :: "'u => 's => 's"
  assumes "map_delete \<alpha> invar delete"
locale map_add
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and add :: "'s => 's => 's"
  assumes "MapSpec.map_add \<alpha> invar add"
locale prio
  fixes \<alpha> :: "'p => ('e * 'a) multiset"
    and invar :: "'p => bool"
locale prio_no_invar
  fixes \<alpha> :: "'a => ('b * 'c) multiset"
    and invar :: "'a => bool"
  assumes "prio_no_invar invar"
locale map_add_dj
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and add_dj :: "'s => 's => 's"
  assumes "map_add_dj \<alpha> invar add_dj"
locale prio_empty
  fixes \<alpha> :: "'p => ('e * 'a) multiset"
    and invar :: "'p => bool"
    and empty :: "unit => 'p"
  assumes "prio_empty \<alpha> invar empty"
locale map_isEmpty
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and isEmpty :: "'s => bool"
  assumes "map_isEmpty \<alpha> invar isEmpty"
locale prio_isEmpty
  fixes \<alpha> :: "'p => ('e * 'a) multiset"
    and invar :: "'p => bool"
    and isEmpty :: "'p => bool"
  assumes "prio_isEmpty \<alpha> invar isEmpty"
locale prio_find
  fixes \<alpha> :: "'p => ('e * 'a) multiset"
    and invar :: "'p => bool"
    and find :: "'p => 'e * 'a"
  assumes "prio_find \<alpha> invar find"
locale map_sng
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and sng :: "'u => 'v => 's"
  assumes "map_sng \<alpha> invar sng"
locale map_isSng
  fixes \<alpha> :: "'s => 'k => 'v option"
    and invar :: "'s => bool"
    and isSng :: "'s => bool"
  assumes "map_isSng \<alpha> invar isSng"
locale prio_insert
  fixes \<alpha> :: "'p => ('e * 'a) multiset"
    and invar :: "'p => bool"
    and insert :: "'e => 'a => 'p => 'p"
  assumes "prio_insert \<alpha> invar insert"
locale prio_meld
  fixes \<alpha> :: "'p => ('e * 'a) multiset"
    and invar :: "'p => bool"
    and meld :: "'p => 'p => 'p"
  assumes "prio_meld \<alpha> invar meld"
locale finite_map
  fixes \<alpha> :: "'a => 'b => 'c option"
    and invar :: "'a => bool"
  assumes "finite_map \<alpha> invar"
locale map_size
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and size :: "'s => nat"
  assumes "map_size \<alpha> invar size"
locale prio_delete
  fixes \<alpha> :: "'p => ('e * 'a) multiset"
    and invar :: "'p => bool"
    and find :: "'p => 'e * 'a"
    and delete :: "'p => 'p"
  assumes "prio_delete \<alpha> invar find delete"
locale map_size_abort
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and size_abort :: "nat => 's => nat"
  assumes "map_size_abort \<alpha> invar size_abort"
locale poly_map_iteratei_defs
  fixes
    list_it ::
      "'s => (('u * 'v) list => bool)
             => ('u * 'v => ('u * 'v) list => ('u * 'v) list)
                => ('u * 'v) list => ('u * 'v) list"
locale poly_map_iteratei
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and
    list_it ::
      "'s => (('u * 'v) list => bool)
             => ('u * 'v => ('u * 'v) list => ('u * 'v) list)
                => ('u * 'v) list => ('u * 'v) list"
  assumes "poly_map_iteratei \<alpha> invar list_it"
locale map_ball
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and ball :: "'s => ('u * 'v => bool) => bool"
  assumes "map_ball \<alpha> invar ball"
locale map_bex
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and bex :: "'s => ('u * 'v => bool) => bool"
  assumes "map_bex \<alpha> invar bex"
locale map_sel
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and sel :: "'s => ('u * 'v => 'r option) => 'r option"
  assumes "map_sel \<alpha> invar sel"
locale map_sel'
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and sel' :: "'s => ('u * 'v => bool) => ('u * 'v) option"
  assumes "map_sel' \<alpha> invar sel'"
locale map_to_list
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and to_list :: "'s => ('u * 'v) list"
  assumes "map_to_list \<alpha> invar to_list"
locale list_to_map
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and to_map :: "('u * 'v) list => 's"
  assumes "list_to_map \<alpha> invar to_map"
locale map_image_filter
  fixes \<alpha>1 :: "'m1 => 'u1 => 'v1 option"
    and invar1 :: "'m1 => bool"
    and \<alpha>2 :: "'m2 => 'u2 => 'v2 option"
    and invar2 :: "'m2 => bool"
    and
    map_image_filter :: "('u1 * 'v1 => ('u2 * 'v2) option) => 'm1 => 'm2"
  assumes
    "map_image_filter \<alpha>1 invar1 \<alpha>2 invar2 map_image_filter"
locale map_value_image_filter
  fixes \<alpha>1 :: "'m1 => 'u => 'v1 option"
    and invar1 :: "'m1 => bool"
    and \<alpha>2 :: "'m2 => 'u => 'v2 option"
    and invar2 :: "'m2 => bool"
    and map_value_image_filter :: "('u => 'v1 => 'v2 option) => 'm1 => 'm2"
  assumes
    "map_value_image_filter \<alpha>1 invar1 \<alpha>2 invar2
      map_value_image_filter"
locale map_restrict
  fixes \<alpha>1 :: "'m1 => 'u => 'v option"
    and invar1 :: "'m1 => bool"
    and \<alpha>2 :: "'m2 => 'u => 'v option"
    and invar2 :: "'m2 => bool"
    and restrict :: "('u * 'v => bool) => 'm1 => 'm2"
  assumes "map_restrict \<alpha>1 invar1 \<alpha>2 invar2 restrict"
locale ordered_map
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
locale ordered_finite_map
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
  assumes "ordered_finite_map \<alpha> invar"
locale poly_map_iterateoi_defs
  fixes
    olist_it ::
      "'s => (('u * 'v) list => bool)
             => ('u * 'v => ('u * 'v) list => ('u * 'v) list)
                => ('u * 'v) list => ('u * 'v) list"
locale poly_map_iterateoi
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and
    list_ordered_it ::
      "'s => (('u * 'v) list => bool)
             => ('u * 'v => ('u * 'v) list => ('u * 'v) list)
                => ('u * 'v) list => ('u * 'v) list"
  assumes "poly_map_iterateoi \<alpha> invar list_ordered_it"
locale poly_map_rev_iterateoi_defs
  fixes
    list_rev_it ::
      "'s => (('u * 'v) list => bool)
             => ('u * 'v => ('u * 'v) list => ('u * 'v) list)
                => ('u * 'v) list => ('u * 'v) list"
locale poly_map_rev_iterateoi
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and
    list_rev_it ::
      "'s => (('u * 'v) list => bool)
             => ('u * 'v => ('u * 'v) list => ('u * 'v) list)
                => ('u * 'v) list => ('u * 'v) list"
  assumes "poly_map_rev_iterateoi \<alpha> invar list_rev_it"
locale StdPrioDefs
  fixes ops :: "('e, 'a, 'p) prio_ops"
locale map_min
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and min :: "'s => ('u * 'v => bool) => ('u * 'v) option"
  assumes "map_min \<alpha> invar min"
locale map_max
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and max :: "'s => ('u * 'v => bool) => ('u * 'v) option"
  assumes "map_max \<alpha> invar max"
locale StdPrio
  fixes ops :: "('a, 'b, 'c) prio_ops"
  assumes "StdPrio ops"
locale StdPrio_no_invar
  fixes ops :: "('a, 'b, 'c) prio_ops"
  assumes "StdPrio_no_invar ops"
### theory "Collections.PrioSpec"
### 2.715s elapsed time, 10.230s cpu time, 7.160s GC time
Loading theory "Collections.BinoPrioImpl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale map_to_sorted_list
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and to_sorted_list :: "'s => ('u * 'v) list"
  assumes "MapSpec.map_to_sorted_list \<alpha> invar to_sorted_list"
locale map_to_rev_list
  fixes \<alpha> :: "'s => 'u => 'v option"
    and invar :: "'s => bool"
    and to_rev_list :: "'s => ('u * 'v) list"
  assumes "map_to_rev_list \<alpha> invar to_rev_list"
locale automaton_union_run
  fixes
    automaton\<^sub>1 ::
      "'a set => 'b set => ('a => 'b => 'b set) => 'c => 'd"
    and alphabet\<^sub>1 :: "'d => 'a set"
    and initial\<^sub>1 :: "'d => 'b set"
    and transition\<^sub>1 :: "'d => 'a => 'b => 'b set"
    and condition\<^sub>1 :: "'d => 'c"
    and test\<^sub>1 :: "'c => 'a stream => 'b stream => 'b => bool"
    and
    automaton\<^sub>2 ::
      "'a set => 'e set => ('a => 'e => 'e set) => 'f => 'g"
    and alphabet\<^sub>2 :: "'g => 'a set"
    and initial\<^sub>2 :: "'g => 'e set"
    and transition\<^sub>2 :: "'g => 'a => 'e => 'e set"
    and condition\<^sub>2 :: "'g => 'f"
    and test\<^sub>2 :: "'f => 'a stream => 'e stream => 'e => bool"
    and
    automaton\<^sub>3 ::
      "'a set
       => ('b + 'e) set => ('a => 'b + 'e => ('b + 'e) set) => 'h => 'i"
    and alphabet\<^sub>3 :: "'i => 'a set"
    and initial\<^sub>3 :: "'i => ('b + 'e) set"
    and transition\<^sub>3 :: "'i => 'a => 'b + 'e => ('b + 'e) set"
    and condition\<^sub>3 :: "'i => 'h"
    and
    test\<^sub>3 :: "'h => 'a stream => ('b + 'e) stream => 'b + 'e => bool"
    and condition :: "'c => 'f => 'h"
  assumes
    "automaton_union_run automaton\<^sub>1 alphabet\<^sub>1 initial\<^sub>1
      transition\<^sub>1 condition\<^sub>1 test\<^sub>1 automaton\<^sub>2
      alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2 condition\<^sub>2
      test\<^sub>2 automaton\<^sub>3 alphabet\<^sub>3 initial\<^sub>3
      transition\<^sub>3 condition\<^sub>3 test\<^sub>3 condition"
locale automaton_product_list
  fixes
    automaton\<^sub>1 ::
      "'label set
       => 'state set
          => ('label => 'state => 'state set)
             => 'condition\<^sub>1 => 'automaton\<^sub>1"
    and alphabet\<^sub>1 :: "'automaton\<^sub>1 => 'label set"
    and initial\<^sub>1 :: "'automaton\<^sub>1 => 'state set"
    and
    transition\<^sub>1 ::
      "'automaton\<^sub>1 => 'label => 'state => 'state set"
    and condition\<^sub>1 :: "'automaton\<^sub>1 => 'condition\<^sub>1"
    and
    automaton\<^sub>2 ::
      "'label set
       => 'state list set
          => ('label => 'state list => 'state list set)
             => 'condition\<^sub>2 => 'automaton\<^sub>2"
    and alphabet\<^sub>2 :: "'automaton\<^sub>2 => 'label set"
    and initial\<^sub>2 :: "'automaton\<^sub>2 => 'state list set"
    and
    transition\<^sub>2 ::
      "'automaton\<^sub>2 => 'label => 'state list => 'state list set"
    and condition\<^sub>2 :: "'automaton\<^sub>2 => 'condition\<^sub>2"
    and condition :: "'condition\<^sub>1 list => 'condition\<^sub>2"
  assumes
    "automaton_product_list automaton\<^sub>1 alphabet\<^sub>1
      initial\<^sub>1 transition\<^sub>1 condition\<^sub>1 automaton\<^sub>2
      alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2 condition\<^sub>2"
### theory "Collections.BinoPrioImpl"
### 0.614s elapsed time, 2.397s cpu time, 0.302s GC time
Loading theory "Collections.PrioByAnnotatedList" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.FTPrioImpl")
locale StdMapDefs
  fixes ops :: "('k, 'v, 's, 'more) map_ops_scheme"
locale automaton_intersection_list_run
  fixes
    automaton\<^sub>1 ::
      "'a set => 'b set => ('a => 'b => 'b set) => 'c => 'd"
    and alphabet\<^sub>1 :: "'d => 'a set"
    and initial\<^sub>1 :: "'d => 'b set"
    and transition\<^sub>1 :: "'d => 'a => 'b => 'b set"
    and condition\<^sub>1 :: "'d => 'c"
    and test\<^sub>1 :: "'c => 'a stream => 'b stream => 'b => bool"
    and
    automaton\<^sub>2 ::
      "'a set => 'b list set => ('a => 'b list => 'b list set) => 'e => 'f"
    and alphabet\<^sub>2 :: "'f => 'a set"
    and initial\<^sub>2 :: "'f => 'b list set"
    and transition\<^sub>2 :: "'f => 'a => 'b list => 'b list set"
    and condition\<^sub>2 :: "'f => 'e"
    and
    test\<^sub>2 :: "'e => 'a stream => 'b list stream => 'b list => bool"
    and condition :: "'c list => 'e"
  assumes
    "automaton_intersection_list_run automaton\<^sub>1 alphabet\<^sub>1
      initial\<^sub>1 transition\<^sub>1 condition\<^sub>1 test\<^sub>1
      automaton\<^sub>2 alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2
      condition\<^sub>2 test\<^sub>2 condition"
locale StdMap
  fixes ops :: "('k, 'v, 's, 'more) map_ops_scheme"
  assumes "StdMap ops"
locale StdMap_no_invar
  fixes ops :: "('a, 'b, 'c, 'd) map_ops_scheme"
  assumes "StdMap_no_invar ops"
### Missing patterns in function definition:
### p_unwrap Infty = undefined
Found termination order: "{}"
Found termination order: "{}"
instantiation
  Prio :: (type, linorder) monoid_add
  zero_Prio == zero_class.zero :: ('a, 'b) Prio
  plus_Prio == plus :: ('a, 'b) Prio => ('a, 'b) Prio => ('a, 'b) Prio
locale automaton_sum_list
  fixes
    automaton\<^sub>1 ::
      "'label set
       => 'state set
          => ('label => 'state => 'state set)
             => 'condition\<^sub>1 => 'automaton\<^sub>1"
    and alphabet\<^sub>1 :: "'automaton\<^sub>1 => 'label set"
    and initial\<^sub>1 :: "'automaton\<^sub>1 => 'state set"
    and
    transition\<^sub>1 ::
      "'automaton\<^sub>1 => 'label => 'state => 'state set"
    and condition\<^sub>1 :: "'automaton\<^sub>1 => 'condition\<^sub>1"
    and
    automaton\<^sub>2 ::
      "'label set
       => (nat * 'state) set
          => ('label => nat * 'state => (nat * 'state) set)
             => 'condition\<^sub>2 => 'automaton\<^sub>2"
    and alphabet\<^sub>2 :: "'automaton\<^sub>2 => 'label set"
    and initial\<^sub>2 :: "'automaton\<^sub>2 => (nat * 'state) set"
    and
    transition\<^sub>2 ::
      "'automaton\<^sub>2 => 'label => nat * 'state => (nat * 'state) set"
    and condition\<^sub>2 :: "'automaton\<^sub>2 => 'condition\<^sub>2"
    and condition :: "'condition\<^sub>1 list => 'condition\<^sub>2"
  assumes
    "automaton_sum_list automaton\<^sub>1 alphabet\<^sub>1 initial\<^sub>1
      transition\<^sub>1 condition\<^sub>1 automaton\<^sub>2
      alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2 condition\<^sub>2"
Found termination order: "{}"
Found termination order: "{}"
instantiation
  Prio :: (type, linorder) preorder
  less_eq_Prio == less_eq :: ('a, 'b) Prio => ('a, 'b) Prio => bool
  less_Prio == less :: ('a, 'b) Prio => ('a, 'b) Prio => bool
locale StdOMapDefs
  fixes ops :: "('k, 'v, 's, 'more) omap_ops_scheme"
locale alprio_defs
  fixes ops :: "(unit, ('e, 'a) Prio, 's) alist_ops"
locale alprio
  fixes ops :: "(unit, ('e, 'a) Prio, 's) alist_ops"
  assumes "alprio ops"
### theory "Collections.PrioByAnnotatedList"
### 1.648s elapsed time, 6.426s cpu time, 0.882s GC time
Loading theory "Collections.SkewPrioImpl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale StdOMap
  fixes ops :: "('k, 'v, 's, 'more) omap_ops_scheme"
  assumes "StdOMap ops"
### theory "Collections.MapSpec"
### 5.143s elapsed time, 19.705s cpu time, 8.422s GC time
Loading theory "Collections.PrioUniqueSpec" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale uprio
  fixes \<alpha> :: "'s => 'e => 'a option"
    and invar :: "'s => bool"
locale uprio_no_invar
  fixes \<alpha> :: "'a => 'b => 'c option"
    and invar :: "'a => bool"
  assumes "uprio_no_invar invar"
locale uprio_finite
  fixes \<alpha> :: "'a => 'b => 'c option"
    and invar :: "'a => bool"
  assumes "uprio_finite \<alpha> invar"
locale uprio_empty
  fixes \<alpha> :: "'s => 'e => 'a option"
    and invar :: "'s => bool"
    and empty :: "unit => 's"
  assumes "uprio_empty \<alpha> invar empty"
locale uprio_isEmpty
  fixes \<alpha> :: "'s => 'e => 'a option"
    and invar :: "'s => bool"
    and isEmpty :: "'s => bool"
  assumes "uprio_isEmpty \<alpha> invar isEmpty"
locale uprio_pop
  fixes \<alpha> :: "'s => 'e => 'a option"
    and invar :: "'s => bool"
    and pop :: "'s => 'e * 'a * 's"
  assumes "uprio_pop \<alpha> invar pop"
locale uprio_insert
  fixes \<alpha> :: "'s => 'e => 'a option"
    and invar :: "'s => bool"
    and insert :: "'s => 'e => 'a => 's"
  assumes "uprio_insert \<alpha> invar insert"
locale uprio_distinct_insert
  fixes \<alpha> :: "'s => 'e => 'a option"
    and invar :: "'s => bool"
    and insert :: "'s => 'e => 'a => 's"
  assumes "uprio_distinct_insert \<alpha> invar insert"
locale automaton_union_list_run
  fixes
    automaton\<^sub>1 ::
      "'a set => 'b set => ('a => 'b => 'b set) => 'c => 'd"
    and alphabet\<^sub>1 :: "'d => 'a set"
    and initial\<^sub>1 :: "'d => 'b set"
    and transition\<^sub>1 :: "'d => 'a => 'b => 'b set"
    and condition\<^sub>1 :: "'d => 'c"
    and test\<^sub>1 :: "'c => 'a stream => 'b stream => 'b => bool"
    and
    automaton\<^sub>2 ::
      "'a set
       => (nat * 'b) set => ('a => nat * 'b => (nat * 'b) set) => 'e => 'f"
    and alphabet\<^sub>2 :: "'f => 'a set"
    and initial\<^sub>2 :: "'f => (nat * 'b) set"
    and transition\<^sub>2 :: "'f => 'a => nat * 'b => (nat * 'b) set"
    and condition\<^sub>2 :: "'f => 'e"
    and
    test\<^sub>2 ::
      "'e => 'a stream => (nat * 'b) stream => nat * 'b => bool"
    and condition :: "'c list => 'e"
  assumes
    "automaton_union_list_run automaton\<^sub>1 alphabet\<^sub>1
      initial\<^sub>1 transition\<^sub>1 condition\<^sub>1 test\<^sub>1
      automaton\<^sub>2 alphabet\<^sub>2 initial\<^sub>2 transition\<^sub>2
      condition\<^sub>2 test\<^sub>2 condition"
locale uprio_prio
  fixes \<alpha> :: "'s => 'e => 'a option"
    and invar :: "'s => bool"
    and prio :: "'s => 'e => 'a option"
  assumes "uprio_prio \<alpha> invar prio"
### theory "Transition_Systems_and_Automata.Nondeterministic"
### 12.177s elapsed time, 46.993s cpu time, 11.907s GC time
Loading theory "Collections.SetSpec" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
locale set
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
locale set_no_invar
  fixes \<alpha> :: "'a => 'b set"
    and invar :: "'a => bool"
  assumes "set_no_invar invar"
locale set_empty
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and empty :: "unit => 's"
  assumes "set_empty \<alpha> invar empty"
locale set_memb
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and memb :: "'x => 's => bool"
  assumes "set_memb \<alpha> invar memb"
locale set_ins
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and ins :: "'x => 's => 's"
  assumes "set_ins \<alpha> invar ins"
locale set_ins_dj
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and ins_dj :: "'x => 's => 's"
  assumes "set_ins_dj \<alpha> invar ins_dj"
locale set_delete
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and delete :: "'x => 's => 's"
  assumes "set_delete \<alpha> invar delete"
locale set_isEmpty
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and isEmpty :: "'s => bool"
  assumes "set_isEmpty \<alpha> invar isEmpty"
locale set_ball
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and ball :: "'s => ('x => bool) => bool"
  assumes "set_ball \<alpha> invar ball"
locale set_bex
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and bex :: "'s => ('x => bool) => bool"
  assumes "set_bex \<alpha> invar bex"
locale finite_set
  fixes \<alpha> :: "'a => 'b set"
    and invar :: "'a => bool"
  assumes "finite_set \<alpha> invar"
locale set_size
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and size :: "'s => nat"
  assumes "set_size \<alpha> invar size"
locale set_size_abort
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and size_abort :: "nat => 's => nat"
  assumes "set_size_abort \<alpha> invar size_abort"
locale set_sng
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and sng :: "'x => 's"
  assumes "set_sng \<alpha> invar sng"
locale set_isSng
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and isSng :: "'s => bool"
  assumes "set_isSng \<alpha> invar isSng"
locale poly_set_iteratei_defs
  fixes
    list_it ::
      "'s => ('x list => bool)
             => ('x => 'x list => 'x list) => 'x list => 'x list"
locale poly_set_iteratei
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and
    list_it ::
      "'s => ('x list => bool)
             => ('x => 'x list => 'x list) => 'x list => 'x list"
  assumes "poly_set_iteratei \<alpha> invar list_it"
locale set_copy
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and copy :: "'s1 => 's2"
  assumes "set_copy \<alpha>1 invar1 \<alpha>2 invar2 copy"
locale set_union
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and \<alpha>3 :: "'s3 => 'a set"
    and invar3 :: "'s3 => bool"
    and union :: "'s1 => 's2 => 's3"
  assumes
    "set_union \<alpha>1 invar1 \<alpha>2 invar2 \<alpha>3 invar3 union"
locale set_union_dj
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and \<alpha>3 :: "'s3 => 'a set"
    and invar3 :: "'s3 => bool"
    and union_dj :: "'s1 => 's2 => 's3"
  assumes
    "set_union_dj \<alpha>1 invar1 \<alpha>2 invar2 \<alpha>3 invar3
      union_dj"
locale set_union_list
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and union_list :: "'s1 list => 's2"
  assumes "set_union_list \<alpha>1 invar1 \<alpha>2 invar2 union_list"
locale set_diff
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and diff :: "'s1 => 's2 => 's1"
  assumes "set_diff \<alpha>1 invar1 \<alpha>2 invar2 diff"
locale set_inter
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and \<alpha>3 :: "'s3 => 'a set"
    and invar3 :: "'s3 => bool"
    and inter :: "'s1 => 's2 => 's3"
  assumes
    "set_inter \<alpha>1 invar1 \<alpha>2 invar2 \<alpha>3 invar3 inter"
locale set_subset
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and subset :: "'s1 => 's2 => bool"
  assumes "set_subset \<alpha>1 invar1 \<alpha>2 invar2 subset"
locale set_equal
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and equal :: "'s1 => 's2 => bool"
  assumes "set_equal \<alpha>1 invar1 \<alpha>2 invar2 equal"
locale set_image_filter
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'b set"
    and invar2 :: "'s2 => bool"
    and image_filter :: "('a => 'b option) => 's1 => 's2"
  assumes "set_image_filter \<alpha>1 invar1 \<alpha>2 invar2 image_filter"
locale set_inj_image_filter
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'b set"
    and invar2 :: "'s2 => bool"
    and inj_image_filter :: "('a => 'b option) => 's1 => 's2"
  assumes
    "set_inj_image_filter \<alpha>1 invar1 \<alpha>2 invar2
      inj_image_filter"
locale set_image
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'b set"
    and invar2 :: "'s2 => bool"
    and image :: "('a => 'b) => 's1 => 's2"
  assumes "set_image \<alpha>1 invar1 \<alpha>2 invar2 image"
locale set_inj_image
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'b set"
    and invar2 :: "'s2 => bool"
    and inj_image :: "('a => 'b) => 's1 => 's2"
  assumes "set_inj_image \<alpha>1 invar1 \<alpha>2 invar2 inj_image"
locale set_filter
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and filter :: "('a => bool) => 's1 => 's2"
  assumes "set_filter \<alpha>1 invar1 \<alpha>2 invar2 filter"
locale set_Union_image
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'b set"
    and invar2 :: "'s2 => bool"
    and \<alpha>3 :: "'s3 => 'b set"
    and invar3 :: "'s3 => bool"
    and Union_image :: "('a => 's2) => 's1 => 's3"
  assumes
    "set_Union_image \<alpha>1 invar1 \<alpha>2 invar2 \<alpha>3 invar3
      Union_image"
locale set_disjoint
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and disjoint :: "'s1 => 's2 => bool"
  assumes "set_disjoint \<alpha>1 invar1 \<alpha>2 invar2 disjoint"
locale set_disjoint_witness
  fixes \<alpha>1 :: "'s1 => 'a set"
    and invar1 :: "'s1 => bool"
    and \<alpha>2 :: "'s2 => 'a set"
    and invar2 :: "'s2 => bool"
    and disjoint_witness :: "'s1 => 's2 => 'a option"
  assumes
    "set_disjoint_witness \<alpha>1 invar1 \<alpha>2 invar2
      disjoint_witness"
locale set_sel
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and sel :: "'s => ('x => 'r option) => 'r option"
  assumes "set_sel \<alpha> invar sel"
locale set_sel'
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and sel' :: "'s => ('x => bool) => 'x option"
  assumes "set_sel' \<alpha> invar sel'"
locale set_to_list
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and to_list :: "'s => 'x list"
  assumes "set_to_list \<alpha> invar to_list"
locale list_to_set
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and to_set :: "'x list => 's"
  assumes "list_to_set \<alpha> invar to_set"
locale ordered_set
  fixes \<alpha> :: "'s => 'u set"
    and invar :: "'s => bool"
locale ordered_finite_set
  fixes \<alpha> :: "'s => 'u set"
    and invar :: "'s => bool"
  assumes "ordered_finite_set \<alpha> invar"
locale poly_set_iterateoi_defs
  fixes
    olist_it ::
      "'s => ('x list => bool)
             => ('x => 'x list => 'x list) => 'x list => 'x list"
### theory "Collections.SkewPrioImpl"
### 0.850s elapsed time, 3.293s cpu time, 0.391s GC time
Loading theory "Collections.Impl_List_Map" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF")
locale StdUprioDefs
  fixes ops :: "('e, 'a, 's, 'more) uprio_ops_scheme"
locale poly_set_iterateoi
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and
    list_ordered_it ::
      "'s => ('x list => bool)
             => ('x => 'x list => 'x list) => 'x list => 'x list"
  assumes "poly_set_iterateoi \<alpha> invar list_ordered_it"
locale poly_set_rev_iterateoi_defs
  fixes
    list_rev_it ::
      "'s => ('x list => bool)
             => ('x => 'x list => 'x list) => 'x list => 'x list"
locale StdUprio
  fixes ops :: "('a, 'b, 'c, 'd) uprio_ops_scheme"
  assumes "StdUprio ops"
locale StdUprio_no_invar
  fixes ops :: "('a, 'b, 'c, 'd) uprio_ops_scheme"
  assumes "StdUprio_no_invar ops"
### theory "Collections.PrioUniqueSpec"
### 0.908s elapsed time, 3.518s cpu time, 0.424s GC time
Loading theory "Collections.PrioUniqueByAnnotatedList" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.FTPrioUniqueImpl")
locale poly_set_rev_iterateoi
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and
    list_rev_it ::
      "'s => ('x list => bool)
             => ('x => 'x list => 'x list) => 'x list => 'x list"
  assumes "poly_set_rev_iterateoi \<alpha> invar list_rev_it"
locale set_min
  fixes \<alpha> :: "'s => 'u set"
    and invar :: "'s => bool"
    and min :: "'s => ('u => bool) => 'u option"
  assumes "set_min \<alpha> invar min"
locale set_max
  fixes \<alpha> :: "'s => 'u set"
    and invar :: "'s => bool"
    and max :: "'s => ('u => bool) => 'u option"
  assumes "set_max \<alpha> invar max"
locale set_to_sorted_list
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and to_sorted_list :: "'s => 'x list"
  assumes "SetSpec.set_to_sorted_list \<alpha> invar to_sorted_list"
locale set_to_rev_list
  fixes \<alpha> :: "'s => 'x set"
    and invar :: "'s => bool"
    and to_rev_list :: "'s => 'x list"
  assumes "set_to_rev_list \<alpha> invar to_rev_list"
consts
  list_map_lookup ::
    "('k => 'k => bool) => 'k => ('k * 'v) list => 'v option"
consts
  list_map_update_aux ::
    "('k => 'k => bool)
     => 'k => 'v => ('k * 'v) list => ('k * 'v) list => ('k * 'v) list"
consts
  list_map_delete_aux ::
    "('k => 'k => bool)
     => 'k => ('k * 'v) list => ('k * 'v) list => ('k * 'v) list"
consts
  list_map_pick_remove :: "'a list => 'a * 'a list"
### theory "Collections.Impl_List_Map"
### 0.792s elapsed time, 3.050s cpu time, 0.408s GC time
Loading theory "Collections.Gen_Map2Set" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF")
### Missing patterns in function definition:
### p_unwrap Infty = undefined
Found termination order: "{}"
Found termination order: "{}"
locale StdSetDefs
  fixes ops :: "('x, 's, 'more) set_ops_scheme"
Found termination order: "{}"
instantiation
  LP :: (linorder, linorder) monoid_add
  zero_LP == zero_class.zero :: ('a, 'b) LP
  plus_LP == plus :: ('a, 'b) LP => ('a, 'b) LP => ('a, 'b) LP
Found termination order: "{}"
Found termination order: "{}"
### theory "Collections.Gen_Map2Set"
### 0.770s elapsed time, 2.932s cpu time, 0.400s GC time
Loading theory "Collections.Gen_Set" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF")
instantiation
  LP :: (type, linorder) preorder
  less_eq_LP == less_eq :: ('a, 'b) LP => ('a, 'b) LP => bool
  less_LP == less :: ('a, 'b) LP => ('a, 'b) LP => bool
locale StdSet
  fixes ops :: "('x, 's, 'more) set_ops_scheme"
  assumes "StdSet ops"
locale StdSet_no_invar
  fixes ops :: "('a, 'b, 'c) set_ops_scheme"
  assumes "StdSet_no_invar ops"
locale aluprio_defs
  fixes ops :: "(unit, ('e, 'a) LP, 's) alist_ops"
locale aluprio
  fixes ops :: "(unit, ('e, 'a) LP, 's) alist_ops"
  assumes "aluprio ops"
### theory "Collections.PrioUniqueByAnnotatedList"
### 3.943s elapsed time, 14.890s cpu time, 8.613s GC time
Loading theory "Collections.Impl_List_Set" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF")
consts
  glist_member :: "('a => 'a => bool) => 'a => 'a list => bool"
consts
  rev_append :: "'a list => 'a list => 'a list"
consts
  glist_delete_aux ::
    "('a => 'a => bool) => 'a => 'a list => 'a list => 'a list"
locale StdOSetDefs
  fixes ops :: "('x, 's, 'more) oset_ops_scheme"
### Adding overloaded interface type to constant: a ::\<^sub>i i_of_rel Id
### Adding overloaded interface type to constant: b ::\<^sub>i i_of_rel Id
### Adding overloaded interface type to constant: {} ::\<^sub>i i_of_rel Rs
### Adding overloaded interface type to constant:
###   insert ::\<^sub>i
###   i_nat \<rightarrow>\<^sub>i i_of_rel Rs \<rightarrow>\<^sub>i i_of_rel Rs
### Cannot skip proof of schematic goal statement
### theory "Collections.Impl_List_Set"
### 0.483s elapsed time, 1.887s cpu time, 0.257s GC time
Loading theory "DFS_Framework.DFS_Framework_Refine_Aux" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "DFS_Framework.Reachable_Nodes" via "DFS_Framework.DFS_Framework" via "DFS_Framework.Param_DFS")
locale StdOSet
  fixes ops :: "('x, 's, 'more) oset_ops_scheme"
  assumes "StdOSet ops"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "Collections.SetSpec"
### 5.435s elapsed time, 20.701s cpu time, 9.317s GC time
Loading theory "Collections.Algos" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
### Cannot skip proof of schematic goal statement
### theory "DFS_Framework.DFS_Framework_Refine_Aux"
### 0.322s elapsed time, 1.269s cpu time, 0.114s GC time
Loading theory "Collections.SetIndex" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl")
### Adding overloaded interface type to constant:
###   atLeastLessThan ::\<^sub>i
###   i_nat \<rightarrow>\<^sub>i i_nat \<rightarrow>\<^sub>i ?Rs
### Adding overloaded interface type to constant:
###   atLeastLessThan ::\<^sub>i
###   i_nat \<rightarrow>\<^sub>i i_nat \<rightarrow>\<^sub>i ?Rs
### Adding overloaded interface type to constant:
###   atLeastLessThan ::\<^sub>i
###   i_nat \<rightarrow>\<^sub>i i_nat \<rightarrow>\<^sub>i ?Rs
### Adding overloaded interface type to constant:
###   atLeastLessThan ::\<^sub>i
###   i_nat \<rightarrow>\<^sub>i i_nat \<rightarrow>\<^sub>i ?Rs
### theory "Collections.Gen_Set"
### 3.313s elapsed time, 12.560s cpu time, 8.208s GC time
Loading theory "Collections.SetIteratorCollectionsGA" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.ListSetImpl" via "Collections.SetGA")
locale index_loc
  fixes m_ops :: "('i, 's, 'm, 'more1) map_ops_scheme"
    and s_ops :: "('x, 's, 'more2) set_ops_scheme"
  assumes "index_loc m_ops s_ops"
locale map_to_nat_loc
  fixes s_ops :: "('x, 's, 'more1) set_ops_scheme"
    and m_ops :: "('x, nat, 'm, 'more2) map_ops_scheme"
  assumes "map_to_nat_loc s_ops m_ops"
### theory "Collections.SetIteratorCollectionsGA"
### 0.369s elapsed time, 1.459s cpu time, 0.154s GC time
Loading theory "Collections.MapGA" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.RBTSetImpl" via "Collections.RBTMapImpl")
locale it_dom_fun_to_map_loc
  fixes s_ops :: "('k, 's, 'more1) set_ops_scheme"
    and m_ops :: "('k, 'v, 'm, 'more2) map_ops_scheme"
  assumes "it_dom_fun_to_map_loc s_ops m_ops"
locale build_index_loc
  fixes m_ops :: "('i, 's, 'm, 'more1) map_ops_scheme"
    and s_ops :: "('x, 's, 'more3) set_ops_scheme"
    and t_ops :: "('x, 't, 'more2) set_ops_scheme"
  assumes "build_index_loc m_ops s_ops t_ops"
locale set_to_list_defs_loc
  fixes s_ops :: "('x, 's, 'more1) set_ops_scheme"
    and l_ops :: "('x, 'l, 'more2) list_ops_scheme"
### theory "Collections.SetIndex"
### 0.551s elapsed time, 2.157s cpu time, 0.237s GC time
Loading theory "Collections.SetGA" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.ListSetImpl")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale set_to_list_loc
  fixes s_ops :: "('x, 's, 'more1) set_ops_scheme"
    and l_ops :: "('x, 'l, 'more2) list_ops_scheme"
  assumes "set_to_list_loc s_ops l_ops"
### theory "Collections.Algos"
### 0.691s elapsed time, 2.729s cpu time, 0.237s GC time
Loading theory "Transition_Systems_and_Automata.Degeneralization_Refine" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NGBA_Algorithms")
locale g_set_xx_defs_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('x, 's2, 'more2) set_ops_scheme"
locale g_set_xx_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('x, 's2, 'more2) set_ops_scheme"
  assumes "g_set_xx_loc ops1 ops2"
locale g_set_xxx_defs_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('x, 's2, 'more2) set_ops_scheme"
    and ops3 :: "('x, 's3, 'more3) set_ops_scheme"
locale g_set_xxx_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('x, 's2, 'more2) set_ops_scheme"
    and ops3 :: "('x, 's3, 'more3) set_ops_scheme"
  assumes "g_set_xxx_loc ops1 ops2 ops3"
### theory "Transition_Systems_and_Automata.Degeneralization_Refine"
### 0.512s elapsed time, 2.004s cpu time, 0.282s GC time
Loading theory "Transition_Systems_and_Automata.NBA" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale g_set_xy_defs_loc
  fixes ops1 :: "('x1, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('x2, 's2, 'more2) set_ops_scheme"
  assumes "g_set_xy_defs_loc ops1 ops2"
locale StdBasicMapDefs
  fixes ops :: "('k, 'v, 's, 'more) map_basic_ops_scheme"
locale StdBasicOMapDefs
  fixes ops :: "('k, 'v, 's, 'more) omap_basic_ops_scheme"
locale StdBasicMap
  fixes ops :: "('k, 'v, 's, 'more) map_basic_ops_scheme"
  assumes "StdBasicMap ops"
locale g_set_xy_loc
  fixes ops1 :: "('x1, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('x2, 's2, 'more2) set_ops_scheme"
  assumes "g_set_xy_loc ops1 ops2"
locale StdBasicOMap
  fixes ops :: "('k, 'v, 's, 'more) omap_basic_ops_scheme"
  assumes "StdBasicOMap ops"
locale StdBasicMapDefs
  fixes ops :: "('k, 'v, 's, 'more) map_basic_ops_scheme"
### Ambiguous input (line 2563 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case1" ("_applC" ("_position" Some) ("_position" v))
###           ("_case_syntax"
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k)))
###             ("_case2"
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))
###               ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                 ("_applC" ("_position" Some)
###                   ("_applC" ("_position" f)
###                     ("_cargs" ("_position" k)
###                       ("_cargs" ("_position" w) ("_position" v)))))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("_applC" ("_position" rbt_lookup)
###       ("_cargs"
###         ("_applC" ("_position" fold)
###           ("_cargs"
###             ("_applC" ("_position" rbt_insert_with_key) ("_position" f))
###             ("_cargs" ("_position" t1) ("_position" t2))))
###         ("_position" k)))
###     ("_case_syntax"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs" ("_position" t1) ("_position" k)))
###       ("_case2"
###         ("_case1" ("_position" None)
###           ("_applC" ("_position" rbt_lookup)
###             ("_cargs" ("_position" t2) ("_position" k))))
###         ("_case2"
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case1" ("_position" None)
###                 ("_applC" ("_position" Some) ("_position" v)))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" w))
###             ("_applC" ("_position" Some)
###               ("_applC" ("_position" f)
###                 ("_cargs" ("_position" k)
###                   ("_cargs" ("_position" w) ("_position" v)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale g_set_xyy_defs_loc
  fixes ops0 :: "('x0, 's0, 'more0) set_ops_scheme"
    and ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('x, 's2, 'more2) set_ops_scheme"
locale g_set_xyy_loc
  fixes ops0 :: "('x0, 's0, 'more0) set_ops_scheme"
    and ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('x, 's2, 'more2) set_ops_scheme"
  assumes "g_set_xyy_loc ops0 ops1 ops2"
locale StdBasicMap
  fixes ops :: "('k, 'v, 's, 'more) map_basic_ops_scheme"
  assumes "StdBasicMap ops"
locale StdBasicOMapDefs
  fixes ops :: "('k, 'v, 's, 'more) omap_basic_ops_scheme"
locale StdBasicOMap
  fixes ops :: "('k, 'v, 's, 'more) omap_basic_ops_scheme"
  assumes "StdBasicOMap ops"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
locale g_image_filter_defs_loc
  fixes ops1 :: "('k1, 'v1, 's1, 'm1) map_ops_scheme"
    and ops2 :: "('k2, 'v2, 's2, 'm2) map_ops_scheme"
locale g_image_filter_loc
  fixes ops1 :: "('k1, 'v1, 's1, 'm1) map_ops_scheme"
    and ops2 :: "('k2, 'v2, 's2, 'm2) map_ops_scheme"
  assumes "g_image_filter_loc ops1 ops2"
locale g_value_image_filter_defs_loc
  fixes ops1 :: "('k, 'v1, 's1, 'm1) map_ops_scheme"
    and ops2 :: "('k, 'v2, 's2, 'm2) map_ops_scheme"
instantiation
  nba :: (type, type) order
  less_eq_nba == less_eq :: ('a, 'b) nba => ('a, 'b) nba => bool
  less_nba == less :: ('a, 'b) nba => ('a, 'b) nba => bool
locale StdBasicSetDefs
  fixes ops :: "('x, 's, 'more) set_basic_ops_scheme"
locale g_value_image_filter_loc
  fixes ops1 :: "('k, 'v1, 's1, 'm1) map_ops_scheme"
    and ops2 :: "('k, 'v2, 's2, 'm2) map_ops_scheme"
  assumes "g_value_image_filter_loc ops1 ops2"
locale StdBasicOSetDefs
  fixes ops :: "('x, 's, 'more) oset_basic_ops_scheme"
### theory "Transition_Systems_and_Automata.NBA"
### 1.190s elapsed time, 4.639s cpu time, 0.547s GC time
Loading theory "Draft.Graph" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Draft.Complementation" via "Draft.Ranking")
### theory "Collections.MapGA"
### 1.952s elapsed time, 7.622s cpu time, 1.050s GC time
Loading theory "Collections.ListMapImpl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.HashSet" via "Collections.HashMap" via "Collections.HashMap_Impl")
locale StdBasicSet
  fixes ops :: "('x, 's, 'more) set_basic_ops_scheme"
  assumes "StdBasicSet ops"
locale StdBasicOSet
  fixes ops :: "('x, 's, 'more) oset_basic_ops_scheme"
  assumes "StdBasicOSet ops"
locale StdBasicSetDefs
  fixes ops :: "('x, 's, 'more) set_basic_ops_scheme"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale StdBasicSet
  fixes ops :: "('x, 's, 'more) set_basic_ops_scheme"
  assumes "StdBasicSet ops"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "Draft.Graph"
### 0.561s elapsed time, 2.172s cpu time, 0.320s GC time
Loading theory "Collections.ListMapImpl_Invar" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.MapStdImpl")
### Ambiguous input (line 2939 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2"
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_union_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2"
###           ("_case1" ("_position" None)
###             ("_applC" ("_position" rbt_lookup)
###               ("_cargs" ("_position" t2) ("_position" k))))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None)
###                   ("_applC" ("_position" Some) ("_position" v)))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 2972 of "~~/src/HOL/Library/RBT_Impl.thy") produces 2 parse trees:
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case1" ("_applC" ("_position" Some) ("_position" v))
###             ("_case_syntax"
###               ("_applC" ("_position" rbt_lookup)
###                 ("_cargs" ("_position" t2) ("_position" k)))
###               ("_case2" ("_case1" ("_position" None) ("_position" None))
###                 ("_case1" ("_applC" ("_position" Some) ("_position" w))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" f)
###                       ("_cargs" ("_position" k)
###                         ("_cargs" ("_position" v)
###                           ("_position" w))))))))))))))
### ("_bigimpl"
###   ("_asms"
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rbt_sorted) ("_position" t1)))
###     ("_asm"
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" rbt_sorted) ("_position" t2)))))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>HOL.eq"
###       ("_applC" ("_position" rbt_lookup)
###         ("_cargs"
###           ("_applC" ("_position" rbt_inter_with_key)
###             ("_cargs" ("_position" f)
###               ("_cargs" ("_position" t1) ("_position" t2))))
###           ("_position" k)))
###       ("_case_syntax"
###         ("_applC" ("_position" rbt_lookup)
###           ("_cargs" ("_position" t1) ("_position" k)))
###         ("_case2" ("_case1" ("_position" None) ("_position" None))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" v))
###               ("_case_syntax"
###                 ("_applC" ("_position" rbt_lookup)
###                   ("_cargs" ("_position" t2) ("_position" k)))
###                 ("_case1" ("_position" None) ("_position" None))))
###             ("_case1" ("_applC" ("_position" Some) ("_position" w))
###               ("_applC" ("_position" Some)
###                 ("_applC" ("_position" f)
###                   ("_cargs" ("_position" k)
###                     ("_cargs" ("_position" v) ("_position" w))))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale StdBasicSet
  fixes ops :: "('x, 's, 'more) set_basic_ops_scheme"
  assumes "StdBasicSet ops"
locale StdBasicOSetDefs
  fixes ops :: "('x, 's, 'more) oset_basic_ops_scheme"
### Code generator: dropping subsumed code equation
### keys (Branch ?c ?l ?k ?v ?r) == keys ?l @ ?k # keys ?r
### Code generator: dropping subsumed code equation
### keys Empty == []
### theory "HOL-Library.RBT_Impl"
### 74.337s elapsed time, 276.153s cpu time, 121.270s GC time
Loading theory "HOL-Library.RBT" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.RBTSetImpl" via "Collections.RBTMapImpl")
locale StdBasicOSet
  fixes ops :: "('x, 's, 'more) oset_basic_ops_scheme"
  assumes "StdBasicOSet ops"
locale image_filter_cp_defs_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('y, 's2, 'more2) set_ops_scheme"
    and ops3 :: "('z, 's3, 'more3) set_ops_scheme"
### theory "Collections.ListMapImpl"
### 1.235s elapsed time, 4.774s cpu time, 0.611s GC time
Loading theory "Collections.TrieMapImpl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.TrieSetImpl")
locale image_filter_cp_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('y, 's2, 'more2) set_ops_scheme"
    and ops3 :: "('z, 's3, 'more3) set_ops_scheme"
  assumes "image_filter_cp_loc ops1 ops2 ops3"
locale inj_image_filter_cp_defs_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('y, 's2, 'more2) set_ops_scheme"
    and ops3 :: "('z, 's3, 'more3) set_ops_scheme"
### theory "HOL-Library.RBT"
### 0.568s elapsed time, 2.196s cpu time, 0.254s GC time
Loading theory "Collections.RBT_add" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_RBT_Map")
locale inj_image_filter_cp_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('y, 's2, 'more2) set_ops_scheme"
    and ops3 :: "('z, 's3, 'more3) set_ops_scheme"
  assumes "inj_image_filter_cp_loc ops1 ops2 ops3"
locale cart_defs_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('y, 's2, 'more2) set_ops_scheme"
    and ops3 :: "('x * 'y, 's3, 'more3) set_ops_scheme"
locale cart_loc
  fixes ops1 :: "('x, 's1, 'more1) set_ops_scheme"
    and ops2 :: "('y, 's2, 'more2) set_ops_scheme"
    and ops3 :: "('x * 'y, 's3, 'more3) set_ops_scheme"
  assumes "cart_loc ops1 ops2 ops3"
### theory "Collections.SetGA"
### 3.573s elapsed time, 13.864s cpu time, 1.901s GC time
Loading theory "Collections.ListSetImpl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl")
consts
  rm_iterateoi ::
    "('k, 'v) rbt
     => ('\<sigma> => bool)
        => ('k * 'v => '\<sigma> => '\<sigma>) => '\<sigma> => '\<sigma>"
consts
  rm_reverse_iterateoi ::
    "('k, 'v) rbt
     => ('\<sigma> => bool)
        => ('k * 'v => '\<sigma> => '\<sigma>) => '\<sigma> => '\<sigma>"
### theory "Collections.TrieMapImpl"
### 1.380s elapsed time, 5.248s cpu time, 0.983s GC time
Loading theory "Collections.ListSetImpl_Invar" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl")
### theory "Collections.ListMapImpl_Invar"
### 2.058s elapsed time, 7.877s cpu time, 1.275s GC time
Loading theory "Collections.ListSetImpl_NotDist" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl")
consts
  bheight_aux :: "('a, 'b) rbt => nat => nat"
### theory "Collections.RBT_add"
### 1.587s elapsed time, 5.995s cpu time, 1.212s GC time
Loading theory "Collections.ListSetImpl_Sorted" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl")
### theory "Collections.ListSetImpl"
### 1.483s elapsed time, 5.496s cpu time, 1.268s GC time
Loading theory "Collections.SetByMap" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.RBTSetImpl")
locale SetByMapDefs
  fixes ops :: "('x, unit, 's, 'more) map_basic_ops_scheme"
locale SetByMap
  fixes ops :: "('x, unit, 's, 'more) map_basic_ops_scheme"
  assumes "SetByMap ops"
locale OSetByOMapDefs
  fixes ops :: "('x, unit, 's, 'more) omap_basic_ops_scheme"
### theory "Collections.ListSetImpl_Invar"
### 3.847s elapsed time, 14.409s cpu time, 9.725s GC time
Loading theory "Collections.RBTMapImpl" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NBA_Translate" via "Transition_Systems_and_Automata.NBA_Explicit" via "Transition_Systems_and_Automata.NBA_Algorithms" via "Transition_Systems_and_Automata.NBA_Graphs" via "CAVA_Automata.Automata_Impl" via "CAVA_Automata.Digraph_Impl" via "CAVA_Automata.Digraph" via "CAVA_Base.CAVA_Base" via "Collections.CollectionsV1" via "Collections.Collections" via "Collections.ICF_Impl" via "Collections.SetStdImpl" via "Collections.RBTSetImpl")
locale OSetByOMap
  fixes ops :: "('x, unit, 's, 'more) omap_basic_ops_scheme"
  assumes "OSetByOMap ops"
### theory "Collections.ListSetImpl_NotDist"
### 4.182s elapsed time, 15.739s cpu time, 9.801s GC time
Loading theory "Collections.Impl_RBT_Map" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF")
### theory "Collections.SetByMap"
### 3.984s elapsed time, 15.184s cpu time, 9.411s GC time
Loading theory "Draft.Ranking" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Draft.Complementation")
Proofs for inductive predicate(s) "color_relp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rbt_rel_auxp"
  Proving monotonicity ...
### theory "Draft.Ranking"
### 0.774s elapsed time, 3.049s cpu time, 0.503s GC time
Loading theory "Draft.Complementation" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement")
### theory "Collections.ListSetImpl_Sorted"
### 5.137s elapsed time, 19.580s cpu time, 10.221s GC time
Loading theory "Transition_Systems_and_Automata.NGBA" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NGBA_Algorithms" via "Transition_Systems_and_Automata.NGBA_Graphs")
### theory "Draft.Complementation"
### 0.545s elapsed time, 2.153s cpu time, 0.249s GC time
Loading theory "Transition_Systems_and_Automata.Transition_System_Refine" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.NBA_Refine")
### theory "Transition_Systems_and_Automata.Transition_System_Refine"
### 0.570s elapsed time, 2.247s cpu time, 0.381s GC time
Loading theory "Transition_Systems_and_Automata.NBA_Refine" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement")
### theory "Transition_Systems_and_Automata.NGBA"
### 1.206s elapsed time, 4.751s cpu time, 0.722s GC time
Loading theory "Transition_Systems_and_Automata.NBA_Combine" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NGBA_Algorithms")
### theory "Collections.RBTMapImpl"
### 2.939s elapsed time, 11.576s cpu time, 1.606s GC time
Loading theory "Transition_Systems_and_Automata.NGBA_Refine" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Transition_Systems_and_Automata.NGBA_Algorithms" via "Transition_Systems_and_Automata.NGBA_Implement")
### Removed duplicate interpretation after retrieving its mixins (line 13 of "$AFP/Transition_Systems_and_Automata/Automata/NBA/NBA.thy") (line 13 of "$AFP/Transition_Systems_and_Automata/Automata/NBA/NGBA.thy"):
###   transition_system_universal "%a p. snd a"
### theory "Transition_Systems_and_Automata.NBA_Refine"
### 0.576s elapsed time, 2.250s cpu time, 0.361s GC time
Loading theory "Native_Word.Code_Symbolic_Bits_Int" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base" via "Native_Word.Bits_Integer")
### theory "Transition_Systems_and_Automata.NGBA_Refine"
### 0.540s elapsed time, 2.125s cpu time, 0.251s GC time
val mk_2elem_list = fn: term -> term -> term
val mk_compr = fn: term -> term -> term
val test1 = "[1, 2]": cterm
val test2 = "{x: {1, 2, 3}. 2 < x}": cterm
val test3 =
   Const ("Groups.plus_class.plus", "nat => nat => nat") $ Bound 0 $
     Bound 0:
   term
val dest_pair_singleton = fn: term -> term
val dest_nat_pair_singleton = fn: term -> term * term
val dest_pair_singleton_T = fn: term -> (term * typ) * (term * typ)
val dest_pair_lambda = fn: term -> string * typ * string * typ * term * term
val foo = fn: term -> term * term * int * term * term
val it = fn:
   (theory -> theory) ->
     (Proof.context -> Proof.context) -> Context.generic -> Context.generic
"True"
  :: "bool"
\<Sqinter> (Sup ` ?A) = \<Squnion> (Inf ` {f ` ?A |f. ALL Y:?A. f Y : Y})
rank_invar (meld bq1 bq2) ==>
min (rank (link t1 t2)) (rank (hd (meld bq1 bq2)))
<= rank (hd (ins (link t1 t2) (meld bq1 bq2)))
[| ALL t:set (filter (%t. rank t = 0) (children (getMinTree q))).
      rank t = 0 & children t = [];
   queue_invar ?q |]
==> queue_to_multiset
     (insertList (filter (%t. rank t = 0) (children (getMinTree q))) ?q) =
    queue_to_multiset (filter (%t. rank t = 0) (children (getMinTree q))) +
    queue_to_multiset ?q
(0 < length ?xs) = (?xs ~= [])
"merge"
  :: "'a"
[| !!e a r ts. ?Q ts ==> ?P (SkewBinomialHeapStruc.Node e a r ts); ?Q [];
   !!t q. [| ?P t; ?Q q |] ==> ?Q (t # q) |]
==> ?P ?a0.0
[| !!e a r ts. ?Q ts ==> ?P (SkewBinomialHeapStruc.Node e a r ts); ?Q [];
   !!t q. [| ?P t; ?Q q |] ==> ?Q (t # q) |]
==> ?Q ?a1.0
val it = "foo == ANNOT foo bar": thm
val it = "foo == foo ::: bar": thm
"set_rel"
  :: "('a * 'b) set => ('a set * 'b set) set"
val it = "Ra \<times>\<^sub>r \<langle>Rb\<rangle>option_rel": cterm
val it =
   "\<langle>Id\<rangle>option_rel \<rightarrow>
    \<langle>Id\<rangle>list_rel":
   cterm
[| path ?E ?x1.0 ?x2.0 ?x3.0; !!u. ?P u [] u;
   !!u v l w.
      [| (u, v) : ?E; path ?E v l w; ?P v l w |] ==> ?P u (u # l) w |]
==> ?P ?x1.0 ?x2.0 ?x3.0
"list_update"
  :: "'a list => nat => 'a => 'a list"
val it = 4: int
val it = "(1::'a) # \<dots> # \<dots>": cterm
val it = [2, 3, 4, 5]: int list
"(o)"
  :: "('a => 'b) => ('c => 'a) => 'c => 'b"
linorder_on (?f ` ?D) ?cmp ==> linorder_on ?D (cmp_img ?f ?cmp)
"cmp_lex"
  :: "('a => 'b => comp_res) => 'a list => 'b list => comp_res"
"cmp_prod"
  :: "('a => 'b => comp_res)
      => ('c => 'd => comp_res) => 'a * 'c => 'b * 'd => comp_res"
[| inj_on ?f ?A; ?B <= ?A |] ==> inj_on ?f ?B
[| inj_on ?f ?B; ?A <= ?B |] ==> inj_on ?f ?A
theorem flatf_fp_induct_pointwise:
  fixes pre :: "'a => 'b => bool"
    and post :: "'a => 'b => 'c => bool"
    and b :: "'c"
    and B :: "('b => 'c) => 'b => 'c"
    and a :: "'a"
    and x :: "'b"
  assumes "!!a x. pre a x ==> post a x b"
    and "flatf_mono b B"
    and "pre a x"
    and
    "!!f a x.
        [| !!a' x'. pre a' x' ==> post a' x' (f x'); pre a x;
           flatf_ord b f (flatf_fp b B) |]
        ==> post a x (B f x)"
  shows "post a x (flatf_fp b B x)"
[| RETURN ?tsl <= ?tsl';
   !!x \<sigma>. RETURN (?f x \<sigma>) <= ?f' x \<sigma> |]
==> RETURN (foldli ?tsl ?c ?f ?\<sigma>)
    <= LIST_FOREACH' ?tsl' ?c ?f' ?\<sigma>
[| ?\<sigma> ~= dSUCCEED; !!x \<sigma>. ?f x \<sigma> ~= dSUCCEED |]
==> foldli ?l ?c (%x s. s >>= ?f x) ?\<sigma> ~= dSUCCEED
(!!x s. nres_of (?f x s) <= ?f' x s) ==>
nres_of
 (foldli ?l (case_dres False False ?c) (%x s. s >>= ?f x) (dRETURN ?s))
<= nfoldli ?l ?c ?f' ?s
(!!x s. RETURN (?f x s) <= ?f' x s) ==>
RETURN (foldli ?l ?c ?f ?s) <= nfoldli ?l ?c ?f' ?s
[| ?\<Phi>; ?\<Phi> ==> RETURN ?M <= ?M' |]
==> RETURN ?M <= ASSUME ?\<Phi> >>= (%_. ?M')
(?\<Phi> ==> RETURN ?M <= ?M') ==> RETURN ?M <= ASSERT ?\<Phi> >>= (%_. ?M')
[| RETURN ?x <= ?M; !!x. RETURN (?f x) <= ?F x |]
==> RETURN (Let ?x ?f) <= ?M >>= ?F
RETURN ?a <= RETURN ?a
[| !!x. ?fr x = ?b ?fr x;
   !!F f x. (!!x. RETURN (f x) <= F x) ==> RETURN (?b f x) <= ?B F x |]
==> RETURN (?fr ?x) <= REC\<^sub>T ?B ?x
[| !!s. RETURN (?fn s) <= ?fn' s;
   !!n rec rec' s.
      (!!s. RETURN (rec s) <= rec' s) ==>
      RETURN (?fs n rec s) <= ?fs' n rec' s |]
==> RETURN (rec_nat ?fn ?fs ?n ?s) <= rec_nat ?fn' ?fs' ?n ?s
[| !!s. RETURN (?fn s) <= ?fn' s;
   !!x l rec rec' s.
      (!!s. RETURN (rec s) <= rec' s) ==>
      RETURN (?fc x l rec s) <= ?fc' x l rec' s |]
==> RETURN (rec_list ?fn ?fc ?l ?s) <= rec_list ?fn' ?fc' ?l ?s
[| RETURN ?fn <= ?Fn; !!x xs. RETURN (?fc x xs) <= ?Fc x xs |]
==> RETURN (case ?l of [] => ?fn | x # xa => ?fc x xa)
    <= (case ?l of [] => ?Fn | x # xa => ?Fc x xa)
[| !!l. RETURN (?fl l) <= ?Fl l; !!r. RETURN (?fr r) <= ?Fr r |]
==> RETURN (case ?x of Inl x => ?fl x | Inr x => ?fr x)
    <= (case ?x of Inl x => ?Fl x | Inr x => ?Fr x)
[| RETURN ?fa <= ?Fa; !!x. RETURN (?fb x) <= ?Fb x |]
==> RETURN (case ?x of None => ?fa | Some x => ?fb x)
    <= (case ?x of None => ?Fa | Some x => ?Fb x)
(!!x. RETURN (?f x) <= ?F x) ==> RETURN (Let ?x ?f) <= Let ?x ?F
(!!a b. RETURN (?f a b) <= ?F a b) ==>
RETURN (case ?x of (x, xa) => ?f x xa) <= (case ?x of (x, xa) => ?F x xa)
[| ?b ==> RETURN ?s1.0 <= ?S1.0; ~ ?b ==> RETURN ?s2.0 <= ?S2.0 |]
==> RETURN (if ?b then ?s1.0 else ?s2.0) <= (if ?b then ?S1.0 else ?S2.0)
(!!x. nres_of (?f x) <= ?F x) ==>
nres_of (dWHILET ?b ?f ?x) <= WHILE\<^sub>T ?b ?F ?x
(!!x. nres_of (?f x) <= ?F x) ==>
nres_of (dWHILE ?b ?f ?x) <= WHILE ?b ?F ?x
(!!x. nres_of (?f x) <= ?F x) ==>
nres_of (dWHILEI ?I ?b ?f ?x) <= WHILE\<^bsup>?I\<^esup> ?b ?F ?x
(!!x. nres_of (?f x) <= ?F x) ==>
nres_of (dWHILEIT ?I ?b ?f ?x) <= WHILE\<^sub>T\<^bsup>?I\<^esup> ?b ?F ?x
[| ?\<Phi>; ?\<Phi> ==> nres_of ?M <= ?M' |]
==> nres_of ?M <= ASSUME ?\<Phi> >>= (%_. ?M')
(?\<Phi> ==> nres_of ?M <= ?M') ==>
nres_of ?M <= ASSERT ?\<Phi> >>= (%_. ?M')
[| nres_of ?m <= ?M; !!x. nres_of (?f x) <= ?F x |]
==> nres_of (?m >>= ?f) <= ?M >>= ?F
nres_of (dRETURN ?x) <= RETURN ?x
nres_of dSUCCEED <= SUCCEED
nres_of dFAIL <= FAIL
nres_of ?x <= nres_of ?x
[| !!F f x. (!!x. nres_of (f x) <= F x) ==> nres_of (?b f x) <= ?B F x;
   trimono ?b |]
==> nres_of (REC ?b ?x) <= REC ?B ?x
[| !!F f x. (!!x. nres_of (f x) <= F x) ==> nres_of (?b f x) <= ?B F x;
   trimono ?b |]
==> nres_of (REC\<^sub>T ?b ?x) <= REC\<^sub>T ?B ?x
[| !!x. ?fr x = ?b ?fr x;
   !!F f x. (!!x. nres_of (f x) <= F x) ==> nres_of (?b f x) <= ?B F x |]
==> nres_of (?fr ?x) <= REC\<^sub>T ?B ?x
[| !!s. nres_of (?fn s) <= ?fn' s;
   !!n rec rec' s.
      (!!s. nres_of (rec s) <= rec' s) ==>
      nres_of (?fs n rec s) <= ?fs' n rec' s |]
==> nres_of (rec_nat ?fn ?fs ?n ?s) <= rec_nat ?fn' ?fs' ?n ?s
[| !!s. nres_of (?fn s) <= ?fn' s;
   !!x l rec rec' s.
      (!!s. nres_of (rec s) <= rec' s) ==>
      nres_of (?fc x l rec s) <= ?fc' x l rec' s |]
==> nres_of (rec_list ?fn ?fc ?l ?s) <= rec_list ?fn' ?fc' ?l ?s
[| nres_of ?fn <= ?Fn; !!x xs. nres_of (?fc x xs) <= ?Fc x xs |]
==> nres_of (case ?l of [] => ?fn | x # xa => ?fc x xa)
    <= (case ?l of [] => ?Fn | x # xa => ?Fc x xa)
[| !!l. nres_of (?fl l) <= ?Fl l; !!r. nres_of (?fr r) <= ?Fr r |]
==> nres_of (case ?x of Inl x => ?fl x | Inr x => ?fr x)
    <= (case ?x of Inl x => ?Fl x | Inr x => ?Fr x)
[| nres_of ?fa <= ?Fa; !!x. nres_of (?fb x) <= ?Fb x |]
==> nres_of (case ?x of None => ?fa | Some x => ?fb x)
    <= (case ?x of None => ?Fa | Some x => ?Fb x)
(!!x. nres_of (?f x) <= ?F x) ==> nres_of (Let ?x ?f) <= Let ?x ?F
(!!a b. nres_of (?f a b) <= ?F a b) ==>
nres_of (case ?x of (x, xa) => ?f x xa) <= (case ?x of (x, xa) => ?F x xa)
[| ?b ==> nres_of ?s1.0 <= ?S1.0; ~ ?b ==> nres_of ?s2.0 <= ?S2.0 |]
==> nres_of (if ?b then ?s1.0 else ?s2.0) <= (if ?b then ?S1.0 else ?S2.0)
(!!x. RETURN (?f x) <= ?F x) ==>
RETURN (while ?b ?f ?x) <= WHILE\<^sub>T ?b ?F ?x
(!!x. RETURN (?f x) <= ?F x) ==>
RETURN (while ?b ?f ?x) <= WHILE\<^sub>T\<^bsup>?I\<^esup> ?b ?F ?x
(!!x. ?f x ~= dSUCCEED) ==> dWHILET ?b ?f ?s ~= dSUCCEED
(!!x. ?f x ~= dSUCCEED) ==> dWHILEIT ?I ?b ?f ?s ~= dSUCCEED
(!!f x. (!!x. f x ~= dSUCCEED) ==> ?B f x ~= dSUCCEED) ==>
REC\<^sub>T ?B ?x ~= dSUCCEED
[| ?fn ~= dSUCCEED; !!x xs. ?fc x xs ~= dSUCCEED |]
==> (case ?x of [] => ?fn | x # xa => ?fc x xa) ~= dSUCCEED
[| ?fn ~= dSUCCEED; !!v. ?fs v ~= dSUCCEED |]
==> (case ?x of None => ?fn | Some x => ?fs x) ~= dSUCCEED
(!!x1 x2. ?g x1 x2 ~= dSUCCEED) ==>
(case ?p of (x, xa) => ?g x xa) ~= dSUCCEED
(!!x. ?f x ~= dSUCCEED) ==> Let ?x ?f ~= dSUCCEED
[| ?m1.0 ~= dSUCCEED; ?m2.0 ~= dSUCCEED |]
==> (if ?b then ?m1.0 else ?m2.0) ~= dSUCCEED
dASSERT ?\<Phi> ~= dSUCCEED
[| ?m ~= dSUCCEED; !!x. ?f x ~= dSUCCEED |] ==> ?m >>= ?f ~= dSUCCEED
dRETURN ?x ~= dSUCCEED
dFAIL ~= dSUCCEED
(!!x. dRETURN (?f x) <= ?F x) ==>
dRETURN (while ?b ?f ?x) <= dWHILET ?b ?F ?x
(!!x. dRETURN (?f x) <= ?F x) ==>
dRETURN (while ?b ?f ?x) <= dWHILEIT ?I ?b ?F ?x
rel_fun (rel_fun ?A ?B) (rel_fun (rel_set ?A) (rel_set ?B)) (`) (`)
((`), (`))
: (?A \<rightarrow> ?B) \<rightarrow>
  \<langle>?A\<rangle>set_rel \<rightarrow> \<langle>?B\<rangle>set_rel
bi_unique ?A ==>
rel_fun (rel_fun ?A ?B) (rel_fun ?A (rel_fun ?B (rel_fun ?A ?B))) fun_upd
 fun_upd
bijective ?A ==>
(fun_upd, fun_upd)
: (?A \<rightarrow> ?B) \<rightarrow>
  ?A \<rightarrow> ?B \<rightarrow> ?A \<rightarrow> ?B
single_valued ?Ra ==>
(set, set)
: \<langle>?Ra\<rangle>list_rel \<rightarrow> \<langle>?Ra\<rangle>set_rel
(set, set)
: \<langle>?R\<rangle>list_rel \<rightarrow> \<langle>?R\<rangle>set_rel
"(((set \<circ>\<circ> map) f \<circ>\<circ> map) g \<circ>\<circ> map) h"
  :: "'c list => 'b set"
"(set \<circ>\<circ> sort_key) (%x. x)"
  :: "'a list => 'a set"
"op_map_restrict"
  :: "('a * 'b => bool) => ('a => 'b option) => 'a => 'b option"
is_map_to_list ?Rk ?Rv ?Rm ?tsl ==
is_map_to_sorted_list (%_ _. True) ?Rk ?Rv ?Rm ?tsl
[| is_map_to_sorted_list ?ordR ?Rk ?Rv ?Rm ?tsl;
   (?m, ?m') : \<langle>?Rk, ?Rv\<rangle>?Rm;
   !!l'. [| (?tsl ?m, l')
            : \<langle>?Rk \<times>\<^sub>r ?Rv\<rangle>list_rel;
            RETURN l'
            <= it_to_sorted_list (key_rel ?ordR) (map_to_set ?m') |]
         ==> ?thesis |]
==> ?thesis
\<langle>?Rk, ?Rv\<rangle>list_map_rel =
\<langle>?Rk \<times>\<^sub>r ?Rv\<rangle>list_rel O
br map_of list_map_invar
List.insert ?x ?xs = (if ?x : set ?xs then ?xs else ?x # ?xs)
[| (?x, color.R) : color_rel; ?x = color.R ==> ?P |] ==> ?P
[| (?x, color.B) : color_rel; ?x = color.B ==> ?P |] ==> ?P
[| (color.R, ?y) : color_rel; ?y = color.R ==> ?P |] ==> ?P
[| (color.B, ?y) : color_rel; ?y = color.B ==> ?P |] ==> ?P
"rbt_insert"
  :: "'a => 'b => ('a, 'b) rbt => ('a, 'b) rbt"
"balance_left"
  :: "('a, 'b) rbt => 'a => 'b => ('a, 'b) rbt => ('a, 'b) rbt"
"balance_right"
  :: "('a, 'b) rbt => 'a => 'b => ('a, 'b) rbt => ('a, 'b) rbt"
"ord.rbt_insert_with_key"
  :: "('a => 'a => bool)
      => ('a => 'b => 'b => 'b) => 'a => 'b => ('a, 'b) rbt => ('a, 'b) rbt"
"RBT_Impl.skip_red"
  :: "('a, 'b) rbt => ('a, 'b) rbt"
"case_rbt"
  :: "'a => (color => ('b, 'c) rbt => 'b => 'c => ('b, 'c) rbt => 'a)
            => ('b, 'c) rbt => 'a"
"rm_iterateoi"
  :: "('a, 'b) rbt => ('c => bool) => ('a * 'b => 'c => 'c) => 'c => 'c"
"bheight"
  :: "('a, 'b) rbt => nat"
"ord.rbt_less"
  :: "('a => 'a => bool) => 'a => ('a, 'b) rbt => bool"
"ord.rbt_greater"
  :: "('a => 'a => bool) => 'a => ('a, 'b) rbt => bool"
### theory "Transition_Systems_and_Automata.NBA_Combine"
### 0.955s elapsed time, 3.846s cpu time, 0.514s GC time
### theory "Native_Word.Code_Symbolic_Bits_Int"
### 0.590s elapsed time, 2.359s cpu time, 0.246s GC time
Loading theory "Native_Word.Bits_Integer" (required by "Draft.Complementation_BuildMoreTemplates" via "Draft.Complementation_Build" via "Draft.Complementation_Final" via "Draft.Complementation_Implement" via "Transition_Systems_and_Automata.NBA_Implement" via "Transition_Systems_and_Automata.Implement" via "Collections.Refine_Dflt" via "Collections.GenCF" via "Collections.Impl_Array_Hash_Map" via "Collections.Intf_Hash" via "Collections.HashCode" via "Native_Word.Uint32" via "Native_Word.Code_Target_Word_Base")
instantiation
  integer :: lsb
  lsb_integer == lsb :: integer => bool
instantiation
  integer :: msb
  msb_integer == msb :: integer => bool
instantiation
  integer :: set_bit
  set_bit_integer == set_bit_class.set_bit ::
    integer => nat => bool => integer
### Code generator: dropping subsumed code equation
### not ?k == - ?k - 1
### Code generator: dropping subsumed code equation
### and ?k ?l ==
### if ?k = 0 | ?l = 0 then 0
### else if ?k = - 1 then ?l
###      else if ?l = - 1 then ?k
###           else ?k mod 2 * (?l mod 2) + 2 * and (?k div 2) (?l div 2)
### Code generator: dropping subsumed code equation
### or ?k ?l ==
### if ?k = - 1 | ?l = - 1 then - 1
### else if ?k = 0 then ?l
###      else if ?l = 0 then ?k
###           else max (?k mod 2) (?l mod 2) + 2 * or (?k div 2) (?l div 2)
### Code generator: dropping subsumed code equation
### xor ?k ?l ==
### if ?k = - 1 then not ?l
### else if ?l = - 1 then not ?k
###      else if ?k = 0 then ?l
###           else if ?l = 0 then ?k
###                else \<bar>?k mod 2 - ?l mod 2\<bar> +
###                     2 * xor (?k div 2) (?l div 2)
### theory "Native_Word.Bits_Integer"
### 1.051s elapsed time, 3.222s cpu time, 0.487s GC time
### theory "Collections.Impl_RBT_Map"
### 5.180s elapsed time, 18.391s cpu time, 2.638s GC time
*** Failed to load theory "Collections.Impl_Array_Stack" (unresolved "Collections.Diff_Array")
*** Failed to load theory "Collections.Array_Iterator" (unresolved "Collections.Diff_Array")
*** Failed to load theory "Collections.FTPrioImpl" (unresolved "Collections.FTAnnotatedListImpl")
*** Failed to load theory "Collections.Impl_Array_Map" (unresolved "Collections.Diff_Array")
*** Failed to load theory "Collections.FTPrioUniqueImpl" (unresolved "Collections.FTAnnotatedListImpl")
*** Failed to load theory "Collections.ArrayMapImpl" (unresolved "Collections.Diff_Array")
*** Failed to load theory "Collections.ArraySetImpl" (unresolved "Collections.ArrayMapImpl")
*** Failed to load theory "Collections.TrieSetImpl" (unresolved "Collections.TrieMapImpl")
*** Failed to load theory "Collections.RBTSetImpl" (unresolved "Collections.RBTMapImpl")
*** Failed to load theory "Collections.Impl_Bit_Set" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Native_Word.Code_Target_Bits_Int" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Native_Word.Code_Target_Word_Base" (unresolved "Native_Word.Bits_Integer")
*** Failed to load theory "Native_Word.Word_Type_Copies" (unresolved "Native_Word.Code_Target_Word_Base")
*** Failed to load theory "Collections.Code_Target_ICF" (unresolved "Native_Word.Code_Target_Bits_Int")
*** Failed to load theory "Native_Word.Uint" (unresolved "Native_Word.Code_Target_Word_Base", "Native_Word.Word_Type_Copies")
*** Failed to load theory "Native_Word.Uint32" (unresolved "Native_Word.Code_Target_Word_Base", "Native_Word.Word_Type_Copies")
*** Failed to load theory "Collections.Impl_Uv_Set" (unresolved "Native_Word.Uint")
*** Failed to load theory "Collections.HashCode" (unresolved "Native_Word.Uint32")
*** Failed to load theory "Collections.HashMap_Impl" (unresolved "Collections.Code_Target_ICF", "Collections.HashCode", "Collections.ListMapImpl", "Collections.RBTMapImpl")
*** Failed to load theory "Collections.ArrayHashMap_Impl" (unresolved "Collections.Array_Iterator", "Collections.Code_Target_ICF", "Collections.Diff_Array", "Collections.HashCode", "Collections.ListMapImpl")
*** Failed to load theory "Collections.HashMap" (unresolved "Collections.HashMap_Impl")
*** Failed to load theory "Collections.ArrayHashMap" (unresolved "Collections.ArrayHashMap_Impl")
*** Failed to load theory "Collections.HashSet" (unresolved "Collections.HashMap")
*** Failed to load theory "Collections.Intf_Hash" (unresolved "Collections.Code_Target_ICF", "Collections.HashCode")
*** Failed to load theory "Collections.Gen_Hash" (unresolved "Collections.Intf_Hash")
*** Failed to load theory "Collections.Impl_Array_Hash_Map" (unresolved "Collections.Array_Iterator", "Collections.Code_Target_ICF", "Collections.Diff_Array", "Collections.HashCode", "Collections.Intf_Hash")
*** Failed to load theory "Collections.ArrayHashSet" (unresolved "Collections.ArrayHashMap")
*** Failed to load theory "Collections.MapStdImpl" (unresolved "Collections.ArrayHashMap", "Collections.ArrayMapImpl", "Collections.HashMap", "Collections.ListMapImpl", "Collections.ListMapImpl_Invar", "Collections.RBTMapImpl", "Collections.TrieMapImpl")
*** Failed to load theory "Collections.SetStdImpl" (unresolved "Collections.ArrayHashSet", "Collections.ArraySetImpl", "Collections.HashSet", "Collections.ListSetImpl", "Collections.ListSetImpl_Invar", "Collections.ListSetImpl_NotDist", "Collections.ListSetImpl_Sorted", "Collections.RBTSetImpl", "Collections.TrieSetImpl")
*** Failed to load theory "Collections.ICF_Impl" (unresolved "Collections.BinoPrioImpl", "Collections.FTAnnotatedListImpl", "Collections.FTPrioImpl", "Collections.FTPrioUniqueImpl", "Collections.Fifo", "Collections.MapStdImpl", "Collections.SetStdImpl", "Collections.SkewPrioImpl")
*** Failed to load theory "Collections.ICF_Refine_Monadic" (unresolved "Collections.ICF_Impl")
*** Failed to load theory "Collections.ICF_Autoref" (unresolved "Collections.ICF_Refine_Monadic")
*** Failed to load theory "Collections.Collections" (unresolved "Collections.ICF_Autoref", "Collections.ICF_Impl", "Collections.ICF_Refine_Monadic")
*** Failed to load theory "Collections.CollectionsV1" (unresolved "Collections.Collections")
*** Failed to load theory "Collections.GenCF" (unresolved "Collections.Code_Target_ICF", "Collections.Gen_Hash", "Collections.Impl_Array_Hash_Map", "Collections.Impl_Array_Map", "Collections.Impl_Array_Stack", "Collections.Impl_Bit_Set", "Collections.Impl_Uv_Set")
*** Failed to load theory "Collections.Refine_Dflt" (unresolved "Collections.Code_Target_ICF", "Collections.GenCF")
*** Failed to load theory "CAVA_Base.Code_String" (unresolved "Collections.Refine_Dflt")
*** Failed to load theory "Transition_Systems_and_Automata.Implement" (unresolved "Collections.Refine_Dflt")
*** Failed to load theory "CAVA_Base.CAVA_Code_Target" (unresolved "CAVA_Base.Code_String", "Collections.Code_Target_ICF")
*** Failed to load theory "Transition_Systems_and_Automata.NBA_Implement" (unresolved "Transition_Systems_and_Automata.Implement")
*** Failed to load theory "Transition_Systems_and_Automata.NGBA_Implement" (unresolved "Transition_Systems_and_Automata.Implement")
*** Failed to load theory "CAVA_Base.CAVA_Base" (unresolved "CAVA_Base.CAVA_Code_Target", "Collections.CollectionsV1", "Collections.Refine_Dflt")
*** Failed to load theory "CAVA_Automata.Digraph" (unresolved "CAVA_Base.CAVA_Base")
*** Failed to load theory "DFS_Framework.Impl_Rev_Array_Stack" (unresolved "CAVA_Base.CAVA_Base")
*** Failed to load theory "Draft.Complementation_Implement" (unresolved "Transition_Systems_and_Automata.NBA_Implement")
*** Failed to load theory "CAVA_Automata.Automata" (unresolved "CAVA_Automata.Digraph")
*** Failed to load theory "CAVA_Automata.Digraph_Impl" (unresolved "CAVA_Automata.Digraph")
*** Failed to load theory "CAVA_Automata.Lasso" (unresolved "CAVA_Automata.Automata")
*** Failed to load theory "CAVA_Automata.Automata_Impl" (unresolved "CAVA_Automata.Automata", "CAVA_Automata.Digraph_Impl")
*** Failed to load theory "Transition_Systems_and_Automata.NBA_Graphs" (unresolved "CAVA_Automata.Automata_Impl")
*** Failed to load theory "Transition_Systems_and_Automata.NGBA_Graphs" (unresolved "CAVA_Automata.Automata_Impl")
*** Failed to load theory "Gabow_SCC.Gabow_Skeleton" (unresolved "CAVA_Automata.Digraph")
*** Failed to load theory "DFS_Framework.Param_DFS" (unresolved "CAVA_Automata.Digraph", "CAVA_Base.CAVA_Base")
*** Failed to load theory "DFS_Framework.DFS_Invars_Basic" (unresolved "DFS_Framework.Param_DFS")
*** Failed to load theory "DFS_Framework.General_DFS_Structure" (unresolved "DFS_Framework.Param_DFS")
*** Failed to load theory "DFS_Framework.Rec_Impl" (unresolved "DFS_Framework.General_DFS_Structure")
*** Failed to load theory "DFS_Framework.Tailrec_Impl" (unresolved "DFS_Framework.General_DFS_Structure")
*** Failed to load theory "Gabow_SCC.Find_Path" (unresolved "CAVA_Automata.Digraph", "CAVA_Base.CAVA_Code_Target")
*** Failed to load theory "Gabow_SCC.Gabow_Skeleton_Code" (unresolved "CAVA_Automata.Digraph_Impl", "CAVA_Base.CAVA_Code_Target", "Gabow_SCC.Gabow_Skeleton")
*** Failed to load theory "Gabow_SCC.Find_Path_Impl" (unresolved "CAVA_Automata.Digraph_Impl", "Gabow_SCC.Find_Path")
*** Failed to load theory "Gabow_SCC.Gabow_GBG" (unresolved "CAVA_Automata.Lasso", "Gabow_SCC.Find_Path", "Gabow_SCC.Gabow_Skeleton")
*** Failed to load theory "DFS_Framework.Simple_Impl" (unresolved "DFS_Framework.Rec_Impl", "DFS_Framework.Tailrec_Impl")
*** Failed to load theory "Gabow_SCC.Gabow_GBG_Code" (unresolved "CAVA_Automata.Automata_Impl", "CAVA_Base.CAVA_Code_Target", "Gabow_SCC.Find_Path_Impl", "Gabow_SCC.Gabow_GBG", "Gabow_SCC.Gabow_Skeleton_Code")
*** Failed to load theory "DFS_Framework.Restr_Impl" (unresolved "DFS_Framework.Simple_Impl")
*** Failed to load theory "DFS_Framework.DFS_Framework" (unresolved "DFS_Framework.DFS_Invars_Basic", "DFS_Framework.Param_DFS", "DFS_Framework.Rec_Impl", "DFS_Framework.Restr_Impl", "DFS_Framework.Simple_Impl", "DFS_Framework.Tailrec_Impl")
*** Failed to load theory "DFS_Framework.Reachable_Nodes" (unresolved "CAVA_Automata.Digraph_Impl", "DFS_Framework.DFS_Framework", "DFS_Framework.Impl_Rev_Array_Stack")
*** Failed to load theory "Transition_Systems_and_Automata.NBA_Algorithms" (unresolved "DFS_Framework.Reachable_Nodes", "Gabow_SCC.Gabow_GBG_Code", "Transition_Systems_and_Automata.NBA_Graphs", "Transition_Systems_and_Automata.NBA_Implement")
*** Failed to load theory "Transition_Systems_and_Automata.NBA_Explicit" (unresolved "Transition_Systems_and_Automata.NBA_Algorithms")
*** Failed to load theory "Transition_Systems_and_Automata.NGBA_Algorithms" (unresolved "Transition_Systems_and_Automata.NBA_Algorithms", "Transition_Systems_and_Automata.NGBA_Graphs", "Transition_Systems_and_Automata.NGBA_Implement")
*** Failed to load theory "Transition_Systems_and_Automata.NBA_Translate" (unresolved "Transition_Systems_and_Automata.NBA_Explicit")
*** Failed to load theory "Draft.Complementation_Final" (unresolved "Draft.Complementation_Implement", "Transition_Systems_and_Automata.NBA_Translate", "Transition_Systems_and_Automata.NGBA_Algorithms")
*** Failed to load theory "Draft.Complementation_Build" (unresolved "Draft.Complementation_Final")
*** Failed to load theory "Draft.Complementation_BuildMoreTemplates" (unresolved "Draft.Complementation_Build")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "28")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 653 of "$AFP/Native_Word/Bits_Integer.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "26")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 135 of "$AFP/Collections/ICF/impl/RBTMapImpl.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "24")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 298 of "$AFP/Collections/ICF/impl/ListSetImpl_Sorted.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "22")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 202 of "$AFP/Collections/ICF/impl/ListSetImpl_NotDist.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "20")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 105 of "$AFP/Collections/ICF/impl/ListSetImpl_Invar.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "18")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 120 of "$AFP/Collections/ICF/impl/ListSetImpl.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "16")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 155 of "$AFP/Collections/ICF/impl/ListMapImpl_Invar.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "14")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 163 of "$AFP/Collections/ICF/impl/TrieMapImpl.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "12")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 101 of "$AFP/Collections/ICF/impl/ListMapImpl.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "10")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 110 of "$AFP/Collections/ICF/impl/SkewPrioImpl.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "8")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 114 of "$AFP/Collections/ICF/impl/BinoPrioImpl.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "6")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 219 of "$AFP/Collections/ICF/impl/FTAnnotatedListImpl.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "4")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 224 of "$AFP/Collections/ICF/impl/Fifo.thy")
*** exception Protocol_Message
***   [("function", "invoke_scala"), ("name", "make_directory"), ("id", "2")] raised (line 124 of "General/output.ML")
*** At command "export_code" (line 1067 of "$AFP/Collections/Lib/Diff_Array.thy")
Exception- TOPLEVEL_ERROR raised
