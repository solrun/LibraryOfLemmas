Loading theory "Draft.HOL_Base" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.Order_Thms" via "Draft.Logic_Thms" via "Draft.Auto2_HOL")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
### theory "Draft.HOL_Base"
### 0.062s elapsed time, 0.284s cpu time, 0.000s GC time
Loading theory "Draft.Auto2_HOL" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.Order_Thms" via "Draft.Logic_Thms")
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.136s elapsed time, 0.564s cpu time, 0.040s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Set_Algebras"
### 0.205s elapsed time, 0.839s cpu time, 0.040s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "size_list size <*mlex*> {}"
signature BASIC_UTIL =
  sig
    val apply_to_lhs: conv -> thm -> thm
    val apply_to_rhs: conv -> thm -> thm
    val apply_to_thm: conv -> thm -> thm
    val assert: bool -> string -> unit
    val dest_arg: term -> term
    val dest_arg1: term -> term
    val filter_split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val fo_init: Type.tyenv * Envir.tenv
    val lookup_inst: Type.tyenv * Envir.tenv -> string -> term
    val lookup_instn: Type.tyenv * Envir.tenv -> string * int -> term
    val meta_sym: thm -> thm
    val propT: typ
    val the_pair: 'a list -> 'a * 'a
    val the_triple: 'a list -> 'a * 'a * 'a
    val trace_fullthm: Proof.context -> string -> thm -> unit
    val trace_fullthm_global: string -> thm -> unit
    val trace_t: Proof.context -> string -> term -> unit
    val trace_thm: Proof.context -> string -> thm -> unit
    val trace_thm_global: string -> thm -> unit
    val trace_tlist: Proof.context -> string -> term list -> unit
  end
signature UTIL =
  sig
    val all_pairs: 'a list * 'b list -> ('a * 'b) list
    val all_permutes: 'a list -> 'a list list
    val apply_to_lhs: conv -> thm -> thm
    val apply_to_rhs: conv -> thm -> thm
    val apply_to_thm: conv -> thm -> thm
    val arg_backn_conv: int -> conv -> conv
    val argn_conv: int -> conv -> conv
    val assert: bool -> string -> unit
    val assume_meta_eq: theory -> term * term -> thm
    val assume_thm: Proof.context -> term -> thm
    val comb_equiv: cterm * thm list -> thm
    val concl_conv: conv -> conv
    val concl_conv_n: int -> conv -> conv
    val cterm_pat_setup: theory -> theory
    val declare_free_term: term -> Proof.context -> Proof.context
    val defined_instn: Type.tyenv * Envir.tenv -> string * int -> bool
    val dest_arg: term -> term
    val dest_arg1: term -> term
    val dest_argn: int -> term -> term
    val dest_args: term -> term list
    val dest_binop: term -> term * (term * term)
    val dest_binop_args: term -> term * term
    val dest_binop_cargs: cterm -> cterm * cterm
    val dest_binop_head: term -> term
    val dest_cargs: cterm -> cterm list
    val eq_cong_th: int -> term -> term -> Proof.context -> thm
    val eq_env:
       (Type.tyenv * Envir.tenv) * (Type.tyenv * Envir.tenv) -> bool
    val exn_trace: (unit -> 'a) -> 'a
    val filter_split: ('a -> bool) -> 'a list -> 'a list * 'a list
    val first_order_match_list:
       theory ->
         (term * term) list ->
           Type.tyenv * Envir.tenv -> Type.tyenv * Envir.tenv
    val fo_init: Type.tyenv * Envir.tenv
    val forall_elim_sch: thm -> thm
    val get_head_name: term -> string
    val has_subterm: term list -> term -> bool
    val has_vars: term -> bool
    val is_abs: term -> bool
    val is_head: term -> term -> bool
    val is_implies: term -> bool
    val is_just_internal: string -> bool
    val is_meta_eq: term -> bool
    val is_pattern: term -> bool
    val is_pattern_list: term list -> bool
    val is_prefix_str: string -> string -> bool
    val is_subseq: ('a * 'a -> bool) -> 'a list * 'a list -> bool
    val is_subterm: term -> term -> bool
    val lambda_abstract: term -> term -> term
    val lhs_of: thm -> term
    val list_meta_horn: term list * (term list * term) -> term
    val lookup_inst: Type.tyenv * Envir.tenv -> string -> term
    val lookup_instn: Type.tyenv * Envir.tenv -> string * int -> term
    val lookup_tyinst: Type.tyenv * Envir.tenv -> string -> typ
    val max: ('a * 'a -> order) -> 'a list -> 'a
    val max_partial: ('a -> 'a -> bool) -> 'a list -> 'a list
    val meta_sym: thm -> thm
    val name_of_thm: thm -> string
    val normalize_meta_all_imp: Proof.context -> conv
    val normalize_meta_horn: Proof.context -> conv
    val occurs_free: term -> term -> bool
    val occurs_frees: term list -> term -> bool
    val pattern_rewr_conv: term -> (term * thm) list -> conv
    val print_term_detail: Proof.context -> term -> string
    val propT: typ
    val remove_dup_lists:
       ('a * 'a -> order) -> 'a list * 'a list -> 'a list * 'a list
    val rename_abs_term: term list -> term -> term
    val repeat_n_conv: int -> conv -> conv
    val reverse_eta_conv: Proof.context -> conv
    val rhs_of: thm -> term
    val send_all_to_hyps: thm -> thm
    val send_first_to_hyps: thm -> thm
    val skip_n_conv: int -> conv -> conv
    val string_of_bool: bool -> string
    val string_of_env: Proof.context -> Envir.tenv -> string
    val string_of_list: ('a -> string) -> 'a list -> string
    val string_of_list': ('a -> string) -> 'a list -> string
    val string_of_terms: Proof.context -> term list -> string
    val string_of_terms_global: theory -> term list -> string
    val string_of_tyenv: Proof.context -> Type.tyenv -> string
    val strip_meta_horn: term -> term list * (term list * term)
    val subsets: 'a list -> 'a list list
    val subst_term_norm: Type.tyenv * Envir.tenv -> term -> term
    val subst_thm: Proof.context -> Type.tyenv * Envir.tenv -> thm -> thm
    val subst_thm_atomic: (cterm * cterm) list -> thm -> thm
    val subst_thm_thy: theory -> Type.tyenv * Envir.tenv -> thm -> thm
    val swap_meta_imp_alls: Proof.context -> conv
    val term_pat_setup: theory -> theory
    val test_conv:
       Proof.context -> conv -> string -> string * string -> unit
    val the_pair: 'a list -> 'a * 'a
    val the_triple: 'a list -> 'a * 'a * 'a
    val timer: string * (unit -> 'a) -> 'a
    val to_internal_vars:
       Proof.context -> term list * term -> term list * term
    val trace_fullthm: Proof.context -> string -> thm -> unit
    val trace_fullthm_global: string -> thm -> unit
    val trace_t: Proof.context -> string -> term -> unit
    val trace_thm: Proof.context -> string -> thm -> unit
    val trace_thm_global: string -> thm -> unit
    val trace_tlist: Proof.context -> string -> term list -> unit
    val transitive_list: thm list -> thm
    val type_pat_setup: theory -> theory
    val update_env:
       indexname * term ->
         Type.tyenv * Envir.tenv -> Type.tyenv * Envir.tenv
    val update_name_of_thm: thm -> string -> thm -> thm
  end
structure Util: UTIL
structure Basic_Util: BASIC_UTIL
val dest_arg1 = fn: term -> term
val trace_fullthm = fn: Proof.context -> string -> thm -> unit
val propT = "prop": typ
val apply_to_rhs = fn: conv -> thm -> thm
val lookup_instn = fn: Type.tyenv * Envir.tenv -> string * int -> term
val the_triple = fn: 'a list -> 'a * 'a * 'a
val filter_split = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val trace_thm = fn: Proof.context -> string -> thm -> unit
val trace_tlist = fn: Proof.context -> string -> term list -> unit
val the_pair = fn: 'a list -> 'a * 'a
val apply_to_thm = fn: conv -> thm -> thm
val lookup_inst = fn: Type.tyenv * Envir.tenv -> string -> term
val apply_to_lhs = fn: conv -> thm -> thm
val trace_thm_global = fn: string -> thm -> unit
val trace_fullthm_global = fn: string -> thm -> unit
val assert = fn: bool -> string -> unit
val meta_sym = fn: thm -> thm
val trace_t = fn: Proof.context -> string -> term -> unit
val fo_init = ({}, {}): Type.tyenv * Envir.tenv
val dest_arg = fn: term -> term
signature BASIC_UTIL_BASE =
  sig
    val bFalse: term
    val bTrue: term
    val boolT: typ
    val cdest_eq: cterm -> cterm * cterm
    val dest_eq: term -> term * term
    val is_eq_term: term -> bool
    val mk_eq: term * term -> term
    val true_th: thm
  end
signature UTIL_BASE =
  sig
    val All_name: string
    val Ball_def_th: thm
    val Ball_name: string
    val Bex_def_th: thm
    val Bex_name: string
    val Conj_name: string
    val Disj_name: string
    val Ex_name: string
    val Imp_name: string
    val Mem_name: string
    val Not_name: string
    val Trueprop_name: string
    val all_trivial_th: thm
    val atomize_all_th: thm
    val atomize_conjL_th: thm
    val atomize_imp_th: thm
    val bFalse: term
    val bTrue: term
    val backward1_conv_th: thm
    val backward2_conv_th: thm
    val backward_conv_th: thm
    val boolT: typ
    val cConj: cterm
    val cDisj: cterm
    val cNot: cterm
    val cTrueprop: cterm
    val case_split_th: thm
    val cdest_eq: cterm -> cterm * cterm
    val conjI_th: thm
    val conj_assoc_th: thm
    val conj_commute_th: thm
    val conjunct1_th: thm
    val conjunct2_th: thm
    val contra_triv_th: thm
    val de_Morgan_conj_th: thm
    val de_Morgan_disj_th: thm
    val dest_eq: term -> term * term
    val disj_True1_th: thm
    val disj_True2_th: thm
    val disj_assoc_th: thm
    val disj_commute_th: thm
    val eq_True_inv_th: thm
    val eq_True_th: thm
    val exE_th': thm
    val ex_vardef_th: thm
    val iffD1_th: thm
    val iffD2_th: thm
    val iffD_th: thm
    val imp_conv_disj_th: thm
    val inv_back_th: thm
    val is_eq_term: term -> bool
    val is_if: term -> bool
    val mk_eq: term * term -> term
    val mk_setT: typ -> typ
    val nn_cancel_th: thm
    val nn_create_th: thm
    val not_all_th: thm
    val not_ex_th: thm
    val not_imp_th: thm
    val obj_sym_cv: conv
    val or_cancel1_th: thm
    val or_cancel2_th: thm
    val or_intro1_th: thm
    val or_intro2_th: thm
    val resolve_conv_th: thm
    val swap_all_disj_th: thm
    val swap_ex_conj_th: thm
    val sym_th: thm
    val to_contra_form_th: thm
    val to_contra_form_th': thm
    val to_meta_eq_cv: conv
    val to_obj_eq_cv: conv
    val to_obj_eq_iff: thm -> thm
    val true_th: thm
  end
### theory "HOL-Library.Nat_Bijection"
### 0.351s elapsed time, 1.409s cpu time, 0.120s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.ExtrEqs")
structure UtilBase: UTIL_BASE
structure Basic_UtilBase: BASIC_UTIL_BASE
val true_th = "True": thm
val cdest_eq = fn: cterm -> cterm * cterm
val boolT = "bool": typ
val bTrue = Const ("HOL.True", "bool"): term
val is_eq_term = fn: term -> bool
val bFalse = Const ("HOL.False", "bool"): term
val mk_eq = fn: term * term -> term
val dest_eq = fn: term -> term * term
signature BASIC_UTIL_LOGIC =
  sig
    val Not: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val apply_to_thm': conv -> thm -> thm
    val assume_eq: theory -> term * term -> thm
    val concl_of': thm -> term
    val conj: term
    val conj_left_th: thm -> thm
    val conj_right_th: thm -> thm
    val cprop_of': thm -> cterm
    val dest_Trueprop: term -> term
    val dest_imp: term -> term * term
    val dest_not: term -> term
    val disj: term
    val equiv_backward_th: thm -> thm
    val equiv_forward_th: thm -> thm
    val get_neg: term -> term
    val get_neg': term -> term
    val imp: term
    val inv_backward_th: thm -> thm
    val is_Trueprop: term -> bool
    val is_ball: term -> bool
    val is_bex: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_ex: term -> bool
    val is_imp: term -> bool
    val is_mem: term -> bool
    val is_neg: term -> bool
    val is_obj_all: term -> bool
    val is_true_th: thm -> bool
    val list_conj: term list -> term
    val list_disj: term list -> term
    val list_obj_imp: term list * term -> term
    val make_trueprop_eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_conj: term * term -> term
    val mk_disj: term * term -> term
    val mk_exists: term -> term -> term
    val mk_imp: term * term -> term
    val mk_mem: term * term -> term
    val mk_not: term -> term
    val mk_obj_all: term -> term -> term
    val obj_sym: thm -> thm
    val obj_sym_th: thm -> thm
    val pFalse: term
    val prop_of': thm -> term
    val rewr_obj_eq: thm -> conv
    val strip_conj: term -> term list
    val strip_disj: term -> term list
    val strip_obj_imp: term -> term list * term
    val to_meta_eq: thm -> thm
    val to_obj_eq: thm -> thm
    val to_obj_eq_iff_th: thm -> thm
    val to_obj_eq_th: thm -> thm
  end
signature UTIL_LOGIC =
  sig
    val Not: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val apply_to_thm': conv -> thm -> thm
    val assume_eq: theory -> term * term -> thm
    val bool_of_term: term -> bool
    val concl_of': thm -> term
    val conj: term
    val conj_left_th: thm -> thm
    val conj_right_th: thm -> thm
    val contra_by_tac:
       (Proof.context -> int -> tactic) -> Proof.context -> thm list -> thm
    val cprop_of': thm -> cterm
    val dest_Trueprop: term -> term
    val dest_imp: term -> term * term
    val dest_not: term -> term
    val disj: term
    val equiv_backward_th: thm -> thm
    val equiv_forward_th: thm -> thm
    val ex_elim: Proof.context -> term -> thm -> thm
    val force_abs_form: term -> term
    val get_all_subterms: term -> term list
    val get_all_subterms_skip_if: term -> term list
    val get_cneg: cterm -> cterm
    val get_neg: term -> term
    val get_neg': term -> term
    val imp: term
    val inv_backward_th: thm -> thm
    val is_Trueprop: term -> bool
    val is_ball: term -> bool
    val is_bex: term -> bool
    val is_conj: term -> bool
    val is_disj: term -> bool
    val is_ex: term -> bool
    val is_ex_form_gen: term -> bool
    val is_imp: term -> bool
    val is_mem: term -> bool
    val is_neg: term -> bool
    val is_obj_all: term -> bool
    val is_true_th: thm -> bool
    val list_conj: term list -> term
    val list_disj: term list -> term
    val list_obj_horn: term list * (term list * term) -> term
    val list_obj_imp: term list * term -> term
    val list_subterms: term -> term list
    val make_neg_eq: thm -> thm
    val make_trueprop_eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_conj: term * term -> term
    val mk_conjs_th: thm list -> thm
    val mk_disj: term * term -> term
    val mk_exists: term -> term -> term
    val mk_imp: term * term -> term
    val mk_mem: term * term -> term
    val mk_not: term -> term
    val mk_obj_all: term -> term -> term
    val normalize_exists: Proof.context -> conv
    val obj_sym: thm -> thm
    val obj_sym_th: thm -> thm
    val pFalse: term
    val prop_of': thm -> term
    val prove_by_tac:
       (Proof.context -> int -> tactic) ->
         Proof.context -> thm list -> term -> thm
    val rewr_obj_eq: thm -> conv
    val rewrite_from_contra_form: conv
    val rewrite_to_contra_form: conv
    val split_conj_gen_th: thm -> thm list
    val split_conj_th: thm -> thm list
    val split_not_disj_th: thm -> thm list
    val strip_conj: term -> term list
    val strip_disj: term -> term list
    val strip_exists: term -> term list * term
    val strip_horn': thm -> term list * term
    val strip_obj_horn: term -> term list * (term list * term)
    val strip_obj_imp: term -> term list * term
    val term_of_bool: bool -> term
    val to_meta_conv: Proof.context -> conv
    val to_meta_eq: thm -> thm
    val to_obj_conv: Proof.context -> conv
    val to_obj_conv_on_horn: Proof.context -> conv
    val to_obj_eq: thm -> thm
    val to_obj_eq_iff_th: thm -> thm
    val to_obj_eq_th: thm -> thm
  end
structure UtilLogic: UTIL_LOGIC
structure Basic_UtilLogic: BASIC_UTIL_LOGIC
val mk_obj_all = fn: term -> term -> term
val dest_not = fn: term -> term
val mk_mem = fn: term * term -> term
val apply_to_thm' = fn: conv -> thm -> thm
val mk_not = fn: term -> term
val is_true_th = fn: thm -> bool
val is_ex = fn: term -> bool
val list_conj = fn: term list -> term
val prop_of' = fn: thm -> term
val inv_backward_th = fn: thm -> thm
val assume_eq = fn: theory -> term * term -> thm
val equiv_forward_th = fn: thm -> thm
val dest_imp = fn: term -> term * term
val concl_of' = fn: thm -> term
val mk_imp = fn: term * term -> term
val strip_disj = fn: term -> term list
val pFalse =
   Const ("HOL.Trueprop", "bool => prop") $ Const ("HOL.False", "bool"):
   term
val cprop_of' = fn: thm -> cterm
val Trueprop = Const ("HOL.Trueprop", "bool => prop"): term
val strip_conj = fn: term -> term list
val mk_conj = fn: term * term -> term
val mk_Trueprop = fn: term -> term
val rewr_obj_eq = fn: thm -> conv
val disj = Const ("HOL.disj", "bool => bool => bool"): term
val strip_obj_imp = fn: term -> term list * term
val to_obj_eq = fn: thm -> thm
val Trueprop_conv = fn: conv -> conv
val imp = Const ("HOL.implies", "bool => bool => bool"): term
val is_neg = fn: term -> bool
val dest_Trueprop = fn: term -> term
val make_trueprop_eq = fn: thm -> thm
val is_bex = fn: term -> bool
val conj_left_th = fn: thm -> thm
val is_ball = fn: term -> bool
val is_disj = fn: term -> bool
val obj_sym_th = fn: thm -> thm
val is_obj_all = fn: term -> bool
val list_obj_imp = fn: term list * term -> term
val to_obj_eq_iff_th = fn: thm -> thm
val equiv_backward_th = fn: thm -> thm
val is_mem = fn: term -> bool
val Not = Const ("HOL.Not", "bool => bool"): term
val to_meta_eq = fn: thm -> thm
val get_neg = fn: term -> term
val conj = Const ("HOL.conj", "bool => bool => bool"): term
val to_obj_eq_th = fn: thm -> thm
val mk_exists = fn: term -> term -> term
val conj_right_th = fn: thm -> thm
val is_imp = fn: term -> bool
val obj_sym = fn: thm -> thm
val list_disj = fn: term list -> term
val mk_disj = fn: term * term -> term
val is_conj = fn: term -> bool
val is_Trueprop = fn: term -> bool
val get_neg' = fn: term -> term
signature BOXID =
  sig
    val add_incr_id: box_id -> box_id
    val add_prim_id: box_id -> Proof.context -> int * Proof.context
    val add_resolved: box_id -> Proof.context -> Proof.context
    type box_id
    type box_lattice
    val get_all_merges: Proof.context -> box_id list list -> box_id list
    val get_all_merges_info:
       Proof.context -> (box_id * 'a) list list -> (box_id * 'a list) list
    val get_ancestors_prim: Proof.context -> box_id -> int list
    val get_parent_at_i: Proof.context -> box_id -> int -> box_id
    val get_parent_prim: Proof.context -> int -> box_id
    val has_incr_id: box_id -> bool
    val home_id: int
    val id_is_eq_ancestor:
       Proof.context -> box_id * 'a -> box_id * 'a -> bool
    val info_eq_better:
       Proof.context -> box_id * thm -> box_id * thm -> bool
    val is_box_resolved: Proof.context -> box_id -> bool
    val is_box_unresolved: Proof.context -> box_id -> bool
    val is_eq_ancestor: Proof.context -> box_id -> box_id -> bool
    val is_eq_descendent: Proof.context -> box_id -> box_id -> bool
    val merge_box_with_info:
       Proof.context -> box_id -> (box_id * 'a) list -> (box_id * 'a) list
    val merge_boxes: Proof.context -> box_id * box_id -> box_id
    val merge_eq_infos:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val reduce_box_id: Proof.context -> int list -> box_id
    val replace_incr_id: box_id -> box_id
    val string_of_box_id: box_id -> string
  end
type box_id = ?.BoxID.box_id
type id_inst = box_id * (Type.tyenv * Envir.tenv)
type id_inst_th = id_inst * thm
type id_inst_ths = id_inst * thm list
structure BoxID: BOXID
structure Boxidtab: TABLE
signature CONSTS =
  sig
    val add_const_data: string * (term -> bool) -> theory -> theory
    val detect_const: theory -> term -> string option
    val detect_const_ctxt: Proof.context -> term -> string option
    val is_const: theory -> term -> bool
    val is_const_ctxt: Proof.context -> term -> bool
    val neq_const: theory -> term * term -> bool
    val neq_const_ctxt: Proof.context -> term * term -> bool
  end
structure Consts: CONSTS
signature PROPERTY =
  sig
    val add_property_field_const: term -> theory -> theory
    val add_property_update: thm -> theory -> theory
    val can_add_property_update: thm -> theory -> bool
    val get_property_arg: term -> term
    val get_property_arg_th: thm -> cterm
    val get_property_name: term -> string
    val get_property_names: term list -> string list
    val instantiate_property_update:
       Proof.context -> term -> thm -> thm option
    val is_property: term -> bool
    val is_property_field: theory -> term -> bool
    val is_property_prem: theory -> term -> bool
    val lookup_property_update: theory -> string -> thm list
    val lookup_property_update_fun: theory -> string -> thm list
    val strip_property_field: theory -> term -> term list
  end
structure Property: PROPERTY
val add_property_field_const = fn: term -> theory -> theory
signature WELLFORM =
  sig
    val is_subterm_wellform_data:
       theory -> term -> term list -> (term * term) option
    val is_subterm_wellform_data':
       theory -> term -> term -> (term * term) option
    val lookup_wellform_data: theory -> term -> term list
    val lookup_wellform_pattern:
       theory -> term * term -> (term * term) option
    val register_wellform_data: string * string list -> theory -> theory
  end
structure WellForm: WELLFORM
val register_wellform_data = fn: string * string list -> theory -> theory
infix 1 then_wfconv
infix 0 else_wfconv
datatype wfterm = WfComb of cterm * wfterm list * thm list | WfTerm of cterm
type wfconv = wfterm -> wfterm * thm
signature WFTERM =
  sig
    val all_conv: wfconv
    val arg1_conv: wfconv -> wfconv
    val arg_conv: wfconv -> wfconv
    val argn_conv: int -> wfconv -> wfconv
    val binop_conv: wfconv -> wfconv
    val conv_of: conv -> wfconv
    val cterm_of: wfterm -> cterm
    val cterm_to_wfterm_assume: term list -> cterm -> wfterm
    val cterm_to_wfterm_on_ths: thm list -> term list -> cterm -> wfterm
    val else_wfconv: wfconv * wfconv -> wfconv
    val every_conv: wfconv list -> wfconv
    val find_target_on_ths: thm list -> term -> thm
    val first_conv: wfconv list -> wfconv
    val no_conv: wfconv
    val repeat_conv: wfconv -> wfconv
    val rewr_obj_eq: term list -> thm -> wfconv
    val rewrite_on_eqs: term list -> (wfterm * thm) list -> wfconv
    val string_of_wfterm: Proof.context -> wfterm -> string
    val strip_comb: wfterm -> cterm * wfterm list
    val term_of: wfterm -> term
    val test_wfconv:
       Proof.context ->
         term list -> wfconv -> string -> string * string -> unit
    val then_wfconv: wfconv * wfconv -> wfconv
    val theory_of_wft: wfterm -> theory
    val try_conv: wfconv -> wfconv
    val wellform_ths_of: wfterm -> thm list
  end
constructor WfComb: cterm * wfterm list * thm list -> wfterm
constructor WfTerm: cterm -> wfterm
structure WfTerm: WFTERM
val then_wfconv = fn: wfconv * wfconv -> wfconv
val else_wfconv = fn: wfconv * wfconv -> wfconv
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  snth :: "'a stream => nat => 'a"
type rewrite_table =
   {all_equiv: (box_id * thm) list Termtab.table,
    contain: cterm list Termtab.table,
    equiv: (box_id * thm) list Termtab.table,
    reps: (box_id * thm) list Termtab.table,
    simp: (box_id * thm) list Termtab.table,
    subsimp: (box_id * thm) list Termtab.table,
    terms: (box_id list * cterm) Termtab.table}
signature REWRITE_TABLE =
  sig
    val add_contain: cterm -> term -> Proof.context -> Proof.context
    val add_equiv: box_id * thm -> Proof.context -> Proof.context
    val add_rewrite:
       box_id * thm -> Proof.context -> (box_id * thm) list * Proof.context
    val add_rewrite_raw: box_id -> thm -> Proof.context -> Proof.context
    val add_term:
       box_id * cterm ->
         Proof.context -> (box_id * thm) list * Proof.context
    val add_term_list:
       (box_id * cterm) list ->
         Proof.context -> (box_id * thm) list * Proof.context
    val add_term_raw: box_id * cterm -> Proof.context -> Proof.context
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val complete_table: Proof.context -> (box_id * thm) list * Proof.context
    val equiv_info:
       Proof.context -> box_id -> cterm * cterm -> (box_id * thm) list
    val equiv_info_t:
       Proof.context -> box_id -> term * term -> (box_id * thm) list
    val equiv_neighs: Proof.context -> term -> (box_id * thm) list
    val get_all_equiv: Proof.context -> term -> (box_id * thm) list
    val get_all_id_terms: Proof.context -> (box_id * cterm) list
    val get_all_terms: Proof.context -> cterm list
    val get_cached_subterm_rewrite: box_id -> Proof.context -> cterm -> thm
    val get_cached_subterm_rewrite_info:
       Proof.context -> term -> (box_id * thm) list
    val get_head_equiv: Proof.context -> cterm -> (box_id * thm) list
    val get_head_equiv_with_t:
       Proof.context -> box_id * cterm -> term -> (box_id * thm) list
    val get_head_rep: box_id -> Proof.context -> term -> thm option
    val get_head_rep_info: Proof.context -> term -> (box_id * thm) list
    val get_head_rep_with_id_th:
       Proof.context -> box_id * thm -> (box_id * thm) list
    val get_new_terms:
       Proof.context * Proof.context -> (box_id * cterm) list
    val get_reachable_terms: bool -> Proof.context -> term list -> term list
    val get_rewrite: box_id -> Proof.context -> cterm -> thm
    val get_rewrite_info: Proof.context -> cterm -> (box_id * thm) list
    val get_subterm_rewrite_info:
       Proof.context -> cterm -> (box_id * thm) list
    val head_simplify: box_id -> Proof.context -> cterm -> thm
    val immediate_contains: Proof.context -> term -> cterm list
    val in_table_raw: Proof.context -> term -> bool
    val in_table_raw_for_id: Proof.context -> box_id * term -> bool
    val in_table_raw_ids: Proof.context -> term -> box_id list
    val is_equiv: box_id -> Proof.context -> cterm * cterm -> bool
    val is_equiv_t: box_id -> Proof.context -> term * term -> bool
    val process_update_simp:
       (box_id * thm) list -> Proof.context -> Proof.context
    val remove_rep: box_id * thm -> Proof.context -> Proof.context
    val simp_val: box_id -> Proof.context -> cterm -> cterm
    val simp_val_t: box_id -> Proof.context -> term -> term
    val simplify: box_id -> Proof.context -> cterm -> thm
    val simplify_info: Proof.context -> cterm -> (box_id * thm) list
    val subequiv_info:
       Proof.context -> box_id -> cterm * cterm -> (box_id * thm) list
    val subterm_simplify: box_id -> Proof.context -> cterm -> thm
    val subterm_simplify_info: Proof.context -> cterm -> (box_id * thm) list
    val update_simp: box_id * thm -> Proof.context -> Proof.context
    val update_subsimp: box_id * thm -> Proof.context -> Proof.context
  end
val simp_ord = fn: thm * thm -> order
val eq_info = fn: (''a * thm) * (''a * thm) -> bool
val print_info = fn: Proof.context -> BoxID.box_id * thm -> string
val print_infos = fn: Proof.context -> (BoxID.box_id * thm) list -> string
val print_info' = fn: Proof.context -> BoxID.box_id * thm list -> string
val print_infos' = fn:
   Proof.context -> (BoxID.box_id * thm list) list -> string
structure RewriteTable: REWRITE_TABLE
consts
  stake :: "nat => 'a stream => 'a list"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  sdrop :: "nat => 'a stream => 'a stream"
signature PROPERTY_DATA =
  sig
    val add_property: box_id * thm -> Proof.context -> Proof.context
    val add_property_raw: box_id * thm -> Proof.context -> Proof.context
    val apply_property_update_on_term:
       Proof.context -> box_id -> term -> (box_id * thm) list
    val apply_property_update_rule:
       Proof.context -> box_id -> thm option -> (box_id * thm) list
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val convert_property:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val get_new_property: Proof.context -> (box_id * thm) list
    val get_property: Proof.context -> box_id * cterm -> (box_id * thm) list
    val get_property_for_term: Proof.context -> term -> (box_id * thm) list
    val get_property_t:
       Proof.context -> box_id * term -> (box_id * thm) list
    val process_rewrite_property:
       box_id * thm -> Proof.context -> Proof.context
    val process_update_property:
       (box_id * thm) list -> Proof.context -> Proof.context
  end
structure PropertyData: PROPERTY_DATA
Found termination order: "size <*mlex*> {}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
### theory "HOL-Library.BigO"
### 1.015s elapsed time, 3.856s cpu time, 0.737s GC time
consts
  cycle :: "'a list => 'a stream"
signature MATCHER =
  sig
    val check_type: theory -> typ * typ -> id_inst -> id_inst option
    val check_type_term:
       theory -> term * term -> id_inst -> (id_inst * term) option
    val match:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_all_head:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_comb:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_head:
       Proof.context ->
         term list -> term * cterm -> id_inst -> id_inst_th list
    val match_list:
       Proof.context ->
         term list -> term list * cterm list -> id_inst -> id_inst_ths list
    val pre_match: Proof.context -> term * cterm -> bool
    val pre_match_all_head: Proof.context -> term * cterm -> bool
    val pre_match_comb: Proof.context -> term * cterm -> bool
    val pre_match_head: Proof.context -> term * cterm -> bool
    val pre_match_head': Proof.context -> term * cterm -> bool
    val pre_match_type: Proof.context -> typ * typ -> bool
    val rewrite_match:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val rewrite_match_head:
       Proof.context -> term * cterm -> id_inst -> id_inst_th list
    val rewrite_match_list:
       Proof.context ->
         (bool * (term * cterm)) list -> id_inst -> id_inst_ths list
    val rewrite_match_subset:
       Proof.context ->
         term list -> term list * cterm list -> id_inst -> id_inst_ths list
    val update_inst:
       term list -> indexname -> cterm -> id_inst -> id_inst_th list
  end
structure Matcher: MATCHER
Found termination order: "size <*mlex*> {}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
datatype raw_item
= Fact of string * term list * thm | Handler of term list * term * thm
type box_item =
   {id: box_id,
    prop: thm, sc: int, tname: cterm list, ty_str: string, uid: int}
signature BOXITEM =
  sig
    val dest_handler_raw: raw_item -> term list * term * thm
    val eq_item: box_item * box_item -> bool
    val eq_ritem: raw_item * raw_item -> bool
    val get_thm_raw: raw_item -> thm
    val get_tname_raw: raw_item -> term list
    val instantiate: (cterm * cterm) list -> raw_item -> raw_item
    val is_fact_raw: raw_item -> bool
    val is_handler_raw: raw_item -> bool
    val item_replace_incr: box_item -> box_item
    val item_with_id: box_id -> box_item -> box_item
    val item_with_incr: box_item -> box_item
    val match_ty_str: string -> box_item -> bool
    val match_ty_str_raw: string -> raw_item -> bool
    val match_ty_strs: string list -> box_item -> bool
    val match_ty_strs_raw: string list -> raw_item -> bool
    val merged_id: Proof.context -> box_item list -> box_id
    val mk_box_item:
       Proof.context -> int * box_id * int * raw_item -> box_item
    val null_item: box_item
    val obtain_variant_frees:
       Proof.context * raw_item list -> Proof.context * (cterm * cterm) list
    val term_to_fact: term -> raw_item
    val var_to_fact: term -> raw_item
  end
val TY_NULL = "NULL": string
val TY_EQ = "EQ": string
val TY_VAR = "VAR": string
val TY_PROP = "PROP": string
val TY_TERM = "TERM": string
val TY_PROPERTY = "PROPERTY": string
constructor Fact: string * term list * thm -> raw_item
constructor Handler: term list * term * thm -> raw_item
type item_matcher =
   {match: term -> box_item -> Proof.context -> id_inst -> id_inst_th list,
    pre_match: term -> box_item -> Proof.context -> bool}
type item_output = Proof.context -> term list * thm -> string
type item_io_info =
   {output_fn: (item_output * serial) option,
    prop_matchers: (item_matcher * serial) list,
    shadow_fn:
    ((Proof.context -> box_id -> term list * cterm list -> bool) * serial)
    option
    ,
    term_fn: ((term list -> term list) * serial) option,
    typed_matchers: (item_matcher * serial) list}
datatype match_arg
=
     PropMatch of term
   | PropertyMatch of term
   | TypedMatch of string * term
   | TypedUniv of string
   | WellFormMatch of term * term
type prfstep_filter = Proof.context -> id_inst -> bool
signature ITEM_IO =
  sig
    val add_basic_item_io: theory -> theory
    val add_item_type:
       string * (term list -> term list) option * item_output option *
       (Proof.context -> box_id -> term list * cterm list -> bool) option
         -> theory -> theory
    val add_prop_matcher: string * item_matcher -> theory -> theory
    val add_typed_matcher: string * item_matcher -> theory -> theory
    val assert_valid_arg: match_arg -> unit
    val check_ty_str: string -> match_arg -> bool
    val eq_tname_typed_matcher: item_matcher
    val get_io_info: theory -> string -> item_io_info
    val get_prop_matchers: theory -> string -> item_matcher list
    val get_typed_matchers: theory -> string -> item_matcher list
    val is_ordinary_match: match_arg -> bool
    val is_side_match: match_arg -> bool
    val match_arg:
       Proof.context -> match_arg -> box_item -> id_inst -> id_inst_th list
    val no_rewr_terms: term list -> term list
    val null_eq_matcher: item_matcher
    val null_property_matcher: item_matcher
    val output_prop_fn: item_output
    val pat_of_match_arg: match_arg -> term
    val pre_match_arg: Proof.context -> match_arg -> box_item -> bool
    val prop_matcher: item_matcher
    val rewr_terms_of_item: Proof.context -> string * term list -> term list
    val string_of_item: Proof.context -> box_item -> string
    val string_of_item_info:
       Proof.context -> string * term list * thm -> string
    val string_of_raw_item: Proof.context -> raw_item -> string
    val subst_arg: Type.tyenv * Envir.tenv -> match_arg -> match_arg
    val term_prop_matcher: item_matcher
    val term_property_matcher: item_matcher
    val term_typed_matcher: item_matcher
    val trace_item: Proof.context -> string -> box_item -> unit
    val trace_items: Proof.context -> string -> box_item list -> unit
    val trace_ritem: Proof.context -> string -> raw_item -> unit
    val trace_ritems: Proof.context -> string -> raw_item list -> unit
  end
structure BoxItem: BOXITEM
constructor PropMatch: term -> match_arg
constructor PropertyMatch: term -> match_arg
constructor TypedMatch: string * term -> match_arg
constructor TypedUniv: string -> match_arg
constructor WellFormMatch: term * term -> match_arg
structure ItemIO: ITEM_IO
Found termination order: "size <*mlex*> {}"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
signature WELLFORM_DATA =
  sig
    val add_wellform_data_raw:
       term * (box_id * thm) -> Proof.context -> Proof.context
    val clean_resolved: box_id -> Proof.context -> Proof.context
    val clear_incr: Proof.context -> Proof.context
    val complete_wellform_data:
       box_item list -> Proof.context -> Proof.context
    val complete_wellform_data_for_terms:
       box_item list -> term list -> Proof.context -> Proof.context
    val convert_wellform:
       Proof.context -> box_id * thm -> box_id * thm -> box_id * thm
    val cterm_to_wfterm:
       Proof.context ->
         term list -> box_id * cterm -> (box_id * wfterm) list
    val find_fact:
       Proof.context ->
         box_item list -> box_id * cterm -> (box_id * thm) list
    val get_complete_wellform:
       Proof.context -> box_id * cterm -> (box_id * thm list) list
    val get_head_equiv:
       Proof.context ->
         term list -> box_id * cterm -> (box_id * (wfterm * thm)) list
    val get_new_wellform_data: Proof.context -> (term * (box_id * thm)) list
    val get_wellform: Proof.context -> box_id * cterm -> (box_id * thm) list
    val get_wellform_for_term:
       Proof.context -> term -> (cterm * (box_id * thm) list) list
    val get_wellform_infos_for_term:
       Proof.context -> term -> (box_id * thm) list
    val get_wellform_t:
       Proof.context -> box_id * term -> (box_id * thm) list
    val initialize_wellform_data: term -> Proof.context -> Proof.context
    val simplify:
       Proof.context ->
         term list ->
           cterm list -> box_id * wfterm -> (box_id * (wfterm * thm)) list
    val simplify_info:
       Proof.context -> term list -> cterm -> (box_id * (wfterm * thm)) list
    val term_to_wfterm:
       Proof.context -> term list -> box_id * term -> (box_id * wfterm) list
  end
structure WellformData: WELLFORM_DATA
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Stream"
### 1.146s elapsed time, 4.151s cpu time, 0.793s GC time
signature AUTO2_DATA =
  sig
    val add_terms:
       box_item list ->
         (box_id * cterm) list -> Proof.context -> Proof.context
    val get_incr_type:
       box_item list -> box_item list -> Proof.context -> Proof.context
    val get_single_type: Proof.context -> Proof.context
    val relevant_terms_single: box_item -> term list
  end
structure Auto2Data: AUTO2_DATA
Found termination order: "size <*mlex*> {}"
datatype raw_update
=
     AddBoxes of {id: box_id, init_assum: term, sc: int option}
   | AddItems of {id: box_id, raw_items: raw_item list, sc: int option}
   | ResolveBox of {id: box_id, th: thm}
   | ShadowItem of {id: box_id, item: box_item}
type update =
   {prfstep_name: string,
    raw_updt: raw_update, sc: int, source: box_item list}
signature UPDATE =
  sig
    val apply_exists_ritems: Proof.context -> thm -> raw_item list * thm
    val replace_id_of_update: raw_update -> raw_update
    val source_info: update -> string
    val string_of_raw_update: Proof.context -> raw_update -> string
    val target_of_update: raw_update -> box_id
    val thm_to_ritem: thm -> raw_item
    val thm_update: box_id * thm -> raw_update
    val thm_update_sc: int -> box_id * thm -> raw_update
    val update_info: Proof.context -> box_id -> raw_item list -> string
  end
constructor AddBoxes:
   {id: box_id, init_assum: term, sc: int option} -> raw_update
constructor AddItems:
   {id: box_id, raw_items: raw_item list, sc: int option} -> raw_update
constructor ResolveBox: {id: box_id, th: thm} -> raw_update
constructor ShadowItem: {id: box_id, item: box_item} -> raw_update
type status =
   {assums: term list,
    ctxt: Proof.context,
    handlers: (box_id * (term list * term * thm)) list,
    items: (box_item * box_id list) Inttab.table,
    queue: Updates_Heap.T, resolve_th: thm option}
signature STATUS =
  sig
    val add_handler: box_id * (term list * term * thm) -> status -> status
    val add_item: box_item -> status -> status
    val add_prim_box: box_id -> term -> status -> int * status
    val add_resolved: box_id -> status -> status
    val add_shadowed: box_id * box_item -> status -> status
    val add_to_queue: update -> status -> status
    val clear_incr: status -> status
    val delmin_from_queue: status -> status
    val empty_status: Proof.context -> status
    val find_fact: status -> box_id -> term -> thm option
    val find_prim_box: status -> box_id -> term -> int option
    val find_ritem_exact: status -> box_id -> raw_item -> bool
    val get_all_items_at_id: status -> box_id -> box_item list
    val get_handlers: status -> (box_id * (term list * term * thm)) list
    val get_init_assum: status -> int -> term
    val get_init_assums: status -> box_id -> term list
    val get_items: status -> box_item list
    val get_num_items: status -> int
    val get_on_resolve: status -> box_id -> int -> thm -> thm
    val get_resolve_th: status -> thm
    val invoke_handler:
       Proof.context -> term list * term * thm -> thm -> thm
    val lookup_item: status -> int -> (box_item * box_id list) option
    val map_context: (Proof.context -> Proof.context) -> status -> status
    val map_queue: (Updates_Heap.T -> Updates_Heap.T) -> status -> status
    val query_removed: status -> box_item -> bool
    val query_shadowed: status -> box_id -> box_item -> bool
    val set_resolve_th: thm -> status -> status
  end
structure Update: UPDATE
structure Updates_Heap: HEAP
structure Status: STATUS
Found termination order: "size <*mlex*> {}"
signature NORMALIZER =
  sig
    val add_inj_struct_data: thm -> theory -> theory
    val add_normalizer: string * normalizer -> theory -> theory
    val add_rewr_normalizer: string * thm -> theory -> theory
    val add_th_normalizer:
       string * (Proof.context -> thm -> thm list) -> theory -> theory
    val def_subst: (term * term) list -> term -> term
    val get_normalizers: theory -> (string * normalizer) list
    val is_def_eq: theory -> term -> bool
    val meta_use_vardef: thm -> (term * term) list * thm
    val meta_use_vardefs: thm -> (term * term) list * thm
    val normalize: Proof.context -> raw_item -> raw_item list
    val normalize_keep: Proof.context -> raw_item -> raw_item list
    type normalizer = Proof.context -> raw_item -> raw_item list
    val swap_eq_to_front: conv
  end
structure Normalizer: NORMALIZER
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
datatype proofstep_fn
=
     OneStep of Proof.context -> box_item -> raw_update list
   | TwoStep of Proof.context -> box_item -> box_item -> raw_update list
type proofstep = {args: match_arg list, func: proofstep_fn, name: string}
datatype prfstep_descriptor
=
     CreateCase of term
   | CreateConcl of term
   | Filter of prfstep_filter
   | GetFact of term * thm
   | ShadowFirst
   | ShadowSecond
   | WithFact of term
   | WithItem of string * term
   | WithProperty of term
   | WithScore of int
   | WithWellForm of term * term
signature PROOFSTEP =
  sig
    val WithGoal: term -> prfstep_descriptor
    val WithProp: term -> prfstep_descriptor
    val WithTerm: term -> prfstep_descriptor
    val all_insts: prfstep_filter
    val apply_pat_r: Proof.context -> id_inst_ths -> term * thm -> thm
    val apply_prfstep:
       Proof.context -> box_item list -> proofstep -> raw_update list
    val eq_prfstep: proofstep * proofstep -> bool
    val gen_prfstep: string -> prfstep_descriptor list -> proofstep
    val get_side_ths:
       Proof.context ->
         id_inst -> match_arg list -> (box_id * thm list) list
    val neq_filter: term -> prfstep_filter
    val not_type_filter: string -> typ -> prfstep_filter
    val order_filter: string -> string -> prfstep_filter
    val prfstep_conv: string -> prfstep_descriptor list -> conv -> proofstep
    val prfstep_custom:
       string ->
         prfstep_descriptor list ->
           (id_inst_ths ->
              box_item list -> Proof.context -> raw_update list)
             -> proofstep
    val prfstep_pre_conv:
       string ->
         prfstep_descriptor list -> (Proof.context -> conv) -> proofstep
    val retrieve_args: prfstep_descriptor list -> match_arg list
    val retrieve_cases: prfstep_descriptor list -> term list
    val retrieve_filts: prfstep_descriptor list -> prfstep_filter
    val retrieve_pats_r: prfstep_descriptor list -> (term * thm) list
    val retrieve_shadows: prfstep_descriptor list -> int list
    val size1_filter: string -> prfstep_filter
    val string_of_desc: theory -> prfstep_descriptor -> string
    val string_of_descs: theory -> prfstep_descriptor list -> string
  end
constructor OneStep:
   (Proof.context -> box_item -> raw_update list) -> proofstep_fn
constructor TwoStep:
   (Proof.context -> box_item -> box_item -> raw_update list) ->
     proofstep_fn
constructor CreateCase: term -> prfstep_descriptor
constructor CreateConcl: term -> prfstep_descriptor
constructor Filter: prfstep_filter -> prfstep_descriptor
constructor GetFact: term * thm -> prfstep_descriptor
constructor ShadowFirst: prfstep_descriptor
constructor ShadowSecond: prfstep_descriptor
constructor WithFact: term -> prfstep_descriptor
constructor WithItem: string * term -> prfstep_descriptor
constructor WithProperty: term -> prfstep_descriptor
constructor WithScore: int -> prfstep_descriptor
constructor WithWellForm: term * term -> prfstep_descriptor
signature PROOFSTEP_DATA =
  sig
    val add_backward1_prfstep: thm -> theory -> theory
    val add_backward1_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_backward2_prfstep: thm -> theory -> theory
    val add_backward2_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_backward_prfstep: thm -> theory -> theory
    val add_backward_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward'_prfstep: thm -> theory -> theory
    val add_forward'_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward_prfstep: thm -> theory -> theory
    val add_forward_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_gen_prfstep:
       string * prfstep_descriptor list -> theory -> theory
    val add_prfstep: proofstep -> theory -> theory
    val add_prfstep_check_req: string * string -> theory -> theory
    val add_prfstep_conv:
       string * prfstep_descriptor list * conv -> theory -> theory
    val add_prfstep_custom:
       string * prfstep_descriptor list *
       (id_inst_ths -> box_item list -> Proof.context -> raw_update list)
         -> theory -> theory
    val add_prfstep_pre_conv:
       string * prfstep_descriptor list * (Proof.context -> conv) ->
         theory -> theory
    val add_resolve_prfstep: thm -> theory -> theory
    val add_resolve_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule: thm -> theory -> theory
    val add_rewrite_rule_back: thm -> theory -> theory
    val add_rewrite_rule_back_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule_bidir: thm -> theory -> theory
    val add_rewrite_rule_bidir_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_rule_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val del_prfstep: string -> theory -> theory
    val del_prfstep_pred: (string -> bool) -> theory -> theory
    val del_prfstep_thm: thm -> theory -> theory
    val del_prfstep_thm_eqforward: thm -> theory -> theory
    val del_prfstep_thm_str: string -> thm -> theory -> theory
    val get_prfsteps: theory -> proofstep list
    type pre_prfstep_descriptor = Proof.context -> prfstep_descriptor
    datatype prfstep_mode
    =
         MODE_BACKWARD
       | MODE_BACKWARD1
       | MODE_BACKWARD2
       | MODE_FORWARD
       | MODE_FORWARD'
       | MODE_RESOLVE
    val setup_attrib: (thm -> theory -> theory) -> attribute context_parser
    val with_cond: string -> pre_prfstep_descriptor
    val with_conds: string list -> pre_prfstep_descriptor list
    val with_filt: prfstep_filter -> pre_prfstep_descriptor
    val with_filts: prfstep_filter list -> pre_prfstep_descriptor list
    val with_score: int -> pre_prfstep_descriptor
    val with_term: string -> pre_prfstep_descriptor
  end
structure ProofStep: PROOFSTEP
val WithTerm = fn: term -> prfstep_descriptor
val WithGoal = fn: term -> prfstep_descriptor
val WithProp = fn: term -> prfstep_descriptor
val neq_filter = fn: term -> prfstep_filter
val order_filter = fn: string -> string -> prfstep_filter
val size1_filter = fn: string -> prfstep_filter
val not_type_filter = fn: string -> typ -> prfstep_filter
datatype prfstep_mode
=
     MODE_BACKWARD
   | MODE_BACKWARD1
   | MODE_BACKWARD2
   | MODE_FORWARD
   | MODE_FORWARD'
   | MODE_RESOLVE
type pre_prfstep_descriptor = Proof.context -> prfstep_descriptor
structure ProofStepData: PROOFSTEP_DATA
constructor MODE_FORWARD': prfstep_mode
constructor MODE_BACKWARD1: prfstep_mode
val del_prfstep_thm_eqforward = fn: thm -> theory -> theory
val get_prfsteps = fn: theory -> proofstep list
val del_prfstep_thm = fn: thm -> theory -> theory
val add_forward'_prfstep = fn: thm -> theory -> theory
val with_conds = fn: string list -> pre_prfstep_descriptor list
val add_prfstep_custom = fn:
   string * prfstep_descriptor list *
   (id_inst_ths -> box_item list -> Proof.context -> raw_update list)
     -> theory -> theory
val add_rewrite_rule_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward'_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val del_prfstep_thm_str = fn: string -> thm -> theory -> theory
val add_rewrite_rule = fn: thm -> theory -> theory
val with_cond = fn: string -> pre_prfstep_descriptor
val add_gen_prfstep = fn:
   string * prfstep_descriptor list -> theory -> theory
val add_backward_prfstep = fn: thm -> theory -> theory
val add_resolve_prfstep = fn: thm -> theory -> theory
constructor MODE_RESOLVE: prfstep_mode
val with_filts = fn: prfstep_filter list -> pre_prfstep_descriptor list
val add_prfstep_check_req = fn: string * string -> theory -> theory
val add_backward_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val with_score = fn: int -> pre_prfstep_descriptor
val add_rewrite_rule_back = fn: thm -> theory -> theory
val add_backward1_prfstep = fn: thm -> theory -> theory
val add_rewrite_rule_bidir_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val with_filt = fn: prfstep_filter -> pre_prfstep_descriptor
constructor MODE_BACKWARD2: prfstep_mode
val add_resolve_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep_pre_conv = fn:
   string * prfstep_descriptor list * (Proof.context -> conv) ->
     theory -> theory
val add_forward_prfstep = fn: thm -> theory -> theory
val add_backward2_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep = fn: proofstep -> theory -> theory
val setup_attrib = fn: (thm -> theory -> theory) -> attribute context_parser
val del_prfstep = fn: string -> theory -> theory
constructor MODE_FORWARD: prfstep_mode
constructor MODE_BACKWARD: prfstep_mode
val add_rewrite_rule_bidir = fn: thm -> theory -> theory
val del_prfstep_pred = fn: (string -> bool) -> theory -> theory
val add_rewrite_rule_back_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_prfstep_conv = fn:
   string * prfstep_descriptor list * conv -> theory -> theory
val add_backward1_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_backward2_prfstep = fn: thm -> theory -> theory
val with_term = fn: string -> pre_prfstep_descriptor
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
type auto2_frame =
   {after_qed: (term list * (thm list -> thm -> thm)) option,
    goals: (term * thm) list,
    induct_stmt: term option, prem_only: term list, selected: int option}
type auto2_state = auto2_frame list
signature AUTO2_STATE =
  sig
    val add_prem_only: term -> Proof.context -> Proof.context
    val get_last_induct_stmt: Proof.context -> term option
    val get_num_frame: Proof.context -> int
    val get_selected: Proof.context -> thm
    val get_subgoal: Proof.context -> term
    val get_top_frame: Proof.context -> auto2_frame
    val lookup_prem_only: Proof.context -> term -> bool
    val map_head_th: (thm -> thm) -> Proof.context -> Proof.context
    val multiple_frame:
       (term * cterm) list * (term list * (thm list -> thm -> thm)) option
         -> auto2_frame
    val pop_head: Proof.context -> Proof.context
    val print_state: Proof.context -> unit
    val push_head: auto2_frame -> Proof.context -> Proof.context
    val set_induct_stmt: term -> Proof.context -> Proof.context
    val set_selected: int option -> Proof.context -> Proof.context
    val simple_frame:
       cterm * (term list * (thm list -> thm -> thm)) option -> auto2_frame
  end
structure Auto2_State: AUTO2_STATE
signature LOGIC_PROOFSTEPS =
  sig
    val TY_DISJ: string
    val add_disj_normalizers: theory -> theory
    val add_disj_proofsteps: theory -> theory
    val add_logic_proofsteps: theory -> theory
    val analyze_disj_th: Proof.context -> thm -> term * thm
    val dest_tname_of_disj: cterm list -> term * cterm list
    val disj_create_case_prfstep: proofstep
    val disj_match_iff_prfstep: proofstep
    val disj_normalizer: Normalizer.normalizer
    val disj_prop_match:
       Proof.context ->
         id_inst ->
           term * (term list * term list) *
           ((indexname * typ) list * cterm list)
             -> id_inst_th list
    val disj_prop_matcher: item_matcher
    val disj_rewr_terms: term list -> term list
    val disj_shadow_prfstep: proofstep
    val disj_to_ritems: bool -> term -> thm -> raw_item list
    val disj_to_update:
       bool -> term -> box_id * int option * thm -> raw_update
    val eq_normalizer: Normalizer.normalizer
    val exists_elim_prfstep: proofstep
    val is_match_prem_only: box_item -> bool
    val logic_thm_update: Proof.context -> box_id * thm -> raw_update
    val match_one_sch_prfstep: proofstep
    val match_update_prfstep: proofstep
    val mk_all_disj: term list * term list -> term
    val norm_all_disj: Proof.context -> conv
    val norm_conj: conv
    val output_disj_fn: item_output
    val property_normalizer: Normalizer.normalizer
    val reduce_disj_True: conv
    val replace_disj_vars:
       Proof.context -> term list * term list -> term list * term list
    val shadow_prop_item: proofstep
    val shadow_term_item: proofstep
    val split_conj_gen_th: Proof.context -> thm -> thm list
    val split_not_imp_th: thm -> thm list
    val strip_all_disj: term -> term list * term list
  end
structure Logic_ProofSteps: LOGIC_PROOFSTEPS
val TY_DISJ = "DISJ": string
Found termination order: "size <*mlex*> {}"
signature SCORES =
  sig
    val get_score: raw_update -> int
    val item_score: raw_item -> int
    val items_score: raw_item list -> int
  end
signature PROOFSTATUS =
  sig
    val apply_update: update -> status -> status
    val apply_update_instant: update -> status -> status
    val check_hyps: box_id -> thm -> status -> unit
    val init_status: Proof.context -> term -> status
    val process_add_boxes: update -> status -> status
    val process_add_items: update -> status -> status
    val process_fact_all: box_id -> int -> box_item list -> status -> status
    val process_resolve: update -> status -> status
    val process_shadow: update -> status -> status
    val scoring:
       proofstep ->
         int ->
           box_item list ->
             status -> (box_item -> raw_update list) -> update list
    val solve_root: int * status -> int * status
  end
structure Scores: SCORES
val print_trace =
   Config
    {get_value = fn, map_value = fn, name = "print_trace", pos =
     {line=41, offset=1042, end_offset=1053, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_intended =
   Config
    {get_value = fn, map_value = fn, name = "print_intended", pos =
     {line=43, offset=1127, end_offset=1141, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_term =
   Config
    {get_value = fn, map_value = fn, name = "print_term", pos =
     {line=45, offset=1211, end_offset=1221, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_shadow =
   Config
    {get_value = fn, map_value = fn, name = "print_shadow", pos =
     {line=47, offset=1293, end_offset=1305, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val print_score =
   Config
    {get_value = fn, map_value = fn, name = "print_score", pos =
     {line=49, offset=1376, end_offset=1387, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   bool Config.T
val max_steps =
   Config
    {get_value = fn, map_value = fn, name = "max_steps", pos =
     {line=53, offset=1507, end_offset=1516, file=$AFP/Auto2_HOL/auto2.ML,
       id=244}}:
   int Config.T
signature AUTO2 = sig val auto2_tac: Proof.context -> tactic end
structure ProofStatus: PROOFSTATUS
structure Auto2: AUTO2
### theory "HOL-Library.Tree"
### 2.061s elapsed time, 6.457s cpu time, 1.006s GC time
Loading theory "Draft.Templates" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.053s elapsed time, 0.105s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Order_ThmsMoreTemplates")
signature AUTO2_OUTER =
  sig
    val auto2_solve: Proof.context -> cterm -> thm
    val case_after_qed: Proof.context -> thm list -> thm -> thm
    val case_cmd: string * bool -> Proof.state -> Proof.state
    val case_resolve: Proof.context -> term list -> thm -> thm
    val contra_after_qed: Proof.context -> thm -> thm
    val contra_cmd: Proof.state -> Proof.state
    val contra_resolve:
       Proof.context -> term list -> term list -> term -> thm
    val end_cmd: Proof.state -> Proof.state
    val endgoal_cmd: Proof.state -> Proof.state
    val have_after_qed: Proof.context -> thm -> thm -> thm
    val have_cmd: bool * string * bool -> Proof.state -> Proof.state
    val have_resolve: Proof.context -> term list -> thm -> term -> thm
    val init_state: Proof.state -> Proof.state
    val let_after_qed: Proof.context -> term list -> thm -> thm
    val let_cmd: string list -> Proof.state -> Proof.state
    val let_resolve:
       Proof.context -> term list -> term -> term list -> term -> thm
    val obtain_after_qed: Proof.context -> thm list -> thm -> thm
    val obtain_cmd:
       string list * string list * bool -> Proof.state -> Proof.state
    val obtain_resolve: Proof.context -> term list -> thm -> term -> thm
    val qed_cmd: Proof.state -> Proof.context
    val refine_subgoal_th: thm -> thm -> thm
    val subgoal_cmd: string -> Proof.state -> Proof.state
  end
structure Auto2_Outer: AUTO2_OUTER
type ac_info =
   {assoc_th: thm,
    cfhead: cterm,
    comm_th: thm, unit: cterm option, unitl_th: thm, unitr_th: thm}
signature ACUTIL =
  sig
    val ac_last_conv: ac_info -> conv -> conv
    val add_ac_data: ac_info -> theory -> theory
    val assoc_cv: ac_info -> conv
    val assoc_sym_cv: ac_info -> conv
    val cdest_ac: ac_info -> cterm -> cterm list
    val comb_ac_equiv: ac_info -> thm list -> thm
    val comm_cv: ac_info -> conv
    val dest_ac: ac_info -> term -> term list
    val eq_unit: ac_info -> term -> bool
    val get_head_ac_info: theory -> term -> ac_info option
    val has_assoc_th: ac_info -> bool
    val has_comm_th: ac_info -> bool
    val has_unit_th: ac_info -> bool
    val head_agrees: ac_info -> term -> bool
    val inst_ac_info: theory -> typ -> ac_info -> ac_info option
    val move_outmost: ac_info -> term -> conv
    val norm_combine: ac_info -> (term -> bool) -> conv -> conv
    val normalize_all_ac: ac_info -> conv
    val normalize_assoc: ac_info -> conv
    val normalize_au: ac_info -> conv
    val normalize_comm: ac_info -> conv
    val normalize_comm_gen: ac_info -> (term * term -> bool) -> conv
    val normalize_unit: ac_info -> conv
    val swap_cv: ac_info -> conv
    val swap_r_cv: ac_info -> conv
  end
structure ACUtil: ACUTIL
signature AC_PROOFSTEPS =
  sig
    val ac_expand:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val ac_expand_equiv: proofstep
    val ac_expand_once:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val ac_expand_unit: proofstep
    val add_ac_proofsteps: theory -> theory
    val get_ac_head_equiv:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
    val max_ac: int Config.T
    val simp_ac_expr:
       Proof.context -> ac_info -> box_id * cterm -> (box_id * thm) list
  end
structure AC_ProofSteps: AC_PROOFSTEPS
signature UNFOLDING =
  sig
    val get_unfold_thms: theory -> term -> thm list
    val get_unfold_thms_by_name: theory -> string -> thm list
    val unfold: theory -> conv
    val unfold_cmd: string -> Proof.state -> Proof.state
  end
structure Unfolding: UNFOLDING
signature INDUCT_PROOFSTEPS =
  sig
    val add_case_induct_rule: thm -> theory -> theory
    val add_cases_rule: thm -> theory -> theory
    val add_fun_induct_rule: term * thm -> theory -> theory
    val add_induct_data: string -> term * thm -> theory -> theory
    val add_prop_induct_rule: thm -> theory -> theory
    val add_strong_induct_rule: thm -> theory -> theory
    val add_typed_induct_data: string -> typ * thm -> theory -> theory
    val add_var_induct_rule: thm -> theory -> theory
    val apply_induct_hyp_cmd: string list -> Proof.state -> Proof.state
    val case_induct_cmd: string -> Proof.state -> Proof.state
    val check_strong_ind_prop: term -> term list * term
    val fun_induct_cmd:
       string * string list * string option -> Proof.state -> Proof.state
    val get_term_ind_th: theory -> string -> term -> thm
    val get_typed_ind_th: theory -> string -> typ -> thm
    val induct_cmd:
       string ->
         string * string option * string list * string option ->
           Proof.state -> Proof.state
    val is_simple_fun_induct: thm -> bool
    val prop_induct_cmd:
       string * string option -> Proof.state -> Proof.state
    val strong_induct_cmd:
       string * string list -> Proof.state -> Proof.state
  end
structure Induct_ProofSteps: INDUCT_PROOFSTEPS
val add_strong_induct_rule = fn: thm -> theory -> theory
val add_case_induct_rule = fn: thm -> theory -> theory
val add_prop_induct_rule = fn: thm -> theory -> theory
val add_var_induct_rule = fn: thm -> theory -> theory
val add_fun_induct_rule = fn: term * thm -> theory -> theory
val add_cases_rule = fn: thm -> theory -> theory
signature EXTRA_HOL =
  sig
    val add_forward_arg1_prfstep: thm -> theory -> theory
    val add_forward_arg1_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_forward_arg_prfstep: thm -> theory -> theory
    val add_forward_arg_prfstep_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_rewrite_arg_rule: thm -> theory -> theory
    val add_rewrite_arg_rule_cond:
       thm -> pre_prfstep_descriptor list -> theory -> theory
    val add_simple_datatype: string -> theory -> theory
    val del_simple_datatype: string -> theory -> theory
  end
structure Extra_HOL: EXTRA_HOL
val add_forward_arg_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_forward_arg1_prfstep = fn: thm -> theory -> theory
val add_forward_arg_prfstep = fn: thm -> theory -> theory
val add_simple_datatype = fn: string -> theory -> theory
val del_simple_datatype = fn: string -> theory -> theory
val add_rewrite_arg_rule_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
val add_rewrite_arg_rule = fn: thm -> theory -> theory
val add_forward_arg1_prfstep_cond = fn:
   thm -> pre_prfstep_descriptor list -> theory -> theory
### theory "Draft.Auto2_HOL"
### 2.480s elapsed time, 7.464s cpu time, 1.120s GC time
Loading theory "Draft.Logic_Thms" (required by "Draft.Order_ThmsMoreTemplates" via "Draft.Order_Thms")
HOL.refl@res
WithGoal ?t = ?t
GetResolve HOL.refl@res
HOL_Base.contra_triv
WithGoal ?A
WithFact ?A
GetResolve HOL_Base.contra_triv
HOL.TrueI@res
WithGoal True
GetResolve HOL.TrueI@res
Logic_Thms.FalseD@res
WithFact False
GetResolve Logic_Thms.FalseD@res
Logic_Thms.exists_triv_eq@res
WithGoal EX x. x = x
GetResolve Logic_Thms.exists_triv_eq@res
HOL.not_sym
WithGoal ?t = ?s
GetGoal (?s = ?t, HOL.not_sym) + 1 filters
Logic_Thms.iff_goal_1
WithGoal ?A = ?B
WithFact ?A
WithScore 1
GetGoal (?B, Logic_Thms.iff_goal_1)
Logic_Thms.iff_goal_2
WithGoal ?A = ?B
WithFact ?B
WithScore 1
GetGoal (?A, Logic_Thms.iff_goal_2)
Logic_Thms.iff_goal_3
WithGoal ?A = ?B
WithGoal ?A
WithScore 1
GetFact (?B, Logic_Thms.iff_goal_3)
Logic_Thms.iff_goal_4
WithGoal ?A = ?B
WithGoal ?B
WithScore 1
GetFact (?A, Logic_Thms.iff_goal_4)
Logic_Thms.iff_goal_5
WithGoal (~ ?A) = ?B
WithFact ?A
WithScore 1
GetFact (?B, Logic_Thms.iff_goal_5)
Logic_Thms.iff_goal_6
WithGoal ?A = (~ ?B)
WithFact ?B
WithScore 1
GetFact (?A, Logic_Thms.iff_goal_6)
Logic_Thms.exists_split@eqbackward@back
WithGoal EX x y. ?P x & ?Q y
GetGoal ((EX x. ?P x) & (EX y. ?Q y), Logic_Thms.exists_split@eqbackward@back)
HOL.if_P
WithTerm if ?P then ?x else ?y
WithFact ?P
WithScore 1
GetFact ((if ?P then ?x else ?y) = ?x, HOL.if_P)
HOL.if_not_P
WithTerm if ?P then ?x else ?y
WithGoal ?P
WithScore 1
GetFact ((if ?P then ?x else ?y) = ?y, HOL.if_not_P)
Logic_Thms.if_eval'
WithTerm if ~ ?P then ?x else ?y
WithFact ?P
WithScore 1
GetFact ((if ~ ?P then ?x else ?y) = ?y, Logic_Thms.if_eval')
Logic_Thms.ifb_eval_1@eqforward
WithFact if ?Pa then ?P else ?y
WithFact ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_1@eqforward)
Logic_Thms.ifb_eval_1@invbackward
WithGoal if ?P then ?B else ?y
WithFact ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_1@invbackward)
Logic_Thms.ifb_eval_2@eqforward
WithFact if ?Pa then ?x else ?P
WithGoal ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_2@eqforward)
Logic_Thms.ifb_eval_2@invbackward
WithGoal if ?P then ?x else ?B
WithGoal ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_2@invbackward)
Logic_Thms.ifb_eval_3@eqforward
WithFact if ~ ?Pa then ?x else ?P
WithFact ?Pa
WithScore 1
GetFact (?P, Logic_Thms.ifb_eval_3@eqforward)
Logic_Thms.ifb_eval_3@invbackward
WithGoal if ~ ?P then ?x else ?B
WithFact ?P
WithScore 1
GetGoal (?B, Logic_Thms.ifb_eval_3@invbackward)
HOL.theI'
WithTerm THE x. ?P x
WithFact EX! x. ?P x
GetFact (?P (THE x. ?P x), HOL.theI')
Logic_Thms.ex_ex1I'@back1
WithGoal EX! x. ?P x
WithFact ?P ?x
GetGoal (ALL y. ?P y --> ?x = y, Logic_Thms.ex_ex1I'@back1)
Logic_Thms.the1_equality'
WithTerm THE x. ?P x
WithFact ?P ?a
GetFact ((EX! x. ?P x) --> (THE x. ?P x) = ?a, Logic_Thms.the1_equality')
Hilbert_Choice.someI
WithTerm SOME x. ?P x
WithFact ?P ?x
GetFact (?P (Eps ?P), Hilbert_Choice.someI)
Hilbert_Choice.someI_ex
WithTerm SOME x. ?P x
WithFact EX x. ?P x
GetFact (?P (SOME x. ?P x), Hilbert_Choice.someI_ex)
Logic_Thms.Least_equality'@back1
WithGoal Least ?P = ?x
WithFact ALL y. ?P y --> ?x <= y
GetGoal (?P ?x, Logic_Thms.Least_equality'@back1)
Product_Type.fst_conv
WithTerm fst (?x1.0, ?x2.0)
GetFact (fst (?x1.0, ?x2.0) = ?x1.0, Product_Type.fst_conv)
Product_Type.snd_conv
WithTerm snd (?x1.0, ?x2.0)
GetFact (snd (?x1.0, ?x2.0) = ?x2.0, Product_Type.snd_conv)
Product_Type.prod.simps_1@eqforward
WithFact (?x1.0, ?x2.0) = (?y1.0, ?y2.0)
GetFact (?x1.0 = ?y1.0 & ?x2.0 = ?y2.0, Product_Type.prod.simps_1@eqforward)
Product_Type.surjective_pairing
WithTerm ?t
GetFact (?t = (fst ?t, snd ?t), Product_Type.surjective_pairing) + 1 filters
Relation.symD
WithProperty sym ?r
WithFact (?b, ?a) : ?r
GetFact ((?a, ?b) : ?r, Relation.symD)
Relation.symI@back
WithGoal sym ?r
GetGoal (ALL a b. (a, b) : ?r --> (b, a) : ?r, Relation.symI@back)
Relation.transD
WithProperty trans ?r
WithFact (?x, ?y) : ?r
WithFact (?y, ?z) : ?r
GetFact ((?x, ?z) : ?r, Relation.transD)
Relation.transI@back
WithGoal trans ?r
GetGoal (ALL x y z. (x, y) : ?r --> (y, z) : ?r --> (x, z) : ?r, Relation.transI@back)
Option.option.distinct_1@res
WithFact None = Some ?x2.0
GetResolve Option.option.distinct_1@res
Option.option.sel
WithTerm the (Some ?x2.0)
GetFact (the (Some ?x2.0) = ?x2.0, Option.option.sel)
Option.option.collapse
WithGoal ?option = None
GetFact (Some (the ?option) = ?option, Option.option.collapse)
Option.option.simps_1@eqforward
WithFact Some ?x2.0 = Some ?y2.0
GetFact (?x2.0 = ?y2.0, Option.option.simps_1@eqforward)
Option.option.case_1
WithTerm case None of None => ?f1.0 | Some x => ?f2.0 x
WithScore 1
GetFact ((case None of None => ?f1.0 | Some x => ?f2.0 x) = ?f1.0, Option.option.case_1)
Option.option.case_2
WithTerm case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x
WithScore 1
GetFact ((case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x) = ?f2.0 ?x2.0, Option.option.case_2)
### theory "Draft.Logic_Thms"
### 0.121s elapsed time, 0.241s cpu time, 0.000s GC time
Loading theory "Draft.Order_Thms" (required by "Draft.Order_ThmsMoreTemplates")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.555s elapsed time, 1.162s cpu time, 0.074s GC time
signature UTIL_ARITH =
  sig
    val contra_by_arith: Proof.context -> thm list -> thm
    val dest_numc: term -> int
    val dest_numc_rat: term -> Rat.rat
    val intT: typ
    val is_divide: term -> bool
    val is_linorder: Proof.context -> term -> bool
    val is_minus: term -> bool
    val is_numc: term -> bool
    val is_one: term -> bool
    val is_order: term -> bool
    val is_plus: term -> bool
    val is_times: term -> bool
    val is_zero: term -> bool
    val natT: typ
    val neg_ineq_back_cv: conv
    val neg_ineq_cv: conv
    val prove_by_arith: Proof.context -> thm list -> term -> thm
    val ratT: typ
    val rat_zero: Rat.rat
  end
structure UtilArith: UTIL_ARITH
val natT = "nat": typ
val intT = "int": typ
Orderings.preorder_class.order.trans
WithFact ?a <= ?b
WithFact ?b <= ?c
GetFact (?a <= ?c, Orderings.preorder_class.order.trans) + 1 filters
Orderings.preorder_class.order.strict_trans
WithFact ?a < ?b
WithFact ?b < ?c
GetFact (?a < ?c, Orderings.preorder_class.order.strict_trans) + 1 filters
Orderings.order_le_less_trans
WithFact ?x <= ?y
WithFact ?y < ?z
GetFact (?x < ?z, Orderings.order_le_less_trans) + 1 filters
Orderings.order_less_le_trans
WithFact ?x < ?y
WithFact ?y <= ?z
GetFact (?x < ?z, Orderings.order_less_le_trans) + 1 filters
Orderings.preorder_class.order.irrefl@res
WithFact ?a < ?a
GetResolve Orderings.preorder_class.order.irrefl@res
Orderings.order_class.le_neq_trans
WithFact ?a <= ?b
WithGoal ?a = ?b
GetFact (?a < ?b, Orderings.order_class.le_neq_trans) + 1 filters
Orderings.order_class.order_antisym
WithFact ?x <= ?y
WithFact ?y <= ?x
GetFact (?x = ?y, Orderings.order_class.order_antisym) + 2 filters
Lattices.linorder_class.min.commute
WithTerm min ?a ?b
GetFact (min ?a ?b = min ?b ?a, Lattices.linorder_class.min.commute)
Lattices.linorder_class.min.idem
WithTerm min ?a ?a
GetFact (min ?a ?a = ?a, Lattices.linorder_class.min.idem)
Lattices.linorder_class.min.cobounded1
WithTerm min ?a ?b
GetFact (min ?a ?b <= ?a, Lattices.linorder_class.min.cobounded1)
Lattices.linorder_class.min.cobounded2
WithTerm min ?a ?b
GetFact (min ?a ?b <= ?b, Lattices.linorder_class.min.cobounded2)
Lattices.linorder_class.min.boundedI@back2
WithGoal ?a <= min ?b ?c
WithFact ?a <= ?b
GetGoal (?a <= ?c, Lattices.linorder_class.min.boundedI@back2)
Lattices.linorder_class.min.mono@back2
WithGoal min ?a ?b <= min ?c ?d
WithFact ?a <= ?c
GetGoal (?b <= ?d, Lattices.linorder_class.min.mono@back2)
Lattices.linorder_class.min.absorb1
WithTerm min ?a ?b
WithFact ?a <= ?b
GetFact (min ?a ?b = ?a, Lattices.linorder_class.min.absorb1)
Lattices.linorder_class.min.absorb2
WithTerm min ?a ?b
WithFact ?b <= ?a
GetFact (min ?a ?b = ?b, Lattices.linorder_class.min.absorb2)
Lattices.linorder_class.max.commute
WithTerm max ?a ?b
GetFact (max ?a ?b = max ?b ?a, Lattices.linorder_class.max.commute)
Lattices.linorder_class.max.idem
WithTerm max ?a ?a
GetFact (max ?a ?a = ?a, Lattices.linorder_class.max.idem)
Lattices.linorder_class.max.cobounded1
WithTerm max ?a ?b
GetFact (?a <= max ?a ?b, Lattices.linorder_class.max.cobounded1)
Lattices.linorder_class.max.cobounded2
WithTerm max ?a ?b
GetFact (?b <= max ?a ?b, Lattices.linorder_class.max.cobounded2)
Lattices.linorder_class.max.boundedI@back2
WithGoal max ?b ?c <= ?a
WithFact ?b <= ?a
GetGoal (?c <= ?a, Lattices.linorder_class.max.boundedI@back2)
Lattices.linorder_class.max.mono@back2
WithGoal max ?c ?d <= max ?a ?b
WithFact ?c <= ?a
GetGoal (?d <= ?b, Lattices.linorder_class.max.mono@back2)
Lattices.linorder_class.max.absorb1
WithTerm max ?a ?b
WithFact ?b <= ?a
GetFact (max ?a ?b = ?a, Lattices.linorder_class.max.absorb1)
Lattices.linorder_class.max.absorb2
WithTerm max ?a ?b
WithFact ?a <= ?b
GetFact (max ?a ?b = ?b, Lattices.linorder_class.max.absorb2)
Lattices_Big.linorder_class.Min_in@back
WithProperty finite ?A
WithGoal Min ?A : ?A
GetFact (?A = {}, Lattices_Big.linorder_class.Min_in@back)
Lattices_Big.linorder_class.Min_le@back
WithProperty finite ?A
WithGoal Min ?A <= ?x
GetGoal (?x : ?A, Lattices_Big.linorder_class.Min_le@back)
Lattices_Big.linorder_class.Min_eqI@back2
WithProperty finite ?A
WithGoal Min ?A = ?x
WithFact ALL y. y : ?A --> ?x <= y
GetGoal (?x : ?A, Lattices_Big.linorder_class.Min_eqI@back2)
Order_Thms.exists_ge@res
WithGoal EX k. ?i <= k
GetResolve Order_Thms.exists_ge@res
Orderings.no_bot_class.lt_ex@res
WithGoal EX y. y < ?x
GetResolve Orderings.no_bot_class.lt_ex@res
Orderings.no_top_class.gt_ex@res
WithGoal EX y. ?x < y
GetResolve Orderings.no_top_class.gt_ex@res
Orderings.dense_order_class.dense@back
WithGoal EX z>?x. z < ?y
GetGoal (?x < ?y, Orderings.dense_order_class.dense@back)
### theory "Draft.Order_Thms"
### 0.276s elapsed time, 0.486s cpu time, 0.052s GC time
Loading theory "Draft.Order_ThmsMoreTemplates"
val templateLemmas =
   [("Order_Thms.exists_ge", "EX k. ?i <= k",
     template_predicate (template_app (template_hole 1, t_empty)))]:
   (string * thm * template) list
### theory "Draft.Order_ThmsMoreTemplates"
### 0.276s elapsed time, 0.374s cpu time, 0.000s GC time
val it = (): unit
