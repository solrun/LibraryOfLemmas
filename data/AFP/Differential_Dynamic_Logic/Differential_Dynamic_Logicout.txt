Loading theory "HOL-Combinatorics.Transposition" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Combinatorics.Permutations")
Loading theory "HOL-Decision_Procs.Dense_Linear_Order" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
Loading theory "HOL-Library.Code_Abstract_Nat" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral_Float" via "HOL-Library.Code_Target_Numeral" via "HOL-Library.Code_Target_Nat")
Loading theory "HOL-Library.Cancellation" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Combinatorics.Permutations" via "HOL-Library.Multiset")
### theory "HOL-Library.Code_Abstract_Nat"
### 0.058s elapsed time, 0.259s cpu time, 0.000s GC time
Loading theory "HOL-Library.Code_Target_Nat" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral_Float" via "HOL-Library.Code_Target_Numeral")
### ML warning (line 98 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 99 of "~~/src/HOL/Decision_Procs/langford_data.ML"):
### Pattern is not exhaustive.
signature LANGFORD_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val get: Proof.context -> simpset * (thm * entry) list
    val match: Proof.context -> cterm -> entry option
  end
structure Langford_Data: LANGFORD_DATA
### Code generator: dropping subsumed code equation
### divmod_nat ?m ?n ==
### if ?n = 0 | ?m < ?n then (0, ?m)
### else let (q, y) = divmod_nat (?m - ?n) ?n in (Suc q, y)
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### Suc ?m <= ?n == ?m < ?n
### Code generator: dropping subsumed code equation
### 0 <= ?n == True
### Code generator: dropping subsumed code equation
### ?m < Suc ?n == ?m <= ?n
### Code generator: dropping subsumed code equation
### ?n < 0 == False
### Code generator: dropping subsumed code equation
### of_nat ?n == semiring_1_class.of_nat_aux (%i. i + (1::?'a)) ?n (0::?'a)
### theory "HOL-Combinatorics.Transposition"
### 0.180s elapsed time, 0.740s cpu time, 0.030s GC time
Loading theory "HOL-Library.Code_Target_Int" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral_Float" via "HOL-Library.Code_Target_Numeral")
signature FERRANTE_RACKOF_DATA =
  sig
    val add: entry -> attribute
    val del: attribute
    type entry
    val funs:
       thm ->
         {isolate_conv:
          morphism -> Proof.context -> cterm list -> cterm -> thm,
          simpset: morphism -> Proof.context -> simpset,
          whatis: morphism -> cterm -> cterm -> ord}
           -> declaration
    val get: Proof.context -> (thm * entry) list
    val match: Proof.context -> cterm -> entry option
    datatype ord = Eq | Ge | Gt | Le | Lt | NEq | Nox
  end
structure Ferrante_Rackoff_Data: FERRANTE_RACKOF_DATA
### theory "HOL-Library.Code_Target_Nat"
### 0.134s elapsed time, 0.519s cpu time, 0.030s GC time
Loading theory "HOL-Library.FuncSet" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Combinatorics.Permutations" via "HOL-Library.Disjoint_Sets")
### Code generator: dropping subsumed code equation
### 1 == Int.Pos num.One
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Neg ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m + Int.Pos ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Neg ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### Int.Pos ?m + Int.Pos ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### 0 + ?l == ?l
### Code generator: dropping subsumed code equation
### ?k + 0 == ?k
### Code generator: dropping subsumed code equation
### - Int.Neg ?m == Int.Pos ?m
### Code generator: dropping subsumed code equation
### - Int.Pos ?m == Int.Neg ?m
### Code generator: dropping subsumed code equation
### - 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Neg ?n == Int.sub ?n ?m
### Code generator: dropping subsumed code equation
### Int.Neg ?m - Int.Pos ?n == Int.Neg (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Neg ?n == Int.Pos (?m + ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m - Int.Pos ?n == Int.sub ?m ?n
### Code generator: dropping subsumed code equation
### 0 - ?l == - ?l
### Code generator: dropping subsumed code equation
### ?k - 0 == ?k
### Code generator: dropping subsumed code equation
### Int.dup (Int.Neg ?n) == Int.Neg (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup (Int.Pos ?n) == Int.Pos (num.Bit0 ?n)
### Code generator: dropping subsumed code equation
### Int.dup 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Neg ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m * Int.Pos ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Neg ?n == Int.Neg (?m * ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m * Int.Pos ?n == Int.Pos (?m * ?n)
### Code generator: dropping subsumed code equation
### 0 * ?l == 0
### Code generator: dropping subsumed code equation
### ?k * 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Neg ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Neg ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Neg ?m div Int.Pos ?n == - Divides.adjust_div (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m div Int.Pos ?n == fst (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k div Int.Neg num.One == - ?k
### Code generator: dropping subsumed code equation
### ?k div Int.Pos num.One == ?k
### Code generator: dropping subsumed code equation
### 0 div ?k == 0
### Code generator: dropping subsumed code equation
### ?k div 0 == 0
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Neg ?n == - snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Neg ?n ==
### - Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Neg ?m mod Int.Pos ?n ==
### Divides.adjust_mod (Int.Pos ?n) (snd (divmod ?m ?n))
### Code generator: dropping subsumed code equation
### Int.Pos ?m mod Int.Pos ?n == snd (divmod ?m ?n)
### Code generator: dropping subsumed code equation
### ?k mod Int.Neg num.One == 0
### Code generator: dropping subsumed code equation
### ?k mod Int.Pos num.One == 0
### Code generator: dropping subsumed code equation
### 0 mod ?k == 0
### Code generator: dropping subsumed code equation
### ?k mod 0 == ?k
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit1 ?n) ==
### if ?m < ?n then (0, numeral (num.Bit1 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit1 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit1 ?n) ==
### if ?m <= ?n then (0, numeral (num.Bit0 ?m))
### else divmod_step (num.Bit1 ?n)
###       (divmod (num.Bit0 ?m) (num.Bit0 (num.Bit1 ?n)))
### Code generator: dropping subsumed code equation
### divmod (num.Bit1 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r + 1)
### Code generator: dropping subsumed code equation
### divmod (num.Bit0 ?m) (num.Bit0 ?n) ==
### case divmod ?m ?n of (q, r) => (q, 2 * r)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit1 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod num.One (num.Bit0 ?n) == (0, Numeral1)
### Code generator: dropping subsumed code equation
### divmod ?m num.One == (numeral ?m, 0)
### Code generator: dropping subsumed code equation
### equal_class.equal ?k ?k == True
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Neg ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Neg ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) (Int.Pos ?l) == equal_class.equal ?k ?l
### Code generator: dropping subsumed code equation
### equal_class.equal (Int.Pos ?k) 0 == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Neg ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 (Int.Pos ?l) == False
### Code generator: dropping subsumed code equation
### equal_class.equal 0 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Neg ?l == ?l <= ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= Int.Pos ?l == ?k <= ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k <= 0 == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 <= Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 <= 0 == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Neg ?l == ?l < ?k
### Code generator: dropping subsumed code equation
### Int.Neg ?k < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### Int.Neg ?k < 0 == True
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### Int.Pos ?k < Int.Pos ?l == ?k < ?l
### Code generator: dropping subsumed code equation
### Int.Pos ?k < 0 == False
### Code generator: dropping subsumed code equation
### 0 < Int.Neg ?l == False
### Code generator: dropping subsumed code equation
### 0 < Int.Pos ?l == True
### Code generator: dropping subsumed code equation
### 0 < 0 == False
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Code generator: dropping subsumed code equation
### of_int (Int.Pos ?k) == numeral ?k
### Code generator: dropping subsumed code equation
### of_int 0 == 0::?'a
### Code generator: dropping subsumed code equation
### of_int (Int.Neg ?k) == - numeral ?k
signature CANCEL = sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Fun (Data: CANCEL_NUMERALS_DATA): CANCEL
### Code generator: dropping subsumed code equation
### nat (Int.Pos ?k) == nat_of_num ?k
### Code generator: dropping subsumed code equation
### nat 0 == 0
### Code generator: dropping subsumed code equation
### nat (Int.Neg ?k) == 0
### theory "HOL-Library.Code_Target_Int"
### 0.151s elapsed time, 0.602s cpu time, 0.037s GC time
Loading theory "HOL-Library.Code_Target_Numeral" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Library.Code_Target_Numeral_Float")
signature CANCEL_DATA =
  sig
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss1: simpset
    val norm_ss2: simpset
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Cancel_Data: CANCEL_DATA
signature CANCEL_SIMPROCS =
  sig
    val diff_cancel: Proof.context -> cterm -> thm option
    val eq_cancel: Proof.context -> cterm -> thm option
    val less_cancel: Proof.context -> cterm -> thm option
    val less_eq_cancel: Proof.context -> cterm -> thm option
  end
structure Cancel_Simprocs: CANCEL_SIMPROCS
### theory "HOL-Library.Cancellation"
### 0.421s elapsed time, 1.685s cpu time, 0.098s GC time
Loading theory "HOL-Library.Multiset" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Combinatorics.Permutations")
### theory "HOL-Library.Code_Target_Numeral"
### 0.116s elapsed time, 0.451s cpu time, 0.031s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
instantiation
  multiset :: (type) cancel_comm_monoid_add
  zero_multiset == zero_class.zero :: 'a multiset
  minus_multiset == minus :: 'a multiset => 'a multiset => 'a multiset
  plus_multiset == plus :: 'a multiset => 'a multiset => 'a multiset
### theory "HOL-Library.Function_Algebras"
### 0.117s elapsed time, 0.452s cpu time, 0.074s GC time
Loading theory "HOL-Library.Infinite_Set" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra")
### theory "HOL-Library.FuncSet"
### 0.375s elapsed time, 1.462s cpu time, 0.142s GC time
Loading theory "HOL-Library.Disjoint_Sets" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Combinatorics.Permutations")
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
consts
  enumerate :: "'a set => nat => 'a"
### theory "HOL-Library.Disjoint_Sets"
### 0.378s elapsed time, 1.368s cpu time, 0.397s GC time
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
### theory "HOL-Library.Infinite_Set"
### 0.397s elapsed time, 1.439s cpu time, 0.397s GC time
Loading theory "HOL-Library.Old_Datatype" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product" via "HOL-Library.Countable_Set" via "HOL-Library.Countable")
### ML warning (file "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 24 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (q) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Value identifier (p) has not been referenced.
### ML warning (file "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 100 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Matches are not exhaustive.
### ML warning (line 136 of "~~/src/HOL/Decision_Procs/langford.ML"):
### Pattern is not exhaustive.
signature LANGFORD =
  sig
    val dlo_conv: Proof.context -> cterm -> thm
    val dlo_tac: Proof.context -> int -> tactic
  end
structure Langford: LANGFORD
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale linorder_stupid_syntax
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
  assumes "linorder_stupid_syntax less_eq less"
Found termination order: "size_list size <*mlex*> {}"
locale linorder_no_ub
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
  assumes "linorder_no_ub (\<sqsubseteq>) (\<sqsubset>)"
### Partially applied constant "Multiset.inter_mset" on left hand side of equation, in theorem:
### semilattice_inf.Inf_fin (\<inter>#) (set (?x # ?xs)) ==
### fold (\<inter>#) ?xs ?x
### Partially applied constant "Multiset.union_mset" on left hand side of equation, in theorem:
### semilattice_sup.Sup_fin (\<union>#) (set (?x # ?xs)) ==
### fold (\<union>#) ?xs ?x
### theory "HOL-Library.Nat_Bijection"
### 0.336s elapsed time, 1.306s cpu time, 0.180s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.ExtrEqs")
signature OLD_DATATYPE =
  sig
    val check_specs: spec list -> theory -> spec list * Proof.context
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val distinct_lemma: thm
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val read_specs: spec_cmd list -> theory -> spec list * Proof.context
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    type spec_cmd =
       (binding * (string * string option) list * mixfix) *
       (binding * string list * mixfix) list
  end
structure Old_Datatype: OLD_DATATYPE
### theory "HOL-Library.Old_Datatype"
### 0.345s elapsed time, 1.365s cpu time, 0.106s GC time
Loading theory "HOL-Library.Phantom_Type" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product" via "HOL-Library.Numeral_Type" via "HOL-Library.Cardinality")
locale linorder_no_lb
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
  assumes "linorder_no_lb (\<sqsubseteq>) (\<sqsubset>)"
signature MULTISET_SIMPROCS =
  sig
    val subset_cancel_msets: Proof.context -> cterm -> thm option
    val subseteq_cancel_msets: Proof.context -> cterm -> thm option
  end
structure Multiset_Simprocs: MULTISET_SIMPROCS
locale constr_dense_linorder
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and between :: "'a => 'a => 'a"
  assumes "constr_dense_linorder (\<sqsubseteq>) (\<sqsubset>) between"
instantiation
  multiset :: (type) Inf
  Inf_multiset == Inf :: 'a multiset set => 'a multiset
instantiation
  multiset :: (type) Sup
  Sup_multiset == Sup :: 'a multiset set => 'a multiset
instantiation
  multiset :: (type) size
  size_multiset == size :: 'a multiset => nat
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
### ML warning (line 33 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (simpset) has not been referenced.
### ML warning (line 32 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (atoms) has not been referenced.
### ML warning (line 31 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (entr) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 35 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 63 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 90 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (file "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 113 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 115 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 117 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 119 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 121 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 149 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Matches are not exhaustive.
### ML warning (line 147 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Decision_Procs/ferrante_rackoff.ML"):
### Pattern is not exhaustive.
signature FERRANTE_RACKOFF =
  sig
    val dlo_conv: Proof.context -> conv
    val dlo_tac: Proof.context -> int -> tactic
  end
structure FerranteRackoff: FERRANTE_RACKOFF
  Proving monotonicity ...
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Min (<=) (set (?x # ?xs)) == fold (ord.min (<=)) ?xs ?x
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### linorder.Max (<=) (set (?x # ?xs)) == fold (ord.max (<=)) ?xs ?x
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
### theory "HOL-Library.Phantom_Type"
### 0.713s elapsed time, 2.633s cpu time, 0.844s GC time
Loading theory "HOL-Library.Cardinality" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product" via "HOL-Library.Numeral_Type")
consts
  mset :: "'a list => 'a multiset"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
### Additional type variable(s) in locale specification "CARD_1": 'a
consts
  cycle :: "'a list => 'a stream"
class CARD_1 = type +
  assumes "CARD_1": "CARD('a) = 1"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
### theory "HOL-Decision_Procs.Dense_Linear_Order"
### 2.144s elapsed time, 8.162s cpu time, 1.593s GC time
Loading theory "HOL-Library.Product_Plus" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra" via "HOL-Analysis.Euclidean_Space" via "HOL-Analysis.Product_Vector")
instantiation
  prod :: (zero, zero) zero
  zero_prod == zero_class.zero :: 'a * 'b
instantiation
  prod :: (plus, plus) plus
  plus_prod == plus :: 'a * 'b => 'a * 'b => 'a * 'b
instantiation
  prod :: (minus, minus) minus
  minus_prod == minus :: 'a * 'b => 'a * 'b => 'a * 'b
consts
  flat :: "'a list stream => 'a stream"
instantiation
  prod :: (uminus, uminus) uminus
  uminus_prod == uminus :: 'a * 'b => 'a * 'b
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### theory "HOL-Library.Product_Plus"
### 0.100s elapsed time, 0.415s cpu time, 0.058s GC time
Loading theory "HOL-Library.Product_Order" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Finite_Product_Measure" via "HOL-Analysis.Binary_Product_Measure" via "HOL-Analysis.Nonnegative_Lebesgue_Integration" via "HOL-Analysis.Borel_Space" via "HOL-Analysis.Ordered_Euclidean_Space")
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
### Additional type variable(s) in locale specification "card2": 'a
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
instantiation
  prod :: (ord, ord) ord
  less_eq_prod == less_eq :: 'a * 'b => 'a * 'b => bool
  less_prod == less :: 'a * 'b => 'a * 'b => bool
instantiation
  prod :: (inf, inf) inf
  inf_prod == inf :: 'a * 'b => 'a * 'b => 'a * 'b
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
class card2 = finite +
  assumes "two_le_card": "2 <= CARD('a)"
locale comm_monoid_mset
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_mset (\<^bold>*) \<^bold>1"
instantiation
  prod :: (sup, sup) sup
  sup_prod == sup :: 'a * 'b => 'a * 'b => 'a * 'b
### theory "HOL-Library.Stream"
### 1.047s elapsed time, 3.979s cpu time, 0.974s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  prod :: (top, top) top
  top_prod == top :: 'a * 'b
class finite_UNIV = type +
  fixes finite_UNIV :: "('a, bool) phantom"
  assumes "finite_UNIV": "finite_UNIV = Phantom('a) (finite UNIV)"
instantiation
  prod :: (bot, bot) bot
  bot_prod == bot :: 'a * 'b
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  prod :: (Inf, Inf) Inf
  Inf_prod == Inf :: ('a * 'b) set => 'a * 'b
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  prod :: (Sup, Sup) Sup
  Sup_prod == Sup :: ('a * 'b) set => 'a * 'b
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class card_UNIV = finite_UNIV +
  fixes card_UNIV :: "('a, nat) phantom"
  assumes "card_UNIV": "card_UNIV_class.card_UNIV = Phantom('a) CARD('a)"
instantiation
  nat :: card_UNIV
  card_UNIV_nat == card_UNIV_class.card_UNIV :: (nat, nat) phantom
  finite_UNIV_nat == finite_UNIV :: (nat, bool) phantom
instantiation
  int :: card_UNIV
  card_UNIV_int == card_UNIV_class.card_UNIV :: (int, nat) phantom
  finite_UNIV_int == finite_UNIV :: (int, bool) phantom
instantiation
  natural :: card_UNIV
  card_UNIV_natural == card_UNIV_class.card_UNIV :: (natural, nat) phantom
  finite_UNIV_natural == finite_UNIV :: (natural, bool) phantom
instantiation
  integer :: card_UNIV
  card_UNIV_integer == card_UNIV_class.card_UNIV :: (integer, nat) phantom
  finite_UNIV_integer == finite_UNIV :: (integer, bool) phantom
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### theory "HOL-Library.Product_Order"
### 0.202s elapsed time, 0.797s cpu time, 0.072s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
instantiation
  list :: (type) card_UNIV
  card_UNIV_list == card_UNIV_class.card_UNIV :: ('a list, nat) phantom
  finite_UNIV_list == finite_UNIV :: ('a list, bool) phantom
instantiation
  unit :: card_UNIV
  card_UNIV_unit == card_UNIV_class.card_UNIV :: (unit, nat) phantom
  finite_UNIV_unit == finite_UNIV :: (unit, bool) phantom
instantiation
  bool :: card_UNIV
  card_UNIV_bool == card_UNIV_class.card_UNIV :: (bool, nat) phantom
  finite_UNIV_bool == finite_UNIV :: (bool, bool) phantom
instantiation
  char :: card_UNIV
  card_UNIV_char == card_UNIV_class.card_UNIV :: (char, nat) phantom
  finite_UNIV_char == finite_UNIV :: (char, bool) phantom
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
instantiation
  prod :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_prod == finite_UNIV :: ('a * 'b, bool) phantom
instantiation
  prod :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_prod == card_UNIV_class.card_UNIV :: ('a * 'b, nat) phantom
instantiation
  sum :: (finite_UNIV, finite_UNIV) finite_UNIV
  finite_UNIV_sum == finite_UNIV :: ('a + 'b, bool) phantom
instantiation
  sum :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_sum == card_UNIV_class.card_UNIV :: ('a + 'b, nat) phantom
### theory "HOL-Library.Set_Algebras"
### 0.196s elapsed time, 0.768s cpu time, 0.073s GC time
Loading theory "HOL-Library.Countable" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product" via "HOL-Library.Countable_Set")
instantiation
  fun :: (finite_UNIV, card_UNIV) finite_UNIV
  finite_UNIV_fun == finite_UNIV :: ('a => 'b, bool) phantom
instantiation
  fun :: (card_UNIV, card_UNIV) card_UNIV
  card_UNIV_fun == card_UNIV_class.card_UNIV :: ('a => 'b, nat) phantom
instantiation
  option :: (finite_UNIV) finite_UNIV
  finite_UNIV_option == finite_UNIV :: ('a option, bool) phantom
instantiation
  option :: (card_UNIV) card_UNIV
  card_UNIV_option == card_UNIV_class.card_UNIV :: ('a option, nat) phantom
instantiation
  String.literal :: card_UNIV
  card_UNIV_literal == card_UNIV_class.card_UNIV ::
    (String.literal, nat) phantom
  finite_UNIV_literal == finite_UNIV :: (String.literal, bool) phantom
instantiation
  set :: (finite_UNIV) finite_UNIV
  finite_UNIV_set == finite_UNIV :: ('a set, bool) phantom
instantiation
  set :: (card_UNIV) card_UNIV
  card_UNIV_set == card_UNIV_class.card_UNIV :: ('a set, nat) phantom
instantiation
  Enum.finite_1 :: card_UNIV
  card_UNIV_finite_1 == card_UNIV_class.card_UNIV ::
    (Enum.finite_1, nat) phantom
  finite_UNIV_finite_1 == finite_UNIV :: (Enum.finite_1, bool) phantom
instantiation
  Enum.finite_2 :: card_UNIV
  card_UNIV_finite_2 == card_UNIV_class.card_UNIV ::
    (Enum.finite_2, nat) phantom
  finite_UNIV_finite_2 == finite_UNIV :: (Enum.finite_2, bool) phantom
instantiation
  Enum.finite_3 :: card_UNIV
  card_UNIV_finite_3 == card_UNIV_class.card_UNIV ::
    (Enum.finite_3, nat) phantom
  finite_UNIV_finite_3 == finite_UNIV :: (Enum.finite_3, bool) phantom
instantiation
  Enum.finite_4 :: card_UNIV
  card_UNIV_finite_4 == card_UNIV_class.card_UNIV ::
    (Enum.finite_4, nat) phantom
  finite_UNIV_finite_4 == finite_UNIV :: (Enum.finite_4, bool) phantom
instantiation
  Enum.finite_5 :: card_UNIV
  card_UNIV_finite_5 == card_UNIV_class.card_UNIV ::
    (Enum.finite_5, nat) phantom
  finite_UNIV_finite_5 == finite_UNIV :: (Enum.finite_5, bool) phantom
### theory "HOL-Library.Cardinality"
### 0.649s elapsed time, 2.579s cpu time, 0.271s GC time
Loading theory "HOL-Library.Code_Cardinality" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "Ordinary_Differential_Equations.ODE_Auxiliarities" via "Affine_Arithmetic.Executable_Euclidean_Space")
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
### Code generator: dropping subsumed code equation
### List.coset [] <= set [] == False
### theory "HOL-Library.Code_Cardinality"
### 0.090s elapsed time, 0.353s cpu time, 0.000s GC time
Loading theory "HOL-Library.Numeral_Type" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product")
instantiation
  num1 :: CARD_1
instantiation
  num1 :: {comm_monoid_mult,numeral,comm_ring}
  uminus_num1 == uminus :: num1 => num1
  zero_num1 == zero_class.zero :: num1
  minus_num1 == minus :: num1 => num1 => num1
  plus_num1 == plus :: num1 => num1 => num1
  one_num1 == one_class.one :: num1
  times_num1 == times :: num1 => num1 => num1
### Additional type variable(s) in locale specification "countable": 'a
instantiation
  num1 :: linorder
  less_eq_num1 == less_eq :: num1 => num1 => bool
  less_num1 == less :: num1 => num1 => bool
class countable = type +
  assumes "ex_inj": "EX to_nat. inj to_nat"
locale mod_type
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_type n Rep Abs"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
locale mod_ring
  fixes n :: "int"
    and Rep :: "'a => int"
    and Abs :: "int => 'a"
  assumes "mod_ring n Rep Abs"
instantiation
  bit0 :: (finite) {minus,one,plus,times,uminus,zero}
  bit1 :: (finite) {minus,one,plus,times,uminus,zero}
  zero_bit0 == zero_class.zero :: 'a bit0
  uminus_bit0 == uminus :: 'a bit0 => 'a bit0
  times_bit0 == times :: 'a bit0 => 'a bit0 => 'a bit0
  plus_bit0 == plus :: 'a bit0 => 'a bit0 => 'a bit0
  one_bit0 == one_class.one :: 'a bit0
  minus_bit0 == minus :: 'a bit0 => 'a bit0 => 'a bit0
  zero_bit1 == zero_class.zero :: 'a bit1
  uminus_bit1 == uminus :: 'a bit1 => 'a bit1
  times_bit1 == times :: 'a bit1 => 'a bit1 => 'a bit1
  plus_bit1 == plus :: 'a bit1 => 'a bit1 => 'a bit1
  one_bit1 == one_class.one :: 'a bit1
  minus_bit1 == minus :: 'a bit1 => 'a bit1 => 'a bit1
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "finite_item"
  Proving monotonicity ...
instantiation
  bit0 :: (finite) linorder
  bit1 :: (finite) linorder
  less_eq_bit0 == less_eq :: 'a bit0 => 'a bit0 => bool
  less_bit0 == less :: 'a bit0 => 'a bit0 => bool
  less_eq_bit1 == less_eq :: 'a bit1 => 'a bit1 => bool
  less_bit1 == less :: 'a bit1 => 'a bit1 => bool
Found termination order: "size <*mlex*> {}"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
instantiation
  num0 :: equal
  equal_num0 == equal_class.equal :: num0 => num0 => bool
instantiation
  num1 :: equal
  equal_num1 == equal_class.equal :: num1 => num1 => bool
instantiation
  num1 :: enum
  enum_num1 == enum_class.enum :: num1 list
  enum_all_num1 == enum_class.enum_all :: (num1 => bool) => bool
  enum_ex_num1 == enum_class.enum_ex :: (num1 => bool) => bool
Found termination order: "size <*mlex*> {}"
instantiation
  num0 :: card_UNIV
  num1 :: card_UNIV
  card_UNIV_num0 == card_UNIV_class.card_UNIV :: (num0, nat) phantom
  finite_UNIV_num0 == finite_UNIV :: (num0, bool) phantom
  card_UNIV_num1 == card_UNIV_class.card_UNIV :: (num1, nat) phantom
  finite_UNIV_num1 == finite_UNIV :: (num1, bool) phantom
val old_countable_datatype_tac = fn: Proof.context -> int -> tactic
Found termination order: "size <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  bit0 :: (finite) equal
  bit1 :: (finite) equal
  equal_bit0 == equal_class.equal :: 'a bit0 => 'a bit0 => bool
  equal_bit1 == equal_class.equal :: 'a bit1 => 'a bit1 => bool
instantiation
  bit0 :: (finite) enum
  enum_bit0 == enum_class.enum :: 'a bit0 list
  enum_all_bit0 == enum_class.enum_all :: ('a bit0 => bool) => bool
  enum_ex_bit0 == enum_class.enum_ex :: ('a bit0 => bool) => bool
### ML warning (line 93 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 139 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 145 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/BNF/bnf_lfp_countable.ML"):
### Pattern is not exhaustive.
signature BNF_LFP_COUNTABLE =
  sig
    val countable_datatype_tac: Proof.context -> tactic
    val derive_encode_injectives_thms:
       Proof.context -> string list -> thm list
  end
structure BNF_LFP_Countable: BNF_LFP_COUNTABLE
val countable_datatype_tac = fn: Proof.context -> thm -> thm Seq.seq
val countable_tac = fn: Proof.context -> int -> tactic
instantiation
  bit1 :: (finite) enum
  enum_bit1 == enum_class.enum :: 'a bit1 list
  enum_all_bit1 == enum_class.enum_all :: ('a bit1 => bool) => bool
  enum_ex_bit1 == enum_class.enum_ex :: ('a bit1 => bool) => bool
Found termination order: "size <*mlex*> {}"
instantiation
  bit0 :: (finite) finite_UNIV
  bit1 :: (finite) finite_UNIV
  finite_UNIV_bit0 == finite_UNIV :: ('a bit0, bool) phantom
  finite_UNIV_bit1 == finite_UNIV :: ('a bit1, bool) phantom
instantiation
  bit0 :: ({card_UNIV,finite}) card_UNIV
  bit1 :: ({card_UNIV,finite}) card_UNIV
  card_UNIV_bit0 == card_UNIV_class.card_UNIV :: ('a bit0, nat) phantom
  card_UNIV_bit1 == card_UNIV_class.card_UNIV :: ('a bit1, nat) phantom
### theory "HOL-Library.Numeral_Type"
### 0.637s elapsed time, 2.514s cpu time, 0.211s GC time
Loading theory "HOL-Analysis.Metric_Arith" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Elementary_Normed_Spaces" via "HOL-Analysis.Elementary_Metric_Spaces")
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (preorder) order
  less_eq_multiset == less_eq :: 'a multiset => 'a multiset => bool
  less_multiset == less :: 'a multiset => 'a multiset => bool
### theory "HOL-Library.Countable"
### 1.037s elapsed time, 4.095s cpu time, 0.354s GC time
Loading theory "HOL-Library.Countable_Set" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Analysis.Cartesian_Space" via "HOL-Analysis.Finite_Cartesian_Product")
Found termination order: "size <*mlex*> {}"
instantiation
  multiset :: (preorder) ordered_ab_semigroup_add
Proofs for inductive predicate(s) "pw_leq"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
Found termination order: "(%p. length (fst p)) <*mlex*> {}"
instantiation
  multiset :: (equal) equal
  equal_multiset == equal_class.equal :: 'a multiset => 'a multiset => bool
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  multiset :: (random) random
  random_multiset == random_class.random ::
    natural
    => natural * natural
       => ('a multiset * (unit => term)) * natural * natural
instantiation
  multiset :: (full_exhaustive) full_exhaustive
  full_exhaustive_multiset == full_exhaustive_class.full_exhaustive ::
    ('a multiset * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Proofs for inductive predicate(s) "pred_mset"
  Proving monotonicity ...
### theory "HOL-Library.Countable_Set"
### 0.487s elapsed time, 1.926s cpu time, 0.199s GC time
Loading theory "HOL-Library.Countable_Complete_Lattices" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real" via "HOL-Library.Extended_Nat" via "HOL-Library.Order_Continuity")
Proofs for inductive predicate(s) "rel_mset'"
  Proving monotonicity ...
signature METRIC_ARITH =
  sig
    val argo_timeout: real Config.T
    val metric_arith_tac: Proof.context -> int -> tactic
    val trace: bool Config.T
  end
structure Metric_Arith: METRIC_ARITH
### theory "HOL-Analysis.Metric_Arith"
### 0.688s elapsed time, 2.721s cpu time, 0.274s GC time
Loading theory "HOL-Library.Set_Idioms" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Connected" via "HOL-Analysis.Abstract_Topology_2" via "HOL-Analysis.Elementary_Topology")
### theory "HOL-Library.Multiset"
### 3.739s elapsed time, 14.462s cpu time, 2.251s GC time
Loading theory "HOL-Computational_Algebra.Factorial_Ring" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Jordan_Curve" via "HOL-Analysis.Arcwise_Connected" via "HOL-Computational_Algebra.Primes" via "HOL-Computational_Algebra.Euclidean_Algorithm")
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Set_Idioms"
### 0.647s elapsed time, 2.318s cpu time, 1.463s GC time
Loading theory "HOL-Combinatorics.Permutations" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants")
### theory "HOL-Library.Tree"
### 2.361s elapsed time, 9.093s cpu time, 2.089s GC time
Loading theory "Draft.Templates" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.083s elapsed time, 0.336s cpu time, 0.000s GC time
Loading theory "Draft.Ids" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
### theory "Draft.Ids"
### 0.116s elapsed time, 0.447s cpu time, 0.113s GC time
Loading theory "Draft.Syntax" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
class countable_complete_lattice = Inf + Sup + lattice + bot + top +
  assumes "ccInf_lower": "!!A x. [| countable A; x : A |] ==> Inf A <= x"
  assumes
    "ccInf_greatest":
      "!!A z. [| countable A; !!x. x : A ==> z <= x |] ==> z <= Inf A"
  assumes "ccSup_upper": "!!A x. [| countable A; x : A |] ==> x <= Sup A"
  assumes
    "ccSup_least":
      "!!A z. [| countable A; !!x. x : A ==> x <= z |] ==> Sup A <= z"
  assumes "ccInf_empty": "Inf {} = top"
  assumes "ccSup_empty": "Sup {} = bot"
Proofs for inductive predicate(s) "swapidseq"
  Proving monotonicity ...
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
class normalization_semidom = algebraic_semidom +
  semidom_divide_unit_factor +
  fixes normalize :: "'a => 'a"
  assumes
    "unit_factor_mult_normalize": "!!a. unit_factor a * normalize a = a"
    and "normalize_0": "normalize (0::'a) = (0::'a)"
Found termination order: "(%p. size_list size (fst p)) <*mlex*> {}"
### theory "HOL-Combinatorics.Permutations"
### 1.480s elapsed time, 5.557s cpu time, 2.062s GC time
Loading theory "HOL-Analysis.Abstract_Topology" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Connected" via "HOL-Analysis.Abstract_Topology_2")
class countable_complete_distrib_lattice = countable_complete_lattice +
  assumes
    "sup_ccInf": "!!B a. countable B ==> sup a (Inf B) = Inf (sup a ` B)"
  assumes
    "inf_ccSup": "!!B a. countable B ==> inf a (Sup B) = Sup (inf a ` B)"
class semiring_gcd = gcd + normalization_semidom +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
    and "normalize_gcd": "!!a b. normalize (gcd a b) = gcd a b"
    and "lcm_gcd": "!!a b. lcm a b = normalize (a * b div gcd a b)"
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "!!x. x ~= (0::'a) ==>
            EX A. (ALL x. x :# A --> prime_elem x) &
                  normalize (\<Prod>\<^sub># A) = normalize x"
### theory "HOL-Library.Countable_Complete_Lattices"
### 3.170s elapsed time, 11.996s cpu time, 3.852s GC time
Loading theory "HOL-Analysis.Continuum_Not_Denumerable" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Homeomorphism" via "HOL-Analysis.Homotopy")
class factorial_semiring = normalization_semidom +
  assumes
    "prime_factorization_exists":
      "!!x. x ~= (0::'a) ==>
            EX A. (ALL x. x :# A --> prime_elem x) &
                  normalize (\<Prod>\<^sub># A) = normalize x"
### theory "HOL-Analysis.Continuum_Not_Denumerable"
### 0.289s elapsed time, 1.143s cpu time, 0.100s GC time
Loading theory "HOL-Analysis.Inner_Product" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra" via "HOL-Analysis.Euclidean_Space")
class real_inner = dist_norm + real_vector + sgn_div_norm +
  uniformity_dist + open_uniformity +
  fixes inner :: "'a => 'a => real"
  assumes "inner_commute": "!!x y. inner x y = inner y x"
    and "inner_add_left": "!!x y z. inner (x + y) z = inner x z + inner y z"
    and
    "inner_scaleR_left": "!!r x y. inner (r *\<^sub>R x) y = r * inner x y"
    and "inner_ge_zero": "!!x. 0 <= inner x x"
    and "inner_eq_zero_iff": "!!x. (inner x x = 0) = (x = (0::'a))"
    and "norm_eq_sqrt_inner": "!!x. norm x = sqrt (inner x x)"
instantiation
  real :: real_inner
  inner_real == inner :: real => real => real
instantiation
  complex :: real_inner
  inner_complex == inner :: complex => complex => real
bundle inner_syntax
bundle no_inner_syntax
### theory "HOL-Analysis.Inner_Product"
### 1.121s elapsed time, 4.419s cpu time, 0.589s GC time
Loading theory "HOL-Analysis.L2_Norm" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra" via "HOL-Analysis.Euclidean_Space")
Proofs for inductive predicate(s) "generate_topology_on"
  Proving monotonicity ...
### theory "HOL-Analysis.L2_Norm"
### 0.093s elapsed time, 0.369s cpu time, 0.000s GC time
Loading theory "HOL-Analysis.Operator_Norm" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Operator_Norm"
### 0.135s elapsed time, 0.530s cpu time, 0.123s GC time
Loading theory "HOL-Analysis.Poly_Roots" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Abstract_Topology"
### 2.643s elapsed time, 10.449s cpu time, 1.139s GC time
Loading theory "HOL-Analysis.Abstract_Limits" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Poly_Roots"
### 0.103s elapsed time, 0.415s cpu time, 0.000s GC time
Loading theory "HOL-Analysis.Product_Vector" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra" via "HOL-Analysis.Euclidean_Space")
### theory "HOL-Analysis.Abstract_Limits"
### 0.246s elapsed time, 0.965s cpu time, 0.117s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.ExtrEqs")
class factorial_semiring_gcd = factorial_semiring + Gcd +
  assumes "gcd_eq_gcd_factorial": "!!a b. gcd a b = gcd_factorial a b"
    and "lcm_eq_lcm_factorial": "!!a b. lcm a b = lcm_factorial a b"
    and "Gcd_eq_Gcd_factorial": "!!A. Gcd A = Gcd_factorial A"
    and "Lcm_eq_Lcm_factorial": "!!A. Lcm A = Lcm_factorial A"
locale module_prod
  fixes s1 :: "'a => 'b => 'b"
    and s2 :: "'a => 'c => 'c"
  assumes "module_prod s1 s2"
locale vector_space_prod
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
  assumes "vector_space_prod (*a) (*b)"
### Cannot skip proof of schematic goal statement
instantiation
  prod :: (real_vector, real_vector) real_vector
  scaleR_prod == scaleR :: real => 'a * 'b => 'a * 'b
### Cannot skip proof of schematic goal statement
instantiation
  prod :: (metric_space, metric_space) dist
  dist_prod == dist :: 'a * 'b => 'a * 'b => real
instantiation
  prod :: (uniformity, uniformity) uniformity
  uniformity_prod == uniformity :: (('a * 'b) * 'a * 'b) filter
instantiation
  prod :: (uniform_space, uniform_space) uniform_space
instantiation
  prod :: (metric_space, metric_space) uniformity_dist
instantiation
  prod :: (metric_space, metric_space) metric_space
instantiation
  prod :: (real_normed_vector, real_normed_vector) real_normed_vector
  sgn_prod == sgn :: 'a * 'b => 'a * 'b
  norm_prod == norm :: 'a * 'b => real
locale finite_dimensional_vector_space_prod
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
    and B1 :: "'b set"
    and B2 :: "'c set"
  assumes "finite_dimensional_vector_space_prod (*a) (*b) B1 B2"
### theory "HOL-Analysis.Product_Vector"
### 0.968s elapsed time, 3.827s cpu time, 0.444s GC time
Loading theory "HOL-Analysis.Elementary_Topology" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Connected" via "HOL-Analysis.Abstract_Topology_2")
### theory "HOL-Library.BigO"
### 0.826s elapsed time, 3.261s cpu time, 0.327s GC time
Loading theory "HOL-Analysis.Euclidean_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine" via "HOL-Analysis.Linear_Algebra")
class topological_space = open +
  assumes "open_UNIV": "open UNIV"
  assumes "open_Int": "!!S T. [| open S; open T |] ==> open (S Int T)"
  assumes "open_Union": "!!K. Ball K open ==> open (\<Union> K)"
locale countable_basis
  fixes p :: "'a set => bool"
    and B :: "'a set set"
  assumes "countable_basis p B"
class euclidean_space = real_inner +
  fixes Basis :: "'a set"
  assumes "nonempty_Basis": "Basis ~= {}"
  assumes "finite_Basis": "finite Basis"
  assumes
    "inner_Basis":
      "!!u v.
          [| u : Basis; v : Basis |]
          ==> inner u v = (if u = v then 1 else 0)"
  assumes
    "euclidean_all_zero_iff":
      "!!x. (ALL u:Basis. inner x u = 0) = (x = (0::'a))"
class second_countable_topology = topological_space +
  assumes
    "ex_countable_subbasis":
      "EX B. countable B & open = generate_topology B"
instantiation
  real :: euclidean_space
  Basis_real == Basis :: real set
instantiation
  complex :: euclidean_space
  Basis_complex == Basis :: complex set
instantiation
  prod :: (real_inner, real_inner) real_inner
  inner_prod == inner :: 'a * 'b => 'a * 'b => real
instantiation
  prod :: (euclidean_space, euclidean_space) euclidean_space
  Basis_prod == Basis :: ('a * 'b) set
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### theory "HOL-Analysis.Euclidean_Space"
### 1.724s elapsed time, 6.796s cpu time, 0.759s GC time
Loading theory "HOL-Analysis.Finite_Cartesian_Product" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants" via "HOL-Analysis.Cartesian_Space")
### theory "HOL-Computational_Algebra.Factorial_Ring"
### 7.460s elapsed time, 29.167s cpu time, 4.553s GC time
Loading theory "HOL-Computational_Algebra.Euclidean_Algorithm" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Jordan_Curve" via "HOL-Analysis.Arcwise_Connected" via "HOL-Computational_Algebra.Primes")
### theory "HOL-Analysis.Elementary_Topology"
### 2.081s elapsed time, 8.205s cpu time, 0.855s GC time
Loading theory "HOL-Analysis.Linear_Algebra" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex" via "HOL-Analysis.Affine")
class real_inner = real_normed_vector +
  fixes inner :: "'a => 'a => real"
  assumes "inner_commute": "!!x y. x \<bullet> y = y \<bullet> x"
    and
    "inner_add_left":
      "!!x y z. (x + y) \<bullet> z = x \<bullet> z + y \<bullet> z"
    and
    "inner_scaleR_left":
      "!!r x y. r *\<^sub>R x \<bullet> y = r * (x \<bullet> y)"
    and "inner_ge_zero": "!!x. 0 <= x \<bullet> x"
    and "inner_eq_zero_iff": "!!x. (x \<bullet> x = 0) = (x = (0::'a))"
    and "norm_eq_sqrt_inner": "!!x. norm x = sqrt (x \<bullet> x)"
bundle vec_syntax
bundle no_vec_syntax
instantiation
  vec :: (zero, finite) zero
  zero_vec == zero_class.zero :: ('a, 'b) vec
instantiation
  vec :: (plus, finite) plus
  plus_vec == plus :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
consts
  sizeF :: "('sf, 'sc, 'sz) formula => nat"
  sizeP :: "('sf, 'sc, 'sz) hp => nat"
instantiation
  vec :: (minus, finite) minus
  minus_vec == minus :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (uminus, finite) uminus
  uminus_vec == uminus :: ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (times, finite) times
  times_vec == times :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (one, finite) one
  one_vec == one_class.one :: ('a, 'b) vec
instantiation
  vec :: (ord, finite) ord
  less_eq_vec == less_eq :: ('a, 'b) vec => ('a, 'b) vec => bool
  less_vec == less :: ('a, 'b) vec => ('a, 'b) vec => bool
instantiation
  vec :: (real_vector, finite) real_vector
  scaleR_vec == scaleR :: real => ('a, 'b) vec => ('a, 'b) vec
instantiation
  vec :: (topological_space, finite) topological_space
  open_vec == open :: ('a, 'b) vec set => bool
instantiation
  vec :: (metric_space, finite) dist
  dist_vec == dist :: ('a, 'b) vec => ('a, 'b) vec => real
instantiation
  vec :: (metric_space, finite) uniformity_dist
  uniformity_vec == uniformity :: (('a, 'b) vec * ('a, 'b) vec) filter
instantiation
  vec :: (metric_space, finite) metric_space
instantiation
  vec :: (real_normed_vector, finite) real_normed_vector
  sgn_vec == sgn :: ('a, 'b) vec => ('a, 'b) vec
  norm_vec == norm :: ('a, 'b) vec => real
Found termination order: "{}"
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
instantiation
  vec :: (real_inner, finite) real_inner
  inner_vec == inner :: ('a, 'b) vec => ('a, 'b) vec => real
instantiation
  vec :: (euclidean_space, finite) euclidean_space
  Basis_vec == Basis :: ('a, 'b) vec set
Found termination order: "{}"
Proofs for inductive predicate(s) "dfree"
  Proving monotonicity ...
### theory "HOL-Analysis.Linear_Algebra"
### 1.112s elapsed time, 4.385s cpu time, 0.449s GC time
Loading theory "HOL-Analysis.Affine" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex")
Proofs for inductive predicate(s) "dsafe"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Proofs for inductive predicate(s) "osafe"
  Proving monotonicity ...
Proofs for inductive predicate(s) "hpfree", "ffree"
  Proving monotonicity ...
### theory "HOL-Analysis.Finite_Cartesian_Product"
### 1.760s elapsed time, 6.920s cpu time, 0.879s GC time
Loading theory "HOL-Analysis.Cartesian_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Determinants")
Proofs for inductive predicate(s) "hpsafe", "fsafe"
  Proving monotonicity ...
### theory "HOL-Analysis.Affine"
### 0.485s elapsed time, 1.900s cpu time, 0.252s GC time
Loading theory "HOL-Analysis.Convex" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### Ambiguous input (line 328 of "$AFP/Differential_Dynamic_Logic/Syntax.thy") produces 4 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>Pure.all_binder" ("_position" x)
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" P)
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" x)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>Pure.all_binder" ("_idts" ("_position" x1) ("_position" x2))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" P)
###           ("\<^const>Syntax.hp.Assign" ("_position" x1) ("_position" x2)))))
###     ("\<^const>Pure.imp"
###       ("\<^const>Pure.all_binder"
###         ("_idts" ("_position" x1) ("_position" x2))
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" P)
###             ("_applC" ("_position" DiffAssign)
###               ("_cargs" ("_position" x1) ("_position" x2))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>Pure.all_binder" ("_position" x)
###           ("\<^const>HOL.Trueprop"
###             ("_applC" ("_position" P)
###               ("_applC" ("\<^const>Syntax.hp.Test") ("_position" x)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>Pure.all_binder"
###             ("_idts" ("_position" x1) ("_position" x2))
###             ("\<^const>HOL.Trueprop"
###               ("_applC" ("_position" P)
###                 ("_applC" ("_position" EvolveODE)
###                   ("_cargs" ("_position" x1) ("_position" x2))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>Pure.all_binder"
###               ("_idts" ("_position" x1) ("_position" x2))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" P) ("_position" x1)))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P) ("_position" x2)))
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P)
###                       ("\<^const>Syntax.hp.Choice" ("_position" x1)
###                         ("_position" x2)))))))
###             ("\<^const>Pure.imp"
###               ("\<^const>Pure.all_binder"
###                 ("_idts" ("_position" x1) ("_position" x2))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P) ("_position" x1)))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P) ("_position" x2)))
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P)
###                         ("\<^const>Syntax.hp.Sequence" ("_position" x1)
###                           ("_position" x2)))))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>Pure.all_binder" ("_position" x)
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P) ("_position" x)))
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Syntax.hp.Loop"
###                         ("_applC" ("_position" P) ("_position" x))))))
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" P) ("_position" hp)))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>Pure.all_binder" ("_position" x)
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" P)
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" x)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>Pure.all_binder" ("_idts" ("_position" x1) ("_position" x2))
###       ("\<^const>HOL.Trueprop"
###         ("_Update" ("_position" P)
###           ("_updbind" ("_position" x1) ("_position" x2)))))
###     ("\<^const>Pure.imp"
###       ("\<^const>Pure.all_binder"
###         ("_idts" ("_position" x1) ("_position" x2))
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" P)
###             ("_applC" ("_position" DiffAssign)
###               ("_cargs" ("_position" x1) ("_position" x2))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>Pure.all_binder" ("_position" x)
###           ("\<^const>HOL.Trueprop"
###             ("_applC" ("_position" P)
###               ("_applC" ("\<^const>Syntax.hp.Test") ("_position" x)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>Pure.all_binder"
###             ("_idts" ("_position" x1) ("_position" x2))
###             ("\<^const>HOL.Trueprop"
###               ("_applC" ("_position" P)
###                 ("_applC" ("_position" EvolveODE)
###                   ("_cargs" ("_position" x1) ("_position" x2))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>Pure.all_binder"
###               ("_idts" ("_position" x1) ("_position" x2))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" P) ("_position" x1)))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P) ("_position" x2)))
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P)
###                       ("\<^const>Syntax.hp.Choice" ("_position" x1)
###                         ("_position" x2)))))))
###             ("\<^const>Pure.imp"
###               ("\<^const>Pure.all_binder"
###                 ("_idts" ("_position" x1) ("_position" x2))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P) ("_position" x1)))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P) ("_position" x2)))
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P)
###                         ("\<^const>Syntax.hp.Sequence" ("_position" x1)
###                           ("_position" x2)))))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>Pure.all_binder" ("_position" x)
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P) ("_position" x)))
###                     ("\<^const>HOL.Trueprop"
###                       ("\<^const>Syntax.hp.Loop"
###                         ("_applC" ("_position" P) ("_position" x))))))
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" P) ("_position" hp)))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>Pure.all_binder" ("_position" x)
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" P)
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" x)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>Pure.all_binder" ("_idts" ("_position" x1) ("_position" x2))
###       ("\<^const>HOL.Trueprop"
###         ("_applC" ("_position" P)
###           ("\<^const>Syntax.hp.Assign" ("_position" x1) ("_position" x2)))))
###     ("\<^const>Pure.imp"
###       ("\<^const>Pure.all_binder"
###         ("_idts" ("_position" x1) ("_position" x2))
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" P)
###             ("_applC" ("_position" DiffAssign)
###               ("_cargs" ("_position" x1) ("_position" x2))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>Pure.all_binder" ("_position" x)
###           ("\<^const>HOL.Trueprop"
###             ("_applC" ("_position" P)
###               ("_applC" ("\<^const>Syntax.hp.Test") ("_position" x)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>Pure.all_binder"
###             ("_idts" ("_position" x1) ("_position" x2))
###             ("\<^const>HOL.Trueprop"
###               ("_applC" ("_position" P)
###                 ("_applC" ("_position" EvolveODE)
###                   ("_cargs" ("_position" x1) ("_position" x2))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>Pure.all_binder"
###               ("_idts" ("_position" x1) ("_position" x2))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" P) ("_position" x1)))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P) ("_position" x2)))
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P)
###                       ("\<^const>Syntax.hp.Choice" ("_position" x1)
###                         ("_position" x2)))))))
###             ("\<^const>Pure.imp"
###               ("\<^const>Pure.all_binder"
###                 ("_idts" ("_position" x1) ("_position" x2))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P) ("_position" x1)))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P) ("_position" x2)))
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P)
###                         ("\<^const>Syntax.hp.Sequence" ("_position" x1)
###                           ("_position" x2)))))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>Pure.all_binder" ("_position" x)
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P) ("_position" x)))
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P)
###                         ("\<^const>Syntax.hp.Loop" ("_position" x))))))
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" P) ("_position" hp)))))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>Pure.all_binder" ("_position" x)
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" P)
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" x)))))
###   ("\<^const>Pure.imp"
###     ("\<^const>Pure.all_binder" ("_idts" ("_position" x1) ("_position" x2))
###       ("\<^const>HOL.Trueprop"
###         ("_Update" ("_position" P)
###           ("_updbind" ("_position" x1) ("_position" x2)))))
###     ("\<^const>Pure.imp"
###       ("\<^const>Pure.all_binder"
###         ("_idts" ("_position" x1) ("_position" x2))
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" P)
###             ("_applC" ("_position" DiffAssign)
###               ("_cargs" ("_position" x1) ("_position" x2))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>Pure.all_binder" ("_position" x)
###           ("\<^const>HOL.Trueprop"
###             ("_applC" ("_position" P)
###               ("_applC" ("\<^const>Syntax.hp.Test") ("_position" x)))))
###         ("\<^const>Pure.imp"
###           ("\<^const>Pure.all_binder"
###             ("_idts" ("_position" x1) ("_position" x2))
###             ("\<^const>HOL.Trueprop"
###               ("_applC" ("_position" P)
###                 ("_applC" ("_position" EvolveODE)
###                   ("_cargs" ("_position" x1) ("_position" x2))))))
###           ("\<^const>Pure.imp"
###             ("\<^const>Pure.all_binder"
###               ("_idts" ("_position" x1) ("_position" x2))
###               ("\<^const>Pure.imp"
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" P) ("_position" x1)))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P) ("_position" x2)))
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P)
###                       ("\<^const>Syntax.hp.Choice" ("_position" x1)
###                         ("_position" x2)))))))
###             ("\<^const>Pure.imp"
###               ("\<^const>Pure.all_binder"
###                 ("_idts" ("_position" x1) ("_position" x2))
###                 ("\<^const>Pure.imp"
###                   ("\<^const>HOL.Trueprop"
###                     ("_applC" ("_position" P) ("_position" x1)))
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P) ("_position" x2)))
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P)
###                         ("\<^const>Syntax.hp.Sequence" ("_position" x1)
###                           ("_position" x2)))))))
###               ("\<^const>Pure.imp"
###                 ("\<^const>Pure.all_binder" ("_position" x)
###                   ("\<^const>Pure.imp"
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P) ("_position" x)))
###                     ("\<^const>HOL.Trueprop"
###                       ("_applC" ("_position" P)
###                         ("\<^const>Syntax.hp.Loop" ("_position" x))))))
###                 ("\<^const>HOL.Trueprop"
###                   ("_applC" ("_position" P) ("_position" hp)))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
### theory "Draft.Syntax"
### 8.841s elapsed time, 34.578s cpu time, 5.351s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Differential_Dynamic_LogicMoreTemplates")
class euclidean_semiring_gcd = normalization_euclidean_semiring + Gcd +
  assumes "gcd_eucl": "normalization_euclidean_semiring_class.gcd = gcd"
    and "lcm_eucl": "normalization_euclidean_semiring_class.lcm = lcm"
  assumes "Gcd_eucl": "normalization_euclidean_semiring_class.Gcd = Gcd"
    and "Lcm_eucl": "normalization_euclidean_semiring_class.Lcm = Lcm"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.720s elapsed time, 2.822s cpu time, 0.379s GC time
Loading theory "HOL-Library.Complex_Order" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Infinite_Sum")
instantiation
  complex :: order
  less_eq_complex == less_eq :: complex => complex => bool
  less_complex == less :: complex => complex => bool
### theory "HOL-Library.Complex_Order"
### 0.058s elapsed time, 0.230s cpu time, 0.000s GC time
Loading theory "HOL-Library.Diagonal_Subsequence" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Flow")
locale subseqs
  fixes P :: "nat => (nat => nat) => bool"
  assumes "Diagonal_Subsequence.subseqs P"
consts
  seqseq :: "nat => nat => nat"
consts
  fold_reduce :: "nat => nat => nat => nat"
### theory "HOL-Library.Diagonal_Subsequence"
### 0.122s elapsed time, 0.478s cpu time, 0.070s GC time
Loading theory "HOL-Library.Discrete" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
### theory "HOL-Analysis.Convex"
### 0.997s elapsed time, 3.893s cpu time, 0.512s GC time
Loading theory "HOL-Library.Indicator_Function" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Connected" via "HOL-Analysis.Abstract_Topology_2")
locale linear_first_finite_dimensional_vector_space
  fixes scaleB :: "'a => 'b => 'b"  (infixr \<open>*b\<close> 75)
    and scaleC :: "'a => 'c => 'c"  (infixr \<open>*c\<close> 75)
    and BasisB :: "'b set"
    and f :: "'b => 'c"
  assumes "linear_first_finite_dimensional_vector_space (*b) (*c) BasisB f"
### Rewrite rule not in simpset:
### Wellfounded.accp log_rel ?n1 ==>
### log ?n1 == if ?n1 < 2 then 0 else Suc (log (?n1 div 2))
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Discrete"
### 0.184s elapsed time, 0.714s cpu time, 0.113s GC time
Loading theory "HOL-Library.Lattice_Algebras" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Interval")
### theory "HOL-Library.Indicator_Function"
### 0.426s elapsed time, 1.655s cpu time, 0.176s GC time
Loading theory "HOL-Analysis.Abstract_Topology_2" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Connected")
### theory "HOL-Analysis.Cartesian_Space"
### 1.726s elapsed time, 6.738s cpu time, 0.927s GC time
Loading theory "HOL-Analysis.Determinants" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Determinants"
### 1.071s elapsed time, 4.140s cpu time, 0.556s GC time
Loading theory "HOL-Library.Liminf_Limsup" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real")
### theory "HOL-Analysis.Abstract_Topology_2"
### 1.424s elapsed time, 5.499s cpu time, 0.713s GC time
Loading theory "HOL-Analysis.Connected" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Library.Liminf_Limsup"
### 0.560s elapsed time, 2.148s cpu time, 0.288s GC time
Loading theory "HOL-Analysis.Elementary_Metric_Spaces" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Elementary_Normed_Spaces")
### theory "HOL-Analysis.Connected"
### 0.373s elapsed time, 1.416s cpu time, 0.257s GC time
Loading theory "HOL-Analysis.Function_Topology" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function")
instantiation
  fun :: (type, topological_space) topological_space
  open_fun == open :: ('a => 'b) set => bool
### theory "HOL-Analysis.Function_Topology"
### 0.834s elapsed time, 3.072s cpu time, 0.662s GC time
Loading theory "HOL-Analysis.Product_Topology" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Weierstrass_Theorems" via "HOL-Analysis.Path_Connected" via "HOL-Analysis.T1_Spaces")
class lattice_ab_group_add_abs = abs + lattice_ab_group_add +
  assumes "abs_lattice": "!!a. \<bar>a\<bar> = sup a (- a)"
class heine_borel = metric_space +
  assumes
    "bounded_imp_convergent_subsequence":
      "!!f. bounded (range f) ==>
            EX l r. strict_mono r & (f o r) \<longlonglongrightarrow> l"
### theory "HOL-Analysis.Product_Topology"
### 1.468s elapsed time, 5.396s cpu time, 4.224s GC time
Loading theory "HOL-Analysis.T1_Spaces" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Weierstrass_Theorems" via "HOL-Analysis.Path_Connected")
### theory "HOL-Analysis.T1_Spaces"
### 0.277s elapsed time, 1.087s cpu time, 0.084s GC time
Loading theory "HOL-Analysis.Lindelof_Spaces" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Lindelof_Spaces"
### 0.115s elapsed time, 0.446s cpu time, 0.055s GC time
Loading theory "HOL-Library.Log_Nat" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float" via "HOL-Library.Float")
### theory "HOL-Library.Log_Nat"
### 0.152s elapsed time, 0.585s cpu time, 0.102s GC time
Loading theory "HOL-Library.Nonpos_Ints" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Harmonic_Numbers" via "HOL-Analysis.Complex_Transcendental" via "HOL-Analysis.Complex_Analysis_Basics")
### theory "HOL-Library.Nonpos_Ints"
### 0.167s elapsed time, 0.656s cpu time, 0.076s GC time
Loading theory "HOL-Library.Order_Continuity" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real" via "HOL-Library.Extended_Nat")
### theory "HOL-Analysis.Elementary_Metric_Spaces"
### 3.268s elapsed time, 12.219s cpu time, 5.414s GC time
Loading theory "HOL-Analysis.Elementary_Normed_Spaces" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Library.Lattice_Algebras"
### 5.767s elapsed time, 21.893s cpu time, 6.639s GC time
Loading theory "HOL-Analysis.Function_Metric" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Library.Order_Continuity"
### 0.593s elapsed time, 2.320s cpu time, 0.255s GC time
Loading theory "HOL-Library.Interval" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
instantiation
  fun :: (countable, metric_space) metric_space
  dist_fun == dist :: ('a => 'b) => ('a => 'b) => real
  uniformity_fun == uniformity :: (('a => 'b) * ('a => 'b)) filter
### theory "HOL-Analysis.Function_Metric"
### 0.343s elapsed time, 1.345s cpu time, 0.116s GC time
Loading theory "HOL-Library.Float" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds" via "HOL-Library.Interval_Float")
instantiation
  interval :: ({equal,preorder}) equal
  equal_interval == equal_class.equal :: 'a interval => 'a interval => bool
instantiation
  interval :: (preorder) ord
  less_eq_interval == less_eq :: 'a interval => 'a interval => bool
  less_interval == less :: 'a interval => 'a interval => bool
instantiation
  float :: {equal,linordered_idom}
  sgn_float == sgn :: float => float
  abs_float == abs :: float => float
  uminus_float == uminus :: float => float
  one_float == one_class.one :: float
  times_float == times :: float => float => float
  zero_float == zero_class.zero :: float
  minus_float == minus :: float => float => float
  less_eq_float == less_eq :: float => float => bool
  less_float == less :: float => float => bool
  plus_float == plus :: float => float => float
  equal_float == equal_class.equal :: float => float => bool
instantiation
  interval :: (lattice) semilattice_sup
  sup_interval == sup :: 'a interval => 'a interval => 'a interval
instantiation
  interval :: (ordered_ab_semigroup_add) ab_semigroup_add
  plus_interval == plus :: 'a interval => 'a interval => 'a interval
instantiation
  interval :: ({zero,preorder}) zero
  zero_interval == zero_class.zero :: 'a interval
### theory "HOL-Analysis.Elementary_Normed_Spaces"
### 1.347s elapsed time, 5.258s cpu time, 0.543s GC time
Loading theory "HOL-Library.Extended_Nat" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Library.Extended_Real")
instantiation
  interval :: (ordered_ab_group_add) uminus
  uminus_interval == uminus :: 'a interval => 'a interval
instantiation
  interval :: (ordered_ab_group_add) minus
  minus_interval == minus :: 'a interval => 'a interval => 'a interval
instantiation
  float :: lattice_ab_group_add
  inf_float == inf :: float => float => float
  sup_float == sup :: float => float => float
instantiation
  interval :: (linordered_semiring) times
  times_interval == times :: 'a interval => 'a interval => 'a interval
instantiation
  float :: exhaustive
  exhaustive_float == exhaustive_class.exhaustive ::
    (float => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  float :: full_exhaustive
  full_exhaustive_float == full_exhaustive_class.full_exhaustive ::
    (float * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
class infinity = type +
  fixes infinity :: "'a"
instantiation
  float :: random
  random_float == random_class.random ::
    natural
    => natural * natural => (float * (unit => term)) * natural * natural
instantiation
  enat :: infinity
  infinity_enat == infinity :: enat
Proofs for inductive predicate(s) "rec_set_enat"
instantiation
  interval :: ({one,preorder}) one
  one_interval == one_class.one :: 'a interval
### No equation for constructor "Extended_Nat.infinity_class.infinity"
### in definition of function "the_enat"
consts
  the_enat :: "enat => nat"
instantiation
  enat :: zero_neq_one
  one_enat == one_class.one :: enat
  zero_enat == zero_class.zero :: enat
instantiation
  enat :: comm_monoid_add
  plus_enat == plus :: enat => enat => enat
instantiation
  enat :: {comm_semiring_1,semiring_no_zero_divisors}
  times_enat == times :: enat => enat => enat
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
instantiation
  enat :: minus
  minus_enat == minus :: enat => enat => enat
instantiation
  enat :: linordered_ab_semigroup_add
  less_eq_enat == less_eq :: enat => enat => bool
  less_enat == less :: enat => enat => bool
instantiation
  enat :: {order_bot,order_top}
  top_enat == top :: enat
  bot_enat == bot :: enat
structure Cancel_Enat_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Enat_Cancel:
  sig val proc: Proof.context -> term -> thm option end
instantiation
  enat :: complete_lattice
  Inf_enat == Inf :: enat set => enat
  Sup_enat == Sup :: enat set => enat
  sup_enat == sup :: enat => enat => enat
  inf_enat == inf :: enat => enat => enat
### theory "HOL-Library.Extended_Nat"
### 0.828s elapsed time, 3.174s cpu time, 0.413s GC time
Loading theory "HOL-Library.Extended_Real" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
instantiation
  interval :: ({preorder,topological_space}) topological_space
  open_interval == open :: 'a interval set => bool
instantiation
  interval :: ({preorder,exhaustive}) exhaustive
  exhaustive_interval == exhaustive_class.exhaustive ::
    ('a interval => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  interval :: ({preorder,full_exhaustive}) full_exhaustive
  full_exhaustive_interval == full_exhaustive_class.full_exhaustive ::
    ('a interval * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
instantiation
  interval :: ({preorder,random}) random
  random_interval == random_class.random ::
    natural
    => natural * natural
       => ('a interval * (unit => term)) * natural * natural
### theory "HOL-Library.Interval"
### 2.093s elapsed time, 8.049s cpu time, 1.023s GC time
Loading theory "HOL-Library.Periodic_Fun" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Harmonic_Numbers" via "HOL-Analysis.Complex_Transcendental")
instantiation
  enat :: linorder_topology
  open_enat == open :: enat set => bool
locale periodic_fun
  fixes f :: "'a => 'b"
    and g :: "'a => 'a => 'a"
    and gm :: "'a => 'a => 'a"
    and g1 :: "'a => 'a"
    and gn1 :: "'a => 'a"
  assumes "periodic_fun f g gm g1 gn1"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
locale periodic_fun_simple
  fixes f :: "'a => 'b"
    and period :: "'a"
  assumes "periodic_fun_simple f period"
locale periodic_fun_simple'
  fixes f :: "'a => 'b"
  assumes "periodic_fun_simple' f"
### theory "HOL-Library.Periodic_Fun"
### 0.195s elapsed time, 0.734s cpu time, 0.093s GC time
Loading theory "HOL-Library.Sum_of_Squares" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Norm_Arith")
### theory "HOL-Library.Float"
### 2.075s elapsed time, 7.939s cpu time, 1.079s GC time
Loading theory "HOL-Library.Code_Target_Numeral_Float" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation")
instantiation
  ereal :: uminus
  uminus_ereal == uminus :: ereal => ereal
### theory "HOL-Computational_Algebra.Euclidean_Algorithm"
### 11.299s elapsed time, 43.301s cpu time, 9.548s GC time
Loading theory "HOL-Computational_Algebra.Primes" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Jordan_Curve" via "HOL-Analysis.Arcwise_Connected")
Found termination order: "{}"
instantiation
  ereal :: infinity
  infinity_ereal == infinity :: ereal
### theory "HOL-Library.Code_Target_Numeral_Float"
### 14.273s elapsed time, 47.645s cpu time, 46.684s GC time
Loading theory "HOL-Computational_Algebra.Formal_Power_Series" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.FPS_Convergence")
instantiation
  ereal :: abs
  abs_ereal == abs :: ereal => ereal
instantiation
  ereal :: {comm_monoid_add,zero_neq_one}
  one_ereal == one_class.one :: ereal
  zero_ereal == zero_class.zero :: ereal
  plus_ereal == plus :: ereal => ereal => ereal
### theory "HOL-Computational_Algebra.Primes"
### 14.331s elapsed time, 47.905s cpu time, 46.741s GC time
Loading theory "HOL-Library.Interval_Float" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation" via "HOL-Decision_Procs.Approximation_Bounds")
instantiation
  ereal :: linorder
  less_eq_ereal == less_eq :: ereal => ereal => bool
  less_ereal == less :: ereal => ereal => bool
instantiation
  ereal :: {comm_monoid_mult,sgn}
  sgn_ereal == sgn :: ereal => ereal
  times_ereal == times :: ereal => ereal => ereal
instantiation
  fps :: (zero) zero
  zero_fps == zero_class.zero :: 'a fps
### ML warning (line 261 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_abs) has not been referenced.
### ML warning (line 265 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_max) has not been referenced.
### ML warning (line 269 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Value identifier (pth_min) has not been referenced.
### ML warning (line 379 of "~~/src/HOL/Library/Sum_of_Squares/positivstellensatz.ML"):
### Pattern is not exhaustive.
signature FUNC =
  sig
    exception DUP of key
    exception SAME
    exception UNDEF of key
    val apply: 'a table -> key -> 'a
    val applyd: 'a table -> (key -> 'a) -> key -> 'a
    val build: ('a table -> 'a table) -> 'a table
    val choose: 'a table -> key * 'a
    val combine:
       ('a -> 'a -> 'a) -> ('a -> bool) -> 'a table -> 'a table -> 'a table
    val cons_list: key * 'a -> 'a list table -> 'a list table
    val default: key * 'a -> 'a table -> 'a table
    val defined: 'a table -> key -> bool
    val delete: key -> 'a table -> 'a table
    val delete_safe: key -> 'a table -> 'a table
    val dest: 'a table -> (key * 'a) list
    val dest_list: 'a list table -> (key * 'a) list
    val dom: 'a table -> key list
    val empty: 'a table
    val exists: (key * 'a -> bool) -> 'a table -> bool
    val fold: (key * 'a -> 'b -> 'b) -> 'a table -> 'b -> 'b
    val fold_rev: (key * 'a -> 'b -> 'b) -> 'a table -> 'b -> 'b
    val forall: (key * 'a -> bool) -> 'a table -> bool
    val get_first: (key * 'a -> 'b option) -> 'a table -> 'b option
    val insert: ('a * 'a -> bool) -> key * 'a -> 'a table -> 'a table
    val insert_list:
       ('a * 'a -> bool) -> key * 'a -> 'a list table -> 'a list table
    val insert_set: key -> set -> set
    val is_empty: 'a table -> bool
    val is_single: 'a table -> bool
    val join: (key -> 'a * 'a -> 'a) -> 'a table * 'a table -> 'a table
    type key
    val keys: 'a table -> key list
    val lookup: 'a table -> key -> 'a option
    val lookup_key: 'a table -> key -> (key * 'a) option
    val lookup_list: 'a list table -> key -> 'a list
    val make: (key * 'a) list -> 'a table
    val make_list: (key * 'a) list -> 'a list table
    val make_set: key list -> set
    val map: (key -> 'a -> 'b) -> 'a table -> 'b table
    val map_default: key * 'a -> ('a -> 'a) -> 'a table -> 'a table
    val map_entry: key -> ('a -> 'a) -> 'a table -> 'a table
    val max: 'a table -> (key * 'a) option
    val member: ('a * 'b -> bool) -> 'b table -> key * 'a -> bool
    val merge: ('a * 'a -> bool) -> 'a table * 'a table -> 'a table
    val merge_list:
       ('a * 'a -> bool) -> 'a list table * 'a list table -> 'a list table
    val min: 'a table -> (key * 'a) option
    val onefunc: key * 'a -> 'a table
    val remove: ('a * 'b -> bool) -> key * 'a -> 'b table -> 'b table
    val remove_list:
       ('a * 'b -> bool) -> key * 'a -> 'b list table -> 'b list table
    val remove_set: key -> set -> set
    type set = unit table
    type 'a table
    val tryapplyd: 'a table -> key -> 'a -> 'a
    val update: key * 'a -> 'a table -> 'a table
    val update_list:
       ('a * 'a -> bool) -> key * 'a -> 'a list table -> 'a list table
    val update_new: key * 'a -> 'a table -> 'a table
    val updatep: (key * 'a -> bool) -> key * 'a -> 'a table -> 'a table
  end
functor FuncFun (Key: KEY): FUNC
signature REAL_ARITH =
  sig
    type cert_conv = cterm -> thm * pss_tree
    val cterm_of_rat: Rat.rat -> cterm
    val dest_ratconst: cterm -> Rat.rat
    val gen_gen_real_arith:
       Proof.context ->
         (Rat.rat -> cterm) * conv * conv * conv * conv * conv * conv *
         conv * conv * conv * prover
           -> cert_conv
    val gen_prover_real_arith: Proof.context -> prover -> cert_conv
    val gen_real_arith:
       Proof.context ->
         (Rat.rat -> cterm) * conv * conv * conv * conv * conv * conv *
         conv * prover
           -> cert_conv
    val is_ratconst: cterm -> bool
    datatype positivstellensatz
    =
         Axiom_eq of int
       | Axiom_le of int
       | Axiom_lt of int
       | Eqmul of FuncUtil.poly * positivstellensatz
       | Product of positivstellensatz * positivstellensatz
       | Rational_eq of Rat.rat
       | Rational_le of Rat.rat
       | Rational_lt of Rat.rat
       | Square of FuncUtil.poly
       | Sum of positivstellensatz * positivstellensatz
    type prover =
       tree_choice list ->
         (thm list * thm list * thm list -> positivstellensatz -> thm) ->
           thm list * thm list * thm list -> thm * pss_tree
    datatype pss_tree
    = Branch of pss_tree * pss_tree | Cert of positivstellensatz | Trivial
    val real_linear_prover:
       (thm list * thm list * thm list -> positivstellensatz -> thm) ->
         thm list * thm list * thm list -> thm * pss_tree
    datatype tree_choice = Left | Right
  end
structure FuncUtil:
  sig
    structure Ctermfunc: FUNC
    structure Intfunc: FUNC
    structure Intpairfunc: FUNC
    structure Monomialfunc: FUNC
    structure Ratfunc: FUNC
    structure Symfunc: FUNC
    structure Termfunc: FUNC
    val dest_monomial: 'a Ctermfunc.table -> (cterm * 'a) list
    type monomial = int Ctermfunc.table
    val monomial_ord: int Ctermfunc.table * int Ctermfunc.table -> order
    val monomial_order: int Ctermfunc.table * int Ctermfunc.table -> order
    type poly = Rat.rat Monomialfunc.table
  end
structure RealArith: REAL_ARITH
instantiation
  fps :: ({one,zero}) one
  one_fps == one_class.one :: 'a fps
instantiation
  fps :: (plus) plus
  plus_fps == plus :: 'a fps => 'a fps => 'a fps
instantiation
  fps :: (minus) minus
  minus_fps == minus :: 'a fps => 'a fps => 'a fps
instantiation
  fps :: (uminus) uminus
  uminus_fps == uminus :: 'a fps => 'a fps
instantiation
  fps :: ({comm_monoid_add,times}) times
  times_fps == times :: 'a fps => 'a fps => 'a fps
signature POSITIVSTELLENSATZ_TOOLS =
  sig
    val print_cert: RealArith.pss_tree -> string
    val read_cert: Proof.context -> string -> RealArith.pss_tree
  end
structure Positivstellensatz_Tools: POSITIVSTELLENSATZ_TOOLS
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
instantiation
  ereal :: minus
  minus_ereal == minus :: ereal => ereal => ereal
Found termination order: "length <*mlex*> {}"
instantiation
  ereal :: inverse
  inverse_ereal == inverse :: ereal => ereal
  divide_ereal == divide :: ereal => ereal => ereal
signature SUM_OF_SQUARES =
  sig
    exception Failure of string
    val debug: bool Config.T
    val debug_message: Proof.context -> (unit -> string) -> unit
    datatype proof_method
    = Certificate of RealArith.pss_tree | Prover of string -> string
    val sos_tac:
       (RealArith.pss_tree -> unit) ->
         proof_method -> Proof.context -> int -> tactic
    val trace: bool Config.T
    val trace_message: Proof.context -> (unit -> string) -> unit
  end
structure Sum_of_Squares: SUM_OF_SQUARES
signature SOS_WRAPPER =
  sig val sos_tac: Proof.context -> string option -> int -> tactic end
structure SOS_Wrapper: SOS_WRAPPER
### theory "HOL-Library.Sum_of_Squares"
### 15.455s elapsed time, 52.252s cpu time, 47.317s GC time
Loading theory "HOL-Analysis.Norm_Arith" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
instantiation
  fps :: (zero) unit_factor
  unit_factor_fps == unit_factor :: 'a fps => 'a fps
instantiation
  ereal :: lattice
  inf_ereal == inf :: ereal => ereal => ereal
  sup_ereal == sup :: ereal => ereal => ereal
instantiation
  fps :: ({minus,zero}) dist
  dist_fps == dist :: 'a fps => 'a fps => real
instantiation
  ereal :: complete_lattice
  Inf_ereal == Inf :: ereal set => ereal
  Sup_ereal == Sup :: ereal set => ereal
  bot_ereal == bot :: ereal
  top_ereal == top :: ereal
instantiation
  fps :: (group_add) metric_space
  uniformity_fps == uniformity :: ('a fps * 'a fps) filter
  open_fps == open :: 'a fps set => bool
instantiation
  ereal :: linear_continuum_topology
  open_ereal == open :: ereal set => bool
### theory "HOL-Library.Interval_Float"
### 1.052s elapsed time, 4.146s cpu time, 0.439s GC time
Loading theory "HOL-Decision_Procs.Approximation_Bounds" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Decision_Procs.Approximation")
### ML warning (line 103 of "~~/src/HOL/Analysis/normarith.ML"):
### Matches are not exhaustive.
signature NORM_ARITH =
  sig
    val norm_arith: Proof.context -> conv
    val norm_arith_tac: Proof.context -> int -> tactic
  end
structure NormArith: NORM_ARITH
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
### theory "HOL-Analysis.Norm_Arith"
### 0.333s elapsed time, 1.298s cpu time, 0.194s GC time
Loading theory "HOL-Analysis.Topology_Euclidean_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Convex_Euclidean_Space")
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
instantiation
  fps :: ({inverse,comm_monoid_add,times,uminus}) inverse
  inverse_fps == inverse :: 'a fps => 'a fps
  divide_fps == divide :: 'a fps => 'a fps => 'a fps
consts
  horner ::
    "(nat => nat)
     => (nat => nat => nat) => nat => nat => nat => real => real"
instantiation
  fps :: ({inverse,uminus,comm_semiring_1}) modulo
  modulo_fps == modulo :: 'a fps => 'a fps => 'a fps
instantiation
  fps :: (field) normalization_semidom_multiplicative
  normalize_fps == normalize :: 'a fps => 'a fps
instantiation
  fps :: (field) euclidean_ring_cancel
  euclidean_size_fps == euclidean_size :: 'a fps => nat
instantiation
  fps :: (field) euclidean_ring_gcd
  Gcd_fps == Gcd :: 'a fps set => 'a fps
  Lcm_fps == Lcm :: 'a fps set => 'a fps
  gcd_fps == gcd :: 'a fps => 'a fps => 'a fps
  lcm_fps == lcm :: 'a fps => 'a fps => 'a fps
### theory "HOL-Library.Extended_Real"
### 17.051s elapsed time, 58.436s cpu time, 48.190s GC time
Loading theory "HOL-Library.Extended_Nonnegative_Real" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests" via "HOL-Analysis.Extended_Real_Limits")
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*> {}"
instantiation
  ennreal :: complete_linorder
  Inf_ennreal == Inf :: ennreal set => ennreal
  Sup_ennreal == Sup :: ennreal set => ennreal
  bot_ennreal == bot :: ennreal
  sup_ennreal == sup :: ennreal => ennreal => ennreal
  top_ennreal == top :: ennreal
  inf_ennreal == inf :: ennreal => ennreal => ennreal
  less_eq_ennreal == less_eq :: ennreal => ennreal => bool
  less_ennreal == less :: ennreal => ennreal => bool
instantiation
  ennreal :: infinity
  infinity_ennreal == infinity :: ennreal
instantiation
  ennreal :: {comm_semiring_1,semiring_1_no_zero_divisors}
  zero_ennreal == zero_class.zero :: ennreal
  plus_ennreal == plus :: ennreal => ennreal => ennreal
  one_ennreal == one_class.one :: ennreal
  times_ennreal == times :: ennreal => ennreal => ennreal
instantiation
  ennreal :: minus
  minus_ennreal == minus :: ennreal => ennreal => ennreal
instantiation
  ennreal :: inverse
  inverse_ennreal == inverse :: ennreal => ennreal
  divide_ennreal == divide :: ennreal => ennreal => ennreal
structure Cancel_Ennreal_Common:
  sig
    val dest_sum: term -> term list
    val dest_summing: term * term list -> term list
    val find_first: term -> term list -> term list
    val find_first_t: term list -> term -> term list -> term list
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_ss: simpset
    val norm_tac: Proof.context -> tactic
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Eq_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Le_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
structure Less_Ennreal_Cancel:
  sig val proc: Proof.context -> term -> thm option end
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd (snd p))) <*mlex*> {}"
instantiation
  ennreal :: linear_continuum_topology
  open_ennreal == open :: ennreal set => bool
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*> {}"
### theory "HOL-Analysis.Topology_Euclidean_Space"
### 2.301s elapsed time, 8.984s cpu time, 1.292s GC time
Loading theory "HOL-Analysis.Convex_Euclidean_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Library.Extended_Nonnegative_Real"
### 1.687s elapsed time, 6.569s cpu time, 0.946s GC time
Loading theory "HOL-Analysis.Infinite_Sum" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
bundle fps_notation
### theory "HOL-Computational_Algebra.Formal_Power_Series"
### 3.845s elapsed time, 15.022s cpu time, 2.093s GC time
Loading theory "HOL-Analysis.Sigma_Algebra" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Finite_Product_Measure" via "HOL-Analysis.Binary_Product_Measure" via "HOL-Analysis.Nonnegative_Lebesgue_Integration" via "HOL-Analysis.Measure_Space" via "HOL-Analysis.Measurable")
locale subset_class
  fixes \<Omega> :: "'a set"
    and M :: "'a set set"
  assumes "subset_class \<Omega> M"
locale semiring_of_sets
  fixes \<Omega> :: "'a set"
    and M :: "'a set set"
  assumes "semiring_of_sets \<Omega> M"
locale ring_of_sets
  fixes \<Omega> :: "'a set"
    and M :: "'a set set"
  assumes "ring_of_sets \<Omega> M"
locale algebra
  fixes \<Omega> :: "'a set"
    and M :: "'a set set"
  assumes "algebra \<Omega> M"
locale sigma_algebra
  fixes \<Omega> :: "'a set"
    and M :: "'a set set"
  assumes "sigma_algebra \<Omega> M"
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*> {}"
Proofs for inductive predicate(s) "sigma_setsp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "smallest_ccdi_setsp"
  Proving monotonicity ...
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*> {}"
### theory "HOL-Analysis.Convex_Euclidean_Space"
### 1.155s elapsed time, 4.459s cpu time, 0.608s GC time
Loading theory "HOL-Analysis.Ordered_Euclidean_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Finite_Product_Measure" via "HOL-Analysis.Binary_Product_Measure" via "HOL-Analysis.Nonnegative_Lebesgue_Integration" via "HOL-Analysis.Borel_Space")
locale Dynkin_system
  fixes \<Omega> :: "'a set"
    and M :: "'a set set"
  assumes "Dynkin_system \<Omega> M"
### theory "HOL-Decision_Procs.Approximation_Bounds"
### 4.038s elapsed time, 15.678s cpu time, 2.255s GC time
Loading theory "HOL-Decision_Procs.Approximation" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex")
### theory "HOL-Analysis.Infinite_Sum"
### 1.612s elapsed time, 6.206s cpu time, 0.856s GC time
Loading theory "HOL-Analysis.Extended_Real_Limits" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit" via "HOL-Analysis.Summation_Tests")
### theory "HOL-Analysis.Sigma_Algebra"
### 1.848s elapsed time, 7.103s cpu time, 0.981s GC time
Loading theory "HOL-Analysis.Measurable" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Finite_Product_Measure" via "HOL-Analysis.Binary_Product_Measure" via "HOL-Analysis.Nonnegative_Lebesgue_Integration" via "HOL-Analysis.Measure_Space")
signature MEASURABLE =
  sig
    val add_del_cong_thm: bool -> thm -> Context.generic -> Context.generic
    val add_local_cong: thm -> Proof.context -> Proof.context
    val add_preprocessor:
       string -> preprocessor -> Context.generic -> Context.generic
    val cong_thm_attr: attribute context_parser
    val del_preprocessor: string -> Context.generic -> Context.generic
    val dest_thm_attr: attribute context_parser
    val get_all: Context.generic -> thm list
    val get_cong: Context.generic -> thm list
    val get_dest: Context.generic -> thm list
    datatype level = Concrete | Generic
    val measurable_tac: Proof.context -> thm list -> tactic
    val measurable_thm_attr: bool * (bool * level) -> attribute
    val prepare_facts: Proof.context -> thm list -> thm list * Proof.context
    type preprocessor = thm -> Proof.context -> thm list * Proof.context
    val simproc: Proof.context -> cterm -> thm option
  end
structure Measurable: MEASURABLE
class ordered_euclidean_space = Inf + Sup + euclidean_space + abs + inf +
  sup + ord +
  assumes
    "eucl_le":
      "!!x y. (x <= y) = (ALL i:Basis. x \<bullet> i <= y \<bullet> i)"
  assumes "eucl_less_le_not_le": "!!x y. (x < y) = (x <= y & ~ y <= x)"
  assumes
    "eucl_inf":
      "!!x y.
          inf x y =
          (SUM i:Basis. inf (x \<bullet> i) (y \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_sup":
      "!!x y.
          sup x y =
          (SUM i:Basis. sup (x \<bullet> i) (y \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_Inf":
      "!!X. Inf X = (SUM i:Basis. (INF x\<in>X. x \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_Sup":
      "!!X. Sup X = (SUM i:Basis. (SUP x\<in>X. x \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_abs":
      "!!x. \<bar>x\<bar> =
            (SUM i:Basis. \<bar>x \<bullet> i\<bar> *\<^sub>R i)"
### theory "HOL-Analysis.Measurable"
### 1.896s elapsed time, 7.131s cpu time, 5.108s GC time
Loading theory "HOL-Analysis.Measure_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Finite_Product_Measure" via "HOL-Analysis.Binary_Product_Measure" via "HOL-Analysis.Nonnegative_Lebesgue_Integration")
### theory "HOL-Analysis.Extended_Real_Limits"
### 2.469s elapsed time, 9.348s cpu time, 5.472s GC time
Loading theory "HOL-Analysis.Summation_Tests" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function" via "HOL-Analysis.Uniform_Limit")
locale sigma_finite_measure
  fixes M :: "'a measure"
  assumes "sigma_finite_measure M"
locale finite_measure
  fixes M :: "'a measure"
  assumes "finite_measure M"
### theory "HOL-Analysis.Summation_Tests"
### 0.954s elapsed time, 3.738s cpu time, 0.611s GC time
Loading theory "HOL-Analysis.Uniform_Limit" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative" via "HOL-Analysis.Bounded_Linear_Function")
instantiation
  measure :: (type) order_bot
  bot_measure == bot :: 'a measure
  less_eq_measure == less_eq :: 'a measure => 'a measure => bool
  less_measure == less :: 'a measure => 'a measure => bool
Proofs for inductive predicate(s) "less_eq_measure"
  Proving monotonicity ...
instantiation
  measure :: (type) semilattice_sup
  sup_measure == sup :: 'a measure => 'a measure => 'a measure
instantiation
  measure :: (type) complete_lattice
  Inf_measure == Inf :: 'a measure set => 'a measure
  Sup_measure == Sup :: 'a measure set => 'a measure
  top_measure == top :: 'a measure
  inf_measure == inf :: 'a measure => 'a measure => 'a measure
### theory "HOL-Analysis.Uniform_Limit"
### 0.660s elapsed time, 2.553s cpu time, 0.354s GC time
Loading theory "HOL-Analysis.Bounded_Continuous_Function" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Measure_Space"
### 2.060s elapsed time, 8.020s cpu time, 1.279s GC time
Loading theory "HOL-Analysis.Caratheodory" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure")
instantiation
  bcontfun :: (topological_space, metric_space) metric_space
  dist_bcontfun == dist ::
    'a \<Rightarrow>\<^sub>C 'b => 'a \<Rightarrow>\<^sub>C 'b => real
  uniformity_bcontfun == uniformity ::
    ('a \<Rightarrow>\<^sub>C 'b * 'a \<Rightarrow>\<^sub>C 'b) filter
  open_bcontfun == open :: ('a \<Rightarrow>\<^sub>C 'b) set => bool
instantiation
  bcontfun :: (topological_space, real_normed_vector) real_vector
  uminus_bcontfun == uminus ::
    'a \<Rightarrow>\<^sub>C 'b => 'a \<Rightarrow>\<^sub>C 'b
  zero_bcontfun == zero_class.zero :: 'a \<Rightarrow>\<^sub>C 'b
  minus_bcontfun == minus ::
    'a \<Rightarrow>\<^sub>C 'b
    => 'a \<Rightarrow>\<^sub>C 'b => 'a \<Rightarrow>\<^sub>C 'b
  plus_bcontfun == plus ::
    'a \<Rightarrow>\<^sub>C 'b
    => 'a \<Rightarrow>\<^sub>C 'b => 'a \<Rightarrow>\<^sub>C 'b
  scaleR_bcontfun == scaleR ::
    real => 'a \<Rightarrow>\<^sub>C 'b => 'a \<Rightarrow>\<^sub>C 'b
instantiation
  prod :: (abs, abs) abs
  abs_prod == abs :: 'a * 'b => 'a * 'b
instantiation
  vec :: (ordered_euclidean_space, finite) ordered_euclidean_space
  abs_vec == abs :: ('a, 'b) vec => ('a, 'b) vec
  inf_vec == inf :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
  sup_vec == sup :: ('a, 'b) vec => ('a, 'b) vec => ('a, 'b) vec
  Inf_vec == Inf :: ('a, 'b) vec set => ('a, 'b) vec
  Sup_vec == Sup :: ('a, 'b) vec set => ('a, 'b) vec
instantiation
  bcontfun :: (topological_space, real_normed_vector) real_normed_vector
  sgn_bcontfun == sgn ::
    'a \<Rightarrow>\<^sub>C 'b => 'a \<Rightarrow>\<^sub>C 'b
  norm_bcontfun == norm :: 'a \<Rightarrow>\<^sub>C 'b => real
### theory "HOL-Analysis.Ordered_Euclidean_Space"
### 5.232s elapsed time, 20.048s cpu time, 7.027s GC time
Loading theory "HOL-Analysis.Bounded_Linear_Function" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Derivative")
### theory "HOL-Analysis.Bounded_Continuous_Function"
### 0.529s elapsed time, 2.048s cpu time, 0.244s GC time
Loading theory "HOL-Analysis.Line_Segment" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Caratheodory"
### 0.448s elapsed time, 1.726s cpu time, 0.314s GC time
Loading theory "HOL-Analysis.Tagged_Division" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Henstock_Kurzweil_Integration")
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
locale operative
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
    and g :: "'b set => 'a"
  assumes "operative (\<^bold>*) \<^bold>1 g"
Found termination order: "{}"
locale operative_real
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
    and g :: "real set => 'a"
  assumes "operative_real (\<^bold>*) \<^bold>1 g"
Found termination order: "{}"
Found termination order: "{}"
### theory "HOL-Analysis.Line_Segment"
### 2.511s elapsed time, 9.567s cpu time, 5.915s GC time
Loading theory "HOL-Analysis.Starlike" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Weierstrass_Theorems" via "HOL-Analysis.Path_Connected")
### theory "HOL-Analysis.Tagged_Division"
### 0.989s elapsed time, 3.880s cpu time, 0.491s GC time
Loading theory "List-Index.List_Index" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "Ordinary_Differential_Equations.ODE_Auxiliarities")
consts
  find_index :: "('a => bool) => 'a list => nat"
instantiation
  blinfun :: (real_normed_vector, real_normed_vector) real_normed_vector
  uminus_blinfun == uminus ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  zero_blinfun == zero_class.zero :: 'a \<Rightarrow>\<^sub>L 'b
  minus_blinfun == minus ::
    'a \<Rightarrow>\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  plus_blinfun == plus ::
    'a \<Rightarrow>\<^sub>L 'b
    => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  sgn_blinfun == sgn ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  norm_blinfun == norm :: 'a \<Rightarrow>\<^sub>L 'b => real
  scaleR_blinfun == scaleR ::
    real => 'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b
  dist_blinfun == dist ::
    'a \<Rightarrow>\<^sub>L 'b => 'a \<Rightarrow>\<^sub>L 'b => real
  uniformity_blinfun == uniformity ::
    ('a \<Rightarrow>\<^sub>L 'b * 'a \<Rightarrow>\<^sub>L 'b) filter
  open_blinfun == open :: ('a \<Rightarrow>\<^sub>L 'b) set => bool
consts
  map_index' :: "nat => (nat => 'a => 'b) => 'a list => 'b list"
consts
  insert_nth :: "nat => 'a => 'a list => 'a list"
locale bounded_bilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_bilinear (**)"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### theory "List-Index.List_Index"
### 0.427s elapsed time, 1.676s cpu time, 0.250s GC time
"(bij, bij_betw, permutation)"
  :: "(('a => 'b) => bool) *
      (('c => 'd) => 'c set => 'd set => bool) * (('e => 'e) => bool)"
"- \<infinity>"
  :: "ereal"
locale bounded_bilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_bilinear (**)"
"\<infinity>"
  :: "ereal"
### theory "HOL-Analysis.Bounded_Linear_Function"
### 3.636s elapsed time, 14.089s cpu time, 6.689s GC time
Loading theory "HOL-Analysis.Derivative" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
"ereal (13 / 4)"
  :: "ereal"
"True"
  :: "bool"
"True"
  :: "bool"
inj_on ?h ?A ==> (?g summable_on ?h ` ?A) = (?g o ?h summable_on ?A)
uniformity =
filtermap (%((x1, x2), y1, y2). ((x1, y1), x2, y2))
 (uniformity \<times>\<^sub>F uniformity)
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*>
   case_sum (%x. 0) (%x. Suc 0) <*mlex*> {}"
?a : affine hull ?S ==> aff_dim ?S = int (dim ((+) (- ?a) ` ?S))
### theory "HOL-Analysis.Starlike"
### 2.018s elapsed time, 7.719s cpu time, 1.260s GC time
Loading theory "HOL-Analysis.Continuous_Extension" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Equivalence_Measurable_On_Borel")
Loading theory "HOL-Analysis.Path_Connected" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Weierstrass_Theorems")
### theory "HOL-Analysis.Continuous_Extension"
### 0.266s elapsed time, 0.996s cpu time, 0.308s GC time
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
### theory "HOL-Analysis.Derivative"
### 3.806s elapsed time, 13.508s cpu time, 7.753s GC time
Loading theory "HOL-Analysis.Borel_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Finite_Product_Measure" via "HOL-Analysis.Binary_Product_Measure" via "HOL-Analysis.Nonnegative_Lebesgue_Integration")
Loading theory "HOL-Analysis.Cartesian_Euclidean_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Cartesian_Euclidean_Space"
### 0.367s elapsed time, 1.438s cpu time, 0.222s GC time
Loading theory "HOL-Analysis.Cross3" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Path_Connected"
### 3.623s elapsed time, 13.120s cpu time, 7.501s GC time
Loading theory "HOL-Analysis.Complex_Analysis_Basics" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Harmonic_Numbers" via "HOL-Analysis.Complex_Transcendental")
bundle cross3_syntax
bundle no_cross3_syntax
### theory "HOL-Analysis.Complex_Analysis_Basics"
### 1.170s elapsed time, 4.554s cpu time, 0.524s GC time
Loading theory "HOL-Analysis.Complex_Transcendental" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Harmonic_Numbers")
### theory "HOL-Analysis.Borel_Space"
### 2.195s elapsed time, 8.565s cpu time, 1.137s GC time
Loading theory "HOL-Analysis.Nonnegative_Lebesgue_Integration" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Finite_Product_Measure" via "HOL-Analysis.Binary_Product_Measure")
instantiation
  complex :: ln
  ln_complex == ln :: complex => complex
### theory "HOL-Analysis.Cross3"
### 2.566s elapsed time, 9.987s cpu time, 1.312s GC time
Loading theory "HOL-Analysis.Regularity" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure")
### theory "HOL-Analysis.Regularity"
### 0.737s elapsed time, 2.821s cpu time, 0.425s GC time
Loading theory "HOL-Analysis.Lipschitz" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Multivariate_Analysis")
bundle lipschitz_syntax
bundle no_lipschitz_syntax
### theory "HOL-Analysis.Complex_Transcendental"
### 1.926s elapsed time, 7.382s cpu time, 1.223s GC time
Loading theory "HOL-Analysis.Generalised_Binomial_Theorem" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Nonnegative_Lebesgue_Integration"
### 1.896s elapsed time, 7.250s cpu time, 1.173s GC time
Loading theory "HOL-Analysis.Binary_Product_Measure" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Finite_Product_Measure")
### theory "HOL-Analysis.Generalised_Binomial_Theorem"
### 0.139s elapsed time, 0.514s cpu time, 0.138s GC time
Loading theory "HOL-Analysis.FPS_Convergence" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Lipschitz"
### 0.665s elapsed time, 2.472s cpu time, 0.506s GC time
Loading theory "HOL-Analysis.Harmonic_Numbers" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function")
locale pair_sigma_finite
  fixes M1 :: "'a measure"
    and M2 :: "'b measure"
  assumes "pair_sigma_finite M1 M2"
### theory "HOL-Analysis.Harmonic_Numbers"
### 0.285s elapsed time, 1.030s cpu time, 0.240s GC time
Loading theory "HOL-Analysis.Infinite_Products" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Binary_Product_Measure"
### 2.753s elapsed time, 10.264s cpu time, 8.230s GC time
Loading theory "HOL-Analysis.Embed_Measure" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Embed_Measure"
### 0.225s elapsed time, 0.886s cpu time, 0.100s GC time
Loading theory "HOL-Analysis.Finite_Product_Measure" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure")
### theory "HOL-Analysis.Infinite_Products"
### 2.692s elapsed time, 10.168s cpu time, 7.963s GC time
Loading theory "HOL-Analysis.Multivariate_Analysis" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.FPS_Convergence"
### 3.305s elapsed time, 12.425s cpu time, 8.414s GC time
Loading theory "HOL-Analysis.Arcwise_Connected" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Jordan_Curve")
locale product_sigma_finite
  fixes M :: "'i => 'a measure"
  assumes "product_sigma_finite M"
locale finite_product_sigma_finite
  fixes M :: "'i => 'a measure"
    and I :: "'i set"
  assumes "finite_product_sigma_finite M I"
### theory "HOL-Analysis.Finite_Product_Measure"
### 0.941s elapsed time, 3.703s cpu time, 0.384s GC time
Loading theory "HOL-Analysis.Bochner_Integration" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure" via "HOL-Analysis.Complete_Measure")
Proofs for inductive predicate(s) "simple_bochner_integrable"
  Proving monotonicity ...
Proofs for inductive predicate(s) "has_bochner_integral"
  Proving monotonicity ...
Proofs for inductive predicate(s) "integrable"
  Proving monotonicity ...
### theory "HOL-Analysis.Multivariate_Analysis"
### 1.281s elapsed time, 5.054s cpu time, 0.568s GC time
Loading theory "Affine_Arithmetic.Affine_Arithmetic_Auxiliarities" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "Ordinary_Differential_Equations.ODE_Auxiliarities")
### theory "Affine_Arithmetic.Affine_Arithmetic_Auxiliarities"
### 0.114s elapsed time, 0.442s cpu time, 0.050s GC time
Loading theory "Triangle.Angles" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Cones" via "Triangle.Triangle")
### theory "Triangle.Angles"
### 0.188s elapsed time, 0.739s cpu time, 0.077s GC time
Loading theory "Triangle.Triangle" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Cones")
locale congruent_triangle
  fixes a1 :: "'a"
    and b1 :: "'a"
    and c1 :: "'a"
    and a2 :: "'b"
    and b2 :: "'b"
    and c2 :: "'b"
  assumes "congruent_triangle a1 b1 c1 a2 b2 c2"
### theory "HOL-Analysis.Arcwise_Connected"
### 1.674s elapsed time, 6.572s cpu time, 0.857s GC time
Loading theory "HOL-Analysis.Homotopy" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Homeomorphism")
### theory "Triangle.Triangle"
### 0.280s elapsed time, 1.085s cpu time, 0.268s GC time
Loading theory "HOL-Analysis.Locally" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Abstract_Euclidean_Space")
### theory "HOL-Analysis.Locally"
### 0.263s elapsed time, 1.021s cpu time, 0.207s GC time
Loading theory "HOL-Analysis.Polytope" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Bochner_Integration"
### 1.608s elapsed time, 6.285s cpu time, 1.065s GC time
Loading theory "HOL-Analysis.Complete_Measure" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Lebesgue_Measure")
locale complete_measure
  fixes M :: "'a measure"
  assumes "complete_measure M"
locale semifinite_measure
  fixes M :: "'a measure"
  assumes "semifinite_measure M"
locale locally_determined_measure
  fixes M :: "'a measure"
  assumes "locally_determined_measure M"
locale cld_measure
  fixes M :: "'a measure"
  assumes "cld_measure M"
### theory "HOL-Analysis.Complete_Measure"
### 0.578s elapsed time, 2.240s cpu time, 0.372s GC time
Loading theory "HOL-Analysis.Radon_Nikodym" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" via "HOL-Analysis.Set_Integral")
### theory "HOL-Analysis.Radon_Nikodym"
### 0.392s elapsed time, 1.507s cpu time, 0.333s GC time
Loading theory "HOL-Analysis.Set_Integral" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration")
locale Retracts
  fixes s :: "'a set"
    and h :: "'a => 'b"
    and t :: "'b set"
    and k :: "'b => 'a"
  assumes "Retracts s h t k"
### theory "HOL-Analysis.Polytope"
### 1.616s elapsed time, 6.217s cpu time, 1.160s GC time
Loading theory "HOL-Analysis.Lebesgue_Measure" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration")
### theory "HOL-Analysis.Set_Integral"
### 0.658s elapsed time, 2.487s cpu time, 0.476s GC time
Loading theory "HOL-Analysis.Infinite_Set_Sum" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Homotopy"
### 2.479s elapsed time, 9.512s cpu time, 1.825s GC time
Loading theory "HOL-Analysis.Homeomorphism" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration")
### theory "HOL-Analysis.Homeomorphism"
### 36.496s elapsed time, 126.300s cpu time, 123.972s GC time
Loading theory "HOL-Analysis.Brouwer_Fixpoint" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Fashoda_Theorem")
### theory "HOL-Analysis.Infinite_Set_Sum"
### 36.951s elapsed time, 128.038s cpu time, 124.197s GC time
Loading theory "HOL-Analysis.Abstract_Euclidean_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
Proofs for inductive predicate(s) "fsigma"
Found termination order:
  "case_sum (%p. size (fst (snd p))) (%p. size (fst (snd p))) <*mlex*>
   case_sum (%x. Suc 0) (%x. 0) <*mlex*>
   case_sum (%p. size (fst (snd (snd p))))
    (%p. size_list size (snd (snd (snd p)))) <*mlex*>
   {}"
  Proving monotonicity ...
### theory "HOL-Analysis.Abstract_Euclidean_Space"
### 0.352s elapsed time, 1.389s cpu time, 0.178s GC time
Loading theory "HOL-Analysis.Weierstrass_Theorems" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
Proofs for inductive predicate(s) "gdelta"
  Proving monotonicity ...
### theory "HOL-Analysis.Lebesgue_Measure"
### 37.540s elapsed time, 130.322s cpu time, 124.493s GC time
Loading theory "HOL-Analysis.Henstock_Kurzweil_Integration" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function" via "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration")
locale kuhn_simplex
  fixes p :: "nat"
    and n :: "nat"
    and base :: "nat => nat"
    and upd :: "nat => nat"
    and s :: "(nat => nat) set"
  assumes "kuhn_simplex p n base upd s"
locale kuhn_simplex_pair
  fixes p :: "nat"
    and n :: "nat"
    and b_s :: "nat => nat"
    and u_s :: "nat => nat"
    and s :: "(nat => nat) set"
    and b_t :: "nat => nat"
    and u_t :: "nat => nat"
    and t :: "(nat => nat) set"
  assumes "kuhn_simplex_pair p n b_s u_s s b_t u_t t"
Proofs for inductive predicate(s) "ksimplex"
  Proving monotonicity ...
locale function_ring_on
  fixes R :: "('a => real) set"
    and S :: "'a set"
  assumes "function_ring_on R S"
### Cannot skip proof of schematic goal statement
Proofs for inductive predicate(s) "real_polynomial_function"
  Proving monotonicity ...
### theory "HOL-Analysis.Brouwer_Fixpoint"
### 1.178s elapsed time, 4.671s cpu time, 0.538s GC time
Loading theory "HOL-Analysis.Fashoda_Theorem" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### theory "HOL-Analysis.Weierstrass_Theorems"
### 0.868s elapsed time, 3.447s cpu time, 0.360s GC time
Loading theory "HOL-Analysis.Retracts" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Jordan_Curve" via "HOL-Analysis.Further_Topology")
### theory "HOL-Analysis.Fashoda_Theorem"
### 0.451s elapsed time, 1.792s cpu time, 0.191s GC time
Loading theory "Affine_Arithmetic.Executable_Euclidean_Space" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "Ordinary_Differential_Equations.ODE_Auxiliarities")
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Analysis.Retracts"
### 0.989s elapsed time, 3.907s cpu time, 0.586s GC time
Loading theory "HOL-Analysis.Smooth_Paths" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Smooth_Paths"
### 0.147s elapsed time, 0.590s cpu time, 0.000s GC time
sigma_finite_measure (count_space ?A)
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
### theory "HOL-Analysis.Henstock_Kurzweil_Integration"
### 2.686s elapsed time, 10.100s cpu time, 1.500s GC time
Loading theory "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Gamma_Function")
Loading theory "HOL-Analysis.Integral_Test" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
locale antimono_fun_sum_integral_diff
  fixes f :: "real => real"
  assumes "antimono_fun_sum_integral_diff f"
### theory "HOL-Analysis.Integral_Test"
### 0.147s elapsed time, 0.570s cpu time, 0.135s GC time
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
Found termination order: "(%p. size (fst (snd (snd (snd p))))) <*mlex*> {}"
class executable_euclidean_space = ordered_euclidean_space +
  fixes Basis_list :: "'a list"
    and eucl_down :: "int => 'a => 'a"
    and eucl_truncate_down :: "nat => 'a => 'a"
    and eucl_truncate_up :: "nat => 'a => 'a"
  assumes
    "eucl_down_def":
      "!!p b.
          eucl_down p b =
          (SUM i:Basis. round_down p (b \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_truncate_down_def":
      "!!q b.
          eucl_truncate_down q b =
          (SUM i:Basis. truncate_down q (b \<bullet> i) *\<^sub>R i)"
  assumes
    "eucl_truncate_up_def":
      "!!q b.
          eucl_truncate_up q b =
          (SUM i:Basis. truncate_up q (b \<bullet> i) *\<^sub>R i)"
  assumes "Basis_list": "set Basis_list = Basis"
  assumes "distinct_Basis_list": "distinct Basis_list"
instantiation
  real :: executable_euclidean_space
  Basis_list_real == Basis_list :: real list
  eucl_down_real == eucl_down :: int => real => real
  eucl_truncate_down_real == eucl_truncate_down :: nat => real => real
  eucl_truncate_up_real == eucl_truncate_up :: nat => real => real
instantiation
  prod :: (executable_euclidean_space, executable_euclidean_space)
    executable_euclidean_space
  Basis_list_prod == Basis_list :: ('a * 'b) list
  eucl_down_prod == eucl_down :: int => 'a * 'b => 'a * 'b
  eucl_truncate_down_prod == eucl_truncate_down :: nat => 'a * 'b => 'a * 'b
  eucl_truncate_up_prod == eucl_truncate_up :: nat => 'a * 'b => 'a * 'b
Found termination order: "(%p. size (fst (snd (snd p)))) <*mlex*> {}"
instantiation
  vec :: (executable_euclidean_space, enum) executable_euclidean_space
  Basis_list_vec == Basis_list :: ('a, 'b) vec list
  eucl_down_vec == eucl_down :: int => ('a, 'b) vec => ('a, 'b) vec
  eucl_truncate_down_vec == eucl_truncate_down ::
    nat => ('a, 'b) vec => ('a, 'b) vec
  eucl_truncate_up_vec == eucl_truncate_up ::
    nat => ('a, 'b) vec => ('a, 'b) vec
locale blinfun_syntax
### theory "Affine_Arithmetic.Executable_Euclidean_Space"
### 3.384s elapsed time, 11.407s cpu time, 1.590s GC time
### theory "HOL-Analysis.Equivalence_Lebesgue_Henstock_Integration"
### 2.248s elapsed time, 7.056s cpu time, 0.814s GC time
Loading theory "HOL-Analysis.Further_Topology" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Jordan_Curve")
Loading theory "HOL-Analysis.Gamma_Function" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume")
Loading theory "HOL-Analysis.Improper_Integral" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Improper_Integral"
### 0.482s elapsed time, 1.893s cpu time, 0.300s GC time
Loading theory "HOL-Analysis.Equivalence_Measurable_On_Borel" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
Found termination order: "(%p. size (fst (snd p))) <*mlex*> {}"
### theory "HOL-Analysis.Equivalence_Measurable_On_Borel"
### 0.738s elapsed time, 2.905s cpu time, 0.341s GC time
Loading theory "HOL-Analysis.Interval_Integral" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume" via "HOL-Analysis.Lebesgue_Integral_Substitution")
### theory "HOL-Analysis.Interval_Integral"
### 0.546s elapsed time, 2.142s cpu time, 0.191s GC time
Loading theory "HOL-Analysis.Lebesgue_Integral_Substitution" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Ball_Volume")
### theory "HOL-Analysis.Lebesgue_Integral_Substitution"
### 0.147s elapsed time, 0.576s cpu time, 0.107s GC time
Loading theory "HOL-Analysis.Vitali_Covering_Theorem" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis" via "HOL-Analysis.Change_Of_Vars")
class Gamma = complete_space + real_normed_field +
  fixes rGamma :: "'a => 'a"
  assumes
    "rGamma_eq_zero_iff_aux":
      "!!z. (rGamma z = (0::'a)) = (EX n. z = - of_nat n)"
  assumes
    "differentiable_rGamma_aux1":
      "!!z. (!!n. z ~= - of_nat n) ==>
            let d = (THE d.
                        (%n. SUM k<n.
                             inverse (of_nat (Suc k)) -
                             inverse (z + of_nat k))
                        \<longlonglongrightarrow> d) -
                    euler_mascheroni *\<^sub>R (1::'a)
            in ((%y. (rGamma y - rGamma z +
                      rGamma z * d * (y - z)) /\<^sub>R
                     norm (y - z)) \<longlongrightarrow>
                (0::'a))
                (at z)"
  assumes
    "differentiable_rGamma_aux2":
      "!!n. let z = - of_nat n
            in ((%y. (rGamma y - rGamma z -
                      (- (1::'a)) ^ n * prod of_nat {1..n} *
                      (y - z)) /\<^sub>R
                     norm (y - z)) \<longlongrightarrow>
                (0::'a))
                (at z)"
  assumes
    "rGamma_series_aux":
      "!!z. (!!n. z ~= - of_nat n) ==>
            let fact' = %n. prod of_nat {1..n};
                exp =
                  %x. THE e.
                         (%n. SUM k<n. x ^ k /\<^sub>R fact k)
                         \<longlonglongrightarrow> e;
                pochhammer' = %a n. PROD n = 0..n. a + of_nat n
            in (%n. pochhammer' z n /
                    (fact' n * exp (z * ln (real n) *\<^sub>R (1::'a))))
               \<longlonglongrightarrow> rGamma z"
instantiation
  complex :: Gamma
  rGamma_complex == rGamma :: complex => complex
instantiation
  real :: Gamma
  rGamma_real == rGamma :: real => real
### theory "HOL-Analysis.Further_Topology"
### 3.000s elapsed time, 11.798s cpu time, 1.506s GC time
Loading theory "HOL-Analysis.Jordan_Curve" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Vitali_Covering_Theorem"
### 1.211s elapsed time, 4.760s cpu time, 0.628s GC time
Loading theory "HOL-Analysis.Change_Of_Vars" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Gamma_Function"
### 3.293s elapsed time, 12.937s cpu time, 1.718s GC time
Loading theory "HOL-Analysis.Ball_Volume" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Ball_Volume"
### 0.613s elapsed time, 2.408s cpu time, 0.346s GC time
?z ~: \<int>\<^sub>\<le>\<^sub>0 ==>
(Polygamma ?n has_field_derivative Polygamma (Suc ?n) ?z) (at ?z within ?A)
### theory "HOL-Analysis.Jordan_Curve"
### 0.935s elapsed time, 3.614s cpu time, 0.557s GC time
### theory "HOL-Analysis.Change_Of_Vars"
### 1.107s elapsed time, 3.598s cpu time, 0.491s GC time
Loading theory "HOL-Analysis.Simplex_Content" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex" via "HOL-Analysis.Analysis")
### theory "HOL-Analysis.Simplex_Content"
### 0.101s elapsed time, 0.216s cpu time, 0.042s GC time
Loading theory "HOL-Analysis.Analysis" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex")
signature APPROXIMATION_COMPUTATION =
  sig
    val approx_arith: Proof.context -> term -> term
    val approx_bool: Proof.context -> term -> term
    val approx_conv: Proof.context -> conv
    val approx_form_eval: Proof.context -> term -> term
  end
structure Approximation_Computation: APPROXIMATION_COMPUTATION
signature APPROXIMATION =
  sig
    val approx: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val reify_form: Proof.context -> term -> term
  end
structure Approximation:
  sig
    val apply_reify_form: Proof.context -> term -> term
    val apply_tactic: Proof.context -> term -> tactic -> term
    val approx: int -> Proof.context -> term -> term
    val approx_arith: int -> Proof.context -> term -> term
    val approx_form: int -> Proof.context -> term -> term
    val approximate: Proof.context -> term -> term
    val approximate_cmd: string list -> string -> Toplevel.state -> unit
    val approximation_tac:
       int ->
         (string * int) list -> int option -> Proof.context -> int -> tactic
    val calculated_subterms: term -> term list
    val dest_float: term -> int * int
    val dest_interpret: term -> term * term
    val dest_interpret_env: term -> term
    val dest_interpret_form: term -> term * term
    val dest_ivl: term -> ((int * int) * (int * int)) option
    val float2_float10: int -> bool -> int * int -> int * int
    val mk_approx': int -> term -> term
    val mk_approx_form_eval: int -> term -> term -> term
    val mk_result: int -> ((int * int) * (int * int)) option -> term
    val opt_modes: Token.T list -> string list * Token.T list
    val prepare_form: Proof.context -> term -> term
    val prepare_form_tac: Proof.context -> int -> tactic
    val preproc_form_conv: Proof.context -> conv
    val realify: term -> term
    val reify_form: Proof.context -> term -> term
    val reify_form_conv: Proof.context -> cterm -> thm
    val reify_form_tac: Proof.context -> int -> tactic
    val reorder_bounds_tac: Proof.context -> thm list -> int -> tactic
    val rewrite_interpret_form_tac:
       Proof.context ->
         int ->
           (string * int) list -> int option -> int -> thm -> thm Seq.seq
  end
### ML warning (line 201 of "~~/src/HOL/Decision_Procs/approximation_generator.ML"):
### Matches are not exhaustive.
signature APPROXIMATION_GENERATOR =
  sig
    val approximation_generator:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val custom_seed: int Config.T
    val epsilon: real Config.T
    val precision: int Config.T
    val setup: theory -> theory
  end
structure Approximation_Generator: APPROXIMATION_GENERATOR
bundle floatarith_notation
bundle no_floatarith_notation
### theory "HOL-Decision_Procs.Approximation"
### 77.624s elapsed time, 272.756s cpu time, 173.552s GC time
### theory "HOL-Analysis.Analysis"
### 7.124s elapsed time, 18.974s cpu time, 10.088s GC time
Loading theory "Ordinary_Differential_Equations.Bounded_Linear_Operator" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Flow")
Loading theory "Ordinary_Differential_Equations.Vector_Derivative_On" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Flow" via "Ordinary_Differential_Equations.Picard_Lindeloef_Qualitative" via "Ordinary_Differential_Equations.Initial_Value_Problem" via "Ordinary_Differential_Equations.Interval_Integral_HK")
Loading theory "Ordinary_Differential_Equations.ODE_Auxiliarities" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.MVT_Ex")
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Bounded_Linear_Function.blinfun" found.
### theory "Ordinary_Differential_Equations.Vector_Derivative_On"
### 0.196s elapsed time, 0.658s cpu time, 0.084s GC time
Loading theory "Ordinary_Differential_Equations.Gronwall" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Flow" via "Ordinary_Differential_Equations.Picard_Lindeloef_Qualitative" via "Ordinary_Differential_Equations.Initial_Value_Problem")
Loading theory "Ordinary_Differential_Equations.Interval_Integral_HK" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Flow" via "Ordinary_Differential_Equations.Picard_Lindeloef_Qualitative" via "Ordinary_Differential_Equations.Initial_Value_Problem")
### theory "Ordinary_Differential_Equations.Gronwall"
### 0.129s elapsed time, 0.524s cpu time, 0.000s GC time
instantiation
  blinop :: (real_normed_vector) real_normed_vector
  uminus_blinop == uminus :: 'a blinop => 'a blinop
  zero_blinop == zero_class.zero :: 'a blinop
  minus_blinop == minus :: 'a blinop => 'a blinop => 'a blinop
  plus_blinop == plus :: 'a blinop => 'a blinop => 'a blinop
  sgn_blinop == sgn :: 'a blinop => 'a blinop
  norm_blinop == norm :: 'a blinop => real
  scaleR_blinop == scaleR :: real => 'a blinop => 'a blinop
  dist_blinop == dist :: 'a blinop => 'a blinop => real
  uniformity_blinop == uniformity :: ('a blinop * 'a blinop) filter
  open_blinop == open :: 'a blinop set => bool
### theory "Ordinary_Differential_Equations.Interval_Integral_HK"
### 0.268s elapsed time, 0.946s cpu time, 0.079s GC time
instantiation
  prod :: (zero_neq_one, zero_neq_one) zero_neq_one
  one_prod == one_class.one :: 'a * 'b
locale no_real_inner
instantiation
  blinop :: ({real_normed_vector,perfect_space}) real_normed_algebra_1
  one_blinop == one_class.one :: 'a blinop
  times_blinop == times :: 'a blinop => 'a blinop => 'a blinop
### theory "Ordinary_Differential_Equations.ODE_Auxiliarities"
### 0.828s elapsed time, 2.368s cpu time, 0.233s GC time
Loading theory "Ordinary_Differential_Equations.Cones" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis")
Loading theory "Ordinary_Differential_Equations.Initial_Value_Problem" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Flow" via "Ordinary_Differential_Equations.Picard_Lindeloef_Qualitative")
Loading theory "Ordinary_Differential_Equations.MVT_Ex" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis")
### theory "Ordinary_Differential_Equations.Bounded_Linear_Operator"
### 0.858s elapsed time, 2.488s cpu time, 0.233s GC time
Loading theory "Ordinary_Differential_Equations.Multivariate_Taylor" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Flow")
locale second_derivative_within
  fixes f :: "'a => 'b"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'b"
    and f'' :: "'a \<Rightarrow>\<^sub>L 'a \<Rightarrow>\<^sub>L 'b"
    and a :: "'a"
    and G :: "'a set"
  assumes "second_derivative_within f f' f'' a G"
locale second_derivative
  fixes f :: "'a => 'b"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'b"
    and f'' :: "'a \<Rightarrow>\<^sub>L 'a \<Rightarrow>\<^sub>L 'b"
    and a :: "'a"
    and G :: "'a set"
  assumes "second_derivative f f' f'' a G"
locale second_derivative_within'
  fixes f :: "'a => 'b"
    and f' :: "'a => 'a => 'b"
    and f'' :: "'a => 'a => 'b"
    and a :: "'a"
    and G :: "'a set"
  assumes "second_derivative_within' f f' f'' a G"
locale second_derivative_on_open
  fixes f :: "'a => 'b"
    and f' :: "'a => 'a => 'b"
    and f'' :: "'a => 'a => 'b"
    and a :: "'a"
    and G :: "'a set"
  assumes "second_derivative_on_open f f' f'' a G"
### theory "Ordinary_Differential_Equations.Multivariate_Taylor"
### 0.685s elapsed time, 2.709s cpu time, 0.250s GC time
### theory "Ordinary_Differential_Equations.Cones"
### 0.939s elapsed time, 3.532s cpu time, 0.340s GC time
locale continuous_rhs
  fixes T :: "'a set"
    and X :: "'b set"
    and f :: "'a => 'b => 'c"
  assumes "continuous_rhs T X f"
### theory "Ordinary_Differential_Equations.MVT_Ex"
### 1.342s elapsed time, 4.402s cpu time, 0.467s GC time
locale global_lipschitz
  fixes T :: "'a set"
    and X :: "'b set"
    and f :: "'a => 'b => 'c"
    and L :: "real"
  assumes "global_lipschitz T X f L"
locale closed_domain
  fixes X :: "'a set"
  assumes "closed_domain X"
locale interval
  fixes T :: "real set"
  assumes "interval T"
locale nonempty_set
  fixes T :: "'a set"
  assumes "nonempty_set T"
locale compact_interval
  fixes T :: "real set"
  assumes "compact_interval T"
locale self_mapping
  fixes T :: "real set"
    and t0 :: "real"
    and x0 :: "'a"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
  assumes "self_mapping T t0 x0 f X"
locale unique_on_closed
  fixes t0 :: "real"
    and T :: "real set"
    and x0 :: "'a"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and L :: "real"
  assumes "unique_on_closed t0 T x0 f X L"
### Ignoring duplicate introduction (intro)
### [| tmin <= ?t; ?t <= tmax |] ==> ?t : T
### Ignoring duplicate rewrite rule:
### [| tmin <= ?t1; ?t1 <= tmax |] ==> ?t1 : T == True
locale unique_on_bounded_closed
  fixes t0 :: "real"
    and T :: "real set"
    and x0 :: "'a"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and L :: "real"
  assumes "unique_on_bounded_closed t0 T x0 f X L"
locale unique_on_closed
  fixes t0 :: "real"
    and T :: "real set"
    and x0 :: "'a"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and L :: "real"
  assumes "unique_on_closed t0 T x0 f X L"
consts
  psolution :: "nat => real => 'a"
locale unique_on_strip
  fixes t0 :: "real"
    and T :: "real set"
    and f :: "real => 'a => 'a"
    and L :: "real"
  assumes "unique_on_strip t0 T f L"
locale solution_in_cylinder
  fixes t0 :: "real"
    and T :: "real set"
    and x0 :: "'a"
    and b :: "real"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and B :: "real"
  assumes "solution_in_cylinder t0 T x0 b f B"
  defines "X == cball x0 b"
locale unique_on_cylinder
  fixes t0 :: "real"
    and T :: "real set"
    and x0 :: "'a"
    and b :: "real"
    and X :: "'a set"
    and f :: "real => 'a => 'a"
    and B :: "real"
    and L :: "real"
  assumes "unique_on_cylinder t0 T x0 b f B L"
  defines "X == cball x0 b"
locale derivative_on_prod
  fixes T :: "real set"
    and X :: "'a set"
    and f :: "real => 'a => 'a"
    and f' :: "real * 'a => real * 'a => 'a"
  assumes "derivative_on_prod T X f f'"
### theory "Ordinary_Differential_Equations.Initial_Value_Problem"
### 1.859s elapsed time, 4.921s cpu time, 0.547s GC time
Loading theory "Ordinary_Differential_Equations.Picard_Lindeloef_Qualitative" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Flow")
locale ll_on_open
  fixes T :: "real set"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
  assumes "ll_on_open T f X"
locale ll_on_open_it
  fixes T :: "real set"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and t0 :: "real"
  assumes "ll_on_open_it T f X"
locale ll_on_open
  fixes T :: "real set"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
  assumes "ll_on_open T f X"
locale ll_on_open_it
  fixes T :: "real set"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and t0 :: "real"
  assumes "ll_on_open_it T f X"
### theory "Ordinary_Differential_Equations.Picard_Lindeloef_Qualitative"
### 0.342s elapsed time, 0.393s cpu time, 0.070s GC time
Loading theory "Ordinary_Differential_Equations.Flow" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis")
locale ll_on_open_it
  fixes T :: "real set"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and t0 :: "real"
  assumes "ll_on_open_it T f X"
[| ?A ~= {}; compact ?A; open ?B; ?A <= ?B;
   !!e. [| 0 < e; {x. infdist x ?A <= e} <= ?B |] ==> ?thesis |]
==> ?thesis
locale two_ll_on_open
  fixes F :: "real => 'a => 'a"
    and T1 :: "real set"
    and G :: "real => 'a => 'a"
    and T2 :: "real set"
    and X :: "'a set"
    and J :: "real set"
    and x0 :: "'a"
    and e :: "real"
    and K :: "real"
  assumes "two_ll_on_open F T1 G T2 X J x0 e K"
locale auto_ll_on_open
  fixes f :: "'a => 'a"
    and X :: "'a set"
  assumes "auto_ll_on_open f X"
locale compact_continuously_diff
  fixes T :: "real set"
    and X :: "'a set"
    and f :: "real => 'a => 'a"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'a"
  assumes "compact_continuously_diff T X f f'"
locale unique_on_compact_continuously_diff
  fixes T :: "real set"
    and t0 :: "real"
    and x0 :: "'a"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'a"
  assumes "unique_on_compact_continuously_diff T t0 x0 f X f'"
locale c1_on_open
  fixes f :: "'a => 'a"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'a"
    and X :: "'a set"
  assumes "c1_on_open f f' X"
locale c1_on_open_euclidean
  fixes f :: "'a => 'a"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'a"
    and X :: "'a set"
  assumes "c1_on_open_euclidean f f' X"
### theory "Ordinary_Differential_Equations.Flow"
### 2.052s elapsed time, 2.163s cpu time, 0.154s GC time
Loading theory "Ordinary_Differential_Equations.Poincare_Map" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis" via "Ordinary_Differential_Equations.Reachability_Analysis")
Loading theory "Ordinary_Differential_Equations.Upper_Lower_Solution" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis")
Loading theory "Ordinary_Differential_Equations.Linear_ODE" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis")
### theory "Ordinary_Differential_Equations.Linear_ODE"
### 0.071s elapsed time, 0.216s cpu time, 0.000s GC time
locale ll_on_open_it
  fixes T :: "real set"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and t0 :: "real"
  assumes "ll_on_open_it T f X"
locale ll_on_open_real
  fixes T :: "real set"
    and f :: "real => real => real"
    and X :: "real set"
  assumes "ll_on_open_real T f X"
locale auto_ll_on_open
  fixes f :: "'a => 'a"
    and X :: "'a set"
  assumes "auto_ll_on_open f X"
### theory "Ordinary_Differential_Equations.Upper_Lower_Solution"
### 0.187s elapsed time, 0.485s cpu time, 0.091s GC time
### Ignoring duplicate rewrite rule:
### norm (- ?x1) == norm ?x1
locale c1_on_open_euclidean
  fixes f :: "'a => 'a"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'a"
    and X :: "'a set"
  assumes "c1_on_open_euclidean f f' X"
### theory "Ordinary_Differential_Equations.Poincare_Map"
### 1.104s elapsed time, 1.466s cpu time, 0.222s GC time
Loading theory "Ordinary_Differential_Equations.Reachability_Analysis" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis")
locale c1_on_open_euclidean
  fixes f :: "'a => 'a"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'a"
    and X :: "'a set"
  assumes "c1_on_open_euclidean f f' X"
### theory "Ordinary_Differential_Equations.Reachability_Analysis"
### 0.994s elapsed time, 1.044s cpu time, 0.068s GC time
Loading theory "Ordinary_Differential_Equations.Flow_Congs" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Ordinary_Differential_Equations.ODE_Analysis")
locale ll_on_open_it
  fixes T :: "real set"
    and f :: "real => 'a => 'a"
    and X :: "'a set"
    and t0 :: "real"
  assumes "ll_on_open_it T f X"
locale auto_ll_on_open
  fixes f :: "'a => 'a"
    and X :: "'a set"
  assumes "auto_ll_on_open f X"
locale c1_on_open_euclidean
  fixes f :: "'a => 'a"
    and f' :: "'a => 'a \<Rightarrow>\<^sub>L 'a"
    and X :: "'a set"
  assumes "c1_on_open_euclidean f f' X"
### theory "Ordinary_Differential_Equations.Flow_Congs"
### 0.316s elapsed time, 0.348s cpu time, 0.045s GC time
Loading theory "Ordinary_Differential_Equations.ODE_Analysis" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
### theory "Ordinary_Differential_Equations.ODE_Analysis"
### 1.427s elapsed time, 1.461s cpu time, 0.047s GC time
Loading theory "Draft.Lib" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
### theory "Draft.Lib"
### 0.154s elapsed time, 0.191s cpu time, 0.051s GC time
Loading theory "Draft.Denotational_Semantics" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
Loading theory "Draft.Pretty_Printer" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic" via "Draft.Proof_Checker")
### Ignoring sort constraints in type variables(s): "'a"
### in type abbreviation "Rvec"
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
Found termination order:
  "(%p. size_list (size_list size) (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
consts
  sterm_sem ::
    "('a, 'b, 'c) interp => ('a, 'c) trm => (real, 'c) vec => real"
Found termination order: "{}"
consts
  trm_to_string :: "('sf, 'sz) trm => char list"
consts
  frechet ::
    "('a, 'b, 'c) interp
     => ('a, 'c) trm => (real, 'c) vec => (real, 'c) vec => real"
consts
  ode_to_string :: "('sf, 'sz) ODE => char list"
consts
  dterm_sem ::
    "('a, 'b, 'c) interp
     => ('a, 'c) trm => (real, 'c) vec * (real, 'c) vec => real"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order:
  "case_sum (%p. size (snd p)) (%p. size (snd p)) <*mlex*> {}"
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
Found termination order: "{}"
### Ambiguous input (line 355 of "$AFP/Differential_Dynamic_Logic/Denotational_Semantics.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>FuncSet.funcset" ("_position" A) ("_position" B)))))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member" ("_position" \<nu>)
###         ("_applC" ("_position" fml_sem)
###           ("_cargs" ("_position" I) ("_position" A))))
###       ("\<^const>Set.member" ("_position" \<nu>)
###         ("_applC" ("_position" fml_sem)
###           ("_cargs" ("_position" I) ("_position" B)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Implies" ("_position" A) ("_position" B)))))
###     ("\<^const>HOL.implies"
###       ("\<^const>Set.member" ("_position" \<nu>)
###         ("_applC" ("_position" fml_sem)
###           ("_cargs" ("_position" I) ("_position" A))))
###       ("\<^const>Set.member" ("_position" \<nu>)
###         ("_applC" ("_position" fml_sem)
###           ("_cargs" ("_position" I) ("_position" B)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
Found termination order: "{}"
### theory "Draft.Denotational_Semantics"
### 3.713s elapsed time, 8.025s cpu time, 0.836s GC time
Loading theory "Draft.Axioms" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
Loading theory "Draft.Frechet_Correctness" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
### Generation of a parametrized correspondence relation failed.
### Reason:
###   No relator for the type "Denotational_Semantics.interp.interp_ext" found.
### Generation of a parametrized correspondence relation failed.
### Reason:  No relator for the type "Syntax.trm" found.
### Ambiguous input (line 34 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 4 parse trees:
### ("\<^const>Pure.eq" ("_position" loop_iterate_axiom)
###   ("\<^const>Syntax.Equiv"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("_applC" ("_position" Predicational) ("_position" pid1)))
###     ("\<^const>Syntax.formula.And"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar")
###             ("\<^const>Syntax.hp.Loop" ("_position" vid1)))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))))
### ("\<^const>Pure.eq" ("_position" loop_iterate_axiom)
###   ("\<^const>Syntax.Equiv"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar")
###         ("\<^const>Syntax.hp.Loop" ("_position" vid1)))
###       ("_applC" ("_position" Predicational) ("_position" pid1)))
###     ("\<^const>Syntax.formula.And"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar")
###             ("\<^const>Syntax.hp.Loop" ("_position" vid1)))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))))
### ("\<^const>Pure.eq" ("_position" loop_iterate_axiom)
###   ("\<^const>Syntax.Equiv"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("_applC" ("_position" Predicational) ("_position" pid1)))
###     ("\<^const>Syntax.formula.And"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>Syntax.Box"
###           ("\<^const>Syntax.hp.Loop"
###             ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))))
### ("\<^const>Pure.eq" ("_position" loop_iterate_axiom)
###   ("\<^const>Syntax.Equiv"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar")
###         ("\<^const>Syntax.hp.Loop" ("_position" vid1)))
###       ("_applC" ("_position" Predicational) ("_position" pid1)))
###     ("\<^const>Syntax.formula.And"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>Syntax.Box"
###           ("\<^const>Syntax.hp.Loop"
###             ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 38 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 2 parse trees:
### ("\<^const>Pure.eq" ("_position" test_axiom)
###   ("\<^const>Syntax.Equiv"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Test")
###         ("_applC" ("\<^const>Syntax.formula.Prop")
###           ("_cargs" ("_position" vid2) ("_position" empty))))
###       ("_applC" ("\<^const>Syntax.formula.Prop")
###         ("_cargs" ("_position" vid1) ("_position" empty))))
###     ("\<^const>Syntax.Implies"
###       ("_applC" ("\<^const>Syntax.formula.Prop")
###         ("_cargs" ("_position" vid2) ("_position" empty)))
###       ("_applC" ("\<^const>Syntax.formula.Prop")
###         ("_cargs" ("_position" vid1) ("_position" empty))))))
### ("\<^const>Pure.eq" ("_position" test_axiom)
###   ("\<^const>Syntax.Equiv"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Test")
###         ("_applC" ("\<^const>Syntax.formula.Prop")
###           ("_cargs" ("_position" vid2) ("_position" empty))))
###       ("_applC" ("\<^const>Syntax.formula.Prop")
###         ("_cargs" ("_position" vid1) ("_position" empty))))
###     ("\<^const>FuncSet.funcset"
###       ("_applC" ("\<^const>Syntax.formula.Prop")
###         ("_cargs" ("_position" vid2) ("_position" empty)))
###       ("_applC" ("\<^const>Syntax.formula.Prop")
###         ("_cargs" ("_position" vid1) ("_position" empty))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Frechet_Correctness"
### 0.377s elapsed time, 1.128s cpu time, 0.050s GC time
Loading theory "Draft.Static_Semantics" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
### Ambiguous input (line 53 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 8 parse trees:
### ("\<^const>Pure.eq" ("_position" Kaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("_position" Predicational) ("_position" pid1))
###           ("_applC" ("_position" Predicational) ("_position" pid2))))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("_applC" ("_position" Predicational) ("_position" pid2)))))
### ("\<^const>Pure.eq" ("_position" Kaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("\<^const>FuncSet.funcset"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid1)))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))))
### ("\<^const>Pure.eq" ("_position" Kaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("\<^const>Syntax.Implies"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid1)))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))))
### ("\<^const>Pure.eq" ("_position" Kaxiom)
###   ("\<^const>FuncSet.funcset"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("\<^const>FuncSet.funcset"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid1)))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))))
### ("\<^const>Pure.eq" ("_position" Kaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("\<^const>FuncSet.funcset"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid1)))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))))
### ("\<^const>Pure.eq" ("_position" Kaxiom)
###   ("\<^const>FuncSet.funcset"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("\<^const>Syntax.Implies"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid1)))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))))
### ("\<^const>Pure.eq" ("_position" Kaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("\<^const>Syntax.Implies"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid1)))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid2))))))
### ("\<^const>Pure.eq" ("_position" Kaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("_position" Predicational) ("_position" pid1))
###           ("_applC" ("_position" Predicational) ("_position" pid2))))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("_applC" ("_position" Predicational) ("_position" pid2)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 65 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 8 parse trees:
### ("\<^const>Pure.eq" ("_position" Iaxiom)
###   ("\<^const>FuncSet.funcset"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("\<^const>FuncSet.funcset"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))
###     ("\<^const>FuncSet.funcset"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("\<^const>Syntax.hp.Loop"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))))
### ("\<^const>Pure.eq" ("_position" Iaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("\<^const>FuncSet.funcset"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))
###     ("\<^const>FuncSet.funcset"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("\<^const>Syntax.hp.Loop"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))))
### ("\<^const>Pure.eq" ("_position" Iaxiom)
###   ("\<^const>FuncSet.funcset"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("\<^const>Syntax.Implies"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))
###     ("\<^const>FuncSet.funcset"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("\<^const>Syntax.hp.Loop"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))))
### ("\<^const>Pure.eq" ("_position" Iaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("\<^const>Syntax.Implies"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))
###     ("\<^const>FuncSet.funcset"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("\<^const>Syntax.hp.Loop"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))))
### ("\<^const>Pure.eq" ("_position" Iaxiom)
###   ("\<^const>FuncSet.funcset"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("\<^const>FuncSet.funcset"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))
###     ("\<^const>Syntax.Implies"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("\<^const>Syntax.hp.Loop"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))))
### ("\<^const>Pure.eq" ("_position" Iaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("\<^const>FuncSet.funcset"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))
###     ("\<^const>Syntax.Implies"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("\<^const>Syntax.hp.Loop"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))))
### ("\<^const>Pure.eq" ("_position" Iaxiom)
###   ("\<^const>FuncSet.funcset"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("\<^const>Syntax.Implies"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))
###     ("\<^const>Syntax.Implies"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("\<^const>Syntax.hp.Loop"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))))
### ("\<^const>Pure.eq" ("_position" Iaxiom)
###   ("\<^const>Syntax.Implies"
###     ("\<^const>Syntax.Box"
###       ("\<^const>Syntax.hp.Loop"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###       ("\<^const>Syntax.Implies"
###         ("_applC" ("_position" Predicational) ("_position" pid1))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))
###     ("\<^const>Syntax.Implies"
###       ("_applC" ("_position" Predicational) ("_position" pid1))
###       ("\<^const>Syntax.Box"
###         ("\<^const>Syntax.hp.Loop"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###         ("_applC" ("_position" Predicational) ("_position" pid1))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  SIGT :: "('a, 'c) trm => 'a set"
### Ambiguous input (line 70 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 2 parse trees:
### ("\<^const>Pure.eq" ("_position" Vaxiom)
###   ("\<^const>FuncSet.funcset"
###     ("_applC" ("\<^const>Syntax.formula.Prop")
###       ("_cargs" ("_position" vid1) ("_position" empty)))
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("_applC" ("\<^const>Syntax.formula.Prop")
###         ("_cargs" ("_position" vid1) ("_position" empty))))))
### ("\<^const>Pure.eq" ("_position" Vaxiom)
###   ("\<^const>Syntax.Implies"
###     ("_applC" ("\<^const>Syntax.formula.Prop")
###       ("_cargs" ("_position" vid1) ("_position" empty)))
###     ("\<^const>Syntax.Box"
###       ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###       ("_applC" ("\<^const>Syntax.formula.Prop")
###         ("_cargs" ("_position" vid1) ("_position" empty))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  SIGO :: "('a, 'c) ODE => ('a + 'c) set"
### Ambiguous input (line 105 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Box"
###             ("\<^const>Syntax.hp.Loop"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1)))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))))
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1))
###               ("\<^const>Syntax.Box"
###                 ("\<^const>Syntax.hp.Loop"
###                   ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1)))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid1))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Box"
###             ("_applC" ("\<^const>Syntax.hp.Pvar")
###               ("\<^const>Syntax.hp.Loop" ("_position" id1)))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))))
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1))
###               ("\<^const>Syntax.Box"
###                 ("\<^const>Syntax.hp.Loop"
###                   ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1)))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid1))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Box"
###             ("\<^const>Syntax.hp.Loop"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1)))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))))
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1))
###               ("\<^const>Syntax.Box"
###                 ("_applC" ("\<^const>Syntax.hp.Pvar")
###                   ("\<^const>Syntax.hp.Loop" ("_position" id1)))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid1))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Box"
###             ("_applC" ("\<^const>Syntax.hp.Pvar")
###               ("\<^const>Syntax.hp.Loop" ("_position" id1)))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))))
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1))
###               ("\<^const>Syntax.Box"
###                 ("_applC" ("\<^const>Syntax.hp.Pvar")
###                   ("\<^const>Syntax.hp.Loop" ("_position" id1)))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid1))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 110 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 4 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1))
###               ("\<^const>Syntax.Box"
###                 ("\<^const>Syntax.hp.Loop"
###                   ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1)))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid1))))))))
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Box"
###             ("\<^const>Syntax.hp.Loop"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1)))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1))
###               ("\<^const>Syntax.Box"
###                 ("_applC" ("\<^const>Syntax.hp.Pvar")
###                   ("\<^const>Syntax.hp.Loop" ("_position" id1)))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid1))))))))
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Box"
###             ("\<^const>Syntax.hp.Loop"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1)))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1))
###               ("\<^const>Syntax.Box"
###                 ("\<^const>Syntax.hp.Loop"
###                   ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1)))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid1))))))))
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Box"
###             ("_applC" ("\<^const>Syntax.hp.Pvar")
###               ("\<^const>Syntax.hp.Loop" ("_position" id1)))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.implies"
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" id1))
###               ("\<^const>Syntax.Box"
###                 ("_applC" ("\<^const>Syntax.hp.Pvar")
###                   ("\<^const>Syntax.hp.Loop" ("_position" id1)))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid1))))))))
###     ("\<^const>Set.member" ("_position" \<nu>)
###       ("_applC" ("_position" fml_sem)
###         ("_cargs" ("_position" I)
###           ("\<^const>Syntax.Box"
###             ("_applC" ("\<^const>Syntax.hp.Pvar")
###               ("\<^const>Syntax.hp.Loop" ("_position" id1)))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 139 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" \<nu>)
###     ("_applC" ("_position" fml_sem)
###       ("_cargs" ("_position" I)
###         ("\<^const>Syntax.Box"
###           ("\<^const>Syntax.hp.Loop"
###             ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###               ("_applC" ("_position" Predicational)
###                 ("_position" pid1)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" \<nu>)
###     ("_applC" ("_position" fml_sem)
###       ("_cargs" ("_position" I)
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar")
###             ("\<^const>Syntax.hp.Loop" ("_position" vid1)))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("\<^const>Syntax.Box"
###               ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###               ("_applC" ("_position" Predicational)
###                 ("_position" pid1)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 142 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" \<nu>)
###     ("_applC" ("_position" fml_sem)
###       ("_cargs" ("_position" I)
###         ("\<^const>Syntax.Box"
###           ("\<^const>Syntax.hp.Loop"
###             ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1)))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>Set.member" ("_position" \<nu>)
###     ("_applC" ("_position" fml_sem)
###       ("_cargs" ("_position" I)
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar")
###             ("\<^const>Syntax.hp.Loop" ("_position" vid1)))
###           ("_applC" ("_position" Predicational) ("_position" pid1)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  SIGP :: "('a, 'b, 'c) hp => ('a + 'b + 'c) set"
  SIGF :: "('a, 'b, 'c) formula => ('a + 'b + 'c) set"
### Ambiguous input (line 193 of "$AFP/Differential_Dynamic_Logic/Axioms.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" MP_holds)
###     ("_cargs" ("_position" \<phi>) ("_position" \<psi>)))
###   ("\<^const>HOL.implies"
###     ("_applC" ("_position" valid)
###       ("\<^const>Syntax.Implies" ("_position" \<phi>) ("_position" \<psi>)))
###     ("\<^const>HOL.implies"
###       ("_applC" ("_position" valid) ("_position" \<phi>))
###       ("_applC" ("_position" valid) ("_position" \<psi>)))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" MP_holds)
###     ("_cargs" ("_position" \<phi>) ("_position" \<psi>)))
###   ("\<^const>HOL.implies"
###     ("_applC" ("_position" valid)
###       ("\<^const>FuncSet.funcset" ("_position" \<phi>)
###         ("_position" \<psi>)))
###     ("\<^const>HOL.implies"
###       ("_applC" ("_position" valid) ("_position" \<phi>))
###       ("_applC" ("_position" valid) ("_position" \<psi>)))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Additional type variable(s) in specification of "CT_holds": 'sc
### Additional type variable(s) in specification of "CQ_holds": 'sc
Found termination order: "{}"
### theory "Draft.Axioms"
### 0.680s elapsed time, 2.051s cpu time, 0.127s GC time
consts
  FVT :: "('a, 'c) trm => ('c + 'c) set"
Found termination order: "{}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "case_sum size size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "case_sum size size <*mlex*> {}"
### theory "Draft.Static_Semantics"
### 1.691s elapsed time, 3.880s cpu time, 0.389s GC time
Loading theory "Draft.Coincidence" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
Loading theory "Draft.USubst" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
### theory "Draft.Coincidence"
### 0.382s elapsed time, 1.141s cpu time, 0.106s GC time
Loading theory "Draft.Bound_Effect" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
Loading theory "Draft.Differential_Axioms" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
### theory "Draft.Bound_Effect"
### 0.116s elapsed time, 0.451s cpu time, 0.049s GC time
Loading theory "Draft.Uniform_Renaming" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
Proofs for inductive predicate(s) "TadmitFFO"
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
  Proving monotonicity ...
Found termination order: "{}"
consts
  TsubstFO :: "('a + 'b, 'c) trm => ('b => ('a, 'c) trm) => ('a, 'c) trm"
Proofs for inductive predicate(s) "TadmitFO"
consts
  TUrename :: "'sz => 'sz => ('sf, 'sz) trm => ('sf, 'sz) trm"
  Proving monotonicity ...
consts
  OUrename :: "'sz => 'sz => ('sf, 'sz) ODE => ('sf, 'sz) ODE"
Proofs for inductive predicate(s) "ORadmit"
  Proving monotonicity ...
consts
  Tsubst :: "('a, 'c) trm => ('a, 'b, 'c) subst => ('a, 'c) trm"
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
consts
  OsubstFO :: "('a + 'b, 'c) ODE => ('b => ('a, 'c) trm) => ('a, 'c) ODE"
consts
  PUrename :: "'sz => 'sz => ('sf, 'sc, 'sz) hp => ('sf, 'sc, 'sz) hp"
  FUrename ::
    "'sz => 'sz => ('sf, 'sc, 'sz) formula => ('sf, 'sc, 'sz) formula"
consts
  Osubst :: "('a, 'c) ODE => ('a, 'b, 'c) subst => ('a, 'c) ODE"
Proofs for inductive predicate(s) "PRadmit", "FRadmit"
  Proving monotonicity ...
### Ambiguous input (line 50 of "$AFP/Differential_Dynamic_Logic/Differential_Axioms.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DCaxiom)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" EvolveODE)
###           ("_cargs" ("_applC" ("_position" OVar) ("_position" vid1))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))
###         ("_applC" ("_position" Predicational) ("_position" pid3)))
###       ("\<^const>Syntax.Equiv"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" EvolveODE)
###             ("_cargs" ("_applC" ("_position" OVar) ("_position" vid1))
###               ("_applC" ("_position" Predicational) ("_position" pid1))))
###           ("_applC" ("_position" Predicational) ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" EvolveODE)
###             ("_cargs" ("_applC" ("_position" OVar) ("_position" vid1))
###               ("_applC" ("_position" And)
###                 ("_cargs"
###                   ("_applC" ("_position" Predicational) ("_position" pid1))
###                   ("_applC" ("_position" Predicational)
###                     ("_position" pid3))))))
###           ("_applC" ("_position" Predicational) ("_position" pid2)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DCaxiom)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" EvolveODE)
###           ("_cargs" ("_applC" ("_position" OVar) ("_position" vid1))
###             ("_applC" ("_position" Predicational) ("_position" pid1))))
###         ("_applC" ("_position" Predicational) ("_position" pid3)))
###       ("\<^const>Syntax.Equiv"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" EvolveODE)
###             ("_cargs" ("_applC" ("_position" OVar) ("_position" vid1))
###               ("_applC" ("_position" Predicational) ("_position" pid1))))
###           ("_applC" ("_position" Predicational) ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" EvolveODE)
###             ("_cargs" ("_applC" ("_position" OVar) ("_position" vid1))
###               ("_applC" ("_position" And)
###                 ("_cargs"
###                   ("_applC" ("_position" Predicational) ("_position" pid1))
###                   ("_applC" ("_position" Predicational)
###                     ("_position" pid3))))))
###           ("_applC" ("_position" Predicational) ("_position" pid2)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Uniform_Renaming"
### 1.029s elapsed time, 3.956s cpu time, 0.397s GC time
### theory "Draft.Differential_Axioms"
### 1.134s elapsed time, 4.327s cpu time, 0.432s GC time
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
Found termination order:
  "case_sum (%p. size (fst p)) (%p. size (fst p)) <*mlex*> {}"
Found termination order: "{}"
Proofs for inductive predicate(s) "Tadmit"
  Proving monotonicity ...
Proofs for inductive predicate(s) "TadmitF"
  Proving monotonicity ...
Proofs for inductive predicate(s) "Oadmit"
  Proving monotonicity ...
Proofs for inductive predicate(s) "OadmitFO"
  Proving monotonicity ...
Proofs for inductive predicate(s) "NPadmit", "NFadmit"
  Proving monotonicity ...
Proofs for inductive predicate(s) "PPadmit", "PFadmit"
  Proving monotonicity ...
Proofs for inductive predicate(s) "Padmit", "Fadmit"
  Proving monotonicity ...
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "case_sum size size <*mlex*> {}"
Found termination order: "{}"
Found termination order: "{}"
### theory "Draft.USubst"
### 9.850s elapsed time, 28.519s cpu time, 13.418s GC time
Loading theory "Draft.USubst_Lemma" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
### theory "Draft.Pretty_Printer"
### 15.690s elapsed time, 41.717s cpu time, 14.759s GC time
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
consts
  extendf_deriv ::
    "('sf, 'sc, 'sz) interp
     => 'sf
        => ('sf + 'sz, 'sz) trm
           => (real, 'sz) vec * (real, 'sz) vec
              => (real, 'sz) vec => (real, 'sz) vec => real"
### Ambiguous input (line 1021 of "$AFP/Differential_Dynamic_Logic/USubst_Lemma.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" e) ("_idts" ("_position" \<sigma>) ("_position" x)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.subset_eq"
###       ("_UNION" ("_position" i)
###         ("_applC" ("_position" SIGT) ("_position" e))
###         ("_case_syntax"
###           ("_applC" ("_position" SFunctions)
###             ("_cargs" ("_position" \<sigma>) ("_position" i)))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" x))
###               ("_applC" ("_position" FVT) ("_position" x)))
###             ("_case1" ("_position" None) ("\<^const>Set.empty")))))
###       ("_UNION" ("_position" a)
###         ("\<^const>Set.inter"
###           ("_applC" ("_position" SDom) ("_position" \<sigma>))
###           ("_applC" ("_position" SIGP)
###             ("\<^const>Syntax.hp.Assign" ("_position" x) ("_position" e))))
###         ("_applC" ("_position" SFV)
###           ("_cargs" ("_position" \<sigma>) ("_position" a)))))))
### ("\<^const>Pure.all_binder"
###   ("_idts" ("_position" e) ("_idts" ("_position" \<sigma>) ("_position" x)))
###   ("\<^const>HOL.Trueprop"
###     ("\<^const>Set.subset_eq"
###       ("_UNION" ("_position" i)
###         ("_applC" ("_position" SIGT) ("_position" e))
###         ("_case_syntax"
###           ("_applC" ("_position" SFunctions)
###             ("_cargs" ("_position" \<sigma>) ("_position" i)))
###           ("_case2"
###             ("_case1" ("_applC" ("_position" Some) ("_position" x))
###               ("_applC" ("_position" FVT) ("_position" x)))
###             ("_case1" ("_position" None) ("\<^const>Set.empty")))))
###       ("_UNION" ("_position" a)
###         ("\<^const>Set.inter"
###           ("_applC" ("_position" SDom) ("_position" \<sigma>))
###           ("_Update" ("_position" SIGP)
###             ("_updbind" ("_position" x) ("_position" e))))
###         ("_applC" ("_position" SFV)
###           ("_cargs" ("_position" \<sigma>) ("_position" a)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.USubst_Lemma"
### 1.892s elapsed time, 2.049s cpu time, 0.226s GC time
Loading theory "Draft.Proof_Checker" (required by "Draft.Differential_Dynamic_LogicMoreTemplates" via "Draft.Differential_Dynamic_Logic")
locale ids
  fixes vid1 :: "'sz"
    and vid2 :: "'sz"
    and vid3 :: "'sz"
    and fid1 :: "'sf"
    and fid2 :: "'sf"
    and fid3 :: "'sf"
    and pid1 :: "'sc"
    and pid2 :: "'sc"
    and pid3 :: "'sc"
    and pid4 :: "'sc"
  assumes "ids vid1 vid2 vid3 fid1 fid2 fid3 pid1 pid2 pid3 pid4"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "{}"
Found termination order:
  "(%p. size_list (%p. size (snd p)) (snd p)) <*mlex*> {}"
Found termination order: "{}"
### Ambiguous input (line 306 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" p) ("_position" q))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" nth)
###           ("_cargs"
###             ("_applC" ("_position" fst)
###               ("_applC" ("_position" nth)
###                 ("_cargs" ("_position" SG) ("_position" i))))
###             ("_position" j)))
###         ("\<^const>Syntax.Implies" ("_position" p) ("_position" q))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" lrule_ok)
###         ("_cargs" ("_position" SG)
###           ("_cargs" ("_position" C)
###             ("_cargs" ("_position" i)
###               ("_cargs" ("_position" j) ("_position" ImplyL)))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" p) ("_position" q))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" nth)
###           ("_cargs"
###             ("_applC" ("_position" fst)
###               ("_applC" ("_position" nth)
###                 ("_cargs" ("_position" SG) ("_position" i))))
###             ("_position" j)))
###         ("\<^const>FuncSet.funcset" ("_position" p) ("_position" q))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" lrule_ok)
###         ("_cargs" ("_position" SG)
###           ("_cargs" ("_position" C)
###             ("_cargs" ("_position" i)
###               ("_cargs" ("_position" j) ("_position" ImplyL)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "lrule_ok"
  Proving monotonicity ...
### Ambiguous input (line 322 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 2 parse trees:
### ("\<^const>Pure.all_binder" ("_idts" ("_position" p) ("_position" q))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" nth)
###           ("_cargs"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" nth)
###                 ("_cargs" ("_position" SG) ("_position" i))))
###             ("_position" j)))
###         ("\<^const>Syntax.Implies" ("_position" p) ("_position" q))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rrule_ok)
###         ("_cargs" ("_position" SG)
###           ("_cargs" ("_position" C)
###             ("_cargs" ("_position" i)
###               ("_cargs" ("_position" j) ("_position" ImplyR)))))))))
### ("\<^const>Pure.all_binder" ("_idts" ("_position" p) ("_position" q))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>HOL.eq"
###         ("_applC" ("_position" nth)
###           ("_cargs"
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" nth)
###                 ("_cargs" ("_position" SG) ("_position" i))))
###             ("_position" j)))
###         ("\<^const>FuncSet.funcset" ("_position" p) ("_position" q))))
###     ("\<^const>HOL.Trueprop"
###       ("_applC" ("_position" rrule_ok)
###         ("_cargs" ("_position" SG)
###           ("_cargs" ("_position" C)
###             ("_cargs" ("_position" i)
###               ("_cargs" ("_position" j) ("_position" ImplyR)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Proofs for inductive predicate(s) "rrule_ok"
  Proving monotonicity ...
Proofs for inductive predicate(s) "step_ok"
  Proving monotonicity ...
Proofs for inductive predicate(s) "deriv_ok"
  Proving monotonicity ...
Proofs for inductive predicate(s) "proof_ok"
  Proving monotonicity ...
### Ambiguous input (line 454 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lrule_ok)
###       ("_cargs" ("_position" SG)
###         ("_cargs" ("_position" C)
###           ("_cargs" ("_position" i)
###             ("_cargs" ("_position" j) ("_position" L)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" i)
###         ("_applC" ("_position" length) ("_position" SG))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_applC" ("_position" length)
###             ("_applC" ("_position" fst)
###               ("\<^const>List.nth" ("_position" SG) ("_position" i))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" sound)
###             ("_tuple" ("_position" SG) ("_tuple_arg" ("_position" C)))))
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" sound)
###             ("_tuple"
###               ("_applC" ("_position" close)
###                 ("_cargs"
###                   ("_applC" ("_position" append)
###                     ("_cargs" ("_position" SG)
###                       ("_applC" ("_position" Lrule_result)
###                         ("_cargs" ("_position" L)
###                           ("_cargs" ("_position" j)
###                             ("_applC" ("_position" nth)
###                               ("_cargs" ("_position" SG)
###                                 ("_position" i))))))))
###                   ("_applC" ("_position" nth)
###                     ("_cargs" ("_position" SG) ("_position" i)))))
###               ("_tuple_arg" ("_position" C)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" lrule_ok)
###       ("_cargs" ("_position" SG)
###         ("_cargs" ("_position" C)
###           ("_cargs" ("_position" i)
###             ("_cargs" ("_position" j) ("_position" L)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" i)
###         ("_applC" ("_position" length) ("_position" SG))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_applC" ("_position" length)
###             ("_applC" ("_position" fst)
###               ("_applC" ("_position" SG)
###                 ("_cargs" ("\<^const>Syntax.formula.Not")
###                   ("_position" i)))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" sound)
###             ("_tuple" ("_position" SG) ("_tuple_arg" ("_position" C)))))
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" sound)
###             ("_tuple"
###               ("_applC" ("_position" close)
###                 ("_cargs"
###                   ("_applC" ("_position" append)
###                     ("_cargs" ("_position" SG)
###                       ("_applC" ("_position" Lrule_result)
###                         ("_cargs" ("_position" L)
###                           ("_cargs" ("_position" j)
###                             ("_applC" ("_position" nth)
###                               ("_cargs" ("_position" SG)
###                                 ("_position" i))))))))
###                   ("_applC" ("_position" nth)
###                     ("_cargs" ("_position" SG) ("_position" i)))))
###               ("_tuple_arg" ("_position" C)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 820 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 2 parse trees:
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" rrule_ok)
###       ("_cargs" ("_position" SG)
###         ("_cargs" ("_position" C)
###           ("_cargs" ("_position" i)
###             ("_cargs" ("_position" j) ("_position" L)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" i)
###         ("_applC" ("_position" length) ("_position" SG))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_applC" ("_position" length)
###             ("_applC" ("_position" snd)
###               ("\<^const>List.nth" ("_position" SG) ("_position" i))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" sound)
###             ("_tuple" ("_position" SG) ("_tuple_arg" ("_position" C)))))
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" sound)
###             ("_tuple"
###               ("_applC" ("_position" close)
###                 ("_cargs"
###                   ("_applC" ("_position" append)
###                     ("_cargs" ("_position" SG)
###                       ("_applC" ("_position" Rrule_result)
###                         ("_cargs" ("_position" L)
###                           ("_cargs" ("_position" j)
###                             ("_applC" ("_position" nth)
###                               ("_cargs" ("_position" SG)
###                                 ("_position" i))))))))
###                   ("_applC" ("_position" nth)
###                     ("_cargs" ("_position" SG) ("_position" i)))))
###               ("_tuple_arg" ("_position" C)))))))))
### ("\<^const>Pure.imp"
###   ("\<^const>HOL.Trueprop"
###     ("_applC" ("_position" rrule_ok)
###       ("_cargs" ("_position" SG)
###         ("_cargs" ("_position" C)
###           ("_cargs" ("_position" i)
###             ("_cargs" ("_position" j) ("_position" L)))))))
###   ("\<^const>Pure.imp"
###     ("\<^const>HOL.Trueprop"
###       ("\<^const>Orderings.ord_class.less" ("_position" i)
###         ("_applC" ("_position" length) ("_position" SG))))
###     ("\<^const>Pure.imp"
###       ("\<^const>HOL.Trueprop"
###         ("\<^const>Orderings.ord_class.less" ("_position" j)
###           ("_applC" ("_position" length)
###             ("_applC" ("_position" snd)
###               ("_applC" ("_position" SG)
###                 ("_cargs" ("\<^const>Syntax.formula.Not")
###                   ("_position" i)))))))
###       ("\<^const>Pure.imp"
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" sound)
###             ("_tuple" ("_position" SG) ("_tuple_arg" ("_position" C)))))
###         ("\<^const>HOL.Trueprop"
###           ("_applC" ("_position" sound)
###             ("_tuple"
###               ("_applC" ("_position" close)
###                 ("_cargs"
###                   ("_applC" ("_position" append)
###                     ("_cargs" ("_position" SG)
###                       ("_applC" ("_position" Rrule_result)
###                         ("_cargs" ("_position" L)
###                           ("_cargs" ("_position" j)
###                             ("_applC" ("_position" nth)
###                               ("_cargs" ("_position" SG)
###                                 ("_position" i))))))))
###                   ("_applC" ("_position" nth)
###                     ("_cargs" ("_position" SG) ("_position" i)))))
###               ("_tuple_arg" ("_position" C)))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1455 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("\<^const>FuncSet.funcset"
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("_position" Predicational) ("_position" pid3))
###                 ("_applC" ("_position" Predicational) ("_position" pid4))))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("_position" Predicational) ("_position" pid1))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid2))))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4))))))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" And)
###           ("_cargs"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("_applC" ("_position" Predicational) ("_position" pid2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4))))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational) ("_position" pid2))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4)))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational)
###                 ("_position" pid2)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4))))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational) ("_position" pid2))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4)))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational)
###                 ("_position" pid2)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4))))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational) ("_position" pid2))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4)))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational)
###                 ("_position" pid2)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4))))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational) ("_position" pid2))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4)))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational)
###                 ("_position" pid2)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4))))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational) ("_position" pid2))))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4)))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational)
###                 ("_position" pid2)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4))))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational) ("_position" pid2))))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4)))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid1))
###               ("_applC" ("_position" Predicational)
###                 ("_position" pid2)))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("_position" Predicational) ("_position" pid3))
###                 ("_applC" ("_position" Predicational) ("_position" pid4))))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("_position" Predicational) ("_position" pid1))
###                 ("_applC" ("_position" Predicational)
###                   ("_position" pid2))))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###           ("_applC" ("_position" And)
###             ("_cargs"
###               ("_applC" ("_position" Predicational) ("_position" pid3))
###               ("_applC" ("_position" Predicational) ("_position" pid4))))))
###       ("\<^const>Syntax.Box"
###         ("_applC" ("\<^const>Syntax.hp.Pvar") ("_position" vid1))
###         ("_applC" ("_position" And)
###           ("_cargs"
###             ("_applC" ("_position" Predicational) ("_position" pid1))
###             ("_applC" ("_position" Predicational) ("_position" pid2))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1502 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCurry12)
###     ("_record"
###       ("_fields"
###         ("_field" ("_constify" SFunctions)
###           ("_lambda" ("_idtdummy") ("_position" None)))
###         ("_fields"
###           ("_field" ("_constify" SPredicates)
###             ("_lambda" ("_idtdummy") ("_position" None)))
###           ("_fields"
###             ("_field" ("_constify" SContexts)
###               ("_lambda" ("_position" C)
###                 ("\<^const>HOL.If"
###                   ("\<^const>HOL.eq" ("_position" C) ("_position" pid1))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" Predicational)
###                       ("_applC" ("_position" Inl) ("_position" pid1))))
###                   ("\<^const>HOL.If"
###                     ("\<^const>HOL.eq" ("_position" C) ("_position" pid2))
###                     ("_applC" ("_position" Some)
###                       ("\<^const>Syntax.Implies"
###                         ("_applC" ("_position" Predicational)
###                           ("_applC" ("_position" Inl) ("_position" pid2)))
###                         ("\<^const>Syntax.formula.And"
###                           ("_applC" ("_position" Predicational)
###                             ("_applC" ("_position" Inl) ("_position" pid1)))
###                           ("_applC" ("_position" Predicational)
###                             ("_applC" ("_position" Inl)
###                               ("_position" pid2))))))
###                     ("_position" None)))))
###             ("_fields"
###               ("_field" ("_constify" SPrograms)
###                 ("_lambda" ("_idtdummy") ("_position" None)))
###               ("_field" ("_constify" SODEs)
###                 ("_lambda" ("_idtdummy") ("_position" None))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCurry12)
###     ("_record"
###       ("_fields"
###         ("_field" ("_constify" SFunctions)
###           ("_lambda" ("_idtdummy") ("_position" None)))
###         ("_fields"
###           ("_field" ("_constify" SPredicates)
###             ("_lambda" ("_idtdummy") ("_position" None)))
###           ("_fields"
###             ("_field" ("_constify" SContexts)
###               ("_lambda" ("_position" C)
###                 ("\<^const>HOL.If"
###                   ("\<^const>HOL.eq" ("_position" C) ("_position" pid1))
###                   ("_applC" ("_position" Some)
###                     ("_applC" ("_position" Predicational)
###                       ("_applC" ("_position" Inl) ("_position" pid1))))
###                   ("\<^const>HOL.If"
###                     ("\<^const>HOL.eq" ("_position" C) ("_position" pid2))
###                     ("_applC" ("_position" Some)
###                       ("\<^const>FuncSet.funcset"
###                         ("_applC" ("_position" Predicational)
###                           ("_applC" ("_position" Inl) ("_position" pid2)))
###                         ("\<^const>Syntax.formula.And"
###                           ("_applC" ("_position" Predicational)
###                             ("_applC" ("_position" Inl) ("_position" pid1)))
###                           ("_applC" ("_position" Predicational)
###                             ("_applC" ("_position" Inl)
###                               ("_position" pid2))))))
###                     ("_position" None)))))
###             ("_fields"
###               ("_field" ("_constify" SPrograms)
###                 ("_lambda" ("_idtdummy") ("_position" None)))
###               ("_field" ("_constify" SODEs)
###                 ("_lambda" ("_idtdummy") ("_position" None))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1523 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 32 parse trees (10 displayed):
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>FuncSet.funcset"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>FuncSet.funcset"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>FuncSet.funcset"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>FuncSet.funcset"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>FuncSet.funcset"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCutP12)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###           ("\<^const>FuncSet.funcset"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2)))))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.Implies"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###             ("_applC" ("_position" And)
###               ("_cargs"
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid1))
###                 ("_applC" ("\<^const>Syntax.Predicational")
###                   ("_position" pid2))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1527 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim1)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim1)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim1)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim1)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim1)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim1)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim1)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid3)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim1)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid3)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1531 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim2)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid4)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim2)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid4)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim2)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid4)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim2)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid4)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim2)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid4)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim2)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid4)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim2)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid4)))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut34Elim2)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4)))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid4))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid3))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid4))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational")
###             ("_position" pid4)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### Ambiguous input (line 1535 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 8 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut12Intro)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2)))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut12Intro)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2)))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut12Intro)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2)))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut12Intro)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2)))))
###       ("\<^const>FuncSet.funcset"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut12Intro)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2)))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut12Intro)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>FuncSet.funcset"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2)))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut12Intro)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2)))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" DIAndCut12Intro)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" Pvar) ("_position" vid1))
###         ("\<^const>Syntax.Implies"
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2)))))
###       ("\<^const>Syntax.Implies"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid2)))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" Pvar) ("_position" vid1))
###           ("\<^const>Syntax.formula.And"
###             ("_applC" ("\<^const>Syntax.Predicational") ("_position" pid1))
###             ("_applC" ("\<^const>Syntax.Predicational")
###               ("_position" pid2))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
Found termination order: "{}"
Found termination order: "{}"
### Ambiguous input (line 1645 of "$AFP/Differential_Dynamic_Logic/Proof_Checker.thy") produces 2 parse trees:
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" SystemDCCut)
###     ("\<^const>Syntax.Implies"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" EvolveODE)
###           ("_cargs"
###             ("_applC" ("_position" OProd)
###               ("_cargs"
###                 ("_applC" ("_position" OSing)
###                   ("_cargs" ("_position" vid1)
###                     ("_applC" ("_position" f0) ("_position" fid1))))
###                 ("_applC" ("_position" OSing)
###                   ("_cargs" ("_position" vid2)
###                     ("_applC" ("_position" Var) ("_position" vid1))))))
###             ("_position" TT)))
###         ("_applC" ("_position" Geq)
###           ("_cargs" ("_applC" ("_position" f0) ("_position" fid1))
###             ("_applC" ("_position" Const)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("\<^const>Syntax.Equiv"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" EvolveODE)
###             ("_cargs"
###               ("_applC" ("_position" OProd)
###                 ("_cargs"
###                   ("_applC" ("_position" OSing)
###                     ("_cargs" ("_position" vid1)
###                       ("_applC" ("_position" f0) ("_position" fid1))))
###                   ("_applC" ("_position" OSing)
###                     ("_cargs" ("_position" vid2)
###                       ("_applC" ("_position" Var) ("_position" vid1))))))
###               ("_position" TT)))
###           ("_applC" ("_position" Geq)
###             ("_cargs"
###               ("_applC" ("_position" Differential)
###                 ("_applC" ("_position" Var) ("_position" vid1)))
###               ("_applC" ("_position" Differential)
###                 ("_applC" ("_position" Const)
###                   ("\<^const>Groups.zero_class.zero"))))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" EvolveODE)
###             ("_cargs"
###               ("_applC" ("_position" OProd)
###                 ("_cargs"
###                   ("_applC" ("_position" OSing)
###                     ("_cargs" ("_position" vid1)
###                       ("_applC" ("_position" f0) ("_position" fid1))))
###                   ("_applC" ("_position" OSing)
###                     ("_cargs" ("_position" vid2)
###                       ("_applC" ("_position" Var) ("_position" vid1))))))
###               ("_applC" ("_position" And)
###                 ("_cargs" ("_position" TT)
###                   ("_applC" ("_position" Geq)
###                     ("_cargs" ("_applC" ("_position" f0) ("_position" fid1))
###                       ("_applC" ("_position" Const)
###                         ("\<^const>Groups.zero_class.zero"))))))))
###           ("_applC" ("_position" Geq)
###             ("_cargs"
###               ("_applC" ("_position" Differential)
###                 ("_applC" ("_position" Var) ("_position" vid1)))
###               ("_applC" ("_position" Differential)
###                 ("_applC" ("_position" Const)
###                   ("\<^const>Groups.zero_class.zero"))))))))))
### ("\<^const>HOL.Trueprop"
###   ("\<^const>HOL.eq" ("_position" SystemDCCut)
###     ("\<^const>FuncSet.funcset"
###       ("\<^const>Syntax.Box"
###         ("_applC" ("_position" EvolveODE)
###           ("_cargs"
###             ("_applC" ("_position" OProd)
###               ("_cargs"
###                 ("_applC" ("_position" OSing)
###                   ("_cargs" ("_position" vid1)
###                     ("_applC" ("_position" f0) ("_position" fid1))))
###                 ("_applC" ("_position" OSing)
###                   ("_cargs" ("_position" vid2)
###                     ("_applC" ("_position" Var) ("_position" vid1))))))
###             ("_position" TT)))
###         ("_applC" ("_position" Geq)
###           ("_cargs" ("_applC" ("_position" f0) ("_position" fid1))
###             ("_applC" ("_position" Const)
###               ("\<^const>Groups.zero_class.zero")))))
###       ("\<^const>Syntax.Equiv"
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" EvolveODE)
###             ("_cargs"
###               ("_applC" ("_position" OProd)
###                 ("_cargs"
###                   ("_applC" ("_position" OSing)
###                     ("_cargs" ("_position" vid1)
###                       ("_applC" ("_position" f0) ("_position" fid1))))
###                   ("_applC" ("_position" OSing)
###                     ("_cargs" ("_position" vid2)
###                       ("_applC" ("_position" Var) ("_position" vid1))))))
###               ("_position" TT)))
###           ("_applC" ("_position" Geq)
###             ("_cargs"
###               ("_applC" ("_position" Differential)
###                 ("_applC" ("_position" Var) ("_position" vid1)))
###               ("_applC" ("_position" Differential)
###                 ("_applC" ("_position" Const)
###                   ("\<^const>Groups.zero_class.zero"))))))
###         ("\<^const>Syntax.Box"
###           ("_applC" ("_position" EvolveODE)
###             ("_cargs"
###               ("_applC" ("_position" OProd)
###                 ("_cargs"
###                   ("_applC" ("_position" OSing)
###                     ("_cargs" ("_position" vid1)
###                       ("_applC" ("_position" f0) ("_position" fid1))))
###                   ("_applC" ("_position" OSing)
###                     ("_cargs" ("_position" vid2)
###                       ("_applC" ("_position" Var) ("_position" vid1))))))
###               ("_applC" ("_position" And)
###                 ("_cargs" ("_position" TT)
###                   ("_applC" ("_position" Geq)
###                     ("_cargs" ("_applC" ("_position" f0) ("_position" fid1))
###                       ("_applC" ("_position" Const)
###                         ("\<^const>Groups.zero_class.zero"))))))))
###           ("_applC" ("_position" Geq)
###             ("_cargs"
###               ("_applC" ("_position" Differential)
###                 ("_applC" ("_position" Var) ("_position" vid1)))
###               ("_applC" ("_position" Differential)
###                 ("_applC" ("_position" Const)
###                   ("\<^const>Groups.zero_class.zero"))))))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "Draft.Proof_Checker"
### 17.012s elapsed time, 26.979s cpu time, 12.983s GC time
Loading theory "Draft.Differential_Dynamic_Logic" (required by "Draft.Differential_Dynamic_LogicMoreTemplates")
### theory "Draft.Differential_Dynamic_Logic"
### 0.052s elapsed time, 0.102s cpu time, 0.000s GC time
Loading theory "Draft.Differential_Dynamic_LogicMoreTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.Differential_Dynamic_LogicMoreTemplates"
### 1.899s elapsed time, 2.466s cpu time, 0.325s GC time
val it = (): unit
