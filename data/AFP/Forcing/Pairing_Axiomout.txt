Loading theory "Draft.Recursion_Thms" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names" via "Draft.Forcing_Data" via "Draft.Interface" via "Draft.Relative_Univ")
Loading theory "Draft.Nat_Miscellanea" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names" via "Draft.Forcing_Data" via "Draft.Interface")
Loading theory "Draft.Utils" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names" via "Draft.Forcing_Data" via "Draft.Interface" via "Draft.Synthetic_Definition")
Loading theory "Draft.Forcing_Notions" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names" via "Draft.Forcing_Data")
locale forcing_notion
  fixes P :: "i"
    and leq :: "i"
    and one :: "i"
  assumes "forcing_notion(P, leq, one)"
signature UTILS =
  sig
    val add_: term -> term -> term
    val app_: term -> term -> term
    val concat_: term -> term -> term
    val dest_apply: term -> term * term
    val dest_eq_tms: term -> term * term
    val dest_iff_lhs: term -> term
    val dest_iff_rhs: term -> term
    val dest_iff_tms: term -> term * term
    val dest_lhs_def: term -> term
    val dest_rhs_def: term -> term
    val dest_satisfies_frm: term -> term
    val dest_satisfies_tms: term -> term * term
    val dest_sats_frm: term -> (term * term) * term
    val dest_trueprop: term -> term
    val eq_: term -> term -> term
    val fix_vars: thm -> string list -> Proof.context -> thm
    val formula_: term
    val freeName: term -> string
    val isFree: term -> bool
    val length_: term -> term
    val list_: term -> term
    val lt_: term -> term -> term
    val mem_: term -> term -> term
    val mk_FinSet: term list -> term
    val mk_Pair: term -> term -> term
    val mk_ZFlist: ('a -> term) -> 'a list -> term
    val mk_ZFnat: int -> term
    val nat_: term
    val nth_: term -> term -> term
    val subset_: term -> term -> term
    val thm_concl_tm:
       Proof.context -> xstring -> cterm Vars.table * term * Proof.context
    val to_ML_list: term -> term list
    val tp: term -> term
  end
structure Utils: UTILS
### theory "Draft.Utils"
### 0.040s elapsed time, 0.148s cpu time, 0.018s GC time
Loading theory "Draft.Synthetic_Definition" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names" via "Draft.Forcing_Data" via "Draft.Interface")
### theory "Draft.Recursion_Thms"
### 0.052s elapsed time, 0.197s cpu time, 0.018s GC time
Loading theory "Draft.Internalizations" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names" via "Draft.Forcing_Data" via "Draft.Interface" via "Draft.Relative_Univ")
### theory "Draft.Internalizations"
### 0.015s elapsed time, 0.057s cpu time, 0.000s GC time
Loading theory "Draft.Relative_Univ" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names" via "Draft.Forcing_Data" via "Draft.Interface")
infix 0 $`
val $` = fn: term -> term -> term
val pair = fn: ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b * 'c
val display = fn:
   string ->
     Position.T -> (string * thm list) * Proof.context -> Proof.context
val prove_tc_form = fn: term -> thm list -> Proof.context -> thm
val prove_sats = fn: term -> thm list -> thm list -> Proof.context -> thm
val is_mem = fn: term -> bool
val synth_thm_sats = fn:
   string ->
     xstring ->
       term ->
         term ->
           term ->
             term list ->
               ('a * cterm) list ->
                 ('b * cterm) list ->
                   Position.T -> thm list -> Proof.context -> Proof.context
val synth_thm_tc = fn:
   string ->
     xstring ->
       term list ->
         ('a * cterm) list -> Position.T -> Proof.context -> Proof.context
val synthetic_def = fn:
   bstring ->
     Facts.ref * 'a ->
       Position.T -> bool -> bool -> Proof.context -> Proof.context
### theory "Draft.Synthetic_Definition"
### 0.061s elapsed time, 0.249s cpu time, 0.000s GC time
Loading theory "Tools.Code_Generator" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Typedef" via "HOL.Set" via "HOL.Lattices" via "HOL.Groups" via "HOL.Orderings" via "HOL.HOL")
### theory "Draft.Nat_Miscellanea"
### 0.107s elapsed time, 0.416s cpu time, 0.018s GC time
signature CACHE_IO =
  sig
    type cache
    val cache_path_of: cache -> Path.T
    val lookup: cache -> string -> result option * string
    val raw_run:
       (Path.T -> Path.T -> string) -> string -> Path.T -> Path.T -> result
    type result =
       {output: string list,
        redirected_output: string list, return_code: int}
    val run: (Path.T -> Path.T -> string) -> string -> result
    val run_and_cache:
       cache -> string -> (Path.T -> Path.T -> string) -> string -> result
    val run_cached:
       cache -> (Path.T -> Path.T -> string) -> string -> result
    val unsynchronized_init: Path.T -> cache
  end
structure Cache_IO: CACHE_IO
locale countable_generic
  fixes P :: "i"
    and leq :: "i"
    and one :: "i"
    and \<D> :: "i"
  assumes "countable_generic(P, leq, one, \<D>)"
### Cannot skip proof of schematic goal statement
locale countable_generic
  fixes P :: "i"
    and leq :: "i"
    and one :: "i"
    and \<D> :: "i"
  assumes "countable_generic(P, leq, one, \<D>)"
### Cannot skip proof of schematic goal statement
### theory "Draft.Forcing_Notions"
### 0.188s elapsed time, 0.666s cpu time, 0.071s GC time
locale M_eclose_pow
  fixes M :: "i => o"
  assumes "M_eclose_pow(M)"
### theory "Draft.Relative_Univ"
### 0.234s elapsed time, 0.636s cpu time, 0.053s GC time
Loading theory "Draft.Interface" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names" via "Draft.Forcing_Data")
### ML warning (line 380 of "~~/src/Tools/Code/code_preproc.ML"):
### Matches are not exhaustive.
### ML warning (line 489 of "~~/src/Tools/Code/code_preproc.ML"):
### Value identifier (c_k) has not been referenced.
### ML warning (line 489 of "~~/src/Tools/Code/code_preproc.ML"):
### Value identifier (eqngr) has not been referenced.
### ML warning (line 489 of "~~/src/Tools/Code/code_preproc.ML"):
### Value identifier (arities) has not been referenced.
### ML warning (line 489 of "~~/src/Tools/Code/code_preproc.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 521 of "~~/src/Tools/Code/code_preproc.ML"):
### Matches are not exhaustive.
signature CODE_PREPROC =
  sig
    val add_functrans:
       string *
       (Proof.context -> (thm * bool) list -> (thm * bool) list option)
         -> theory -> theory
    val all: code_graph -> string list
    val cert: code_graph -> string -> Code.cert
    type code_algebra
    type code_graph
    val del_functrans: string -> theory -> theory
    val dynamic_conv:
       Proof.context -> (code_algebra -> code_graph -> term -> conv) -> conv
    val dynamic_value:
       Proof.context ->
         ((term -> term) -> 'a -> 'b) ->
           (code_algebra -> code_graph -> term -> 'a) -> term -> 'b
    val map_post: (Proof.context -> Proof.context) -> theory -> theory
    val map_pre: (Proof.context -> Proof.context) -> theory -> theory
    val obtain:
       bool ->
         {consts: string list, ctxt: Proof.context, terms: term list} ->
           {algebra: code_algebra, eqngr: code_graph}
    val pretty: Proof.context -> code_graph -> Pretty.T
    val print_codeproc: Proof.context -> unit
    val simple_functrans:
       (Proof.context -> thm list -> thm list option) ->
         Proof.context -> (thm * bool) list -> (thm * bool) list option
    val sortargs: code_graph -> string -> sort list
    val static_conv:
       {consts: string list, ctxt: Proof.context} ->
         ({algebra: code_algebra, eqngr: code_graph} ->
            Proof.context -> term -> conv)
           -> Proof.context -> conv
    val static_value:
       {consts: string list,
        ctxt: Proof.context, lift_postproc: (term -> term) -> 'a -> 'b}
         ->
         ({algebra: code_algebra, eqngr: code_graph} ->
            Proof.context -> term -> 'a)
           -> Proof.context -> term -> 'b
    val timed: string -> ('a -> Proof.context) -> ('a -> 'b) -> 'a -> 'b
    val timed_conv:
       string -> (Proof.context -> conv) -> Proof.context -> conv
    val timed_exec: string -> (unit -> 'a) -> Proof.context -> 'a
    val timed_value:
       string ->
         (Proof.context -> term -> 'a) -> Proof.context -> term -> 'a
    val timing: bool Config.T
    val trace_all: Context.generic -> Context.generic
    val trace_none: Context.generic -> Context.generic
    val trace_only: string list -> Context.generic -> Context.generic
    val trace_only_ext: string list -> Context.generic -> Context.generic
  end
structure Code_Preproc: CODE_PREPROC
locale M_basic
  fixes M :: "i => o"
  assumes "M_basic(M)"
locale M_ZF_trans
  fixes M :: "i"
  assumes "M_ZF_trans(M)"
locale M_ZF_trans
  fixes M :: "i"
  assumes "M_ZF_trans(M)"
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### ML warning (line 90 of "~~/src/Tools/Code/code_symbol.ML"):
### Matches are not exhaustive.
### ML warning (line 110 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 110 of "~~/src/Tools/Code/code_symbol.ML"):
### Matches are not exhaustive.
### ML warning (line 126 of "~~/src/Tools/Code/code_symbol.ML"):
### Matches are not exhaustive.
### ML warning (line 139 of "~~/src/Tools/Code/code_symbol.ML"):
### Matches are not exhaustive.
### ML warning (line 150 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 150 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 150 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 150 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 150 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 149 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 149 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 149 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 149 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 149 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 148 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 148 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 148 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 148 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 148 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 147 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 147 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 147 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 147 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 147 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 146 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 146 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 146 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 146 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 146 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 145 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 145 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 145 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 145 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 145 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 157 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 157 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 157 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 157 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 157 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 156 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 156 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 156 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 156 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 156 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 155 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 155 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 155 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 155 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 155 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 154 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 154 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 154 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 154 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 154 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 153 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 153 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 153 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 153 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 153 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 152 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 152 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 152 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 152 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 152 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 164 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 164 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 164 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 164 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 164 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 163 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 163 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 163 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 163 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 163 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 162 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 162 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 162 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 162 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 162 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 161 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 161 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 161 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 161 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
### ML warning (line 161 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 160 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 160 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 160 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 160 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 160 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 159 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (module) has not been referenced.
### ML warning (line 159 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (inst) has not been referenced.
### ML warning (line 159 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (classrel) has not been referenced.
### ML warning (line 159 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (class) has not been referenced.
### ML warning (line 159 of "~~/src/Tools/Code/code_symbol.ML"):
### Value identifier (tyco) has not been referenced.
signature BASIC_CODE_SYMBOL =
  sig
    datatype ('a, 'b, 'c, 'd, 'e, 'f) attr
    =
         Class_Instance of 'e
       | Class_Relation of 'd
       | Constant of 'a
       | Module of 'f
       | Type_Class of 'c
       | Type_Constructor of 'b
  end
signature CODE_SYMBOL =
  sig
    structure Graph: GRAPH
    type T =
       (string, string, class, class * class, string * class, string) attr
    structure Table: TABLE
    datatype ('a, 'b, 'c, 'd, 'e, 'f) attr
    =
         Class_Instance of 'e
       | Class_Relation of 'd
       | Constant of 'a
       | Module of 'f
       | Type_Class of 'c
       | Type_Constructor of 'b
    type ('a, 'b, 'c, 'd, 'e, 'f) data
    val default_base: T -> string
    val default_prefix: Proof.context -> T -> string
    val dest_module_data:
       ('a, 'b, 'c, 'd, 'e, 'f) data -> (string * 'f) list
    val empty_data: ('a, 'b, 'c, 'd, 'e, 'f) data
    val is_value: T -> bool
    val lookup: ('a, 'a, 'a, 'a, 'a, 'a) data -> T -> 'a option
    val lookup_class_instance_data:
       ('a, 'b, 'c, 'd, 'e, 'f) data -> string * class -> 'e option
    val lookup_class_relation_data:
       ('a, 'b, 'c, 'd, 'e, 'f) data -> class * class -> 'd option
    val lookup_constant_data:
       ('a, 'b, 'c, 'd, 'e, 'f) data -> string -> 'a option
    val lookup_module_data:
       ('a, 'b, 'c, 'd, 'e, 'f) data -> string -> 'f option
    val lookup_type_class_data:
       ('a, 'b, 'c, 'd, 'e, 'f) data -> class -> 'c option
    val lookup_type_constructor_data:
       ('a, 'b, 'c, 'd, 'e, 'f) data -> string -> 'b option
    val map_attr:
       ('a -> 'b) ->
         ('c -> 'd) ->
           ('e -> 'f) ->
             ('g -> 'h) ->
               ('i -> 'j) ->
                 ('k -> 'l) ->
                   ('a, 'c, 'e, 'g, 'i, 'k) attr ->
                     ('b, 'd, 'f, 'h, 'j, 'l) attr
    val maps_attr:
       ('a -> 'b list) ->
         ('c -> 'd list) ->
           ('e -> 'f list) ->
             ('g -> 'h list) ->
               ('i -> 'j list) ->
                 ('k -> 'l list) ->
                   ('a, 'c, 'e, 'g, 'i, 'k) attr ->
                     ('b, 'd, 'f, 'h, 'j, 'l) attr list
    val maps_attr':
       ('a -> ('b * 'c) list) ->
         ('d -> ('b * 'e) list) ->
           ('f -> ('b * 'g) list) ->
             ('h -> ('b * 'i) list) ->
               ('j -> ('b * 'k) list) ->
                 ('l -> ('b * 'm) list) ->
                   ('a, 'd, 'f, 'h, 'j, 'l) attr ->
                     ('b * ('c, 'e, 'g, 'i, 'k, 'm) attr) list
    val marker: T -> string
    val merge_data:
       ('a, 'b, 'c, 'd, 'e, 'f) data * ('a, 'b, 'c, 'd, 'e, 'f) data ->
         ('a, 'b, 'c, 'd, 'e, 'f) data
    val quote: Proof.context -> T -> string
    val set_data:
       (string * 'a option, string * 'b option, string * 'c option,
       (class * class) * 'd option, (string * class) * 'e option,
       string * 'f option)
       attr
         -> ('a, 'b, 'c, 'd, 'e, 'f) data -> ('a, 'b, 'c, 'd, 'e, 'f) data
    val symbols_of: ('a, 'b, 'c, 'd, 'e, 'f) data -> T list
    val value: T
  end
structure Code_Symbol: CODE_SYMBOL
structure Basic_Code_Symbol: BASIC_CODE_SYMBOL
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### ML warning (line 323 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 332 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 331 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 330 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 329 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 328 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 325 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 448 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 484 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (unique) has not been referenced.
### ML warning (line 494 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 589 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 600 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 613 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (permissive) has not been referenced.
### ML warning (line 613 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (eqngr) has not been referenced.
### ML warning (line 613 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (algbr) has not been referenced.
### ML warning (line 613 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 613 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 621 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (some_abs) has not been referenced.
### ML warning (line 621 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 621 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (permissive) has not been referenced.
### ML warning (line 621 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (eqngr) has not been referenced.
### ML warning (line 621 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (algbr) has not been referenced.
### ML warning (line 621 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 619 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 661 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (range) has not been referenced.
### ML warning (line 667 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 682 of "~~/src/Tools/Code/code_thingol.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 728 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 729 of "~~/src/Tools/Code/code_thingol.ML"):
### Matches are not exhaustive.
### ML warning (line 868 of "~~/src/Tools/Code/code_thingol.ML"):
### Pattern is not exhaustive.
infix 8 `%%
infix 4 `$
infix 4 `$$
infixr 3 `->
infixr 3 `|=>
infixr 3 `|==>
signature BASIC_CODE_THINGOL =
  sig
    val `$$ : iterm * iterm list -> iterm
    val `-> : itype * itype -> itype
    val `|==> : (vname option * itype) list * iterm -> iterm
    type const =
       {annotation: itype option,
        dicts: dict list list,
        dom: itype list, sym: Code_Symbol.T, typargs: itype list}
    datatype dict = Dict of (class * class) list * plain_dict
    datatype iterm
    =
         ICase of
             {clauses: (iterm * iterm) list,
              primitive: iterm, term: iterm, typ: itype}
       | IConst of const
       | IVar of vname option
       | `$ of iterm * iterm
       | `|=> of (vname option * itype) * iterm
    datatype itype = ITyVar of vname | `%% of string * itype list
    datatype plain_dict
    =
         Dict_Const of (string * class) * dict list list
       | Dict_Var of
           {class: class, index: int, length: int, unique: bool, var: vname}
    type typscheme = (vname * sort) list * itype
    eqtype vname
  end
signature CODE_THINGOL =
  sig
    val `$$ : iterm * iterm list -> iterm
    val `-> : itype * itype -> itype
    val `|==> : (vname option * itype) list * iterm -> iterm
    val add_constsyms: iterm -> Code_Symbol.T list -> Code_Symbol.T list
    val add_tyconames: iterm -> string list -> string list
    type const =
       {annotation: itype option,
        dicts: dict list list,
        dom: itype list, sym: Code_Symbol.T, typargs: itype list}
    val consts_program: Proof.context -> string list -> program
    val contains_dict_var: iterm -> bool
    datatype dict = Dict of (class * class) list * plain_dict
    val dynamic_conv:
       Proof.context ->
         (program -> typscheme * iterm -> Code_Symbol.T list -> conv) ->
           conv
    val dynamic_value:
       Proof.context ->
         ((term -> term) -> 'a -> 'a) ->
           (program ->
              term -> typscheme * iterm -> Code_Symbol.T list -> 'a)
             -> term -> 'a
    val eta_expand: int -> const * iterm list -> iterm
    val fold_varnames: (string -> 'a -> 'a) -> iterm -> 'a -> 'a
    val group_stmts:
       Proof.context ->
         program ->
           ((Code_Symbol.T * stmt) list * (Code_Symbol.T * stmt) list *
            ((Code_Symbol.T * stmt) list * (Code_Symbol.T * stmt) list)
           )
           list
    val implemented_deps: program -> string list
    val is_IAbs: iterm -> bool
    val is_IVar: iterm -> bool
    val is_case: stmt -> bool
    val is_constr: program -> Code_Symbol.T -> bool
    datatype iterm
    =
         ICase of
             {clauses: (iterm * iterm) list,
              primitive: iterm, term: iterm, typ: itype}
       | IConst of const
       | IVar of vname option
       | `$ of iterm * iterm
       | `|=> of (vname option * itype) * iterm
    datatype itype = ITyVar of vname | `%% of string * itype list
    val map_terms_bottom_up: (iterm -> iterm) -> iterm -> iterm
    val map_terms_stmt: (iterm -> iterm) -> stmt -> stmt
    datatype plain_dict
    =
         Dict_Const of (string * class) * dict list list
       | Dict_Var of
           {class: class, index: int, length: int, unique: bool, var: vname}
    type program = stmt ?.Graph.T
    val read_const_exprs: Proof.context -> string list -> string list
    val split_let: iterm -> (((iterm * itype) * iterm) * iterm) option
    val split_let_no_pat:
       iterm -> (((string option * itype) * iterm) * iterm) option
    val split_pat_abs: iterm -> ((iterm * itype) * iterm) option
    val static_conv_isa:
       {consts: string list, ctxt: Proof.context} ->
         (program -> Proof.context -> term -> conv) -> Proof.context -> conv
    val static_conv_thingol:
       {consts: string list, ctxt: Proof.context} ->
         ({deps: string list, program: program} ->
            Proof.context ->
              typscheme * iterm -> Code_Symbol.T list -> conv)
           -> Proof.context -> conv
    val static_value:
       {consts: string list,
        ctxt: Proof.context, lift_postproc: (term -> term) -> 'a -> 'a}
         ->
         ({deps: string list, program: program} ->
            Proof.context ->
              term -> typscheme * iterm -> Code_Symbol.T list -> 'a)
           -> Proof.context -> term -> 'a
    datatype stmt
    =
         Class of vname * ((class * class) list * (string * itype) list)
       | Classinst of
           {class: string,
            inst_params: ((string * (const * int)) * (thm * bool)) list,
            superinst_params: ((string * (const * int)) * (thm * bool)) list
            ,
            superinsts: (class * dict list list) list,
            tyco: string, vs: (vname * sort) list}
       | Classparam of class
       | Classrel of class * class
       | Datatype of vname list * ((string * vname list) * itype list) list
       | Datatypecons of string
       | Fun of
           (typscheme * ((iterm list * iterm) * (thm option * bool)) list) *
           thm option
       | NoStmt
    type typscheme = (vname * sort) list * itype
    val unambiguous_dictss: dict list list -> bool
    val unfold_abs: iterm -> (vname option * itype) list * iterm
    val unfold_app: iterm -> iterm * iterm list
    val unfold_const_app: iterm -> (const * iterm list) option
    val unfold_fun: itype -> itype list * itype
    val unfold_fun_n: int -> itype -> itype list * itype
    val unfold_let: iterm -> ((iterm * itype) * iterm) list * iterm
    val unfold_let_no_pat:
       iterm -> ((string option * itype) * iterm) list * iterm
    val unfold_pat_abs: iterm -> (iterm * itype) list * iterm
    val unfoldl: ('a -> ('a * 'b) option) -> 'a -> 'a * 'b list
    val unfoldr: ('a -> ('b * 'a) option) -> 'a -> 'b list * 'a
    val unimplemented: program -> string list
    eqtype vname
  end
structure Code_Thingol: CODE_THINGOL
structure Basic_Code_Thingol: BASIC_CODE_THINGOL
### Cannot skip proof of schematic goal statement
signature CODE_SIMP =
  sig
    val dynamic_conv: Proof.context -> conv
    val dynamic_tac: Proof.context -> int -> tactic
    val dynamic_value: Proof.context -> term -> term
    val map_ss: (Proof.context -> Proof.context) -> theory -> theory
    val static_conv:
       {consts: string list, ctxt: Proof.context, simpset: simpset option}
         -> Proof.context -> conv
    val static_tac:
       {consts: string list, ctxt: Proof.context, simpset: simpset option}
         -> Proof.context -> int -> tactic
    val trace: bool Config.T
  end
structure Code_Simp: CODE_SIMP
theorem
  trans_closure_fm_type:
    [| ?i : nat; ?j : nat |] ==> trans_closure_fm(?i, ?j) : formula
### ML warning (line 135 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (default) has not been referenced.
### ML warning (line 134 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (r) has not been referenced.
### ML warning (line 134 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (l) has not been referenced.
### ML warning (line 134 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (sep) has not been referenced.
### ML warning (line 260 of "~~/src/Tools/Code/code_printer.ML"):
### Matches are not exhaustive.
### ML warning (line 281 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (strict) has not been referenced.
### ML warning (line 277 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 318 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 318 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 316 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (literals) has not been referenced.
### ML warning (line 364 of "~~/src/Tools/Code/code_printer.ML"):
### Matches are not exhaustive.
### ML warning (line 413 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (of_plain) has not been referenced.
### ML warning (line 412 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (prep_arg) has not been referenced.
### ML warning (line 412 of "~~/src/Tools/Code/code_printer.ML"):
### Value identifier (of_printer) has not been referenced.
signature CODE_PRINTER =
  sig
    val @@ : 'a * 'a -> 'a list
    val @| : 'a list * 'a -> 'a list
    val APP: fixity
    val BR: fixity
    val INFX: int * lrx -> fixity
    val L: lrx
    val Literals:
       {infix_cons: int * string,
        literal_list: Pretty.T list -> Pretty.T,
        literal_numeral: int -> string, literal_string: string -> string}
         -> literals
    val NOBR: fixity
    val R: lrx
    val X: lrx
    val applify:
       string ->
         string ->
           ('a -> Pretty.T) -> fixity -> Pretty.T -> 'a list -> Pretty.T
    val aux_params: var_ctxt -> iterm list list -> string list
    val brackets: Pretty.T list -> Pretty.T
    val brackify: fixity -> Pretty.T list -> Pretty.T
    val brackify_block:
       fixity -> Pretty.T -> Pretty.T list -> Pretty.T -> Pretty.T
    val brackify_infix:
       int * lrx -> fixity -> Pretty.T * Pretty.T * Pretty.T -> Pretty.T
    val commas: Pretty.T list -> Pretty.T list
    val complex_const_syntax: complex_const_syntax -> raw_const_syntax
    type complex_const_syntax
    val concat: Pretty.T list -> Pretty.T
    type const = Code_Thingol.const
    datatype const_printer
    =
         Complex_printer of
             (var_ctxt -> fixity -> iterm -> Pretty.T) ->
               thm option ->
                 var_ctxt -> fixity -> (iterm * itype) list -> Pretty.T
       | Plain_printer of string
    type const_syntax = int * const_printer
    type data
    eqtype dict
    val doublesemicolon: Pretty.T list -> Pretty.T
    val empty_data: data
    val enclose: string -> string -> Pretty.T list -> Pretty.T
    val enum: string -> string -> string -> Pretty.T list -> Pretty.T
    val enum_default:
       string -> string -> string -> string -> Pretty.T list -> Pretty.T
    val eqn_error: theory -> thm option -> string -> 'a
    type fixity
    val format: Code_Symbol.T list -> int -> Pretty.T -> string
    val gen_applify:
       bool ->
         string ->
           string ->
             ('a -> Pretty.T) -> fixity -> Pretty.T -> 'a list -> Pretty.T
    val gen_print_app:
       (thm option -> var_ctxt -> const * iterm list -> Pretty.T list) ->
         (thm option -> var_ctxt -> fixity -> iterm -> Pretty.T) ->
           (string -> const_syntax option) ->
             thm option ->
               var_ctxt -> fixity -> const * iterm list -> Pretty.T
    val gen_print_bind:
       (thm option -> var_ctxt -> fixity -> iterm -> Pretty.T) ->
         thm option -> fixity -> iterm -> var_ctxt -> Pretty.T * var_ctxt
    type identifiers
    val indent: int -> Pretty.T -> Pretty.T
    val infix_cons: literals -> int * string
    val intro_base_names:
       (string -> bool) ->
         (string -> string) -> string list -> var_ctxt -> var_ctxt
    val intro_base_names_for:
       (string -> bool) ->
         (Code_Symbol.T -> string) -> iterm list -> var_ctxt -> var_ctxt
    val intro_vars: string list -> var_ctxt -> var_ctxt
    eqtype iterm
    eqtype itype
    val literal_list: literals -> Pretty.T list -> Pretty.T
    val literal_numeral: literals -> int -> string
    val literal_string: literals -> string -> string
    type literals
    val lookup_var: var_ctxt -> string -> string
    type lrx
    val make_vars: string list -> var_ctxt
    val map_data:
       (string list * identifiers * printings ->
          string list * identifiers * printings)
         -> data -> data
    val markup_stmt: Code_Symbol.T -> Pretty.T -> Pretty.T
    val merge_data: data * data -> data
    val parse_const_syntax: raw_const_syntax parser
    val parse_tyco_syntax: tyco_syntax parser
    val plain_const_syntax: string -> raw_const_syntax
    val prep_const_syntax:
       theory -> literals -> string -> raw_const_syntax -> const_syntax
    type printings
    type raw_const_syntax
    val requires_args: raw_const_syntax -> int
    val semicolon: Pretty.T list -> Pretty.T
    val simple_const_syntax: simple_const_syntax -> raw_const_syntax
    type simple_const_syntax
    val str: string -> Pretty.T
    val the_identifiers: data -> identifiers
    val the_printings: data -> printings
    val the_reserved: data -> string list
    val tuplify:
       (fixity -> 'a -> Pretty.T) -> fixity -> 'a list -> Pretty.T option
    type tyco_syntax
    type var_ctxt
  end
structure Code_Printer: CODE_PRINTER
theorem
  trans_closure_fm_iff_sats:
    [| nth(?i, ?env) = ?r; nth(?j, ?env) = ?rp; ?i : nat; ?j : nat;
       ?env : list(?A) |]
    ==> tran_closure(##?A, ?r, ?rp) <->
        ?A, ?env \<Turnstile> trans_closure_fm(?i, ?j)
### Cannot skip proof of schematic goal statement
### ML warning (line 500 of "~~/src/Tools/Code/code_target.ML"):
### Pattern is not exhaustive.
### ML warning (line 606 of "~~/src/Tools/Code/code_target.ML"):
### Value identifier (target_name) has not been referenced.
signature CODE_TARGET =
  sig
    val add_derived_target: string * ancestry -> theory -> theory
    val add_language: string * language -> theory -> theory
    val add_reserved: string -> string -> theory -> theory
    type ancestry
    val assert_target: theory -> string -> string
    val cert_tyco: Proof.context -> string -> string
    val check_code:
       bool ->
         string list ->
           ((string * bool) * Token.T list) list ->
             local_theory -> local_theory
    val check_code_for:
       string ->
         bool ->
           Token.T list ->
             Code_Thingol.program ->
               bool -> Code_Symbol.T list -> local_theory -> local_theory
    val codeN: string
    val code_export_message: theory -> unit
    val code_path: Path.T -> Path.T
    val compilation_text:
       Proof.context ->
         string ->
           Code_Thingol.program ->
             Code_Symbol.T list ->
               bool ->
                 ((string * class list) list * Code_Thingol.itype) *
                 Code_Thingol.iterm
                   -> (string list * string) list * string
    val compilation_text':
       Proof.context ->
         string ->
           string option ->
             Code_Thingol.program ->
               Code_Symbol.T list ->
                 bool ->
                   ((string * class list) list * Code_Thingol.itype) *
                   Code_Thingol.iterm
                     ->
                     ((string list * string) list * string) *
                     (Code_Symbol.T -> string option)
    val default_code_width: int Config.T
    val export: Path.binding -> string -> theory -> theory
    val export_code:
       bool ->
         string list ->
           (((string * string) *
             ({physical: bool} * (Path.T * Position.T)) option)
            *
            Token.T list
           )
           list
             -> local_theory -> local_theory
    val export_code_cmd:
       bool ->
         string list ->
           (((string * string) * ({physical: bool} * Input.source) option) *
            Token.T list
           )
           list
             -> local_theory -> local_theory
    val export_code_for:
       ({physical: bool} * (Path.T * Position.T)) option ->
         string ->
           string ->
             int option ->
               Token.T list ->
                 Code_Thingol.program ->
                   bool ->
                     Code_Symbol.T list -> local_theory -> local_theory
    val generatedN: string
    type language
    type literals
    val next_export: theory -> string * theory
    val parse_args: 'a parser -> Token.T list -> 'a
    val present_code:
       Proof.context ->
         string list ->
           Code_Symbol.T list ->
             string -> string -> int option -> Token.T list -> string
    val present_code_for:
       Proof.context ->
         string ->
           string ->
             int option ->
               Token.T list ->
                 Code_Thingol.program ->
                   Code_Symbol.T list * Code_Symbol.T list -> string
    datatype pretty_modules
    =
         Hierarchy of (string list * Pretty.T) list
       | Singleton of string * Pretty.T
    val produce_code:
       Proof.context ->
         bool ->
           string list ->
             string ->
               string ->
                 int option ->
                   Token.T list ->
                     (string list * string) list * string option list
    val produce_code_for:
       Proof.context ->
         string ->
           string ->
             int option ->
               Token.T list ->
                 Code_Thingol.program ->
                   bool ->
                     Code_Symbol.T list ->
                       (string list * string) list * string option list
    val read_tyco: Proof.context -> string -> string
    type serializer
    val set_identifiers:
       (string, string, string, string, string, string) symbol_attr_decl ->
         theory -> theory
    val set_printings:
       (Code_Printer.raw_const_syntax, Code_Printer.tyco_syntax, string,
       unit, unit, string * Code_Symbol.T list)
       symbol_attr_decl
         -> theory -> theory
    type ('a, 'b, 'c, 'd, 'e, 'f) symbol_attr_decl
    val the_literals: Proof.context -> string -> literals
  end
structure Code_Target: CODE_TARGET
### ML warning (line 308 of "~~/src/Tools/Code/code_namespace.ML"):
### Matches are not exhaustive.
### ML warning (line 310 of "~~/src/Tools/Code/code_namespace.ML"):
### Matches are not exhaustive.
### ML warning (line 329 of "~~/src/Tools/Code/code_namespace.ML"):
### Matches are not exhaustive.
### ML warning (line 368 of "~~/src/Tools/Code/code_namespace.ML"):
### Matches are not exhaustive.
### ML warning (line 437 of "~~/src/Tools/Code/code_namespace.ML"):
### Matches are not exhaustive.
### ML warning (line 447 of "~~/src/Tools/Code/code_namespace.ML"):
### Matches are not exhaustive.
signature CODE_NAMESPACE =
  sig
    datatype export = Opaque | Private | Public
    val flat_program:
       Proof.context ->
         {empty_nsp: 'a,
          identifiers: Code_Printer.identifiers,
          modify_stmt: Code_Thingol.stmt -> Code_Thingol.stmt option,
          module_name: string,
          module_prefix: string,
          namify_stmt: Code_Thingol.stmt -> string -> 'a -> string * 'a,
          reserved: Name.context}
           ->
           Code_Symbol.T list ->
             Code_Thingol.program ->
               {deresolver: string -> Code_Symbol.T -> string,
                flat_program: flat_program}
    type flat_program
    val hierarchical_program:
       Proof.context ->
         {class_relation_public: bool,
          class_transitive: bool,
          cyclic_modules: bool,
          empty_data: 'a,
          empty_nsp: 'b,
          identifiers: Code_Printer.identifiers,
          memorize_data: Code_Symbol.T -> 'a -> 'a,
          modify_stmts:
          (Code_Symbol.T * (export * Code_Thingol.stmt)) list ->
            (export * 'c) option list
          ,
          module_name: string,
          namify_module: string -> 'b -> string * 'b,
          namify_stmt: Code_Thingol.stmt -> string -> 'b -> string * 'b,
          reserved: Name.context}
           ->
           Code_Symbol.T list ->
             Code_Thingol.program ->
               {deresolver: string list -> Code_Symbol.T -> string,
                hierarchical_program: ('c, 'a) hierarchical_program}
    type ('a, 'b) hierarchical_program
    val is_public: export -> bool
    val join_exports: export list -> export
    datatype ('a, 'b) node
    =
         Dummy
       | Module of 'b * (string * ('a, 'b) node) ?.Graph.T
       | Stmt of export * 'a
    val not_private: export -> bool
    val print_hierarchical:
       {lift_markup: (Pretty.T -> Pretty.T) -> 'a -> 'a,
        print_module: string list -> string -> 'b -> 'a list -> 'a,
        print_stmt: string list -> Code_Symbol.T * (export * 'c) -> 'a}
         -> ('c, 'b) hierarchical_program -> 'a list
    val variant_case_insensitive:
       string -> Name.context -> string * Name.context
  end
structure Code_Namespace: CODE_NAMESPACE
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### theory "Draft.Interface"
### 1.251s elapsed time, 2.635s cpu time, 0.443s GC time
Loading theory "Draft.Forcing_Data" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom" via "Draft.Names")
locale M_ZF
  fixes M :: "i"
  assumes "M_ZF(M)"
locale M_ctm
  fixes M :: "i"
    and enum :: "i"
  assumes "M_ctm(M, enum)"
### ML warning (line 76 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 93 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 93 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (is_pseudo_fun) has not been referenced.
### ML warning (line 89 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 111 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 104 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 104 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 104 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (is_pseudo_fun) has not been referenced.
### ML warning (line 102 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 102 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (vars) has not been referenced.
### ML warning (line 102 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 102 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (is_pseudo_fun) has not been referenced.
### ML warning (line 121 of "~~/src/Tools/Code/code_ml.ML"):
### Matches are not exhaustive.
### ML warning (line 114 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 159 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 159 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 143 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 141 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 141 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (vars) has not been referenced.
### ML warning (line 141 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 141 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (is_pseudo_fun) has not been referenced.
### ML warning (line 190 of "~~/src/Tools/Code/code_ml.ML"):
### Matches are not exhaustive.
### ML warning (line 253 of "~~/src/Tools/Code/code_ml.ML"):
### Matches are not exhaustive.
### ML warning (line 404 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 420 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 420 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (is_pseudo_fun) has not been referenced.
### ML warning (line 416 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 438 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 431 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 431 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 431 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (is_pseudo_fun) has not been referenced.
### ML warning (line 429 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 429 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (vars) has not been referenced.
### ML warning (line 429 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 429 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (is_pseudo_fun) has not been referenced.
### ML warning (line 445 of "~~/src/Tools/Code/code_ml.ML"):
### Matches are not exhaustive.
### ML warning (line 479 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 479 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 467 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 465 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 465 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (vars) has not been referenced.
### ML warning (line 465 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 465 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (is_pseudo_fun) has not been referenced.
### ML warning (line 524 of "~~/src/Tools/Code/code_ml.ML"):
### Matches are not exhaustive.
### ML warning (line 615 of "~~/src/Tools/Code/code_ml.ML"):
### Matches are not exhaustive.
### ML warning (line 745 of "~~/src/Tools/Code/code_ml.ML"):
### Matches are not exhaustive.
### ML warning (line 778 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (sym) has not been referenced.
### ML warning (line 832 of "~~/src/Tools/Code/code_ml.ML"):
### Value identifier (class_syntax) has not been referenced.
### ML warning (line 871 of "~~/src/Tools/Code/code_ml.ML"):
### Matches are not exhaustive.
signature CODE_ML = sig val target_OCaml: string val target_SML: string end
structure Code_ML: CODE_ML
locale M_ctm
  fixes M :: "i"
    and enum :: "i"
  assumes "M_ctm(M, enum)"
locale forcing_data
  fixes P :: "i"
    and leq :: "i"
    and one :: "i"
    and M :: "i"
    and enum :: "i"
  assumes "forcing_data(P, leq, one, M, enum)"
### theory "Draft.Forcing_Data"
### 0.293s elapsed time, 0.604s cpu time, 0.052s GC time
Loading theory "Draft.Names" (required by "Draft.Pairing_AxiomTemplates" via "Draft.Pairing_Axiom")
### ML warning (line 67 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 86 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 84 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 84 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 84 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (tyvars) has not been referenced.
### ML warning (line 82 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 82 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (vars) has not been referenced.
### ML warning (line 82 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 82 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (tyvars) has not been referenced.
### ML warning (line 93 of "~~/src/Tools/Code/code_haskell.ML"):
### Matches are not exhaustive.
### ML warning (line 123 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 123 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 109 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (vars) has not been referenced.
### ML warning (line 109 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 109 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (tyvars) has not been referenced.
### ML warning (line 247 of "~~/src/Tools/Code/code_haskell.ML"):
### Pattern is not exhaustive.
### ML warning (line 133 of "~~/src/Tools/Code/code_haskell.ML"):
### Matches are not exhaustive.
### ML warning (line 289 of "~~/src/Tools/Code/code_haskell.ML"):
### Matches are not exhaustive.
### ML warning (line 297 of "~~/src/Tools/Code/code_haskell.ML"):
### Matches are not exhaustive.
### ML warning (line 348 of "~~/src/Tools/Code/code_haskell.ML"):
### Matches are not exhaustive.
### ML warning (line 394 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (sym) has not been referenced.
### ML warning (line 389 of "~~/src/Tools/Code/code_haskell.ML"):
### Matches are not exhaustive.
### ML warning (line 447 of "~~/src/Tools/Code/code_haskell.ML"):
### Value identifier (print_bind) has not been referenced.
### ML warning (line 455 of "~~/src/Tools/Code/code_haskell.ML"):
### Matches are not exhaustive.
### ML warning (line 492 of "~~/src/Tools/Code/code_haskell.ML"):
### Matches are not exhaustive.
signature CODE_HASKELL =
  sig
    val language_params: string
    val print_numeral: string -> int -> string
    val target: string
  end
structure Code_Haskell: CODE_HASKELL
locale M_ctm
  fixes M :: "i"
    and enum :: "i"
  assumes "M_ctm(M, enum)"
locale forcing_data
  fixes P :: "i"
    and leq :: "i"
    and one :: "i"
    and M :: "i"
    and enum :: "i"
  assumes "forcing_data(P, leq, one, M, enum)"
locale forcing_data
  fixes P :: "i"
    and leq :: "i"
    and one :: "i"
    and M :: "i"
    and enum :: "i"
  assumes "forcing_data(P, leq, one, M, enum)"
### Cannot skip proof of schematic goal statement
theorem
  rcheck_fm_type: [| ?i : nat; ?j : nat |] ==> rcheck_fm(?i, ?j) : formula
### ML warning (line 64 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 74 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (vars) has not been referenced.
### ML warning (line 94 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 94 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (is_pat) has not been referenced.
### ML warning (line 92 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 92 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 92 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (is_pat) has not been referenced.
### ML warning (line 92 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (tyvars) has not been referenced.
### ML warning (line 103 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 180 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 180 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (fxy) has not been referenced.
### ML warning (line 155 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (vars) has not been referenced.
### ML warning (line 155 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (some_thm) has not been referenced.
### ML warning (line 155 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (tyvars) has not been referenced.
### ML warning (line 159 of "~~/src/Tools/Code/code_scala.ML"):
### Pattern is not exhaustive.
### ML warning (line 176 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 227 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 316 of "~~/src/Tools/Code/code_scala.ML"):
### Pattern is not exhaustive.
### ML warning (line 283 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 377 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 385 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 405 of "~~/src/Tools/Code/code_scala.ML"):
### Value identifier (class_syntax) has not been referenced.
### ML warning (line 415 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 418 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 420 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 419 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
### ML warning (line 473 of "~~/src/Tools/Code/code_scala.ML"):
### Matches are not exhaustive.
signature CODE_SCALA = sig val target: string end
structure Code_Scala: CODE_SCALA
theorem
  rcheck_fm_iff_sats:
    [| ?i : nat; ?j : nat; ?env : list(M) |]
    ==> is_rcheck(nth(?i, ?env), nth(?j, ?env)) <->
        M, ?env \<Turnstile> rcheck_fm(?i, ?j)
locale G_generic
  fixes P :: "i"
    and leq :: "i"
    and one :: "i"
    and M :: "i"
    and enum :: "i"
    and G :: "i"
  assumes "G_generic(P, leq, one, M, enum, G)"
### theory "Draft.Names"
### 0.616s elapsed time, 1.375s cpu time, 0.445s GC time
Loading theory "Draft.Pairing_Axiom" (required by "Draft.Pairing_AxiomTemplates")
locale forcing_data
  fixes P :: "i"
    and leq :: "i"
    and one :: "i"
    and M :: "i"
    and enum :: "i"
  assumes "forcing_data(P, leq, one, M, enum)"
### theory "Draft.Pairing_Axiom"
### 0.044s elapsed time, 0.089s cpu time, 0.000s GC time
### ML warning (line 241 of "~~/src/Tools/Code/code_runtime.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 239 of "~~/src/Tools/Code/code_runtime.ML"):
### Matches are not exhaustive.
### ML warning (line 287 of "~~/src/Tools/Code/code_runtime.ML"):
### Value identifier (compiled_value) has not been referenced.
### ML warning (line 609 of "~~/src/Tools/Code/code_runtime.ML"):
### Matches are not exhaustive.
### ML warning (line 603 of "~~/src/Tools/Code/code_runtime.ML"):
### Matches are not exhaustive.
### ML warning (line 685 of "~~/src/Tools/Code/code_runtime.ML"):
### Value identifier (pr') has not been referenced.
### ML warning (line 858 of "~~/src/Tools/Code/code_runtime.ML"):
### Matches are not exhaustive.
signature CODE_RUNTIME =
  sig
    val code_reflect:
       (string * string list option) list ->
         string list -> string -> Path.binding option -> theory -> theory
    val code_reflect_cmd:
       (string * string list option) list ->
         string list -> string -> Path.binding option -> theory -> theory
    type 'a cookie =
       (Proof.context -> unit -> 'a) *
       ((unit -> 'a) -> Proof.context -> Proof.context) * string
    val dynamic_holds_conv: Proof.context -> conv
    val dynamic_value:
       'a cookie ->
         Proof.context ->
           string option ->
             ((term -> term) -> 'a -> 'a) ->
               term -> string list -> 'a option
    val dynamic_value_exn:
       'a cookie ->
         Proof.context ->
           string option ->
             ((term -> term) -> 'a -> 'a) ->
               term -> string list -> 'a Exn.result
    val dynamic_value_strict:
       'a cookie ->
         Proof.context ->
           string option ->
             ((term -> term) -> 'a -> 'a) -> term -> string list -> 'a
    val mount_computation:
       Proof.context ->
         (string * typ) list ->
           typ ->
             (term -> 'a) ->
               ((term -> term) -> 'a option -> 'b) ->
                 Proof.context -> term -> 'b
    val mount_computation_check:
       Proof.context ->
         (string * typ) list -> (term -> truth) -> Proof.context -> conv
    val mount_computation_conv:
       Proof.context ->
         (string * typ) list ->
           typ ->
             (term -> 'a) ->
               (Proof.context -> 'a -> conv) -> Proof.context -> conv
    val polyml_as_definition:
       (binding * typ) list -> Path.T list -> theory -> theory
    val put_truth: (unit -> truth) -> Proof.context -> Proof.context
    val target: string
    val trace: bool Config.T
    datatype truth = Holds
    val value:
       Proof.context ->
         (Proof.context -> unit -> 'a) *
         ((unit -> 'a) -> Proof.context -> Proof.context) * string
           -> string * string -> 'a
  end
structure Code_Runtime: CODE_RUNTIME
### ML warning (line 184 of "~~/src/Tools/nbe.ML"):
### Matches are not exhaustive.
### ML warning (line 221 of "~~/src/Tools/nbe.ML"):
### Matches are not exhaustive.
### ML warning (line 258 of "~~/src/Tools/nbe.ML"):
### Value identifier (idx_of) has not been referenced.
### ML warning (line 329 of "~~/src/Tools/nbe.ML"):
### Value identifier (match_cont) has not been referenced.
### ML warning (line 328 of "~~/src/Tools/nbe.ML"):
### Value identifier (match_cont) has not been referenced.
### ML warning (line 327 of "~~/src/Tools/nbe.ML"):
### Value identifier (match_cont) has not been referenced.
### ML warning (line 327 of "~~/src/Tools/nbe.ML"):
### Matches are not exhaustive.
### ML warning (line 349 of "~~/src/Tools/nbe.ML"):
### Matches are not exhaustive.
### ML warning (line 399 of "~~/src/Tools/nbe.ML"):
### Value identifier (raw_deps) has not been referenced.
### ML warning (line 399 of "~~/src/Tools/nbe.ML"):
### Value identifier (nbe_program) has not been referenced.
### ML warning (line 399 of "~~/src/Tools/nbe.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 510 of "~~/src/Tools/nbe.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 519 of "~~/src/Tools/nbe.ML"):
### Matches are not exhaustive.
### ML warning (line 523 of "~~/src/Tools/nbe.ML"):
### Matches are not exhaustive.
### ML warning (line 545 of "~~/src/Tools/nbe.ML"):
### Value identifier (ty) has not been referenced.
signature NBE =
  sig
    datatype Univ
    =
         Abs of (int * (Univ list -> Univ)) * Univ list
       | BVar of int * Univ list
       | Const of int * Univ list
       | DFree of string * int
    val abss: int -> (Univ list -> Univ) -> Univ
    val add_const_alias: thm -> theory -> theory
    val apps: Univ -> Univ list -> Univ
    val dynamic_conv: Proof.context -> conv
    val dynamic_value: Proof.context -> term -> term
    val put_result:
       (unit -> Univ list -> Univ list) -> Proof.context -> Proof.context
    val same: Univ * Univ -> bool
    val static_conv:
       {consts: string list, ctxt: Proof.context} -> Proof.context -> conv
    val static_value:
       {consts: string list, ctxt: Proof.context} ->
         Proof.context -> term -> term
    val trace: bool Config.T
  end
structure Nbe: NBE
### theory "Tools.Code_Generator"
### 2.670s elapsed time, 5.532s cpu time, 1.024s GC time
Loading theory "HOL.HOL" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Typedef" via "HOL.Set" via "HOL.Lattices" via "HOL.Groups" via "HOL.Orderings")
### ML warning (line 64 of "~~/src/Tools/misc_legacy.ML"):
### Value identifier (add_term_tfree_names) has not been referenced.
### ML warning (line 67 of "~~/src/Tools/misc_legacy.ML"):
### Value identifier (typ_tfrees) has not been referenced.
### ML warning (line 174 of "~~/src/Tools/misc_legacy.ML"):
### Matches are not exhaustive.
signature MISC_LEGACY =
  sig
    val METAHYPS: Proof.context -> (thm list -> tactic) -> int -> tactic
    val add_term_frees: term * term list -> term list
    val add_term_names: term * string list -> string list
    val add_term_tfrees: term * (string * sort) list -> (string * sort) list
    val add_term_tvars:
       term * (indexname * sort) list -> (indexname * sort) list
    val add_term_vars: term * term list -> term list
    val freeze_thaw_robust:
       Proof.context -> thm -> thm * (int -> thm -> thm)
    val get_def: theory -> xstring -> thm
    val mk_defpair: term * term -> string * term
    val term_frees: term -> term list
    val term_tfrees: term -> (string * sort) list
    val term_tvars: term -> (indexname * sort) list
    val term_vars: term -> term list
    val typ_tvars: typ -> (indexname * sort) list
  end
structure Misc_Legacy: MISC_LEGACY
### ML warning (line 96 of "~~/src/Tools/try.ML"):
### Handler catches all exceptions.
signature TRY =
  sig
    type body = bool -> Proof.state -> bool * (string * string list)
    val get_tools: theory -> tool list
    val serial_commas: string -> string list -> string list
    type tool = {auto_option: string, body: body, name: string, weight: int}
    val tool_setup: tool -> unit
    val try_tools: Proof.state -> (string * string) option
  end
structure Try: TRY
### ML warning (line 119 of "~~/src/Tools/quickcheck.ML"):
### Matches are not exhaustive.
### ML warning (line 315 of "~~/src/Tools/quickcheck.ML"):
### Matches are not exhaustive.
### ML warning (line 485 of "~~/src/Tools/quickcheck.ML"):
### Pattern is not exhaustive.
### ML warning (line 476 of "~~/src/Tools/quickcheck.ML"):
### Matches are not exhaustive.
signature QUICKCHECK =
  sig
    val abort_potential: bool Config.T
    val active_testers: Proof.context -> tester list
    val add_batch_generator:
       string *
       (Proof.context -> term list -> (int -> term list option) list)
         -> Context.generic -> Context.generic
    val add_batch_validator:
       string * (Proof.context -> term list -> (int -> bool) list) ->
         Context.generic -> Context.generic
    val add_report: int -> report option -> result ref -> unit
    val add_response:
       string list ->
         term list -> (bool * term list) option -> result ref -> unit
    val add_tester:
       string * (bool Config.T * tester) ->
         Context.generic -> Context.generic
    val add_timing: string * int -> result ref -> unit
    val allow_function_inversion: bool Config.T
    val batch_tester: string Config.T
    val counterexample_of: result -> (bool * (string * term) list) option
    val default_type: Proof.context -> typ list
    val depth: int Config.T
    val empty_result: result
    datatype expectation
    = Counterexample | No_Counterexample | No_Expectation
    val finite_type_size: int Config.T
    val finite_types: bool Config.T
    val found_counterexample: result -> bool
    val genuineN: string
    val genuine_only: bool Config.T
    val iterations: int Config.T
    val limit:
       Time.time ->
         bool * bool -> (unit -> 'a) -> (unit -> 'a) -> unit -> 'a
    val locale: string Config.T
    val map_test_params:
       (typ list * expectation -> typ list * expectation) ->
         Context.generic -> Context.generic
    val message: Proof.context -> string -> unit
    val mk_batch_tester:
       Proof.context -> term list -> (int -> term list option) list option
    val mk_batch_validator:
       Proof.context -> term list -> (int -> bool) list option
    val no_assms: bool Config.T
    val noneN: string
    val pretty_counterex:
       Proof.context ->
         bool ->
           ((bool * (string * term) list) * (term * term) list) option ->
             Pretty.T
    val quickcheck:
       (string * string list) list ->
         int -> Proof.state -> (bool * (string * term) list) option
    val quickcheckN: string
    val quiet: bool Config.T
    datatype report
    =
         Report of
             {iterations: int,
              positive_concl_tests: int,
              raised_match_errors: int, satisfied_assms: int list}
    val report: bool Config.T
    datatype result
    =
         Result of
             {counterexample: (bool * (string * term) list) option,
              evaluation_terms: (term * term) list option,
              reports: (int * report) list, timings: (string * int) list}
    val set_active_testers:
       string list -> Context.generic -> Context.generic
    val size: int Config.T
    val tag: string Config.T
    datatype test_params
    = Test_Params of {default_type: typ list, expect: expectation}
    val test_params_of: Proof.context -> test_params
    val test_terms:
       Proof.context ->
         bool * bool ->
           (string * typ) list ->
             (term * term list) list -> result list option
    type tester =
       Proof.context ->
         bool ->
           (string * typ) list -> (term * term list) list -> result list
    val timeout: real Config.T
    val timing: bool Config.T
    val timings_of: result -> (string * int) list
    val unknownN: string
    val use_subtype: bool Config.T
    val verbose: bool Config.T
    val verbose_message: Proof.context -> string -> unit
  end
structure Quickcheck: QUICKCHECK
signature SOLVE_DIRECT =
  sig
    val max_solutions: int Config.T
    val noneN: string
    val solve_direct: Proof.state -> bool * (string * string list)
    val solve_directN: string
    val someN: string
    val strict_warnings: bool Config.T
    val unknownN: string
  end
structure Solve_Direct: SOLVE_DIRECT
### ML warning (line 268 of "~~/src/Tools/IsaPlanner/zipper.ML"):
### Value identifier (z) has not been referenced.
### ML warning (line 270 of "~~/src/Tools/IsaPlanner/zipper.ML"):
### Value identifier (z) has not been referenced.
### ML warning (line 273 of "~~/src/Tools/IsaPlanner/zipper.ML"):
### Value identifier (z) has not been referenced.
### ML warning (line 275 of "~~/src/Tools/IsaPlanner/zipper.ML"):
### Value identifier (z) has not been referenced.
### ML warning (line 282 of "~~/src/Tools/IsaPlanner/zipper.ML"):
### Value identifier (z) has not been referenced.
### ML warning (line 354 of "~~/src/Tools/IsaPlanner/zipper.ML"):
### Value identifier (a) has not been referenced.
signature ABSTRACT_TRM =
  sig
    type T
    type aname
    type bname
    type cname
    type fname
    datatype term
    =
         $ of term * term
       | Abs of aname * typ * term
       | Bound of bname
       | Const of cname * typ
       | Free of fname * typ
       | Var of vname * typ
    type typ
    type vname
  end
structure IsabelleTrmWrap: ABSTRACT_TRM
signature TRM_CTXT_DATA =
  sig
    structure Trm: ABSTRACT_TRM
    val apply: dtrm -> Trm.T -> Trm.T
    datatype dtrm
    = Abs of Trm.aname * Trm.typ | AppL of Trm.T | AppR of Trm.T
    val eq_pos: dtrm * dtrm -> bool
  end
signature TRM_CTXT =
  sig
    structure D: TRM_CTXT_DATA
    type T = D.dtrm list
    val add_abs: D.Trm.aname * D.Trm.typ -> T -> T
    val add_appl: D.Trm.term -> T -> T
    val add_appr: D.Trm.term -> T -> T
    val add_dtrm: D.dtrm -> T -> T
    val add_outerctxt: T -> T -> T
    val apply: T -> D.Trm.term -> D.Trm.term
    val depth: T -> int
    val empty: T
    val eq_path: T * T -> bool
    val fold_down: (D.dtrm -> 'a -> 'a) -> T -> 'a -> 'a
    val fold_up: (D.dtrm -> 'a -> 'a) -> T -> 'a -> 'a
    val is_empty: T -> bool
    val map: (D.dtrm -> D.dtrm) -> T -> T
    val nty_ctxt: T -> (D.Trm.aname * D.Trm.typ) list
    val ty_ctxt: T -> D.Trm.typ list
  end
signature ZIPPER =
  sig
    structure C: TRM_CTXT
    type T
    val add_outerctxt: C.T -> T -> T
    val at_top: T -> bool
    val ctxt: T -> C.T
    val depth_of_ctxt: T -> int
    val fold_down_ctxt: (C.D.dtrm -> 'a -> 'a) -> T -> 'a -> 'a
    val fold_up_ctxt: (C.D.dtrm -> 'a -> 'a) -> T -> 'a -> 'a
    val goto_top: T -> T
    val limit_apply: (T -> T Seq.seq) -> T -> T Seq.seq
    val limit_capply: (C.T -> T -> T Seq.seq) -> T -> T Seq.seq
    val limit_pcapply:
       (C.T -> T -> ('a * T) Seq.seq) -> T -> ('a * T) Seq.seq
    val lzy_search: (T -> zsearch list) -> T -> T Seq.seq
    val map_on_ctxt: (C.D.dtrm -> C.D.dtrm) -> T -> T
    val mk: C.D.Trm.term * C.T -> T
    val mktop: C.D.Trm.term -> T
    exception move of string * T
    val move_down_abs: T -> T
    val move_down_app: T -> T * T
    val move_down_left: T -> T
    val move_down_right: T -> T
    val move_up: T -> T
    val move_up_abs: T -> T
    val move_up_app: T -> T
    val move_up_left: T -> T
    val move_up_left_or_abs: T -> T
    val move_up_right: T -> T
    val move_up_right_or_abs: T -> T
    val nty_ctxt: T -> (C.D.Trm.aname * C.D.Trm.typ) list
    val omove_down_abs: T -> T option
    val omove_down_app: T -> (T * T) option
    val omove_down_left: T -> T option
    val omove_down_right: T -> T option
    val omove_up: T -> T option
    val omove_up_abs: T -> T option
    val omove_up_app: T -> T option
    val omove_up_left: T -> T option
    val omove_up_left_or_abs: T -> T option
    val omove_up_right: T -> T option
    val omove_up_right_or_abs: T -> T option
    val pf_lzy_search:
       ('a -> T -> 'a * zsearch list) -> 'a -> T -> T Seq.seq
    val searchfold:
       ('a -> T -> ('a * zsearch) list) -> 'a -> T -> ('a * T) Seq.seq
    val set_ctxt: C.T -> T -> T
    val set_trm: C.D.Trm.term -> T -> T
    val split: T -> T * C.T
    val top_trm: T -> C.D.Trm.term
    val trm: T -> C.D.Trm.term
    val ty_ctxt: T -> C.D.Trm.typ list
    val zipto: C.T -> T -> T
    datatype zsearch = Here of T | LookIn of T
  end
functor TrmCtxtDataFUN (Trm: ABSTRACT_TRM): TRM_CTXT_DATA
functor TrmCtxtFUN (D: TRM_CTXT_DATA): TRM_CTXT
functor ZipperFUN (C: TRM_CTXT): ZIPPER
structure TrmCtxtData: TRM_CTXT_DATA
structure TrmCtxt: TRM_CTXT
structure Zipper: ZIPPER
signature ZIPPER_SEARCH =
  sig
    structure Z: ZIPPER
    val all_bl_ru: Z.T -> Z.T Seq.seq
    val all_bl_ur: Z.T -> Z.T Seq.seq
    val all_td_lr: Z.T -> Z.T Seq.seq
    val all_td_rl: Z.T -> Z.T Seq.seq
    val leaves_lr: Z.T -> Z.T Seq.seq
    val leaves_rl: Z.T -> Z.T Seq.seq
  end
functor ZipperSearchFUN (Zipper: ZIPPER): ZIPPER_SEARCH
structure ZipperSearch: ZIPPER_SEARCH
signature ISA_ND =
  sig
    val fix_alls_term: Proof.context -> int -> term -> term * term list
    val fixed_subgoal_thms:
       Proof.context -> thm -> thm list * (thm list -> thm)
    val variant_names:
       Proof.context -> term list -> string list -> string list
  end
structure IsaND: ISA_ND
### ML warning (line 70 of "~~/src/Tools/IsaPlanner/rw_inst.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 88 of "~~/src/Tools/IsaPlanner/rw_inst.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 113 of "~~/src/Tools/IsaPlanner/rw_inst.ML"):
### Value identifier (tv) has not been referenced.
### ML warning (line 127 of "~~/src/Tools/IsaPlanner/rw_inst.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 137 of "~~/src/Tools/IsaPlanner/rw_inst.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 149 of "~~/src/Tools/IsaPlanner/rw_inst.ML"):
### Value identifier (srt) has not been referenced.
### ML warning (line 215 of "~~/src/Tools/IsaPlanner/rw_inst.ML"):
### Value identifier (ty) has not been referenced.
### ML warning (line 216 of "~~/src/Tools/IsaPlanner/rw_inst.ML"):
### Value identifier (ty) has not been referenced.
signature RW_INST =
  sig
    val rw:
       Proof.context ->
         ((indexname * (sort * typ)) list * (indexname * (typ * term)) list)
         *
         (string * typ) list * (string * typ) list * term
           -> thm -> thm -> thm
  end
structure RW_Inst: RW_INST
### ML warning (line 114 of "~~/src/Provers/hypsubst.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 121 of "~~/src/Provers/hypsubst.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 238 of "~~/src/Provers/hypsubst.ML"):
### Value identifier (i) has not been referenced.
signature HYPSUBST_DATA =
  sig
    val dest_Trueprop: term -> term
    val dest_eq: term -> term * term
    val dest_imp: term -> term * term
    val eq_reflection: thm
    val imp_intr: thm
    val rev_eq_reflection: thm
    val rev_mp: thm
    val subst: thm
    val sym: thm
    val thin_refl: thm
  end
signature HYPSUBST =
  sig
    val blast_hyp_subst_tac: Proof.context -> bool -> int -> tactic
    val bound_hyp_subst_tac: Proof.context -> int -> tactic
    val hyp_subst_tac: Proof.context -> int -> tactic
    val hyp_subst_tac_thin: bool -> Proof.context -> int -> tactic
    val hyp_subst_thin: bool Config.T
    val stac: Proof.context -> thm -> int -> tactic
  end
functor Hypsubst (Data: HYPSUBST_DATA): HYPSUBST
### ML warning (line 107 of "~~/src/Provers/splitter.ML"):
### Pattern is not exhaustive.
### ML warning (line 127 of "~~/src/Provers/splitter.ML"):
### Pattern is not exhaustive.
### ML warning (line 292 of "~~/src/Provers/splitter.ML"):
### Pattern is not exhaustive.
### ML warning (line 320 of "~~/src/Provers/splitter.ML"):
### Pattern is not exhaustive.
### ML warning (line 342 of "~~/src/Provers/splitter.ML"):
### Pattern is not exhaustive.
### ML warning (line 356 of "~~/src/Provers/splitter.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 364 of "~~/src/Provers/splitter.ML"):
### Value identifier (pos) has not been referenced.
signature SPLITTER_DATA =
  sig
    val conjE: thm
    val context: Proof.context
    val contrapos: thm
    val contrapos2: thm
    val disjE: thm
    val exE: thm
    val iffD: thm
    val meta_eq_to_iff: thm
    val mk_eq: thm -> thm
    val notnotD: thm
    val safe_tac: Proof.context -> tactic
  end
signature SPLITTER =
  sig
    val add_split: thm -> Proof.context -> Proof.context
    val add_split_bang: thm -> Proof.context -> Proof.context
    val cmap_of_split_thms:
       thm list -> (string * (typ * term * thm * typ * int) list) list
    val del_split: thm -> Proof.context -> Proof.context
    val split_asm_tac: Proof.context -> thm list -> int -> tactic
    val split_inside_tac: Proof.context -> thm list -> int -> tactic
    val split_modifiers: Method.modifier parser list
    val split_posns:
       (string * (typ * term * thm * typ * int) list) list ->
         theory ->
           typ list ->
             term ->
               (thm * (typ * typ * int list) list * int list * typ * term)
               list
    val split_tac: Proof.context -> thm list -> int -> tactic
  end
functor Splitter (Data: SPLITTER_DATA): SPLITTER
### ML warning (line 268 of "~~/src/Provers/classical.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 739 of "~~/src/Provers/classical.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 923 of "~~/src/Provers/classical.ML"):
### Pattern is not exhaustive.
infix 4 addSIs
infix 4 addSEs
infix 4 addSDs
infix 4 addIs
infix 4 addEs
infix 4 addDs
infix 4 delrules
infix 4 addSWrapper
infix 4 delSWrapper
infix 4 addWrapper
infix 4 delWrapper
infix 4 addSbefore
infix 4 addSafter
infix 4 addbefore
infix 4 addafter
infix 4 addD2
infix 4 addE2
infix 4 addSD2
infix 4 addSE2
signature CLASSICAL_DATA =
  sig
    val classical: thm
    val hyp_subst_tacs: (Proof.context -> int -> tactic) list
    val imp_elim: thm
    val not_elim: thm
    val sizef: thm -> int
    val swap: thm
  end
signature BASIC_CLASSICAL =
  sig
    val addD2: Proof.context * (string * thm) -> Proof.context
    val addDs: Proof.context * thm list -> Proof.context
    val addE2: Proof.context * (string * thm) -> Proof.context
    val addEs: Proof.context * thm list -> Proof.context
    val addIs: Proof.context * thm list -> Proof.context
    val addSD2: Proof.context * (string * thm) -> Proof.context
    val addSDs: Proof.context * thm list -> Proof.context
    val addSE2: Proof.context * (string * thm) -> Proof.context
    val addSEs: Proof.context * thm list -> Proof.context
    val addSIs: Proof.context * thm list -> Proof.context
    val addSWrapper:
       Proof.context * (string * (Proof.context -> wrapper)) ->
         Proof.context
    val addSafter:
       Proof.context * (string * (Proof.context -> int -> tactic)) ->
         Proof.context
    val addSbefore:
       Proof.context * (string * (Proof.context -> int -> tactic)) ->
         Proof.context
    val addWrapper:
       Proof.context * (string * (Proof.context -> wrapper)) ->
         Proof.context
    val addafter:
       Proof.context * (string * (Proof.context -> int -> tactic)) ->
         Proof.context
    val addbefore:
       Proof.context * (string * (Proof.context -> int -> tactic)) ->
         Proof.context
    val appSWrappers: Proof.context -> wrapper
    val appWrappers: Proof.context -> wrapper
    val astar_tac: Proof.context -> int -> tactic
    val best_tac: Proof.context -> int -> tactic
    val clarify_step_tac: Proof.context -> int -> tactic
    val clarify_tac: Proof.context -> int -> tactic
    type claset
    val claset_of: Proof.context -> claset
    val contr_tac: Proof.context -> int -> tactic
    val deepen_tac: Proof.context -> int -> int -> tactic
    val delSWrapper: Proof.context * string -> Proof.context
    val delWrapper: Proof.context * string -> Proof.context
    val delrules: Proof.context * thm list -> Proof.context
    val depth_tac: Proof.context -> int -> int -> tactic
    val dup_elim: Proof.context -> thm -> thm
    val dup_intr: thm -> thm
    val dup_step_tac: Proof.context -> int -> tactic
    val eq_mp_tac: Proof.context -> int -> tactic
    val fast_tac: Proof.context -> int -> tactic
    val first_best_tac: Proof.context -> int -> tactic
    val inst0_step_tac: Proof.context -> int -> tactic
    val inst_step_tac: Proof.context -> int -> tactic
    val instp_step_tac: Proof.context -> int -> tactic
    val map_theory_claset:
       (Proof.context -> Proof.context) -> theory -> theory
    val mp_tac: Proof.context -> int -> tactic
    val print_claset: Proof.context -> unit
    val put_claset: claset -> Proof.context -> Proof.context
    val safe_step_tac: Proof.context -> int -> tactic
    val safe_steps_tac: Proof.context -> int -> tactic
    val safe_tac: Proof.context -> tactic
    val slow_astar_tac: Proof.context -> int -> tactic
    val slow_best_tac: Proof.context -> int -> tactic
    val slow_step_tac: Proof.context -> int -> tactic
    val slow_tac: Proof.context -> int -> tactic
    val step_tac: Proof.context -> int -> tactic
    val swap_res_tac: Proof.context -> thm list -> int -> tactic
    val swapify: thm list -> thm list
    val unsafe_step_tac: Proof.context -> int -> tactic
    type wrapper = (int -> tactic) -> int -> tactic
  end
signature CLASSICAL =
  sig
    val addD2: Proof.context * (string * thm) -> Proof.context
    val addDs: Proof.context * thm list -> Proof.context
    val addE2: Proof.context * (string * thm) -> Proof.context
    val addEs: Proof.context * thm list -> Proof.context
    val addIs: Proof.context * thm list -> Proof.context
    val addSD2: Proof.context * (string * thm) -> Proof.context
    val addSDs: Proof.context * thm list -> Proof.context
    val addSE2: Proof.context * (string * thm) -> Proof.context
    val addSEs: Proof.context * thm list -> Proof.context
    val addSIs: Proof.context * thm list -> Proof.context
    val addSWrapper:
       Proof.context * (string * (Proof.context -> wrapper)) ->
         Proof.context
    val addSafter:
       Proof.context * (string * (Proof.context -> int -> tactic)) ->
         Proof.context
    val addSbefore:
       Proof.context * (string * (Proof.context -> int -> tactic)) ->
         Proof.context
    val addWrapper:
       Proof.context * (string * (Proof.context -> wrapper)) ->
         Proof.context
    val addafter:
       Proof.context * (string * (Proof.context -> int -> tactic)) ->
         Proof.context
    val addbefore:
       Proof.context * (string * (Proof.context -> int -> tactic)) ->
         Proof.context
    val appSWrappers: Proof.context -> wrapper
    val appWrappers: Proof.context -> wrapper
    val astar_tac: Proof.context -> int -> tactic
    val best_tac: Proof.context -> int -> tactic
    val cla_method:
       (Proof.context -> tactic) ->
         (Proof.context -> Proof.method) context_parser
    val cla_method':
       (Proof.context -> int -> tactic) ->
         (Proof.context -> Proof.method) context_parser
    val cla_modifiers: Method.modifier parser list
    val clarify_step_tac: Proof.context -> int -> tactic
    val clarify_tac: Proof.context -> int -> tactic
    type claset
    val claset_of: Proof.context -> claset
    val classical_rule: Proof.context -> thm -> thm
    val contr_tac: Proof.context -> int -> tactic
    val deepen_tac: Proof.context -> int -> int -> tactic
    val delSWrapper: Proof.context * string -> Proof.context
    val delWrapper: Proof.context * string -> Proof.context
    val delrules: Proof.context * thm list -> Proof.context
    val depth_tac: Proof.context -> int -> int -> tactic
    val dup_elim: Proof.context -> thm -> thm
    val dup_intr: thm -> thm
    val dup_step_tac: Proof.context -> int -> tactic
    val eq_mp_tac: Proof.context -> int -> tactic
    val fast_tac: Proof.context -> int -> tactic
    val first_best_tac: Proof.context -> int -> tactic
    val get_cs: Context.generic -> claset
    val inst0_step_tac: Proof.context -> int -> tactic
    val inst_step_tac: Proof.context -> int -> tactic
    val instp_step_tac: Proof.context -> int -> tactic
    val map_cs: (claset -> claset) -> Context.generic -> Context.generic
    val map_theory_claset:
       (Proof.context -> Proof.context) -> theory -> theory
    val mp_tac: Proof.context -> int -> tactic
    type netpair =
       (int * (bool * thm)) Net.net * (int * (bool * thm)) Net.net
    val print_claset: Proof.context -> unit
    val put_claset: claset -> Proof.context -> Proof.context
    val rep_cs:
       claset ->
         {dup_netpair: netpair,
          extra_netpair: Context_Rules.netpair,
          safe0_netpair: netpair,
          safeEs: rule Item_Net.T,
          safeIs: rule Item_Net.T,
          safep_netpair: netpair,
          swrappers: (string * (Proof.context -> wrapper)) list,
          unsafeEs: rule Item_Net.T,
          unsafeIs: rule Item_Net.T,
          unsafe_netpair: netpair,
          uwrappers: (string * (Proof.context -> wrapper)) list}
    type rule = thm * (thm * thm list) * (thm * thm list)
    val rule_del: attribute
    val rule_tac: Proof.context -> thm list -> thm list -> int -> tactic
    val safe_dest: int option -> attribute
    val safe_elim: int option -> attribute
    val safe_intro: int option -> attribute
    val safe_step_tac: Proof.context -> int -> tactic
    val safe_steps_tac: Proof.context -> int -> tactic
    val safe_tac: Proof.context -> tactic
    val slow_astar_tac: Proof.context -> int -> tactic
    val slow_best_tac: Proof.context -> int -> tactic
    val slow_step_tac: Proof.context -> int -> tactic
    val slow_tac: Proof.context -> int -> tactic
    val standard_tac: Proof.context -> thm list -> tactic
    val step_tac: Proof.context -> int -> tactic
    val swap_res_tac: Proof.context -> thm list -> int -> tactic
    val swapify: thm list -> thm list
    val unsafe_dest: int option -> attribute
    val unsafe_elim: int option -> attribute
    val unsafe_intro: int option -> attribute
    val unsafe_step_tac: Proof.context -> int -> tactic
    type wrapper = (int -> tactic) -> int -> tactic
  end
functor Classical (Data: CLASSICAL_DATA): CLASSICAL
### ML warning (line 142 of "~~/src/Provers/blast.ML"):
### Matches are not exhaustive.
### ML warning (line 144 of "~~/src/Provers/blast.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 144 of "~~/src/Provers/blast.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/Provers/blast.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 186 of "~~/src/Provers/blast.ML"):
### Value identifier (alist) has not been referenced.
### ML warning (line 219 of "~~/src/Provers/blast.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 228 of "~~/src/Provers/blast.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 257 of "~~/src/Provers/blast.ML"):
### Value identifier (lev) has not been referenced.
### ML warning (line 257 of "~~/src/Provers/blast.ML"):
### Value identifier (inc) has not been referenced.
### ML warning (line 281 of "~~/src/Provers/blast.ML"):
### Value identifier (lev) has not been referenced.
### ML warning (line 315 of "~~/src/Provers/blast.ML"):
### Value identifier (args) has not been referenced.
### ML warning (line 315 of "~~/src/Provers/blast.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 323 of "~~/src/Provers/blast.ML"):
### Value identifier (lev) has not been referenced.
### ML warning (line 334 of "~~/src/Provers/blast.ML"):
### Value identifier (lev) has not been referenced.
### ML warning (line 355 of "~~/src/Provers/blast.ML"):
### Matches are not exhaustive.
### ML warning (line 367 of "~~/src/Provers/blast.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 366 of "~~/src/Provers/blast.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 389 of "~~/src/Provers/blast.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 413 of "~~/src/Provers/blast.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 409 of "~~/src/Provers/blast.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 406 of "~~/src/Provers/blast.ML"):
### Value identifier (instVars) has not been referenced.
### ML warning (line 426 of "~~/src/Provers/blast.ML"):
### Value identifier (A) has not been referenced.
### ML warning (line 455 of "~~/src/Provers/blast.ML"):
### Pattern is not exhaustive.
### ML warning (line 456 of "~~/src/Provers/blast.ML"):
### Pattern is not exhaustive.
### ML warning (line 472 of "~~/src/Provers/blast.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 474 of "~~/src/Provers/blast.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 558 of "~~/src/Provers/blast.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 558 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 557 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 556 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 555 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 554 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 553 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 605 of "~~/src/Provers/blast.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 616 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 614 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 613 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 612 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 611 of "~~/src/Provers/blast.ML"):
### Value identifier (d) has not been referenced.
### ML warning (line 656 of "~~/src/Provers/blast.ML"):
### Value identifier (lits) has not been referenced.
### ML warning (line 656 of "~~/src/Provers/blast.ML"):
### Matches are not exhaustive.
### ML warning (line 698 of "~~/src/Provers/blast.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 760 of "~~/src/Provers/blast.ML"):
### Value identifier (subst2) has not been referenced.
### ML warning (line 805 of "~~/src/Provers/blast.ML"):
### Matches are not exhaustive.
### ML warning (line 822 of "~~/src/Provers/blast.ML"):
### Value identifier (md) has not been referenced.
### ML warning (line 841 of "~~/src/Provers/blast.ML"):
### Value identifier (nxtVars) has not been referenced.
### ML warning (line 853 of "~~/src/Provers/blast.ML"):
### Value identifier (exn) has not been referenced.
### ML warning (line 864 of "~~/src/Provers/blast.ML"):
### Value identifier (lim) has not been referenced.
### ML warning (line 864 of "~~/src/Provers/blast.ML"):
### Value identifier (lits) has not been referenced.
### ML warning (line 864 of "~~/src/Provers/blast.ML"):
### Value identifier (pairs) has not been referenced.
### ML warning (line 867 of "~~/src/Provers/blast.ML"):
### Value identifier (ntrl) has not been referenced.
### ML warning (line 867 of "~~/src/Provers/blast.ML"):
### Value identifier (choices) has not been referenced.
### ML warning (line 910 of "~~/src/Provers/blast.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 910 of "~~/src/Provers/blast.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 901 of "~~/src/Provers/blast.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 911 of "~~/src/Provers/blast.ML"):
### Matches are not exhaustive.
### ML warning (line 1174 of "~~/src/Provers/blast.ML"):
### Value identifier (brs) has not been referenced.
### ML warning (line 1174 of "~~/src/Provers/blast.ML"):
### Value identifier (trs) has not been referenced.
### ML warning (line 1174 of "~~/src/Provers/blast.ML"):
### Value identifier (tacs) has not been referenced.
### ML warning (line 1191 of "~~/src/Provers/blast.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 1191 of "~~/src/Provers/blast.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 1196 of "~~/src/Provers/blast.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1208 of "~~/src/Provers/blast.ML"):
### Value identifier (is) has not been referenced.
### ML warning (line 1208 of "~~/src/Provers/blast.ML"):
### Value identifier (ix) has not been referenced.
### ML warning (line 1208 of "~~/src/Provers/blast.ML"):
### Matches are not exhaustive.
### ML warning (line 1217 of "~~/src/Provers/blast.ML"):
### Value identifier (ts) has not been referenced.
### ML warning (line 1221 of "~~/src/Provers/blast.ML"):
### Matches are not exhaustive.
signature BLAST_DATA =
  sig
    structure Classical: CLASSICAL
    val Trueprop_const: string * typ
    val ccontr: thm
    val equality_name: string
    val hyp_subst_tac: Proof.context -> bool -> int -> tactic
    val notE: thm
    val not_name: string
  end
signature BLAST =
  sig
    exception TRANS of string
    val blast_tac: Proof.context -> int -> tactic
    type branch
    val depth_limit: int Config.T
    val depth_tac: Proof.context -> int -> int -> tactic
    val stats: bool Config.T
    datatype term
    =
         $ of term * term
       | Abs of string * term
       | Bound of int
       | Const of string * term list
       | Free of string
       | Skolem of string * term option ref list
       | Var of term option ref
    val trace: bool Config.T
    val tryIt:
       Proof.context ->
         int ->
           string ->
             {fullTrace: branch list list,
              result:
              (int -> tactic) list * branch list list *
              (int * int * exn) list}
  end
functor Blast (Data: BLAST_DATA): BLAST
signature CLASIMP_DATA =
  sig
    structure Blast: BLAST
    structure Classical: CLASSICAL
    structure Splitter: SPLITTER
    val iffD1: thm
    val iffD2: thm
    val notE: thm
  end
signature CLASIMP =
  sig
    val addSss: Proof.context -> Proof.context
    val addss: Proof.context -> Proof.context
    val auto_tac: Proof.context -> tactic
    val best_simp_tac: Proof.context -> int -> tactic
    val clarsimp_tac: Proof.context -> int -> tactic
    val clasimp_modifiers: Method.modifier parser list
    val fast_force_tac: Proof.context -> int -> tactic
    val force_tac: Proof.context -> int -> tactic
    val iff_add: attribute
    val iff_add': attribute
    val iff_del: attribute
    val iff_modifiers: Method.modifier parser list
    val mk_auto_tac: Proof.context -> int -> int -> tactic
    val slow_simp_tac: Proof.context -> int -> tactic
  end
functor Clasimp (Data: CLASIMP_DATA): CLASIMP
### ML warning (line 114 of "~~/src/Tools/eqsubst.ML"):
### Value identifier (newnames) has not been referenced.
### ML warning (line 374 of "~~/src/Tools/eqsubst.ML"):
### Value identifier (occ) has not been referenced.
signature EQSUBST =
  sig
    val eqsubst_asm_tac:
       Proof.context -> int list -> thm list -> int -> tactic
    val eqsubst_asm_tac':
       Proof.context ->
         (searchinfo -> int -> term -> match skipseq) ->
           int -> thm -> int -> tactic
    val eqsubst_tac: Proof.context -> int list -> thm list -> int -> tactic
    val eqsubst_tac':
       Proof.context ->
         (searchinfo -> term -> match Seq.seq) ->
           thm -> int -> thm -> thm Seq.seq
    type match =
       ((indexname * (sort * typ)) list * (indexname * (typ * term)) list) *
       (string * typ) list * (string * typ) list * term
    val search_lr_all: Zipper.T -> Zipper.T Seq.seq
    val search_lr_valid: (Zipper.T -> bool) -> Zipper.T -> Zipper.T Seq.seq
    val searchf_bt_unify_valid: searchinfo -> term -> match Seq.seq Seq.seq
    val searchf_lr_unify_all: searchinfo -> term -> match Seq.seq Seq.seq
    val searchf_lr_unify_valid: searchinfo -> term -> match Seq.seq Seq.seq
    type searchinfo = Proof.context * int * Zipper.T
    val skip_first_asm_occs_search:
       ('a -> 'b -> 'c Seq.seq Seq.seq) -> 'a -> int -> 'b -> 'c skipseq
    val skip_first_occs_search:
       int -> ('a -> 'b -> 'c Seq.seq Seq.seq) -> 'a -> 'b -> 'c Seq.seq
    datatype 'a skipseq = SkipMore of int | SkipSeq of 'a Seq.seq Seq.seq
    val skipto_skipseq: int -> 'a Seq.seq Seq.seq -> 'a skipseq
    val valid_match_start: Zipper.T -> bool
  end
structure EqSubst: EQSUBST
### ML warning (line 120 of "~~/src/Provers/quantifier1.ML"):
### Pattern is not exhaustive.
signature QUANTIFIER1_DATA =
  sig
    val all_comm: thm
    val atomize: Proof.context -> conv
    val conj: term
    val conjE: thm
    val conjI: thm
    val dest_conj: term -> (term * term) option
    val dest_eq: term -> (term * term) option
    val dest_imp: term -> (term * term) option
    val exE: thm
    val exI: thm
    val ex_comm: thm
    val iffI: thm
    val iff_allI: thm
    val iff_exI: thm
    val iff_reflection: thm
    val iff_trans: thm
    val imp: term
    val impI: thm
    val mp: thm
    val uncurry: thm
  end
signature QUANTIFIER1 =
  sig
    val rearrange_All: Proof.context -> cterm -> thm option
    val rearrange_Ball:
       (Proof.context -> tactic) -> Proof.context -> cterm -> thm option
    val rearrange_Bex:
       (Proof.context -> tactic) -> Proof.context -> cterm -> thm option
    val rearrange_Collect:
       (Proof.context -> tactic) -> Proof.context -> cterm -> thm option
    val rearrange_Ex: Proof.context -> cterm -> thm option
    val rearrange_all: Proof.context -> cterm -> thm option
  end
functor Quantifier1 (Data: QUANTIFIER1_DATA): QUANTIFIER1
### ML warning (line 76 of "~~/src/Tools/atomize_elim.ML"):
### Pattern is not exhaustive.
### ML warning (line 113 of "~~/src/Tools/atomize_elim.ML"):
### Pattern is not exhaustive.
signature ATOMIZE_ELIM =
  sig
    val atomize_elim_conv: Proof.context -> conv
    val atomize_elim_tac: Proof.context -> int -> tactic
    val full_atomize_elim_conv: Proof.context -> conv
  end
structure Atomize_Elim: ATOMIZE_ELIM
### ML warning (line 23 of "~~/src/Tools/cong_tac.ML"):
### Pattern is not exhaustive.
signature CONG_TAC =
  sig val cong_tac: Proof.context -> thm -> int -> tactic end
structure Cong_Tac: CONG_TAC
signature INTUITIONISTIC =
  sig
    val method_setup: binding -> theory -> theory
    val prover_tac: Proof.context -> int option -> int -> tactic
  end
structure Intuitionistic: INTUITIONISTIC
### ML warning (line 42 of "~~/src/Tools/project_rule.ML"):
### Pattern is not exhaustive.
### ML warning (line 62 of "~~/src/Tools/project_rule.ML"):
### Pattern is not exhaustive.
signature PROJECT_RULE_DATA =
  sig val conjunct1: thm val conjunct2: thm val mp: thm end
signature PROJECT_RULE =
  sig
    val project: Proof.context -> int -> thm -> thm
    val projections: Proof.context -> thm -> thm list
    val projects: Proof.context -> int list -> thm -> thm list
  end
functor Project_Rule (Data: PROJECT_RULE_DATA): PROJECT_RULE
### ML warning (line 98 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 257 of "~~/src/Tools/subtyping.ML"):
### Pattern is not exhaustive.
### ML warning (line 272 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 278 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 278 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 354 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 417 of "~~/src/Tools/subtyping.ML"):
### Pattern is not exhaustive.
### ML warning (line 418 of "~~/src/Tools/subtyping.ML"):
### Pattern is not exhaustive.
### ML warning (line 419 of "~~/src/Tools/subtyping.ML"):
### Pattern is not exhaustive.
### ML warning (line 482 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 514 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 580 of "~~/src/Tools/subtyping.ML"):
### Pattern is not exhaustive.
### ML warning (line 711 of "~~/src/Tools/subtyping.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 712 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 777 of "~~/src/Tools/subtyping.ML"):
### Value identifier (idx) has not been referenced.
### ML warning (line 790 of "~~/src/Tools/subtyping.ML"):
### Pattern is not exhaustive.
### ML warning (line 909 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
### ML warning (line 941 of "~~/src/Tools/subtyping.ML"):
### Matches are not exhaustive.
signature SUBTYPING =
  sig
    val add_coercion: term -> Context.generic -> Context.generic
    val add_type_map: term -> Context.generic -> Context.generic
    val coercion_enabled: bool Config.T
    val print_coercions: Proof.context -> unit
  end
structure Subtyping: SUBTYPING
### ML warning (line 70 of "~~/src/Tools/case_product.ML"):
### Pattern is not exhaustive.
signature CASE_PRODUCT =
  sig
    val annotation: thm -> thm -> attribute
    val combine: Proof.context -> thm -> thm -> thm
    val combine_annotated: Proof.context -> thm -> thm -> thm
  end
structure Case_Product: CASE_PRODUCT
val it = "extraction": string
val it = "quickcheck_random": string
val it = "quickcheck_exhaustive": string
val it = "quickcheck_bounded_forall": string
val it = "quickcheck_full_exhaustive": string
val it = "quickcheck_narrowing": string
val it = "quickcheck": string
### Introduced fixed type variable(s): 'a, 'b in "P" or "a" or "f" or "g" or "s" or "t"
class default = type +
  fixes default :: "'a"
val cong_tac = fn: Proof.context -> int -> tactic
### Introduced fixed type variable(s): 'a in "x" or "y"
### ML warning (line 421 of "~~/src/HOL/Tools/hologic.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 449 of "~~/src/HOL/Tools/hologic.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 475 of "~~/src/HOL/Tools/hologic.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 474 of "~~/src/HOL/Tools/hologic.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 474 of "~~/src/HOL/Tools/hologic.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 664 of "~~/src/HOL/Tools/hologic.ML"):
### Matches are not exhaustive.
signature HOLOGIC =
  sig
    val Collect_const: typ -> term
    val Not: term
    val Suc_zero: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val add_numerals: term -> (term * typ) list -> (term * typ) list
    val all_const: typ -> term
    val bit0_const: term
    val bit1_const: term
    val boolN: string
    val boolT: typ
    val case_prod_const: typ * typ * typ -> term
    val charT: typ
    val choice_const: typ -> term
    val class_equal: string
    val class_size: string
    val code_integerT: typ
    val code_naturalT: typ
    val conj: term
    val conj_conv: conv -> conv -> conv
    val conj_elim: Proof.context -> thm -> thm * thm
    val conj_elims: Proof.context -> thm -> thm list
    val conj_intr: Proof.context -> thm -> thm -> thm
    val conjuncts: term -> term list
    val cons_const: typ -> term
    val dest_Suc: term -> term
    val dest_Trueprop: term -> term
    val dest_bin: string -> typ -> term -> term * term
    val dest_char: term -> int
    val dest_conj: term -> term list
    val dest_disj: term -> term list
    val dest_eq: term -> term * term
    val dest_imp: term -> term * term
    val dest_list: term -> term list
    val dest_literal: term -> string
    val dest_mem: term -> term * term
    val dest_nat: term -> int
    val dest_not: term -> term
    val dest_number: term -> typ * int
    val dest_numeral: term -> int
    val dest_prod: term -> term * term
    val dest_prodT: typ -> typ * typ
    val dest_set: term -> term list
    val dest_setT: typ -> typ
    val dest_string: term -> string
    val disj: term
    val disjuncts: term -> term list
    val eq_const: typ -> term
    val eq_conv: conv -> conv -> conv
    val exists_const: typ -> term
    val flat_tupleT_paths: typ -> int list list
    val flat_tuple_paths: term -> int list list
    val flatten_tupleT: typ -> typ list
    val id_const: typ -> term
    val imp: term
    val intT: typ
    val is_unit: term -> bool
    val is_unitT: typ -> bool
    val is_zero: term -> bool
    val listT: typ -> typ
    val list_all: (string * typ) list * term -> term
    val literalT: typ
    val mk_Collect: string * typ * term -> term
    val mk_ST:
       ((term * typ) * (string * typ) option) list ->
         term -> typ -> typ option * typ -> term
    val mk_Suc: term -> term
    val mk_Trueprop: term -> term
    val mk_UNIV: typ -> term
    val mk_all: string * typ * term -> term
    val mk_binop: string -> term * term -> term
    val mk_binrel: string -> term * term -> term
    val mk_case_prod: term -> term
    val mk_char: int -> term
    val mk_comp: term * term -> term
    val mk_conj: term * term -> term
    val mk_disj: term * term -> term
    val mk_eq: term * term -> term
    val mk_exists: string * typ * term -> term
    val mk_fst: term -> term
    val mk_imp: term * term -> term
    val mk_induct_forall: typ -> term
    val mk_list: typ -> term list -> term
    val mk_literal: string -> term
    val mk_mem: term * term -> term
    val mk_nat: int -> term
    val mk_not: term -> term
    val mk_number: typ -> int -> term
    val mk_numeral: int -> term
    val mk_obj_eq: thm -> thm
    val mk_prod: term * term -> term
    val mk_prodT: typ * typ -> typ
    val mk_ptuple: int list list -> typ -> term list -> term
    val mk_ptupleT: int list list -> typ list -> typ
    val mk_ptupleabs: int list list -> typ -> typ -> term -> term
    val mk_random: typ -> term -> term
    val mk_return: typ -> typ -> term -> term
    val mk_set: typ -> term list -> term
    val mk_setT: typ -> typ
    val mk_snd: term -> term
    val mk_string: string -> term
    val mk_term_of: typ -> term -> term
    val mk_tuple: term list -> term
    val mk_tupleT: typ list -> typ
    val mk_typerep: typ -> term
    val mk_valtermify_app: string -> (string * typ) list -> typ -> term
    val natT: typ
    val nil_const: typ -> term
    val numeral_const: typ -> term
    val one_const: term
    val pair_const: typ -> typ -> term
    val realT: typ
    val reflect_term: term -> term
    val size_const: typ -> term
    val stringT: typ
    val strip_ptuple: int list list -> term -> term list
    val strip_ptupleT: int list list -> typ -> typ list
    val strip_ptupleabs: term -> term * typ list * int list list
    val strip_tuple: term -> term list
    val strip_tupleT: typ -> typ list
    val termT: typ
    val term_of_const: typ -> term
    val tupled_lambda: term -> term -> term
    val unit: term
    val unitT: typ
    val zero: term
  end
structure HOLogic: HOLOGIC
### ML warning (line 309 of "~~/src/HOL/Tools/rewrite_hol_proof.ML"):
### Value identifier (prfT) has not been referenced.
### ML warning (line 316 of "~~/src/HOL/Tools/rewrite_hol_proof.ML"):
### Value identifier (xs) has not been referenced.
### ML warning (line 316 of "~~/src/HOL/Tools/rewrite_hol_proof.ML"):
### Value identifier (Ts) has not been referenced.
### ML warning (line 346 of "~~/src/HOL/Tools/rewrite_hol_proof.ML"):
### Value identifier (hs) has not been referenced.
signature REWRITE_HOL_PROOF =
  sig
    val elim_cong:
       typ list -> term option list -> proof -> (proof * proof) option
    val rews: (proof * proof) list
  end
structure Rewrite_HOL_Proof: REWRITE_HOL_PROOF
structure Hypsubst: HYPSUBST
val blast_hyp_subst_tac = fn: Proof.context -> bool -> int -> tactic
val hyp_subst_thin =
   Config
    {get_value = fn, map_value = fn, name = "hypsubst_thin", pos =
     {line=223, offset=9566, end_offset=9579,
       file=~~/src/Provers/hypsubst.ML, id=218}}:
   bool Config.T
val hyp_subst_tac_thin = fn: bool -> Proof.context -> int -> tactic
val bound_hyp_subst_tac = fn: Proof.context -> int -> tactic
val stac = fn: Proof.context -> thm -> int -> tactic
val hyp_subst_tac = fn: Proof.context -> int -> tactic
structure Classical: CLASSICAL
structure Basic_Classical: BASIC_CLASSICAL
type wrapper = (int -> tactic) -> int -> tactic
type claset
val addSEs = fn: Proof.context * thm list -> Proof.context
val addSIs = fn: Proof.context * thm list -> Proof.context
val print_claset = fn: Proof.context -> unit
val best_tac = fn: Proof.context -> int -> tactic
val inst0_step_tac = fn: Proof.context -> int -> tactic
val swap_res_tac = fn: Proof.context -> thm list -> int -> tactic
val clarify_tac = fn: Proof.context -> int -> tactic
val unsafe_step_tac = fn: Proof.context -> int -> tactic
val astar_tac = fn: Proof.context -> int -> tactic
val dup_intr = fn: thm -> thm
val addafter = fn:
   Proof.context * (string * (Proof.context -> int -> tactic)) ->
     Proof.context
val addDs = fn: Proof.context * thm list -> Proof.context
val deepen_tac = fn: Proof.context -> int -> int -> tactic
val safe_step_tac = fn: Proof.context -> int -> tactic
val slow_best_tac = fn: Proof.context -> int -> tactic
val slow_tac = fn: Proof.context -> int -> tactic
val addSD2 = fn: Proof.context * (string * thm) -> Proof.context
val addSE2 = fn: Proof.context * (string * thm) -> Proof.context
val slow_astar_tac = fn: Proof.context -> int -> tactic
val first_best_tac = fn: Proof.context -> int -> tactic
val put_claset = fn: claset -> Proof.context -> Proof.context
val addD2 = fn: Proof.context * (string * thm) -> Proof.context
val appSWrappers = fn: Proof.context -> wrapper
val addEs = fn: Proof.context * thm list -> Proof.context
val inst_step_tac = fn: Proof.context -> int -> tactic
val mp_tac = fn: Proof.context -> int -> tactic
val eq_mp_tac = fn: Proof.context -> int -> tactic
val contr_tac = fn: Proof.context -> int -> tactic
val addSbefore = fn:
   Proof.context * (string * (Proof.context -> int -> tactic)) ->
     Proof.context
val addbefore = fn:
   Proof.context * (string * (Proof.context -> int -> tactic)) ->
     Proof.context
val addSWrapper = fn:
   Proof.context * (string * (Proof.context -> wrapper)) -> Proof.context
val delSWrapper = fn: Proof.context * string -> Proof.context
val addIs = fn: Proof.context * thm list -> Proof.context
val safe_tac = fn: Proof.context -> tactic
val dup_step_tac = fn: Proof.context -> int -> tactic
val addE2 = fn: Proof.context * (string * thm) -> Proof.context
val map_theory_claset = fn:
   (Proof.context -> Proof.context) -> theory -> theory
val addSafter = fn:
   Proof.context * (string * (Proof.context -> int -> tactic)) ->
     Proof.context
val dup_elim = fn: Proof.context -> thm -> thm
val fast_tac = fn: Proof.context -> int -> tactic
val swapify = fn: thm list -> thm list
val appWrappers = fn: Proof.context -> wrapper
val depth_tac = fn: Proof.context -> int -> int -> tactic
val safe_steps_tac = fn: Proof.context -> int -> tactic
val delrules = fn: Proof.context * thm list -> Proof.context
val step_tac = fn: Proof.context -> int -> tactic
val instp_step_tac = fn: Proof.context -> int -> tactic
val slow_step_tac = fn: Proof.context -> int -> tactic
val clarify_step_tac = fn: Proof.context -> int -> tactic
val claset_of = fn: Proof.context -> claset
val delWrapper = fn: Proof.context * string -> Proof.context
val addWrapper = fn:
   Proof.context * (string * (Proof.context -> wrapper)) -> Proof.context
val addSDs = fn: Proof.context * thm list -> Proof.context
val HOL_cs =
   CS {dup_netpair =
       (Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms = {}, comb =
                          Net {atoms =
                               {("HOL.Ex",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [(999999, (false, "..."))]})},
                               comb = Leaf [], var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []},
        Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms = {}, comb =
                          Net {atoms =
                               {("HOL.All",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [(999997, (true, "..."))]}),
                                 ("HOL.Not",
                                   Net {atoms = {}, comb =
  Net {atoms = {("HOL.Ex", Net {atoms = {}, ...})}, comb = Leaf [], var =
       Leaf []},
  var = Leaf []})},
                               comb = Leaf [], var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []}),
       extra_netpair =
       (Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms =
                          {("HOL.True", Leaf [((0, ~6), (false, "True"))])},
                          comb =
                          Net {atoms =
                               {("HOL.Ex",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [((1, ~1), (false, "..."))]}),
                                 ("HOL.All",
                                   Net {atoms = {}, comb = Leaf [], var =
  Leaf [((0, ~14), (false, ...))]}),
                                 ("HOL.Ex1",
                                   Net {atoms = {}, comb = Leaf [], var =
  Leaf [((0, ~13), (false, ...))]}),
                                 ("HOL.Not",
                                   Net {atoms = {}, comb = Leaf [], var =
  Leaf [((0, ~2), (false, "(?P ==> False) ==> ~ ?P"))]})},
                               comb =
                               Net {atoms =
                                    {("HOL.eq",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
("HOL.conj",
  Net {atoms = {}, comb = Leaf [], var =
       Net {atoms = {}, comb = ..., var = ...}}),
("HOL.disj",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
("HOL.implies", Net {atoms = {}, comb = ..., var = ...})},
                                    comb = Leaf [], var = Leaf []},
                               var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []},
        Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms =
                          {("HOL.False",
                             Leaf [((0, ~9), (true, "False ==> ?P"))])},
                          comb =
                          Net {atoms =
                               {("HOL.Ex",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [((0, ~15), (true, "..."))]}),
                                 ("HOL.All",
                                   Net {atoms = {}, comb = Leaf [], var =
  Leaf [((1, ~2), (true, ...))]})},
                               comb =
                               Net {atoms =
                                    {("HOL.eq",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
("HOL.conj",
  Net {atoms = {}, comb = Leaf [], var =
       Net {atoms = {}, comb = ..., var = ...}}),
("HOL.disj",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
("HOL.implies", Net {atoms = {}, comb = ..., var = ...})},
                                    comb = Leaf [], var = Leaf []},
                               var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []}),
       safe0_netpair =
       (Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms =
                          {("HOL.True", Leaf [(~11, (false, "True"))])},
                          comb =
                          Net {atoms = {}, comb =
                               Net {atoms =
                                    {("HOL.eq",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}})},
                                    comb = Leaf [], var = Leaf []},
                               var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []},
        Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms =
                          {("HOL.False",
                             Leaf [(~16, (true, "False ==> ?P"))])},
                          comb =
                          Net {atoms =
                               {("HOL.Not",
                                  Net {atoms =
 {("HOL.True", Leaf [(~12, (true, ...))])}, comb =
 Net {atoms = {}, comb =
      Net {atoms = {("HOL.eq", ...)}, comb = Leaf [...], var = Leaf [...]},
      var = Leaf []},
 var = Leaf []})},
                               comb = Leaf [], var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []}),
       safeEs =
       Items
        {content =
         [("[| EX x. ?P x; !!x. ?P x ==> ?Q |] ==> ?Q",
           ("[| EX x. ?P x; !!x. ?P x ==> ?Q |] ==> ?Q", []),
           ("[| EX x. ?P x; !!x. ?P x ==> ?Q |] ==> ?Q", [])),
          ("[| ?P & ?Q; [| ?P; ?Q |] ==> ?R |] ==> ?R",
           ("[| ?P & ?Q; [| ?P; ?Q |] ==> ?R |] ==> ?R", []),
           ("[| ?P & ?Q; [| ?P; ?Q |] ==> ?R |] ==> ?R", [])),
          ("[| ?P | ?Q; ?P ==> ?R; ?Q ==> ?R |] ==> ?R",
           ("[| ?P | ?Q; ?P ==> ?R; ?Q ==> ?R |] ==> ?R", []),
           ("[| ?P | ?Q; ?P ==> ?R; ?Q ==> ?R |] ==> ?R", [])),
          ("[| ?P --> ?Q; ~ ?P ==> ?R; ?Q ==> ?R |] ==> ?R",
           ("[| ?P --> ?Q; ~ ?P ==> ?R; ?Q ==> ?R |] ==> ?R", []),
           ("[| ?P --> ?Q; ~ ?P ==> ?R; ?Q ==> ?R |] ==> ?R", [])),
          ("False ==> ?P", ("False ==> ?P", []), ("False ==> ?P", [])),
          ("[| ?P = ?Q; [| ?P; ?Q |] ==> ?R; [| ~ ?P; ~ ?Q |] ==> ?R |]
            ==> ?R",
           ("[| ?P = ?Q; [| ?P; ?Q |] ==> ?R; [| ... ?P; ... ?Q |] ==> ?R |]
             ==> ?R",
            []),
           ("[| ?P = ?Q; [| ?P; ?Q |] ==> ?R; [| ... ?P; ... ?Q |] ==> ?R |]
             ==> ?R",
            []))],
         eq = fn, index = fn, net =
         Net {atoms = {}, comb =
              Net {atoms = {}, comb =
                   Net {atoms =
                        {("Pure.imp",
                           Net {atoms = {}, comb =
                                Net {atoms =
                                     {("HOL.Trueprop",
  Net {atoms = {("HOL.False", Net {atoms = {}, ...})}, comb =
       Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []})},
                                     comb = Leaf [], var = Leaf []},
                                var = Leaf []})},
                        comb = Leaf [], var = Leaf []},
                   var = Leaf []},
              var = Leaf []},
         next = ~7},
       safeIs =
       Items
        {content =
         [("(!!x. ?P x) ==> ALL x. ?P x",
           ("(!!x. ?P x) ==> ALL x. ?P x",
            ["[| ~ (ALL x. ?P1 x); !!x. ~ ?R ==> ?P1 x |] ==> ?R"]),
           ("(!!x. ?P x) ==> ALL x. ?P x",
            ["[| ~ (ALL x. ?P1 x); !!x. ~ ?R ==> ?P1 x |] ==> ?R"])),
          ("[| EX x. ?P x; !!x y. [| ?P x; ?P y |] ==> x = y |]
            ==> EX! x. ?P x",
           ("[| EX x. ?P x; !!x y. [| ?P x; ?P y |] ==> x = y |]
             ==> EX! x. ?P x",
            ["[| \<nexists>!x. ?P1 x; ~ ?R ==> EX x. ?P1 x;
                 !!x y. [| ~ ?R; ?P1 x; ?P1 y |] ==> x = y |]
              ==> ?R"]),
           ("[| EX x. ?P x; !!x y. [| ?P x; ?P y |] ==> x = y |]
             ==> EX! x. ?P x",
            ["[| \<nexists>!x. ?P1 x; ~ ?R ==> EX x. ?P1 x;
                 !!x y. [| ~ ?R; ?P1 x; ?P1 y |] ==> x = y |]
              ==> ?R"])),
          ("?t = ?t", ("?t = ?t", ["?t1 ~= ?t1 ==> ?R"]),
           ("?t = ?t", ["?t1 ~= ?t1 ==> ?R"])),
          ("True", ("True", ["~ True ==> ?R"]),
           ("True", ["~ True ==> ?R"])),
          ("[| ?P; ?Q |] ==> ?P & ?Q",
           ("[| ?P; ?Q |] ==> ?P & ?Q",
            ["[| ~ (?P1 & ?Q1); ~ ?R ==> ?P1; ~ ?R ==> ?Q1 |] ==> ?R"]),
           ("[| ?P; ?Q |] ==> ?P & ?Q",
            ["[| ~ (?P1 & ?Q1); ~ ?R ==> ?P1; ~ ?R ==> ?Q1 |] ==> ?R"])),
          ("(~ ?Q ==> ?P) ==> ?P | ?Q",
           ("(~ ?Q ==> ?P) ==> ?P | ?Q",
            ["[| ~ (?P1 ... ?Q1); [| ... ?R; ... ?Q1 |] ==> ?P1 |]
              ==> ?R"]),
           ("(~ ?Q ==> ?P) ==> ?P | ?Q",
            ["[| ~ (?P1 ... ?Q1); [| ... ?R; ... ?Q1 |] ==> ?P1 |]
              ==> ?R"])),
          ("(?P ==> ?Q) ==> ?P --> ?Q",
           ("(?P ==> ?Q) ==> ?P --> ?Q",
            ["[| ~ (... ... ...); [| ... ...; ... |] ==> ?Q1 |] ==> ?R"]),
           ("(?P ==> ?Q) ==> ?P --> ?Q",
            ["[| ~ (... ... ...); [| ... ...; ... |] ==> ?Q1 |] ==> ?R"])),
          ("(?P ==> False) ==> ~ ?P",
           ("(... ... ...) ==> ~ ?P",
            ["[| ... ... ?P1; ... ...... ... ... ==> ... |] ==> ?R"]),
           ("(... ... ...) ==> ~ ?P",
            ["[| ... ... ?P1; ... ...... ... ... ==> ... |] ==> ?R"])),
          ("[| ... ... ...; ... ... ... |] ==> ?P ... ?Q",
           ("[| ... ... ...; ... ... ... |] ==> ... ... ...",
            ["[| ...; ... ... ...; ... ... ... |] ==> ?R"]),
           ("[| ... ... ...; ... ... ... |] ==> ... ... ...",
            ["[| ...; ... ... ...; ... ... ... |] ==> ?R"]))],
         eq = fn, index = fn, net =
         Net {atoms = {}, comb =
              Net {atoms =
                   {("HOL.Trueprop",
                      Net {atoms =
                           {("HOL.True",
                              Leaf
                               [(~6,
                                 ("True", ("...", ["... ... ..."]),
                                  ("...", ["... ... ..."])))])},
                           comb =
                           Net {atoms = {}, comb =
                                Net {atoms =
                                     {("HOL.eq",
  Net {atoms = {}, comb = Leaf [], var =
       Net {atoms = {}, comb = ..., var = ...}})},
                                     comb = Leaf [], var = Leaf []},
                                var = Leaf []},
                           var = Leaf []})},
                   comb =
                   Net {atoms =
                        {("Pure.imp",
                           Net {atoms = {}, comb =
                                Net {atoms =
                                     {("Pure.all",
  Net {atoms = {}, comb = Leaf [], var =
       Net {atoms = {}, comb = ..., var = ...}}),
 ("HOL.Trueprop",
   Net {atoms = {}, comb = Net {atoms = {...}, ...}, var =
        Net {atoms = {}, ...}})},
                                     comb =
                                     Net
{atoms = {("Pure.imp", Net {atoms = {}, comb = ..., var = ...})}, comb =
 Leaf [], var = Leaf []},
                                     var = Leaf []},
                                var = Leaf []})},
                        comb = Leaf [], var = Leaf []},
                   var = Leaf []},
              var = Leaf []},
         next = ~10},
       safep_netpair =
       (Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms = {}, comb =
                          Net {atoms =
                               {("HOL.All",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [(999978, (false, "..."))]}),
                                 ("HOL.Ex1",
                                   Net {atoms = {}, comb = Leaf [], var =
  Leaf [(1999980, (false, ...))]}),
                                 ("HOL.Not",
                                   Net {atoms = {}, comb = Leaf [], var =
  Leaf [(999997, (false, ...))]})},
                               comb =
                               Net {atoms =
                                    {("HOL.eq",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
("HOL.conj",
  Net {atoms = {}, comb = Leaf [], var =
       Net {atoms = {}, comb = ..., var = ...}}),
("HOL.disj",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
("HOL.implies", Net {atoms = {}, comb = ..., var = ...})},
                                    comb = Leaf [], var = Leaf []},
                               var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []},
        Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms = {}, comb =
                          Net {atoms =
                               {("HOL.Ex",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [(999976, (true, "..."))]}),
                                 ("HOL.Not",
                                   Net {atoms = {}, comb =
  Net {atoms = {("HOL.All", Net {atoms = {}, ...}), ("HOL.Ex1", ...), ...},
       comb = Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
  var = Leaf []})},
                               comb =
                               Net {atoms =
                                    {("HOL.eq",
 Net {atoms = {}, comb = Leaf [], var =
      Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
("HOL.conj",
  Net {atoms = {}, comb = Leaf [], var =
       Net {atoms = {}, comb = ..., var = ...}}),
("HOL.disj",
  Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
("HOL.implies", Net {atoms = {}, comb = ..., var = ...})},
                                    comb = Leaf [], var = Leaf []},
                               var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []}),
       swrappers = [], unsafeEs =
       Items
        {content =
         [("[| ALL x. ?P x; ?P ?x ==> ?R |] ==> ?R",
           ("[| ALL x. ?P x; ?P ?x ==> ?R |] ==> ?R", []),
           ("[| ALL x. ?P x; [| ?P ?x; ALL x. ?P x |] ==> ?R |] ==> ?R",
            []))],
         eq = fn, index = fn, net =
         Net {atoms = {}, comb =
              Net {atoms = {}, comb =
                   Net {atoms =
                        {("Pure.imp",
                           Net {atoms = {}, comb =
                                Net {atoms =
                                     {("HOL.Trueprop",
  Net {atoms = {}, comb = Net {atoms = {...}, comb = ..., var = ...}, var =
       Leaf []})},
                                     comb = Leaf [], var = Leaf []},
                                var = Leaf []})},
                        comb = Leaf [], var = Leaf []},
                   var = Leaf []},
              var = Leaf []},
         next = ~2},
       unsafeIs =
       Items
        {content =
         [("?P ?x ==> EX x. ?P x",
           ("?P ?x ==> EX x. ?P x",
            ["[| \<nexists>x. ?P1 x; ~ ?R ==> ?P1 ?x1 |] ==> ?R"]),
           ("(\<nexists>x. ?P x ==> ?P ?x) ==> EX x. ?P x",
            ["[| \<nexists>x. ?P1 x;
                 [| ~ ?R; \<nexists>x. ?P1 x |] ==> ?P1 ?x1 |]
              ==> ?R"]))],
         eq = fn, index = fn, net =
         Net {atoms = {}, comb =
              Net {atoms = {}, comb =
                   Net {atoms =
                        {("Pure.imp",
                           Net {atoms = {}, comb =
                                Net {atoms =
                                     {("HOL.Trueprop",
  Net {atoms = {}, comb = Leaf [], var =
       Net {atoms = {}, comb = ..., var = ...}})},
                                     comb = Leaf [], var = Leaf []},
                                var = Leaf []})},
                        comb = Leaf [], var = Leaf []},
                   var = Leaf []},
              var = Leaf []},
         next = ~2},
       unsafe_netpair =
       (Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms = {}, comb =
                          Net {atoms =
                               {("HOL.Ex",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [(999999, (false, "..."))]})},
                               comb = Leaf [], var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []},
        Net {atoms = {}, comb =
             Net {atoms =
                  {("HOL.Trueprop",
                     Net {atoms = {}, comb =
                          Net {atoms =
                               {("HOL.All",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [(999997, (true, "..."))]}),
                                 ("HOL.Not",
                                   Net {atoms = {}, comb =
  Net {atoms = {("HOL.Ex", Net {atoms = {}, ...})}, comb = Leaf [], var =
       Leaf []},
  var = Leaf []})},
                               comb = Leaf [], var = Leaf []},
                          var = Leaf []})},
                  comb = Leaf [], var = Leaf []},
             var = Leaf []}),
       uwrappers = []}:
   claset
structure Blast: BLAST
val blast_tac = fn: Proof.context -> int -> tactic
### ML warning (line 106 of "~~/src/HOL/Tools/simpdata.ML"):
### Matches are not exhaustive.
structure Quantifier1: QUANTIFIER1
structure Simpdata:
  sig
    structure Clasimp: CLASIMP
    val HOL_basic_ss: simpset
    structure Splitter: SPLITTER
    val addSss: Proof.context -> Proof.context
    val addss: Proof.context -> Proof.context
    val auto_tac: Proof.context -> tactic
    val best_simp_tac: Proof.context -> int -> tactic
    val clarsimp_tac: Proof.context -> int -> tactic
    val clasimp_modifiers: Method.modifier parser list
    val fast_force_tac: Proof.context -> int -> tactic
    val force_tac: Proof.context -> int -> tactic
    val hol_simplify: Proof.context -> thm list -> thm -> thm
    val iff_add: attribute
    val iff_add': attribute
    val iff_del: attribute
    val iff_modifiers: Method.modifier parser list
    val lift_meta_eq_to_obj_eq: Proof.context -> int -> thm -> thm
    val mk_atomize:
       Proof.context -> (string * thm list) list -> thm -> thm list
    val mk_auto_tac: Proof.context -> int -> int -> tactic
    val mk_eq: thm -> thm
    val mk_eq_True: Proof.context -> thm -> thm option
    val mk_meta_cong: Proof.context -> thm -> thm
    val mk_meta_eq: thm -> thm
    val mksimps:
       (string * thm list) list -> Proof.context -> thm -> thm list
    val mksimps_pairs: (string * thm list) list
    val safe_mk_meta_eq: thm -> thm
    val safe_solver: solver
    val safe_solver_tac: Proof.context -> int -> tactic
    val slow_simp_tac: Proof.context -> int -> tactic
    val split_inside_tac: Proof.context -> thm list -> int -> tactic
    val split_tac: Proof.context -> thm list -> int -> tactic
    val unfold_tac: Proof.context -> thm list -> tactic
    val unsafe_solver: solver
    val unsafe_solver_tac: Proof.context -> int -> tactic
  end
structure Splitter: SPLITTER
structure Clasimp: CLASIMP
structure Clasimp: CLASIMP
structure Splitter: SPLITTER
val mk_eq_True = fn: Proof.context -> thm -> thm option
val force_tac = fn: Proof.context -> int -> tactic
val mk_atomize = fn:
   Proof.context -> (string * thm list) list -> thm -> thm list
val clarsimp_tac = fn: Proof.context -> int -> tactic
val fast_force_tac = fn: Proof.context -> int -> tactic
val iff_add = fn: attribute
val best_simp_tac = fn: Proof.context -> int -> tactic
val HOL_basic_ss =
   Simpset
    ({depth = (0, ref false), prems = [], rules = Leaf []},
     {congs = ({}, []), loop_tacs = [], mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs = Leaf [], solvers =
      ([Solver {id = Stamp 890442, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 890444, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val iff_del = fn: attribute
val mk_auto_tac = fn: Proof.context -> int -> int -> tactic
val mk_meta_eq = fn: thm -> thm
val unsafe_solver =
   Solver {id = Stamp 890442, name = "HOL unsafe", solver = fn}: solver
val mk_eq = fn: thm -> thm
val iff_modifiers = [fn, fn, fn]: Method.modifier parser list
val unsafe_solver_tac = fn: Proof.context -> int -> tactic
val iff_add' = fn: attribute
val slow_simp_tac = fn: Proof.context -> int -> tactic
val mksimps_pairs =
   [("HOL.implies", ["[| ?P --> ?Q; ?P |] ==> ?Q"]),
    ("HOL.conj", ["?P & ?Q ==> ?P", "?P & ?Q ==> ?Q"]),
    ("HOL.All", ["ALL x. ?P x ==> ?P ?x"]), ("HOL.True", []),
    ("HOL.False", []),
    ("HOL.If",
     ["if ?P1 then ?Q1 else ?R1 ==> (?P1 --> ?Q1) & (~ ?P1 --> ?R1)"])]:
   (string * thm list) list
val split_tac = fn: Proof.context -> thm list -> int -> tactic
val clasimp_modifiers =
   [fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn,
    fn, fn, ...]:
   Method.modifier parser list
val addSss = fn: Proof.context -> Proof.context
val safe_mk_meta_eq = fn: thm -> thm
val split_inside_tac = fn: Proof.context -> thm list -> int -> tactic
val auto_tac = fn: Proof.context -> tactic
val safe_solver =
   Solver {id = Stamp 890444, name = "HOL safe", solver = fn}: solver
val hol_simplify = fn: Proof.context -> thm list -> thm -> thm
val addss = fn: Proof.context -> Proof.context
val mk_meta_cong = fn: Proof.context -> thm -> thm
val safe_solver_tac = fn: Proof.context -> int -> tactic
val unfold_tac = fn: Proof.context -> thm list -> tactic
val mksimps = fn:
   (string * thm list) list -> Proof.context -> thm -> thm list
val lift_meta_eq_to_obj_eq = fn: Proof.context -> int -> thm -> thm
val eliminate_false_implies = fn: cterm -> thm option
val HOL_ss =
   Simpset
    ({depth = (0, ref false), prems = [], rules =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb =
                        Net {atoms =
                             {("HOL.eq",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[{elhs = "... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Abs ("...", "?'d1", ...), name = "HOL.simp_thms_38",
  ...}]})},
                             comb = Leaf [], var = Leaf []},
                        var =
                        Leaf
                         [{elhs = "EX x. ?t1 = x & ?P1 x", extra = false,
                           fo = false, lhs =
                           Const ("HOL.Ex", "(... ... ...) => bool") $
                             Abs ("x", "?'d1",
                               Const ("...", ...) $ (... $ ... $ ...) $
                                 ...),
                           name = "HOL.simp_thms_40", perm = false, thm =
                           "EX x. ?t1 ... x & ?P1 x == ?P1 ?t1"},
                          {elhs = "EX x. x = ?t1 & ?P1 x", extra = false,
                           fo = false, lhs =
                           Const ("HOL.Ex", "(...) ... bool") $
                             Abs ("x", "?'d1",
                               Const ("...", "bool => bool => bool") $ ... $
                                 ...),
                           name = "HOL.simp_thms_39", perm = false, thm =
                           "EX x. ... ... ... ... ... ... == ?P1 ?t1"},
                          {elhs = "EX x. x = ?t1", extra = false, fo = true,
                           lhs =
                           Const ("HOL.Ex", "... ... ...") $
                             Abs ("x", "...", ... $ ... $ ...),
                           name = "HOL.simp_thms_37", perm = false, thm =
                           "... x... ... ... ... == True"},
                          {elhs = "EX x. ?y", extra = false, fo = true,
                           lhs =
                           Const ("HOL.Ex", "...") $ Abs ("x", "...", ...),
                           name = "HOL.simp_thms_36", perm = false, thm =
                           "... ...... ... ... ?y"},
                          {elhs = "... x... ... ... ...", extra = false,
                           fo = false, lhs =
                           Const ("HOL.Ex", "...") $ Abs ("x", ..., ...),
                           name = "HOL.ex_simps_6", perm = false, thm =
                           "... ... ..."},
                          {elhs = "... ...... ...", extra = false, fo =
                           false, lhs =
                           Const ("...", ...) $ Abs ("...", "?'e1", ...),
                           name = "HOL.ex_simps_5", ...},
                          {elhs = "...", extra = false, fo = false, lhs =
                           Const ("...", "(?'d1 => bool) => bool") $ ...,
                           ...},
                          {elhs = "...", extra = false, fo = false, ...},
                          {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "ALL x. ?t1 ~= x", extra = false, fo =
                            true, lhs =
                            Const ("HOL.All", "(...) ... bool") $
                              Abs ("x", "?'d1",
                                Const ("...", "bool => bool") $ ...),
                            name = "HOL.simp_thms_44", perm = false, thm =
                            "ALL x. ?t1 ... x == False"},
                           {elhs = "ALL x. x ~= ?t1", extra = false, fo =
                            true, lhs =
                            Const ("HOL.All", "... ... ...") $
                              Abs ("x", "...", ... $ ...),
                            name = "HOL.simp_thms_43", perm = false, thm =
                            "... x... ... ... ... == False"},
                           {elhs = "ALL x. ... ... ... ... ... ...", extra =
                            false, fo = false, lhs =
                            Const ("HOL.All", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.simp_thms_42", perm = false, thm =
                            "... ...... ... ... ... ..."},
                           {elhs = "... x... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("HOL.All", "...") $ Abs ("x", ..., ...),
                            name = "HOL.simp_thms_41", perm = false, thm =
                            "... ... ..."},
                           {elhs = "... ...... ...", extra = false, fo =
                            true, lhs =
                            Const ("...", ...) $ Abs ("...", "?'b1", ...),
                            name = "HOL.simp_thms_35", ...},
                           {elhs = "...", extra = false, fo = false, lhs =
                            Const ("...", "(?'f1 => bool) => bool") $ ...,
                            ...},
                           {elhs = "...", extra = false, fo = false, ...},
                           {elhs = ..., extra = false, ...}, ...]}),
                  ("HOL.Not",
                    Net {atoms =
                         {("HOL.True",
                            Leaf
                             [{elhs = "~ True", extra = false, fo = true,
                               lhs =
                               Const ("HOL.Not", "...") $
                                 Const ("HOL.True", "..."),
                               name = "HOL.simp_thms_7", perm = false, thm =
                               "... True ... False"}]),
                           ("HOL.False",
                             Leaf
                              [{elhs = "~ False", extra = false, fo = true,
                                lhs =
                                Const ("HOL.Not", "...") $
                                  Const ("...", ...),
                                name = "HOL.simp_thms_8", perm = false,
                                thm = "... ... ... ..."}])},
                         comb =
                         Net {atoms =
                              {("HOL.Ex",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = "...", extra = false, fo = true, ...}]}),
                                ("HOL.All",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = ..., extra = false, ...}]}),
                                ("HOL.Not",
                                  Net {atoms = {}, comb = Leaf [...], var =
 Leaf [...]})},
                              comb =
                              Net {atoms =
                                   {("HOL.eq",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}}),
                                     ("HOL.conj",
 Net {atoms = {}, comb = ..., var = ...}),
                                     ("HOL.disj", Net {atoms = {}, ...}),
                                     ("HOL.implies", ...)},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []},
                         var = Leaf []}),
                  ("HOL.The",
                    Net {atoms = {}, comb =
                         Net {atoms =
                              {("HOL.eq",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = ..., extra = false, ...}]})},
                              comb = Leaf [], var = Leaf []},
                         var =
                         Leaf
                          [{elhs = "THE x. x ... ?y", extra = false, fo =
                            true, lhs =
                            Const ("HOL.The", "...") $
                              Abs ("x", "...", ...),
                            name = "HOL.the_eq_trivial", perm = false, thm =
                            "... ...... ... ... ?y"}]}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [{elhs = "...x... ... ... ... ...", extra = false,
                            fo = false, lhs =
                            Const ("Pure.all", "...") $ Abs ("x", ..., ...),
                            name = "HOL.subst_all_2", perm = false, thm =
                            "... ... ... ..."},
                           {elhs = "......... ...", extra = false, fo =
                            false, lhs =
                            Const ("...", ...) $ Abs ("...", "?'a", ...),
                            name = "HOL.subst_all_1", ...},
                           {elhs = "...", extra = false, fo = true, lhs =
                            Const ("...", "(?'a => prop) => prop") $ ...,
                            ...}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms =
                             {("HOL.True",
                                Net {atoms = {}, comb = Leaf [], var =
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Const ("...", "bool") $ ..., name =
  "HOL.simp_thms_11", ...}]}),
                               ("HOL.False",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]})},
                             comb =
                             Net {atoms =
                                  {("HOL.Not",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Net {atoms = {...}, ...}, var = Leaf [...]}})},
                                  comb = Leaf [], var = Leaf []},
                             var =
                             Net {atoms =
                                  {("HOL.True",
                                     Leaf
[{elhs = "... ... ...", extra = false, fo = true, lhs =
  Const ("...", ...) $ Var ((...), "bool") $ ..., name = "HOL.simp_thms_12",
  ...}]),
                                    ("HOL.False",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}])},
                                  comb =
                                  Net {atoms =
 {("HOL.Not", Net {atoms = {}, comb = Leaf [...], var = Leaf [...]})},
 comb = Leaf [], var = Leaf []},
                                  var =
                                  Leaf
                                   [{elhs = "?x1 ... ?x1", extra = false,
                                     fo = true, lhs =
                                     Const ("HOL.eq", "...") $
 Var (("...", 1), ...) $ Var ((...), "?'a1"),
                                     name = "HOL.simp_thms_6", perm = false,
                                     thm = "... ... ..."}]}}),
                       ("HOL.conj",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = "...", extra = false, fo = true, ...}]})},
                              comb =
                              Net {atoms =
                                   {("HOL.Not",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                   comb =
                                   Net {atoms =
  {("HOL.conj", Net {atoms = {}, comb = ..., var = ...}),
    ("HOL.implies", Net {atoms = {}, ...})},
  comb = Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True",
Leaf
 [{elhs = "...", extra = false, fo = true, lhs =
   Const ("...", "bool => bool => bool") $ ... $ ..., ...}]),
                                     ("HOL.False",
 Leaf [{elhs = "...", extra = false, fo = true, ...}])},
                                   comb =
                                   Net {atoms =
  {("HOL.Not", Net {atoms = {}, comb = ..., var = ...})}, comb =
  Net {atoms = {("HOL.conj", ...)}, comb = Leaf [...], var = Leaf [...]},
  var = Leaf []},
                                   var =
                                   Leaf
                                    [{elhs = "... ... ...", extra = false,
fo = true, lhs = Const ("...", ...) $ Var ((...), "bool") $ ..., name =
"HOL.simp_thms_25", ...}]}}),
                       ("HOL.disj",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [], var =
Leaf [{elhs = "...", extra = false, fo = true, ...}]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = Leaf [], var =
 Leaf [{elhs = ..., extra = false, ...}]})},
                              comb =
                              Net {atoms =
                                   {("HOL.Not",
Net {atoms = {}, comb = Leaf [...], var = Net {atoms = {}, ...}})},
                                   comb =
                                   Net {atoms =
  {("HOL.disj", Net {atoms = {}, ...}), ("HOL.implies", ...)}, comb =
  Leaf [], var = Leaf []},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True",
Leaf [{elhs = "...", extra = false, fo = true, ...}]),
                                     ("HOL.False",
 Leaf [{elhs = ..., extra = false, ...}])},
                                   comb =
                                   Net {atoms =
  {("HOL.Not", Net {atoms = {}, ...})}, comb =
  Net {atoms = {...}, comb = ..., var = ...}, var = Leaf []},
                                   var =
                                   Leaf
                                    [{elhs = "...", extra = false, fo =
true, lhs = Const ("...", "bool => bool => bool") $ ... $ ..., ...}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {...}, comb = ..., var = ...})},
                                   comb = Leaf [], var = Leaf []},
                              var =
                              Net {atoms = {}, comb =
                                   Net {atoms = {("HOL.Trueprop", ...)},
  comb = Leaf [...], var = Leaf [...]},
                                   var = Leaf []}}),
                       ("HOL.implies",
                         Net {atoms =
                              {("HOL.True",
                                 Net {atoms = {}, comb = Leaf [...], var =
Leaf [...]}),
                                ("HOL.False",
                                  Net {atoms = {}, comb = ..., var = ...})},
                              comb =
                              Net {atoms = {}, comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var = Leaf []},
                              var =
                              Net {atoms =
                                   {("HOL.True", Leaf [...]),
                                     ("HOL.False", ...)},
                                   comb =
                                   Net {atoms = {...}, comb = ..., var =
  ...},
                                   var =
                                   Leaf
                                    [{elhs = ..., extra = false, ...}]}})},
                     comb =
                     Net {atoms =
                          {("HOL.If",
                             Net {atoms =
                                  {("HOL.True",
                                     Net
{atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [...], var = Leaf [...]}}),
                                    ("HOL.False",
Net {atoms = {}, comb = Leaf [], var =
     Net {atoms = {}, comb = ..., var = ...}})},
                                  comb =
                                  Net {atoms = {}, comb =
 Net {atoms = {("HOL.eq", Net {atoms = {}, ...})}, comb = Leaf [], var =
      Leaf []},
 var = Leaf []},
                                  var =
                                  Net {atoms = {}, comb = Leaf [], var =
 Net {atoms = {}, comb = Leaf [], var =
      Leaf [{elhs = ..., extra = false, ...}]}}})},
                          comb = Leaf [], var = Leaf []},
                     var = Leaf []},
                var = Leaf []},
           var = Leaf []}},
     {congs =
      ({((true, "HOL.implies"),
          "[| ?P == ?P'; ?P' ==> ?Q == ?Q' |]
           ==> ?P --> ?Q == ?P' --> ?Q'"),
         ((true, "HOL.simp_implies"),
           "[| PROP ?P == PROP ?P'; PROP ?P' ==> PROP ?Q == PROP ?Q' |]
            ==> (PROP ?P =simp=> PROP ?Q) == (PROP ?P' =simp=> PROP ?Q')")},
       []),
      loop_tacs =
      [("split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun", fn)], mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs =
      Net {atoms = {}, comb =
           Net {atoms =
                {("HOL.Ex",
                   Net {atoms = {}, comb = Leaf [], var =
                        Leaf
                         [Proc
                           {lhs =
                            Const ("HOL.Ex", "(...) ... bool") $
                              Abs ("x", "?'a",
                                Var ((...), "?'a => bool") $ ...),
                            name = "HOL.defined_Ex", proc = fn, stamp =
                            Stamp 890694}]}),
                  ("HOL.All",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("HOL.All", "... ... ...") $
                               Abs ("x", "...", ... $ ...),
                             name = "HOL.defined_All", proc = fn, stamp =
                             Stamp 890740}]}),
                  ("Pure.all",
                    Net {atoms = {}, comb = Leaf [], var =
                         Leaf
                          [Proc
                            {lhs =
                             Const ("Pure.all", "...") $
                               Abs ("x", "...", ...),
                             name = "HOL.defined_all", proc = fn, stamp =
                             Stamp 890786}]})},
                comb =
                Net {atoms =
                     {("HOL.eq",
                        Net {atoms = {}, comb = Leaf [], var =
                             Net {atoms = {}, comb = Leaf [], var =
                                  Leaf
                                   [Proc
                                     {lhs =
Const ("...", ...) $ Var ((...), "?'a") $ ..., name = "HOL.neq", proc = fn,
stamp = Stamp 890896}]}}),
                       ("HOL.Let",
                         Net {atoms = {}, comb = Leaf [], var =
                              Net {atoms = {}, comb = Leaf [], var =
                                   Leaf
                                    [Proc
{lhs = Const ("...", "?'a => (?'a => ?'b) => ?'b") $ ... $ ..., name =
 "HOL.let_simp", proc = fn, stamp = Stamp 891022}]}}),
                       ("Pure.imp",
                         Net {atoms = {}, comb =
                              Net {atoms =
                                   {("HOL.Trueprop",
Net {atoms = {("HOL.False", ...)}, comb = Leaf [...], var = Leaf [...]})},
                                   comb = Leaf [], var = Leaf []},
                              var = Leaf []})},
                     comb = Leaf [], var = Leaf []},
                var = Leaf []},
           var = Leaf []},
      solvers =
      ([Solver {id = Stamp 890442, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 890444, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
structure Project_Rule: PROJECT_RULE
### ML warning (line 416 of "~~/src/Tools/induct.ML"):
### Matches are not exhaustive.
### ML warning (line 685 of "~~/src/Tools/induct.ML"):
### Matches are not exhaustive.
### ML warning (line 725 of "~~/src/Tools/induct.ML"):
### Pattern is not exhaustive.
### ML warning (line 733 of "~~/src/Tools/induct.ML"):
### Pattern is not exhaustive.
### ML warning (line 725 of "~~/src/Tools/induct.ML"):
### Pattern is not exhaustive.
signature INDUCT_ARGS =
  sig
    val atomize: thm list
    val cases_default: thm
    val dest_def: term -> (term * term) option
    val equal_def: thm
    val rulify: thm list
    val rulify_fallback: thm list
    val trivial_tac: Proof.context -> int -> tactic
  end
signature INDUCT =
  sig
    val add_defs:
       (binding option * (term * bool)) option list ->
         Proof.context -> (term option list * thm list) * Proof.context
    val arbitrary_tac:
       Proof.context -> int -> (string * typ) list -> int -> tactic
    val atomize_cterm: Proof.context -> conv
    val atomize_tac: Proof.context -> int -> tactic
    val atomize_term: Proof.context -> term -> term
    val casesN: string
    val cases_context_tactic:
       bool ->
         term option list list ->
           thm option -> thm list -> int -> context_tactic
    val cases_del: attribute
    val cases_pred: string -> attribute
    val cases_tac:
       Proof.context ->
         bool ->
           term option list list -> thm option -> thm list -> int -> tactic
    val cases_type: string -> attribute
    val coinductN: string
    val coinduct_context_tactic:
       term option list ->
         term option list -> thm option -> thm list -> int -> context_tactic
    val coinduct_del: attribute
    val coinduct_pred: string -> attribute
    val coinduct_tac:
       Proof.context ->
         term option list ->
           term option list -> thm option -> thm list -> int -> tactic
    val coinduct_type: string -> attribute
    val dest_rules:
       Proof.context ->
         {pred_cases: (string * thm) list,
          pred_coinduct: (string * thm) list,
          pred_induct: (string * thm) list,
          type_cases: (string * thm) list,
          type_coinduct: (string * thm) list,
          type_induct: (string * thm) list}
    val find_casesP: Proof.context -> term -> thm list
    val find_casesT: Proof.context -> typ -> thm list
    val find_coinductP: Proof.context -> term -> thm list
    val find_coinductT: Proof.context -> typ -> thm list
    val find_inductP: Proof.context -> term -> thm list
    val find_inductT: Proof.context -> typ -> thm list
    val gen_induct_context_tactic:
       ((Rule_Cases.info * int) * thm -> (Rule_Cases.info * int) * thm) ->
         bool ->
           (binding option * (term * bool)) option list list ->
             (string * typ) list list ->
               term option list ->
                 thm list option -> thm list -> int -> context_tactic
    val gen_induct_setup:
       binding ->
         (bool ->
            (binding option * (term * bool)) option list list ->
              (string * typ) list list ->
                term option list ->
                  thm list option -> thm list -> int -> context_tactic)
           -> local_theory -> local_theory
    val gen_induct_tac:
       Proof.context ->
         ((Rule_Cases.info * int) * thm -> (Rule_Cases.info * int) * thm) ->
           bool ->
             (binding option * (term * bool)) option list list ->
               (string * typ) list list ->
                 term option list ->
                   thm list option -> thm list -> int -> tactic
    val get_inductT: Proof.context -> term option list list -> thm list list
    val guess_instance: Proof.context -> thm -> int -> thm -> thm Seq.seq
    val inductN: string
    val induct_context_tactic:
       bool ->
         (binding option * (term * bool)) option list list ->
           (string * typ) list list ->
             term option list ->
               thm list option -> thm list -> int -> context_tactic
    val induct_del: attribute
    val induct_pred: string -> attribute
    val induct_simp_add: attribute
    val induct_simp_del: attribute
    val induct_tac:
       Proof.context ->
         bool ->
           (binding option * (term * bool)) option list list ->
             (string * typ) list list ->
               term option list ->
                 thm list option -> thm list -> int -> tactic
    val induct_type: string -> attribute
    val inner_atomize_tac: Proof.context -> int -> tactic
    val internalize: Proof.context -> int -> thm -> thm
    val lookup_casesP: Proof.context -> string -> thm option
    val lookup_casesT: Proof.context -> string -> thm option
    val lookup_coinductP: Proof.context -> string -> thm option
    val lookup_coinductT: Proof.context -> string -> thm option
    val lookup_inductP: Proof.context -> string -> thm option
    val lookup_inductT: Proof.context -> string -> thm option
    val map_simpset:
       (Proof.context -> Proof.context) ->
         Context.generic -> Context.generic
    val no_simpN: string
    val predN: string
    val print_rules: Proof.context -> unit
    val rotate_tac: int -> int -> int -> tactic
    val rulified_term: Proof.context -> thm -> term
    val rulify_tac: Proof.context -> int -> tactic
    val setN: string
    val simplified_rule: Proof.context -> thm -> thm
    val simplify_tac: Proof.context -> int -> tactic
    val trivial_tac: Proof.context -> int -> tactic
    val typeN: string
    val vars_of: term -> term list
  end
functor Induct (Induct_Args: INDUCT_ARGS): INDUCT
structure Induct: INDUCT
signature INDUCTION =
  sig
    val induction_context_tactic:
       bool ->
         (binding option * (term * bool)) option list list ->
           (string * typ) list list ->
             term option list ->
               thm list option -> thm list -> int -> context_tactic
    val induction_tac:
       Proof.context ->
         bool ->
           (binding option * (term * bool)) option list list ->
             (string * typ) list list ->
               term option list ->
                 thm list option -> thm list -> int -> tactic
  end
structure Induction: INDUCTION
signature INDUCT_TACS =
  sig
    val case_tac:
       Proof.context ->
         string ->
           (binding * string option * mixfix) list ->
             thm option -> int -> tactic
    val induct_tac:
       Proof.context ->
         string option list list -> thm list option -> int -> tactic
  end
structure Induct_Tacs: INDUCT_TACS
signature COHERENT_DATA =
  sig
    val atomize_conjL: thm
    val atomize_disjL: thm
    val atomize_elimL: thm
    val atomize_exL: thm
    val operator_names: string list
  end
signature COHERENT =
  sig
    val coherent_tac: Proof.context -> thm list -> int -> tactic
    val trace: bool Config.T
  end
functor Coherent (Data: COHERENT_DATA): COHERENT
structure Coherent: COHERENT
### ML warning (line 1667 of "~~/src/HOL/HOL.thy"):
### Value identifier (phi) has not been referenced.
### ML warning (line 1672 of "~~/src/HOL/HOL.thy"):
### Value identifier (t) has not been referenced.
signature REORIENT_PROC =
  sig
    val add: (term -> bool) -> theory -> theory
    val proc: morphism -> Proof.context -> cterm -> thm option
  end
structure Reorient_Proc: REORIENT_PROC
val FalseE = "False ==> ?P": thm
val Let_def = "Let ?s ?f == ?f ?s": thm
val TrueI = "True": thm
val allE = "[| ALL x. ?P x; ?P ?x ==> ?R |] ==> ?R": thm
val allI = "(!!x. ?P x) ==> ALL x. ?P x": thm
val all_dupE = "[| ALL x. ?P x; [| ?P ?x; ALL x. ?P x |] ==> ?R |] ==> ?R":
   thm
val arg_cong = "?x = ?y ==> ?f ?x = ?f ?y": thm
val box_equals = "[| ?a = ?b; ?a = ?c; ?b = ?d |] ==> ?c = ?d": thm
val ccontr = "(~ ?P ==> False) ==> ?P": thm
val classical = "(~ ?P ==> ?P) ==> ?P": thm
val conjE = "[| ?P & ?Q; [| ?P; ?Q |] ==> ?R |] ==> ?R": thm
val conjI = "[| ?P; ?Q |] ==> ?P & ?Q": thm
val conjunct1 = "?P & ?Q ==> ?P": thm
val conjunct2 = "?P & ?Q ==> ?Q": thm
val disjCI = "(~ ?Q ==> ?P) ==> ?P | ?Q": thm
val disjE = "[| ?P | ?Q; ?P ==> ?R; ?Q ==> ?R |] ==> ?R": thm
val disjI1 = "?P ==> ?P | ?Q": thm
val disjI2 = "?Q ==> ?P | ?Q": thm
val eq_reflection = "?x = ?y ==> ?x == ?y": thm
val ex1E =
   "[| EX! x. ?P x; !!x. [| ?P x; ALL y. ?P y --> y = x |] ==> ?R |]
    ==> ?R":
   thm
val ex1I = "[| ?P ?a; !!x. ?P x ==> x = ?a |] ==> EX! x. ?P x": thm
val ex1_implies_ex = "EX! x. ?P x ==> EX x. ?P x": thm
val exE = "[| EX x. ?P x; !!x. ?P x ==> ?Q |] ==> ?Q": thm
val exI = "?P ?x ==> EX x. ?P x": thm
val excluded_middle = "~ ?P | ?P": thm
val ext = "(!!x. ?f x = ?g x) ==> ?f = ?g": thm
val fun_cong = "?f = ?g ==> ?f ?x = ?g ?x": thm
val iffD1 = "[| ?Q = ?P; ?Q |] ==> ?P": thm
val iffD2 = "[| ?P = ?Q; ?Q |] ==> ?P": thm
val iffI = "[| ?P ==> ?Q; ?Q ==> ?P |] ==> ?P = ?Q": thm
val impE = "[| ?P --> ?Q; ?P; ?Q ==> ?R |] ==> ?R": thm
val impI = "(?P ==> ?Q) ==> ?P --> ?Q": thm
val meta_eq_to_obj_eq = "?A == ?B ==> ?A = ?B": thm
val mp = "[| ?P --> ?Q; ?P |] ==> ?Q": thm
val notE = "[| ~ ?P; ?P |] ==> ?R": thm
val notI = "(?P ==> False) ==> ~ ?P": thm
val not_all = "(~ (ALL x. ?P x)) = (EX x. ~ ?P x)": thm
val not_ex = "(\<nexists>x. ?P x) = (ALL x. ~ ?P x)": thm
val not_iff = "(?P ~= ?Q) = (?P = (~ ?Q))": thm
val not_not = "(~ ~ ?P) = ?P": thm
val not_sym = "?t ~= ?s ==> ?s ~= ?t": thm
val refl = "?t = ?t": thm
val rev_mp = "[| ?P; ?P --> ?Q |] ==> ?Q": thm
val spec = "ALL x. ?P x ==> ?P ?x": thm
val ssubst = "[| ?t = ?s; ?P ?s |] ==> ?P ?t": thm
val subst = "[| ?s = ?t; ?P ?s |] ==> ?P ?t": thm
val sym = "?s = ?t ==> ?t = ?s": thm
val trans = "[| ?r = ?s; ?s = ?t |] ==> ?r = ?t": thm
locale cnf
signature CNF =
  sig
    val clause2raw_thm: Proof.context -> thm -> thm
    val clause_is_trivial: term -> bool
    val cnf_rewrite_tac: Proof.context -> int -> tactic
    val cnfx_rewrite_tac: Proof.context -> int -> tactic
    val is_atom: term -> bool
    val is_clause: term -> bool
    val is_literal: term -> bool
    val make_cnf_thm: Proof.context -> term -> thm
    val make_cnfx_thm: Proof.context -> term -> thm
    val make_nnf_thm: theory -> term -> thm
    val weakening_tac: Proof.context -> int -> tactic
  end
structure CNF: CNF
class equal = type +
  fixes equal :: "'a => 'a => bool"
  assumes "equal_eq": "!!x y. equal x y = (x = y)"
instantiation
  itself :: (type) equal
  equal_itself == equal :: 'a itself => 'a itself => bool
### Ignoring duplicate rewrite rule:
### ~ ~ ?y == ?y
val smp_tac = fn: Proof.context -> int -> int -> tactic
val nnf_conv = fn: Proof.context -> conv
### theory "HOL.HOL"
### 3.074s elapsed time, 3.457s cpu time, 0.577s GC time
Loading theory "HOL.Argo" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Fun_Def" via "HOL.SAT")
Loading theory "HOL.Ctr_Sugar" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Inductive")
Loading theory "HOL.Orderings" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Typedef" via "HOL.Set" via "HOL.Lattices" via "HOL.Groups")
signature ARGO_EXPR =
  sig
    exception EXPR of expr
    exception TYPE of expr
    val check: expr -> bool
    val con_ord: (string * typ) ord
    val dual_expr: expr -> expr -> bool
    val eq_expr: expr * expr -> bool
    val eq_kind: kind * kind -> bool
    datatype expr = E of kind * expr list
    val expr_ord: expr ord
    val false_expr: expr
    val int_of_kind: kind -> int
    val is_nary: kind -> bool
    datatype kind
    =
         Abs
       | Add
       | And
       | App
       | Con of string * typ
       | Div
       | Eq
       | False
       | Iff
       | Imp
       | Ite
       | Le
       | Lt
       | Max
       | Min
       | Mul
       | Neg
       | Not
       | Num of Rat.rat
       | ...
    val kind_of_string: string -> kind
    val kind_ord: kind ord
    val mk_abs: expr -> expr
    val mk_add: expr list -> expr
    val mk_add2: expr -> expr -> expr
    val mk_and: expr list -> expr
    val mk_and2: expr -> expr -> expr
    val mk_app: expr -> expr -> expr
    val mk_con: string * typ -> expr
    val mk_div: expr -> expr -> expr
    val mk_eq: expr -> expr -> expr
    val mk_iff: expr -> expr -> expr
    val mk_imp: expr -> expr -> expr
    val mk_ite: expr -> expr -> expr -> expr
    val mk_le: expr -> expr -> expr
    val mk_lt: expr -> expr -> expr
    val mk_max: expr -> expr -> expr
    val mk_min: expr -> expr -> expr
    val mk_mul: expr -> expr -> expr
    val mk_neg: expr -> expr
    val mk_not: expr -> expr
    val mk_num: Rat.rat -> expr
    val mk_or: expr list -> expr
    val mk_or2: expr -> expr -> expr
    val mk_sub: expr -> expr -> expr
    val string_of_kind: kind -> string
    val true_expr: expr
    datatype typ = Bool | Func of typ * typ | Real | Type of string
    val type_of: expr -> typ
  end
structure Argo_Expr: ARGO_EXPR
structure Argo_Exprtab: TABLE
### ML warning (line 106 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (B_) has not been referenced.
### ML warning (line 109 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 108 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 113 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 113 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 121 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 124 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (A_) has not been referenced.
### ML warning (line 126 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 129 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 260 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 260 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (A_) has not been referenced.
### ML warning (line 271 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (uu) has not been referenced.
### ML warning (line 270 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 282 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (uu) has not been referenced.
### ML warning (line 281 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 281 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (A_) has not been referenced.
### ML warning (line 290 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 290 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (A_) has not been referenced.
### ML warning (line 293 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (A_) has not been referenced.
### ML warning (line 335 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 340 of "~~/src/Provers/order_procedure.ML"):
### Matches are not exhaustive.
### ML warning (line 342 of "~~/src/Provers/order_procedure.ML"):
### Matches are not exhaustive.
### ML warning (line 384 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 384 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 383 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 383 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 383 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 382 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 382 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 381 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 381 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 381 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 380 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 380 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 380 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 380 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 379 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 379 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 379 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 378 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 378 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 377 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 377 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 377 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 376 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 376 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 395 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 394 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 408 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 418 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 418 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (trm_of_atom) has not been referenced.
### ML warning (line 411 of "~~/src/Provers/order_procedure.ML"):
### Matches are not exhaustive.
### ML warning (line 433 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (trm_of_atom) has not been referenced.
### ML warning (line 420 of "~~/src/Provers/order_procedure.ML"):
### Matches are not exhaustive.
### ML warning (line 444 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 446 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 453 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 453 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 452 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 452 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 452 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 451 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 451 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 450 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 450 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 449 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 449 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 448 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 448 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 462 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 462 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 462 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 461 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 461 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 461 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 460 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 460 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 459 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 459 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 458 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 458 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 457 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 457 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 465 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 483 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (combine) has not been referenced.
### ML warning (line 483 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (B2_) has not been referenced.
### ML warning (line 483 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (B1_) has not been referenced.
### ML warning (line 529 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 529 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 529 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 529 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (uu) has not been referenced.
### ML warning (line 528 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 528 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (uu) has not been referenced.
### ML warning (line 531 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (leqm) has not been referenced.
### ML warning (line 544 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 544 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 544 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 543 of "~~/src/Provers/order_procedure.ML"):
### Value identifier (va) has not been referenced.
structure Order_Procedure:
  sig
    datatype 'a fm
    = And of 'a fm * 'a fm | Atom of 'a | Neg of 'a fm | Or of 'a fm * 'a fm
    datatype inta = Int_of_integer of int
    val integer_of_int: inta -> int
    val lo_contr_prf: (bool * order_atom) fm -> prf_trm option
    datatype order_atom
    = EQ of inta * inta | LEQ of inta * inta | LESS of inta * inta
    val po_contr_prf: (bool * order_atom) fm -> prf_trm option
    datatype prf_trm
    =
         AbsP of trm * prf_trm
       | AppP of prf_trm * prf_trm
       | Appt of prf_trm * trm
       | Bound of trm
       | Conv of trm * prf_trm * prf_trm
       | PThm of string
    datatype trm = App of trm * trm | Const of string | Var of inta
  end
signature ARGO_TERM =
  sig
    val context: context
    type context
    val eq_term: term * term -> bool
    val expr_of: term -> Argo_Expr.expr
    val id_of: term -> int
    datatype identified = Known of term | New of term
    val identify_item: item -> context -> identified * context
    datatype item = Expr of Argo_Expr.expr | Term of term
    type meta
    datatype term = T of meta * Argo_Expr.kind * term list
    val term_ord: term ord
    val type_of: term -> Argo_Expr.typ
  end
structure Argo_Term: ARGO_TERM
structure Argo_Termtab: TABLE
signature ARGO_LIT =
  sig
    val dest: literal -> Argo_Term.term * bool
    val dual_lit: literal * literal -> bool
    val eq_id: literal * literal -> bool
    val eq_lit: literal * literal -> bool
    val literal: Argo_Term.term -> bool -> literal
    datatype literal = Neg of Argo_Term.term | Pos of Argo_Term.term
    val negate: literal -> literal
    val signed_expr_of: literal -> Argo_Expr.expr
    val signed_id_of: literal -> int
    val term_of: literal -> Argo_Term.term
  end
structure Argo_Lit: ARGO_LIT
### ML warning (line 275 of "~~/src/HOL/Tools/Ctr_Sugar/case_translation.ML"):
### Matches are not exhaustive.
### ML warning (line 292 of "~~/src/HOL/Tools/Ctr_Sugar/case_translation.ML"):
### Matches are not exhaustive.
### ML warning (line 351 of "~~/src/HOL/Tools/Ctr_Sugar/case_translation.ML"):
### Matches are not exhaustive.
### ML warning (line 372 of "~~/src/HOL/Tools/Ctr_Sugar/case_translation.ML"):
### Matches are not exhaustive.
### ML warning (line 502 of "~~/src/HOL/Tools/Ctr_Sugar/case_translation.ML"):
### Matches are not exhaustive.
signature CASE_TRANSLATION =
  sig
    val case_tr: bool -> Proof.context -> term list -> term
    datatype config = Error | Quiet | Warning
    val indexify_names: string list -> string list
    val lookup_by_case: Proof.context -> string -> (term * term list) option
    val lookup_by_constr:
       Proof.context -> string * typ -> (term * term list) option
    val lookup_by_constr_permissive:
       Proof.context -> string * typ -> (term * term list) option
    val make_case:
       Proof.context ->
         config -> Name.context -> term -> (term * term) list -> term
    val make_tnames: typ list -> string list
    val print_case_translations: Proof.context -> unit
    val register: term -> term list -> Context.generic -> Context.generic
    val show_cases: bool Config.T
    val strip_case:
       Proof.context -> bool -> term -> (term * (term * term) list) option
    val strip_case_full: Proof.context -> bool -> term -> term
  end
structure Case_Translation: CASE_TRANSLATION
### ML warning (line 81 of "~~/src/Provers/order_tac.ML"):
### Matches are not exhaustive.
### ML warning (line 82 of "~~/src/Provers/order_tac.ML"):
### Matches are not exhaustive.
### ML warning (line 83 of "~~/src/Provers/order_tac.ML"):
### Matches are not exhaustive.
### ML warning (line 209 of "~~/src/Provers/order_tac.ML"):
### Matches are not exhaustive.
### ML warning (line 201 of "~~/src/Provers/order_tac.ML"):
### Matches are not exhaustive.
### ML warning (line 221 of "~~/src/Provers/order_tac.ML"):
### Matches are not exhaustive.
### ML warning (line 296 of "~~/src/Provers/order_tac.ML"):
### Pattern is not exhaustive.
datatype order_kind = Linorder | Order
type order_literal = bool * Order_Procedure.order_atom
type order_context =
   {conv_thms: (string * thm) list,
    kind: order_kind, ops: term list, thms: (string * thm) list}
signature REIFY_TABLE =
  sig
    val empty: table
    val get_term: int -> table -> term option
    val get_var: term -> table -> int * table
    type table
  end
signature LOGIC_SIGNATURE =
  sig
    val Not: term
    val Trueprop_conv: conv -> conv
    val ccontr: thm
    val conj: term
    val conjE: thm
    val conjI: thm
    val conj_disj_distribL_conv: conv
    val conj_disj_distribR_conv: conv
    val de_Morgan_conj_conv: conv
    val de_Morgan_disj_conv: conv
    val dest_Trueprop: term -> term
    val disj: term
    val disjE: thm
    val mk_Trueprop: term -> term
    val notI: thm
    val not_not_conv: conv
  end
signature BASE_ORDER_TAC =
  sig
    val tac:
       (order_literal Order_Procedure.fm -> Order_Procedure.prf_trm option)
         -> order_context -> thm list -> Proof.context -> int -> tactic
  end
structure Reifytab: REIFY_TABLE
functor Base_Order_Tac (
  sig structure Logic_Sig: LOGIC_SIGNATURE val excluded_types: typ list end
  ): 
  BASE_ORDER_TAC
functor Order_Tac (sig structure Base_Tac: BASE_ORDER_TAC end): 
  sig
    structure Data: GENERIC_DATA
    val declare:
       {conv_thms: (string * thm) list,
        kind: order_kind,
        ops: term list,
        raw_proc:
        order_context -> thm list -> Proof.context -> int -> tactic,
        thms: (string * thm) list}
         -> local_theory -> local_theory
    val declare_linorder:
       {conv_thms: {less_le: thm, nle_le: thm, nless_le: thm},
        ops: {eq: term, le: term, lt: term},
        thms:
        {antisym: thm,
         contr: thm, eqD1: thm, eqD2: thm, refl: thm, trans: thm}}
         -> local_theory -> local_theory
    val declare_order:
       {conv_thms: {less_le: thm, nless_le: thm},
        ops: {eq: term, le: term, lt: term},
        thms:
        {antisym: thm,
         contr: thm, eqD1: thm, eqD2: thm, refl: thm, trans: thm}}
         -> local_theory -> local_theory
    val order_context_eq:
       {conv_thms: 'a, kind: ''b, ops: term list, thms: 'c} *
       {conv_thms: 'd, kind: ''b, ops: term list, thms: 'e}
         -> bool
    val order_data_eq:
       ({conv_thms: 'a, kind: ''b, ops: term list, thms: 'c} * 'd) *
       ({conv_thms: 'e, kind: ''b, ops: term list, thms: 'f} * 'g)
         -> bool
    val tac: thm list -> Proof.context -> int -> tactic
  end
val order_trace_cfg =
   Config
    {get_value = fn, map_value = fn, name = "order_trace", pos =
     {line=48, offset=1416, end_offset=1427,
       file=~~/src/Provers/order_tac.ML, id=224}}:
   bool Config.T
val order_split_limit_cfg =
   Config
    {get_value = fn, map_value = fn, name = "order_split_limit", pos =
     {line=53, offset=1768, end_offset=1785,
       file=~~/src/Provers/order_tac.ML, id=224}}:
   int Config.T
constructor Linorder: order_kind
constructor Order: order_kind
locale partial_preordering
  fixes
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
  assumes "partial_preordering (\<^bold>\<le>)"
locale preordering
  fixes
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes "preordering (\<^bold>\<le>) (\<^bold><)"
locale ordering
  fixes
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes "ordering (\<^bold>\<le>) (\<^bold><)"
locale ordering_top
  fixes
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
    and top :: "'a"  (\<open>\<^bold>\<top>\<close>)
  assumes "ordering_top (\<^bold>\<le>) (\<^bold><) \<^bold>\<top>"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### ML warning (line 142 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar_util.ML"):
### Matches are not exhaustive.
### ML warning (line 200 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar_util.ML"):
### Matches are not exhaustive.
### ML warning (line 210 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar_util.ML"):
### Matches are not exhaustive.
signature CTR_SUGAR_UTIL =
  sig
    val CONJ_WRAP: ('a -> tactic) -> 'a list -> tactic
    val CONJ_WRAP': ('a -> int -> tactic) -> 'a list -> int -> tactic
    val CONJ_WRAP_GEN: tactic -> ('a -> tactic) -> 'a list -> tactic
    val CONJ_WRAP_GEN':
       (int -> tactic) -> ('a -> int -> tactic) -> 'a list -> int -> tactic
    val WRAP:
       ('a -> tactic) -> ('a -> tactic) -> 'a list -> tactic -> tactic
    val WRAP':
       ('a -> int -> tactic) ->
         ('a -> int -> tactic) ->
           'a list -> (int -> tactic) -> int -> tactic
    val base_name_of_typ: typ -> string
    val dest_TFree_or_TVar: typ -> string * sort
    val dtac: Proof.context -> thm -> int -> tactic
    val eqFalseI: thm
    val eqTrueI: thm
    val etac: Proof.context -> thm -> int -> tactic
    val fo_match: Proof.context -> term -> term -> Type.tyenv * Envir.tenv
    val lhs_head_of: thm -> term
    val list_all_free: term list -> term -> term
    val list_exists_free: term list -> term -> term
    val map_prod: ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val mk_Frees:
       string -> typ list -> Proof.context -> term list * Proof.context
    val mk_Frees':
       string ->
         typ list ->
           Proof.context ->
             (term list * (string * typ) list) * Proof.context
    val mk_Freess:
       string ->
         typ list list -> Proof.context -> term list list * Proof.context
    val mk_Freess':
       string ->
         typ list list ->
           Proof.context ->
             (term list list * (string * typ) list list) * Proof.context
    val mk_IfN: typ -> term list -> term list -> term
    val mk_TFrees: int -> Proof.context -> typ list * Proof.context
    val mk_TFrees': sort list -> Proof.context -> typ list * Proof.context
    val mk_Trueprop_eq: term * term -> term
    val mk_Trueprop_mem: term * term -> term
    val mk_abs_def: thm -> thm
    val mk_disjIN: int -> int -> thm
    val mk_fresh_names:
       Proof.context -> int -> string -> string list * Proof.context
    val mk_names: int -> string -> string list
    val mk_pred1T: typ -> typ
    val mk_predT: typ list -> typ
    val mk_unabs_def: int -> thm -> thm
    val name_noted_thms:
       string ->
         string -> (string * thm list) list -> (string * thm list) list
    val name_of_const: string -> (typ -> typ) -> term -> string
    val pad_list: 'a -> int -> 'a list -> 'a list
    val parse_binding_colon: binding parser
    val parse_opt_binding_colon: binding parser
    val permute_like:
       ('a * 'a -> bool) -> 'a list -> 'a list -> 'b list -> 'b list
    val permute_like_unique:
       ('a * 'b -> bool) -> 'a list -> 'b list -> 'c list -> 'c list
    val rapp: term -> term -> term
    val resort_tfree_or_tvar: sort -> typ -> typ
    val rtac: Proof.context -> thm -> int -> tactic
    val seq_conds: (bool -> 'a -> 'b) -> int -> int -> 'a list -> 'b list
    val splice: 'a list -> 'a list -> 'a list
    val ss_only: thm list -> Proof.context -> Proof.context
    val standard_binding: binding
    val subst_nonatomic_types: (typ * typ) list -> term -> term
    val substitute_noted_thm: (string * thm list) list -> morphism
    val transpose: 'a list list -> 'a list list
    val typ_subst_nonatomic: (typ * typ) list -> typ -> typ
    val unfold_thms: Proof.context -> thm list -> thm -> thm
    val variant_tfrees:
       string list -> Proof.context -> typ list * Proof.context
    val variant_types:
       string list ->
         sort list -> Proof.context -> (string * sort) list * Proof.context
  end
structure Ctr_Sugar_Util: CTR_SUGAR_UTIL
class preorder = ord +
  assumes "less_le_not_le": "!!x y. (x < y) = (x <= y & ~ y <= x)"
    and "order_refl": "!!x. x <= x"
    and "order_trans": "!!x y z. [| x <= y; y <= z |] ==> x <= z"
signature ARGO_PROOF =
  sig
    exception UNSAT of proof
    val cc_context: context
    val cdcl_context: context
    type context
    datatype conv
    =
         Args_Conv of Argo_Expr.kind * conv list
       | Keep_Conv
       | Rewr_Conv of rewrite
       | Then_Conv of conv * conv
    val dest: proof -> proof_id * rule * proof list
    val eq_proof_id: proof_id * proof_id -> bool
    val id_of: proof -> proof_id
    datatype inequality = Le | Lt
    val keep_conv: conv
    val mk_args_conv: Argo_Expr.kind -> conv list -> conv
    val mk_axiom: int -> context -> proof * context
    val mk_clause:
       Argo_Lit.literal list -> proof -> context -> proof * context
    val mk_cong: proof -> proof -> context -> proof * context
    val mk_conj: int -> int -> proof -> context -> proof * context
    val mk_hyp: Argo_Lit.literal -> context -> proof * context
    val mk_lemma:
       Argo_Lit.literal list -> proof -> context -> proof * context
    val mk_linear_comb: proof list -> context -> proof * context
    val mk_refl: Argo_Term.term -> context -> proof * context
    val mk_rewr_conv: rewrite -> conv
    val mk_rewrite: conv -> proof -> context -> proof * context
    val mk_subst: proof -> proof -> proof -> context -> proof * context
    val mk_symm: proof -> context -> proof * context
    val mk_taut: tautology -> Argo_Expr.expr -> context -> proof * context
    val mk_then_conv: conv -> conv -> conv
    val mk_trans: proof -> proof -> context -> proof * context
    val mk_unit_res:
       Argo_Lit.literal -> proof -> proof -> context -> proof * context
    type proof
    type proof_id
    val proof_id_ord: proof_id ord
    datatype rewrite
    =
         Rewr_Abs
       | Rewr_Add of
           (Rat.rat * int option) list * (Rat.rat * int option) list
       | Rewr_And_Dual of int * int
       | Rewr_And_False of int
       | Rewr_And_Sort of int * int list list
       | Rewr_Div_Div of side
       | Rewr_Div_Mul of side * Rat.rat
       | Rewr_Div_Num of side * Rat.rat
       | Rewr_Div_Nums of Rat.rat * Rat.rat
       | Rewr_Div_One
       | Rewr_Div_Sum
       | Rewr_Div_Zero
       | Rewr_Eq_Le
       | Rewr_Eq_Nums of bool
       | Rewr_Eq_Refl
       | Rewr_Eq_Sub
       | Rewr_Eq_Symm
       | Rewr_Iff_Dual
       | Rewr_Iff_False
       | ...
    datatype rule
    =
         Axiom of int
       | Clause of int list
       | Cong
       | Conjunct of int * int
       | Hyp of int * Argo_Expr.expr
       | Lemma of int list
       | Linear_Comb
       | Refl of Argo_Expr.expr
       | Rewrite of conv
       | Subst
       | Symm
       | Taut of tautology * Argo_Expr.expr
       | Trans
       | Unit_Res of int
    datatype side = Left | Right
    val simplex_context: context
    val solver_context: context
    val string_of_proof_id: proof_id -> string
    val string_of_rule: rule -> string
    val string_of_taut: tautology -> string
    datatype tautology
    =
         Taut_And_1 of int
       | Taut_And_2 of int * int
       | Taut_Iff_1
       | Taut_Iff_2
       | Taut_Iff_3
       | Taut_Iff_4
       | Taut_Ite_Else
       | Taut_Ite_Then
       | Taut_Or_1 of int * int
       | Taut_Or_2 of int
    val unsat: proof -> 'a
  end
structure Argo_Proof: ARGO_PROOF
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
### ML warning (line 147 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar_tactics.ML"):
### Matches are not exhaustive.
signature CTR_SUGAR_GENERAL_TACTICS =
  sig
    val select_prem_tac:
       Proof.context -> int -> (int -> tactic) -> int -> int -> tactic
    val unfold_thms_tac: Proof.context -> thm list -> tactic
  end
signature CTR_SUGAR_TACTICS =
  sig
    val mk_alternate_disc_def_tac:
       Proof.context -> int -> thm -> thm -> thm -> tactic
    val mk_case_cong_tac: Proof.context -> thm -> thm list -> tactic
    val mk_case_distrib_tac:
       Proof.context -> cterm -> thm -> thm list -> tactic
    val mk_case_eq_if_tac:
       Proof.context ->
         int -> thm -> thm list -> thm list list -> thm list list -> tactic
    val mk_case_tac:
       Proof.context ->
         int -> int -> thm -> thm list -> thm list list -> tactic
    val mk_collapse_tac: Proof.context -> int -> thm -> thm list -> tactic
    val mk_disc_eq_case_tac:
       Proof.context ->
         cterm -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_exhaust_disc_tac:
       Proof.context -> int -> thm -> thm list -> tactic
    val mk_exhaust_sel_tac:
       Proof.context -> int -> thm -> thm list -> tactic
    val mk_expand_tac:
       Proof.context ->
         int ->
           int list ->
             thm ->
               thm ->
                 thm list ->
                   thm list list list -> thm list list list -> tactic
    val mk_half_distinct_disc_tac:
       Proof.context -> int -> thm -> thm -> tactic
    val mk_nchotomy_tac: Proof.context -> int -> thm -> tactic
    val mk_other_half_distinct_disc_tac: Proof.context -> thm -> tactic
    val mk_split_asm_tac: Proof.context -> thm -> tactic
    val mk_split_tac:
       Proof.context ->
         thm ->
           thm list ->
             thm list list -> thm list list -> thm list list list -> tactic
    val mk_unique_disc_def_tac: Proof.context -> int -> thm -> tactic
    val select_prem_tac:
       Proof.context -> int -> (int -> tactic) -> int -> int -> tactic
    val unfold_thms_tac: Proof.context -> thm list -> tactic
  end
structure Ctr_Sugar_Tactics: CTR_SUGAR_TACTICS
structure Ctr_Sugar_General_Tactics: CTR_SUGAR_GENERAL_TACTICS
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### ML warning (line 28 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar_code.ML"):
### Pattern is not exhaustive.
### ML warning (line 58 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar_code.ML"):
### Matches are not exhaustive.
### ML warning (line 59 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar_code.ML"):
### Matches are not exhaustive.
### ML warning (line 117 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar_code.ML"):
### Matches are not exhaustive.
signature CTR_SUGAR_CODE =
  sig
    val add_ctr_code:
       string ->
         typ list ->
           (string * typ) list ->
             thm list -> thm list -> thm list -> theory -> theory
  end
structure Ctr_Sugar_Code: CTR_SUGAR_CODE
signature ARGO_REWR =
  sig
    val args: conv -> conv
    val context: context
    type context
    type conv = Argo_Expr.expr -> Argo_Expr.expr * Argo_Proof.conv
    val keep: conv
    val nnf: context -> context
    val norm_add: context -> context
    val norm_arith: context -> context
    val norm_eq: context -> context
    val norm_ite: context -> context
    val norm_mul: context -> context
    val norm_prop: context -> context
    val rewr: Argo_Proof.rewrite -> Argo_Expr.expr -> conv
    val rewrite: context -> conv
    val rewrite_top: context -> conv
    val seq: conv list -> conv
    val with_proof:
       conv ->
         Argo_Expr.expr * Argo_Proof.proof ->
           Argo_Proof.context ->
             (Argo_Expr.expr * Argo_Proof.proof) * Argo_Proof.context
  end
structure Argo_Rewr: ARGO_REWR
signature ARGO_CLS =
  sig
    type clause = Argo_Lit.literal list * Argo_Proof.proof
    val eq_clause: clause * clause -> bool
    val get_watches: table -> clause -> Argo_Lit.literal * Argo_Lit.literal
    val put_watches:
       clause -> Argo_Lit.literal * Argo_Lit.literal -> table -> table
    val table: table
    type table
  end
structure Argo_Cls: ARGO_CLS
signature ARGO_COMMON =
  sig
    datatype 'a implied = Conflict of Argo_Cls.clause | Implied of 'a list
    type literal = Argo_Lit.literal * Argo_Proof.proof option
  end
structure Argo_Common: ARGO_COMMON
structure Logic_Signature: LOGIC_SIGNATURE
structure HOL_Base_Order_Tac: BASE_ORDER_TAC
structure HOL_Order_Tac:
  sig
    structure Data: GENERIC_DATA
    val declare:
       {conv_thms: (string * thm) list,
        kind: order_kind,
        ops: term list,
        raw_proc:
        order_context -> thm list -> Proof.context -> int -> tactic,
        thms: (string * thm) list}
         -> local_theory -> local_theory
    val declare_linorder:
       {conv_thms: {less_le: thm, nle_le: thm, nless_le: thm},
        ops: {eq: term, le: term, lt: term},
        thms:
        {antisym: thm,
         contr: thm, eqD1: thm, eqD2: thm, refl: thm, trans: thm}}
         -> local_theory -> local_theory
    val declare_order:
       {conv_thms: {less_le: thm, nless_le: thm},
        ops: {eq: term, le: term, lt: term},
        thms:
        {antisym: thm,
         contr: thm, eqD1: thm, eqD2: thm, refl: thm, trans: thm}}
         -> local_theory -> local_theory
    val order_context_eq:
       {conv_thms: 'a, kind: ''b, ops: term list, thms: 'c} *
       {conv_thms: 'd, kind: ''b, ops: term list, thms: 'e}
         -> bool
    val order_data_eq:
       ({conv_thms: 'a, kind: ''b, ops: term list, thms: 'c} * 'd) *
       ({conv_thms: 'e, kind: ''b, ops: term list, thms: 'f} * 'g)
         -> bool
    val tac: thm list -> Proof.context -> int -> tactic
  end
val print_orders = fn: Proof.context -> unit
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
val antisym_le_simproc = fn: Proof.context -> cterm -> thm option
val antisym_less_simproc = fn: Proof.context -> cterm -> thm option
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
signature ARGO_CC =
  sig
    val add_atom:
       Argo_Term.term -> context -> Argo_Lit.literal option * context
    val add_level: context -> context
    val assume:
       Argo_Common.literal ->
         context -> Argo_Lit.literal Argo_Common.implied * context
    val backtrack: context -> context
    val check: context -> Argo_Lit.literal Argo_Common.implied * context
    val context: context
    type context
    val explain:
       Argo_Lit.literal -> context -> (Argo_Cls.clause * context) option
  end
structure Argo_Cc: ARGO_CC
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
signature ARGO_SIMPLEX =
  sig
    val add_atom:
       Argo_Term.term -> context -> Argo_Lit.literal option * context
    val add_level: context -> context
    val assume:
       Argo_Common.literal ->
         context -> Argo_Lit.literal Argo_Common.implied * context
    val backtrack: context -> context
    val check: context -> Argo_Lit.literal Argo_Common.implied * context
    val context: context
    type context
    val explain:
       Argo_Lit.literal -> context -> (Argo_Cls.clause * context) option
    val prepare: context -> context
  end
structure Argo_Simplex: ARGO_SIMPLEX
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class bot = type +
  fixes bot :: "'a"
class order_bot = bot + order +
  assumes "bot_least": "!!a. \<bottom> <= a"
class top = type +
  fixes top :: "'a"
class order_top = order + top +
  assumes "top_greatest": "!!a. a <= \<top>"
### ML warning (line 212 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 221 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 275 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 289 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 294 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 334 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 418 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 590 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 608 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 897 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 916 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 929 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 929 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 680 of "~~/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML"):
### Matches are not exhaustive.
signature CTR_SUGAR =
  sig
    val args_of_ctr_spec: ('a, 'b) ctr_spec -> 'b list
    val code_plugin: string
    val ctr_of_ctr_spec: ('a, 'b) ctr_spec -> 'a
    type ctr_options = (string -> bool) * bool
    type ctr_options_cmd = (Proof.context -> string -> bool) * bool
    type ('a, 'b) ctr_spec = (binding * 'a) * 'b list
    type ctr_sugar =
       {T: typ,
        case_cong: thm,
        case_cong_weak: thm,
        case_distribs: thm list,
        case_eq_ifs: thm list,
        case_thms: thm list,
        casex: term,
        collapses: thm list,
        ctrs: term list,
        discIs: thm list,
        disc_defs: thm list,
        disc_eq_cases: thm list,
        disc_thmss: thm list list,
        discs: term list,
        distinct_discsss: thm list list list,
        distincts: thm list, exhaust: thm, exhaust_discs: thm list, ...}
    val ctr_sugar_interpretation:
       string ->
         (ctr_sugar -> local_theory -> local_theory) -> theory -> theory
    datatype ctr_sugar_kind = Codatatype | Datatype | Record | Unknown
    val ctr_sugar_of: Proof.context -> string -> ctr_sugar option
    val ctr_sugar_of_case: Proof.context -> string -> ctr_sugar option
    val ctr_sugar_of_case_global: theory -> string -> ctr_sugar option
    val ctr_sugar_of_global: theory -> string -> ctr_sugar option
    val ctr_sugars_of: Proof.context -> ctr_sugar list
    val ctr_sugars_of_global: theory -> ctr_sugar list
    val default_ctr_options: ctr_options
    val default_ctr_options_cmd: ctr_options_cmd
    val default_register_ctr_sugar_global:
       (string -> bool) -> ctr_sugar -> theory -> theory
    val dest_case:
       Proof.context ->
         string ->
           typ list -> term -> (ctr_sugar * term list * term list) option
    val dest_ctr: Proof.context -> string -> term -> term * term list
    val disc_of_ctr_spec: ('a, 'b) ctr_spec -> binding
    val fake_local_theory_for_sel_defaults:
       (binding * typ) list -> Proof.context -> Proof.context
    val free_constructors:
       ctr_sugar_kind ->
         ({context: Proof.context, prems: thm list} -> tactic) list list ->
           ((ctr_options * binding) * (term, binding) ctr_spec list) *
           term list
             -> local_theory -> ctr_sugar * local_theory
    val free_constructors_cmd:
       ctr_sugar_kind ->
         ((((Proof.context -> Plugin_Name.filter) * bool) * binding) *
          ((binding * string) * binding list) list)
         *
         string list
           -> Proof.context -> Proof.state
    val interpret_ctr_sugar:
       (string -> bool) -> ctr_sugar -> local_theory -> local_theory
    val join_halves:
       int -> 'a list list -> 'a list list -> 'a list * 'a list list list
    val mk_case: typ list -> typ -> term -> term
    val mk_ctr: typ list -> term -> term
    val mk_disc_or_sel: typ list -> term -> term
    val mk_half_pairss: 'a list * 'a list -> ('a * 'a) list list
    val morph_ctr_sugar: morphism -> ctr_sugar -> ctr_sugar
    val name_of_ctr: term -> string
    val name_of_disc: term -> string
    val parse_bound_term: (binding * string) parser
    val parse_ctr_options: ctr_options_cmd parser
    val parse_ctr_spec: 'a parser -> 'b parser -> ('a, 'b) ctr_spec parser
    val parse_sel_default_eqs: string list parser
    val register_ctr_sugar:
       (string -> bool) -> ctr_sugar -> local_theory -> local_theory
    val register_ctr_sugar_raw: ctr_sugar -> local_theory -> local_theory
    val transfer_ctr_sugar: theory -> ctr_sugar -> ctr_sugar
  end
structure Ctr_Sugar: CTR_SUGAR
signature ARGO_THY =
  sig
    val add_atom:
       Argo_Term.term -> context -> Argo_Lit.literal option * context
    val add_level: context -> context
    val assume:
       Argo_Common.literal ->
         context -> Argo_Lit.literal Argo_Common.implied * context
    val backtrack: context -> context
    val check: context -> Argo_Lit.literal Argo_Common.implied * context
    val context: context
    type context
    val explain: Argo_Lit.literal -> context -> Argo_Cls.clause * context
    val prepare: context -> context
  end
structure Argo_Thy: ARGO_THY
class dense_order = order +
  assumes "dense": "!!x y. x < y ==> EX z>x. z < y"
signature ARGO_HEAP =
  sig
    val count: Argo_Lit.literal -> heap -> heap
    val decay: heap -> heap
    val extract: heap -> (Argo_Lit.literal * heap) option
    val heap: heap
    type heap
    val increase: Argo_Lit.literal -> heap -> heap
    val insert: Argo_Lit.literal -> heap -> heap
    val rebuild: (Argo_Term.term -> bool) -> heap -> heap
  end
structure Argo_Heap: ARGO_HEAP
signature COINDUCTION =
  sig
    val coinduction_context_tactic:
       term list -> thm list option -> thm list -> int -> context_tactic
    val coinduction_tac:
       Proof.context ->
         term list -> thm list option -> thm list -> int -> tactic
  end
structure Coinduction: COINDUCTION
### theory "HOL.Ctr_Sugar"
### 0.903s elapsed time, 2.714s cpu time, 0.221s GC time
class no_top = order +
  assumes "gt_ex": "!!x. EX y. x < y"
class no_bot = order +
  assumes "lt_ex": "!!x. EX y. y < x"
signature ARGO_CDCL =
  sig
    val add_atom: Argo_Term.term -> context -> context
    val add_axiom: Argo_Cls.clause -> context -> int * context
    val analyze:
       'a explain -> Argo_Cls.clause -> context -> 'a -> int * context * 'a
    val assignment_of: context -> Argo_Lit.literal -> bool option
    val assume:
       'a explain ->
         Argo_Lit.literal ->
           context -> 'a -> Argo_Cls.clause option * context * 'a
    val context: context
    type context
    val decide: context -> context option
    type 'a explain = Argo_Lit.literal -> 'a -> Argo_Cls.clause * 'a
    val propagate:
       context -> Argo_Common.literal Argo_Common.implied * context
    val restart: context -> int * context
  end
structure Argo_Cdcl: ARGO_CDCL
class wellorder = linorder +
  assumes
    "less_induct": "!!P a. (!!x. (!!y. y < x ==> P y) ==> P x) ==> P a"
signature ARGO_CORE =
  sig
    val add_atom:
       Argo_Term.item -> context -> Argo_Term.identified * context
    val add_axiom: Argo_Cls.clause -> context -> context
    val context: context
    type context
    val identify:
       Argo_Term.item -> context -> Argo_Term.identified * context
    val model_of: context -> string * Argo_Expr.typ -> bool option
    val run: context -> context
  end
structure Argo_Core: ARGO_CORE
instantiation
  bool :: {linorder,order_bot,order_top}
  top_bool == top :: bool
  bot_bool == bot :: bool
  less_eq_bool == less_eq :: bool => bool => bool
  less_bool == less :: bool => bool => bool
instantiation
  fun :: (type, ord) ord
  less_eq_fun == less_eq :: ('a => 'b) => ('a => 'b) => bool
  less_fun == less :: ('a => 'b) => ('a => 'b) => bool
instantiation
  fun :: (type, bot) bot
  bot_fun == bot :: 'a => 'b
instantiation
  fun :: (type, order_bot) order_bot
instantiation
  fun :: (type, top) top
  top_fun == top :: 'a => 'b
instantiation
  fun :: (type, order_top) order_top
signature ARGO_CLAUSIFY =
  sig
    val clausify:
       Argo_Rewr.context ->
         Argo_Expr.expr * Argo_Proof.proof ->
           Argo_Proof.context * Argo_Core.context ->
             Argo_Proof.context * Argo_Core.context
  end
structure Argo_Clausify: ARGO_CLAUSIFY
### theory "HOL.Orderings"
### 1.091s elapsed time, 3.090s cpu time, 0.245s GC time
Loading theory "HOL.Groups" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Typedef" via "HOL.Set" via "HOL.Lattices")
signature ARGO_SOLVER =
  sig
    val assert: Argo_Expr.expr list -> context -> context
    val context: context
    type context
    val model_of: context -> string * Argo_Expr.typ -> bool option
  end
structure Argo_Solver: ARGO_SOLVER
locale semigroup
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "semigroup (\<^bold>*)"
locale abel_semigroup
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "abel_semigroup (\<^bold>*)"
locale monoid
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "monoid (\<^bold>*) \<^bold>1"
locale comm_monoid
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid (\<^bold>*) \<^bold>1"
locale group
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
    and inverse :: "'a => 'a"
  assumes "group (\<^bold>*) \<^bold>1 inverse"
class zero = type +
  fixes zero :: "'a"
class one = type +
  fixes one :: "'a"
class plus = type +
  fixes plus :: "'a => 'a => 'a"
class minus = type +
  fixes minus :: "'a => 'a => 'a"
class uminus = type +
  fixes uminus :: "'a => 'a"
class times = type +
  fixes times :: "'a => 'a => 'a"
class semigroup_add = plus +
  assumes "add_assoc": "!!a b c. a + b + c = a + (b + c)"
class ab_semigroup_add = semigroup_add +
  assumes "add_commute": "!!a b. a + b = b + a"
class semigroup_mult = times +
  assumes "mult_assoc": "!!a b c. a * b * c = a * (b * c)"
class ab_semigroup_mult = semigroup_mult +
  assumes "mult_commute": "!!a b. a * b = b * a"
class monoid_add = semigroup_add + zero +
  assumes "add_0_left": "!!a. (0::'a) + a = a"
    and "add_0_right": "!!a. a + (0::'a) = a"
class comm_monoid_add = ab_semigroup_add + zero +
  assumes "add_0": "!!a. (0::'a) + a = a"
class monoid_mult = one + semigroup_mult +
  assumes "mult_1_left": "!!a. (1::'a) * a = a"
    and "mult_1_right": "!!a. a * (1::'a) = a"
class comm_monoid_mult = ab_semigroup_mult + one +
  assumes "mult_1": "!!a. (1::'a) * a = a"
class cancel_semigroup_add = semigroup_add +
  assumes "add_left_imp_eq": "!!a b c. a + b = a + c ==> b = c"
  assumes "add_right_imp_eq": "!!b a c. b + a = c + a ==> b = c"
class cancel_ab_semigroup_add = ab_semigroup_add + minus +
  assumes "add_diff_cancel_left'": "!!a b. a + b - a = b"
  assumes "diff_diff_add": "!!a b c. a - b - c = a - (b + c)"
class comm_monoid_diff = cancel_comm_monoid_add +
  assumes "zero_diff": "!!a. (0::'a) - a = (0::'a)"
class group_add = minus + monoid_add + uminus +
  assumes "left_minus": "!!a. - a + a = (0::'a)"
  assumes "add_uminus_conv_diff": "!!a b. a + - b = a - b"
class ab_group_add = comm_monoid_add + minus + uminus +
  assumes "ab_left_minus": "!!a. - a + a = (0::'a)"
  assumes "ab_diff_conv_add_uminus": "!!a b. a - b = a + - b"
class ordered_ab_semigroup_add = ab_semigroup_add + order +
  assumes "add_left_mono": "!!a b c. a <= b ==> c + a <= c + b"
class strict_ordered_ab_semigroup_add = ordered_ab_semigroup_add +
  assumes
    "add_strict_mono": "!!a b c d. [| a < b; c < d |] ==> a + c < b + d"
class ordered_ab_semigroup_add_imp_le = ordered_cancel_ab_semigroup_add +
  assumes "add_le_imp_le_left": "!!c a b. c + a <= c + b ==> a <= b"
locale group_cancel
signature GROUP_CANCEL =
  sig
    val cancel_add_conv: conv
    val cancel_diff_conv: conv
    val cancel_eq_conv: conv
    val cancel_le_conv: conv
    val cancel_less_conv: conv
  end
structure Group_Cancel: GROUP_CANCEL
class abs = type +
  fixes abs :: "'a => 'a"
class sgn = type +
  fixes sgn :: "'a => 'a"
class ordered_ab_group_add_abs = abs + ordered_ab_group_add +
  assumes "abs_ge_zero": "!!a. (0::'a) <= \<bar>a\<bar>"
    and "abs_ge_self": "!!a. a <= \<bar>a\<bar>"
    and "abs_leI": "!!a b. [| a <= b; - a <= b |] ==> \<bar>a\<bar> <= b"
    and "abs_minus_cancel": "!!a. \<bar>- a\<bar> = \<bar>a\<bar>"
    and
    "abs_triangle_ineq":
      "!!a b. \<bar>a + b\<bar> <= \<bar>a\<bar> + \<bar>b\<bar>"
signature ARGO_TACTIC =
  sig
    val add_extension: extension -> theory -> theory
    val argo_tac: Proof.context -> thm list -> int -> tactic
    val check: term list -> Proof.context -> result * Proof.context
    val discharges: thm -> thm list -> thm list
    type extension =
       {replay:
        (Argo_Expr.expr -> cterm) ->
          Proof.context -> Argo_Proof.rule -> thm list -> thm option
        ,
        replay_rewr: Proof.context -> Argo_Proof.rewrite -> conv,
        term_of: (Argo_Expr.expr -> term) -> Argo_Expr.expr -> term option,
        trans_term:
        (term, Argo_Expr.expr) trans -> (term, Argo_Expr.expr) trans',
        trans_type:
        (typ, Argo_Expr.typ) trans -> (typ, Argo_Expr.typ) trans'}
    val flatten_conv: conv -> thm -> conv
    val prove: thm list -> Proof.context -> thm option * Proof.context
    datatype result = Satisfiable of term -> bool option | Unsatisfiable
    val timeout: real Config.T
    val trace: string Config.T
    type ('a, 'b) trans = 'a -> trans_context -> 'b * trans_context
    type ('a, 'b) trans' =
       'a -> trans_context -> ('b * trans_context) option
    type trans_context =
       Name.context * Argo_Expr.typ Typtab.table *
       (string * Argo_Expr.typ) Termtab.table
  end
structure Argo_Tactic: ARGO_TACTIC
### theory "HOL.Argo"
### 2.373s elapsed time, 5.711s cpu time, 0.402s GC time
Loading theory "HOL.SAT" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Fun_Def")
signature PROP_LOGIC =
  sig
    val SAnd: prop_formula * prop_formula -> prop_formula
    val SNot: prop_formula -> prop_formula
    val SOr: prop_formula * prop_formula -> prop_formula
    val all: prop_formula list -> prop_formula
    val cnf: prop_formula -> prop_formula
    val defcnf: prop_formula -> prop_formula
    val dot_product: prop_formula list * prop_formula list -> prop_formula
    val eval: (int -> bool) -> prop_formula -> bool
    val exists: prop_formula list -> prop_formula
    val indices: prop_formula -> int list
    val is_cnf: prop_formula -> bool
    val is_nnf: prop_formula -> bool
    val maxidx: prop_formula -> int
    val nnf: prop_formula -> prop_formula
    datatype prop_formula
    =
         And of prop_formula * prop_formula
       | BoolVar of int
       | False
       | Not of prop_formula
       | Or of prop_formula * prop_formula
       | True
    val prop_formula_of_term:
       term -> int Termtab.table -> prop_formula * int Termtab.table
    val simplify: prop_formula -> prop_formula
    val term_of_prop_formula: prop_formula -> term
  end
structure Prop_Logic: PROP_LOGIC
class canonically_ordered_monoid_add = comm_monoid_add + order +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
### ML warning (line 240 of "~~/src/HOL/Tools/sat_solver.ML"):
### Value identifier (i) has not been referenced.
signature SAT_SOLVER =
  sig
    exception NOT_CONFIGURED
    val add_solver: string * solver -> unit
    type assignment = int -> bool option
    val get_solvers: unit -> (string * solver) list
    val invoke_solver: string -> solver
    val make_external_solver:
       string ->
         (Prop_Logic.prop_formula -> unit) -> (unit -> result) -> solver
    type proof = int list Inttab.table * int
    val read_dimacs_cnf_file: Path.T -> Prop_Logic.prop_formula
    val read_std_result_file: Path.T -> string * string * string -> result
    datatype result
    = SATISFIABLE of assignment | UNKNOWN | UNSATISFIABLE of proof option
    type solver = Prop_Logic.prop_formula -> result
    val write_dimacs_cnf_file: Path.T -> Prop_Logic.prop_formula -> unit
    val write_dimacs_sat_file: Path.T -> Prop_Logic.prop_formula -> unit
  end
structure SAT_Solver: SAT_SOLVER
val it = (): unit
val it = (): unit
val it = (): unit
val it = (): unit
val it = (): unit
val it = (): unit
val it = (): unit
val it = (): unit
### theory "HOL.Groups"
### 1.475s elapsed time, 3.005s cpu time, 0.189s GC time
Loading theory "HOL.Lattices" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Typedef" via "HOL.Set")
locale semilattice
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "semilattice (\<^bold>*)"
locale semilattice_neutr
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "semilattice_neutr (\<^bold>*) \<^bold>1"
locale semilattice_order
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes "semilattice_order (\<^bold>*) (\<^bold>\<le>) (\<^bold><)"
locale semilattice_neutr_order
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
    and
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes
    "semilattice_neutr_order (\<^bold>*) \<^bold>1 (\<^bold>\<le>)
      (\<^bold><)"
signature SAT =
  sig
    val counter: int ref
    val rawsat_tac: Proof.context -> int -> tactic
    val rawsat_thm: Proof.context -> cterm list -> thm
    val sat_tac: Proof.context -> int -> tactic
    val satx_tac: Proof.context -> int -> tactic
    val solver: string Config.T
    val trace: bool Config.T
  end
structure SAT: SAT
structure Argo_SAT_Solver: sig end
### theory "HOL.SAT"
### 0.282s elapsed time, 0.575s cpu time, 0.032s GC time
class inf = type +
  fixes inf :: "'a => 'a => 'a"
class sup = type +
  fixes sup :: "'a => 'a => 'a"
class semilattice_inf = inf + order +
  assumes "inf_le1": "!!x y. x \<sqinter> y <= x"
    and "inf_le2": "!!x y. x \<sqinter> y <= y"
    and
    "inf_greatest": "!!x y z. [| x <= y; x <= z |] ==> x <= y \<sqinter> z"
class semilattice_sup = sup + order +
  assumes "sup_ge1": "!!x y. x <= x \<squnion> y"
    and "sup_ge2": "!!y x. y <= x \<squnion> y"
    and "sup_least": "!!y x z. [| y <= x; z <= x |] ==> y \<squnion> z <= x"
class semilattice_inf = inf + order +
  assumes "inf_le1": "!!x y. x \<sqinter> y <= x"
    and "inf_le2": "!!x y. x \<sqinter> y <= y"
    and
    "inf_greatest": "!!x y z. [| x <= y; x <= z |] ==> x <= y \<sqinter> z"
class semilattice_sup = sup + order +
  assumes "sup_ge1": "!!x y. x <= x \<squnion> y"
    and "sup_ge2": "!!y x. y <= x \<squnion> y"
    and "sup_least": "!!y x z. [| y <= x; z <= x |] ==> y \<squnion> z <= x"
class semilattice_inf = inf + order +
  assumes "inf_le1": "!!x y. x \<sqinter> y <= x"
    and "inf_le2": "!!x y. x \<sqinter> y <= y"
    and
    "inf_greatest": "!!x y z. [| x <= y; x <= z |] ==> x <= y \<sqinter> z"
class semilattice_sup = sup + order +
  assumes "sup_ge1": "!!x y. x <= x \<squnion> y"
    and "sup_ge2": "!!y x. y <= x \<squnion> y"
    and "sup_least": "!!y x z. [| y <= x; z <= x |] ==> y \<squnion> z <= x"
class semilattice_inf = inf + order +
  assumes "inf_le1": "!!x y. x \<sqinter> y <= x"
    and "inf_le2": "!!x y. x \<sqinter> y <= y"
    and
    "inf_greatest": "!!x y z. [| x <= y; x <= z |] ==> x <= y \<sqinter> z"
class semilattice_sup = sup + order +
  assumes "sup_ge1": "!!x y. x <= x \<squnion> y"
    and "sup_ge2": "!!y x. y <= x \<squnion> y"
    and "sup_least": "!!y x z. [| y <= x; z <= x |] ==> y \<squnion> z <= x"
class distrib_lattice = lattice +
  assumes
    "sup_inf_distrib1":
      "!!x y z.
          x \<squnion> y \<sqinter> z =
          (x \<squnion> y) \<sqinter> (x \<squnion> z)"
class distrib_lattice = lattice +
  assumes
    "sup_inf_distrib1":
      "!!x y z.
          x \<squnion> y \<sqinter> z =
          (x \<squnion> y) \<sqinter> (x \<squnion> z)"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
instantiation
  fun :: (type, semilattice_sup) semilattice_sup
  sup_fun == sup :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, semilattice_inf) semilattice_inf
  inf_fun == inf :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, uminus) uminus
  uminus_fun == uminus :: ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, minus) minus
  minus_fun == minus :: ('a => 'b) => ('a => 'b) => 'a => 'b
### theory "HOL.Lattices"
### 0.773s elapsed time, 0.929s cpu time, 0.077s GC time
Loading theory "HOL.Boolean_Algebras" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Typedef" via "HOL.Set")
locale abstract_boolean_algebra
  fixes
    conj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<sqinter>\<close> 70)
    and
    disj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<squnion>\<close> 65)
    and compl :: "'a => 'a"  (\<open>\<^bold>- _\<close> [81] 80)
    and zero :: "'a"  (\<open>\<^bold>0\<close>)
    and one :: "'a"  (\<open>\<^bold>1\<close>)
  assumes
    "abstract_boolean_algebra (\<^bold>\<sqinter>) (\<^bold>\<squnion>)
      compl \<^bold>0 \<^bold>1"
### Ignoring duplicate rewrite rule:
### ?x1 \<^bold>\<squnion> \<^bold>1 == \<^bold>1
### Ignoring duplicate rewrite rule:
### \<^bold>- \<^bold>0 == \<^bold>1
### Ignoring duplicate rewrite rule:
### \<^bold>1 \<^bold>\<squnion> ?x1 == \<^bold>1
### Ignoring duplicate rewrite rule:
### \<^bold>- ?x1 \<^bold>\<squnion> ?x1 == \<^bold>1
### Ignoring duplicate rewrite rule:
### \<^bold>- (?x1 \<^bold>\<squnion> ?y1) ==
### \<^bold>- ?x1 \<^bold>\<sqinter> \<^bold>- ?y1
locale abstract_boolean_algebra_sym_diff
  fixes
    conj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<sqinter>\<close> 70)
    and
    disj :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<squnion>\<close> 65)
    and compl :: "'a => 'a"  (\<open>\<^bold>- _\<close> [81] 80)
    and zero :: "'a"  (\<open>\<^bold>0\<close>)
    and one :: "'a"  (\<open>\<^bold>1\<close>)
    and
    xor :: "'a => 'a => 'a"  (infixr \<open>\<^bold>\<ominus>\<close> 65)
  assumes
    "abstract_boolean_algebra_sym_diff (\<^bold>\<sqinter>)
      (\<^bold>\<squnion>) compl \<^bold>0 \<^bold>1 (\<^bold>\<ominus>)"
class boolean_algebra = minus + uminus + bounded_lattice + distrib_lattice +
  assumes "inf_compl_bot": "!!x. x \<sqinter> - x = \<bottom>"
    and "sup_compl_top": "!!x. x \<squnion> - x = \<top>"
  assumes "diff_eq": "!!x y. x - y = x \<sqinter> - y"
instantiation
  bool :: boolean_algebra
  minus_bool == minus :: bool => bool => bool
  uminus_bool == uminus :: bool => bool
  inf_bool == inf :: bool => bool => bool
  sup_bool == sup :: bool => bool => bool
locale boolean_algebra_cancel
signature BOOLEAN_ALGEBRA_CANCEL =
  sig val cancel_inf_conv: conv val cancel_sup_conv: conv end
structure Boolean_Algebra_Cancel: BOOLEAN_ALGEBRA_CANCEL
class boolean_algebra = minus + uminus + bounded_lattice + distrib_lattice +
  assumes "inf_compl_bot": "!!x. x \<sqinter> - x = \<bottom>"
    and "sup_compl_top": "!!x. x \<squnion> - x = \<top>"
  assumes "diff_eq": "!!x y. x - y = x \<sqinter> - y"
### theory "HOL.Boolean_Algebras"
### 0.319s elapsed time, 0.372s cpu time, 0.042s GC time
Loading theory "HOL.Set" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Typedef")
instantiation
  set :: (type) boolean_algebra
  minus_set == minus :: 'a set => 'a set => 'a set
  uminus_set == uminus :: 'a set => 'a set
  bot_set == bot :: 'a set
  top_set == top :: 'a set
  inf_set == inf :: 'a set => 'a set => 'a set
  sup_set == sup :: 'a set => 'a set => 'a set
  less_eq_set == less_eq :: 'a set => 'a set => bool
  less_set == less :: 'a set => 'a set => bool
structure Simpdata:
  sig
    structure Clasimp: CLASIMP
    val HOL_basic_ss: simpset
    structure Splitter: SPLITTER
    val addSss: Proof.context -> Proof.context
    val addss: Proof.context -> Proof.context
    val auto_tac: Proof.context -> tactic
    val best_simp_tac: Proof.context -> int -> tactic
    val clarsimp_tac: Proof.context -> int -> tactic
    val clasimp_modifiers: Method.modifier parser list
    val fast_force_tac: Proof.context -> int -> tactic
    val force_tac: Proof.context -> int -> tactic
    val hol_simplify: Proof.context -> thm list -> thm -> thm
    val iff_add: attribute
    val iff_add': attribute
    val iff_del: attribute
    val iff_modifiers: Method.modifier parser list
    val lift_meta_eq_to_obj_eq: Proof.context -> int -> thm -> thm
    val mk_atomize:
       Proof.context -> (string * thm list) list -> thm -> thm list
    val mk_auto_tac: Proof.context -> int -> int -> tactic
    val mk_eq: thm -> thm
    val mk_eq_True: Proof.context -> thm -> thm option
    val mk_meta_cong: Proof.context -> thm -> thm
    val mk_meta_eq: thm -> thm
    val mksimps:
       (string * thm list) list -> Proof.context -> thm -> thm list
    val mksimps_pairs: (string * thm list) list
    val safe_mk_meta_eq: thm -> thm
    val safe_solver: solver
    val safe_solver_tac: Proof.context -> int -> tactic
    val slow_simp_tac: Proof.context -> int -> tactic
    val split_inside_tac: Proof.context -> thm list -> int -> tactic
    val split_tac: Proof.context -> thm list -> int -> tactic
    val unfold_tac: Proof.context -> thm list -> tactic
    val unsafe_solver: solver
    val unsafe_solver_tac: Proof.context -> int -> tactic
  end
structure Clasimp: CLASIMP
structure Splitter: SPLITTER
val mk_eq_True = fn: Proof.context -> thm -> thm option
val force_tac = fn: Proof.context -> int -> tactic
val mk_atomize = fn:
   Proof.context -> (string * thm list) list -> thm -> thm list
val clarsimp_tac = fn: Proof.context -> int -> tactic
val fast_force_tac = fn: Proof.context -> int -> tactic
val iff_add = fn: attribute
val best_simp_tac = fn: Proof.context -> int -> tactic
val HOL_basic_ss =
   Simpset
    ({depth = (0, ref false), prems = [], rules = Leaf []},
     {congs = ({}, []), loop_tacs = [], mk_rews =
      {mk = fn, mk_cong = fn, mk_eq_True = fn, mk_sym = fn, reorient = fn},
      procs = Leaf [], solvers =
      ([Solver {id = Stamp 890442, name = "HOL unsafe", solver = fn}],
       [Solver {id = Stamp 890444, name = "HOL safe", solver = fn}]),
      subgoal_tac = fn, term_ord = fn}):
   simpset
val iff_del = fn: attribute
val mk_auto_tac = fn: Proof.context -> int -> int -> tactic
val mk_meta_eq = fn: thm -> thm
val unsafe_solver =
   Solver {id = Stamp 890442, name = "HOL unsafe", solver = fn}: solver
val mk_eq = fn: thm -> thm
val iff_modifiers = [fn, fn, fn]: Method.modifier parser list
val unsafe_solver_tac = fn: Proof.context -> int -> tactic
val iff_add' = fn: attribute
val slow_simp_tac = fn: Proof.context -> int -> tactic
val mksimps_pairs =
   [("Set.Ball", ["[| ALL x:?A. ?P x; ?x : ?A |] ==> ?P ?x"]),
    ("HOL.implies", ["[| ?P --> ?Q; ?P |] ==> ?Q"]),
    ("HOL.conj", ["?P & ?Q ==> ?P", "?P & ?Q ==> ?Q"]),
    ("HOL.All", ["ALL x. ?P x ==> ?P ?x"]), ("HOL.True", []),
    ("HOL.False", []),
    ("HOL.If",
     ["if ?P1 then ?Q1 else ?R1 ==> (?P1 --> ?Q1) & (~ ?P1 --> ?R1)"])]:
   (string * thm list) list
val split_tac = fn: Proof.context -> thm list -> int -> tactic
val clasimp_modifiers =
   [fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn, fn,
    fn, fn, ...]:
   Method.modifier parser list
val addSss = fn: Proof.context -> Proof.context
val safe_mk_meta_eq = fn: thm -> thm
val split_inside_tac = fn: Proof.context -> thm list -> int -> tactic
val auto_tac = fn: Proof.context -> tactic
val safe_solver =
   Solver {id = Stamp 890444, name = "HOL safe", solver = fn}: solver
val hol_simplify = fn: Proof.context -> thm list -> thm -> thm
val addss = fn: Proof.context -> Proof.context
val mk_meta_cong = fn: Proof.context -> thm -> thm
val safe_solver_tac = fn: Proof.context -> int -> tactic
val unfold_tac = fn: Proof.context -> thm list -> tactic
val mksimps = fn:
   (string * thm list) list -> Proof.context -> thm -> thm list
val lift_meta_eq_to_obj_eq = fn: Proof.context -> int -> thm -> thm
instantiation
  set :: (equal) equal
  equal_set == equal_class.equal :: 'a set => 'a set => bool
val Ball_def = "Ball ?A ?P = (ALL x. x : ?A --> ?P x)": thm
val Bex_def = "Bex ?A ?P = (EX x. x : ?A & ?P x)": thm
val CollectD = "?a : {x. ?P x} ==> ?P ?a": thm
val CollectE = "[| ?a : {x. ?P x}; ?P ?a ==> PROP ?W |] ==> PROP ?W": thm
val CollectI = "?P ?a ==> ?a : {x. ?P x}": thm
val Collect_conj_eq = "{x. ?P x & ?Q x} = {x. ?P x} Int {x. ?Q x}": thm
val Collect_mem_eq = "{x. x : ?A} = ?A": thm
val IntD1 = "?c : ?A Int ?B ==> ?c : ?A": thm
val IntD2 = "?c : ?A Int ?B ==> ?c : ?B": thm
val IntE = "[| ?c : ?A Int ?B; [| ?c : ?A; ?c : ?B |] ==> ?P |] ==> ?P": thm
val IntI = "[| ?c : ?A; ?c : ?B |] ==> ?c : ?A Int ?B": thm
val Int_Collect = "(?x : ?A Int {x. ?P x}) = (?x : ?A & ?P ?x)": thm
val UNIV_I = "?x : UNIV": thm
val UNIV_witness = "EX x. x : UNIV": thm
val UnE = "[| ?c : ?A Un ?B; ?c : ?A ==> ?P; ?c : ?B ==> ?P |] ==> ?P": thm
val UnI1 = "?c : ?A ==> ?c : ?A Un ?B": thm
val UnI2 = "?c : ?B ==> ?c : ?A Un ?B": thm
val ballE = "[| ALL x:?A. ?P x; ?P ?x ==> ?Q; ?x ~: ?A ==> ?Q |] ==> ?Q":
   thm
val ballI = "(!!x. x : ?A ==> ?P x) ==> ALL x:?A. ?P x": thm
val bexCI = "[| ALL x:?A. ~ ?P x ==> ?P ?a; ?a : ?A |] ==> EX x:?A. ?P x":
   thm
val bexE = "[| EX x:?A. ?P x; !!x. [| x : ?A; ?P x |] ==> ?Q |] ==> ?Q": thm
val bexI = "[| ?P ?x; ?x : ?A |] ==> EX x:?A. ?P x": thm
val bex_triv = "(EX x:?A. ?P) = ((EX x. x : ?A) & ?P)": thm
val bspec = "[| ALL x:?A. ?P x; ?x : ?A |] ==> ?P ?x": thm
val contra_subsetD = "[| ?A <= ?B; ?c ~: ?B |] ==> ?c ~: ?A": thm
val equalityCE =
   "[| ?A = ?B; [| ?c : ?A; ?c : ?B |] ==> ?P;
       [| ?c ~: ?A; ?c ~: ?B |] ==> ?P |]
    ==> ?P":
   thm
val equalityD1 = "?A = ?B ==> ?A <= ?B": thm
val equalityD2 = "?A = ?B ==> ?B <= ?A": thm
val equalityE = "[| ?A = ?B; [| ?A <= ?B; ?B <= ?A |] ==> ?P |] ==> ?P": thm
val equalityI = "[| ?A <= ?B; ?B <= ?A |] ==> ?A = ?B": thm
val imageE =
   "[| ?b : ?f ` ?A; !!x. [| ?b = ?f x; x : ?A |] ==> ?thesis |]
    ==> ?thesis":
   thm
val imageI = "?x : ?A ==> ?f ?x : ?f ` ?A": thm
val image_Un = "?f ` (?A Un ?B) = ?f ` ?A Un ?f ` ?B": thm
val image_insert = "?f ` insert ?a ?B = insert (?f ?a) (?f ` ?B)": thm
val insert_commute = "insert ?x (insert ?y ?A) = insert ?y (insert ?x ?A)":
   thm
val insert_iff = "(?a : insert ?b ?A) = (?a = ?b | ?a : ?A)": thm
val mem_Collect_eq = "(?a : Collect ?P) = ?P ?a": thm
val rangeE = "[| ?b : range ?f; !!x. ?b = ?f x ==> ?P |] ==> ?P": thm
val rangeI = "?f ?x : range ?f": thm
val range_eqI = "?b = ?f ?x ==> ?b : range ?f": thm
val subsetCE = "[| ?A <= ?B; ?c ~: ?A ==> ?P; ?c : ?B ==> ?P |] ==> ?P": thm
val subsetD = "[| ?A <= ?B; ?c : ?A |] ==> ?c : ?B": thm
val subsetI = "(!!x. x : ?A ==> x : ?B) ==> ?A <= ?B": thm
val subset_refl = "?A <= ?A": thm
val subset_trans = "[| ?A <= ?B; ?B <= ?C |] ==> ?A <= ?C": thm
val vimageD = "?a : ?f -` ?A ==> ?f ?a : ?A": thm
val vimageE =
   "[| ?a : ?f -` ?B; !!x. [| ?f ?a = x; x : ?B |] ==> ?P |] ==> ?P": thm
val vimageI = "[| ?f ?a = ?b; ?b : ?B |] ==> ?a : ?f -` ?B": thm
val vimageI2 = "?f ?a : ?A ==> ?a : ?f -` ?A": thm
val vimage_Collect =
   "(!!x. ?P (?f x) = ?Q x) ==> ?f -` Collect ?P = Collect ?Q": thm
val vimage_Int = "?f -` (?A Int ?B) = ?f -` ?A Int ?f -` ?B": thm
val vimage_Un = "?f -` (?A Un ?B) = ?f -` ?A Un ?f -` ?B": thm
### theory "HOL.Set"
### 0.590s elapsed time, 0.636s cpu time, 0.065s GC time
Loading theory "HOL.Fun" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Inductive" via "HOL.Complete_Lattices")
Loading theory "HOL.Typedef" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type")
locale type_definition
  fixes Rep :: "'b => 'a"
    and Abs :: "'a => 'b"
    and A :: "'a set"
  assumes "type_definition Rep Abs A"
### ML warning (line 224 of "~~/src/HOL/Tools/typedef.ML"):
### Pattern is not exhaustive.
### ML warning (line 242 of "~~/src/HOL/Tools/typedef.ML"):
### Matches are not exhaustive.
### ML warning (line 246 of "~~/src/HOL/Tools/typedef.ML"):
### Pattern is not exhaustive.
### ML warning (line 320 of "~~/src/HOL/Tools/typedef.ML"):
### Matches are not exhaustive.
signature TYPEDEF =
  sig
    val add_typedef:
       {overloaded: bool} ->
         binding * (string * sort) list * mixfix ->
           term ->
             bindings option ->
               (Proof.context -> tactic) ->
                 local_theory -> (string * info) * local_theory
    val add_typedef_global:
       {overloaded: bool} ->
         binding * (string * sort) list * mixfix ->
           term ->
             bindings option ->
               (Proof.context -> tactic) ->
                 theory -> (string * info) * theory
    type bindings =
       {Abs_name: binding, Rep_name: binding, type_definition_name: binding}
    val default_bindings: binding -> bindings
    val get_info: Proof.context -> string -> info list
    val get_info_global: theory -> string -> info list
    type info =
       {Abs_name: string,
        Rep_name: string, abs_type: typ, axiom_name: string, rep_type: typ}
       *
       {Abs_cases: thm,
        Abs_induct: thm,
        Abs_inject: thm,
        Abs_inverse: thm,
        Rep: thm,
        Rep_cases: thm,
        Rep_induct: thm,
        Rep_inject: thm,
        Rep_inverse: thm, inhabited: thm, type_definition: thm}
    val interpretation:
       (string -> local_theory -> local_theory) -> theory -> theory
    val make_bindings: binding -> bindings option -> bindings
    val make_morphisms: binding -> (binding * binding) option -> bindings
    val overloaded: bool Config.T
    val transform_info: morphism -> info -> info
    val typedef:
       {overloaded: bool} ->
         binding * (string * sort) list * mixfix ->
           term -> bindings option -> local_theory -> Proof.state
    val typedef_cmd:
       {overloaded: bool} ->
         binding * (string * string option) list * mixfix ->
           string -> bindings option -> local_theory -> Proof.state
  end
structure Typedef: TYPEDEF
### theory "HOL.Typedef"
### 0.139s elapsed time, 0.311s cpu time, 0.065s GC time
class cancel_semigroup_add = semigroup_add +
  assumes "add_left_imp_eq": "!!a b c. a + b = a + c ==> b = c"
  assumes "add_right_imp_eq": "!!b a c. b + a = c + a ==> b = c"
class ab_group_add = cancel_comm_monoid_add + group_add +
  assumes "ab_left_minus": "!!a. - a + a = (0::'a)"
  assumes "ab_diff_conv_add_uminus": "!!a b. a - b = a + - b"
### ML warning (line 68 of "~~/src/HOL/Tools/functor.ML"):
### Matches are not exhaustive.
### ML warning (line 258 of "~~/src/HOL/Tools/functor.ML"):
### Matches are not exhaustive.
### ML warning (line 254 of "~~/src/HOL/Tools/functor.ML"):
### Matches are not exhaustive.
signature FUNCTOR =
  sig
    val construct_mapper:
       Proof.context ->
         (string * bool -> term) -> bool -> typ -> typ -> term
    val entries: Proof.context -> entry list Symtab.table
    type entry
    val find_atomic: Proof.context -> typ -> (typ * (bool * bool)) list
    val functor_: string option -> term -> local_theory -> Proof.state
    val functor_cmd: string option -> string -> Proof.context -> Proof.state
  end
structure Functor: FUNCTOR
### theory "HOL.Fun"
### 0.441s elapsed time, 0.639s cpu time, 0.116s GC time
Loading theory "HOL.Complete_Lattices" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type" via "HOL.Inductive")
Loading theory "HOL.Rings" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Fields" via "HOL.Nat")
class Inf = type +
  fixes Inf :: "'a set => 'a"
class Sup = type +
  fixes Sup :: "'a set => 'a"
class Inf = type +
  fixes Inf :: "'a set => 'a"
class Sup = type +
  fixes Sup :: "'a set => 'a"
class semiring = ab_semigroup_add + semigroup_mult +
  assumes "distrib_right": "!!a b c. (a + b) * c = a * c + b * c"
  assumes "distrib_left": "!!a b c. a * (b + c) = a * b + a * c"
class mult_zero = times + zero +
  assumes "mult_zero_left": "!!a. (0::'a) * a = (0::'a)"
  assumes "mult_zero_right": "!!a. a * (0::'a) = (0::'a)"
class comm_semiring = ab_semigroup_add + ab_semigroup_mult +
  assumes "distrib": "!!a b c. (a + b) * c = a * c + b * c"
class complete_lattice = Inf + Sup + lattice + bot + top +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class complete_lattice = Inf + Sup + bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class zero_neq_one = one + zero +
  assumes "zero_neq_one": "(0::'a) ~= (1::'a)"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult +
  assumes "mult_1": "!!a. (1::'a) * a = a"
class comm_semiring_1_cancel = cancel_comm_monoid_add + comm_monoid_mult +
  comm_semiring + zero_neq_one +
  assumes "right_diff_distrib'": "!!a b c. a * (b - c) = a * b - a * c"
class complete_lattice = Inf + Sup + bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class complete_distrib_lattice = complete_lattice +
  assumes
    "Inf_Sup_le":
      "!!A. \<Sqinter> (Sup ` A)
            <= \<Squnion> (Inf ` {f ` A |f. ALL Y:A. f Y : Y})"
class complete_lattice = Inf + Sup + bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class semiring_no_zero_divisors = semiring_0 +
  assumes
    "no_zero_divisors":
      "!!a b. [| a ~= (0::'a); b ~= (0::'a) |] ==> a * b ~= (0::'a)"
class semiring_no_zero_divisors_cancel = semiring_no_zero_divisors +
  assumes
    "mult_cancel_right": "!!a c b. (a * c = b * c) = (c = (0::'a) | a = b)"
    and
    "mult_cancel_left": "!!c a b. (c * a = c * b) = (c = (0::'a) | a = b)"
instantiation
  bool :: complete_lattice
  Inf_bool == Inf :: bool set => bool
  Sup_bool == Sup :: bool set => bool
instantiation
  fun :: (type, Inf) Inf
  Inf_fun == Inf :: ('a => 'b) set => 'a => 'b
instantiation
  fun :: (type, Sup) Sup
  Sup_fun == Sup :: ('a => 'b) set => 'a => 'b
instantiation
  fun :: (type, complete_lattice) complete_lattice
instantiation
  set :: (type) complete_lattice
  Inf_set == Inf :: 'a set set => 'a set
  Sup_set == Sup :: 'a set set => 'a set
class idom_abs_sgn = abs + sgn + idom +
  assumes "sgn_mult_abs": "!!a. sgn a * \<bar>a\<bar> = a"
    and "sgn_sgn": "!!a. sgn (sgn a) = sgn a"
    and "abs_abs": "!!a. \<bar>\<bar>a\<bar>\<bar> = \<bar>a\<bar>"
    and "abs_0": "\<bar>0::'a\<bar> = (0::'a)"
    and "sgn_0": "sgn (0::'a) = (0::'a)"
    and "sgn_1": "sgn (1::'a) = (1::'a)"
    and "sgn_minus_1": "sgn (- (1::'a)) = - (1::'a)"
    and "sgn_mult": "!!a b. sgn (a * b) = sgn a * sgn b"
### theory "HOL.Complete_Lattices"
### 1.265s elapsed time, 2.632s cpu time, 0.250s GC time
Loading theory "HOL.Inductive" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Product_Type")
class divide = type +
  fixes divide :: "'a => 'a => 'a"
class semiring = ab_semigroup_add + semigroup_mult +
  assumes "distrib_right": "!!a b c. (a + b) * c = a * c + b * c"
  assumes "distrib_left": "!!a b c. a * (b + c) = a * b + a * c"
class complete_lattice = Inf + Sup + bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class complete_lattice = Inf + Sup + bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class semidom_divide = divide + semidom +
  assumes
    "nonzero_mult_div_cancel_right":
      "!!b a. b ~= (0::'a) ==> a * b div b = a"
  assumes "div_by_0": "!!a. a div (0::'a) = (0::'a)"
class unit_factor = type +
  fixes unit_factor :: "'a => 'a"
### ML warning (line 132 of "~~/src/HOL/Tools/inductive.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 132 of "~~/src/HOL/Tools/inductive.ML"):
### Value identifier (g) has not been referenced.
### ML warning (line 132 of "~~/src/HOL/Tools/inductive.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 141 of "~~/src/HOL/Tools/inductive.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 141 of "~~/src/HOL/Tools/inductive.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 167 of "~~/src/HOL/Tools/inductive.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 443 of "~~/src/HOL/Tools/inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 721 of "~~/src/HOL/Tools/inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 841 of "~~/src/HOL/Tools/inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 915 of "~~/src/HOL/Tools/inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 947 of "~~/src/HOL/Tools/inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 1049 of "~~/src/HOL/Tools/inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 1228 of "~~/src/HOL/Tools/inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 1235 of "~~/src/HOL/Tools/inductive.ML"):
### Pattern is not exhaustive.
### ML warning (line 1255 of "~~/src/HOL/Tools/inductive.ML"):
### Matches are not exhaustive.
### ML warning (line 1260 of "~~/src/HOL/Tools/inductive.ML"):
### Pattern is not exhaustive.
signature INDUCTIVE =
  sig
    val add_ind_def: add_ind_def
    type add_ind_def =
       flags ->
         term list ->
           (Attrib.binding * term) list ->
             thm list ->
               term list ->
                 (binding * mixfix) list ->
                   local_theory -> result * local_theory
    val add_inductive:
       flags ->
         ((binding * typ) * mixfix) list ->
           (string * typ) list ->
             (Attrib.binding * term) list ->
               thm list -> local_theory -> result * local_theory
    val add_inductive_cmd:
       bool ->
         bool ->
           (binding * string option * mixfix) list ->
             (binding * string option * mixfix) list ->
               Specification.multi_specs_cmd ->
                 (Facts.ref * Token.src list) list ->
                   local_theory -> result * local_theory
    val arities_of: thm -> (string * int) list
    val declare_rules:
       binding ->
         bool ->
           bool ->
             binding ->
               string list ->
                 term list ->
                   thm list ->
                     binding list ->
                       Token.src list list ->
                         (thm * string list * int) list ->
                           thm list ->
                             thm ->
                               local_theory ->
                                 thm list * thm list * thm list * thm *
                                 thm list * local_theory
    type flags =
       {alt_name: binding,
        coind: bool,
        no_elim: bool,
        no_ind: bool, quiet_mode: bool, skip_mono: bool, verbose: bool}
    val gen_add_inductive:
       add_ind_def ->
         flags ->
           ((binding * typ) * mixfix) list ->
             (string * typ) list ->
               (Attrib.binding * term) list ->
                 thm list -> local_theory -> result * local_theory
    val gen_add_inductive_cmd:
       add_ind_def ->
         bool ->
           bool ->
             (binding * string option * mixfix) list ->
               (binding * string option * mixfix) list ->
                 Specification.multi_specs_cmd ->
                   (Facts.ref * Token.src list) list ->
                     local_theory -> result * local_theory
    val gen_ind_decl:
       add_ind_def -> bool -> (local_theory -> local_theory) parser
    val get_monos: Proof.context -> thm list
    val ind_cases_rules:
       Proof.context ->
         string list -> (binding * string option * mixfix) list -> thm list
    val inductive_cases:
       (Attrib.binding * term list) list ->
         local_theory -> (string * thm list) list * local_theory
    val inductive_cases_cmd:
       (Attrib.binding * string list) list ->
         local_theory -> (string * thm list) list * local_theory
    val inductive_forall_def: thm
    val inductive_internals: bool Config.T
    val inductive_simps:
       (Attrib.binding * term list) list ->
         local_theory -> (string * thm list) list * local_theory
    val inductive_simps_cmd:
       (Attrib.binding * string list) list ->
         local_theory -> (string * thm list) list * local_theory
    val infer_intro_vars: theory -> thm -> int -> thm list -> term list list
    type info = {coind: bool, names: string list} * result
    val mk_cases: Proof.context -> term -> thm
    val mk_cases_tac: Proof.context -> tactic
    val mono_add: attribute
    val mono_del: attribute
    val params_of: thm -> term list
    val partition_rules: thm -> thm list -> (string * thm list) list
    val partition_rules':
       thm -> (thm * 'a) list -> (string * (thm * 'a) list) list
    val print_inductives: bool -> Proof.context -> unit
    type result =
       {elims: thm list,
        eqs: thm list,
        induct: thm,
        inducts: thm list,
        intrs: thm list, preds: term list, raw_induct: thm}
    val rulify: Proof.context -> thm -> thm
    val select_disj_tac: Proof.context -> int -> int -> int -> tactic
    val the_inductive: Proof.context -> term -> info
    val the_inductive_global: Proof.context -> string -> info
    val transform_result: morphism -> result -> result
    val unpartition_rules: thm list -> (string * 'a list) list -> 'a list
  end
structure Inductive: INDUCTIVE
class semidom_divide_unit_factor = semidom_divide + unit_factor +
  assumes "unit_factor_0": "unit_factor (0::'a) = (0::'a)"
    and "is_unit_unit_factor": "!!a. a dvd (1::'a) ==> unit_factor a = a"
    and
    "unit_factor_is_unit": "!!a. a ~= (0::'a) ==> unit_factor a dvd (1::'a)"
    and
    "unit_factor_mult_unit_left":
      "!!a b. a dvd (1::'a) ==> unit_factor (a * b) = a * unit_factor b"
### ML warning (line 108 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_aux.ML"):
### Matches are not exhaustive.
### ML warning (line 140 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_aux.ML"):
### Matches are not exhaustive.
### ML warning (line 160 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 163 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 249 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_aux.ML"):
### Value identifier (descr) has not been referenced.
signature OLD_DATATYPE_COMMON =
  sig
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
  end
signature OLD_DATATYPE_AUX =
  sig
    exception Datatype
    exception Datatype_Empty of string
    val app_bnds: term -> int -> term
    val body_index: dtyp -> int
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    val dest_DtRec: dtyp -> int
    val dest_DtTFree: dtyp -> string * sort
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    val dtyp_of_typ: (string * (string * sort) list) list -> typ -> dtyp
    val exh_tac: Proof.context -> (string -> thm) -> int -> tactic
    val find_shortest_path: descr -> int -> (string * int) option
    val get_arities: descr -> int list
    val get_branching_types: descr -> typ list
    val get_nonrec_types: descr -> typ list
    val get_rec_types: descr -> typ list
    val ind_tac: Proof.context -> thm -> string list -> int -> tactic
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val interpret_construction:
       descr ->
         (string * sort) list ->
           {atyp: typ -> 'a,
            dtyp: typ list -> int * bool -> string * typ list -> 'a}
             -> ((string * typ list) * (string * 'a list) list) list
    val is_rec_type: dtyp -> bool
    val message: config -> string -> unit
    val mk_Free: string -> typ -> int -> term
    val mk_conj: term list -> term
    val mk_disj: term list -> term
    val mk_fun_dtyp: dtyp list -> dtyp -> dtyp
    val name_of_typ: typ -> string
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    val split_conj_thm: thm -> thm list
    val store_thms:
       string -> string list -> thm list -> theory -> thm list * theory
    val store_thms_atts:
       string ->
         string list ->
           attribute list list -> thm list -> theory -> thm list * theory
    val store_thmss:
       string ->
         string list -> thm list list -> theory -> thm list list * theory
    val store_thmss_atts:
       string ->
         string list ->
           attribute list list ->
             thm list list -> theory -> thm list list * theory
    val strip_dtyp: dtyp -> dtyp list * dtyp
    val typ_of_dtyp: descr -> dtyp -> typ
    val unfold_datatypes:
       Proof.context ->
         descr -> info Symtab.table -> descr -> int -> descr list * int
  end
structure Old_Datatype_Aux: OLD_DATATYPE_AUX
class normalization_semidom = algebraic_semidom +
  semidom_divide_unit_factor +
  fixes normalize :: "'a => 'a"
  assumes
    "unit_factor_mult_normalize": "!!a. unit_factor a * normalize a = a"
    and "normalize_0": "normalize (0::'a) = (0::'a)"
### ML warning (line 33 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Value identifier (make_tnames) has not been referenced.
### ML warning (line 37 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Matches are not exhaustive.
### ML warning (line 201 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 228 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Value identifier (U) has not been referenced.
### ML warning (line 217 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Matches are not exhaustive.
### ML warning (line 249 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 257 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 315 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Matches are not exhaustive.
### ML warning (line 317 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Matches are not exhaustive.
### ML warning (line 340 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Pattern is not exhaustive.
### ML warning (line 370 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_prop.ML"):
### Pattern is not exhaustive.
signature OLD_DATATYPE_PROP =
  sig
    type descr = Old_Datatype_Aux.descr
    val indexify_names: string list -> string list
    val make_case_combs:
       string list -> descr list -> theory -> string -> term list
    val make_case_cong_weaks:
       string list -> descr list -> theory -> term list
    val make_case_congs: string list -> descr list -> theory -> term list
    val make_casedists: descr list -> term list
    val make_cases: string list -> descr list -> theory -> term list list
    val make_distincts: descr list -> term list list
    val make_ind: descr list -> term
    val make_injs: descr list -> term list list
    val make_nchotomys: descr list -> term list
    val make_primrec_Ts: descr list -> string list -> typ list * typ list
    val make_primrecs: string list -> descr list -> theory -> term list
    val make_splits:
       string list -> descr list -> theory -> (term * term) list
    val make_tnames: typ list -> string list
  end
structure Old_Datatype_Prop: OLD_DATATYPE_PROP
### ML warning (line 98 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 153 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_data.ML"):
### Matches are not exhaustive.
### ML warning (line 248 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_data.ML"):
### Matches are not exhaustive.
signature OLD_DATATYPE_DATA =
  sig
    val all_distincts: theory -> typ list -> thm list list
    type config = {quiet: bool, strict: bool}
    val default_config: config
    type descr =
       (int * (string * dtyp list * (string * dtyp list) list)) list
    datatype dtyp
    = DtRec of int | DtTFree of string * sort | DtType of string * dtyp list
    val get_all: theory -> info Symtab.table
    val get_constrs: theory -> string -> (string * typ) list option
    val get_info: theory -> string -> info option
    type info =
       {case_cong: thm,
        case_cong_weak: thm,
        case_name: string,
        case_rewrites: thm list,
        descr: descr,
        distinct: thm list,
        exhaust: thm,
        index: int,
        induct: thm,
        inducts: thm list,
        inject: thm list,
        nchotomy: thm,
        rec_names: string list,
        rec_rewrites: thm list, split: thm, split_asm: thm}
    val info_of_case: theory -> string -> info option
    val info_of_constr: theory -> string * typ -> info option
    val info_of_constr_permissive: theory -> string * typ -> info option
    val interpretation:
       (config -> string list -> theory -> theory) -> theory -> theory
    val interpretation_data: config * string list -> theory -> theory
    val mk_case_names_exhausts: descr -> string list -> attribute list
    val mk_case_names_induct: descr -> attribute
    val register: (string * info) list -> theory -> theory
    type spec =
       (binding * (string * sort) list * mixfix) *
       (binding * typ list * mixfix) list
    val the_descr:
       theory ->
         string list ->
           descr * (string * sort) list * string list * string *
           (string list * string list) * (typ list * typ list)
    val the_info: theory -> string -> info
    val the_spec:
       theory -> string -> (string * sort) list * (string * typ list) list
  end
structure Old_Datatype_Data: OLD_DATATYPE_DATA
class normalization_semidom_multiplicative = normalization_semidom +
  assumes
    "unit_factor_mult":
      "!!a b. unit_factor (a * b) = unit_factor a * unit_factor b"
class modulo = divide + dvd +
  fixes modulo :: "'a => 'a => 'a"
class semiring_modulo = comm_semiring_1_cancel + modulo +
  assumes "div_mult_mod_eq": "!!a b. a div b * b + a mod b = a"
### ML warning (line 43 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 167 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Value identifier (T') has not been referenced.
### ML warning (line 167 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 178 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Value identifier (cname) has not been referenced.
### ML warning (line 178 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 338 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 312 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 353 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 361 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Matches are not exhaustive.
### ML warning (line 388 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 458 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 459 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 461 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 562 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Value identifier (dtname) has not been referenced.
### ML warning (line 600 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Pattern is not exhaustive.
### ML warning (line 666 of "~~/src/HOL/Tools/Old_Datatype/old_rep_datatype.ML"):
### Pattern is not exhaustive.
signature OLD_REP_DATATYPE =
  sig
    val derive_datatype_props:
       Old_Datatype_Aux.config ->
         string list ->
           Old_Datatype_Aux.descr list ->
             thm ->
               thm list list ->
                 thm list list -> theory -> string list * theory
    val rep_datatype:
       Old_Datatype_Aux.config ->
         (string list -> Proof.context -> Proof.context) ->
           term list -> theory -> Proof.state
    val rep_datatype_cmd:
       Old_Datatype_Aux.config ->
         (string list -> Proof.context -> Proof.context) ->
           string list -> theory -> Proof.state
  end
structure Old_Rep_Datatype: OLD_REP_DATATYPE
### ML warning (line 17 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_codegen.ML"):
### Pattern is not exhaustive.
### ML warning (line 18 of "~~/src/HOL/Tools/Old_Datatype/old_datatype_codegen.ML"):
### Pattern is not exhaustive.
signature OLD_DATATYPE_CODEGEN = sig end
structure Old_Datatype_Codegen: OLD_DATATYPE_CODEGEN
### ML warning (line 249 of "~~/src/HOL/Tools/BNF/bnf_fp_rec_sugar_util.ML"):
### Matches are not exhaustive.
### ML warning (line 262 of "~~/src/HOL/Tools/BNF/bnf_fp_rec_sugar_util.ML"):
### Matches are not exhaustive.
signature BNF_FP_REC_SUGAR_UTIL =
  sig
    val case_fp: fp_kind -> 'a -> 'a -> 'a
    val check_all_fun_arg_frees:
       Proof.context -> term list -> term list -> unit
    val check_duplicate_const_names: binding list -> unit
    val check_duplicate_variables_in_lhs:
       Proof.context -> term list -> term list -> unit
    val check_top_sort: Proof.context -> binding -> typ -> unit
    val conj_dests: int -> thm -> thm list
    val drop_all: term -> term
    val error_at: Proof.context -> term list -> string -> 'a
    val excess_equations: Proof.context -> term list -> 'a
    val exists_strict_subtype_in: typ list -> typ -> bool
    val exists_subtype_in: typ list -> typ -> bool
    val extra_variable_in_rhs: Proof.context -> term list -> term -> 'a
    val find_index_eq: ''a list -> ''a -> int
    val find_indices: ('a * 'b -> bool) -> 'b list -> 'a list -> int list
    val finds:
       ('a * 'b -> bool) ->
         'a list -> 'b list -> ('a * 'b list) list * 'b list
    val flat_rec_arg_args: 'a list list -> 'a list
    datatype fp_kind = Greatest_FP | Least_FP
    type fp_rec_sugar =
       {fpTs: typ list,
        fun_defs: thm list,
        fun_names: string list, funs: term list, transfers: bool list}
    val ill_formed_corec_call: Proof.context -> term -> 'a
    val ill_formed_equation: Proof.context -> term -> 'a
    val ill_formed_equation_head: Proof.context -> term list -> 'a
    val ill_formed_equation_lhs_rhs: Proof.context -> term list -> 'a
    val ill_formed_formula: Proof.context -> term -> 'a
    val ill_formed_rec_call: Proof.context -> term -> 'a
    val inconstant_pattern_pos_for_fun:
       Proof.context -> term list -> string -> 'a
    val indexed: 'a list -> int -> int list * int
    val indexedd: 'a list list -> int -> int list list * int
    val indexeddd: 'a list list list -> int -> int list list list * int
    val indexedddd:
       'a list list list list -> int -> int list list list list * int
    val invalid_map: Proof.context -> term list -> term -> 'a
    val missing_args_to_fun_on_lhs: Proof.context -> term list -> 'a
    val missing_equations_for_const: string -> 'a
    val missing_equations_for_fun: string -> 'a
    val missing_pattern: Proof.context -> term list -> 'a
    val mk_co_rec: theory -> fp_kind -> typ list -> typ -> term -> term
    val mk_common_name: string list -> string
    val mk_comp: typ list -> term * term -> term
    val mk_compN: int -> typ list -> term * term -> term
    val mk_conjunctN: int -> int -> thm
    val mk_partial_compN: int -> typ -> term -> term
    val more_than_one_nonvar_in_lhs: Proof.context -> term list -> 'a
    val morph_fp_rec_sugar: morphism -> fp_rec_sugar -> fp_rec_sugar
    val multiple_equations_for_ctr: Proof.context -> term list -> 'a
    val no_equation_for_ctr_warning:
       Proof.context -> term list -> term -> unit
    val nonprimitive_corec: Proof.context -> term list -> 'a
    val nonprimitive_pattern_in_lhs: Proof.context -> term list -> 'a
    val not_codatatype: Proof.context -> typ -> 'a
    val not_constructor_in_pattern: Proof.context -> term list -> term -> 'a
    val not_constructor_in_rhs: Proof.context -> term list -> term -> 'a
    val not_datatype: Proof.context -> typ -> 'a
    val num_binder_types: typ -> int
    val order_strong_conn:
       ('a * 'a -> bool) ->
         ((('a * unit) * 'a list) list -> 'b) ->
           ('b -> 'a list) ->
             ('a * 'a list) list -> 'a list list -> 'a list list
    val partially_applied_ctr_in_pattern: Proof.context -> term list -> 'a
    val partially_applied_ctr_in_rhs: Proof.context -> term list -> 'a
    val permute_args: int -> term -> term
    val print_def_consts:
       bool -> (term * (string * thm)) list -> Proof.context -> unit
    val rec_call_not_apply_to_ctr_arg:
       Proof.context -> term list -> term -> 'a
    val retype_const_or_free: typ -> term -> term
    val too_few_args_in_rec_call: Proof.context -> term list -> term -> 'a
    val transfer_fp_rec_sugar: theory -> fp_rec_sugar -> fp_rec_sugar
    val tvar_subst:
       theory -> typ list -> typ list -> ((string * int) * typ) list
    val unexpected_corec_call_in: Proof.context -> term list -> term -> 'a
    val unexpected_rec_call_in: Proof.context -> term list -> term -> 'a
    val unsupported_case_around_corec_call:
       Proof.context -> term list -> term -> 'a
    val warning_at: Proof.context -> term list -> string -> unit
  end
structure BNF_FP_Rec_Sugar_Util: BNF_FP_REC_SUGAR_UTIL
### ML warning (line 137 of "~~/src/HOL/Tools/Old_Datatype/old_primrec.ML"):
### Matches are not exhaustive.
### ML warning (line 200 of "~~/src/HOL/Tools/Old_Datatype/old_primrec.ML"):
### Pattern is not exhaustive.
signature OLD_PRIMREC =
  sig
    val primrec:
       bool ->
         (binding * typ option * mixfix) list ->
           Specification.multi_specs ->
             local_theory ->
               {result: term list * thm list, types: string list} *
               local_theory
    val primrec_cmd:
       bool ->
         (binding * string option * mixfix) list ->
           Specification.multi_specs_cmd ->
             local_theory ->
               {result: term list * thm list, types: string list} *
               local_theory
    val primrec_global:
       bool ->
         (binding * typ option * mixfix) list ->
           Specification.multi_specs ->
             theory -> (term list * thm list) * theory
    val primrec_overloaded:
       bool ->
         (string * (string * typ) * bool) list ->
           (binding * typ option * mixfix) list ->
             Specification.multi_specs ->
               theory -> (term list * thm list) * theory
    val primrec_simple:
       bool ->
         ((binding * typ) * mixfix) list ->
           term list ->
             local_theory ->
               {prefix: string,
                result: term list * thm list, types: string list}
               *
               local_theory
  end
structure Old_Primrec: OLD_PRIMREC
### ML warning (line 68 of "~~/src/HOL/Tools/arith_data.ML"):
### Value identifier (T) has not been referenced.
signature ARITH_DATA =
  sig
    val add_tactic:
       string -> (Proof.context -> int -> tactic) -> theory -> theory
    val arith_tac: Proof.context -> int -> tactic
    val dest_sum: term -> term list
    val long_mk_sum: typ -> term list -> term
    val mk_number: typ -> int -> term
    val mk_sum: typ -> term list -> term
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val prove_conv2:
       tactic ->
         (Proof.context -> tactic) -> Proof.context -> term * term -> thm
    val prove_conv_nohyps:
       tactic list -> Proof.context -> term * term -> thm option
    val simp_all_tac: thm list -> Proof.context -> tactic
    val simplify_meta_eq: thm list -> Proof.context -> thm -> thm
  end
structure Arith_Data: ARITH_DATA
signature CANCEL_DIV_MOD_DATA =
  sig
    val dest_sum: term -> term list
    val div_mod_eqs: thm list
    val div_name: string
    val mk_binop: string -> term * term -> term
    val mk_sum: typ -> term list -> term
    val mod_name: string
    val prove_eq_sums: Proof.context -> term * term -> thm
  end
signature CANCEL_DIV_MOD =
  sig val proc: Proof.context -> cterm -> thm option end
functor Cancel_Div_Mod (Data: CANCEL_DIV_MOD_DATA): CANCEL_DIV_MOD
structure Cancel_Div_Mod_Ring: CANCEL_DIV_MOD
### ML warning (line 248 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 387 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 389 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 391 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 411 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 477 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 552 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 635 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 636 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML"):
### Matches are not exhaustive.
signature BNF_LFP_REC_SUGAR =
  sig
    type basic_lfp_sugar =
       {C: typ,
        T: typ,
        ctr_sugar: Ctr_Sugar.ctr_sugar,
        fp_res_index: int,
        fun_arg_Tsss: typ list list list, rec_thms: thm list, recx: term}
    val default_basic_lfp_sugars_of:
       binding list ->
         typ list ->
           term list ->
             (term * term list list) list list ->
               local_theory ->
                 typ list * int list * basic_lfp_sugar list * thm list *
                 thm list * thm list * thm * Token.src list * bool *
                 local_theory
    type lfp_rec_extension =
       {basic_lfp_sugars_of:
        binding list ->
          typ list ->
            term list ->
              (term * term list list) list list ->
                local_theory ->
                  typ list * int list * basic_lfp_sugar list * thm list *
                  thm list * thm list * thm * Token.src list * bool *
                  local_theory
        ,
        is_new_datatype: Proof.context -> string -> bool,
        nested_simps: thm list,
        rewrite_nested_rec_call:
        (Proof.context ->
           (term -> bool) ->
             (string -> int) -> typ list -> term -> term -> term -> term
        )
        option
        ,
        special_endgame_tac:
        Proof.context -> thm list -> thm list -> thm list -> tactic}
    val lfp_rec_sugar_interpretation:
       string ->
         (BNF_FP_Rec_Sugar_Util.fp_rec_sugar ->
            local_theory -> local_theory)
           -> theory -> theory
    val primrec:
       bool ->
         rec_option list ->
           (binding * typ option * mixfix) list ->
             Specification.multi_specs ->
               local_theory ->
                 (term list * thm list * thm list list) * local_theory
    val primrec_cmd:
       bool ->
         rec_option list ->
           (binding * string option * mixfix) list ->
             Specification.multi_specs_cmd ->
               local_theory ->
                 (term list * thm list * thm list list) * local_theory
    val primrec_global:
       bool ->
         rec_option list ->
           (binding * typ option * mixfix) list ->
             Specification.multi_specs ->
               theory -> (term list * thm list * thm list list) * theory
    val primrec_overloaded:
       bool ->
         rec_option list ->
           (string * (string * typ) * bool) list ->
             (binding * typ option * mixfix) list ->
               Specification.multi_specs ->
                 theory -> (term list * thm list * thm list list) * theory
    val primrec_simple:
       bool ->
         ((binding * typ) * mixfix) list ->
           term list ->
             local_theory ->
               ((string list * (binding -> binding) list) *
                (term list * thm list * (int list list * thm list list)))
               *
               local_theory
    datatype rec_call
    =
         Mutual_Rec of (int * typ) * (int * typ)
       | Nested_Rec of int * typ
       | No_Rec of int * typ
    type rec_ctr_spec =
       {calls: rec_call list, ctr: term, offset: int, rec_thm: thm}
    datatype rec_option
    =
         Nonexhaustive_Option
       | Plugins_Option of Proof.context -> Plugin_Name.filter
       | Transfer_Option
    type rec_spec =
       {ctr_specs: rec_ctr_spec list,
        fp_nesting_map_comps: thm list,
        fp_nesting_map_ident0s: thm list,
        fp_nesting_pred_maps: thm list, recx: term}
    val rec_specs_of:
       binding list ->
         typ list ->
           typ list ->
             term list ->
               (term * term list list) list list ->
                 local_theory ->
                   (bool * rec_spec list * typ list * thm * thm list *
                    Token.src list * typ list)
                   *
                   local_theory
    val register_lfp_rec_extension: lfp_rec_extension -> theory -> theory
  end
structure BNF_LFP_Rec_Sugar: BNF_LFP_REC_SUGAR
### theory "HOL.Inductive"
### 1.398s elapsed time, 2.927s cpu time, 0.294s GC time
Loading theory "HOL.Product_Type" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set")
Loading theory "HOL.Sum_Type" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set")
Proofs for inductive predicate(s) "rec_set_bool"
### Ignoring duplicate safe elimination (elim!)
### True = False ==> ?R
### Ignoring duplicate safe elimination (elim!)
### False = True ==> ?R
### Ignoring duplicate rewrite rule:
### HOL.induct_equal HOL.induct_true HOL.induct_false == HOL.induct_false
### Ignoring duplicate rewrite rule:
### HOL.induct_equal HOL.induct_false HOL.induct_true == HOL.induct_false
class ordered_semiring = ordered_comm_monoid_add + semiring +
  assumes
    "mult_left_mono":
      "!!a b c. [| a <= b; (0::'a) <= c |] ==> c * a <= c * b"
  assumes
    "mult_right_mono":
      "!!a b c. [| a <= b; (0::'a) <= c |] ==> a * c <= b * c"
Proofs for inductive predicate(s) "rec_set_unit"
Proofs for inductive predicate(s) "rec_set_sum"
instantiation
  unit :: default
  default_unit == default :: unit
instantiation
  unit :: {complete_boolean_algebra,complete_linorder,wellorder}
  minus_unit == minus :: unit => unit => unit
  uminus_unit == uminus :: unit => unit
  Inf_unit == Inf :: unit set => unit
  Sup_unit == Sup :: unit set => unit
  bot_unit == bot :: unit
  sup_unit == sup :: unit => unit => unit
  top_unit == top :: unit
  inf_unit == inf :: unit => unit => unit
  less_eq_unit == less_eq :: unit => unit => bool
  less_unit == less :: unit => unit => bool
consts
  map_sum :: "('a => 'c) => ('b => 'd) => 'a + 'b => 'c + 'd"
### No equation for constructor "Inr"
consts
  Suml :: "('a => 'c) => 'a + 'b => 'c"
### No equation for constructor "Inl"
consts
  Sumr :: "('b => 'c) => 'a + 'b => 'c"
### theory "HOL.Sum_Type"
### 0.156s elapsed time, 0.471s cpu time, 0.037s GC time
Proofs for inductive predicate(s) "rec_set_prod"
val split_all_tac = fn: Proof.context -> int -> tactic
val unsafe_split_all_tac = fn: Proof.context -> int -> tactic
val split_all = fn: Proof.context -> thm -> thm
### ML warning (line 543 of "~~/src/HOL/Product_Type.thy"):
### Value identifier (i) has not been referenced.
### ML warning (line 543 of "~~/src/HOL/Product_Type.thy"):
### Value identifier (tp) has not been referenced.
### ML warning (line 558 of "~~/src/HOL/Product_Type.thy"):
### Value identifier (i) has not been referenced.
### ML warning (line 558 of "~~/src/HOL/Product_Type.thy"):
### Value identifier (k) has not been referenced.
### ML warning (line 558 of "~~/src/HOL/Product_Type.thy"):
### Value identifier (arg) has not been referenced.
### ML warning (line 567 of "~~/src/HOL/Product_Type.thy"):
### Pattern is not exhaustive.
val beta_proc = fn: Proof.context -> term -> thm option
val eta_proc = fn: Proof.context -> term -> thm option
val split_conv_tac = fn: Proof.context -> int -> tactic
### ML warning (line 39 of "~~/src/HOL/Tools/split_rule.ML"):
### Value identifier (T3) has not been referenced.
### ML warning (line 56 of "~~/src/HOL/Tools/split_rule.ML"):
### Value identifier (t) has not been referenced.
signature SPLIT_RULE =
  sig
    val complete_split_rule: Proof.context -> thm -> thm
    val split_rule: Proof.context -> thm -> thm
    val split_rule_var: Proof.context -> term -> thm -> thm
  end
structure Split_Rule: SPLIT_RULE
bundle state_combinator_syntax
class zero_less_one = one + zero + order +
  assumes "zero_less_one": "(0::'a) < (1::'a)"
bundle no_Set_Product_syntax
bundle Set_Product_syntax
class linordered_semiring_strict = comm_monoid_add +
  linordered_cancel_ab_semigroup_add + semiring +
  assumes
    "mult_strict_left_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> c * a < c * b"
  assumes
    "mult_strict_right_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> a * c < b * c"
### ML warning (line 43 of "~~/src/HOL/Tools/set_comprehension_pointfree.ML"):
### Pattern is not exhaustive.
### ML warning (line 62 of "~~/src/HOL/Tools/set_comprehension_pointfree.ML"):
### Pattern is not exhaustive.
### ML warning (line 116 of "~~/src/HOL/Tools/set_comprehension_pointfree.ML"):
### Matches are not exhaustive.
### ML warning (line 132 of "~~/src/HOL/Tools/set_comprehension_pointfree.ML"):
### Matches are not exhaustive.
### ML warning (line 229 of "~~/src/HOL/Tools/set_comprehension_pointfree.ML"):
### Pattern is not exhaustive.
### ML warning (line 273 of "~~/src/HOL/Tools/set_comprehension_pointfree.ML"):
### Matches are not exhaustive.
### ML warning (line 498 of "~~/src/HOL/Tools/set_comprehension_pointfree.ML"):
### Pattern is not exhaustive.
### ML warning (line 505 of "~~/src/HOL/Tools/set_comprehension_pointfree.ML"):
### Pattern is not exhaustive.
signature SET_COMPREHENSION_POINTFREE =
  sig
    val base_simproc: Proof.context -> cterm -> thm option
    val code_simproc: Proof.context -> cterm -> thm option
    val simproc: Proof.context -> cterm -> thm option
  end
structure Set_Comprehension_Pointfree: SET_COMPREHENSION_POINTFREE
### ML warning (line 117 of "~~/src/HOL/Tools/inductive_set.ML"):
### Value identifier (b) has not been referenced.
### ML warning (line 168 of "~~/src/HOL/Tools/inductive_set.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 232 of "~~/src/HOL/Tools/inductive_set.ML"):
### Pattern is not exhaustive.
### ML warning (line 432 of "~~/src/HOL/Tools/inductive_set.ML"):
### Matches are not exhaustive.
### ML warning (line 484 of "~~/src/HOL/Tools/inductive_set.ML"):
### Matches are not exhaustive.
signature INDUCTIVE_SET =
  sig
    val add_inductive:
       Inductive.flags ->
         ((binding * typ) * mixfix) list ->
           (string * typ) list ->
             (Attrib.binding * term) list ->
               thm list -> local_theory -> Inductive.result * local_theory
    val add_inductive_cmd:
       bool ->
         bool ->
           (binding * string option * mixfix) list ->
             (binding * string option * mixfix) list ->
               Specification.multi_specs_cmd ->
                 (Facts.ref * Token.src list) list ->
                   local_theory -> Inductive.result * local_theory
    val mono_add: attribute
    val mono_del: attribute
    val pred_set_conv_att: attribute
    val to_pred: thm list -> Context.generic -> thm -> thm
    val to_pred_att: thm list -> attribute
    val to_set_att: thm list -> attribute
  end
structure Inductive_Set: INDUCTIVE_SET
### theory "HOL.Product_Type"
### 0.975s elapsed time, 2.182s cpu time, 0.228s GC time
Loading theory "HOL.Complete_Partial_Order" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Fun_Def" via "HOL.Partial_Function")
class ordered_comm_semiring = ordered_ab_semigroup_add + comm_semiring_0 +
  assumes
    "comm_mult_left_mono":
      "!!a b c. [| a <= b; (0::'a) <= c |] ==> c * a <= c * b"
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x. [| chain (<=) A; x : A |] ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| chain (<=) A; !!x. x : A ==> x <= z |] ==> \<Squnion> A <= z"
Proofs for inductive predicate(s) "iteratesp"
  Proving monotonicity ...
class ccpo = Sup + order +
  assumes
    "ccpo_Sup_upper":
      "!!A x. [| chain (<=) A; x : A |] ==> x <= \<Squnion> A"
  assumes
    "ccpo_Sup_least":
      "!!A z.
          [| chain (<=) A; !!x. x : A ==> x <= z |] ==> \<Squnion> A <= z"
### theory "HOL.Complete_Partial_Order"
### 0.204s elapsed time, 0.416s cpu time, 0.024s GC time
class linordered_comm_semiring_strict = linordered_cancel_ab_semigroup_add +
  comm_semiring_0 +
  assumes
    "comm_mult_strict_left_mono":
      "!!a b c. [| a < b; (0::'a) < c |] ==> c * a < c * b"
class abs_if = abs + minus + uminus + zero + ord +
  assumes "abs_if": "!!a. \<bar>a\<bar> = (if a < (0::'a) then - a else a)"
class linordered_nonzero_semiring = monoid_mult + linorder +
  ordered_comm_semiring + zero_less_one +
  assumes "add_mono1": "!!a b. a < b ==> a + (1::'a) < b + (1::'a)"
### Ignoring duplicate rewrite rule:
### (0::'a) <= (1::'a) == True
class linordered_semidom = linordered_comm_semiring_strict + semidom +
  zero_less_one +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
class linordered_idom = ordered_ab_group_add + sgn + abs_if + comm_ring_1 +
  linordered_comm_semiring_strict +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
class linordered_idom = idom_abs_sgn + linordered_ring_strict +
  linordered_semidom + linordered_semiring_1_strict + ordered_comm_ring +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
class linordered_idom = idom_abs_sgn + linordered_ring_strict +
  linordered_semidom + linordered_semiring_1_strict + ordered_comm_ring +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
class ordered_ring_abs = ordered_ab_group_add_abs + ordered_ring +
  assumes
    "abs_eq_mult":
      "!!a b.
          ((0::'a) <= a | a <= (0::'a)) & ((0::'a) <= b | b <= (0::'a)) ==>
          \<bar>a * b\<bar> = \<bar>a\<bar> * \<bar>b\<bar>"
class linordered_idom = idom_abs_sgn + linordered_ring_strict +
  linordered_semidom + linordered_semiring_1_strict + ordered_comm_ring +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "HOL.Rings"
### 6.418s elapsed time, 10.913s cpu time, 1.020s GC time
Loading theory "HOL.Nat" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set" via "HOL.Fields")
Proofs for inductive predicate(s) "Nat"
  Proving monotonicity ...
instantiation
  nat :: zero
  zero_nat == zero_class.zero :: nat
Proofs for inductive predicate(s) "rec_set_nat"
val nat_basic_lfp_sugar =
   {C = "?'a", T = "nat", ctr_sugar =
    {T = "nat", case_cong =
     "[| ?nat = ?nat'; ?nat' = 0 ==> ?f1.0 = ?g1.0;
         !!x2. ?nat' = Suc x2 ==> ?f2.0 x2 = ?g2.0 x2 |]
      ==> (case ?nat of 0 => ?f1.0 | Suc x2 => ?f2.0 x2) =
          (case ?nat' of 0 => ?g1.0 | Suc x2 => ?g2.0 x2)",
     case_cong_weak =
     "?nat = ?nat' ==>
      (case ?nat of 0 => ?f1.0 | Suc x => ?f2.0 x) =
      (case ?nat' of 0 => ?f1.0 | Suc x => ?f2.0 x)",
     case_distribs =
     ["?h (case ?nat of 0 => ?f1.0 | Suc x => ?f2.0 x) =
       (case ?nat of 0 => ?h ?f1.0 | Suc x => ?h (?f2.0 x))"],
     case_eq_ifs =
     ["(case ?nat of 0 => ?f1.0 | Suc x => ?f2.0 x) =
       (if ?nat = 0 then ?f1.0 else ?f2.0 (nat.pred ?nat))"],
     case_thms =
     ["(case 0 of 0 => ?f1.0 | Suc x => ?f2.0 x) = ?f1.0",
      "(case Suc ?x2.0 of 0 => ?f1.0 | Suc x => ?f2.0 x) = ?f2.0 ?x2.0"],
     casex =
     Const ("Nat.nat.case_nat", "?'a => (nat => ?'a) => nat => ?'a"),
     collapses =
     ["?nat = 0 ==> ?nat = 0", "?nat ~= 0 ==> Suc (nat.pred ?nat) = ?nat"],
     ctrs =
     [Const ("Groups.zero_class.zero", "nat"),
      Const ("Nat.Suc", "nat => nat")],
     discIs = ["?P ==> ?P", "?nat = Suc ?x2.0 ==> ?nat ~= 0"], disc_defs =
     [], disc_eq_cases =
     ["(?nat = 0) = (case ?nat of 0 => True | Suc uu_ => False)",
      "(?nat ~= 0) = (case ?nat of 0 => False | Suc uu_ => True)"],
     disc_thmss =
     [["?t = ?t", "Suc ?x2.0 ~= 0"], ["~ 0 ~= 0", "Suc ?x2.0 ~= 0"]],
     discs =
     [Abs ("nat", "nat",
        Const ("HOL.eq", "nat => nat => bool") $ Bound 0 $
          Const ("Groups.zero_class.zero", "nat")),
      Abs ("nat", "nat",
        Const ("HOL.Not", "bool => bool") $
          (Const ("HOL.eq", "nat => nat => bool") $ Bound 0 $
            Const ("Groups.zero_class.zero", "nat")))],
     distinct_discsss =
     [[[], ["?nat = 0 ==> ~ ?nat ~= 0"]],
      [["?nat ~= 0 ==> ?nat ~= 0"], []]],
     distincts = ["0 ~= Suc ?x2.0", "Suc ?x2.0 ~= 0"], exhaust =
     "[| ?y = 0 ==> ?P; !!x2. ?y = Suc x2 ==> ?P |] ==> ?P", exhaust_discs =
     ["[| ?nat = 0 ==> ?P; ?nat ~= 0 ==> ?P |] ==> ?P"], exhaust_sels =
     ["[| ?nat = 0 ==> ?P; ?nat = Suc (nat.pred ?nat) ==> ?P |] ==> ?P"],
     expands =
     ["[| (?nat = 0) = (?nat' = 0);
          [| ?nat ~= 0; ?nat' ~= 0 |] ==> nat.pred ?nat = nat.pred ?nat' |]
       ==> ?nat = ?nat'"],
     ...},
    fp_res_index = 0, fun_arg_Tsss = [[], [["nat", "?'a"]]], rec_thms =
    ["rec_nat ?f1.0 ?f2.0 0 = ?f1.0",
     "rec_nat ?f1.0 ?f2.0 (Suc ?nat) =
      ?f2.0 ?nat (rec_nat ?f1.0 ?f2.0 ?nat)"],
    recx =
    Const ("Nat.old.nat.rec_nat",
           "?'a => (nat => ?'a => ?'a) => nat => ?'a")}:
   {C: typ,
    T: typ,
    ctr_sugar: Ctr_Sugar.ctr_sugar,
    fp_res_index: int,
    fun_arg_Tsss: typ list list list, rec_thms: thm list, recx: term}
instantiation
  nat :: comm_monoid_diff
  minus_nat == minus :: nat => nat => nat
  plus_nat == plus :: nat => nat => nat
consts
  plus_nat :: "nat => nat => nat"
consts
  minus_nat :: "nat => nat => nat"
instantiation
  nat :: comm_semiring_1_cancel
  one_nat == one_class.one :: nat
  times_nat == times :: nat => nat => nat
consts
  times_nat :: "nat => nat => nat"
instantiation
  nat :: linorder
  less_eq_nat == less_eq :: nat => nat => bool
  less_nat == less :: nat => nat => bool
consts
  less_eq_nat :: "nat => nat => bool"
instantiation
  nat :: order_bot
  bot_nat == bot :: nat
### Ignoring duplicate rewrite rule:
### max 0 ?y == ?y
### Ignoring duplicate rewrite rule:
### max ?y 0 == ?y
instantiation
  nat :: distrib_lattice
  inf_nat == inf :: nat => nat => nat
  sup_nat == sup :: nat => nat => nat
overloading
  funpow \<equiv> compow :: nat => ('a => 'a) => 'a => 'a
consts
  funpow :: "nat => ('a => 'a) => 'a => 'a"
consts
  of_nat_aux :: "('a => 'a) => nat => 'a => 'a"
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
class linordered_nonzero_semiring = linorder + comm_semiring_1 +
  ordered_comm_semiring + zero_less_one +
  assumes "add_mono1": "!!a b. a < b ==> a + (1::'a) < b + (1::'a)"
class linordered_nonzero_semiring = semiring_char_0 + linorder +
  comm_semiring_1 + ordered_comm_semiring + zero_less_one +
  assumes "add_mono1": "!!a b. a < b ==> a + (1::'a) < b + (1::'a)"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
class linordered_idom = idom_abs_sgn + linordered_ring_strict +
  linordered_semidom + linordered_semiring_1_strict + ordered_comm_ring +
  ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
locale nat_arith
signature NAT_ARITH =
  sig
    val cancel_diff_conv: Proof.context -> conv
    val cancel_eq_conv: Proof.context -> conv
    val cancel_le_conv: Proof.context -> conv
    val cancel_less_conv: Proof.context -> conv
  end
structure Nat_Arith: NAT_ARITH
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
class size = type +
  fixes size :: "'a => nat"
instantiation
  nat :: size
  size_nat == size :: nat => nat
### theory "HOL.Nat"
### 1.554s elapsed time, 2.788s cpu time, 1.662s GC time
Loading theory "HOL.Fields" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation" via "HOL.Finite_Set")
Loading theory "HOL.Meson" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.Transfer" via "HOL.Metis" via "HOL.ATP")
class inverse = divide +
  fixes inverse :: "'a => 'a"
### ML warning (line 775 of "~~/src/Provers/Arith/fast_lin_arith.ML"):
### Matches are not exhaustive.
signature LIN_ARITH_LOGIC =
  sig
    val atomize: thm -> thm list
    val ccontr: thm
    val conjI: thm
    val is_False: thm -> bool
    val is_nat: typ list * term -> bool
    val mk_Eq: thm -> thm
    val mk_Trueprop: term -> term
    val mk_nat_thm: theory -> term -> thm
    val neg_prop: term -> term
    val notI: thm
    val not_leD: thm
    val not_lessD: thm
    val sym: thm
    val trueI: thm
  end
signature LIN_ARITH_DATA =
  sig
    val abstract:
       term ->
         (term * term) list * Proof.context ->
           term * ((term * term) list * Proof.context)
    val abstract_arith:
       term ->
         (term * term) list * Proof.context ->
           term * ((term * term) list * Proof.context)
    val decomp: Proof.context -> term -> decomp option
    type decomp =
       (term * Rat.rat) list * Rat.rat * string * (term * Rat.rat) list *
       Rat.rat * bool
    val domain_is_nat: term -> bool
    val neq_limit: int Config.T
    val pre_decomp:
       Proof.context -> typ list * term list -> (typ list * term list) list
    val pre_tac: Proof.context -> int -> tactic
    val trace: bool Config.T
  end
signature FAST_LIN_ARITH =
  sig
    val add_inj_thms: thm list -> Context.generic -> Context.generic
    val add_lessD: thm -> Context.generic -> Context.generic
    val add_simprocs: simproc list -> Context.generic -> Context.generic
    val add_simps: thm list -> Context.generic -> Context.generic
    val lin_arith_simproc: Proof.context -> cterm -> thm option
    val lin_arith_tac: Proof.context -> int -> tactic
    val map_data:
       ({add_mono_thms: thm list,
         inj_thms: thm list,
         lessD: thm list,
         mult_mono_thms: thm list,
         neqE: thm list,
         number_of: (Proof.context -> typ -> int -> cterm) option,
         simpset: simpset}
          ->
          {add_mono_thms: thm list,
           inj_thms: thm list,
           lessD: thm list,
           mult_mono_thms: thm list,
           neqE: thm list,
           number_of: (Proof.context -> typ -> int -> cterm) option,
           simpset: simpset})
         -> Context.generic -> Context.generic
    val prems_lin_arith_tac: Proof.context -> int -> tactic
    val set_number_of:
       (Proof.context -> typ -> int -> cterm) ->
         Context.generic -> Context.generic
  end
functor Fast_Lin_Arith (
  sig
    structure LA_Data: LIN_ARITH_DATA
    structure LA_Logic: LIN_ARITH_LOGIC
  end
  ): 
  FAST_LIN_ARITH
### ML warning (file "~~/src/HOL/Tools/Meson/meson.ML"):
### Pattern is not exhaustive.
### ML warning (line 291 of "~~/src/HOL/Tools/Meson/meson.ML"):
### Matches are not exhaustive.
### ML warning (line 357 of "~~/src/HOL/Tools/Meson/meson.ML"):
### Pattern is not exhaustive.
### ML warning (line 396 of "~~/src/HOL/Tools/Meson/meson.ML"):
### Matches are not exhaustive.
signature MESON =
  sig
    val MESON:
       tactic ->
         (thm list -> thm list) ->
           (thm list -> tactic) -> Proof.context -> int -> tactic
    val abs_extensionalize_conv: Proof.context -> conv
    val abs_extensionalize_thm: Proof.context -> thm -> thm
    val best_meson_tac: (thm -> int) -> Proof.context -> int -> tactic
    val best_prolog_tac: Proof.context -> (thm -> int) -> thm list -> tactic
    val choice_theorems: theory -> thm list
    val cong_extensionalize_thm: Proof.context -> thm -> thm
    val depth_meson_tac: Proof.context -> int -> tactic
    val depth_prolog_tac: Proof.context -> thm list -> tactic
    val finish_cnf: thm list -> thm list
    val first_order_resolve: Proof.context -> thm -> thm -> thm
    val gocls: thm list -> thm list
    val has_too_many_clauses: Proof.context -> term -> bool
    val iter_deepen_meson_tac: Proof.context -> thm list -> int -> tactic
    val iter_deepen_prolog_tac: Proof.context -> thm list -> tactic
    val make_clauses: Proof.context -> thm list -> thm list
    val make_clauses_unsorted: Proof.context -> thm list -> thm list
    val make_cnf:
       thm list -> thm -> Proof.context -> thm list * Proof.context
    val make_horns: thm list -> thm list
    val make_meta_clause: Proof.context -> thm -> thm
    val make_meta_clauses: Proof.context -> thm list -> thm list
    val make_nnf: simp_options -> Proof.context -> thm -> thm
    val max_clauses: int Config.T
    val meson_tac: Proof.context -> thm list -> int -> tactic
    val presimplified_consts: string list
    val presimplify: simp_options -> Proof.context -> thm -> thm
    val prolog_step_tac': Proof.context -> thm list -> int -> tactic
    val safe_best_meson_tac: Proof.context -> int -> tactic
    type simp_options = {if_simps: bool, let_simps: bool}
    val simp_options_all_true: simp_options
    val size_of_subgoals: thm -> int
    val skolemize: simp_options -> Proof.context -> thm -> thm
    val skolemize_prems_tac:
       simp_options -> Proof.context -> thm list -> int -> tactic
    val skolemize_with_choice_theorems:
       simp_options -> Proof.context -> thm list -> thm -> thm
    val trace: bool Config.T
  end
structure Meson: MESON
### ML warning (line 92 of "~~/src/HOL/Tools/Meson/meson_clausify.ML"):
### Pattern is not exhaustive.
### ML warning (line 143 of "~~/src/HOL/Tools/Meson/meson_clausify.ML"):
### Matches are not exhaustive.
### ML warning (line 199 of "~~/src/HOL/Tools/Meson/meson_clausify.ML"):
### Matches are not exhaustive.
signature MESON_CLAUSIFY =
  sig
    val cluster_of_zapped_var_name: string -> (int * (int * int)) * bool
    val cnf_axiom:
       Meson.simp_options ->
         Proof.context ->
           bool -> bool -> int -> thm -> (thm * term) option * thm list
    val introduce_combinators_in_cterm: Proof.context -> cterm -> thm
    val introduce_combinators_in_theorem: Proof.context -> thm -> thm
    val is_quasi_lambda_free: term -> bool
    val is_zapped_var_name: string -> bool
    val new_nonskolem_var_prefix: string
    val new_skolem_var_prefix: string
    val ss_only: thm list -> Proof.context -> Proof.context
  end
structure Meson_Clausify: MESON_CLAUSIFY
signature MESON_TACTIC =
  sig val meson_general_tac: Proof.context -> thm list -> int -> tactic end
structure Meson_Tactic: MESON_TACTIC
### theory "HOL.Meson"
### 0.401s elapsed time, 0.870s cpu time, 0.139s GC time
Loading theory "HOL.ATP" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.Transfer" via "HOL.Metis")
signature ATP_UTIL =
  sig
    val abs_extensionalize_term: Proof.context -> term -> term
    val chunk_list: int -> 'a list -> 'a list list
    val close_form: term -> term
    val cong_extensionalize_term: Proof.context -> term -> term
    val elide_string: int -> string -> string
    val eta_expand: typ list -> term -> int -> term
    val extract_lambda_def: (term -> string * typ) -> term -> string * term
    val find_enclosed: string -> string -> string -> string list
    val hash_string: string -> int
    val hashw: word * word -> word
    val hashw_string: string * word -> word
    val hol_close_form: term -> term
    val hol_close_form_prefix: string
    val hol_open_form: (string -> string) -> term -> term
    val instantiate_type: theory -> typ -> typ -> typ -> typ
    val is_type_surely_finite: Proof.context -> typ -> bool
    val is_type_surely_infinite:
       Proof.context -> bool -> typ list -> typ -> bool
    val map_prod: ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val maybe_quote: Keyword.keywords -> string -> string
    val nat_subscript: int -> string
    val s_conj: term * term -> term
    val s_disj: term * term -> term
    val s_iff: term * term -> term
    val s_imp: term * term -> term
    val s_not: term -> term
    val short_thm_name: Proof.context -> thm -> string
    val specialize_type: theory -> string * typ -> term -> term
    val stringN_of_int: int -> int -> string
    val string_of_ext_time: bool * Time.time -> string
    val string_of_time: Time.time -> string
    val strip_spaces: bool -> (char -> bool) -> string -> string
    val strip_spaces_except_between_idents: string -> string
    val strip_subgoal:
       thm -> int -> Proof.context -> (string * typ) list * term list * term
    val timestamp: unit -> string
    val transform_elim_prop: term -> term
    val type_equiv: theory -> typ * typ -> bool
    val type_generalization: theory -> typ -> typ -> bool
    val type_instance: theory -> typ -> typ -> bool
    val type_intersect: theory -> typ -> typ -> bool
    val unextensionalize_def: term -> term
    val unquote_tvar: string -> string
    val varify_and_instantiate_type:
       Proof.context -> typ -> typ -> typ -> typ
    val varify_type: Proof.context -> typ -> typ
  end
structure ATP_Util: ATP_UTIL
### ML warning (line 57 of "~~/src/HOL/Tools/lin_arith.ML"):
### Pattern is not exhaustive.
signature LIN_ARITH =
  sig
    val add_discrete_type: string -> Context.generic -> Context.generic
    val add_inj_const: string * typ -> Context.generic -> Context.generic
    val add_inj_thms: thm list -> Context.generic -> Context.generic
    val add_lessD: thm -> Context.generic -> Context.generic
    val add_simprocs: simproc list -> Context.generic -> Context.generic
    val add_simps: thm list -> Context.generic -> Context.generic
    val global_setup: theory -> theory
    val init_arith_data: Context.generic -> Context.generic
    val neq_limit: int Config.T
    val pre_tac: Proof.context -> int -> tactic
    val set_number_of:
       (Proof.context -> typ -> int -> cterm) ->
         Context.generic -> Context.generic
    val simple_tac: Proof.context -> int -> tactic
    val simproc: Proof.context -> cterm -> thm option
    val split_limit: int Config.T
    val tac: Proof.context -> int -> tactic
    val trace: bool Config.T
  end
structure Lin_Arith: LIN_ARITH
class division_ring = inverse + ring_1 +
  assumes "left_inverse": "!!a. a ~= (0::'a) ==> inverse a * a = (1::'a)"
  assumes "right_inverse": "!!a. a ~= (0::'a) ==> a * inverse a = (1::'a)"
  assumes "divide_inverse": "!!a b. a / b = a * inverse b"
  assumes "inverse_zero": "inverse (0::'a) = (0::'a)"
### ML warning (line 439 of "~~/src/HOL/Tools/ATP/atp_problem.ML"):
### Pattern is not exhaustive.
### ML warning (line 600 of "~~/src/HOL/Tools/ATP/atp_problem.ML"):
### Matches are not exhaustive.
### ML warning (line 736 of "~~/src/HOL/Tools/ATP/atp_problem.ML"):
### Matches are not exhaustive.
### ML warning (line 740 of "~~/src/HOL/Tools/ATP/atp_problem.ML"):
### Matches are not exhaustive.
### ML warning (line 758 of "~~/src/HOL/Tools/ATP/atp_problem.ML"):
### Matches are not exhaustive.
### ML warning (line 761 of "~~/src/HOL/Tools/ATP/atp_problem.ML"):
### Matches are not exhaustive.
### ML warning (line 763 of "~~/src/HOL/Tools/ATP/atp_problem.ML"):
### Matches are not exhaustive.
signature ATP_PROBLEM =
  sig
    val aconn_fold:
       bool option ->
         (bool option -> 'a -> 'b -> 'b) ->
           atp_connective * 'a list -> 'b -> 'b
    val aconn_map:
       bool option ->
         (bool option -> 'a -> ('b, 'c, 'd, 'e) atp_formula) ->
           atp_connective * 'a list -> ('b, 'c, 'd, 'e) atp_formula
    datatype atp_connective = AAnd | AIff | AImplies | ANot | AOr
    datatype atp_format
    =
         CNF
       | CNF_UEQ
       | DFG of polymorphism
       | FOF
       | TFF of fool * polymorphism
       | THF of fool * polymorphism * thf_flavor
    datatype ('a, 'b, 'c, 'd) atp_formula
    =
         AAtom of 'c
       | AConn of atp_connective * ('a, 'b, 'c, 'd) atp_formula list
       | AQuant of
           atp_quantifier * ('a * 'b option) list *
           ('a, 'b, 'c, 'd) atp_formula
       | ATyQuant of
           atp_quantifier * ('b * 'd list) list *
           ('a, 'b, 'c, 'd) atp_formula
    datatype atp_formula_role
    =
         Axiom
       | Conjecture
       | Definition
       | Hypothesis
       | Lemma
       | Negated_Conjecture
       | Plain
       | Type_Role
       | Unknown
    type 'a atp_problem = (string * 'a atp_problem_line list) list
    datatype 'a atp_problem_line
    =
         Class_Decl of string * 'a * 'a list
       | Class_Memb of string * ('a * 'a list) list * 'a atp_type * 'a
       | Datatype_Decl of
           string * ('a * 'a list) list * 'a atp_type *
           ('a, 'a atp_type) atp_term list * bool
       | Formula of
           (string * string) * atp_formula_role *
           ('a, 'a atp_type, ('a, 'a atp_type) atp_term, 'a) atp_formula *
           (string, string atp_type) atp_term option *
           (string, string atp_type) atp_term list
       | Sym_Decl of string * 'a * 'a atp_type
       | Type_Decl of string * 'a * int
    datatype atp_quantifier = AExists | AForall
    datatype ('a, 'b) atp_term
    =
         AAbs of (('a * 'b) * ('a, 'b) atp_term) * ('a, 'b) atp_term list
       | ATerm of ('a * 'b list) * ('a, 'b) atp_term list
    datatype 'a atp_type
    =
         AFun of 'a atp_type * 'a atp_type
       | APi of 'a list * 'a atp_type
       | AType of ('a * 'a list) * 'a atp_type list
    val bool_atype: (string * string) atp_type
    val declared_in_atp_problem:
       'a atp_problem -> ('a list * 'a list) * 'a list
    val default_rank: int
    val default_term_order_weight: int
    val dfg_individual_type: string
    val elimN: string
    val ensure_cnf_problem:
       (string * string) atp_problem -> (string * string) atp_problem
    val extract_isabelle_rank: (string, 'a) atp_term list -> int
    val extract_isabelle_status: (string, 'a) atp_term list -> string option
    val filter_cnf_ueq_problem:
       (string * string) atp_problem -> (string * string) atp_problem
    datatype fool = With_FOOL | Without_FOOL
    val formula_fold:
       bool option ->
         (bool option -> 'a -> 'b -> 'b) ->
           ('c, 'd, 'a, 'e) atp_formula -> 'b -> 'b
    val formula_map:
       ('a -> 'b) ->
         ('c, 'd, 'a, 'e) atp_formula -> ('c, 'd, 'b, 'e) atp_formula
    val individual_atype: (string * string) atp_type
    val inductionN: string
    val inductiveN: string
    val introN: string
    val is_built_in_tptp_symbol: string -> bool
    val is_format_higher_order: atp_format -> bool
    val is_tptp_equal: string -> bool
    val is_tptp_user_symbol: string -> bool
    val is_tptp_variable: string -> bool
    val isabelle_info: bool -> string -> int -> (string, 'a) atp_term list
    val isabelle_info_prefix: string
    val lines_of_atp_problem:
       atp_format ->
         term_order ->
           (unit -> (string * int) list) ->
             string atp_problem -> string list
    val minimum_rank: int
    val mk_aconn:
       atp_connective ->
         ('a, 'b, 'c, 'd) atp_formula ->
           ('a, 'b, 'c, 'd) atp_formula -> ('a, 'b, 'c, 'd) atp_formula
    val mk_anot:
       ('a, 'b, 'c, 'd) atp_formula -> ('a, 'b, 'c, 'd) atp_formula
    val mk_app:
       (string, 'a) atp_term ->
         (string, 'a) atp_term -> (string, 'a) atp_term
    val mk_apps:
       (string, 'a) atp_term ->
         (string, 'a) atp_term list -> (string, 'a) atp_term
    val mk_simple_aterm: 'a -> ('a, 'b) atp_term
    val nice_atp_problem:
       bool ->
         atp_format ->
           ('a * (string * string) atp_problem_line list) list ->
             ('a * string atp_problem_line list) list *
             (string Symtab.table * string Symtab.table) option
    val non_rec_defN: string
    datatype polymorphism = Monomorphic | Polymorphic
    val rankN: string
    val rec_defN: string
    val simpN: string
    val strip_atype:
       'a atp_type -> 'a list * ('a atp_type list * 'a atp_type)
    type term_order =
       {gen_prec: bool, gen_simp: bool, gen_weights: bool, is_lpo: bool}
    datatype thf_flavor
    = THF_Lambda_Free | THF_With_Choice | THF_Without_Choice
    val tptp_and: string
    val tptp_app: string
    val tptp_bool_type: string
    type tptp_builtin_desc = {arity: int, is_predicate: bool}
    val tptp_builtins: tptp_builtin_desc Symtab.table
    val tptp_choice: string
    val tptp_cnf: string
    val tptp_empty_list: string
    val tptp_equal: string
    val tptp_exists: string
    val tptp_false: string
    val tptp_fof: string
    val tptp_forall: string
    val tptp_fun_type: string
    val tptp_has_type: string
    val tptp_hilbert_choice: string
    val tptp_hilbert_the: string
    val tptp_ho_choice: string
    val tptp_ho_exists: string
    val tptp_ho_forall: string
    val tptp_if: string
    val tptp_iff: string
    val tptp_implies: string
    val tptp_individual_type: string
    val tptp_ite: string
    val tptp_lambda: string
    val tptp_let: string
    val tptp_not: string
    val tptp_not_and: string
    val tptp_not_equal: string
    val tptp_not_iff: string
    val tptp_not_infix: string
    val tptp_not_or: string
    val tptp_old_equal: string
    val tptp_or: string
    val tptp_pi_binder: string
    val tptp_product_type: string
    val tptp_string_of_format: atp_format -> string
    val tptp_string_of_line: atp_format -> string atp_problem_line -> string
    val tptp_string_of_role: atp_formula_role -> string
    val tptp_tff: string
    val tptp_thf: string
    val tptp_true: string
    val tptp_type_of_types: string
  end
structure ATP_Problem: ATP_PROBLEM
### ML warning (line 397 of "~~/src/HOL/Tools/ATP/atp_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 502 of "~~/src/HOL/Tools/ATP/atp_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 675 of "~~/src/HOL/Tools/ATP/atp_proof.ML"):
### Matches are not exhaustive.
signature ATP_PROOF =
  sig
    exception UNRECOGNIZED_ATP_PROOF of unit
    val agsyholN: string
    val agsyhol_core_rule: string
    val alt_ergoN: string
    datatype atp_failure
    =
         Crashed
       | GaveUp
       | Inappropriate
       | InternalError
       | Interrupted
       | MalformedInput
       | MalformedOutput
       | MaybeUnprovable
       | OutOfResources
       | ProofIncomplete
       | ProofMissing
       | ProofUnparsable
       | TimedOut
       | UnknownError of string
       | Unprovable
       | UnsoundProof of bool * string list
    eqtype ('a, 'b, 'c, 'd) atp_formula
    eqtype atp_formula_role
    type 'a atp_problem = 'a ATP_Problem.atp_problem
    type 'a atp_proof =
       (('a, 'a, ('a, 'a atp_type) atp_term, 'a) atp_formula, string)
       atp_step
       list
    val atp_proof_of_tstplike_proof:
       string -> string atp_problem -> string -> string atp_proof
    type ('a, 'b) atp_step =
       atp_step_name * atp_formula_role * 'a * 'b * atp_step_name list
    type atp_step_name = string * string list
    eqtype ('a, 'b) atp_term
    eqtype 'a atp_type
    val clean_up_atp_proof_dependencies:
       string atp_proof -> string atp_proof
    val core_inference:
       'a ->
         'b ->
           ('b * 'b list) * atp_formula_role *
           ('c, 'd, (string, 'e) atp_term, 'f) atp_formula * 'a * 'g list
    val core_of_agsyhol_proof: string -> string list option
    val dummy_atype: string atp_type
    val dummy_fofN: string
    val dummy_tfxN: string
    val dummy_thfN: string
    val eN: string
    val extract_important_message: string -> string
    val extract_known_atp_failure:
       (atp_failure * string) list -> string -> atp_failure option
    val extract_tstplike_proof_and_outcome:
       bool ->
         (string * string) list ->
           (atp_failure * string) list ->
             string -> string * atp_failure option
    val iproverN: string
    val is_same_atp_step: atp_step_name -> atp_step_name -> bool
    val leo2N: string
    val leo3N: string
    val map_term_names_in_atp_proof:
       (string -> string) -> string atp_proof -> string atp_proof
    val nasty_atp_proof:
       string Symtab.table -> string atp_proof -> string atp_proof
    val parse_fol_formula:
       string list ->
         (string, string atp_type, (string, string atp_type) atp_term,
         string)
         atp_formula
         *
         string list
    val parse_hol_formula:
       string list ->
         ('a, 'b, (string, string atp_type) atp_term, 'c) atp_formula *
         string list
    val parse_line:
       string ->
         ('a * string ATP_Problem.atp_problem_line list) list ->
           string list ->
             ((string * string list) * atp_formula_role *
              (string, 'b, (string, string atp_type) atp_term, 'c)
              atp_formula
              *
              string * (string * 'd list) list
             )
             list
             *
             string list
    val remote_prefix: string
    val role_of_tptp_string: string -> atp_formula_role
    val satallaxN: string
    val scan_general_id: string list -> string * string list
    val short_output: bool -> string -> string
    val skip_term: string list -> string * string list
    val spassN: string
    val spass_input_rule: string
    val spass_pre_skolemize_rule: string
    val spass_skolemize_rule: string
    val string_of_atp_failure: atp_failure -> string
    val string_of_atp_step:
       ('a -> string) -> ('b -> string) -> ('a, 'b) atp_step -> string
    val vampireN: string
    val vampire_step_name_ord: (string * 'a) ord
    val waldmeisterN: string
    val z3_tptpN: string
    val z3_tptp_core_rule: string
    val zipperpositionN: string
  end
structure ATP_Proof: ATP_PROOF
### ML warning (line 136 of "~~/src/HOL/Tools/ATP/atp_proof_redirect.ML"):
### Matches are not exhaustive.
signature ATP_ATOM =
  sig type key val ord: key ord val string_of: key -> string end
signature ATP_PROOF_REDIRECT =
  sig
    structure Atom_Graph: GRAPH
    type atom
    val axioms_of_refute_graph: refute_graph -> atom list -> atom list
    type clause = atom list
    val direct_graph: direct_sequent list -> direct_graph
    type direct_graph = unit Atom_Graph.T
    datatype direct_inference
    = Cases of (clause * direct_inference list) list | Have of rich_sequent
    type direct_proof = direct_inference list
    type direct_sequent = atom * (atom list * clause)
    val make_refute_graph: atom -> (atom list * atom) list -> refute_graph
    val redirect_graph:
       atom list -> atom list -> atom -> refute_graph -> direct_proof
    val redirect_sequent:
       atom list -> atom -> refute_sequent -> direct_sequent
    type refute_graph = unit Atom_Graph.T
    type refute_sequent = atom list * atom
    type rich_sequent = atom * (clause list * clause)
    val sequents_of_refute_graph: refute_graph -> refute_sequent list
    val string_of_direct_proof: direct_proof -> string
    val string_of_refute_graph: refute_graph -> string
    val succedent_of_cases: (clause * direct_inference list) list -> clause
    val tainted_atoms_of_refute_graph:
       refute_graph -> atom list -> atom list
  end
functor ATP_Proof_Redirect (Atom: ATP_ATOM): ATP_PROOF_REDIRECT
class field = inverse + comm_ring_1 +
  assumes "field_inverse": "!!a. a ~= (0::'a) ==> inverse a * a = (1::'a)"
  assumes "field_divide_inverse": "!!a b. a / b = a * inverse b"
  assumes "field_inverse_zero": "inverse (0::'a) = (0::'a)"
signature LAMBDA_LIFTING =
  sig
    type context = (term * term) Termtab.table * Proof.context
    val finish: context -> term list * Proof.context
    val init: Proof.context -> context
    val is_quantifier: term -> bool
    val lift_lambdas:
       string option ->
         (term -> bool) ->
           term list ->
             Proof.context -> (term list * term list) * Proof.context
    val lift_lambdas1:
       (term -> bool) -> string option -> term -> context -> term * context
  end
structure Lambda_Lifting: LAMBDA_LIFTING
signature MONOMORPH =
  sig
    val add_schematic_consts_of:
       term -> typ list Symtab.table -> typ list Symtab.table
    val all_schematic_consts_of: term -> typ list Symtab.table
    val max_duplicated_instances: int Config.T
    val max_new_const_instances_per_round: int Config.T
    val max_new_instances: int Config.T
    val max_rounds: int Config.T
    val max_thm_instances: int Config.T
    val monomorph:
       (term -> typ list Symtab.table) ->
         Proof.context -> (int * thm) list -> (int * thm) list list
    val typ_has_tvars: typ -> bool
  end
structure Monomorph: MONOMORPH
### ML warning (line 603 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Value identifier (t') has not been referenced.
### ML warning (line 603 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 603 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 692 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 690 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 985 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 985 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 1888 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 1885 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 1889 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 1889 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 2638 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 2651 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
### ML warning (line 2650 of "~~/src/HOL/Tools/ATP/atp_problem_generate.ML"):
### Matches are not exhaustive.
signature ATP_PROBLEM_GENERATE =
  sig
    val adjust_type_enc: atp_format -> type_enc -> type_enc
    val app_op_name: string
    val ascii_of: string -> string
    eqtype atp_connective
    eqtype atp_format
    eqtype ('a, 'b, 'c, 'd) atp_formula
    eqtype atp_formula_role
    val atp_irrelevant_consts: string list
    val atp_logical_consts: string list
    type 'a atp_problem = 'a ATP_Problem.atp_problem
    val atp_problem_selection_weights:
       string atp_problem -> (string * real) list
    val atp_problem_term_order_info:
       string atp_problem -> (string * int) list
    val atp_schematic_consts_of: term -> typ list Symtab.table
    eqtype ('a, 'b) atp_term
    val atp_widely_irrelevant_consts: string list
    val class_decl_prefix: string
    val class_memb_prefix: string
    val class_prefix: string
    val combinator_prefix: string
    val combsN: string
    val combs_and_liftingN: string
    val combs_or_liftingN: string
    val conjecture_prefix: string
    val const_prefix: string
    datatype ctr_optim = With_Ctr_Optim | Without_Ctr_Optim
    val datatype_decl_prefix: string
    val do_cheaply_conceal_lambdas: typ list -> term -> term
    val fact_prefix: string
    val factsN: string
    val fixed_var_prefix: string
    val generate_atp_problem:
       Proof.context ->
         bool ->
           atp_format ->
             atp_formula_role ->
               type_enc ->
                 mode ->
                   string ->
                     bool ->
                       bool ->
                         bool ->
                           term list ->
                             term ->
                               ((string * stature) * term) list ->
                                 string atp_problem * string Symtab.table *
                                 (string * term) list * int Symtab.table
    val guards_sym_formula_prefix: string
    val helper_prefix: string
    val helper_table: bool -> ((string * bool) * (status * thm) list) list
    val invert_const: string -> string
    val is_first_order_lambda_free: term -> bool
    val is_irrelevant_const: string -> bool
    val is_type_enc_higher_order: type_enc -> bool
    val is_type_enc_polymorphic: type_enc -> bool
    val is_type_enc_sound: type_enc -> bool
    val is_widely_irrelevant_const: string -> bool
    val keep_lamsN: string
    val lam_fact_prefix: string
    val lam_lifted_mono_prefix: string
    val lam_lifted_poly_prefix: string
    val lam_lifted_prefix: string
    val level_of_type_enc: type_enc -> type_level
    val liftingN: string
    val mk_aconns:
       atp_connective ->
         ('a, 'b, 'c, 'd) atp_formula list -> ('a, 'b, 'c, 'd) atp_formula
    datatype mode
    =
         Exporter
       | Metis
       | Sledgehammer
       | Sledgehammer_Completish of int
       | Translator
    val native_type_prefix: string
    val new_skolem_const_prefix: string
    val new_skolem_var_name_of_const: string -> string
    val no_lamsN: string
    val old_skolem_const_prefix: string
    val opaque_combsN: string
    val opaque_liftingN: string
    val predicator_name: string
    val prefixed_app_op_name: string
    val prefixed_predicator_name: string
    val prefixed_type_tag_name: string
    val proxify_const: string -> (string * string) option
    val proxy_table: (string * (string * (thm * (string * string)))) list
    val schematic_var_prefix: string
    datatype scope = Assum | Chained | Global | Local
    val skolem_const_prefix: string
    type stature = scope * status
    datatype status
    =
         Elim
       | General
       | Induction
       | Inductive
       | Intro
       | Non_Rec_Def
       | Rec_Def
       | Simp
    datatype strictness = Non_Strict | Strict
    val string_of_status: status -> string
    val subclass_prefix: string
    val sym_decl_prefix: string
    val tags_sym_formula_prefix: string
    val tcon_clause_prefix: string
    val tfree_clause_prefix: string
    val tfree_prefix: string
    val trans_lams_of_string:
       Proof.context ->
         type_enc -> string -> term list -> term list * term list
    val tvar_prefix: string
    val type_const_prefix: string
    val type_decl_prefix: string
    type type_enc
    val type_enc_of_string: strictness -> string -> type_enc
    val type_guard_name: string
    datatype type_level
    =
         All_Types
       | Const_Types of ctr_optim
       | No_Types
       | Nonmono_Types of strictness * uniformity
       | Undercover_Types
    val type_tag_name: string
    val typed_helper_suffix: string
    val unascii_of: string -> string
    datatype uniformity = Non_Uniform | Uniform
    val unmangled_const: string -> string * (string, 'a) atp_term list
    val unmangled_const_name: string -> string list
    val unmangled_type: string -> (string, 'a) atp_term
    val unprefix_and_unascii: string -> string -> string option
    val unproxify_const: string -> string
    val untyped_helper_suffix: string
  end
structure ATP_Problem_Generate: ATP_PROBLEM_GENERATE
### ML warning (line 170 of "~~/src/HOL/Tools/ATP/atp_proof_reconstruct.ML"):
### Matches are not exhaustive.
### ML warning (line 182 of "~~/src/HOL/Tools/ATP/atp_proof_reconstruct.ML"):
### Matches are not exhaustive.
### ML warning (line 207 of "~~/src/HOL/Tools/ATP/atp_proof_reconstruct.ML"):
### Matches are not exhaustive.
### ML warning (line 265 of "~~/src/HOL/Tools/ATP/atp_proof_reconstruct.ML"):
### Matches are not exhaustive.
### ML warning (line 349 of "~~/src/HOL/Tools/ATP/atp_proof_reconstruct.ML"):
### Matches are not exhaustive.
### ML warning (line 436 of "~~/src/HOL/Tools/ATP/atp_proof_reconstruct.ML"):
### Matches are not exhaustive.
### ML warning (line 620 of "~~/src/HOL/Tools/ATP/atp_proof_reconstruct.ML"):
### Matches are not exhaustive.
### ML warning (line 709 of "~~/src/HOL/Tools/ATP/atp_proof_reconstruct.ML"):
### Matches are not exhaustive.
signature ATP_PROOF_RECONSTRUCT =
  sig
    eqtype ('a, 'b, 'c, 'd) atp_formula
    type 'a atp_proof = 'a ATP_Proof.atp_proof
    val atp_proof_prefers_lifting: string atp_proof -> bool
    type ('a, 'b) atp_step = ('a, 'b) ATP_Proof.atp_step
    type atp_step_name = ATP_Proof.atp_step_name
    eqtype ('a, 'b) atp_term
    eqtype 'a atp_type
    val default_metis_lam_trans: string
    val exists_of: term -> term -> term
    val factify_atp_proof:
       (string * 'a) list ->
         term list ->
           term ->
             (term, string) atp_step list -> (term, string) atp_step list
    val forall_of: term -> term -> term
    val full_type_enc: string
    val full_type_encs: string list
    val full_typesN: string
    val infer_formulas_types: Proof.context -> term list -> term list
    val introduce_spass_skolems:
       (term, string) atp_step list -> (term, string) atp_step list
    val is_typed_helper_used_in_atp_proof: string atp_proof -> bool
    val leo2_extcnf_equal_neg_rule: string
    val metisN: string
    val no_type_enc: string
    val no_typesN: string
    val partial_type_enc: string
    val partial_type_encs: string list
    val partial_typesN: string
    val prop_of_atp:
       Proof.context ->
         ATP_Problem.atp_format ->
           ATP_Problem_Generate.type_enc ->
             bool ->
               int Symtab.table ->
                 (string, string, (string, string atp_type) atp_term, string
                 )
                 atp_formula
                   -> term
    val really_full_type_enc: string
    val rename_bound_vars: term -> term
    val repair_waldmeister_endgame:
       (term, 'a) atp_step list -> (term, 'a) atp_step list
    val replace_dependencies_in_line:
       atp_step_name * atp_step_name list ->
         ('a, 'b) atp_step -> ('a, 'b) atp_step
    val satallax_tab_rule_prefix: string
    val simplify_bool: term -> term
    type stature = ATP_Problem_Generate.stature
    val term_of_atp:
       Proof.context ->
         ATP_Problem.atp_format ->
           ATP_Problem_Generate.type_enc ->
             bool ->
               int Symtab.table ->
                 typ option -> (string, string atp_type) atp_term -> term
    val termify_atp_proof:
       Proof.context ->
         string ->
           ATP_Problem.atp_format ->
             ATP_Problem_Generate.type_enc ->
               string Symtab.table ->
                 (string * term) list ->
                   int Symtab.table ->
                     string atp_proof -> (term, string) atp_step list
    val type_enc_aliases: (string * string list) list
    val unalias_type_enc: string -> string list
    val used_facts_in_atp_proof:
       Proof.context ->
         (string * stature) list ->
           string atp_proof -> (string * stature) list
    val used_facts_in_unsound_atp_proof:
       Proof.context ->
         (string * stature) list -> 'a atp_proof -> string list option
    val var_name_of_typ: typ -> string
  end
structure ATP_Proof_Reconstruct: ATP_PROOF_RECONSTRUCT
### theory "HOL.ATP"
### 2.117s elapsed time, 5.059s cpu time, 1.954s GC time
Loading theory "HOL.Metis" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.Transfer")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 51 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 149 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 527 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 1498 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 1794 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 3427 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 5046 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 5602 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 6349 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 6626 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 6914 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 7201 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 8884 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 9206 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 9356 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 9641 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 10504 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 10900 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 11351 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 12123 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 12570 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 12855 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 13586 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 14433 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 16114 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 17461 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 17677 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 18186 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 18301 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 18432 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 18794 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 19098 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 19868 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 20087 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 20522 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 21552 of "~~/src/Tools/Metis/metis.ML")
### Opaque signature matching (:>) fails to work with ML pretty printing --
### prefer non-opaque matching (:) possibly with abstype (line 21900 of "~~/src/Tools/Metis/metis.ML")
### theory "HOL.Fields"
### 4.415s elapsed time, 10.605s cpu time, 4.310s GC time
Loading theory "HOL.Finite_Set" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure" via "HOL.Relation")
Proofs for inductive predicate(s) "finite"
  Proving monotonicity ...
### Additional type variable(s) in locale specification "finite": 'a
class finite = type +
  assumes "finite_UNIV": "finite UNIV"
locale comp_fun_commute_on
  fixes S :: "'a set"
    and f :: "'a => 'b => 'b"
  assumes "comp_fun_commute_on S f"
Proofs for inductive predicate(s) "fold_graph"
  Proving monotonicity ...
locale comp_fun_commute_on
  fixes S :: "'a set"
    and f :: "'a => 'b => 'b"
  assumes "comp_fun_commute_on S f"
locale comp_fun_idem_on
  fixes S :: "'a set"
    and f :: "'a => 'b => 'b"
  assumes "comp_fun_idem_on S f"
locale comp_fun_commute
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_commute f"
### Cannot skip proof of schematic goal statement
locale comp_fun_idem
  fixes f :: "'a => 'b => 'b"
  assumes "comp_fun_idem f"
### Cannot skip proof of schematic goal statement
class complete_lattice = Inf + Sup + bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
locale folding_on
  fixes S :: "'a set"
    and f :: "'a => 'b => 'b"
    and z :: "'b"
  assumes "folding_on S f"
locale folding_idem_on
  fixes S :: "'a set"
    and f :: "'a => 'b => 'b"
    and z :: "'b"
  assumes "folding_idem_on S f"
locale folding
  fixes f :: "'a => 'b => 'b"
    and z :: "'b"
  assumes "folding f"
### Cannot skip proof of schematic goal statement
locale folding_idem
  fixes f :: "'a => 'b => 'b"
    and z :: "'b"
  assumes "folding_idem f"
### Cannot skip proof of schematic goal statement
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
### theory "HOL.Finite_Set"
### 0.860s elapsed time, 1.805s cpu time, 0.197s GC time
Loading theory "HOL.Relation" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded" via "HOL.Transitive_Closure")
### Ignoring conversion rule for operator Complete_Lattices.Inf_class.Inf
### Ignoring conversion rule for operator Complete_Lattices.Inf_class.Inf
### Ignoring conversion rule for operator Complete_Lattices.Inf_class.Inf
### Ignoring conversion rule for operator Complete_Lattices.Inf_class.Inf
### Ignoring conversion rule for operator Complete_Lattices.Inf_class.Inf
### Ignoring conversion rule for operator Complete_Lattices.Inf_class.Inf
### Ignoring conversion rule for operator Complete_Lattices.Inf_class.Inf
### Ignoring conversion rule for operator Complete_Lattices.Inf_class.Inf
### Ignoring conversion rule for operator Complete_Lattices.Sup_class.Sup
### Ignoring conversion rule for operator Complete_Lattices.Sup_class.Sup
### Ignoring conversion rule for operator Complete_Lattices.Sup_class.Sup
### Ignoring conversion rule for operator Complete_Lattices.Sup_class.Sup
### Ignoring conversion rule for operator Complete_Lattices.Sup_class.Sup
### Ignoring conversion rule for operator Complete_Lattices.Sup_class.Sup
### Ignoring conversion rule for operator Complete_Lattices.Sup_class.Sup
### Ignoring conversion rule for operator Complete_Lattices.Sup_class.Sup
Proofs for inductive predicate(s) "asym"
  Proving monotonicity ...
Proofs for inductive predicate(s) "asymp"
  Proving monotonicity ...
class preorder = ord +
  assumes "less_le_not_le": "!!x y. (x < y) = (x <= y & ~ y <= x)"
    and "order_refl": "!!x. x <= x"
    and "order_trans": "!!x y z. [| x <= y; y <= z |] ==> x <= z"
Proofs for inductive predicate(s) "relcompp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "conversep"
  Proving monotonicity ...
Proofs for inductive predicate(s) "Domainp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "Rangep"
  Proving monotonicity ...
### theory "HOL.Relation"
### 0.739s elapsed time, 1.546s cpu time, 0.168s GC time
Loading theory "HOL.Transitive_Closure" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec" via "HOL.Wellfounded")
### ML warning (line 96 of "~~/src/Provers/trancl.ML"):
### Pattern is not exhaustive.
### ML warning (line 399 of "~~/src/Provers/trancl.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 545 of "~~/src/Provers/trancl.ML"):
### Pattern is not exhaustive.
### ML warning (line 563 of "~~/src/Provers/trancl.ML"):
### Pattern is not exhaustive.
signature TRANCL_ARITH =
  sig
    val decomp: term -> (term * term * term * string) option
    val r_into_rtrancl: thm
    val r_into_trancl: thm
    val rtrancl_refl: thm
    val rtrancl_trancl_trancl: thm
    val rtrancl_trans: thm
    val trancl_into_rtrancl: thm
    val trancl_rtrancl_trancl: thm
    val trancl_trans: thm
  end
signature TRANCL_TAC =
  sig
    val rtrancl_tac: Proof.context -> int -> tactic
    val trancl_tac: Proof.context -> int -> tactic
  end
functor Trancl_Tac (Cls: TRANCL_ARITH): TRANCL_TAC
Proofs for inductive predicate(s) "rtranclp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "tranclp"
  Proving monotonicity ...
overloading
  relpow \<equiv> compow :: nat => ('a * 'a) set => ('a * 'a) set
  relpowp \<equiv> compow :: nat => ('a => 'a => bool) => 'a => 'a => bool
consts
  relpow :: "nat => ('a * 'a) set => ('a * 'a) set"
consts
  relpowp :: "nat => ('a => 'a => bool) => 'a => 'a => bool"
structure Trancl_Tac: TRANCL_TAC
structure Tranclp_Tac: TRANCL_TAC
### theory "HOL.Transitive_Closure"
### 0.731s elapsed time, 1.545s cpu time, 0.183s GC time
Loading theory "HOL.Wellfounded" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation" via "HOL.Wfrec")
Proofs for inductive predicate(s) "accp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "max_extp"
  Proving monotonicity ...
### theory "HOL.Wellfounded"
### 0.341s elapsed time, 0.734s cpu time, 0.118s GC time
Loading theory "HOL.Fun_Def_Base" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def")
Loading theory "HOL.Hilbert_Choice" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn")
Loading theory "HOL.Wfrec" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn" via "HOL.Order_Relation")
Proofs for inductive predicate(s) "wfrec_rel"
  Proving monotonicity ...
### ML warning (line 49 of "~~/src/HOL/Tools/Function/function_lib.ML"):
### Value identifier (sg) has not been referenced.
### ML warning (line 48 of "~~/src/HOL/Tools/Function/function_lib.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 48 of "~~/src/HOL/Tools/Function/function_lib.ML"):
### Value identifier (pl) has not been referenced.
### ML warning (line 71 of "~~/src/HOL/Tools/Function/function_lib.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 79 of "~~/src/HOL/Tools/Function/function_lib.ML"):
### Pattern is not exhaustive.
signature FUNCTION_LIB =
  sig
    val derived_name: binding -> string -> binding
    val derived_name_suffix: binding -> string -> binding
    val dest_all_all: term -> term list * term
    val dest_binop_list: string -> term -> term list
    val forall_intr_rename: string * cterm -> thm -> thm
    val function_internals: bool Config.T
    val inst_constrs_of: Proof.context -> typ -> term list
    val mk_forall_rename: string * term -> term -> term
    val plural: string -> string -> 'a list -> string
    datatype proof_attempt = Fail | Solved of thm | Stuck of thm
    val regroup_conv:
       Proof.context -> string -> string -> thm list -> int list -> conv
    val regroup_union_conv: Proof.context -> int list -> conv
    val rename_bound: string -> term -> term
    val try_proof: Proof.context -> cterm -> tactic -> proof_attempt
    val unordered_pairs: 'a list -> ('a * 'a) list
  end
structure Function_Lib: FUNCTION_LIB
### theory "HOL.Wfrec"
### 0.066s elapsed time, 0.267s cpu time, 0.000s GC time
Loading theory "HOL.Order_Relation" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.Zorn")
signature FUNCTION_COMMON =
  sig
    val PROFILE: string -> ('a -> 'b) -> 'a -> 'b
    val add_function_data: info -> Context.generic -> Context.generic
    val check_defs:
       Proof.context -> ((string * typ) * 'a) list -> term list -> unit
    val default_config: function_config
    val empty_preproc:
       (Proof.context -> ((string * typ) * mixfix) list -> term list -> 'a)
         -> preproc
    type fixes = ((string * typ) * mixfix) list
    val fname_of: term -> string
    datatype function_config
    =
         FunctionConfig of
             {default: string option,
              domintros: bool, partials: bool, sequential: bool}
    val function_parser:
       function_config ->
         (function_config *
          ((binding * string option * mixfix) list *
           Specification.multi_specs_cmd)
         )
         parser
    datatype function_result
    =
         FunctionResult of
             {G: term,
              R: term,
              cases: thm list,
              dom: term,
              domintros: thm list option,
              fs: term list,
              pelims: thm list list,
              psimps: thm list, simple_pinducts: thm list, termination: thm}
    val get_preproc: Proof.context -> preproc
    val import_function_data: term -> Proof.context -> info option
    val import_last_function: Proof.context -> info option
    type info =
       {R: term,
        add_simps:
        (binding -> binding) ->
          string ->
            (binding -> binding) ->
              Token.src list ->
                thm list -> local_theory -> thm list * local_theory
        ,
        case_names: string list,
        cases: thm list,
        defname: binding,
        dom: term,
        elims: thm list list option,
        fnames: binding list,
        fs: term list,
        inducts: thm list option,
        is_partial: bool,
        pelims: thm list list,
        pinducts: thm list,
        psimps: thm list,
        simps: thm list option, termination: thm, totality: thm option}
    val mk_acc: typ -> term -> term
    val mk_case_names: int -> string -> int -> string list
    type preproc =
       function_config ->
         Proof.context ->
           fixes ->
             term spec ->
               term list * (thm list -> thm spec) *
               (thm list -> thm list list) * string list
    val profile: bool ref
    val retrieve_function_data: Proof.context -> term -> (term * info) list
    val set_preproc: preproc -> Context.generic -> Context.generic
    val set_termination_prover:
       (bool -> Proof.context -> tactic) ->
         Context.generic -> Context.generic
    type 'a spec = (Attrib.binding * 'a list) list
    val split_def:
       Proof.context ->
         (string -> 'a) ->
           term ->
             string * (string * typ) list * term list * term list * term
    val store_termination_rule: thm -> Context.generic -> Context.generic
    val termination_prover_tac: bool -> Proof.context -> tactic
    val termination_rule_tac: Proof.context -> int -> tactic
    val transform_function_data: morphism -> info -> info
  end
structure Function_Common: FUNCTION_COMMON
locale bijection
  fixes f :: "'a => 'a"
  assumes "bijection f"
### theory "HOL.Order_Relation"
### 0.210s elapsed time, 0.831s cpu time, 0.095s GC time
Loading theory "HOL.BNF_Wellorder_Relation" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.BNF_Wellorder_Constructions" via "HOL.BNF_Wellorder_Embedding")
### ML warning (line 219 of "~~/src/HOL/Tools/Function/function_context_tree.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 246 of "~~/src/HOL/Tools/Function/function_context_tree.ML"):
### Pattern is not exhaustive.
### ML warning (line 243 of "~~/src/HOL/Tools/Function/function_context_tree.ML"):
### Matches are not exhaustive.
signature FUNCTION_CONTEXT_TREE =
  sig
    val add_function_cong: thm -> Context.generic -> Context.generic
    val cong_add: attribute
    val cong_del: attribute
    type ctx_tree
    type ctxt = (string * typ) list * thm list
    val export_term: ctxt -> term -> term
    val export_thm: Proof.context -> ctxt -> thm -> thm
    val get_function_congs: Proof.context -> thm list
    val import_thm: Proof.context -> ctxt -> thm -> thm
    val inst_tree: Proof.context -> term -> term -> ctx_tree -> ctx_tree
    val mk_tree: term -> term -> Proof.context -> term -> ctx_tree
    val rewrite_by_tree:
       Proof.context ->
         term ->
           thm -> (thm * thm) list -> ctx_tree -> thm * (thm * thm) list
    val traverse_tree:
       (ctxt ->
          term ->
            (ctxt * thm) list ->
              (ctxt * thm) list * 'a -> (ctxt * thm) list * 'a)
         -> ctx_tree -> 'a -> 'a
  end
structure Function_Context_Tree: FUNCTION_CONTEXT_TREE
locale wo_rel
  fixes r :: "('a * 'a) set"
  assumes "wo_rel r"
### ML warning (line 42 of "~~/src/HOL/Tools/Function/sum_tree.ML"):
### Value identifier (RT) has not been referenced.
### ML warning (line 42 of "~~/src/HOL/Tools/Function/sum_tree.ML"):
### Matches are not exhaustive.
### ML warning (line 44 of "~~/src/HOL/Tools/Function/sum_tree.ML"):
### Value identifier (LT) has not been referenced.
### ML warning (line 44 of "~~/src/HOL/Tools/Function/sum_tree.ML"):
### Matches are not exhaustive.
### ML warning (line 51 of "~~/src/HOL/Tools/Function/sum_tree.ML"):
### Value identifier (RT) has not been referenced.
### ML warning (line 51 of "~~/src/HOL/Tools/Function/sum_tree.ML"):
### Matches are not exhaustive.
### ML warning (line 53 of "~~/src/HOL/Tools/Function/sum_tree.ML"):
### Value identifier (LT) has not been referenced.
### ML warning (line 53 of "~~/src/HOL/Tools/Function/sum_tree.ML"):
### Matches are not exhaustive.
signature SUM_TREE =
  sig
    val App: term -> term -> term
    val access_top_down:
       {init: 'a, left: 'a -> 'a, right: 'a -> 'a} -> int -> int -> 'a
    val mk_inj: typ -> int -> int -> term -> term
    val mk_proj: typ -> int -> int -> term -> term
    val mk_sumT: typ -> typ -> typ
    val mk_sumcase: typ -> typ -> typ -> term -> term -> term
    val mk_sumcases: typ -> term list -> term
    val sumcase_split_ss: simpset
  end
structure Sum_Tree: SUM_TREE
### theory "HOL.Fun_Def_Base"
### 0.305s elapsed time, 1.208s cpu time, 0.095s GC time
### ML warning (line 79 of "~~/src/HOL/Tools/choice_specification.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 77 of "~~/src/HOL/Tools/choice_specification.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 135 of "~~/src/HOL/Tools/choice_specification.ML"):
### Value identifier (thm) has not been referenced.
### ML warning (line 185 of "~~/src/HOL/Tools/choice_specification.ML"):
### Matches are not exhaustive.
signature CHOICE_SPECIFICATION =
  sig
    val add_specification:
       (bstring * xstring * bool) list -> theory * thm -> theory * thm
    val close_form: term -> term
  end
structure Choice_Specification: CHOICE_SPECIFICATION
class complete_distrib_lattice = complete_lattice + distrib_lattice +
  assumes
    "Inf_Sup_le":
      "!!A. \<Sqinter> (Sup ` A)
            <= \<Squnion> (Inf ` {f ` A |f. ALL Y:A. f Y : Y})"
### theory "HOL.BNF_Wellorder_Relation"
### 0.166s elapsed time, 0.539s cpu time, 0.130s GC time
class complete_distrib_lattice = complete_lattice + distrib_lattice +
  assumes
    "Inf_Sup_le":
      "!!A. \<Sqinter> (Sup ` A)
            <= \<Squnion> (Inf ` {f ` A |f. ALL Y:A. f Y : Y})"
instantiation
  set :: (type) complete_distrib_lattice
### ML warning (line 599 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 715 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 751 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 977 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (m) has not been referenced.
### ML warning (line 1278 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (realToString) has not been referenced.
### ML warning (line 1344 of "~~/src/Tools/Metis/metis.ML"):
### Handler catches all exceptions.
### ML warning (line 1425 of "~~/src/Tools/Metis/metis.ML"):
### Handler catches all exceptions.
### ML warning (line 6709 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 6746 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 7300 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (isInconsistentBlock) has not been referenced.
### ML warning (line 7334 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (updateSizeBreak) has not been referenced.
### ML warning (line 7733 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (b) has not been referenced.
### ML warning (line 7733 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 7858 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (styleFrame) has not been referenced.
### ML warning (line 8629 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (lineLength) has not been referenced.
### ML warning (line 8633 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (lineLength) has not been referenced.
### ML warning (line 8680 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (state) has not been referenced.
### ML warning (line 8961 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (p) has not been referenced.
### ML warning (line 9738 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (func) has not been referenced.
### ML warning (line 9899 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (isFnHasType) has not been referenced.
### ML warning (line 9977 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (isFnApp) has not been referenced.
### ML warning (line 13242 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (ths) has not been referenced.
### ML warning (line 13775 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (changedConv) has not been referenced.
### ML warning (line 13892 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (changedLiterule) has not been referenced.
### ML warning (line 14209 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (ppEdge) has not been referenced.
### ML warning (line 14467 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (isZeroLogReal) has not been referenced.
### ML warning (line 14571 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (ppCount) has not been referenced.
### ML warning (line 14914 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (ExistsList) has not been referenced.
### ML warning (line 14952 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (ForallList) has not been referenced.
### ML warning (line 14956 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (generalize) has not been referenced.
### ML warning (line 15113 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (toString) has not been referenced.
### ML warning (line 15255 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (c1) has not been referenced.
### ML warning (line 15256 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (c2) has not been referenced.
### ML warning (line 15319 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (cl') has not been referenced.
### ML warning (line 15445 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (fm) has not been referenced.
### ML warning (line 17105 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (f_tms) has not been referenced.
### ML warning (line 17721 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (equalFnQterm) has not been referenced.
### ML warning (line 17733 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (matchQtermQterm) has not been referenced.
### ML warning (line 18197 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (termToAtom) has not been referenced.
### ML warning (line 18848 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (weightZero) has not been referenced.
### ML warning (line 18883 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (w) has not been referenced.
### ML warning (line 19260 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (thmReducible) has not been referenced.
### ML warning (line 19897 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (units) has not been referenced.
### ML warning (line 20813 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (subs) has not been referenced.
### ML warning (line 20879 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (toString) has not been referenced.
### ML warning (line 21113 of "~~/src/Tools/Metis/metis.ML"):
### Value identifier (parameters) has not been referenced.
signature Metis_Random =
  sig
    val nextBool: unit -> bool
    val nextInt: int -> int
    val nextReal: unit -> real
    val nextWord: unit -> word
  end
structure Metis_Random: Metis_Random
datatype 'a frag = ANTIQUOTE of 'a | QUOTE of string
signature Metis_Portable =
  sig
    val critical: (unit -> 'a) -> unit -> 'a
    val ml: string
    val pointerEqual: 'a * 'a -> bool
    val randomBool: unit -> bool
    val randomInt: int -> int
    val randomReal: unit -> real
    val randomWord: unit -> word
    val time: ('a -> 'b) -> 'a -> 'b
  end
signature Metis_Useful =
  sig
    val ## : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd
    exception Bug of string
    val C: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
    exception Error of string
    val I: 'a -> 'a
    val K: 'a -> 'b -> 'a
    val S: ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
    val W: ('a -> 'a -> 'b) -> 'a -> 'b
    val alignColumn:
       columnAlignment -> string list -> string list -> string list
    val alignTable: columnAlignment list -> string list list -> string list
    val append: 'a list -> 'a list -> 'a list
    val bind: ('a -> 'b * 'a) -> ('b -> 'a -> 'c * 'a) -> 'a -> 'c * 'a
    val boolCompare: bool * bool -> order
    val can: ('a -> 'b) -> 'a -> bool
    val capitalize: string -> string
    val cart: 'a list -> 'b list -> ('a * 'b) list
    val cartwith: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val charFromInt: int -> char option
    val charToInt: char -> int option
    val chat: string -> unit
    val chide: string -> unit
    val chomp: string -> string
    val cloneArray: 'a array -> 'a array
    type columnAlignment = {leftAlign: bool, padChar: char}
    val cons: 'a -> 'a list -> 'a list
    val curry: ('a * 'b -> 'c) -> 'a -> 'b -> 'c
    val date: unit -> string
    val delete: ''a -> ''a list -> ''a list
    val deleteNth: int -> 'a list -> 'a list
    val destLeft: ('a, 'b) sum -> 'a
    val destPrefix: string -> string -> string
    val destRight: ('a, 'b) sum -> 'b
    val destSuffix: string -> string -> string
    val die: string -> 'a
    val difference: ''a list -> ''a list -> ''a list
    val distinct: ''a list -> bool
    val divide: 'a list -> int -> 'a list * 'a list
    val divideWhile: ('a -> bool) -> 'a list -> 'a list * 'a list
    val divides: int -> int -> bool
    val dropWhile: ('a -> bool) -> 'a list -> 'a list
    val enumerate: 'a list -> (int * 'a) list
    val equal: ''a -> ''a -> bool
    val executionTime: unit -> real
    val exp: ('a * 'a -> 'a) -> 'a -> int -> 'a -> 'a
    val first: ('a -> 'b option) -> 'a list -> 'b option
    val fst: 'a * 'b -> 'a
    val funpow: int -> ('a -> 'a) -> 'a -> 'a
    val gcd: int -> int -> int
    val groups: ('a * 'b -> bool * 'b) -> 'b -> 'a list -> 'a list list
    val groupsBy: ('a * 'a -> bool) -> 'a list -> 'a list list
    val groupsByFst: (''a * 'b) list -> (''a * 'b list) list
    val groupsOf: int -> 'a list -> 'a list list
    val hdTl: 'a list -> 'a * 'a list
    val host: unit -> string
    val incSieve: sieve -> bool * sieve
    val index: ('a -> bool) -> 'a list -> int option
    val initSieve: sieve
    val insert: ''a -> ''a list -> ''a list
    val intersect: ''a list -> ''a list -> ''a list
    val interval: int -> int -> int list
    val isLeft: ('a, 'b) sum -> bool
    val isPrefix: string -> string -> bool
    val isRight: ('a, 'b) sum -> bool
    val isSuffix: string -> string -> bool
    val join: string -> string list -> string
    val lexCompare: ('a * 'a -> order) -> 'a list * 'a list -> order
    val listEqual: ('a -> 'a -> bool) -> 'a list -> 'a list -> bool
    val log2: real -> real
    val mapCompare: ('a -> 'b) -> ('b * 'b -> order) -> 'a * 'a -> order
    val maps: ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
    val mapsPartial:
       ('a -> 'b -> 'c option * 'b) -> 'a list -> 'b -> 'c list * 'b
    val maxSieve: sieve -> int
    val maximum: ('a * 'a -> order) -> 'a list -> 'a * 'a list
    val mem: ''a -> ''a list -> bool
    val merge: ('a * 'a -> order) -> 'a list -> 'a list -> 'a list
    val minimum: ('a * 'a -> order) -> 'a list -> 'a * 'a list
    val mjoin: ('a -> ('a -> 'b * 'a) * 'a) -> 'a -> 'b * 'a
    val mkPrefix: string -> string -> string
    val mkSuffix: string -> string -> string
    val mmap: ('a -> 'b) -> ('c -> 'a * 'c) -> 'c -> 'b * 'c
    val mwhile: ('a -> bool) -> ('a -> 'b -> 'a * 'b) -> 'a -> 'b -> 'a * 'b
    val nChars: char -> int -> string
    val newInt: unit -> int
    val newInts: int -> int list
    val nextSieve: sieve -> int * sieve
    val notEqual: ''a -> ''a -> bool
    val optionCompare: ('a * 'a -> order) -> 'a option * 'a option -> order
    val pair: 'a -> 'b -> 'a * 'b
    val percentToString: real -> string
    val pos: real -> real
    val primes: int -> int list
    val primesSieve: sieve -> int list
    val primesUpTo: int -> int list
    val prodCompare:
       ('a * 'a -> order) ->
         ('b * 'b -> order) -> ('a * 'b) * ('a * 'b) -> order
    val readDirectory: {directory: string} -> {filename: string} list
    val readTextFile: {filename: string} -> string
    val revCompare: ('a * 'a -> order) -> 'a * 'a -> order
    val revDivide: 'a list -> int -> 'a list * 'a list
    val rot: int -> char -> char
    val setify: ''a list -> ''a list
    type sieve
    val singleton: 'a -> 'a list
    val snd: 'a * 'b -> 'b
    val sort: ('a * 'a -> order) -> 'a list -> 'a list
    val sortMap: ('a -> 'b) -> ('b * 'b -> order) -> 'a list -> 'a list
    val split: string -> string -> string list
    val stripPrefix: (char -> bool) -> string -> string
    val stripSuffix: (char -> bool) -> string -> string
    val subset: ''a list -> ''a list -> bool
    datatype ('a, 'b) sum = Left of 'a | Right of 'b
    val swap: 'a * 'b -> 'b * 'a
    val takeWhile: ('a -> bool) -> 'a list -> 'a list
    val time: unit -> string
    val timed: ('a -> 'b) -> 'a -> real * 'b
    val timedMany: ('a -> 'b) -> 'a -> real * 'b
    val total: ('a -> 'b) -> 'a -> 'b option
    val trace: string -> unit
    val tracePrint: (string -> unit) ref
    val trim: string -> string
    val try: ('a -> 'b) -> 'a -> 'b
    val uncurry: ('a -> 'b -> 'c) -> 'a * 'b -> 'c
    val union: ''a list -> ''a list -> ''a list
    val unit: 'a -> 'b -> 'a * 'b
    val unzip: ('a * 'b) list -> 'a list * 'b list
    val updateNth: int * 'a -> 'a list -> 'a list
    val warn: string -> unit
    val withRef: 'a ref * 'a -> ('b -> 'c) -> 'b -> 'c
    val writeTextFile: {contents: string, filename: string} -> unit
    val zip: 'a list -> 'b list -> ('a * 'b) list
    val zipWith: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
  end
signature Metis_Lazy =
  sig
    val delay: (unit -> 'a) -> 'a lazy
    val force: 'a lazy -> 'a
    type 'a lazy
    val memoize: (unit -> 'a) -> unit -> 'a
    val quickly: 'a -> 'a lazy
  end
signature Metis_Ordered = sig val compare: t * t -> order type t end
structure Metis_Portable: Metis_Portable
structure Metis_Useful: Metis_Useful
structure Metis_Lazy: Metis_Lazy
structure Metis_IntOrdered: sig val compare: int * int -> order eqtype t end
constructor ANTIQUOTE: 'a -> 'a frag
constructor QUOTE: string -> 'a frag
structure Metis_IntPairOrdered:
  sig val compare: (int * int) * (int * int) -> order type t = int * int end
structure Metis_StringOrdered:
  sig val compare: string * string -> order eqtype t end
signature Metis_Map =
  sig
    val advanceIterator: ('a, 'b) iterator -> ('a, 'b) iterator option
    val all: ('a * 'b -> bool) -> ('a, 'b) map -> bool
    val app: ('a * 'b -> unit) -> ('a, 'b) map -> unit
    val compare: ('a * 'a -> order) -> ('b, 'a) map * ('b, 'a) map -> order
    val count: ('a * 'b -> bool) -> ('a, 'b) map -> int
    val delete: ('a, 'b) map -> 'a -> ('a, 'b) map
    val deleteNth: ('a, 'b) map -> int -> ('a * 'b) * ('a, 'b) map
    val deletePick: ('a, 'b) map -> ('a * 'b) * ('a, 'b) map
    val deleteRandom: ('a, 'b) map -> ('a * 'b) * ('a, 'b) map
    val differenceDomain: ('a, 'b) map -> ('a, 'b) map -> ('a, 'b) map
    val disjointDomain: ('a, 'b) map -> ('a, 'b) map -> bool
    val equal: ('a -> 'a -> bool) -> ('b, 'a) map -> ('b, 'a) map -> bool
    val equalDomain: ('a, 'b) map -> ('a, 'b) map -> bool
    val exists: ('a * 'b -> bool) -> ('a, 'b) map -> bool
    val filter: ('a * 'b -> bool) -> ('a, 'b) map -> ('a, 'b) map
    val findl: ('a * 'b -> bool) -> ('a, 'b) map -> ('a * 'b) option
    val findr: ('a * 'b -> bool) -> ('a, 'b) map -> ('a * 'b) option
    val firstl: ('a * 'b -> 'c option) -> ('a, 'b) map -> 'c option
    val firstr: ('a * 'b -> 'c option) -> ('a, 'b) map -> 'c option
    val foldl: ('a * 'b * 'c -> 'c) -> 'c -> ('a, 'b) map -> 'c
    val foldr: ('a * 'b * 'c -> 'c) -> 'c -> ('a, 'b) map -> 'c
    val fromList: ('a * 'a -> order) -> ('a * 'b) list -> ('a, 'b) map
    val get: ('a, 'b) map -> 'a -> 'b
    val inDomain: 'a -> ('a, 'b) map -> bool
    val insert: ('a, 'b) map -> 'a * 'b -> ('a, 'b) map
    val insertList: ('a, 'b) map -> ('a * 'b) list -> ('a, 'b) map
    val intersect:
       (('a * 'b) * ('a * 'c) -> 'd option) ->
         ('a, 'b) map -> ('a, 'c) map -> ('a, 'd) map
    val intersectDomain: ('a, 'b) map -> ('a, 'b) map -> ('a, 'b) map
    val intersectListDomain: ('a, 'b) map list -> ('a, 'b) map
    type ('a, 'b) iterator
    val keys: ('a, 'b) map -> 'a list
    val map: ('a * 'b -> 'c) -> ('a, 'b) map -> ('a, 'c) map
    type ('a, 'b) map
    val mapPartial: ('a * 'b -> 'c option) -> ('a, 'b) map -> ('a, 'c) map
    val merge:
       {both: ('a * 'b) * ('a * 'c) -> 'd option,
        first: 'a * 'b -> 'd option, second: 'a * 'c -> 'd option}
         -> ('a, 'b) map -> ('a, 'c) map -> ('a, 'd) map
    val mkIterator: ('a, 'b) map -> ('a, 'b) iterator option
    val mkRevIterator: ('a, 'b) map -> ('a, 'b) iterator option
    val new: ('a * 'a -> order) -> ('a, 'b) map
    val nth: ('a, 'b) map -> int -> 'a * 'b
    val null: ('a, 'b) map -> bool
    val partition:
       ('a * 'b -> bool) -> ('a, 'b) map -> ('a, 'b) map * ('a, 'b) map
    val peek: ('a, 'b) map -> 'a -> 'b option
    val peekKey: ('a, 'b) map -> 'a -> ('a * 'b) option
    val pick: ('a, 'b) map -> 'a * 'b
    val random: ('a, 'b) map -> 'a * 'b
    val readIterator: ('a, 'b) iterator -> 'a * 'b
    val remove: ('a, 'b) map -> 'a -> ('a, 'b) map
    val singleton: ('a * 'a -> order) -> 'a * 'b -> ('a, 'b) map
    val size: ('a, 'b) map -> int
    val subsetDomain: ('a, 'b) map -> ('a, 'b) map -> bool
    val symmetricDifferenceDomain:
       ('a, 'b) map -> ('a, 'b) map -> ('a, 'b) map
    val toList: ('a, 'b) map -> ('a * 'b) list
    val toString: ('a, 'b) map -> string
    val transform: ('a -> 'b) -> ('c, 'a) map -> ('c, 'b) map
    val union:
       (('a * 'b) * ('a * 'b) -> 'b option) ->
         ('a, 'b) map -> ('a, 'b) map -> ('a, 'b) map
    val unionDomain: ('a, 'b) map -> ('a, 'b) map -> ('a, 'b) map
    val unionListDomain: ('a, 'b) map list -> ('a, 'b) map
    val values: ('a, 'b) map -> 'b list
  end
signature Metis_KeyMap =
  sig
    val advanceIterator: 'a iterator -> 'a iterator option
    val all: (key * 'a -> bool) -> 'a map -> bool
    val app: (key * 'a -> unit) -> 'a map -> unit
    val compare: ('a * 'a -> order) -> 'a map * 'a map -> order
    val compareKey: key * key -> order
    val count: (key * 'a -> bool) -> 'a map -> int
    val delete: 'a map -> key -> 'a map
    val deleteNth: 'a map -> int -> (key * 'a) * 'a map
    val deletePick: 'a map -> (key * 'a) * 'a map
    val deleteRandom: 'a map -> (key * 'a) * 'a map
    val differenceDomain: 'a map -> 'a map -> 'a map
    val disjointDomain: 'a map -> 'a map -> bool
    val equal: ('a -> 'a -> bool) -> 'a map -> 'a map -> bool
    val equalDomain: 'a map -> 'a map -> bool
    val equalKey: key -> key -> bool
    val exists: (key * 'a -> bool) -> 'a map -> bool
    val filter: (key * 'a -> bool) -> 'a map -> 'a map
    val findl: (key * 'a -> bool) -> 'a map -> (key * 'a) option
    val findr: (key * 'a -> bool) -> 'a map -> (key * 'a) option
    val firstl: (key * 'a -> 'b option) -> 'a map -> 'b option
    val firstr: (key * 'a -> 'b option) -> 'a map -> 'b option
    val foldl: (key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldr: (key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val fromList: (key * 'a) list -> 'a map
    val get: 'a map -> key -> 'a
    val inDomain: key -> 'a map -> bool
    val insert: 'a map -> key * 'a -> 'a map
    val insertList: 'a map -> (key * 'a) list -> 'a map
    val intersect:
       ((key * 'a) * (key * 'b) -> 'c option) -> 'a map -> 'b map -> 'c map
    val intersectDomain: 'a map -> 'a map -> 'a map
    val intersectListDomain: 'a map list -> 'a map
    type 'a iterator
    type key
    val keys: 'a map -> key list
    val map: (key * 'a -> 'b) -> 'a map -> 'b map
    type 'a map
    val mapPartial: (key * 'a -> 'b option) -> 'a map -> 'b map
    val merge:
       {both: (key * 'a) * (key * 'b) -> 'c option,
        first: key * 'a -> 'c option, second: key * 'b -> 'c option}
         -> 'a map -> 'b map -> 'c map
    val mkIterator: 'a map -> 'a iterator option
    val mkRevIterator: 'a map -> 'a iterator option
    val new: unit -> 'a map
    val nth: 'a map -> int -> key * 'a
    val null: 'a map -> bool
    val partition: (key * 'a -> bool) -> 'a map -> 'a map * 'a map
    val peek: 'a map -> key -> 'a option
    val peekKey: 'a map -> key -> (key * 'a) option
    val pick: 'a map -> key * 'a
    val random: 'a map -> key * 'a
    val readIterator: 'a iterator -> key * 'a
    val remove: 'a map -> key -> 'a map
    val singleton: key * 'a -> 'a map
    val size: 'a map -> int
    val subsetDomain: 'a map -> 'a map -> bool
    val symmetricDifferenceDomain: 'a map -> 'a map -> 'a map
    val toList: 'a map -> (key * 'a) list
    val toString: 'a map -> string
    val transform: ('a -> 'b) -> 'a map -> 'b map
    val union:
       ((key * 'a) * (key * 'a) -> 'a option) -> 'a map -> 'a map -> 'a map
    val unionDomain: 'a map -> 'a map -> 'a map
    val unionListDomain: 'a map list -> 'a map
    val values: 'a map -> 'a list
  end
structure Metis_Map: Metis_Map
structure Metis_IntMap: Metis_KeyMap
functor Metis_KeyMap (Key: Metis_Ordered): Metis_KeyMap
structure Metis_IntPairMap: Metis_KeyMap
structure Metis_StringMap: Metis_KeyMap
signature Metis_Set =
  sig
    val add: 'a set -> 'a -> 'a set
    val addList: 'a set -> 'a list -> 'a set
    val advanceIterator: 'a iterator -> 'a iterator option
    val all: ('a -> bool) -> 'a set -> bool
    val app: ('a -> unit) -> 'a set -> unit
    val compare: 'a set * 'a set -> order
    val count: ('a -> bool) -> 'a set -> int
    val delete: 'a set -> 'a -> 'a set
    val deleteNth: 'a set -> int -> 'a * 'a set
    val deletePick: 'a set -> 'a * 'a set
    val deleteRandom: 'a set -> 'a * 'a set
    val difference: 'a set -> 'a set -> 'a set
    val disjoint: 'a set -> 'a set -> bool
    val domain: ('a, 'b) map -> 'a set
    val empty: ('a * 'a -> order) -> 'a set
    val equal: 'a set -> 'a set -> bool
    val exists: ('a -> bool) -> 'a set -> bool
    val filter: ('a -> bool) -> 'a set -> 'a set
    val findl: ('a -> bool) -> 'a set -> 'a option
    val findr: ('a -> bool) -> 'a set -> 'a option
    val firstl: ('a -> 'b option) -> 'a set -> 'b option
    val firstr: ('a -> 'b option) -> 'a set -> 'b option
    val foldl: ('a * 'b -> 'b) -> 'b -> 'a set -> 'b
    val foldr: ('a * 'b -> 'b) -> 'b -> 'a set -> 'b
    val fromList: ('a * 'a -> order) -> 'a list -> 'a set
    val intersect: 'a set -> 'a set -> 'a set
    val intersectList: 'a set list -> 'a set
    type 'a iterator
    val map: ('a -> 'b) -> 'a set -> ('a, 'b) map
    type ('a, 'b) map
    val mapPartial: ('a -> 'b option) -> 'a set -> ('a, 'b) map
    val member: 'a -> 'a set -> bool
    val mkIterator: 'a set -> 'a iterator option
    val mkRevIterator: 'a set -> 'a iterator option
    val nth: 'a set -> int -> 'a
    val null: 'a set -> bool
    val partition: ('a -> bool) -> 'a set -> 'a set * 'a set
    val peek: 'a set -> 'a -> 'a option
    val pick: 'a set -> 'a
    val random: 'a set -> 'a
    val readIterator: 'a iterator -> 'a
    val remove: 'a set -> 'a -> 'a set
    type 'a set
    val singleton: ('a * 'a -> order) -> 'a -> 'a set
    val size: 'a set -> int
    val subset: 'a set -> 'a set -> bool
    val symmetricDifference: 'a set -> 'a set -> 'a set
    val toList: 'a set -> 'a list
    val toString: 'a set -> string
    val transform: ('a -> 'b) -> 'a set -> 'b list
    val union: 'a set -> 'a set -> 'a set
    val unionList: 'a set list -> 'a set
  end
signature Metis_ElementSet =
  sig
    val add: set -> element -> set
    val addList: set -> element list -> set
    val advanceIterator: iterator -> iterator option
    val all: (element -> bool) -> set -> bool
    val app: (element -> unit) -> set -> unit
    val close: (element -> set) -> set -> set
    val closedAdd: (element -> set) -> set -> set -> set
    val compare: set * set -> order
    val compareElement: element * element -> order
    val count: (element -> bool) -> set -> int
    val delete: set -> element -> set
    val deleteNth: set -> int -> element * set
    val deletePick: set -> element * set
    val deleteRandom: set -> element * set
    val difference: set -> set -> set
    val disjoint: set -> set -> bool
    val domain: 'a map -> set
    type element
    val empty: set
    val equal: set -> set -> bool
    val equalElement: element -> element -> bool
    val exists: (element -> bool) -> set -> bool
    val filter: (element -> bool) -> set -> set
    val findl: (element -> bool) -> set -> element option
    val findr: (element -> bool) -> set -> element option
    val firstl: (element -> 'a option) -> set -> 'a option
    val firstr: (element -> 'a option) -> set -> 'a option
    val foldl: (element * 'a -> 'a) -> 'a -> set -> 'a
    val foldr: (element * 'a -> 'a) -> 'a -> set -> 'a
    val fromList: element list -> set
    val intersect: set -> set -> set
    val intersectList: set list -> set
    type iterator
    val lift: (element -> set) -> set -> set
    val map: (element -> 'a) -> set -> 'a map
    type 'a map
    val mapPartial: (element -> 'a option) -> set -> 'a map
    val member: element -> set -> bool
    val mkIterator: set -> iterator option
    val mkRevIterator: set -> iterator option
    val nth: set -> int -> element
    val null: set -> bool
    datatype ordering = Cycle of element list | Linear of element list
    val partition: (element -> bool) -> set -> set * set
    val peek: set -> element -> element option
    val pick: set -> element
    val postOrder: (element -> set) -> set -> ordering
    val postOrderSCC: (element -> set) -> set -> set list
    val postOrdered: (element -> set) -> element list -> bool
    val postOrderedSCC: (element -> set) -> set list -> bool
    val preOrder: (element -> set) -> set -> ordering
    val preOrderSCC: (element -> set) -> set -> set list
    val preOrdered: (element -> set) -> element list -> bool
    val preOrderedSCC: (element -> set) -> set list -> bool
    val random: set -> element
    val readIterator: iterator -> element
    val remove: set -> element -> set
    type set
    val singleton: element -> set
    val size: set -> int
    val subset: set -> set -> bool
    val symmetricDifference: set -> set -> set
    val toList: set -> element list
    val toString: set -> string
    val transform: (element -> 'a) -> set -> 'a list
    val union: set -> set -> set
    val unionList: set list -> set
  end
structure Metis_Set: Metis_Set
structure Metis_IntSet: Metis_ElementSet
functor Metis_ElementSet (KM: Metis_KeyMap): Metis_ElementSet
structure Metis_IntPairSet: Metis_ElementSet
structure Metis_StringSet: Metis_ElementSet
signature Metis_Sharing =
  sig
    val cache: ('a * 'a -> order) -> ('a -> 'b) -> 'a -> 'b
    val hashCons: ('a * 'a -> order) -> 'a -> 'a
    val map: ('a -> 'a) -> 'a list -> 'a list
    val mapOption: ('a -> 'a) -> 'a option -> 'a option
    val maps: ('a -> 'b -> 'a * 'b) -> 'a list -> 'b -> 'a list * 'b
    val mapsOption:
       ('a -> 'b -> 'a * 'b) -> 'a option -> 'b -> 'a option * 'b
    val revMap: ('a -> 'a) -> 'a list -> 'a list
    val revMaps: ('a -> 'b -> 'a * 'b) -> 'a list -> 'b -> 'a list * 'b
    val setify: ''a list -> ''a list
    val updateNth: int * 'a -> 'a list -> 'a list
  end
signature Metis_Stream =
  sig
    val all: ('a -> bool) -> 'a stream -> bool
    val append: 'a stream -> (unit -> 'a stream) -> 'a stream
    val concat: 'a stream stream -> 'a stream
    val concatList: 'a stream list -> 'a stream
    val cons: 'a -> (unit -> 'a stream) -> 'a stream
    val count: int -> int stream
    val drop: int -> 'a stream -> 'a stream
    val exists: ('a -> bool) -> 'a stream -> bool
    val filter: ('a -> bool) -> 'a stream -> 'a stream
    val foldl: ('a * 'b -> 'b) -> 'b -> 'a stream -> 'b
    val fromList: 'a list -> 'a stream
    val fromString: string -> char stream
    val fromTextFile: {filename: string} -> string stream
    val funpows: ('a -> 'a) -> 'a -> 'a stream
    val hd: 'a stream -> 'a
    val hdTl: 'a stream -> 'a * 'a stream
    val length: 'a stream -> int
    val listConcat: 'a list stream -> 'a stream
    val map: ('a -> 'b) -> 'a stream -> 'b stream
    val mapConcat: ('a -> 'b stream) -> 'a stream -> 'b stream
    val mapPartial: ('a -> 'b option) -> 'a stream -> 'b stream
    val maps:
       ('a -> 'b -> 'c * 'b) ->
         ('b -> 'c stream) -> 'b -> 'a stream -> 'c stream
    val mapsConcat:
       ('a -> 'b -> 'c stream * 'b) ->
         ('b -> 'c stream) -> 'b -> 'a stream -> 'c stream
    val mapsPartial:
       ('a -> 'b -> 'c option * 'b) ->
         ('b -> 'c stream) -> 'b -> 'a stream -> 'c stream
    val memoize: 'a stream -> 'a stream
    val null: 'a stream -> bool
    val primes: int stream
    val repeat: 'a -> 'a stream
    val singleton: 'a -> 'a stream
    datatype 'a stream = Cons of 'a * (unit -> 'a stream) | Nil
    val take: int -> 'a stream -> 'a stream
    val tl: 'a stream -> 'a stream
    val toList: 'a stream -> 'a list
    val toString: char stream -> string
    val toTextFile: {filename: string} -> string stream -> unit
    val unfold: ('a -> ('b * 'a) option) -> 'a -> 'b stream
    val zip: 'a stream -> 'b stream -> ('a * 'b) stream
    val zipwith: ('a -> 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream
  end
signature Metis_Heap =
  sig
    val add: 'a heap -> 'a -> 'a heap
    val app: ('a -> unit) -> 'a heap -> unit
    type 'a heap
    val new: ('a * 'a -> order) -> 'a heap
    val null: 'a heap -> bool
    val remove: 'a heap -> 'a * 'a heap
    val size: 'a heap -> int
    val toList: 'a heap -> 'a list
    val toStream: 'a heap -> 'a Metis_Stream.stream
    val toString: 'a heap -> string
    val top: 'a heap -> 'a
  end
signature Metis_Print =
  sig
    datatype assoc = LeftAssoc | NonAssoc | RightAssoc
    val block: block -> ppstream -> ppstream
    datatype block = Block of {indent: int, style: style}
    val break: ppstream
    datatype break = Break of {extraIndent: int, size: int}
    val breaks: int -> ppstream
    val charWord: char -> word
    val consistentBlock: int -> ppstream list -> ppstream
    val duplicate: int -> ppstream -> ppstream
    val emptyWord: word
    val escapeString: {escape: char list} -> string -> string
    val inconsistentBlock: int -> ppstream list -> ppstream
    val indentBlock: block -> int
    datatype infixes
    = Infixes of {assoc: assoc, precedence: int, token: token} list
    val layerInfixes:
       infixes -> {assoc: assoc, tokens: Metis_StringSet.set} list
    val lineLength: int ref
    val mkBreak: int -> break
    val mkWord: string -> word
    val newline: ppstream
    val newlines: int -> ppstream
    type 'a pp = 'a -> ppstream
    val ppBool: bool pp
    val ppBracket: string -> string -> 'a pp -> 'a pp
    val ppBreak: break pp
    val ppChar: char pp
    val ppEscapeString: {escape: char list} -> string pp
    val ppException: exn pp
    val ppInfixes:
       infixes ->
         ('a -> (token * 'a * 'a) option) ->
           ('a * token) pp -> ('a * bool) pp -> ('a * bool) pp
    val ppInt: int pp
    val ppList: 'a pp -> 'a list pp
    val ppMap: ('a -> 'b) -> 'b pp -> 'a pp
    val ppOp: string -> ppstream
    val ppOp2: string -> 'a pp -> 'b pp -> ('a * 'b) pp
    val ppOp3:
       string -> string -> 'a pp -> 'b pp -> 'c pp -> ('a * 'b * 'c) pp
    val ppOpList: string -> 'a pp -> 'a list pp
    val ppOpStream: string -> 'a pp -> 'a Metis_Stream.stream pp
    val ppOption: 'a pp -> 'a option pp
    val ppOrder: order pp
    val ppPair: 'a pp -> 'b pp -> ('a * 'b) pp
    val ppPercent: real pp
    val ppPpstream: ppstream pp
    val ppPrettyInt: int pp
    val ppReal: real pp
    val ppStream: 'a pp -> 'a Metis_Stream.stream pp
    val ppString: string pp
    val ppTriple: 'a pp -> 'b pp -> 'c pp -> ('a * 'b * 'c) pp
    val ppUnit: unit pp
    val ppWord: word pp
    type ppstream
    val program: ppstream list -> ppstream
    val render:
       {lineLength: int option} ->
         ppstream -> {indent: int, line: string} Metis_Stream.stream
    val sequence: ppstream -> ppstream -> ppstream
    val skip: ppstream
    val space: ppstream
    val spaces: int -> ppstream
    val stream: ppstream Metis_Stream.stream -> ppstream
    datatype style = Consistent | Inconsistent
    val styleBlock: block -> style
    val toLine: 'a pp -> 'a -> string
    val toStream: 'a pp -> 'a -> string Metis_Stream.stream
    val toStreamWithLineLength:
       {lineLength: int option} -> 'a pp -> 'a -> string Metis_Stream.stream
    val toString: 'a pp -> 'a -> string
    val toStringWithLineLength:
       {lineLength: int option} -> 'a pp -> 'a -> string
    eqtype token
    val tokensInfixes: infixes -> Metis_StringSet.set
    val trace: 'a pp -> string -> 'a -> unit
    datatype word = Word of {size: int, word: string}
  end
signature Metis_Parse =
  sig
    val ++ : ('a -> 'b * 'a) * ('a -> 'c * 'a) -> 'a -> ('b * 'c) * 'a
    val >> : ('a -> 'b * 'a) * ('b -> 'c) -> 'a -> 'c * 'a
    val >>++ : ('a -> 'b * 'a) * ('b -> 'a -> 'c * 'a) -> 'a -> 'c * 'a
    exception NoParse
    val any: ('a, 'a) parser
    val atLeastOne: ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val atLeastOneSpace: (char, unit) parser
    val error: 'a -> 'b * 'a
    val escapeString: {escape: char list} -> (char, string) parser
    val everything:
       ('a, 'b list) parser ->
         'a Metis_Stream.stream -> 'b Metis_Stream.stream
    val exactChar: char -> (char, unit) parser
    val exactCharList: char list -> (char, unit) parser
    val exactString: string -> (char, unit) parser
    val finished: ('a, unit) parser
    val first: ('a -> 'b * 'a) list -> 'a -> 'b * 'a
    val fromList: ('a, 'b) parser -> 'a list -> 'b
    val fromStream: ('a, 'b) parser -> 'a Metis_Stream.stream -> 'b
    val fromString: (char, 'a) parser -> string -> 'a
    val initialize:
       {lines: string Metis_Stream.stream} ->
         {chars: char list Metis_Stream.stream,
          parseErrorLocation: unit -> string}
    val many: ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val manySpace: (char, unit) parser
    val maybe: ('a -> 'b option) -> ('a, 'b) parser
    val mmany: ('a -> 'b -> 'a * 'b) -> 'a -> 'b -> 'a * 'b
    val nothing: 'a -> unit * 'a
    val optional: ('a -> 'b * 'a) -> 'a -> 'b option * 'a
    val parseInfixes:
       Metis_Print.infixes ->
         (string * 'a * 'a -> 'a) ->
           ('b, string) parser -> ('b, 'a) parser -> ('b, 'a) parser
    val parseQuotation:
       ('a -> string) -> (string -> 'b) -> 'a quotation -> 'b
    type ('a, 'b) parser =
       'a Metis_Stream.stream -> 'b * 'a Metis_Stream.stream
    type 'a quotation = 'a frag list
    val some: ('a -> bool) -> ('a, 'a) parser
    val || : ('a -> 'b * 'a) * ('a -> 'b * 'a) -> 'a -> 'b * 'a
  end
signature Metis_Name =
  sig
    val compare: name * name -> order
    val equal: name -> name -> bool
    val fromString: string -> name
    type name
    val newName: unit -> name
    val newNames: int -> name list
    val pp: name Metis_Print.pp
    val toString: name -> string
    val variantNum: {avoid: name -> bool} -> name -> name
    val variantPrime: {avoid: name -> bool} -> name -> name
  end
structure Metis_Sharing: Metis_Sharing
structure Metis_Stream: Metis_Stream
structure Metis_Heap: Metis_Heap
structure Metis_Print: Metis_Print
structure Metis_Parse: Metis_Parse
structure Metis_Name: Metis_Name
structure Metis_NameOrdered:
  sig val compare: Metis_Name.name * Metis_Name.name -> order type t end
structure Metis_NameMap: Metis_KeyMap
signature Metis_NameArity =
  sig
    val arity: nameArity -> int
    val binary: nameArity -> bool
    val compare: nameArity * nameArity -> order
    val equal: nameArity -> nameArity -> bool
    val name: nameArity -> Metis_Name.name
    type nameArity = Metis_Name.name * int
    val nary: int -> nameArity -> bool
    val nullary: nameArity -> bool
    val pp: nameArity Metis_Print.pp
    val ternary: nameArity -> bool
    val unary: nameArity -> bool
  end
signature Metis_Term =
  sig
    val appName: Metis_Name.name
    val binders: string list ref
    val brackets: (string * string) list ref
    val compare: term * term -> order
    type const
    val destApp: term -> term * term
    val destBinop: functionName -> term -> term * term
    val destConst: term -> const
    val destFn: term -> functionName * term list
    val destVar: term -> var
    val equal: term -> term -> bool
    val equalVar: var -> term -> bool
    val find: (term -> bool) -> term -> path option
    val fnArguments: term -> term list
    val fnArity: term -> int
    val fnFunction: term -> function
    val fnName: term -> functionName
    val freeIn: var -> term -> bool
    val freeVars: term -> Metis_NameSet.S.set
    val freeVarsList: term list -> Metis_NameSet.S.set
    val fromString: string -> term
    type function = functionName * int
    type functionName
    val functionNames: term -> Metis_NameSet.S.set
    val functions: term -> Metis_NameAritySet.S.set
    val hasTypeFunction: function
    val hasTypeFunctionName: functionName
    val infixes: Metis_Print.infixes ref
    val isApp: term -> bool
    val isBinop: functionName -> term -> bool
    val isConst: term -> bool
    val isFn: term -> bool
    val isTypedVar: term -> bool
    val isVar: term -> bool
    val listMkApp: term * term list -> term
    val mkApp: term * term -> term
    val mkBinop: functionName -> term * term -> term
    val mkConst: const -> term
    val negation: string ref
    val newVar: unit -> term
    val newVars: int -> term list
    val nonVarTypedSubterms: term -> (path * term) list
    val parse: term Metis_Parse.quotation -> term
    type path = int list
    val pathToString: path -> string
    val pp: term Metis_Print.pp
    val ppPath: path Metis_Print.pp
    val replace: term -> path * term -> term
    val stripApp: term -> term * term list
    val subterm: term -> path -> term
    val subterms: term -> (path * term) list
    val symbols: term -> int
    datatype term = Fn of functionName * term list | Var of var
    val toString: term -> string
    val typedSymbols: term -> int
    type var
    val variantNum: Metis_NameSet.S.set -> var -> var
    val variantPrime: Metis_NameSet.S.set -> var -> var
  end
structure Metis_NameSet:
  sig
    val add: set -> element -> set
    val addList: set -> element list -> set
    val advanceIterator: iterator -> iterator option
    val all: (element -> bool) -> set -> bool
    val app: (element -> unit) -> set -> unit
    val close: (element -> set) -> set -> set
    val closedAdd: (element -> set) -> set -> set -> set
    val compare: set * set -> order
    val compareElement: element * element -> order
    val count: (element -> bool) -> set -> int
    val delete: set -> element -> set
    val deleteNth: set -> int -> element * set
    val deletePick: set -> element * set
    val deleteRandom: set -> element * set
    val difference: set -> set -> set
    val disjoint: set -> set -> bool
    val domain: 'a map -> set
    type element
    val empty: set
    val equal: set -> set -> bool
    val equalElement: element -> element -> bool
    val exists: (element -> bool) -> set -> bool
    val filter: (element -> bool) -> set -> set
    val findl: (element -> bool) -> set -> element option
    val findr: (element -> bool) -> set -> element option
    val firstl: (element -> 'a option) -> set -> 'a option
    val firstr: (element -> 'a option) -> set -> 'a option
    val foldl: (element * 'a -> 'a) -> 'a -> set -> 'a
    val foldr: (element * 'a -> 'a) -> 'a -> set -> 'a
    val fromList: element list -> set
    val intersect: set -> set -> set
    val intersectList: set list -> set
    type iterator
    val lift: (element -> set) -> set -> set
    val map: (element -> 'a) -> set -> 'a map
    type 'a map
    val mapPartial: (element -> 'a option) -> set -> 'a map
    val member: element -> set -> bool
    val mkIterator: set -> iterator option
    val mkRevIterator: set -> iterator option
    val nth: set -> int -> element
    val null: set -> bool
    datatype ordering = Cycle of element list | Linear of element list
    val partition: (element -> bool) -> set -> set * set
    val peek: set -> element -> element option
    val pick: set -> element
    val postOrder: (element -> set) -> set -> ordering
    val postOrderSCC: (element -> set) -> set -> set list
    val postOrdered: (element -> set) -> element list -> bool
    val postOrderedSCC: (element -> set) -> set list -> bool
    val pp: set Metis_Print.pp
    val preOrder: (element -> set) -> set -> ordering
    val preOrderSCC: (element -> set) -> set -> set list
    val preOrdered: (element -> set) -> element list -> bool
    val preOrderedSCC: (element -> set) -> set list -> bool
    val random: set -> element
    val readIterator: iterator -> element
    val remove: set -> element -> set
    type set
    val singleton: element -> set
    val size: set -> int
    val subset: set -> set -> bool
    val symmetricDifference: set -> set -> set
    val toList: set -> element list
    val toString: set -> string
    val transform: (element -> 'a) -> set -> 'a list
    val union: set -> set -> set
    val unionList: set list -> set
  end
structure Metis_NameArity: Metis_NameArity
structure Metis_NameArityOrdered:
  sig
    val compare:
       Metis_NameArity.nameArity * Metis_NameArity.nameArity -> order
    type t = Metis_NameArity.nameArity
  end
structure Metis_NameArityMap:
  sig
    val advanceIterator: 'a iterator -> 'a iterator option
    val all: (key * 'a -> bool) -> 'a map -> bool
    val app: (key * 'a -> unit) -> 'a map -> unit
    val compare: ('a * 'a -> order) -> 'a map * 'a map -> order
    val compareKey: key * key -> order
    val compose: Metis_Name.name map -> 'a map -> 'a map
    val count: (key * 'a -> bool) -> 'a map -> int
    val delete: 'a map -> key -> 'a map
    val deleteNth: 'a map -> int -> (key * 'a) * 'a map
    val deletePick: 'a map -> (key * 'a) * 'a map
    val deleteRandom: 'a map -> (key * 'a) * 'a map
    val differenceDomain: 'a map -> 'a map -> 'a map
    val disjointDomain: 'a map -> 'a map -> bool
    val equal: ('a -> 'a -> bool) -> 'a map -> 'a map -> bool
    val equalDomain: 'a map -> 'a map -> bool
    val equalKey: key -> key -> bool
    val exists: (key * 'a -> bool) -> 'a map -> bool
    val filter: (key * 'a -> bool) -> 'a map -> 'a map
    val findl: (key * 'a -> bool) -> 'a map -> (key * 'a) option
    val findr: (key * 'a -> bool) -> 'a map -> (key * 'a) option
    val firstl: (key * 'a -> 'b option) -> 'a map -> 'b option
    val firstr: (key * 'a -> 'b option) -> 'a map -> 'b option
    val foldl: (key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val foldr: (key * 'a * 'b -> 'b) -> 'b -> 'a map -> 'b
    val fromList: (key * 'a) list -> 'a map
    val get: 'a map -> key -> 'a
    val inDomain: key -> 'a map -> bool
    val insert: 'a map -> key * 'a -> 'a map
    val insertList: 'a map -> (key * 'a) list -> 'a map
    val intersect:
       ((key * 'a) * (key * 'b) -> 'c option) -> 'a map -> 'b map -> 'c map
    val intersectDomain: 'a map -> 'a map -> 'a map
    val intersectListDomain: 'a map list -> 'a map
    type 'a iterator
    type key = Metis_NameArity.nameArity
    val keys: 'a map -> key list
    val map: (key * 'a -> 'b) -> 'a map -> 'b map
    type 'a map
    val mapPartial: (key * 'a -> 'b option) -> 'a map -> 'b map
    val merge:
       {both: (key * 'a) * (key * 'b) -> 'c option,
        first: key * 'a -> 'c option, second: key * 'b -> 'c option}
         -> 'a map -> 'b map -> 'c map
    val mkIterator: 'a map -> 'a iterator option
    val mkRevIterator: 'a map -> 'a iterator option
    val new: unit -> 'a map
    val nth: 'a map -> int -> key * 'a
    val null: 'a map -> bool
    val partition: (key * 'a -> bool) -> 'a map -> 'a map * 'a map
    val peek: 'a map -> key -> 'a option
    val peekKey: 'a map -> key -> (key * 'a) option
    val pick: 'a map -> key * 'a
    val random: 'a map -> key * 'a
    val readIterator: 'a iterator -> key * 'a
    val remove: 'a map -> key -> 'a map
    val singleton: key * 'a -> 'a map
    val size: 'a map -> int
    val subsetDomain: 'a map -> 'a map -> bool
    val symmetricDifferenceDomain: 'a map -> 'a map -> 'a map
    val toList: 'a map -> (key * 'a) list
    val toString: 'a map -> string
    val transform: ('a -> 'b) -> 'a map -> 'b map
    val union:
       ((key * 'a) * (key * 'a) -> 'a option) -> 'a map -> 'a map -> 'a map
    val unionDomain: 'a map -> 'a map -> 'a map
    val unionListDomain: 'a map list -> 'a map
    val values: 'a map -> 'a list
  end
structure Metis_NameAritySet:
  sig
    val add: set -> element -> set
    val addList: set -> element list -> set
    val advanceIterator: iterator -> iterator option
    val all: (element -> bool) -> set -> bool
    val allNullary: set -> bool
    val app: (element -> unit) -> set -> unit
    val close: (element -> set) -> set -> set
    val closedAdd: (element -> set) -> set -> set -> set
    val compare: set * set -> order
    val compareElement: element * element -> order
    val count: (element -> bool) -> set -> int
    val delete: set -> element -> set
    val deleteNth: set -> int -> element * set
    val deletePick: set -> element * set
    val deleteRandom: set -> element * set
    val difference: set -> set -> set
    val disjoint: set -> set -> bool
    val domain: 'a map -> set
    type element = Metis_NameArity.nameArity
    val empty: set
    val equal: set -> set -> bool
    val equalElement: element -> element -> bool
    val exists: (element -> bool) -> set -> bool
    val filter: (element -> bool) -> set -> set
    val findl: (element -> bool) -> set -> element option
    val findr: (element -> bool) -> set -> element option
    val firstl: (element -> 'a option) -> set -> 'a option
    val firstr: (element -> 'a option) -> set -> 'a option
    val foldl: (element * 'a -> 'a) -> 'a -> set -> 'a
    val foldr: (element * 'a -> 'a) -> 'a -> set -> 'a
    val fromList: element list -> set
    val intersect: set -> set -> set
    val intersectList: set list -> set
    type iterator
    val lift: (element -> set) -> set -> set
    val map: (element -> 'a) -> set -> 'a map
    type 'a map
    val mapPartial: (element -> 'a option) -> set -> 'a map
    val member: element -> set -> bool
    val mkIterator: set -> iterator option
    val mkRevIterator: set -> iterator option
    val nth: set -> int -> element
    val null: set -> bool
    datatype ordering = Cycle of element list | Linear of element list
    val partition: (element -> bool) -> set -> set * set
    val peek: set -> element -> element option
    val pick: set -> element
    val postOrder: (element -> set) -> set -> ordering
    val postOrderSCC: (element -> set) -> set -> set list
    val postOrdered: (element -> set) -> element list -> bool
    val postOrderedSCC: (element -> set) -> set list -> bool
    val pp: set Metis_Print.pp
    val preOrder: (element -> set) -> set -> ordering
    val preOrderSCC: (element -> set) -> set -> set list
    val preOrdered: (element -> set) -> element list -> bool
    val preOrderedSCC: (element -> set) -> set list -> bool
    val random: set -> element
    val readIterator: iterator -> element
    val remove: set -> element -> set
    type set
    val singleton: element -> set
    val size: set -> int
    val subset: set -> set -> bool
    val symmetricDifference: set -> set -> set
    val toList: set -> element list
    val toString: set -> string
    val transform: (element -> 'a) -> set -> 'a list
    val union: set -> set -> set
    val unionList: set list -> set
  end
structure Metis_Term: Metis_Term
structure Metis_TermOrdered:
  sig val compare: Metis_Term.term * Metis_Term.term -> order type t end
structure Metis_TermMap: Metis_KeyMap
structure Metis_TermSet: Metis_ElementSet
signature Metis_Subst =
  sig
    val compose: subst -> subst -> subst
    val empty: subst
    val foldl: (var * Metis_Term.term * 'a -> 'a) -> 'a -> subst -> 'a
    val foldr: (var * Metis_Term.term * 'a -> 'a) -> 'a -> subst -> 'a
    val freeVars: subst -> Metis_NameSet.S.set
    val freshVars: Metis_NameSet.S.set -> subst
    val fromList: (var * Metis_Term.term) list -> subst
    val functions: subst -> Metis_NameAritySet.S.set
    val insert: subst -> var * Metis_Term.term -> subst
    val invert: subst -> subst
    val isRenaming: subst -> bool
    val match: subst -> Metis_Term.term -> Metis_Term.term -> subst
    val normalize: subst -> subst
    val null: subst -> bool
    val peek: subst -> var -> Metis_Term.term option
    val pp: subst Metis_Print.pp
    val redexes: subst -> Metis_NameSet.S.set
    val remove: subst -> Metis_NameSet.S.set -> subst
    val residueFreeVars: subst -> Metis_NameSet.S.set
    val restrict: subst -> Metis_NameSet.S.set -> subst
    val singleton: var * Metis_Term.term -> subst
    val size: subst -> int
    val subst: subst -> Metis_Term.term -> Metis_Term.term
    type subst
    val toList: subst -> (var * Metis_Term.term) list
    val toString: subst -> string
    val unify: subst -> Metis_Term.term -> Metis_Term.term -> subst
    val union: subst -> subst -> subst
  end
signature Metis_Atom =
  sig
    val arguments: atom -> Metis_Term.term list
    val arity: atom -> int
    type atom = relationName * Metis_Term.term list
    val compare: atom * atom -> order
    val destBinop: relationName -> atom -> Metis_Term.term * Metis_Term.term
    val destEq: atom -> Metis_Term.term * Metis_Term.term
    val destRefl: atom -> Metis_Term.term
    val eqRelation: relation
    val eqRelationName: relationName
    val equal: atom -> atom -> bool
    val find: (Metis_Term.term -> bool) -> atom -> Metis_Term.path option
    val freeIn: var -> atom -> bool
    val freeVars: atom -> Metis_NameSet.S.set
    val fromString: string -> atom
    val functionNames: atom -> Metis_NameSet.S.set
    val functions: atom -> Metis_NameAritySet.S.set
    val isBinop: relationName -> atom -> bool
    val isEq: atom -> bool
    val isRefl: atom -> bool
    val lhs: atom -> Metis_Term.term
    val match: Metis_Subst.subst -> atom -> atom -> Metis_Subst.subst
    val mkBinop: relationName -> Metis_Term.term * Metis_Term.term -> atom
    val mkEq: Metis_Term.term * Metis_Term.term -> atom
    val mkRefl: Metis_Term.term -> atom
    val name: atom -> relationName
    val nonVarTypedSubterms:
       atom -> (Metis_Term.path * Metis_Term.term) list
    val parse: Metis_Term.term Metis_Parse.quotation -> atom
    val pp: atom Metis_Print.pp
    val relation: atom -> relation
    type relation = relationName * int
    type relationName
    val replace: atom -> Metis_Term.path * Metis_Term.term -> atom
    val rhs: atom -> Metis_Term.term
    val subst: Metis_Subst.subst -> atom -> atom
    val subterm: atom -> Metis_Term.path -> Metis_Term.term
    val subterms: atom -> (Metis_Term.path * Metis_Term.term) list
    val sym: atom -> atom
    val symbols: atom -> int
    val toString: atom -> string
    val typedSymbols: atom -> int
    val unify: Metis_Subst.subst -> atom -> atom -> Metis_Subst.subst
  end
structure Metis_Subst: Metis_Subst
structure Metis_Atom: Metis_Atom
structure Metis_AtomOrdered:
  sig
    val compare: Metis_Atom.atom * Metis_Atom.atom -> order
    type t = Metis_Atom.atom
  end
structure Metis_AtomMap: Metis_KeyMap
structure Metis_AtomSet: Metis_ElementSet
signature Metis_Formula =
  sig
    val compare: formula * formula -> order
    val destAtom: formula -> Metis_Atom.atom
    val destBoolean: formula -> bool
    val destEq: formula -> Metis_Term.term * Metis_Term.term
    val destExists: formula -> var * formula
    val destForall: formula -> var * formula
    val destNeg: formula -> formula
    val destNeq: formula -> Metis_Term.term * Metis_Term.term
    val destRefl: formula -> Metis_Term.term
    val equal: formula -> formula -> bool
    val flattenConj: formula -> formula list
    val flattenDisj: formula -> formula list
    val flattenEquiv: formula -> formula list
    datatype formula
    =
         And of formula * formula
       | Exists of var * formula
       | False
       | Forall of var * formula
       | Iff of formula * formula
       | Imp of formula * formula
       | Metis_Atom of Metis_Atom.atom
       | Not of formula
       | Or of formula * formula
       | True
    val freeIn: var -> formula -> bool
    val freeVars: formula -> Metis_NameSet.S.set
    val freeVarsList: formula list -> Metis_NameSet.S.set
    val fromString: string -> formula
    val functionNames: formula -> Metis_NameSet.S.set
    val functions: formula -> Metis_NameAritySet.S.set
    val generalize: formula -> formula
    val isAtom: formula -> bool
    val isBoolean: formula -> bool
    val isEq: formula -> bool
    val isExists: formula -> bool
    val isFalse: formula -> bool
    val isForall: formula -> bool
    val isNeg: formula -> bool
    val isNeq: formula -> bool
    val isRefl: formula -> bool
    val isTrue: formula -> bool
    val lhs: formula -> Metis_Term.term
    val listMkConj: formula list -> formula
    val listMkDisj: formula list -> formula
    val listMkEquiv: formula list -> formula
    val listMkExists: var list * formula -> formula
    val listMkForall: var list * formula -> formula
    val mkBoolean: bool -> formula
    val mkEq: Metis_Term.term * Metis_Term.term -> formula
    val mkNeq: Metis_Term.term * Metis_Term.term -> formula
    val mkRefl: Metis_Term.term -> formula
    val parse: quotation -> formula
    val pp: formula Metis_Print.pp
    type quotation = formula Metis_Parse.quotation
    val relationNames: formula -> Metis_NameSet.S.set
    val relations: formula -> Metis_NameAritySet.S.set
    val rhs: formula -> Metis_Term.term
    val setMkExists: Metis_NameSet.S.set * formula -> formula
    val setMkForall: Metis_NameSet.S.set * formula -> formula
    val specialize: formula -> formula
    val splitGoal: formula -> formula list
    val stripConj: formula -> formula list
    val stripDisj: formula -> formula list
    val stripEquiv: formula -> formula list
    val stripExists: formula -> var list * formula
    val stripForall: formula -> var list * formula
    val stripNeg: formula -> int * formula
    val subst: Metis_Subst.subst -> formula -> formula
    val sym: formula -> formula
    val symbols: formula -> int
    val toString: formula -> string
  end
structure Metis_Formula: Metis_Formula
structure Metis_FormulaOrdered:
  sig
    val compare: Metis_Formula.formula * Metis_Formula.formula -> order
    type t
  end
structure Metis_FormulaMap: Metis_KeyMap
structure Metis_FormulaSet: Metis_ElementSet
signature Metis_Literal =
  sig
    val arguments: literal -> Metis_Term.term list
    val arity: literal -> int
    val atom: literal -> Metis_Atom.atom
    val compare: literal * literal -> order
    val destBinop:
       relationName ->
         literal -> polarity * Metis_Term.term * Metis_Term.term
    val destEq: literal -> Metis_Term.term * Metis_Term.term
    val destIrrefl: literal -> Metis_Term.term
    val destNeq: literal -> Metis_Term.term * Metis_Term.term
    val destRefl: literal -> Metis_Term.term
    val equal: literal -> literal -> bool
    val freeIn: var -> literal -> bool
    val freeVars: literal -> Metis_NameSet.S.set
    val fromFormula: Metis_Formula.formula -> literal
    val fromString: string -> literal
    val functionNames: literal -> Metis_NameSet.S.set
    val functions: literal -> Metis_NameAritySet.S.set
    val isBinop: relationName -> literal -> bool
    val isEq: literal -> bool
    val isIrrefl: literal -> bool
    val isNeq: literal -> bool
    val isRefl: literal -> bool
    val lhs: literal -> Metis_Term.term
    type literal = polarity * Metis_Atom.atom
    val match: Metis_Subst.subst -> literal -> literal -> Metis_Subst.subst
    val mkBinop:
       relationName ->
         polarity * Metis_Term.term * Metis_Term.term -> literal
    val mkEq: Metis_Term.term * Metis_Term.term -> literal
    val mkIrrefl: Metis_Term.term -> literal
    val mkNeq: Metis_Term.term * Metis_Term.term -> literal
    val mkRefl: Metis_Term.term -> literal
    val name: literal -> relationName
    val negate: literal -> literal
    val negative: literal -> bool
    val nonVarTypedSubterms:
       literal -> (Metis_Term.path * Metis_Term.term) list
    val parse: Metis_Term.term Metis_Parse.quotation -> literal
    val polarity: literal -> polarity
    eqtype polarity
    val positive: literal -> bool
    val pp: literal Metis_Print.pp
    val relation: literal -> Metis_Atom.relation
    val replace: literal -> Metis_Term.path * Metis_Term.term -> literal
    val rhs: literal -> Metis_Term.term
    val subst: Metis_Subst.subst -> literal -> literal
    val subterm: literal -> Metis_Term.path -> Metis_Term.term
    val subterms: literal -> (Metis_Term.path * Metis_Term.term) list
    val sym: literal -> literal
    val symbols: literal -> int
    val toFormula: literal -> Metis_Formula.formula
    val toString: literal -> string
    val typedSymbols: literal -> int
    val unify: Metis_Subst.subst -> literal -> literal -> Metis_Subst.subst
  end
structure Metis_Literal: Metis_Literal
structure Metis_LiteralOrdered:
  sig
    val compare: Metis_Literal.literal * Metis_Literal.literal -> order
    type t = Metis_Literal.literal
  end
structure Metis_LiteralMap: Metis_KeyMap
structure Metis_LiteralSet:
  sig
    val add: set -> element -> set
    val addList: set -> element list -> set
    val advanceIterator: iterator -> iterator option
    val all: (element -> bool) -> set -> bool
    val app: (element -> unit) -> set -> unit
    val close: (element -> set) -> set -> set
    val closedAdd: (element -> set) -> set -> set -> set
    val compare: set * set -> order
    val compareElement: element * element -> order
    val conjoin: set -> Metis_Formula.formula
    val count: (element -> bool) -> set -> int
    val delete: set -> element -> set
    val deleteNth: set -> int -> element * set
    val deletePick: set -> element * set
    val deleteRandom: set -> element * set
    val difference: set -> set -> set
    val disjoin: set -> Metis_Formula.formula
    val disjoint: set -> set -> bool
    val domain: 'a map -> set
    type element = Metis_Literal.literal
    val empty: set
    val equal: set -> set -> bool
    val equalElement: element -> element -> bool
    val exists: (element -> bool) -> set -> bool
    val filter: (element -> bool) -> set -> set
    val findl: (element -> bool) -> set -> element option
    val findr: (element -> bool) -> set -> element option
    val firstl: (element -> 'a option) -> set -> 'a option
    val firstr: (element -> 'a option) -> set -> 'a option
    val foldl: (element * 'a -> 'a) -> 'a -> set -> 'a
    val foldr: (element * 'a -> 'a) -> 'a -> set -> 'a
    val freeIn: var -> set -> bool
    val freeVars: set -> ?.Metis_NameSet.S.set
    val freeVarsList: set list -> ?.Metis_NameSet.S.set
    val fromList: element list -> set
    val functions: set -> ?.Metis_NameAritySet.S.set
    val intersect: set -> set -> set
    val intersectList: set list -> set
    type iterator
    val lift: (element -> set) -> set -> set
    val map: (element -> 'a) -> set -> 'a map
    type 'a map
    val mapPartial: (element -> 'a option) -> set -> 'a map
    val member: element -> set -> bool
    val mkIterator: set -> iterator option
    val mkRevIterator: set -> iterator option
    val negate: set -> set
    val negateMember: Metis_Literal.literal -> set -> bool
    val nth: set -> int -> element
    val null: set -> bool
    datatype ordering = Cycle of element list | Linear of element list
    val partition: (element -> bool) -> set -> set * set
    val peek: set -> element -> element option
    val pick: set -> element
    val postOrder: (element -> set) -> set -> ordering
    val postOrderSCC: (element -> set) -> set -> set list
    val postOrdered: (element -> set) -> element list -> bool
    val postOrderedSCC: (element -> set) -> set list -> bool
    val pp: set Metis_Print.pp
    val preOrder: (element -> set) -> set -> ordering
    val preOrderSCC: (element -> set) -> set -> set list
    val preOrdered: (element -> set) -> element list -> bool
    val preOrderedSCC: (element -> set) -> set list -> bool
    val random: set -> element
    val readIterator: iterator -> element
    val relations: set -> ?.Metis_NameAritySet.S.set
    val remove: set -> element -> set
    type set
    val singleton: element -> set
    val size: set -> int
    val subset: set -> set -> bool
    val subst: Metis_Subst.subst -> set -> set
    val symbols: set -> int
    val symmetricDifference: set -> set -> set
    val toList: set -> element list
    val toString: set -> string
    val transform: (element -> 'a) -> set -> 'a list
    val typedSymbols: set -> int
    val union: set -> set -> set
    val unionList: set list -> set
  end
structure Metis_LiteralSetOrdered:
  sig
    val compare: Metis_LiteralSet.S.set * Metis_LiteralSet.S.set -> order
    type t
  end
structure Metis_LiteralSetMap: Metis_KeyMap
structure Metis_LiteralSetSet: Metis_ElementSet
signature Metis_Thm =
  sig
    val assume: Metis_Literal.literal -> thm
    val axiom: clause -> thm
    val clause: thm -> clause
    type clause
    val compare: thm * thm -> order
    val destUnit: thm -> Metis_Literal.literal
    val destUnitEq: thm -> Metis_Term.term * Metis_Term.term
    val equal: thm -> thm -> bool
    val equality:
       Metis_Literal.literal -> Metis_Term.path -> Metis_Term.term -> thm
    val freeIn: var -> thm -> bool
    val freeVars: thm -> Metis_NameSet.S.set
    val inference: thm -> inference
    type inference = inferenceType * thm list
    datatype inferenceType
    = Assume | Axiom | Equality | Factor | Metis_Subst | Refl | Resolve
    val inferenceTypeToString: inferenceType -> string
    val isContradiction: thm -> bool
    val isTautology: thm -> bool
    val isUnit: thm -> bool
    val isUnitEq: thm -> bool
    val member: Metis_Literal.literal -> thm -> bool
    val negateMember: Metis_Literal.literal -> thm -> bool
    val pp: thm Metis_Print.pp
    val ppInferenceType: inferenceType Metis_Print.pp
    val refl: Metis_Term.term -> thm
    val resolve: Metis_Literal.literal -> thm -> thm -> thm
    val subst: Metis_Subst.subst -> thm -> thm
    type thm
    val toString: thm -> string
  end
signature Metis_Proof =
  sig
    val freeIn: var -> proof -> bool
    val freeVars: proof -> Metis_NameSet.S.set
    datatype inference
    =
         Assume of Metis_Atom.atom
       | Axiom of Metis_LiteralSet.S.set
       | Equality of
           Metis_Literal.literal * Metis_Term.path * Metis_Term.term
       | Metis_Subst of Metis_Subst.subst * ?.Metis_Thm.thm
       | Refl of Metis_Term.term
       | Resolve of Metis_Atom.atom * ?.Metis_Thm.thm * ?.Metis_Thm.thm
    val inferenceToString: inference -> string
    val inferenceToThm: inference -> ?.Metis_Thm.thm
    val inferenceType: inference -> Metis_Thm.inferenceType
    val parents: inference -> ?.Metis_Thm.thm list
    val pp: proof Metis_Print.pp
    val ppInference: inference Metis_Print.pp
    val proof: ?.Metis_Thm.thm -> proof
    type proof = (?.Metis_Thm.thm * inference) list
    val thmToInference: ?.Metis_Thm.thm -> inference
    val toString: proof -> string
  end
signature Metis_Rule =
  sig
    val allArgumentsLiterule: conv -> literule
    val allConv: conv
    val allLiteralsRule: literule -> rule
    val allLiterule: literule
    val allRule: rule
    val argumentLiterule: conv -> int -> literule
    val bottomUpConv: conv -> conv
    val changedRule: rule -> rule
    type conv = Metis_Term.term -> Metis_Term.term * ?.Metis_Thm.thm
    val convRule: conv -> rule
    type equation = (Metis_Term.term * Metis_Term.term) * ?.Metis_Thm.thm
    val equationLiteral: equation -> Metis_Literal.literal option
    val equationToString: equation -> string
    val everyConv: conv list -> conv
    val everyLiterule: literule list -> literule
    val everyRule: rule list -> rule
    val expandAbbrevs: rule
    val factor: ?.Metis_Thm.thm -> ?.Metis_Thm.thm list
    val factor': clause -> Metis_Subst.subst list
    val firstConv: conv list -> conv
    val firstLiterule: literule list -> literule
    val firstRule: rule list -> rule
    val freshVars: rule
    val functionCongruence: Metis_Term.function -> ?.Metis_Thm.thm
    val literalRule: literule -> Metis_Literal.literal -> rule
    val literalsRule: literule -> Metis_LiteralSet.S.set -> rule
    type literule =
       Metis_Literal.literal -> Metis_Literal.literal * ?.Metis_Thm.thm
    val noConv: conv
    val noLiterule: literule
    val noRule: rule
    val orelseConv: conv -> conv -> conv
    val orelseLiterule: literule -> literule -> literule
    val orelseRule: rule -> rule -> rule
    val pathConv: conv -> Metis_Term.path -> conv
    val pathLiterule: conv -> Metis_Term.path -> literule
    val pathRule: conv -> Metis_Literal.literal -> Metis_Term.path -> rule
    val ppEquation: equation Metis_Print.pp
    val reflEqn: Metis_Term.term -> equation
    val reflexivity: ?.Metis_Thm.thm
    val reflexivityRule: Metis_Term.term -> ?.Metis_Thm.thm
    val relationCongruence: Metis_Atom.relation -> ?.Metis_Thm.thm
    val removeIrrefl: rule
    val removeSym: rule
    val repeatConv: conv -> conv
    val repeatLiterule: literule -> literule
    val repeatRule: rule -> rule
    val repeatTopDownConv: conv -> conv
    val rewrConv: equation -> Metis_Term.path -> conv
    val rewrLiterule: equation -> Metis_Term.path -> literule
    val rewrRule:
       equation -> Metis_Literal.literal -> Metis_Term.path -> rule
    type rule = ?.Metis_Thm.thm -> ?.Metis_Thm.thm
    val simplify: ?.Metis_Thm.thm -> ?.Metis_Thm.thm option
    val subtermConv: conv -> int -> conv
    val subtermsConv: conv -> conv
    val sym: Metis_Literal.literal -> rule
    val symEq: Metis_Literal.literal -> rule
    val symEqn: equation -> equation
    val symNeq: Metis_Literal.literal -> rule
    val symmetry: ?.Metis_Thm.thm
    val symmetryRule: Metis_Term.term -> Metis_Term.term -> ?.Metis_Thm.thm
    val thenConv: conv -> conv -> conv
    val thenLiterule: literule -> literule -> literule
    val thenRule: rule -> rule -> rule
    val topDownConv: conv -> conv
    val transEqn: equation -> equation -> equation
    val transitivity: ?.Metis_Thm.thm
    val tryConv: conv -> conv
    val tryLiterule: literule -> literule
    val tryRule: rule -> rule
  end
signature Metis_Normalize =
  sig
    val addCnf: thm -> cnf -> (clause * thm) list * cnf
    val cnf: Metis_Formula.formula -> clause list
    type cnf
    val destThm: thm -> Metis_Formula.formula * inference
    datatype inference
    =
         Axiom of Metis_Formula.formula
       | Clausify of thm
       | Conjunct of thm
       | Definition of string * Metis_Formula.formula
       | Simplify of thm * thm list
       | Skolemize of thm
       | Specialize of thm
    val initialCnf: cnf
    val mkAxiom: Metis_Formula.formula -> thm
    val nnf: Metis_Formula.formula -> Metis_Formula.formula
    val ppInference: inference Metis_Print.pp
    val proveCnf: thm list -> (clause * thm) list
    val proveThms:
       thm list ->
         (Metis_Formula.formula * inference * Metis_Formula.formula list)
         list
    type thm
    val toStringInference: inference -> string
  end
signature Metis_Model =
  sig
    val addName: Metis_Name.name
    val appendName: Metis_Name.name
    val basicFixed: fixed
    val cardName: Metis_Name.name
    val check:
       (model -> valuation -> 'a -> bool) ->
         {maxChecks: int option} ->
           model -> Metis_NameSet.S.set -> 'a -> {F: int, T: int}
    val checkAtom:
       {maxChecks: int option} ->
         model -> Metis_Atom.atom -> {F: int, T: int}
    val checkClause:
       {maxChecks: int option} -> model -> clause -> {F: int, T: int}
    val checkFormula:
       {maxChecks: int option} ->
         model -> Metis_Formula.formula -> {F: int, T: int}
    val checkLiteral:
       {maxChecks: int option} ->
         model -> Metis_Literal.literal -> {F: int, T: int}
    val complementName: Metis_Name.name
    val consName: Metis_Name.name
    val constantValuation: element -> Metis_NameSet.S.set -> valuation
    val default: parameters
    val differenceName: Metis_Name.name
    val divName: Metis_Name.name
    val dividesName: Metis_Name.name
    eqtype element
    val emptyFixed: fixed
    val emptyName: Metis_Name.name
    val emptyValuation: valuation
    val evenName: Metis_Name.name
    val expName: Metis_Name.name
    datatype fixed
    =
         Fixed of
             {functions: fixedFunction Metis_NameArityMap.S.map,
              relations: fixedRelation Metis_NameArityMap.S.map}
    type fixedFunction = size -> element list -> element option
    type fixedMap =
       {functionMap: Metis_Name.name Metis_NameArityMap.S.map,
        relationMap: Metis_Name.name Metis_NameArityMap.S.map}
    type fixedRelation = size -> element list -> bool option
    val foldValuation:
       {size: int} ->
         Metis_NameSet.S.set -> (valuation * 'a -> 'a) -> 'a -> 'a
    val geName: Metis_Name.name
    val getFunctionFixed:
       fixed -> Metis_NameArity.nameArity -> fixedFunction
    val getRelationFixed:
       fixed -> Metis_NameArity.nameArity -> fixedRelation
    val getValuation: valuation -> Metis_Name.name -> element
    val gtName: Metis_Name.name
    val incrementElement: size -> element -> element option
    val incrementValuation:
       {size: int} -> Metis_NameSet.S.set -> valuation -> valuation option
    val insertFunctionFixed:
       fixed -> Metis_NameArity.nameArity * fixedFunction -> fixed
    val insertName: Metis_Name.name
    val insertRelationFixed:
       fixed -> Metis_NameArity.nameArity * fixedRelation -> fixed
    val insertValuation: valuation -> Metis_Name.name * element -> valuation
    val interpretAtom: model -> valuation -> Metis_Atom.atom -> bool
    val interpretClause: model -> valuation -> clause -> bool
    val interpretFormula:
       model -> valuation -> Metis_Formula.formula -> bool
    val interpretFunction: model -> functionName * element list -> element
    val interpretLiteral:
       model -> valuation -> Metis_Literal.literal -> bool
    val interpretRelation: model -> relationName * element list -> bool
    val interpretTerm: model -> valuation -> Metis_Term.term -> element
    val intersectName: Metis_Name.name
    val isZeroName: Metis_Name.name
    val leName: Metis_Name.name
    val lengthName: Metis_Name.name
    val listFixed: fixed
    val ltName: Metis_Name.name
    val mapFixed: fixedMap -> fixed -> fixed
    val memberName: Metis_Name.name
    val modName: Metis_Name.name
    type model
    val modularFixed: fixed
    val multName: Metis_Name.name
    val negName: Metis_Name.name
    val new: parameters -> model
    val nilName: Metis_Name.name
    val nullName: Metis_Name.name
    val numeralMax: int
    val numeralMin: int
    val numeralName: int -> Metis_Name.name
    val oddName: Metis_Name.name
    val overflowFixed: fixed
    type parameters = {fixed: fixed, size: int}
    val peekValuation: valuation -> Metis_Name.name -> element option
    val perturbAtom: model -> valuation -> Metis_Atom.atom * bool -> unit
    val perturbClause: model -> valuation -> clause -> unit
    val perturbLiteral: model -> valuation -> Metis_Literal.literal -> unit
    val perturbTerm:
       model -> valuation -> Metis_Term.term * element list -> unit
    val pp: model Metis_Print.pp
    val ppFixedMap: fixedMap Metis_Print.pp
    val preName: Metis_Name.name
    val projectionFixed: fixed
    val projectionMax: int
    val projectionMin: int
    val projectionName: int -> Metis_Name.name
    val randomValuation: {size: int} -> Metis_NameSet.S.set -> valuation
    val setFixed: fixed
    val singletonName: Metis_Name.name
    val size: model -> int
    type size = {size: int}
    val subName: Metis_Name.name
    val subsetName: Metis_Name.name
    val sucName: Metis_Name.name
    val symmetricDifferenceName: Metis_Name.name
    val tailName: Metis_Name.name
    val unionFixed: fixed -> fixed -> fixed
    val unionListFixed: fixed list -> fixed
    val unionName: Metis_Name.name
    val universeName: Metis_Name.name
    val updateFunction:
       model -> (functionName * element list) * element -> unit
    val updateRelation:
       model -> (relationName * element list) * bool -> unit
    type valuation
    val zeroElement: element
    val zeroValuation: Metis_NameSet.S.set -> valuation
  end
signature Metis_Problem =
  sig
    val categorize: problem -> category
    type category =
       {equality: equality, horn: horn, propositional: propositional}
    val categoryToString: category -> string
    datatype equality = Equality | NonEquality | PureEquality
    val freeVars: problem -> Metis_NameSet.S.set
    datatype horn
    = DoubleHorn | Horn | NegativeHorn | NonHorn | Trivial | Unit
    type problem = {axioms: clause list, conjecture: clause list}
    datatype propositional
    = EffectivelyPropositional | NonPropositional | Propositional
    val size:
       problem ->
         {clauses: int, literals: int, symbols: int, typedSymbols: int}
    val toClauses: problem -> clause list
    val toFormula: problem -> Metis_Formula.formula
    val toGoal: problem -> Metis_Formula.formula
    val toString: problem -> string
  end
signature Metis_TermNet =
  sig
    val filter: ('a -> bool) -> 'a termNet -> 'a termNet
    val fromList: parameters -> (Metis_Term.term * 'a) list -> 'a termNet
    val insert: 'a termNet -> Metis_Term.term * 'a -> 'a termNet
    val match: 'a termNet -> Metis_Term.term -> 'a list
    val matched: 'a termNet -> Metis_Term.term -> 'a list
    val new: parameters -> 'a termNet
    val null: 'a termNet -> bool
    type parameters = {fifo: bool}
    val pp: 'a Metis_Print.pp -> 'a termNet Metis_Print.pp
    val size: 'a termNet -> int
    type 'a termNet
    val toString: 'a termNet -> string
    val unify: 'a termNet -> Metis_Term.term -> 'a list
  end
signature Metis_AtomNet =
  sig
    type 'a atomNet
    val filter: ('a -> bool) -> 'a atomNet -> 'a atomNet
    val fromList: parameters -> (Metis_Atom.atom * 'a) list -> 'a atomNet
    val insert: 'a atomNet -> Metis_Atom.atom * 'a -> 'a atomNet
    val match: 'a atomNet -> Metis_Atom.atom -> 'a list
    val matched: 'a atomNet -> Metis_Atom.atom -> 'a list
    val new: parameters -> 'a atomNet
    type parameters = {fifo: bool}
    val pp: 'a Metis_Print.pp -> 'a atomNet Metis_Print.pp
    val size: 'a atomNet -> int
    val toString: 'a atomNet -> string
    val unify: 'a atomNet -> Metis_Atom.atom -> 'a list
  end
signature Metis_LiteralNet =
  sig
    val filter: ('a -> bool) -> 'a literalNet -> 'a literalNet
    val fromList:
       parameters -> (Metis_Literal.literal * 'a) list -> 'a literalNet
    val insert: 'a literalNet -> Metis_Literal.literal * 'a -> 'a literalNet
    type 'a literalNet
    val match: 'a literalNet -> Metis_Literal.literal -> 'a list
    val matched: 'a literalNet -> Metis_Literal.literal -> 'a list
    val new: parameters -> 'a literalNet
    type parameters = {fifo: bool}
    val pp: 'a Metis_Print.pp -> 'a literalNet Metis_Print.pp
    val profile: 'a literalNet -> {negative: int, positive: int}
    val size: 'a literalNet -> int
    val toString: 'a literalNet -> string
    val unify: 'a literalNet -> Metis_Literal.literal -> 'a list
  end
signature Metis_Subsume =
  sig
    val clauseStrictlySubsumes: clause -> clause -> Metis_Subst.subst option
    val clauseSubsumes: clause -> clause -> Metis_Subst.subst option
    val filter: ('a -> bool) -> 'a subsume -> 'a subsume
    val insert: 'a subsume -> clause * 'a -> 'a subsume
    val isStrictlySubsumed: 'a subsume -> clause -> bool
    val isSubsumed: 'a subsume -> clause -> bool
    val new: unit -> 'a subsume
    val pp: 'a subsume Metis_Print.pp
    val size: 'a subsume -> int
    val strictlySubsumes:
       (clause * Metis_Subst.subst * 'a -> bool) ->
         'a subsume -> clause -> (clause * Metis_Subst.subst * 'a) option
    type 'a subsume
    val subsumes:
       (clause * Metis_Subst.subst * 'a -> bool) ->
         'a subsume -> clause -> (clause * Metis_Subst.subst * 'a) option
    val toString: 'a subsume -> string
  end
signature Metis_KnuthBendixOrder =
  sig
    val compare: kbo -> Metis_Term.term * Metis_Term.term -> order option
    val default: kbo
    type kbo =
       {precedence: Metis_Term.function * Metis_Term.function -> order,
        weight: Metis_Term.function -> int}
  end
signature Metis_Rewrite =
  sig
    val add: rewrite -> equationId * equation -> rewrite
    val addList: rewrite -> (equationId * equation) list -> rewrite
    type equation = ?.Metis_Rule.equation
    eqtype equationId
    val equations: rewrite -> equation list
    val isReduced: rewrite -> bool
    val new: reductionOrder -> rewrite
    val orderedRewrite:
       reductionOrder -> equation list -> ?.Metis_Thm.thm -> ?.Metis_Thm.thm
    datatype orient = LeftToRight | RightToLeft
    val peek: rewrite -> equationId -> (equation * orient option) option
    val pp: rewrite Metis_Print.pp
    val ppOrient: orient Metis_Print.pp
    val ppOrientOption: orient option Metis_Print.pp
    val reduce: rewrite -> rewrite
    val reduce': rewrite -> rewrite * equationId list
    type reductionOrder = Metis_Term.term * Metis_Term.term -> order option
    val rewrConv: rewrite -> reductionOrder -> ?.Metis_Rule.conv
    val rewrIdConv:
       rewrite -> reductionOrder -> equationId -> ?.Metis_Rule.conv
    val rewrite: equation list -> ?.Metis_Thm.thm -> ?.Metis_Thm.thm
    type rewrite
    val rewriteConv: rewrite -> reductionOrder -> ?.Metis_Rule.conv
    val rewriteIdConv:
       rewrite -> reductionOrder -> equationId -> ?.Metis_Rule.conv
    val rewriteIdLiteralsRule:
       rewrite ->
         reductionOrder ->
           equationId -> Metis_LiteralSet.S.set -> Metis_Rule.rule
    val rewriteIdRule:
       rewrite -> reductionOrder -> equationId -> Metis_Rule.rule
    val rewriteLiteralsRule:
       rewrite ->
         reductionOrder -> Metis_LiteralSet.S.set -> Metis_Rule.rule
    val rewriteRule: rewrite -> reductionOrder -> Metis_Rule.rule
    val size: rewrite -> int
    val toString: rewrite -> string
    val toStringOrient: orient -> string
    val toStringOrientOption: orient option -> string
  end
signature Metis_Units =
  sig
    val add: units -> unitThm -> units
    val addList: units -> unitThm list -> units
    val empty: units
    val match:
       units ->
         Metis_Literal.literal -> (unitThm * Metis_Subst.subst) option
    val pp: units Metis_Print.pp
    val reduce: units -> Metis_Rule.rule
    val size: units -> int
    val toString: units -> string
    type unitThm = Metis_Literal.literal * ?.Metis_Thm.thm
    type units
  end
signature Metis_Clause =
  sig
    val allSubterms:
       clause ->
         (Metis_Literal.literal * Metis_Term.path * Metis_Term.term) list
    type clause
    eqtype clauseId
    type clauseInfo =
       {id: clauseId, parameters: parameters, thm: ?.Metis_Thm.thm}
    val default: parameters
    val dest: clause -> clauseInfo
    val equalThms: clause -> clause -> bool
    val factor: clause -> clause list
    val freshVars: clause -> clause
    val id: clause -> clauseId
    val isContradiction: clause -> bool
    val isTautology: clause -> bool
    val largestEquations:
       clause ->
         (Metis_Literal.literal * Metis_Rewrite.orient * Metis_Term.term)
         list
    val largestLiterals: clause -> Metis_LiteralSet.S.set
    val largestSubterms:
       clause ->
         (Metis_Literal.literal * Metis_Term.path * Metis_Term.term) list
    datatype literalOrder
    = NoLiteralOrder | PositiveLiteralOrder | UnsignedLiteralOrder
    val literals: clause -> ?.clause
    val mk: clauseInfo -> clause
    val newId: unit -> clauseId
    type parameters =
       {orderLiterals: literalOrder,
        orderTerms: bool, ordering: Metis_KnuthBendixOrder.kbo}
    val paramodulate:
       clause * Metis_Literal.literal * Metis_Rewrite.orient *
       Metis_Term.term
         ->
         clause * Metis_Literal.literal * Metis_Term.path * Metis_Term.term
           -> clause
    val pp: clause Metis_Print.pp
    val reduce: Metis_Units.units -> clause -> clause
    val resolve:
       clause * Metis_Literal.literal ->
         clause * Metis_Literal.literal -> clause
    val rewrite: Metis_Rewrite.rewrite -> clause -> clause
    val showId: bool ref
    val simplify: clause -> clause option
    val subsumes: clause Metis_Subsume.subsume -> clause -> bool
    val thm: clause -> ?.Metis_Thm.thm
    val toString: clause -> string
  end
signature Metis_Active =
  sig
    type active
    val add:
       active -> Metis_Clause.clause -> active * Metis_Clause.clause list
    val default: parameters
    val new:
       parameters ->
         {axioms: ?.Metis_Thm.thm list, conjecture: ?.Metis_Thm.thm list} ->
           active *
           {axioms: Metis_Clause.clause list,
            conjecture: Metis_Clause.clause list}
    type parameters =
       {clause: ?.Metis_Clause.parameters,
        postfactor: simplify, prefactor: simplify}
    val pp: active Metis_Print.pp
    val saturation: active -> Metis_Clause.clause list
    type simplify = {reduce: bool, rewrite: bool, subsume: bool}
    val size: active -> int
  end
signature Metis_Waiting =
  sig
    val add: waiting -> distance * Metis_Clause.clause list -> waiting
    val default: parameters
    type distance
    type modelParameters =
       {initialPerturbations: int,
        maxChecks: int option,
        model: ?.Metis_Model.parameters, perturbations: int, weight: weight}
    val new:
       parameters ->
         {axioms: Metis_Clause.clause list,
          conjecture: Metis_Clause.clause list}
           -> waiting
    type parameters =
       {literalsWeight: weight,
        models: modelParameters list,
        symbolsWeight: weight, variablesWeight: weight}
    val pp: waiting Metis_Print.pp
    val remove:
       waiting -> ((distance * Metis_Clause.clause) * waiting) option
    val size: waiting -> int
    type waiting
    type weight
  end
signature Metis_Resolution =
  sig
    val active: resolution -> Metis_Active.active
    datatype decision
    = Contradiction of ?.Metis_Thm.thm | Satisfiable of ?.Metis_Thm.thm list
    val default: parameters
    val iterate: resolution -> state
    val loop: resolution -> decision
    val new:
       parameters ->
         {axioms: ?.Metis_Thm.thm list, conjecture: ?.Metis_Thm.thm list} ->
           resolution
    type parameters =
       {active: ?.Metis_Active.parameters,
        waiting: ?.Metis_Waiting.parameters}
    val pp: resolution Metis_Print.pp
    type resolution
    datatype state = Decided of decision | Undecided of resolution
    val waiting: resolution -> Metis_Waiting.waiting
  end
structure Metis_Thm: Metis_Thm
structure Metis_Proof: Metis_Proof
structure Metis_Rule: Metis_Rule
structure Metis_Normalize: Metis_Normalize
structure Metis_Model: Metis_Model
structure Metis_Problem: Metis_Problem
structure Metis_TermNet: Metis_TermNet
structure Metis_AtomNet: Metis_AtomNet
structure Metis_LiteralNet: Metis_LiteralNet
structure Metis_Subsume: Metis_Subsume
structure Metis_KnuthBendixOrder: Metis_KnuthBendixOrder
structure Metis_Rewrite: Metis_Rewrite
structure Metis_Units: Metis_Units
structure Metis_Clause: Metis_Clause
structure Metis_Active: Metis_Active
structure Metis_Waiting: Metis_Waiting
structure Metis_Resolution: Metis_Resolution
instantiation
  fun :: (type, complete_distrib_lattice) complete_distrib_lattice
### ML warning (line 137 of "~~/src/HOL/Tools/Metis/metis_generate.ML"):
### Matches are not exhaustive.
signature METIS_GENERATE =
  sig
    val generate_metis_problem:
       Proof.context ->
         type_enc ->
           string ->
             thm list ->
               thm list ->
                 int Symtab.table * (Metis_Thm.thm * isa_thm) list *
                 (unit -> (string * int) list) *
                 ((string * term) list * (string * term) list)
    datatype isa_thm
    = Isa_Lambda_Lifted | Isa_Raw of thm | Isa_Reflexive_or_Trivial
    val metis_ad_hoc_type_tag: string
    val metis_app_op: string
    val metis_equal: string
    val metis_generated_var_prefix: string
    val metis_name_table:
       ((string * int) * ((type_enc -> string) * bool)) list
    val metis_predicator: string
    val metis_systematic_type_tag: string
    val reveal_lam_lifted: (string * term) list -> term -> term
    val reveal_old_skolem_terms: (string * term) list -> term -> term
    val trace: bool Config.T
    val trace_msg: Proof.context -> (unit -> string) -> unit
    eqtype type_enc
    val verbose: bool Config.T
    val verbose_warning: Proof.context -> string -> unit
  end
structure Metis_Generate: METIS_GENERATE
### theory "HOL.Hilbert_Choice"
### 0.600s elapsed time, 1.960s cpu time, 0.226s GC time
Loading theory "HOL.BNF_Wellorder_Embedding" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation" via "HOL.BNF_Wellorder_Constructions")
Loading theory "HOL.Zorn" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation")
locale pred_on
  fixes A :: "'a set"
    and P :: "'a => 'a => bool"  (infix \<open>\<sqsubset>\<close> 50)
Proofs for inductive predicate(s) "suc_Union_closedp"
  Proving monotonicity ...
### ML warning (line 192 of "~~/src/HOL/Tools/Metis/metis_reconstruct.ML"):
### Pattern is not exhaustive.
### ML warning (line 207 of "~~/src/HOL/Tools/Metis/metis_reconstruct.ML"):
### Matches are not exhaustive.
### ML warning (line 319 of "~~/src/HOL/Tools/Metis/metis_reconstruct.ML"):
### Pattern is not exhaustive.
### ML warning (line 321 of "~~/src/HOL/Tools/Metis/metis_reconstruct.ML"):
### Matches are not exhaustive.
signature METIS_RECONSTRUCT =
  sig
    exception METIS_RECONSTRUCT of string * string
    val discharge_skolem_premises:
       Proof.context -> (thm * term) option list -> thm -> thm
    val hol_clause_of_metis:
       Proof.context ->
         type_enc ->
           int Symtab.table ->
             (string * term) list * (string * term) list ->
               Metis_Thm.thm -> term
    val lookth: (Metis_Thm.thm * 'a) list -> Metis_Thm.thm -> 'a
    val replay_one_inference:
       Proof.context ->
         type_enc ->
           (string * term) list * (string * term) list ->
             int Symtab.table ->
               Metis_Thm.thm * Metis_Proof.inference ->
                 (Metis_Thm.thm * thm) list -> (Metis_Thm.thm * thm) list
    eqtype type_enc
  end
structure Metis_Reconstruct: METIS_RECONSTRUCT
### theory "HOL.BNF_Wellorder_Embedding"
### 0.298s elapsed time, 0.915s cpu time, 0.099s GC time
Loading theory "HOL.BNF_Wellorder_Constructions" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic" via "HOL.BNF_Cardinal_Order_Relation")
### ML warning (line 102 of "~~/src/HOL/Tools/Metis/metis_tactic.ML"):
### Pattern is not exhaustive.
### ML warning (line 168 of "~~/src/HOL/Tools/Metis/metis_tactic.ML"):
### Pattern is not exhaustive.
signature METIS_TACTIC =
  sig
    val advisory_simp: bool Config.T
    val metis_lam_transs: string list
    val metis_method:
       (string list option * string option) * thm list ->
         Proof.context -> thm list -> tactic
    val metis_tac:
       string list -> string -> Proof.context -> thm list -> int -> tactic
    val metis_tac_unused:
       string list ->
         string ->
           Proof.context -> thm list -> int -> thm -> thm list * thm Seq.seq
    val new_skolem: bool Config.T
    val parse_metis_options: (string list option * string option) parser
    val trace: bool Config.T
    val verbose: bool Config.T
  end
structure Metis_Tactic: METIS_TACTIC
### theory "HOL.Metis"
### 5.578s elapsed time, 13.529s cpu time, 3.207s GC time
### theory "HOL.Zorn"
### 0.417s elapsed time, 1.186s cpu time, 0.099s GC time
### theory "HOL.BNF_Wellorder_Constructions"
### 0.392s elapsed time, 0.618s cpu time, 0.142s GC time
Loading theory "HOL.BNF_Cardinal_Order_Relation" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def" via "HOL.BNF_Cardinal_Arithmetic")
### theory "HOL.BNF_Cardinal_Order_Relation"
### 0.378s elapsed time, 0.378s cpu time, 0.000s GC time
Loading theory "HOL.BNF_Cardinal_Arithmetic" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition" via "HOL.BNF_Def")
### theory "HOL.BNF_Cardinal_Arithmetic"
### 0.281s elapsed time, 0.422s cpu time, 0.189s GC time
Loading theory "HOL.BNF_Def" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base" via "HOL.BNF_Composition")
Proofs for inductive predicate(s) "rel_sum"
  Proving monotonicity ...
### ML warning (line 131 of "~~/src/HOL/Tools/BNF/bnf_util.ML"):
### Matches are not exhaustive.
### ML warning (line 351 of "~~/src/HOL/Tools/BNF/bnf_util.ML"):
### Pattern is not exhaustive.
signature BNF_UTIL =
  sig
    val CONJ_WRAP: ('a -> tactic) -> 'a list -> tactic
    val CONJ_WRAP': ('a -> int -> tactic) -> 'a list -> int -> tactic
    val CONJ_WRAP_GEN: tactic -> ('a -> tactic) -> 'a list -> tactic
    val CONJ_WRAP_GEN':
       (int -> tactic) -> ('a -> int -> tactic) -> 'a list -> int -> tactic
    val Id_const: typ -> term
    val WRAP:
       ('a -> tactic) -> ('a -> tactic) -> 'a list -> tactic -> tactic
    val WRAP':
       ('a -> int -> tactic) ->
         ('a -> int -> tactic) ->
           'a list -> (int -> tactic) -> int -> tactic
    val base_name_of_typ: typ -> string
    val binder_fun_types: typ -> typ list
    val body_fun_type: typ -> typ
    val case_fp: fp_kind -> 'a -> 'a -> 'a
    val check_all_fun_arg_frees:
       Proof.context -> term list -> term list -> unit
    val check_duplicate_const_names: binding list -> unit
    val check_duplicate_variables_in_lhs:
       Proof.context -> term list -> term list -> unit
    val check_top_sort: Proof.context -> binding -> typ -> unit
    val conj_dests: int -> thm -> thm list
    val ctrans: thm
    val ctwo: term
    val dest_TFree_or_TVar: typ -> string * sort
    val dest_pred2T: typ -> typ * typ
    val dest_relT: typ -> typ * typ
    val drop_all: term -> term
    val dtac: Proof.context -> thm -> int -> tactic
    val enforce_type: Proof.context -> (typ -> typ) -> typ -> term -> term
    val eqFalseI: thm
    val eqTrueI: thm
    val error_at: Proof.context -> term list -> string -> 'a
    val etac: Proof.context -> thm -> int -> tactic
    val excess_equations: Proof.context -> term list -> 'a
    val exists_strict_subtype_in: typ list -> typ -> bool
    val exists_subtype_in: typ list -> typ -> bool
    val extra_variable_in_rhs: Proof.context -> term list -> term -> 'a
    val find_index_eq: ''a list -> ''a -> int
    val find_indices: ('a * 'b -> bool) -> 'b list -> 'a list -> int list
    val finds:
       ('a * 'b -> bool) ->
         'a list -> 'b list -> ('a * 'b list) list * 'b list
    val flat_rec_arg_args: 'a list list -> 'a list
    val fo_match: Proof.context -> term -> term -> Type.tyenv * Envir.tenv
    datatype fp_kind = Greatest_FP | Least_FP
    type fp_rec_sugar =
       {fpTs: typ list,
        fun_defs: thm list,
        fun_names: string list, funs: term list, transfers: bool list}
    val fst_const: typ -> term
    val id_apply: thm
    val ill_formed_corec_call: Proof.context -> term -> 'a
    val ill_formed_equation: Proof.context -> term -> 'a
    val ill_formed_equation_head: Proof.context -> term list -> 'a
    val ill_formed_equation_lhs_rhs: Proof.context -> term list -> 'a
    val ill_formed_formula: Proof.context -> term -> 'a
    val ill_formed_rec_call: Proof.context -> term -> 'a
    val inconstant_pattern_pos_for_fun:
       Proof.context -> term list -> string -> 'a
    val indexed: 'a list -> int -> int list * int
    val indexedd: 'a list list -> int -> int list list * int
    val indexeddd: 'a list list list -> int -> int list list list * int
    val indexedddd:
       'a list list list list -> int -> int list list list list * int
    val invalid_map: Proof.context -> term list -> term -> 'a
    val is_concl_refl: thm -> bool
    val is_refl: thm -> bool
    val is_refl_bool: term -> bool
    val lhs_head_of: thm -> term
    val list_all_free: term list -> term -> term
    val list_exists_free: term list -> term -> term
    val map_prod: ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val meta_mp: thm
    val meta_spec: thm
    val missing_args_to_fun_on_lhs: Proof.context -> term list -> 'a
    val missing_equations_for_const: string -> 'a
    val missing_equations_for_fun: string -> 'a
    val missing_pattern: Proof.context -> term list -> 'a
    val mk_Ball: term -> term -> term
    val mk_Bex: term -> term -> term
    val mk_Card_order: term -> term
    val mk_Field: term -> term
    val mk_Frees:
       string -> typ list -> Proof.context -> term list * Proof.context
    val mk_Frees':
       string ->
         typ list ->
           Proof.context ->
             (term list * (string * typ) list) * Proof.context
    val mk_Freess:
       string ->
         typ list list -> Proof.context -> term list list * Proof.context
    val mk_Freess':
       string ->
         typ list list ->
           Proof.context ->
             (term list list * (string * typ) list list) * Proof.context
    val mk_Freesss:
       string ->
         typ list list list ->
           Proof.context -> term list list list * Proof.context
    val mk_Freessss:
       string ->
         typ list list list list ->
           Proof.context -> term list list list list * Proof.context
    val mk_Gr: term -> term -> term
    val mk_Grp: term -> term -> term
    val mk_IfN: typ -> term list -> term list -> term
    val mk_TFrees: int -> Proof.context -> typ list * Proof.context
    val mk_TFrees': sort list -> Proof.context -> typ list * Proof.context
    val mk_TFreess:
       int list -> Proof.context -> typ list list * Proof.context
    val mk_Trueprop_eq: term * term -> term
    val mk_Trueprop_mem: term * term -> term
    val mk_UNION: term -> term -> term
    val mk_UnIN: int -> int -> thm
    val mk_Un_upper: int -> int -> thm
    val mk_Union: typ -> term
    val mk_abs_def: thm -> thm
    val mk_card_binop: string -> (typ * typ -> typ) -> term -> term -> term
    val mk_card_of: term -> term
    val mk_card_order: term -> term
    val mk_cexp: term -> term -> term
    val mk_cinfinite: term -> term
    val mk_co_rec: theory -> fp_kind -> typ list -> typ -> term -> term
    val mk_collect: term list -> typ -> term
    val mk_common_name: string list -> string
    val mk_comp: typ list -> term * term -> term
    val mk_compN: int -> typ list -> term * term -> term
    val mk_conjIN: int -> thm
    val mk_conjunctN: int -> int -> thm
    val mk_converse: term -> term
    val mk_conversep: term -> term
    val mk_cprod: term -> term -> term
    val mk_csum: term -> term -> term
    val mk_dir_image: term -> term -> term
    val mk_disjIN: int -> int -> thm
    val mk_eq_onp: term -> term
    val mk_fresh_names:
       Proof.context -> int -> string -> string list * Proof.context
    val mk_image: term -> term
    val mk_in: term list -> term list -> typ -> term
    val mk_inj: term -> term
    val mk_leq: term -> term -> term
    val mk_names: int -> string -> string list
    val mk_nthI: int -> int -> thm
    val mk_nthN: int -> term -> int -> term
    val mk_nth_conv: int -> int -> thm
    val mk_ordLeq: term -> term -> term
    val mk_ordLeq_csum: int -> int -> thm -> thm
    val mk_partial_compN: int -> typ -> term -> term
    val mk_pointful: Proof.context -> thm -> thm
    val mk_pred1T: typ -> typ
    val mk_pred2T: typ -> typ -> typ
    val mk_predT: typ list -> typ
    val mk_reflp: term -> term
    val mk_relT: typ * typ -> typ
    val mk_rel_comp: term * term -> term
    val mk_rel_compp: term * term -> term
    val mk_rel_fun: term -> term -> term
    val mk_rel_funDN: int -> thm -> thm
    val mk_rel_funDN_rotated: int -> thm -> thm
    val mk_sumT: typ * typ -> typ
    val mk_sym: thm -> thm
    val mk_symp: term -> term
    val mk_trans: thm -> thm -> thm
    val mk_transp: term -> term
    val mk_unabs_def: int -> thm -> thm
    val mk_union: term * term -> term
    val mk_vimage2p: term -> term -> term
    val more_than_one_nonvar_in_lhs: Proof.context -> term list -> 'a
    val morph_fp_rec_sugar: morphism -> fp_rec_sugar -> fp_rec_sugar
    val multiple_equations_for_ctr: Proof.context -> term list -> 'a
    val name_noted_thms:
       string ->
         string -> (string * thm list) list -> (string * thm list) list
    val name_of_const: string -> (typ -> typ) -> term -> string
    val no_equation_for_ctr_warning:
       Proof.context -> term list -> term -> unit
    val no_refl: thm list -> thm list
    val no_reflexive: thm list -> thm list
    val nonprimitive_corec: Proof.context -> term list -> 'a
    val nonprimitive_pattern_in_lhs: Proof.context -> term list -> 'a
    val nonzero_string_of_int: int -> string
    val not_codatatype: Proof.context -> typ -> 'a
    val not_constructor_in_pattern: Proof.context -> term list -> term -> 'a
    val not_constructor_in_rhs: Proof.context -> term list -> term -> 'a
    val not_datatype: Proof.context -> typ -> 'a
    val num_binder_types: typ -> int
    val o_apply: thm
    val order_strong_conn:
       ('a * 'a -> bool) ->
         ((('a * unit) * 'a list) list -> 'b) ->
           ('b -> 'a list) ->
             ('a * 'a list) list -> 'a list list -> 'a list list
    val pad_list: 'a -> int -> 'a list -> 'a list
    val parse_binding_colon: binding parser
    val parse_map_rel_pred_bindings: (binding * binding * binding) parser
    val parse_opt_binding_colon: binding parser
    val parse_type_args_named_constrained:
       (binding option * (string * string option)) list parser
    val partially_applied_ctr_in_pattern: Proof.context -> term list -> 'a
    val partially_applied_ctr_in_rhs: Proof.context -> term list -> 'a
    val permute_args: int -> term -> term
    val permute_like:
       ('a * 'a -> bool) -> 'a list -> 'a list -> 'b list -> 'b list
    val permute_like_unique:
       ('a * 'b -> bool) -> 'a list -> 'b list -> 'c list -> 'c list
    val print_def_consts:
       bool -> (term * (string * thm)) list -> Proof.context -> unit
    val prod_injectD: thm
    val prod_injectI: thm
    val rapp: term -> term -> term
    val rec_call_not_apply_to_ctr_arg:
       Proof.context -> term list -> term -> 'a
    val rel_funD: thm
    val rel_funI: thm
    val resort_tfree_or_tvar: sort -> typ -> typ
    val retype_const_or_free: typ -> term -> term
    val rtac: Proof.context -> thm -> int -> tactic
    val seq_conds: (bool -> 'a -> 'b) -> int -> int -> 'a list -> 'b list
    val set_mp: thm
    val set_rev_mp: thm
    val snd_const: typ -> term
    val splice: 'a list -> 'a list -> 'a list
    val ss_only: thm list -> Proof.context -> Proof.context
    val standard_binding: binding
    val strip_fun_type: typ -> typ list * typ
    val strip_typeN: int -> typ -> typ list * typ
    val subset_UNIV: thm
    val subst_nonatomic_types: (typ * typ) list -> term -> term
    val substitute_noted_thm: (string * thm list) list -> morphism
    val too_few_args_in_rec_call: Proof.context -> term list -> term -> 'a
    val transfer_fp_rec_sugar: theory -> fp_rec_sugar -> fp_rec_sugar
    val transfer_plugin: string
    val transpose: 'a list list -> 'a list list
    val tvar_subst:
       theory -> typ list -> typ list -> ((string * int) * typ) list
    val typ_subst_nonatomic: (typ * typ) list -> typ -> typ
    val typedef:
       binding * (string * sort) list * mixfix ->
         term ->
           (binding * binding) option ->
             (Proof.context -> tactic) ->
               local_theory -> (string * Typedef.info) * local_theory
    val unexpected_corec_call_in: Proof.context -> term list -> term -> 'a
    val unexpected_rec_call_in: Proof.context -> term list -> term -> 'a
    val unflatt: 'a list list list -> 'b list -> 'b list list list
    val unflattt:
       'a list list list list -> 'b list -> 'b list list list list
    val unfold_thms: Proof.context -> thm list -> thm -> thm
    val unsupported_case_around_corec_call:
       Proof.context -> term list -> term -> 'a
    val variant_tfrees:
       string list -> Proof.context -> typ list * Proof.context
    val variant_types:
       string list ->
         sort list -> Proof.context -> (string * sort) list * Proof.context
    val warning_at: Proof.context -> term list -> string -> unit
  end
structure BNF_Util: BNF_UTIL
signature BNF_TACTICS =
  sig
    val clean_blast_tac: Proof.context -> int -> tactic
    val fo_rtac: Proof.context -> thm -> int -> tactic
    val mk_Abs_bij_thm: Proof.context -> thm -> thm -> thm
    val mk_Abs_inj_thm: thm -> thm
    val mk_map_comp_id_tac: Proof.context -> thm -> tactic
    val mk_map_cong0L_tac: Proof.context -> int -> thm -> thm -> tactic
    val mk_map_cong0_tac: Proof.context -> int -> thm -> tactic
    val mk_pointfree2: Proof.context -> thm -> thm
    val mk_rotate_eq_tac:
       Proof.context ->
         (int -> tactic) ->
           thm -> thm -> thm -> thm -> ''a list -> ''a list -> int -> tactic
    val select_prem_tac:
       Proof.context -> int -> (int -> tactic) -> int -> int -> tactic
    val subst_asm_tac:
       Proof.context -> int list option -> thm list -> int -> tactic
    val subst_tac:
       Proof.context -> int list option -> thm list -> int -> tactic
    val unfold_thms_tac: Proof.context -> thm list -> tactic
  end
structure BNF_Tactics: BNF_TACTICS
signature BNF_DEF_TACTICS =
  sig
    val mk_collect_set_map_tac: Proof.context -> thm list -> tactic
    val mk_in_bd_tac:
       Proof.context ->
         int ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm list ->
                     thm list -> thm -> thm -> thm -> thm -> tactic
    val mk_in_mono_tac: Proof.context -> int -> tactic
    val mk_inj_map_strong_tac:
       Proof.context -> thm -> thm list -> thm -> tactic
    val mk_inj_map_tac:
       Proof.context -> int -> thm -> thm -> thm -> thm -> tactic
    val mk_map_comp: thm -> thm
    val mk_map_cong_tac: Proof.context -> thm -> tactic
    val mk_map_id: thm -> thm
    val mk_map_ident: Proof.context -> thm -> thm
    val mk_map_transfer_tac:
       Proof.context -> thm -> thm -> thm list -> thm -> thm -> tactic
    val mk_pred_mono_strong0_tac: Proof.context -> thm -> thm -> tactic
    val mk_pred_mono_tac: Proof.context -> thm -> thm -> tactic
    val mk_pred_transfer_tac:
       Proof.context -> int -> thm -> thm -> thm -> tactic
    val mk_rel_Grp_tac:
       Proof.context ->
         thm list -> thm -> thm -> thm -> thm -> thm list -> tactic
    val mk_rel_OO_le_tac:
       Proof.context -> thm list -> thm -> thm -> thm -> thm list -> tactic
    val mk_rel_cong_tac:
       Proof.context -> thm list * thm list -> thm -> tactic
    val mk_rel_conversep_le_tac:
       Proof.context -> thm list -> thm -> thm -> thm -> thm list -> tactic
    val mk_rel_conversep_tac: Proof.context -> thm -> thm -> tactic
    val mk_rel_eq_onp_tac: Proof.context -> thm -> thm -> thm -> tactic
    val mk_rel_eq_tac: Proof.context -> int -> thm -> thm -> thm -> tactic
    val mk_rel_map0_tac:
       Proof.context -> int -> thm -> thm -> thm -> thm -> tactic
    val mk_rel_mono_strong0_tac: Proof.context -> thm -> thm list -> tactic
    val mk_rel_mono_tac: Proof.context -> thm list -> thm -> tactic
    val mk_rel_transfer_tac:
       Proof.context -> thm -> thm list -> thm -> tactic
    val mk_set_map: thm -> thm
    val mk_set_transfer_tac: Proof.context -> thm -> thm list -> tactic
    val mk_trivial_wit_tac: Proof.context -> thm list -> thm list -> tactic
  end
structure BNF_Def_Tactics: BNF_DEF_TACTICS
### ML warning (line 520 of "~~/src/HOL/Tools/BNF/bnf_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 732 of "~~/src/HOL/Tools/BNF/bnf_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 737 of "~~/src/HOL/Tools/BNF/bnf_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 743 of "~~/src/HOL/Tools/BNF/bnf_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 798 of "~~/src/HOL/Tools/BNF/bnf_def.ML"):
### Pattern is not exhaustive.
signature BNF_DEF =
  sig
    val T_of_bnf: bnf -> typ
    val bd_Card_order_of_bnf: bnf -> thm
    val bd_Cinfinite_of_bnf: bnf -> thm
    val bd_Cnotzero_of_bnf: bnf -> thm
    val bd_card_order_of_bnf: bnf -> thm
    val bd_cinfinite_of_bnf: bnf -> thm
    val bd_of_bnf: bnf -> term
    type bnf
    val bnf_cmd:
       (((((((binding * string) * string) * string list) * string) *
          string list)
         *
         string option)
        *
        string option)
       *
       (Proof.context -> Plugin_Name.filter)
         -> Proof.context -> Proof.state
    val bnf_def:
       inline_policy ->
         (Proof.context -> fact_policy) ->
           bool ->
             (binding -> binding) ->
               (Proof.context -> tactic) list ->
                 (Proof.context -> tactic) ->
                   typ list option ->
                     binding ->
                       binding ->
                         binding ->
                           binding list ->
                             ((((((binding * typ) * term) * term list) *
                                term)
                               *
                               term list)
                              *
                              term option)
                             *
                             term option
                               -> local_theory -> bnf * local_theory
    val bnf_internals: bool Config.T
    val bnf_interpretation:
       string -> (bnf -> local_theory -> local_theory) -> theory -> theory
    val bnf_of: Proof.context -> string -> bnf option
    val bnf_of_global: theory -> string -> bnf option
    val bnf_timing: bool Config.T
    val build_map:
       Proof.context ->
         typ list -> typ list -> (typ * typ -> term) -> typ * typ -> term
    val build_rel:
       (string * (int * term)) list ->
         Proof.context ->
           typ list -> typ list -> (typ * typ -> term) -> typ * typ -> term
    val build_set: Proof.context -> typ -> typ -> term
    val collect_set_map_of_bnf: bnf -> thm
    val dead_of_bnf: bnf -> int
    val deads_of_bnf: bnf -> typ list
    val define_bnf_consts:
       inline_policy ->
         fact_policy ->
           bool ->
             typ list option ->
               binding ->
                 binding ->
                   binding ->
                     binding list ->
                       ((((((binding * typ) * term) * term list) * term) *
                         term list)
                        *
                        term option)
                       *
                       term option
                         ->
                         local_theory ->
                           ((typ list * typ list * typ list * typ) *
                            (term * term list * term *
                             (int list * term) list * term * term)
                            *
                            (thm * thm list * thm * thm list * thm * thm) *
                            ((typ list -> typ list -> typ list -> term) *
                             (typ list -> typ list -> term -> term) *
                             (typ list -> typ list -> ...) *
                             (typ list -> ...) * ... * ...))
                           *
                           local_theory
    datatype fact_policy = Dont_Note | Note_All | Note_Some
    val flatten_type_args_of_bnf: bnf -> 'a -> 'a list -> 'a list
    val in_bd_of_bnf: bnf -> thm
    val in_cong_of_bnf: bnf -> thm
    val in_mono_of_bnf: bnf -> thm
    val in_rel_of_bnf: bnf -> thm
    val inj_map_of_bnf: bnf -> thm
    val inj_map_strong_of_bnf: bnf -> thm
    datatype inline_policy
    = Do_Inline | Dont_Inline | Hardly_Inline | Smart_Inline
    val interpret_bnf:
       (string -> bool) -> bnf -> local_theory -> local_theory
    val le_rel_OO_of_bnf: bnf -> thm
    val live_of_bnf: bnf -> int
    val lives_of_bnf: bnf -> typ list
    val mapN: string
    val map_comp0_of_bnf: bnf -> thm
    val map_comp_of_bnf: bnf -> thm
    val map_cong0_of_bnf: bnf -> thm
    val map_cong_of_bnf: bnf -> thm
    val map_cong_pred_of_bnf: bnf -> thm
    val map_cong_simp_of_bnf: bnf -> thm
    val map_def_of_bnf: bnf -> thm
    val map_flattened_map_args:
       Proof.context ->
         string -> (term list -> 'a list) -> term list -> 'a list
    val map_id0_of_bnf: bnf -> thm
    val map_id_of_bnf: bnf -> thm
    val map_ident0_of_bnf: bnf -> thm
    val map_ident_of_bnf: bnf -> thm
    val map_of_bnf: bnf -> term
    val map_transfer_of_bnf: bnf -> thm
    val minimize_wits: (''a list * 'b) list -> (''a list * 'b) list
    val mk_T_of_bnf: typ list -> typ list -> bnf -> typ
    val mk_bd_of_bnf: typ list -> typ list -> bnf -> term
    val mk_map: int -> typ list -> typ list -> term -> term
    val mk_map_of_bnf: typ list -> typ list -> typ list -> bnf -> term
    val mk_pred: typ list -> term -> term
    val mk_pred_of_bnf: typ list -> typ list -> bnf -> term
    val mk_rel: int -> typ list -> typ list -> term -> term
    val mk_rel_of_bnf: typ list -> typ list -> typ list -> bnf -> term
    val mk_set: typ list -> term -> term
    val mk_setN: int -> string
    val mk_sets_of_bnf: typ list list -> typ list list -> bnf -> term list
    val mk_witN: int -> string
    val mk_wit_goals:
       term list -> term list -> term list -> int list * term -> term list
    val mk_witness: int list * term -> thm list -> nonemptiness_witness
    val mk_wits_of_bnf:
       typ list list -> typ list list -> bnf -> (int list * term) list
    val morph_bnf: morphism -> bnf -> bnf
    val morph_bnf_defs: morphism -> bnf -> bnf
    val name_of_bnf: bnf -> binding
    type nonemptiness_witness = {I: int list, prop: thm list, wit: term}
    val note_bnf_defs: bnf -> local_theory -> bnf * local_theory
    val note_bnf_thms:
       fact_policy ->
         (binding -> binding) ->
           binding -> bnf -> local_theory -> bnf * local_theory
    val nwits_of_bnf: bnf -> int
    val permute_deads: (typ list -> typ list) -> bnf -> bnf
    val predN: string
    val pred_True_of_bnf: bnf -> thm
    val pred_cong0_of_bnf: bnf -> thm
    val pred_cong_of_bnf: bnf -> thm
    val pred_cong_simp_of_bnf: bnf -> thm
    val pred_def_of_bnf: bnf -> thm
    val pred_map_of_bnf: bnf -> thm
    val pred_mono_of_bnf: bnf -> thm
    val pred_mono_strong0_of_bnf: bnf -> thm
    val pred_mono_strong_of_bnf: bnf -> thm
    val pred_of_bnf: bnf -> term
    val pred_rel_of_bnf: bnf -> thm
    val pred_set_of_bnf: bnf -> thm
    val pred_transfer_of_bnf: bnf -> thm
    val prepare_def:
       inline_policy ->
         (Proof.context -> fact_policy) ->
           bool ->
             (binding -> binding) ->
               (Proof.context -> 'a -> typ) ->
                 (Proof.context -> 'b -> term) ->
                   typ list option ->
                     binding ->
                       binding ->
                         binding ->
                           binding list ->
                             ((((((binding * 'a) * 'b) * 'b list) * 'b) *
                               'b list)
                              *
                              'b option)
                             *
                             'b option
                               ->
                               Proof.context ->
                                 string * term list *
                                 ((Proof.context -> thm list -> tactic)
                                  option
                                  *
                                  term list list)
                                 *
                                 ((thm list -> thm list list) ->
                                    thm list list -> Proof.context -> ...)
                                 *
                                 local_theory * thm list
    val print_bnfs: Proof.context -> unit
    val register_bnf:
       (string -> bool) -> string -> bnf -> local_theory -> local_theory
    val register_bnf_raw: string -> bnf -> local_theory -> local_theory
    val relN: string
    val rel_Grp_of_bnf: bnf -> thm
    val rel_OO_Grp_of_bnf: bnf -> thm
    val rel_OO_of_bnf: bnf -> thm
    val rel_cong0_of_bnf: bnf -> thm
    val rel_cong_of_bnf: bnf -> thm
    val rel_cong_simp_of_bnf: bnf -> thm
    val rel_conversep_of_bnf: bnf -> thm
    val rel_def_of_bnf: bnf -> thm
    val rel_eq_of_bnf: bnf -> thm
    val rel_eq_onp_of_bnf: bnf -> thm
    val rel_flip_of_bnf: bnf -> thm
    val rel_map_of_bnf: bnf -> thm list
    val rel_mono_of_bnf: bnf -> thm
    val rel_mono_strong0_of_bnf: bnf -> thm
    val rel_mono_strong_of_bnf: bnf -> thm
    val rel_of_bnf: bnf -> term
    val rel_refl_of_bnf: bnf -> thm
    val rel_refl_strong_of_bnf: bnf -> thm
    val rel_reflp_of_bnf: bnf -> thm
    val rel_symp_of_bnf: bnf -> thm
    val rel_transfer_of_bnf: bnf -> thm
    val rel_transp_of_bnf: bnf -> thm
    val setN: string
    val set_bd_of_bnf: bnf -> thm list
    val set_defs_of_bnf: bnf -> thm list
    val set_map0_of_bnf: bnf -> thm list
    val set_map_of_bnf: bnf -> thm list
    val set_transfer_of_bnf: bnf -> thm list
    val sets_of_bnf: bnf -> term list
    val transfer_bnf: theory -> bnf -> bnf
    val user_policy: fact_policy -> Proof.context -> fact_policy
    val wit_thms_of_bnf: bnf -> thm list
    val wit_thmss_of_bnf: bnf -> thm list list
    val wits_of_bnf: bnf -> nonemptiness_witness list
    val zip_axioms:
       'a ->
         'a ->
           'a -> 'a list -> 'a -> 'a -> 'a list -> 'a -> 'a -> 'a -> 'a list
  end
structure BNF_Def: BNF_DEF
### theory "HOL.BNF_Def"
### 1.836s elapsed time, 1.961s cpu time, 0.185s GC time
Loading theory "HOL.BNF_Composition" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base")
Loading theory "HOL.Basic_BNFs" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint" via "HOL.BNF_Fixpoint_Base")
Proofs for inductive predicate(s) "setlp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "setrp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "pred_sum"
  Proving monotonicity ...
Proofs for inductive predicate(s) "fstsp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "sndsp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "rel_prod"
  Proving monotonicity ...
Proofs for inductive predicate(s) "pred_prod"
  Proving monotonicity ...
### theory "HOL.Basic_BNFs"
### 0.217s elapsed time, 0.433s cpu time, 0.000s GC time
signature BNF_COMP_TACTICS =
  sig
    val bd_ordIso_natLeq_tac: Proof.context -> tactic
    val empty_natural_tac: Proof.context -> tactic
    val kill_in_alt_tac: Proof.context -> tactic
    val lift_in_alt_tac: Proof.context -> tactic
    val mk_comp_bd_card_order_tac:
       Proof.context -> thm list -> thm -> tactic
    val mk_comp_bd_cinfinite_tac: Proof.context -> thm -> thm -> tactic
    val mk_comp_in_alt_tac: Proof.context -> thm list -> tactic
    val mk_comp_map_comp0_tac:
       Proof.context -> thm -> thm -> thm list -> tactic
    val mk_comp_map_cong0_tac:
       Proof.context -> thm list -> thm list -> thm -> thm list -> tactic
    val mk_comp_map_id0_tac:
       Proof.context -> thm -> thm -> thm list -> tactic
    val mk_comp_set_alt_tac: Proof.context -> thm -> tactic
    val mk_comp_set_bd_tac:
       Proof.context -> thm -> thm option -> thm -> thm list -> tactic
    val mk_comp_set_map0_tac:
       Proof.context -> thm -> thm -> thm -> thm -> thm list -> tactic
    val mk_comp_wit_tac:
       Proof.context -> thm list -> thm list -> thm -> thm list -> tactic
    val mk_kill_map_cong0_tac: Proof.context -> int -> int -> thm -> tactic
    val mk_le_rel_OO_tac: Proof.context -> thm -> thm -> thm list -> tactic
    val mk_lift_set_bd_tac: Proof.context -> thm -> tactic
    val mk_permute_in_alt_tac:
       Proof.context -> ''a list -> ''a list -> tactic
    val mk_simple_pred_set_tac: Proof.context -> thm -> thm -> tactic
    val mk_simple_rel_OO_Grp_tac: Proof.context -> thm -> thm -> tactic
    val mk_simple_wit_tac: Proof.context -> thm list -> tactic
    val mk_simplified_set_tac: Proof.context -> thm -> tactic
  end
structure BNF_Comp_Tactics: BNF_COMP_TACTICS
### ML warning (line 802 of "~~/src/HOL/Tools/BNF/bnf_comp.ML"):
### Matches are not exhaustive.
signature BNF_COMP =
  sig
    exception BAD_DEAD of typ * typ
    val DEADID_bnf: BNF_Def.bnf
    val ID_bnf: BNF_Def.bnf
    type absT_info =
       {abs: term,
        absT: typ,
        abs_inject: thm,
        abs_inverse: thm, rep: term, repT: typ, type_definition: thm}
    val bnf_of_typ:
       bool ->
         BNF_Def.inline_policy ->
           (binding -> binding) ->
             ((string * sort) list list -> (string * sort) list) ->
               (string * sort) list ->
                 (string * sort) list ->
                   typ ->
                     (comp_cache * unfold_set) * local_theory ->
                       (BNF_Def.bnf * (typ list * typ list)) *
                       ((comp_cache * unfold_set) * local_theory)
    val clean_compose_bnf:
       BNF_Def.inline_policy ->
         (binding -> binding) ->
           binding ->
             BNF_Def.bnf ->
               BNF_Def.bnf list ->
                 unfold_set * local_theory ->
                   BNF_Def.bnf * (unfold_set * local_theory)
    type comp_cache
    val compose_bnf:
       BNF_Def.inline_policy ->
         (int -> binding -> binding) ->
           ((string * sort) list list -> (string * sort) list) ->
             BNF_Def.bnf ->
               BNF_Def.bnf list ->
                 typ list ->
                   typ list list ->
                     typ list list ->
                       (comp_cache * unfold_set) * local_theory ->
                         (BNF_Def.bnf * (typ list * typ list)) *
                         ((comp_cache * unfold_set) * local_theory)
    val default_comp_sort: (string * sort) list list -> (string * sort) list
    val empty_comp_cache: comp_cache
    val empty_unfolds: unfold_set
    val kill_bnf:
       (binding -> binding) ->
         int ->
           BNF_Def.bnf ->
             (comp_cache * unfold_set) * local_theory ->
               BNF_Def.bnf * ((comp_cache * unfold_set) * local_theory)
    val lift_and_permute_bnf:
       (binding -> binding) ->
         int ->
           int list ->
             int list ->
               BNF_Def.bnf ->
                 (comp_cache * unfold_set) * local_theory ->
                   BNF_Def.bnf * ((comp_cache * unfold_set) * local_theory)
    val lift_bnf:
       (binding -> binding) ->
         int ->
           BNF_Def.bnf ->
             (comp_cache * unfold_set) * local_theory ->
               BNF_Def.bnf * ((comp_cache * unfold_set) * local_theory)
    val mk_abs: typ -> term -> term
    val mk_absT: theory -> typ -> typ -> typ -> typ
    val mk_rep: typ -> term -> term
    val mk_repT: typ -> typ -> typ -> typ
    val morph_absT_info: morphism -> absT_info -> absT_info
    val normalize_bnfs:
       (int -> binding -> binding) ->
         ''a list list ->
           ''a list ->
             (''a list list -> ''a list) ->
               BNF_Def.bnf list ->
                 (comp_cache * unfold_set) * local_theory ->
                   (int list list * ''a list) *
                   (BNF_Def.bnf list *
                    ((comp_cache * unfold_set) * local_theory))
    val permute_and_kill_bnf:
       (binding -> binding) ->
         int ->
           int list ->
             int list ->
               BNF_Def.bnf ->
                 (comp_cache * unfold_set) * local_theory ->
                   BNF_Def.bnf * ((comp_cache * unfold_set) * local_theory)
    val permute_bnf:
       (binding -> binding) ->
         int list ->
           int list ->
             BNF_Def.bnf ->
               (comp_cache * unfold_set) * local_theory ->
                 BNF_Def.bnf * ((comp_cache * unfold_set) * local_theory)
    val seal_bnf:
       (binding -> binding) ->
         unfold_set ->
           binding ->
             bool ->
               typ list ->
                 typ list ->
                   BNF_Def.bnf ->
                     local_theory ->
                       (BNF_Def.bnf * (typ list * absT_info)) * local_theory
    val typedef_threshold: int Config.T
    type unfold_set =
       {map_unfolds: thm list,
        pred_unfolds: thm list,
        rel_unfolds: thm list, set_unfoldss: thm list list}
    val with_typedef_threshold:
       int ->
         (Proof.context -> Proof.context) -> Proof.context -> Proof.context
    val with_typedef_threshold_yield:
       int ->
         (Proof.context -> 'a * Proof.context) ->
           Proof.context -> 'a * Proof.context
  end
structure BNF_Comp: BNF_COMP
### theory "HOL.BNF_Composition"
### 0.562s elapsed time, 0.858s cpu time, 0.109s GC time
Loading theory "HOL.BNF_Fixpoint_Base" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.BNF_Least_Fixpoint")
signature BNF_FP_UTIL_TACTICS =
  sig
    val mk_xtor_co_rec_id_tac:
       Proof.context -> thm list -> thm -> thm list -> thm list -> tactic
    val mk_xtor_co_rec_tac:
       Proof.context -> thm -> thm list -> thm list -> tactic
    val mk_xtor_co_rec_transfer_tac:
       Proof.context ->
         BNF_Util.fp_kind ->
           int ->
             int -> thm list -> thm list -> thm list -> thm list -> tactic
    val mk_xtor_co_rec_unique_tac:
       Proof.context ->
         BNF_Util.fp_kind ->
           thm list -> thm list -> thm -> thm list -> thm list -> tactic
    val mk_xtor_un_fold_xtor_tac:
       Proof.context -> thm -> thm list -> thm list -> tactic
  end
structure BNF_FP_Util_Tactics:
  sig
    val CONJ_WRAP: ('a -> tactic) -> 'a list -> tactic
    val CONJ_WRAP': ('a -> int -> tactic) -> 'a list -> int -> tactic
    val CONJ_WRAP_GEN: tactic -> ('a -> tactic) -> 'a list -> tactic
    val CONJ_WRAP_GEN':
       (int -> tactic) -> ('a -> int -> tactic) -> 'a list -> int -> tactic
    val Id_const: typ -> term
    val WRAP:
       ('a -> tactic) -> ('a -> tactic) -> 'a list -> tactic -> tactic
    val WRAP':
       ('a -> int -> tactic) ->
         ('a -> int -> tactic) ->
           'a list -> (int -> tactic) -> int -> tactic
    val base_name_of_typ: typ -> string
    val binder_fun_types: typ -> typ list
    val body_fun_type: typ -> typ
    val case_fp: fp_kind -> 'a -> 'a -> 'a
    val check_all_fun_arg_frees:
       Proof.context -> term list -> term list -> unit
    val check_duplicate_const_names: binding list -> unit
    val check_duplicate_variables_in_lhs:
       Proof.context -> term list -> term list -> unit
    val check_top_sort: Proof.context -> binding -> typ -> unit
    val clean_blast_tac: Proof.context -> int -> tactic
    val conj_dests: int -> thm -> thm list
    val ctrans: thm
    val ctwo: term
    val dest_TFree_or_TVar: typ -> string * sort
    val dest_pred2T: typ -> typ * typ
    val dest_relT: typ -> typ * typ
    val drop_all: term -> term
    val dtac: Proof.context -> thm -> int -> tactic
    val enforce_type: Proof.context -> (typ -> typ) -> typ -> term -> term
    val eqFalseI: thm
    val eqTrueI: thm
    val error_at: Proof.context -> term list -> string -> 'a
    val etac: Proof.context -> thm -> int -> tactic
    val excess_equations: Proof.context -> term list -> 'a
    val exists_strict_subtype_in: typ list -> typ -> bool
    val exists_subtype_in: typ list -> typ -> bool
    val extra_variable_in_rhs: Proof.context -> term list -> term -> 'a
    val find_index_eq: ''a list -> ''a -> int
    val find_indices: ('a * 'b -> bool) -> 'b list -> 'a list -> int list
    val finds:
       ('a * 'b -> bool) ->
         'a list -> 'b list -> ('a * 'b list) list * 'b list
    val flat_rec_arg_args: 'a list list -> 'a list
    val fo_match: Proof.context -> term -> term -> Type.tyenv * Envir.tenv
    val fo_rtac: Proof.context -> thm -> int -> tactic
    datatype fp_kind = Greatest_FP | Least_FP
    type fp_rec_sugar =
       {fpTs: typ list,
        fun_defs: thm list,
        fun_names: string list, funs: term list, transfers: bool list}
    val fst_const: typ -> term
    val id_apply: thm
    val ill_formed_corec_call: Proof.context -> term -> 'a
    val ill_formed_equation: Proof.context -> term -> 'a
    val ill_formed_equation_head: Proof.context -> term list -> 'a
    val ill_formed_equation_lhs_rhs: Proof.context -> term list -> 'a
    val ill_formed_formula: Proof.context -> term -> 'a
    val ill_formed_rec_call: Proof.context -> term -> 'a
    val inconstant_pattern_pos_for_fun:
       Proof.context -> term list -> string -> 'a
    val indexed: 'a list -> int -> int list * int
    val indexedd: 'a list list -> int -> int list list * int
    val indexeddd: 'a list list list -> int -> int list list list * int
    val indexedddd:
       'a list list list list -> int -> int list list list list * int
    val invalid_map: Proof.context -> term list -> term -> 'a
    val is_concl_refl: thm -> bool
    val is_refl: thm -> bool
    val is_refl_bool: term -> bool
    val lhs_head_of: thm -> term
    val list_all_free: term list -> term -> term
    val list_exists_free: term list -> term -> term
    val map_prod: ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd
    val meta_mp: thm
    val meta_spec: thm
    val missing_args_to_fun_on_lhs: Proof.context -> term list -> 'a
    val missing_equations_for_const: string -> 'a
    val missing_equations_for_fun: string -> 'a
    val missing_pattern: Proof.context -> term list -> 'a
    val mk_Abs_bij_thm: Proof.context -> thm -> thm -> thm
    val mk_Abs_inj_thm: thm -> thm
    val mk_Ball: term -> term -> term
    val mk_Bex: term -> term -> term
    val mk_Card_order: term -> term
    val mk_Field: term -> term
    val mk_Frees:
       string -> typ list -> Proof.context -> term list * Proof.context
    val mk_Frees':
       string ->
         typ list ->
           Proof.context ->
             (term list * (string * typ) list) * Proof.context
    val mk_Freess:
       string ->
         typ list list -> Proof.context -> term list list * Proof.context
    val mk_Freess':
       string ->
         typ list list ->
           Proof.context ->
             (term list list * (string * typ) list list) * Proof.context
    val mk_Freesss:
       string ->
         typ list list list ->
           Proof.context -> term list list list * Proof.context
    val mk_Freessss:
       string ->
         typ list list list list ->
           Proof.context -> term list list list list * Proof.context
    val mk_Gr: term -> term -> term
    val mk_Grp: term -> term -> term
    val mk_IfN: typ -> term list -> term list -> term
    val mk_TFrees: int -> Proof.context -> typ list * Proof.context
    val mk_TFrees': sort list -> Proof.context -> typ list * Proof.context
    val mk_TFreess:
       int list -> Proof.context -> typ list list * Proof.context
    val mk_Trueprop_eq: term * term -> term
    val mk_Trueprop_mem: term * term -> term
    val mk_UNION: term -> term -> term
    val mk_UnIN: int -> int -> thm
    val mk_Un_upper: int -> int -> thm
    val mk_Union: typ -> term
    val mk_abs_def: thm -> thm
    val mk_card_binop: string -> (typ * typ -> typ) -> term -> term -> term
    val mk_card_of: term -> term
    val mk_card_order: term -> term
    val mk_cexp: term -> term -> term
    val mk_cinfinite: term -> term
    val mk_co_rec: theory -> fp_kind -> typ list -> typ -> term -> term
    val mk_collect: term list -> typ -> term
    val mk_common_name: string list -> string
    val mk_comp: typ list -> term * term -> term
    val mk_compN: int -> typ list -> term * term -> term
    val mk_conjIN: int -> thm
    val mk_conj_arg_congN: int -> thm
    val mk_conjunctN: int -> int -> thm
    val mk_converse: term -> term
    val mk_conversep: term -> term
    val mk_cprod: term -> term -> term
    val mk_csum: term -> term -> term
    val mk_dir_image: term -> term -> term
    val mk_disjIN: int -> int -> thm
    val mk_eq_onp: term -> term
    val mk_fresh_names:
       Proof.context -> int -> string -> string list * Proof.context
    val mk_image: term -> term
    val mk_in: term list -> term list -> typ -> term
    val mk_inj: term -> term
    val mk_leq: term -> term -> term
    val mk_map_comp_id_tac: Proof.context -> thm -> tactic
    val mk_map_cong0L_tac: Proof.context -> int -> thm -> thm -> tactic
    val mk_map_cong0_tac: Proof.context -> int -> thm -> tactic
    val mk_names: int -> string -> string list
    val mk_nthI: int -> int -> thm
    val mk_nthN: int -> term -> int -> term
    val mk_nth_conv: int -> int -> thm
    val mk_ordLeq: term -> term -> term
    val mk_ordLeq_csum: int -> int -> thm -> thm
    val mk_partial_compN: int -> typ -> term -> term
    val mk_pointfree2: Proof.context -> thm -> thm
    val mk_pointful: Proof.context -> thm -> thm
    val mk_pred1T: typ -> typ
    val mk_pred2T: typ -> typ -> typ
    val mk_predT: typ list -> typ
    val mk_reflp: term -> term
    val mk_relT: typ * typ -> typ
    val mk_rel_comp: term * term -> term
    val mk_rel_compp: term * term -> term
    val mk_rel_fun: term -> term -> term
    val mk_rel_funDN: int -> thm -> thm
    val mk_rel_funDN_rotated: int -> thm -> thm
    val mk_rotate_eq_tac:
       Proof.context ->
         (int -> tactic) ->
           thm -> thm -> thm -> thm -> ''a list -> ''a list -> int -> tactic
    val mk_sumT: typ * typ -> typ
    val mk_sym: thm -> thm
    val mk_symp: term -> term
    val mk_trans: thm -> thm -> thm
    val mk_transp: term -> term
    val mk_unabs_def: int -> thm -> thm
    val mk_union: term * term -> term
    val mk_vimage2p: term -> term -> term
    val mk_xtor_co_rec_id_tac:
       Proof.context -> thm list -> thm -> thm list -> thm list -> tactic
    val mk_xtor_co_rec_tac:
       Proof.context -> thm -> thm list -> thm list -> tactic
    val mk_xtor_co_rec_transfer_tac:
       Proof.context ->
         fp_kind ->
           int ->
             int -> thm list -> thm list -> thm list -> thm list -> tactic
    val mk_xtor_co_rec_unique_tac:
       Proof.context ->
         fp_kind ->
           thm list ->
             thm list -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_xtor_un_fold_xtor_tac:
       Proof.context -> thm -> thm list -> thm list -> tactic
    val more_than_one_nonvar_in_lhs: Proof.context -> term list -> 'a
    val morph_fp_rec_sugar: morphism -> fp_rec_sugar -> fp_rec_sugar
    val multiple_equations_for_ctr: Proof.context -> term list -> 'a
    val name_noted_thms:
       string ->
         string -> (string * thm list) list -> (string * thm list) list
    val name_of_const: string -> (typ -> typ) -> term -> string
    val no_equation_for_ctr_warning:
       Proof.context -> term list -> term -> unit
    val no_refl: thm list -> thm list
    val no_reflexive: thm list -> thm list
    val nonprimitive_corec: Proof.context -> term list -> 'a
    val nonprimitive_pattern_in_lhs: Proof.context -> term list -> 'a
    val nonzero_string_of_int: int -> string
    val not_codatatype: Proof.context -> typ -> 'a
    val not_constructor_in_pattern: Proof.context -> term list -> term -> 'a
    val not_constructor_in_rhs: Proof.context -> term list -> term -> 'a
    val not_datatype: Proof.context -> typ -> 'a
    val num_binder_types: typ -> int
    val o_apply: thm
    val order_strong_conn:
       ('a * 'a -> bool) ->
         ((('a * unit) * 'a list) list -> 'b) ->
           ('b -> 'a list) ->
             ('a * 'a list) list -> 'a list list -> 'a list list
    val pad_list: 'a -> int -> 'a list -> 'a list
    val parse_binding_colon: binding parser
    val parse_map_rel_pred_bindings: (binding * binding * binding) parser
    val parse_opt_binding_colon: binding parser
    val parse_type_args_named_constrained:
       (binding option * (string * string option)) list parser
    val partially_applied_ctr_in_pattern: Proof.context -> term list -> 'a
    val partially_applied_ctr_in_rhs: Proof.context -> term list -> 'a
    val permute_args: int -> term -> term
    val permute_like:
       ('a * 'a -> bool) -> 'a list -> 'a list -> 'b list -> 'b list
    val permute_like_unique:
       ('a * 'b -> bool) -> 'a list -> 'b list -> 'c list -> 'c list
    val print_def_consts:
       bool -> (term * (string * thm)) list -> Proof.context -> unit
    val prod_injectD: thm
    val prod_injectI: thm
    val rapp: term -> term -> term
    val rec_call_not_apply_to_ctr_arg:
       Proof.context -> term list -> term -> 'a
    val rel_funD: thm
    val rel_funI: thm
    val resort_tfree_or_tvar: sort -> typ -> typ
    val retype_const_or_free: typ -> term -> term
    val rtac: Proof.context -> thm -> int -> tactic
    val select_prem_tac:
       Proof.context -> int -> (int -> tactic) -> int -> int -> tactic
    val seq_conds: (bool -> 'a -> 'b) -> int -> int -> 'a list -> 'b list
    val set_mp: thm
    val set_rev_mp: thm
    val snd_const: typ -> term
    val splice: 'a list -> 'a list -> 'a list
    val ss_only: thm list -> Proof.context -> Proof.context
    val standard_binding: binding
    val strip_fun_type: typ -> typ list * typ
    val strip_typeN: int -> typ -> typ list * typ
    val subset_UNIV: thm
    val subst_asm_tac:
       Proof.context -> int list option -> thm list -> int -> tactic
    val subst_nonatomic_types: (typ * typ) list -> term -> term
    val subst_tac:
       Proof.context -> int list option -> thm list -> int -> tactic
    val substitute_noted_thm: (string * thm list) list -> morphism
    val too_few_args_in_rec_call: Proof.context -> term list -> term -> 'a
    val transfer_fp_rec_sugar: theory -> fp_rec_sugar -> fp_rec_sugar
    val transfer_plugin: string
    val transpose: 'a list list -> 'a list list
    val tvar_subst:
       theory -> typ list -> typ list -> ((string * int) * typ) list
    val typ_subst_nonatomic: (typ * typ) list -> typ -> typ
    val typedef:
       binding * (string * sort) list * mixfix ->
         term ->
           (binding * binding) option ->
             (Proof.context -> tactic) ->
               local_theory -> (string * Typedef.info) * local_theory
    val unexpected_corec_call_in: Proof.context -> term list -> term -> 'a
    val unexpected_rec_call_in: Proof.context -> term list -> term -> 'a
    val unflatt: 'a list list list -> 'b list -> 'b list list list
    val unflattt:
       'a list list list list -> 'b list -> 'b list list list list
    val unfold_thms: Proof.context -> thm list -> thm -> thm
    val unfold_thms_tac: Proof.context -> thm list -> tactic
    val unsupported_case_around_corec_call:
       Proof.context -> term list -> term -> 'a
    val variant_tfrees:
       string list -> Proof.context -> typ list * Proof.context
    val variant_types:
       string list ->
         sort list -> Proof.context -> (string * sort) list * Proof.context
    val warning_at: Proof.context -> term list -> string -> unit
  end
### ML warning (line 403 of "~~/src/HOL/Tools/BNF/bnf_fp_util.ML"):
### Matches are not exhaustive.
### ML warning (line 545 of "~~/src/HOL/Tools/BNF/bnf_fp_util.ML"):
### Matches are not exhaustive.
### ML warning (line 548 of "~~/src/HOL/Tools/BNF/bnf_fp_util.ML"):
### Matches are not exhaustive.
### ML warning (line 979 of "~~/src/HOL/Tools/BNF/bnf_fp_util.ML"):
### Value identifier (timer) has not been referenced.
signature BNF_FP_UTIL =
  sig
    exception EMPTY_DATATYPE of string
    val IITN: string
    val If_const: typ -> term
    val Inl_const: typ -> typ -> term
    val Inr_const: typ -> typ -> term
    val LevN: string
    val abs_curried_balanced: typ list -> term -> term
    val algN: string
    val behN: string
    val bisN: string
    val carTN: string
    val caseN: string
    val coN: string
    val co_prefix: BNF_Util.fp_kind -> string
    val coinductN: string
    val coinduct_strongN: string
    val colN: string
    val corecN: string
    val corec_discN: string
    val corec_disc_iffN: string
    val corec_selN: string
    val ctorN: string
    val ctor_dtorN: string
    val ctor_exhaustN: string
    val ctor_foldN: string
    val ctor_fold_o_mapN: string
    val ctor_fold_transferN: string
    val ctor_fold_uniqueN: string
    val ctor_induct2N: string
    val ctor_inductN: string
    val ctor_injectN: string
    val ctor_mapN: string
    val ctor_map_uniqueN: string
    val ctor_recN: string
    val ctor_rec_o_mapN: string
    val ctor_rec_transferN: string
    val ctor_rec_uniqueN: string
    val ctor_relN: string
    val ctor_rel_inductN: string
    val ctor_set_inclN: string
    val ctor_set_set_inclN: string
    val derive_xtor_co_recs:
       BNF_Util.fp_kind ->
         binding list ->
           (typ list -> typ list) ->
             typ list list * typ list ->
               BNF_Def.bnf list ->
                 term list ->
                   term list ->
                     thm ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm list ->
                               (BNF_Comp.absT_info * BNF_Comp.absT_info)
                               option
                               list
                                 ->
                                 local_theory ->
                                   (term list *
                                    (thm list * thm * thm list * thm list))
                                   *
                                   local_theory
    val dest_absumprodT:
       typ -> typ -> int -> int list -> typ -> typ list list
    val dest_sumT: typ -> typ * typ
    val dest_sumTN_balanced: int -> typ -> typ list
    val dest_tupleT_balanced: int -> typ -> typ list
    val dtorN: string
    val dtor_coinductN: string
    val dtor_coinduct_strongN: string
    val dtor_corecN: string
    val dtor_corec_o_mapN: string
    val dtor_corec_transferN: string
    val dtor_corec_uniqueN: string
    val dtor_ctorN: string
    val dtor_exhaustN: string
    val dtor_injectN: string
    val dtor_mapN: string
    val dtor_map_coinductN: string
    val dtor_map_coinduct_strongN: string
    val dtor_map_uniqueN: string
    val dtor_relN: string
    val dtor_rel_coinductN: string
    val dtor_set_inclN: string
    val dtor_set_set_inclN: string
    val dtor_unfoldN: string
    val dtor_unfold_o_mapN: string
    val dtor_unfold_transferN: string
    val dtor_unfold_uniqueN: string
    val exhaustN: string
    val fixpoint:
       ('a * 'a -> bool) -> ('a list -> 'a list) -> 'a list -> 'a list
    val fixpoint_bnf:
       bool ->
         (binding -> binding) ->
           (binding list ->
              (string * sort) list ->
                typ list * typ list list ->
                  BNF_Def.bnf list ->
                    BNF_Comp.absT_info list -> local_theory -> 'a)
             ->
             binding list ->
               (string * sort) list ->
                 (string * sort) list ->
                   (string * sort) list ->
                     typ list ->
                       BNF_Comp.comp_cache ->
                         local_theory ->
                           ((BNF_Def.bnf list * BNF_Comp.absT_info list) *
                            BNF_Comp.comp_cache)
                           *
                           'a
    val force_typ: Proof.context -> typ -> term -> term
    type fp_result =
       {Ts: typ list,
        absT_infos: BNF_Comp.absT_info list,
        bnfs: BNF_Def.bnf list,
        ctor_dtors: thm list,
        ctor_injects: thm list,
        ctors: term list,
        dtor_ctors: thm list,
        dtor_injects: thm list,
        dtor_set_inducts: thm list,
        dtors: term list,
        pre_bnfs: BNF_Def.bnf list,
        xtor_co_induct: thm,
        xtor_co_rec_o_maps: thm list,
        xtor_co_rec_thms: thm list,
        xtor_co_rec_transfers: thm list,
        xtor_co_rec_unique: thm,
        xtor_co_recs: term list, xtor_map_unique: thm, ...}
    val inductN: string
    val injectN: string
    val isNodeN: string
    val lsbisN: string
    val mapN: string
    val map_uniqueN: string
    val min_algN: string
    val mk_Field: term -> term
    val mk_If: term -> term -> term -> term
    val mk_Inl: typ -> term -> term
    val mk_Inr: typ -> term -> term
    val mk_absumprod: typ -> term -> int -> int -> term list -> term
    val mk_absumprodE: thm -> int list -> thm
    val mk_case_absumprod:
       typ -> term -> term list -> term list list -> term list list -> term
    val mk_case_sum: term * term -> term
    val mk_case_sumN: term list -> term
    val mk_convol: term * term -> term
    val mk_ctor_setN: int -> string
    val mk_dtor_setN: int -> string
    val mk_dtor_set_inductN: int -> string
    val mk_proj: typ -> int -> int -> term
    val mk_rel_prod: term -> term -> term
    val mk_rel_sum: term -> term -> term
    val mk_set_inductN: int -> string
    val mk_sumTN: typ list -> typ
    val mk_sumTN_balanced: typ list -> typ
    val mk_sum_Cinfinite: thm list -> thm
    val mk_sum_card_order: thm list -> thm
    val mk_sum_caseN: int -> int -> thm
    val mk_sum_caseN_balanced: int -> int -> thm
    val mk_sumprodT_balanced: typ list list -> typ
    val mk_sumprod_balanced: typ -> int -> int -> term list -> term
    val mk_tuple1_balanced: typ list -> term list -> term
    val mk_tupleT_balanced: typ list -> typ
    val mk_tuple_balanced: term list -> term
    val mk_tupled_fun: term -> term -> term list -> term
    val mk_xtor_co_iter_o_map_thms:
       BNF_Util.fp_kind ->
         bool ->
           int ->
             thm -> thm list -> thm list -> thm list -> thm list -> thm list
    val mk_xtor_co_iter_transfer_thms:
       BNF_Util.fp_kind ->
         term list ->
           term list ->
             term list ->
               term list ->
                 term list ->
                   term list ->
                     term list ->
                       ({context: Proof.context, prems: thm list} -> tactic)
                         -> Proof.context -> thm list
    val mk_xtor_rel_co_induct_thm:
       BNF_Util.fp_kind ->
         term list ->
           term list ->
             term list ->
               term list ->
                 term list ->
                   term list ->
                     term list ->
                       term list ->
                         ({context: Proof.context, prems: thm list} ->
                            tactic)
                           -> Proof.context -> thm
    val morN: string
    val morph_fp_result: morphism -> fp_result -> fp_result
    val nchotomyN: string
    val raw_qualify: (binding -> binding) -> binding -> binding -> binding
    val recN: string
    val rel_casesN: string
    val rel_coinductN: string
    val rel_distinctN: string
    val rel_inductN: string
    val rel_injectN: string
    val rel_introsN: string
    val rel_selN: string
    val rvN: string
    val setN: string
    val set_inclN: string
    val set_set_inclN: string
    val simpsN: string
    val split_conj_prems: int -> thm -> thm
    val split_conj_thm: thm -> thm list
    val strTN: string
    val str_initN: string
    val sum_bdN: string
    val sum_bdTN: string
    val time:
       Proof.context -> Timer.real_timer -> string -> Timer.real_timer
    val uniqueN: string
  end
structure BNF_FP_Util: BNF_FP_UTIL
### ML warning (line 287 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar_tactics.ML"):
### Matches are not exhaustive.
### ML warning (line 296 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar_tactics.ML"):
### Pattern is not exhaustive.
signature BNF_FP_DEF_SUGAR_TACTICS =
  sig
    val co_induct_inst_as_projs_tac: Proof.context -> int -> tactic
    val mk_case_transfer_tac: Proof.context -> thm -> thm list -> tactic
    val mk_co_rec_o_map_tac:
       Proof.context ->
         thm ->
           thm list -> thm list -> thm list -> thm -> thm -> thm Seq.seq
    val mk_coinduct_discharge_prem_tac:
       Proof.context ->
         thm list ->
           thm list ->
             int ->
               int ->
                 int ->
                   thm ->
                     thm ->
                       thm ->
                         thm ->
                           thm ->
                             thm list ->
                               thm list list ->
                                 thm list list -> int -> tactic
    val mk_coinduct_tac:
       Proof.context ->
         thm list ->
           int ->
             int list ->
               thm ->
                 thm list ->
                   thm list ->
                     thm list ->
                       thm list ->
                         thm list ->
                           thm list list ->
                             thm list list list ->
                               thm list list list -> tactic
    val mk_corec_disc_iff_tac:
       thm list -> thm list -> thm list -> Proof.context -> tactic
    val mk_corec_tac:
       thm list ->
         thm list -> thm -> thm -> thm -> thm -> Proof.context -> tactic
    val mk_corec_transfer_tac:
       Proof.context ->
         cterm list ->
           cterm list ->
             thm list ->
               thm list ->
                 thm list ->
                   thm list ->
                     thm list ->
                       ''a list ->
                         ''a list list ->
                           ''a list list list list ->
                             ''a list list list list -> tactic
    val mk_ctor_iff_dtor_tac:
       Proof.context ->
         ctyp option list -> cterm -> cterm -> thm -> thm -> tactic
    val mk_ctr_transfer_tac: Proof.context -> thm list -> thm list -> tactic
    val mk_disc_transfer_tac:
       Proof.context -> thm -> thm -> thm list -> tactic
    val mk_exhaust_tac:
       Proof.context -> int -> thm list -> thm -> thm -> tactic
    val mk_half_distinct_tac:
       Proof.context -> thm -> thm -> thm list -> tactic
    val mk_induct_discharge_prem_tac:
       Proof.context ->
         int ->
           int ->
             thm list ->
               thm list ->
                 thm list -> thm list -> int -> int -> int list -> tactic
    val mk_induct_tac:
       Proof.context ->
         int ->
           int list ->
             int list list ->
               int list list list ->
                 thm list ->
                   thm ->
                     thm list ->
                       thm list -> thm list -> thm list list -> tactic
    val mk_inject_tac: Proof.context -> thm -> thm -> thm -> tactic
    val mk_map_disc_iff_tac:
       Proof.context -> cterm -> thm -> thm list -> thm list -> tactic
    val mk_map_sel_tac:
       Proof.context ->
         cterm ->
           thm -> thm list -> thm list -> thm list -> thm list -> tactic
    val mk_map_tac:
       Proof.context ->
         thm list ->
           thm -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_rec_tac:
       thm list ->
         thm list ->
           thm list -> thm -> thm -> thm -> thm -> Proof.context -> tactic
    val mk_rec_transfer_tac:
       Proof.context ->
         int ->
           int list ->
             cterm list ->
               cterm list ->
                 term list list list list ->
                   thm list -> thm list -> thm list -> thm list -> tactic
    val mk_rel_case_tac:
       Proof.context ->
         cterm ->
           cterm ->
             thm ->
               thm list ->
                 thm list -> thm list -> thm list -> thm list -> tactic
    val mk_rel_coinduct0_tac:
       Proof.context ->
         thm ->
           cterm list ->
             thm list ->
               thm list ->
                 thm list list ->
                   thm list list ->
                     thm list list ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm list -> thm list -> thm list -> tactic
    val mk_rel_induct0_tac:
       Proof.context ->
         thm ->
           thm list ->
             cterm list ->
               thm list ->
                 thm list list ->
                   thm list -> thm list -> thm list -> thm list -> tactic
    val mk_rel_sel_tac:
       Proof.context ->
         cterm ->
           cterm ->
             thm ->
               thm list ->
                 thm list ->
                   thm list -> thm list -> thm list -> thm list -> tactic
    val mk_rel_tac:
       Proof.context ->
         thm list ->
           thm -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_sel_transfer_tac:
       Proof.context -> int -> thm list -> thm -> tactic
    val mk_set0_tac:
       Proof.context ->
         thm list ->
           thm list ->
             thm ->
               thm list ->
                 thm list -> thm list -> thm list -> thm list -> tactic
    val mk_set_cases_tac:
       Proof.context -> cterm -> thm list -> thm -> thm list -> tactic
    val mk_set_induct0_tac:
       Proof.context ->
         cterm list ->
           thm list ->
             thm list ->
               thm list ->
                 thm list -> thm list -> thm list -> thm list -> tactic
    val mk_set_intros_tac: Proof.context -> thm list -> tactic
    val mk_set_sel_tac:
       Proof.context ->
         cterm -> thm -> thm list -> thm list -> thm list -> tactic
    val sumprod_thms_rel: thm list
  end
structure BNF_FP_Def_Sugar_Tactics: BNF_FP_DEF_SUGAR_TACTICS
### ML warning (line 322 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 323 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 420 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 530 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 556 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 560 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 572 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 581 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 630 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 843 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 863 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 925 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1514 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1533 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 1544 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1753 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Value identifier (plugins) has not been referenced.
### ML warning (line 1820 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1921 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2281 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2331 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2407 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2397 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2455 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2557 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2598 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2789 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 2802 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2889 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 2898 of "~~/src/HOL/Tools/BNF/bnf_fp_def_sugar.ML"):
### Value identifier (timer) has not been referenced.
signature BNF_FP_DEF_SUGAR =
  sig
    val co_datatype_cmd:
       BNF_Util.fp_kind ->
         (mixfix list ->
            binding list ->
              binding list ->
                binding list ->
                  binding list list ->
                    binding list ->
                      (string * sort) list ->
                        typ list * typ list list ->
                          BNF_Def.bnf list ->
                            BNF_Comp.absT_info list ->
                              local_theory ->
                                BNF_FP_Util.fp_result * Proof.context)
           ->
           ((Proof.context -> Plugin_Name.filter) * bool) *
           ((((((binding option * (string * string option)) list * binding)
               *
               mixfix)
              *
              ((binding, binding * string) Ctr_Sugar.ctr_spec * mixfix)
              list)
             *
             (binding * binding * binding))
            *
            string list
           )
           list
             -> Proof.context -> local_theory
    val co_datatypes:
       BNF_Util.fp_kind ->
         (mixfix list ->
            binding list ->
              binding list ->
                binding list ->
                  binding list list ->
                    binding list ->
                      (string * sort) list ->
                        typ list * typ list list ->
                          BNF_Def.bnf list ->
                            BNF_Comp.absT_info list ->
                              local_theory ->
                                BNF_FP_Util.fp_result * local_theory)
           ->
           Ctr_Sugar.ctr_options *
           ((((((binding option * (typ * sort)) list * binding) * mixfix) *
              ((binding, binding * typ) Ctr_Sugar.ctr_spec * mixfix) list)
             *
             (binding * binding * binding))
            *
            term list
           )
           list
             -> local_theory -> local_theory
    val co_induct_of: 'a list -> 'a
    val define_co_rec_as:
       BNF_Util.fp_kind ->
         typ list ->
           typ ->
             binding -> term -> local_theory -> (term * thm) * local_theory
    val define_corec:
       'a * term list * term list list *
       (((term list list * term list list * term list list list list *
          term list list list list)
         *
         term list list list)
        *
        typ list)
         ->
         (string -> binding) ->
           'b list ->
             typ list ->
               term list ->
                 term -> local_theory -> (term * thm) * local_theory
    val define_ctrs_dtrs_for_type:
       string ->
         typ ->
           term ->
             term ->
               thm ->
                 thm ->
                   int ->
                     int list ->
                       term ->
                         binding list ->
                           mixfix list ->
                             typ list list ->
                               local_theory ->
                                 (term list list * term list * thm *
                                  thm list)
                                 *
                                 local_theory
    val define_rec:
       typ list list * typ list list list list * term list list *
       term list list list list
         ->
         (string -> binding) ->
           typ list ->
             typ list ->
               term list ->
                 term -> Proof.context -> (term * thm) * Proof.context
    val derive_coinduct_corecs_thms_for_types:
       Proof.context ->
         BNF_Def.bnf list ->
           string * term list * term list list *
           (((term list list * term list list * term list list list list *
              term list list list list)
             *
             term list list list)
            *
            typ list)
             ->
             thm ->
               thm list ->
                 thm list ->
                   thm list ->
                     BNF_Def.bnf list ->
                       typ list ->
                         typ list ->
                           typ list ->
                             typ list list list ->
                               int list list ->
                                 int list list ->
                                   int list ->
                                     thm list ->
                                       thm list ->
   (thm -> thm) -> thm list list -> Ctr_Sugar.ctr_sugar list -> ...
    val derive_coinduct_thms_for_types:
       Proof.context ->
         bool ->
           (term -> term) ->
             BNF_Def.bnf list ->
               thm ->
                 thm list ->
                   BNF_Def.bnf list ->
                     typ list ->
                       typ list ->
                         typ list list list ->
                           int list ->
                             thm list ->
                               thm list ->
                                 (thm -> thm) ->
                                   thm list list ->
                                     Ctr_Sugar.ctr_sugar list ->
                                       (thm list * thm) list
    val derive_induct_recs_thms_for_types:
       (string -> bool) ->
         BNF_Def.bnf list ->
           ('a * typ list list list list * term list list * 'b) option ->
             thm ->
               thm list ->
                 BNF_Def.bnf list ->
                   BNF_Def.bnf list ->
                     typ list ->
                       typ list ->
                         typ list ->
                           typ list list list ->
                             thm list ->
                               thm list ->
                                 thm list ->
                                   term list list ->
                                     thm list list ->
                                       term list ->
   thm list -> Proof.context -> lfp_sugar_thms
    val derive_map_set_rel_pred_thms:
       (string -> bool) ->
         BNF_Util.fp_kind ->
           int ->
             typ list ->
               typ list ->
                 typ ->
                   typ ->
                     thm list ->
                       thm list ->
                         thm list ->
                           thm list ->
                             thm list ->
                               thm list ->
                                 thm list ->
                                   thm list ->
                                     thm list ->
                                       string ->
   BNF_Def.bnf -> BNF_Def.bnf list -> typ -> ...
    val finish_induct_prem:
       Proof.context ->
         int ->
           term list ->
             term list * ((term * (term * term)) list * (int * term)) list *
             term
               -> term
    val flat_corec_preds_predsss_gettersss:
       'a list -> 'a list list list -> 'a list list list -> 'a list
    type fp_bnf_sugar =
       {map_disc_iffs: thm list,
        map_selss: thm list list,
        map_thms: thm list,
        pred_injects: thm list,
        rel_cases: thm list,
        rel_distincts: thm list,
        rel_injects: thm list,
        rel_intros: thm list,
        rel_sels: thm list,
        set_cases: thm list,
        set_introssss: thm list list list list,
        set_selssss: thm list list list list, set_thms: thm list}
    type fp_co_induct_sugar =
       {co_inducts: thm list,
        co_rec: term,
        co_rec_codes: thm list,
        co_rec_def: thm,
        co_rec_disc_iffs: thm list,
        co_rec_discs: thm list,
        co_rec_o_maps: thm list,
        co_rec_selss: thm list list,
        co_rec_thms: thm list,
        co_rec_transfers: thm list,
        common_co_inducts: thm list,
        common_rel_co_inducts: thm list,
        common_set_inducts: thm list,
        rel_co_inducts: thm list, set_inducts: thm list}
    type fp_ctr_sugar =
       {case_transfers: thm list,
        ctor_iff_dtor: thm,
        ctrXs_Tss: typ list list,
        ctr_defs: thm list,
        ctr_sugar: Ctr_Sugar.ctr_sugar,
        ctr_transfers: thm list,
        disc_transfers: thm list, sel_transfers: thm list}
    type fp_sugar =
       {BT: typ,
        T: typ,
        X: typ,
        absT_info: BNF_Comp.absT_info,
        fp: BNF_Util.fp_kind,
        fp_bnf: BNF_Def.bnf,
        fp_bnf_sugar: fp_bnf_sugar,
        fp_co_induct_sugar: fp_co_induct_sugar option,
        fp_ctr_sugar: fp_ctr_sugar,
        fp_nesting_bnfs: BNF_Def.bnf list,
        fp_res: BNF_FP_Util.fp_result,
        fp_res_index: int,
        live_nesting_bnfs: BNF_Def.bnf list, pre_bnf: BNF_Def.bnf}
    val fp_sugar_of: Proof.context -> string -> fp_sugar option
    val fp_sugar_of_global: theory -> string -> fp_sugar option
    val fp_sugars_interpretation:
       string ->
         (fp_sugar list -> local_theory -> local_theory) -> theory -> theory
    val fp_sugars_of: Proof.context -> fp_sugar list
    val fp_sugars_of_global: theory -> fp_sugar list
    type gfp_sugar_thms =
       ((thm list * thm) list * (Token.src list * Token.src list)) *
       thm list list * thm list list * (thm list list * Token.src list) *
       (thm list list list * Token.src list)
    val interpret_fp_sugars:
       (string -> bool) -> fp_sugar list -> local_theory -> local_theory
    type lfp_sugar_thms =
       (thm list * thm * Token.src list) * (thm list list * Token.src list)
    val liveness_of_fp_bnf: int -> BNF_Def.bnf -> bool list
    val map_binding_of_spec: ('a * ('b * 'c * 'd)) * 'e -> 'b
    val massage_multi_notes:
       string list ->
         typ list ->
           (string * 'a list list * (string -> 'b)) list ->
             ((binding * 'b) * ('a list * 'c list) list) list
    val massage_simple_notes:
       string ->
         (bstring * 'a list * (int -> 'b)) list ->
           ((binding * 'c list) * ('a list * 'b) list) list
    val merge_type_args: BNF_Util.fp_kind -> ''a list * ''a list -> ''a list
    val mixfix_of_spec: ((('a * 'b) * 'c) * 'd) * 'e -> 'b
    val mixfixed_ctr_specs_of_spec: (('a * 'b) * 'c) * 'd -> 'b
    val mk_bnf_sets: BNF_Def.bnf -> string * term list
    val mk_co_recs_prelims:
       Proof.context ->
         BNF_Util.fp_kind ->
           typ list list list ->
             typ list ->
               typ list ->
                 typ list ->
                   typ list ->
                     int list ->
                       int list list ->
                         term list ->
                           term list *
                           (typ list list * typ list list list list *
                            term list list * term list list list list
                           )
                           option
                           *
                           (string * term list * term list list *
                            (((term list list * ...) * term list list list)
                             *
                             typ list)
                           )
                           option
    val mk_coinduct_attrs:
       typ list ->
         term list list ->
           term list list ->
             int list list -> Token.src list * Token.src list
    val mk_coinduct_prem:
       Proof.context ->
         typ list list ->
           typ list list ->
             term list ->
               term ->
                 term ->
                   term ->
                     int ->
                       term list ->
                         term list list ->
                           term list ->
                             term list list -> typ list list -> term
    val mk_corec_fun_arg_types:
       typ list list list ->
         typ list ->
           typ list ->
             typ list ->
               int list ->
                 int list list ->
                   term ->
                     typ list list *
                     (typ list list list list * typ list list list *
                      typ list list list list * typ list)
    val mk_corec_p_pred_types: typ list -> int list -> typ list list
    val mk_ctor: typ list -> term -> term
    val mk_dtor: typ list -> term -> term
    val mk_induct_attrs: term list list -> Token.src list
    val mk_induct_raw_prem:
       (term -> term) ->
         Proof.context ->
           typ list list ->
             (string * term list) list ->
               term ->
                 term ->
                   typ list ->
                     typ list ->
                       term list *
                       ((term * (term * term)) list * (int * term)) list *
                       term
    val mk_parametricity_goal:
       Proof.context -> term list -> term -> term -> term
    val morph_fp_bnf_sugar: morphism -> fp_bnf_sugar -> fp_bnf_sugar
    val morph_fp_co_induct_sugar:
       morphism -> fp_co_induct_sugar -> fp_co_induct_sugar
    val morph_fp_ctr_sugar: morphism -> fp_ctr_sugar -> fp_ctr_sugar
    val morph_fp_sugar: morphism -> fp_sugar -> fp_sugar
    val morph_gfp_sugar_thms: morphism -> gfp_sugar_thms -> gfp_sugar_thms
    val morph_lfp_sugar_thms: morphism -> lfp_sugar_thms -> lfp_sugar_thms
    val nesting_bnfs:
       Proof.context -> typ list list list -> typ list -> BNF_Def.bnf list
    val parse_co_datatype:
       (Ctr_Sugar.ctr_options_cmd *
        ((((((binding option * (string * string option)) list * binding) *
            mixfix)
           *
           ((binding, binding * string) Ctr_Sugar.ctr_spec * mixfix) list)
          *
          (binding * binding * binding))
         *
         string list
        )
        list
       )
       parser
    val parse_co_datatype_cmd:
       BNF_Util.fp_kind ->
         (mixfix list ->
            binding list ->
              binding list ->
                binding list ->
                  binding list list ->
                    binding list ->
                      (string * sort) list ->
                        typ list * typ list list ->
                          BNF_Def.bnf list ->
                            BNF_Comp.absT_info list ->
                              local_theory ->
                                BNF_FP_Util.fp_result * local_theory)
           -> (local_theory -> local_theory) parser
    val parse_ctr_arg: (binding * string) parser
    val parse_ctr_specs:
       ((binding, binding * string) Ctr_Sugar.ctr_spec * mixfix) list parser
    val parse_spec:
       ((((((binding option * (string * string option)) list * binding) *
           mixfix)
          *
          ((binding, binding * string) Ctr_Sugar.ctr_spec * mixfix) list)
         *
         (binding * binding * binding))
        *
        string list
       )
       parser
    val pred_binding_of_spec: ('a * ('b * 'c * 'd)) * 'e -> 'd
    val register_fp_sugars:
       (string -> bool) -> fp_sugar list -> local_theory -> local_theory
    val register_fp_sugars_raw:
       fp_sugar list -> local_theory -> local_theory
    val rel_binding_of_spec: ('a * ('b * 'c * 'd)) * 'e -> 'c
    val repair_nullary_single_ctr: typ list list -> typ list list
    val sel_default_eqs_of_spec: 'a * 'b -> 'b
    val strong_co_induct_of: 'a list -> 'a
    val transfer_fp_sugar: theory -> fp_sugar -> fp_sugar
    val transfer_gfp_sugar_thms: theory -> gfp_sugar_thms -> gfp_sugar_thms
    val transfer_lfp_sugar_thms: theory -> lfp_sugar_thms -> lfp_sugar_thms
    val type_args_named_constrained_of_spec:
       (((('a * 'b) * 'c) * 'd) * 'e) * 'f -> 'a
    val type_binding_of_spec: (((('a * 'b) * 'c) * 'd) * 'e) * 'f -> 'b
    val wrap_ctrs:
       (string -> bool) ->
         BNF_Util.fp_kind ->
           bool ->
             string ->
               thm ->
                 int ->
                   int list ->
                     thm ->
                       thm ->
                         binding list ->
                           binding list list ->
                             term list ->
                               term list ->
                                 thm ->
                                   thm list ->
                                     local_theory ->
                                       Ctr_Sugar.ctr_sugar * local_theory
  end
structure BNF_FP_Def_Sugar: BNF_FP_DEF_SUGAR
signature BNF_FP_N2M_TACTICS =
  sig
    val mk_rel_xtor_co_induct_tac:
       BNF_Util.fp_kind ->
         thm list ->
           thm list ->
             thm list ->
               thm list ->
                 thm list ->
                   thm list ->
                     {context: Proof.context, prems: thm list} -> tactic
    val mk_xtor_un_fold_tac:
       Proof.context -> int -> thm list -> thm list -> tactic
    val mk_xtor_un_fold_transfer_tac:
       Proof.context ->
         int ->
           thm list ->
             thm list ->
               thm list ->
                 thm list -> thm list -> thm list -> thm list -> tactic
    val mk_xtor_un_fold_unique_tac:
       BNF_Util.fp_kind ->
         thm list ->
           thm list ->
             thm list ->
               thm list ->
                 thm list ->
                   thm list ->
                     thm list ->
                       thm list ->
                         thm list ->
                           {context: Proof.context, prems: thm list} ->
                             tactic
  end
structure BNF_FP_N2M_Tactics: BNF_FP_N2M_TACTICS
### ML warning (line 617 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m.ML"):
### A function value is being discarded.
signature BNF_FP_N2M =
  sig
    val construct_mutualized_fp:
       BNF_Util.fp_kind ->
         int list ->
           typ list ->
             (int * BNF_FP_Util.fp_result) list ->
               binding list ->
                 (string * sort) list ->
                   typ list * typ list list ->
                     BNF_Def.bnf list ->
                       BNF_Comp.absT_info list ->
                         local_theory ->
                           BNF_FP_Util.fp_result * local_theory
  end
structure BNF_FP_N2M: BNF_FP_N2M
### ML warning (line 103 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 113 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 189 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 225 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 231 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 295 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Value identifier (timer) has not been referenced.
### ML warning (line 300 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 375 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 404 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 406 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 421 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 430 of "~~/src/HOL/Tools/BNF/bnf_fp_n2m_sugar.ML"):
### Pattern is not exhaustive.
signature BNF_FP_N2M_SUGAR =
  sig
    val dest_map: Proof.context -> string -> term -> term * term list
    val dest_pred: Proof.context -> string -> term -> term * term list
    val mutualize_fp_sugars:
       (string -> bool) ->
         BNF_Util.fp_kind ->
           int list ->
             binding list ->
               typ list ->
                 term list ->
                   term list list list list ->
                     BNF_FP_Def_Sugar.fp_sugar list ->
                       local_theory ->
                         (BNF_FP_Def_Sugar.fp_sugar list *
                          (BNF_FP_Def_Sugar.lfp_sugar_thms option *
                           BNF_FP_Def_Sugar.gfp_sugar_thms option))
                         *
                         local_theory
    val nested_to_mutual_fps:
       (string -> bool) ->
         BNF_Util.fp_kind ->
           binding list ->
             typ list ->
               term list ->
                 (term * term list list) list list ->
                   local_theory ->
                     (typ list * int list * BNF_FP_Def_Sugar.fp_sugar list *
                      (BNF_FP_Def_Sugar.lfp_sugar_thms option *
                       BNF_FP_Def_Sugar.gfp_sugar_thms option))
                     *
                     local_theory
    val unfold_lets_splits: term -> term
    val unfold_splits_lets: term -> term
  end
structure BNF_FP_N2M_Sugar: BNF_FP_N2M_SUGAR
### theory "HOL.BNF_Fixpoint_Base"
### 2.621s elapsed time, 2.771s cpu time, 0.212s GC time
Loading theory "HOL.BNF_Least_Fixpoint" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num")
signature BNF_LFP_UTIL =
  sig
    val mk_bij_betw: term -> term -> term -> term
    val mk_cardSuc: term -> term
    val mk_not_empty: term -> term
    val mk_not_eq: term -> term -> term
    val mk_rapp: term -> typ -> term
    val mk_relChain: term -> term -> term
    val mk_underS: term -> term
    val mk_worec: term -> term -> term
  end
structure BNF_LFP_Util: BNF_LFP_UTIL
signature BNF_LFP_TACTICS =
  sig
    val mk_alg_min_alg_tac:
       Proof.context ->
         int ->
           thm ->
             thm list ->
               thm -> thm -> thm list list -> thm list -> thm list -> tactic
    val mk_alg_not_empty_tac:
       Proof.context -> thm -> thm list -> thm list -> tactic
    val mk_alg_select_tac: Proof.context -> thm -> tactic
    val mk_alg_set_tac: Proof.context -> thm -> tactic
    val mk_bd_card_order_tac: Proof.context -> thm list -> tactic
    val mk_bd_limit_tac: Proof.context -> int -> thm -> tactic
    val mk_card_of_min_alg_tac:
       Proof.context -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_copy_tac:
       Proof.context ->
         int -> thm -> thm -> thm list -> thm list list -> tactic
    val mk_ctor_induct2_tac:
       Proof.context ->
         ctyp option list -> cterm option list -> thm -> thm list -> tactic
    val mk_ctor_induct_tac:
       Proof.context ->
         int ->
           thm list list ->
             thm ->
               thm list -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_ctor_map_unique_tac: Proof.context -> thm -> thm list -> tactic
    val mk_ctor_rec_transfer_tac:
       Proof.context ->
         int ->
           int -> thm list -> thm list -> thm list -> thm list -> tactic
    val mk_ctor_rel_tac:
       Proof.context ->
         thm list ->
           int ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm list ->
                       thm ->
                         thm ->
                           thm list -> thm list -> thm list list -> tactic
    val mk_ctor_set_tac: Proof.context -> thm -> thm -> thm list -> tactic
    val mk_dtor_o_ctor_tac:
       Proof.context -> thm -> thm -> thm -> thm -> thm list -> tactic
    val mk_fold_transfer_tac:
       Proof.context -> int -> thm -> thm list -> thm list -> tactic
    val mk_fold_unique_mor_tac:
       Proof.context ->
         thm list -> thm list -> thm list -> thm -> thm -> thm -> tactic
    val mk_init_ex_mor_tac:
       Proof.context ->
         thm -> thm -> thm list -> thm -> thm -> thm -> thm -> tactic
    val mk_init_induct_tac:
       Proof.context -> int -> thm -> thm -> thm list -> thm list -> tactic
    val mk_init_unique_mor_tac:
       Proof.context ->
         cterm list ->
           int ->
             thm ->
               thm ->
                 thm list ->
                   thm list -> thm list -> thm list -> thm list -> tactic
    val mk_le_rel_OO_tac:
       Proof.context ->
         int ->
           thm -> thm list -> thm list -> thm list -> thm list -> tactic
    val mk_least_min_alg_tac: Proof.context -> thm -> thm -> tactic
    val mk_map_comp0_tac:
       Proof.context -> thm list -> thm list -> thm -> int -> tactic
    val mk_map_id0_tac: Proof.context -> thm list -> thm -> tactic
    val mk_map_tac:
       Proof.context -> int -> int -> thm -> thm -> thm -> tactic
    val mk_mcong_tac:
       Proof.context ->
         (int -> tactic) ->
           thm list list list -> thm list -> thm list -> tactic
    val mk_min_algs_card_of_tac:
       Proof.context ->
         ctyp ->
           cterm ->
             int ->
               thm ->
                 thm list ->
                   thm list ->
                     thm -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_min_algs_least_tac:
       Proof.context ->
         ctyp -> cterm -> thm -> thm list -> thm list -> tactic
    val mk_min_algs_mono_tac: Proof.context -> thm -> tactic
    val mk_min_algs_tac: Proof.context -> thm -> thm list -> tactic
    val mk_mor_Abs_tac:
       Proof.context ->
         cterm list ->
           thm list -> thm list -> thm list -> thm list -> tactic
    val mk_mor_Rep_tac:
       Proof.context ->
         int ->
           thm list ->
             thm list ->
               thm list -> thm -> thm list -> thm list list -> tactic
    val mk_mor_UNIV_tac: Proof.context -> int -> thm list -> thm -> tactic
    val mk_mor_comp_tac:
       Proof.context -> thm -> thm list list -> thm list -> tactic
    val mk_mor_elim_tac: Proof.context -> thm -> tactic
    val mk_mor_fold_tac:
       Proof.context -> ctyp -> cterm -> thm list -> thm -> thm -> tactic
    val mk_mor_incl_tac: Proof.context -> thm -> thm list -> tactic
    val mk_mor_select_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm -> thm list -> thm list list -> thm list -> tactic
    val mk_mor_str_tac: Proof.context -> 'a list -> thm -> tactic
    val mk_rec_tac: Proof.context -> thm list -> thm -> thm list -> tactic
    val mk_rec_unique_mor_tac:
       Proof.context -> thm list -> thm list -> thm -> tactic
    val mk_rel_induct_tac:
       Proof.context ->
         thm list ->
           int -> thm -> int list -> thm list -> thm list -> tactic
    val mk_set_bd_tac:
       Proof.context ->
         int ->
           (int -> tactic) ->
             thm -> thm list list -> thm list -> int -> tactic
    val mk_set_map0_tac: Proof.context -> thm -> tactic
    val mk_set_nat_tac:
       Proof.context ->
         int ->
           (int -> tactic) ->
             thm list list ->
               thm list -> cterm list -> thm list -> int -> tactic
    val mk_set_tac: Proof.context -> thm -> tactic
    val mk_wit_tac: Proof.context -> int -> thm list -> thm list -> tactic
  end
structure BNF_LFP_Tactics: BNF_LFP_TACTICS
### ML warning (line 1866 of "~~/src/HOL/Tools/BNF/bnf_lfp.ML"):
### A function value is being discarded.
signature BNF_LFP =
  sig
    val construct_lfp:
       mixfix list ->
         binding list ->
           binding list ->
             binding list ->
               binding list list ->
                 binding list ->
                   (string * sort) list ->
                     typ list * typ list list ->
                       BNF_Def.bnf list ->
                         BNF_Comp.absT_info list ->
                           local_theory ->
                             BNF_FP_Util.fp_result * local_theory
  end
structure BNF_LFP: BNF_LFP
### ML warning (line 58 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 56 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 121 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 178 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 223 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Pattern is not exhaustive.
### ML warning (line 226 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Pattern is not exhaustive.
### ML warning (line 230 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 231 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 239 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 242 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Pattern is not exhaustive.
### ML warning (line 246 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Pattern is not exhaustive.
### ML warning (line 297 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 304 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Pattern is not exhaustive.
### ML warning (line 327 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 358 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
### ML warning (line 395 of "~~/src/HOL/Tools/BNF/bnf_lfp_compat.ML"):
### Matches are not exhaustive.
signature BNF_LFP_COMPAT =
  sig
    val add_datatype:
       preference list ->
         Old_Datatype_Aux.spec list -> theory -> string list * theory
    val datatype_compat: string list -> local_theory -> local_theory
    val datatype_compat_cmd: string list -> local_theory -> local_theory
    val datatype_compat_global: string list -> theory -> theory
    val get_all:
       theory -> preference list -> Old_Datatype_Aux.info Symtab.table
    val get_constrs: theory -> string -> (string * typ) list option
    val get_info:
       theory -> preference list -> string -> Old_Datatype_Aux.info option
    val interpretation:
       string ->
         preference list ->
           (Old_Datatype_Aux.config -> string list -> theory -> theory) ->
             theory -> theory
    datatype preference = Include_GFPs | Keep_Nesting | Kill_Type_Args
    val primrec:
       (binding * typ option * mixfix) list ->
         Specification.multi_specs ->
           local_theory -> (term list * thm list) * local_theory
    val primrec_global:
       (binding * typ option * mixfix) list ->
         Specification.multi_specs ->
           theory -> (term list * thm list) * theory
    val primrec_overloaded:
       (string * (string * typ) * bool) list ->
         (binding * typ option * mixfix) list ->
           Specification.multi_specs ->
             theory -> (term list * thm list) * theory
    val primrec_simple:
       ((binding * typ) * mixfix) list ->
         term list ->
           local_theory ->
             (string list * (term list * thm list)) * local_theory
    val the_descr:
       theory ->
         preference list ->
           string list ->
             Old_Datatype_Aux.descr * (string * sort) list * string list *
             string * (string list * string list) * (typ list * typ list)
    val the_info:
       theory -> preference list -> string -> Old_Datatype_Aux.info
    val the_spec:
       theory -> string -> (string * sort) list * (string * typ list) list
  end
structure BNF_LFP_Compat: BNF_LFP_COMPAT
### ML warning (line 45 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar_more.ML"):
### Matches are not exhaustive.
### ML warning (line 54 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar_more.ML"):
### Pattern is not exhaustive.
### ML warning (line 111 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar_more.ML"):
### Pattern is not exhaustive.
### ML warning (line 174 of "~~/src/HOL/Tools/BNF/bnf_lfp_rec_sugar_more.ML"):
### Matches are not exhaustive.
signature BNF_LFP_REC_SUGAR_MORE =
  sig
    val massage_nested_rec_call:
       Proof.context ->
         (term -> bool) ->
           (typ -> typ -> term -> term) ->
             (typ * typ -> term) -> typ list -> term -> term -> term -> term
  end
structure BNF_LFP_Rec_Sugar_More: BNF_LFP_REC_SUGAR_MORE
### ML warning (line 113 of "~~/src/HOL/Tools/BNF/bnf_lfp_size.ML"):
### Pattern is not exhaustive.
### ML warning (line 137 of "~~/src/HOL/Tools/BNF/bnf_lfp_size.ML"):
### Matches are not exhaustive.
### ML warning (line 235 of "~~/src/HOL/Tools/BNF/bnf_lfp_size.ML"):
### Pattern is not exhaustive.
### ML warning (line 283 of "~~/src/HOL/Tools/BNF/bnf_lfp_size.ML"):
### Pattern is not exhaustive.
### ML warning (line 331 of "~~/src/HOL/Tools/BNF/bnf_lfp_size.ML"):
### Matches are not exhaustive.
### ML warning (line 345 of "~~/src/HOL/Tools/BNF/bnf_lfp_size.ML"):
### Matches are not exhaustive.
### ML warning (line 386 of "~~/src/HOL/Tools/BNF/bnf_lfp_size.ML"):
### Matches are not exhaustive.
signature BNF_LFP_SIZE =
  sig
    val register_size:
       string ->
         string ->
           thm -> thm list -> thm list -> local_theory -> local_theory
    val register_size_global:
       string -> string -> thm -> thm list -> thm list -> theory -> theory
    val size_of:
       Proof.context ->
         string -> (string * (thm * thm list * thm list)) option
    val size_of_global:
       theory -> string -> (string * (thm * thm list * thm list)) option
  end
structure BNF_LFP_Size: BNF_LFP_SIZE
### ML warning (line 95 of "~~/src/HOL/Tools/datatype_simprocs.ML"):
### Value identifier (T_args) has not been referenced.
signature DATATYPE_SIMPROCS =
  sig
    val no_proper_subterm_simproc: Proof.context -> cterm -> thm option
  end
structure Datatype_Simprocs: DATATYPE_SIMPROCS
### theory "HOL.BNF_Least_Fixpoint"
### 2.324s elapsed time, 2.468s cpu time, 0.220s GC time
Loading theory "HOL.Basic_BNF_LFPs" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num" via "HOL.Transfer")
### ML warning (line 55 of "~~/src/HOL/Tools/BNF/bnf_lfp_basic_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 127 of "~~/src/HOL/Tools/BNF/bnf_lfp_basic_sugar.ML"):
### Pattern is not exhaustive.
structure BNF_LFP_Basic_Sugar: sig end
### theory "HOL.Basic_BNF_LFPs"
### 0.132s elapsed time, 0.144s cpu time, 0.019s GC time
Loading theory "HOL.Transfer" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power" via "HOL.Num")
bundle lifting_syntax
### ML warning (line 437 of "~~/src/HOL/Tools/Transfer/transfer.ML"):
### Pattern is not exhaustive.
signature TRANSFER =
  sig
    val eq_tac: Proof.context -> int -> tactic
    val fold_relator_eqs_conv: Proof.context -> conv
    val gen_frees_tac: (string * typ) list -> Proof.context -> int -> tactic
    val get_relator_domain: Proof.context -> thm list
    val get_relator_eq: Proof.context -> thm list
    val get_relator_eq_raw: Proof.context -> thm list
    val get_sym_relator_eq: Proof.context -> thm list
    val get_transfer_raw: Proof.context -> thm list
    val is_compound_lhs: Proof.context -> term -> bool
    val is_compound_rhs: Proof.context -> term -> bool
    val lookup_pred_data: Proof.context -> string -> pred_data option
    val mk_pred_data: thm -> thm -> thm list -> pred_data
    val morph_pred_data: morphism -> pred_data -> pred_data
    type pred_data
    val pred_def: pred_data -> thm
    val pred_simps: pred_data -> thm list
    val prep_conv: conv
    val prep_transfer_domain_thm: Proof.context -> thm -> thm
    val rel_eq_onp: pred_data -> thm
    val retrieve_relator_eq: Proof.context -> term -> thm list
    val transfer_add: attribute
    val transfer_del: attribute
    val transfer_domain_add: attribute
    val transfer_domain_del: attribute
    val transfer_end_tac: Proof.context -> int -> tactic
    val transfer_prover_end_tac: Proof.context -> int -> tactic
    val transfer_prover_start_tac: Proof.context -> int -> tactic
    val transfer_prover_tac: Proof.context -> int -> tactic
    val transfer_raw_add: thm -> Context.generic -> Context.generic
    val transfer_raw_del: thm -> Context.generic -> Context.generic
    val transfer_rule_of_lhs: Proof.context -> term -> thm
    val transfer_rule_of_term: Proof.context -> bool -> term -> thm
    val transfer_start_tac: bool -> Proof.context -> int -> tactic
    val transfer_step_tac: Proof.context -> int -> tactic
    val transfer_tac: bool -> Proof.context -> int -> tactic
    val transferred_attribute: thm list -> attribute
    val unfold_relator_eqs_conv: Proof.context -> conv
    val untransferred_attribute: thm list -> attribute
    val update_pred_data:
       string -> pred_data -> Context.generic -> Context.generic
    val update_pred_simps: thm list -> pred_data -> pred_data
  end
structure Transfer: TRANSFER
signature TRANSFER_BNF =
  sig
    exception NO_PRED_DATA of unit
    val base_name_of_bnf: BNF_Def.bnf -> binding
    val bnf_only_type_ctr:
       (BNF_Def.bnf -> 'a -> 'a) -> BNF_Def.bnf -> 'a -> 'a
    val lookup_defined_pred_data:
       Proof.context -> string -> Transfer.pred_data
    val type_name_of_bnf: BNF_Def.bnf -> string
  end
structure Transfer_BNF: TRANSFER_BNF
### ML warning (line 45 of "~~/src/HOL/Tools/BNF/bnf_fp_rec_sugar_transfer.ML"):
### Pattern is not exhaustive.
### ML warning (line 79 of "~~/src/HOL/Tools/BNF/bnf_fp_rec_sugar_transfer.ML"):
### Matches are not exhaustive.
signature BNF_FP_REC_SUGAR_TRANSFER =
  sig
    val gfp_rec_sugar_transfer_interpretation:
       BNF_FP_Rec_Sugar_Util.fp_rec_sugar -> Proof.context -> Proof.context
    val lfp_rec_sugar_transfer_interpretation:
       BNF_FP_Rec_Sugar_Util.fp_rec_sugar -> Proof.context -> Proof.context
    val set_transfer_rule_attrs: thm list -> local_theory -> local_theory
  end
structure BNF_FP_Rec_Sugar_Transfer: BNF_FP_REC_SUGAR_TRANSFER
### theory "HOL.Transfer"
### 0.680s elapsed time, 0.711s cpu time, 0.044s GC time
Loading theory "HOL.Num" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big" via "HOL.Power")
consts
  inc :: "num => num"
consts
  nat_of_num :: "num => nat"
consts
  num_of_nat :: "nat => num"
instantiation
  num :: {plus,times,linorder}
  less_eq_num == less_eq :: num => num => bool
  less_num == less :: num => num => bool
  times_num == times :: num => num => num
  plus_num == plus :: num => num => num
consts
  BitM :: "num => num"
consts
  sqr :: "num => num"
consts
  pow :: "num => num => num"
consts
  numeral :: "num => 'a"
### ML warning (line 20 of "~~/src/HOL/Tools/numeral.ML"):
### Matches are not exhaustive.
### ML warning (line 27 of "~~/src/HOL/Tools/numeral.ML"):
### Matches are not exhaustive.
### ML warning (line 105 of "~~/src/HOL/Tools/numeral.ML"):
### Matches are not exhaustive.
signature NUMERAL =
  sig
    val add_code:
       string ->
         (int -> int) ->
           (Code_Printer.literals -> int -> string) ->
             string -> theory -> theory
    val dest_num_syntax: term -> int
    val mk_cnumber: ctyp -> int -> cterm
    val mk_number_syntax: int -> term
  end
structure Numeral: NUMERAL
Proofs for inductive predicate(s) "is_num"
  Proving monotonicity ...
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
class linordered_nonzero_semiring = semiring_char_0 + linorder +
  comm_semiring_1 + ordered_comm_semiring + zero_less_one +
  assumes "add_mono1": "!!a b. a < b ==> a + (1::'a) < b + (1::'a)"
class linordered_idom = idom_abs_sgn + linordered_ring_strict +
  linordered_semidom + linordered_semiring_1_strict + ordered_comm_ring +
  ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### Ignoring duplicate rewrite rule:
### (0::?'a1) + ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y + (0::?'a1) == ?y
### Ignoring duplicate rewrite rule:
### - (0::?'a1) == 0::?'a1
### Ignoring duplicate rewrite rule:
### (0::?'a1) <= (1::?'a1) == True
### Ignoring duplicate rewrite rule:
### (1::?'a1) <= (0::?'a1) == False
### Ignoring duplicate rewrite rule:
### (1::?'a1) < (0::?'a1) == False
### Ignoring duplicate rewrite rule:
### (0::?'a1) = (1::?'a1) == False
### Ignoring duplicate rewrite rule:
### (0::?'a1) + ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y + (0::?'a1) == ?y
### Ignoring duplicate rewrite rule:
### - (0::?'a1) == 0::?'a1
### Ignoring duplicate rewrite rule:
### (0::?'a1) <= (1::?'a1) == True
### Ignoring duplicate rewrite rule:
### (1::?'a1) <= (0::?'a1) == False
### Ignoring duplicate rewrite rule:
### (1::?'a1) < (0::?'a1) == False
### Ignoring duplicate rewrite rule:
### (0::?'a1) = (1::?'a1) == False
### theory "HOL.Num"
### 1.482s elapsed time, 1.596s cpu time, 0.156s GC time
Loading theory "HOL.Power" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations" via "HOL.Groups_Big")
consts
  power :: "'a => nat => 'a"
class monoid_mult = one + semigroup_mult +
  assumes "mult_1_left": "!!a. (1::'a) * a = a"
    and "mult_1_right": "!!a. a * (1::'a) = a"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
class semidom_divide = divide + semidom + semiring_no_zero_divisors_cancel +
  assumes
    "nonzero_mult_div_cancel_right":
      "!!b a. b ~= (0::'a) ==> a * b div b = a"
  assumes "div_by_0": "!!a. a div (0::'a) = (0::'a)"
class normalization_semidom_multiplicative = normalization_semidom +
  assumes
    "unit_factor_mult":
      "!!a b. unit_factor (a * b) = unit_factor a * unit_factor b"
class division_ring = inverse + ring_1_no_zero_divisors +
  assumes "left_inverse": "!!a. a ~= (0::'a) ==> inverse a * a = (1::'a)"
  assumes "right_inverse": "!!a. a ~= (0::'a) ==> a * inverse a = (1::'a)"
  assumes "divide_inverse": "!!a b. a / b = a * inverse b"
  assumes "inverse_zero": "inverse (0::'a) = (0::'a)"
class field = division_ring + idom_divide +
  assumes "field_inverse": "!!a. a ~= (0::'a) ==> inverse a * a = (1::'a)"
  assumes "field_divide_inverse": "!!a b. a / b = a * inverse b"
  assumes "field_inverse_zero": "inverse (0::'a) = (0::'a)"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
### theory "HOL.Power"
### 1.271s elapsed time, 1.397s cpu time, 0.138s GC time
Loading theory "HOL.Groups_Big" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Equiv_Relations")
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
class linordered_nonzero_semiring = semiring_char_0 + linorder +
  comm_semiring_1 + ordered_comm_semiring + zero_less_one +
  assumes "add_mono1": "!!a b. a < b ==> a + (1::'a) < b + (1::'a)"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
### theory "HOL.Groups_Big"
### 1.010s elapsed time, 1.132s cpu time, 0.147s GC time
Loading theory "HOL.Equiv_Relations" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int")
### theory "HOL.Equiv_Relations"
### 0.215s elapsed time, 0.254s cpu time, 0.000s GC time
Loading theory "HOL.Lifting" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Quotient")
signature LIFTING_UTIL =
  sig
    val MRSL: thm list * thm -> thm
    val Quotient_R_conv: conv -> conv
    val Quotient_conv: conv -> conv -> conv -> conv -> conv
    val Targs: typ -> typ list
    val Tname: typ -> string
    val all_args_conv: conv -> conv
    val conceal_naming_result:
       (local_theory -> 'a * local_theory) ->
         local_theory -> 'a * local_theory
    val dest_Quotient: term -> term * term * term * term
    val get_args: int -> term -> term list
    val is_fun_type: typ -> bool
    val is_rel_fun: term -> bool
    val map_interrupt: ('a -> 'b option) -> 'a list -> 'b list option
    val quot_thm_abs: thm -> term
    val quot_thm_crel: thm -> term
    val quot_thm_rel: thm -> term
    val quot_thm_rep: thm -> term
    val quot_thm_rty_qty: thm -> typ * typ
    val relation_types: typ -> typ * typ
    val same_type_constrs: typ * typ -> bool
    val strip_args: int -> term -> term
    val undisch: thm -> thm
    val undisch_all: thm -> thm
  end
structure Lifting_Util: LIFTING_UTIL
### ML warning (line 159 of "~~/src/HOL/Tools/Lifting/lifting_info.ML"):
### Pattern is not exhaustive.
### ML warning (line 316 of "~~/src/HOL/Tools/Lifting/lifting_info.ML"):
### Value identifier (map_pos_mono_rule) has not been referenced.
### ML warning (line 317 of "~~/src/HOL/Tools/Lifting/lifting_info.ML"):
### Value identifier (map_neg_mono_rule) has not been referenced.
### ML warning (line 508 of "~~/src/HOL/Tools/Lifting/lifting_info.ML"):
### Matches are not exhaustive.
signature LIFTING_INFO =
  sig
    val add_no_code_type: string -> Context.generic -> Context.generic
    val add_reflexivity_rule_attribute: attribute
    val add_transfer_rules_in_restore_data:
       string -> thm Item_Net.T -> Context.generic -> Context.generic
    val delete_quotients: thm -> Context.generic -> Context.generic
    val get_no_code_types: Proof.context -> unit Symtab.table
    val get_quot_maps: Proof.context -> quot_map Symtab.table
    val get_quotients: Proof.context -> quotient Symtab.table
    val get_reflexivity_rules: Proof.context -> thm list
    val get_relator_distr_data:
       Proof.context -> relator_distr_data Symtab.table
    val get_relator_eq_onp_rules: Proof.context -> thm list
    val get_restore_data: Proof.context -> restore_data Symtab.table
    val init_restore_data:
       string -> quotient -> Context.generic -> Context.generic
    val is_no_code_type: Proof.context -> string -> bool
    val lookup_quot_maps: Proof.context -> string -> quot_map option
    val lookup_quot_thm_quotients: Proof.context -> thm -> quotient option
    val lookup_quotients: Proof.context -> string -> quotient option
    val lookup_relator_distr_data:
       Proof.context -> string -> relator_distr_data option
    val lookup_restore_data: Proof.context -> string -> restore_data option
    type pcr = {pcr_cr_eq: thm, pcrel_def: thm}
    val pcr_eq: pcr * pcr -> bool
    val print_quot_maps: Proof.context -> unit
    val print_quotients: Proof.context -> unit
    type quot_map = {rel_quot_thm: thm}
    type quotient = {pcr_info: pcr option, quot_thm: thm}
    val quotient_eq: quotient * quotient -> bool
    type relator_distr_data =
       {neg_distr_rules: thm list,
        neg_mono_rule: thm, pos_distr_rules: thm list, pos_mono_rule: thm}
    type restore_data = {quotient: quotient, transfer_rules: thm Item_Net.T}
    val transform_quotient: morphism -> quotient -> quotient
    val update_quotients:
       string -> quotient -> Context.generic -> Context.generic
  end
structure Lifting_Info: LIFTING_INFO
signature LIFTING_BNF = sig end
structure Lifting_BNF: LIFTING_BNF
### ML warning (line 111 of "~~/src/HOL/Tools/Lifting/lifting_term.ML"):
### Matches are not exhaustive.
### ML warning (line 483 of "~~/src/HOL/Tools/Lifting/lifting_term.ML"):
### Matches are not exhaustive.
signature LIFTING_TERM =
  sig
    exception CHECK_RTY of typ * typ
    exception MERGE_TRANSFER_REL of Pretty.T
    exception PARAM_QUOT_THM of typ * Pretty.T
    exception QUOT_THM of typ * typ * Pretty.T
    val abs_fun: Proof.context -> typ * typ -> term
    val equiv_relation: Proof.context -> typ * typ -> term
    type 'a fold_quot_thm =
       {comp_lift: typ -> thm * 'a -> thm * 'a,
        constr: typ -> thm * 'a -> thm * 'a,
        lift: typ -> thm * 'a -> thm * 'a}
    val force_qty_type: Proof.context -> typ -> thm -> thm
    val generate_parametrized_relator:
       Proof.context -> typ -> term * term list
    val instantiate_rtys: Proof.context -> typ * typ -> typ * typ
    val merge_transfer_relations: Proof.context -> cterm -> thm
    val parametrize_transfer_rule: Proof.context -> thm -> thm
    val prove_param_quot_thm:
       Proof.context -> typ -> thm * (typ * thm) list * Proof.context
    val prove_quot_thm: Proof.context -> typ * typ -> thm
    val prove_schematic_quot_thm:
       'a fold_quot_thm ->
         quotients -> Proof.context -> typ * typ -> 'a -> thm * 'a
    type quotients = Lifting_Info.quotient Symtab.table
  end
structure Lifting_Term: LIFTING_TERM
### ML warning (line 194 of "~~/src/HOL/Tools/Lifting/lifting_def.ML"):
### Pattern is not exhaustive.
### ML warning (line 506 of "~~/src/HOL/Tools/Lifting/lifting_def.ML"):
### Pattern is not exhaustive.
signature LIFTING_DEF =
  sig
    val abs_eq_of_lift_def: lift_def -> thm
    val add_lift_def:
       config ->
         binding * mixfix ->
           typ ->
             term ->
               thm -> thm list -> local_theory -> lift_def * local_theory
    val can_generate_code_cert: thm -> bool
    datatype code_eq = ABS_EQ | NONE_EQ | REP_EQ | UNKNOWN_EQ
    val code_eq_of_lift_def: lift_def -> code_eq
    type config = {notes: bool}
    val def_thm_of_lift_def: lift_def -> thm
    val default_config: config
    val gen_lift_def:
       (binding * mixfix ->
          typ ->
            term ->
              thm -> thm list -> local_theory -> lift_def * local_theory)
         ->
         binding * mixfix ->
           typ ->
             term ->
               (Proof.context -> tactic) ->
                 thm list -> local_theory -> lift_def * local_theory
    val generate_parametric_transfer_rule:
       Proof.context -> thm -> thm -> thm
    val inst_of_lift_def: Proof.context -> typ -> lift_def -> lift_def
    val lift_const_of_lift_def: lift_def -> term
    val lift_def:
       config ->
         binding * mixfix ->
           typ ->
             term ->
               (Proof.context -> tactic) ->
                 thm list -> local_theory -> lift_def * local_theory
    type lift_def
    val map_config: (bool -> bool) -> config -> config
    val mk_lift_const_of_lift_def: typ -> lift_def -> term
    val morph_lift_def: morphism -> lift_def -> lift_def
    val prepare_lift_def:
       (binding * mixfix ->
          typ ->
            term ->
              thm -> thm list -> Proof.context -> lift_def * local_theory)
         ->
         binding * mixfix ->
           typ ->
             term ->
               thm list ->
                 local_theory ->
                   term option *
                   (thm -> Proof.context -> lift_def * local_theory)
    val qty_of_lift_def: lift_def -> typ
    val rep_eq_of_lift_def: lift_def -> thm option
    val rhs_of_lift_def: lift_def -> term
    val rsp_thm_of_lift_def: lift_def -> thm
    val rty_of_lift_def: lift_def -> typ
    val transfer_rules_of_lift_def: lift_def -> thm list
  end
structure Lifting_Def: LIFTING_DEF
### ML warning (line 72 of "~~/src/HOL/Tools/Lifting/lifting_setup.ML"):
### Pattern is not exhaustive.
### ML warning (line 209 of "~~/src/HOL/Tools/Lifting/lifting_setup.ML"):
### Pattern is not exhaustive.
### ML warning (line 641 of "~~/src/HOL/Tools/Lifting/lifting_setup.ML"):
### Pattern is not exhaustive.
signature LIFTING_SETUP =
  sig
    exception SETUP_LIFTING_INFR of string
    type config = {notes: bool}
    val default_config: config
    val lifting_forget: string -> local_theory -> local_theory
    val lifting_restore:
       Lifting_Info.quotient -> Context.generic -> Context.generic
    val pointer_of_bundle_binding: Proof.context -> binding -> string
    val setup_by_quotient:
       config ->
         thm ->
           thm option ->
             thm option -> local_theory -> binding * local_theory
    val setup_by_typedef_thm:
       config -> thm -> local_theory -> binding * local_theory
    val update_transfer_rules: string -> local_theory -> local_theory
  end
structure Lifting_Setup: LIFTING_SETUP
### ML warning (line 779 of "~~/src/HOL/Tools/Lifting/lifting_def_code_dt.ML"):
### Pattern is not exhaustive.
### ML warning (line 794 of "~~/src/HOL/Tools/Lifting/lifting_def_code_dt.ML"):
### Matches are not exhaustive.
signature LIFTING_DEF_CODE_DT =
  sig
    val add_lift_def_code_dt:
       config_code_dt ->
         binding * mixfix ->
           typ ->
             term ->
               thm ->
                 thm list ->
                   local_theory -> Lifting_Def.lift_def * local_theory
    val all_code_dt_of: Proof.context -> code_dt list
    val all_code_dt_of_global: theory -> code_dt list
    val bundle_name_of_rep_isom_data: rep_isom_data -> string
    type code_dt
    val code_dt_of: Proof.context -> typ * typ -> code_dt option
    val code_dt_of_global: theory -> typ * typ -> code_dt option
    type config_code_dt = {code_dt: bool, lift_config: Lifting_Def.config}
    val default_config_code_dt: config_code_dt
    val isom_of_rep_isom_data: rep_isom_data -> term
    val lift_def_cmd:
       string list * (binding * string option * mixfix) * string *
       (Facts.ref * Token.src list) list
         -> local_theory -> Proof.state
    val lift_def_code_dt:
       config_code_dt ->
         binding * mixfix ->
           typ ->
             term ->
               (Proof.context -> tactic) ->
                 thm list ->
                   local_theory -> Lifting_Def.lift_def * local_theory
    val mk_rep_isom_of_code_dt: typ -> code_dt -> term option
    val mk_witness_of_code_dt: typ -> code_dt -> term
    val morph_code_dt: morphism -> code_dt -> code_dt
    val pointer_of_rep_isom_data: rep_isom_data -> string
    val qty_of_code_dt: code_dt -> typ
    type rep_isom_data
    val rep_isom_data_of_code_dt: code_dt -> rep_isom_data option
    val rty_of_code_dt: code_dt -> typ
    val transfer_of_rep_isom_data: rep_isom_data -> thm
    val wit_of_code_dt: code_dt -> term
    val wit_thm_of_code_dt: code_dt -> thm
  end
structure Lifting_Def_Code_Dt: LIFTING_DEF_CODE_DT
### theory "HOL.Lifting"
### 1.003s elapsed time, 1.090s cpu time, 0.120s GC time
Loading theory "HOL.Lifting_Set" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List")
Loading theory "HOL.Option" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Fun_Def" via "HOL.Partial_Function")
Loading theory "HOL.Quotient" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int")
### theory "HOL.Lifting_Set"
### 0.203s elapsed time, 0.620s cpu time, 0.075s GC time
locale quot_type
  fixes R :: "'a => 'a => bool"
    and Abs :: "'a set => 'b"
    and Rep :: "'b => 'a set"
  assumes "quot_type R Abs Rep"
consts
  bind :: "'a option => ('a => 'b option) => 'b option"
### theory "HOL.Option"
### 0.379s elapsed time, 0.972s cpu time, 0.075s GC time
Loading theory "HOL.Extraction" (required by "Draft.Pairing_AxiomTemplates" via "Main")
Loading theory "HOL.Lattices_Big" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division")
Loading theory "HOL.Partial_Function" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int" via "HOL.Fun_Def")
locale semilattice_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
  assumes "semilattice_set (\<^bold>*)"
locale semilattice_order_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes "semilattice_order_set (\<^bold>*) (\<^bold>\<le>) (\<^bold><)"
locale semilattice_neutr_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "semilattice_neutr_set (\<^bold>*) \<^bold>1"
locale semilattice_order_neutr_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
    and
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes
    "semilattice_order_neutr_set (\<^bold>*) \<^bold>1 (\<^bold>\<le>)
      (\<^bold><)"
class semilattice_inf = inf + order +
  assumes "inf_le1": "!!x y. x \<sqinter> y <= x"
    and "inf_le2": "!!x y. x \<sqinter> y <= y"
    and
    "inf_greatest": "!!x y z. [| x <= y; x <= z |] ==> x <= y \<sqinter> z"
class semilattice_sup = sup + order +
  assumes "sup_ge1": "!!x y. x <= x \<squnion> y"
    and "sup_ge2": "!!y x. y <= x \<squnion> y"
    and "sup_least": "!!y x z. [| y <= x; z <= x |] ==> y \<squnion> z <= x"
signature QUOTIENT_INFO =
  sig
    type abs_rep = {abs: term, rep: term}
    val dest_quotconsts: Proof.context -> quotconsts list
    val dest_quotconsts_global: theory -> quotconsts list
    val dest_quotients: Proof.context -> quotients list
    val lookup_abs_rep: Proof.context -> string -> abs_rep option
    val lookup_abs_rep_global: theory -> string -> abs_rep option
    val lookup_quotconsts_global: theory -> term -> quotconsts option
    val lookup_quotients: Proof.context -> string -> quotients option
    val lookup_quotients_global: theory -> string -> quotients option
    val lookup_quotmaps: Proof.context -> string -> quotmaps option
    val lookup_quotmaps_global: theory -> string -> quotmaps option
    val print_abs_rep: Proof.context -> unit
    val print_quotconsts: Proof.context -> unit
    val print_quotients: Proof.context -> unit
    val print_quotmaps: Proof.context -> unit
    type quotconsts = {def: thm, qconst: term, rconst: term}
    type quotients =
       {equiv_rel: term,
        equiv_thm: thm, qtyp: typ, quot_thm: thm, rtyp: typ}
    type quotmaps = {quot_thm: thm, relmap: string}
    val transform_abs_rep: morphism -> abs_rep -> abs_rep
    val transform_quotconsts: morphism -> quotconsts -> quotconsts
    val transform_quotients: morphism -> quotients -> quotients
    val update_abs_rep:
       string * abs_rep -> Context.generic -> Context.generic
    val update_quotconsts:
       string * quotconsts -> Context.generic -> Context.generic
    val update_quotients:
       string * quotients -> Context.generic -> Context.generic
    val update_quotmaps:
       string * quotmaps -> Context.generic -> Context.generic
  end
structure Quotient_Info: QUOTIENT_INFO
class distrib_lattice = lattice +
  assumes
    "sup_inf_distrib1":
      "!!x y z.
          x \<squnion> y \<sqinter> z =
          (x \<squnion> y) \<sqinter> (x \<squnion> z)"
class complete_lattice = Inf + Sup + bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### ML warning (line 168 of "~~/src/HOL/Tools/Function/partial_function.ML"):
### Pattern is not exhaustive.
### ML warning (line 189 of "~~/src/HOL/Tools/Function/partial_function.ML"):
### Pattern is not exhaustive.
### ML warning (line 231 of "~~/src/HOL/Tools/Function/partial_function.ML"):
### Pattern is not exhaustive.
### ML warning (line 301 of "~~/src/HOL/Tools/Function/partial_function.ML"):
### Pattern is not exhaustive.
signature PARTIAL_FUNCTION =
  sig
    val add_partial_function:
       string ->
         (binding * typ option * mixfix) list ->
           Attrib.binding * term ->
             local_theory -> (term * thm) * local_theory
    val add_partial_function_cmd:
       string ->
         (binding * string option * mixfix) list ->
           Attrib.binding * string ->
             local_theory -> (term * thm) * local_theory
    val init:
       string -> term -> term -> thm -> thm -> thm option -> declaration
    val mono_tac: Proof.context -> int -> tactic
    val transform_result: morphism -> term * thm -> term * thm
  end
structure Partial_Function: PARTIAL_FUNCTION
### ML warning (line 208 of "~~/src/HOL/Tools/Quotient/quotient_term.ML"):
### Pattern is not exhaustive.
### ML warning (line 310 of "~~/src/HOL/Tools/Quotient/quotient_term.ML"):
### Pattern is not exhaustive.
### ML warning (line 357 of "~~/src/HOL/Tools/Quotient/quotient_term.ML"):
### Pattern is not exhaustive.
### ML warning (line 385 of "~~/src/HOL/Tools/Quotient/quotient_term.ML"):
### Pattern is not exhaustive.
### ML warning (line 631 of "~~/src/HOL/Tools/Quotient/quotient_term.ML"):
### Value identifier (v2) has not been referenced.
### ML warning (line 627 of "~~/src/HOL/Tools/Quotient/quotient_term.ML"):
### Value identifier (v2') has not been referenced.
### ML warning (line 627 of "~~/src/HOL/Tools/Quotient/quotient_term.ML"):
### Value identifier (v2) has not been referenced.
### ML warning (line 512 of "~~/src/HOL/Tools/Quotient/quotient_term.ML"):
### Value identifier (T) has not been referenced.
signature QUOTIENT_TERM =
  sig
    exception LIFT_MATCH of string
    val absrep_const_chk: Proof.context -> flag -> string -> term
    val absrep_fun: Proof.context -> flag -> typ * typ -> term
    val absrep_fun_chk: Proof.context -> flag -> typ * typ -> term
    val derive_qtrm: Proof.context -> typ list -> term -> term
    val derive_qtyp: Proof.context -> typ list -> typ -> typ
    val derive_rtrm: Proof.context -> typ list -> term -> term
    val derive_rtyp: Proof.context -> typ list -> typ -> typ
    val equiv_relation: Proof.context -> typ * typ -> term
    val equiv_relation_chk: Proof.context -> typ * typ -> term
    datatype flag = AbsF | RepF
    val get_rel_from_quot_thm: thm -> term
    val inj_repabs_trm: Proof.context -> term * term -> term
    val inj_repabs_trm_chk: Proof.context -> term * term -> term
    val prove_quot_thm: Proof.context -> typ * typ -> thm
    val regularize_trm: Proof.context -> term * term -> term
    val regularize_trm_chk: Proof.context -> term * term -> term
  end
structure Quotient_Term: QUOTIENT_TERM
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale partial_function_definitions
  fixes leq :: "'a => 'a => bool"
    and lub :: "'a set => 'a"
  assumes "partial_function_definitions leq lub"
### ML warning (line 34 of "~~/src/HOL/Tools/Quotient/quotient_type.ML"):
### Pattern is not exhaustive.
### ML warning (line 118 of "~~/src/HOL/Tools/Quotient/quotient_type.ML"):
### Pattern is not exhaustive.
### ML warning (line 120 of "~~/src/HOL/Tools/Quotient/quotient_type.ML"):
### Value identifier (rty) has not been referenced.
### ML warning (line 141 of "~~/src/HOL/Tools/Quotient/quotient_type.ML"):
### Pattern is not exhaustive.
### ML warning (line 315 of "~~/src/HOL/Tools/Quotient/quotient_type.ML"):
### Matches are not exhaustive.
signature QUOTIENT_TYPE =
  sig
    val add_quotient_type:
       {overloaded: bool} ->
         ((string list * binding * mixfix) * (typ * term * bool) *
          ((binding * binding) option * thm option))
         *
         thm
           -> local_theory -> Quotient_Info.quotients * local_theory
    val quotient_type:
       {overloaded: bool} ->
         (string list * binding * mixfix) * (typ * term * bool) *
         ((binding * binding) option * thm option)
           -> Proof.context -> Proof.state
    val quotient_type_cmd:
       {overloaded: bool} ->
         (((((string list * binding) * mixfix) * string) * (bool * string))
          *
          (binding * binding) option)
         *
         (Facts.ref * Token.src list) option
           -> Proof.context -> Proof.state
  end
structure Quotient_Type: QUOTIENT_TYPE
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
### ML warning (line 183 of "~~/src/HOL/Tools/Quotient/quotient_def.ML"):
### Matches are not exhaustive.
signature QUOTIENT_DEF =
  sig
    val add_quotient_def:
       ((binding * mixfix) * Attrib.binding) * (term * term) ->
         thm -> local_theory -> Quotient_Info.quotconsts * local_theory
    val quotient_def:
       (binding * typ option * mixfix) option *
       (Attrib.binding * (term * term))
         -> local_theory -> Proof.state
    val quotient_def_cmd:
       (binding * string option * mixfix) option *
       (Attrib.binding * (string * string))
         -> local_theory -> Proof.state
  end
structure Quotient_Def: QUOTIENT_DEF
### theory "HOL.Partial_Function"
### 0.680s elapsed time, 2.683s cpu time, 0.392s GC time
Loading theory "HOL.Fun_Def" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division" via "HOL.Int")
### ML warning (line 78 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Pattern is not exhaustive.
### ML warning (line 194 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Matches are not exhaustive.
### ML warning (line 219 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Matches are not exhaustive.
### ML warning (line 220 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Matches are not exhaustive.
### ML warning (line 263 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Value identifier (ctm) has not been referenced.
### ML warning (line 442 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Pattern is not exhaustive.
### ML warning (line 443 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Pattern is not exhaustive.
### ML warning (line 450 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Pattern is not exhaustive.
### ML warning (line 451 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Pattern is not exhaustive.
### ML warning (line 746 of "~~/src/HOL/Tools/Quotient/quotient_tacs.ML"):
### Pattern is not exhaustive.
signature QUOTIENT_TACS =
  sig
    val all_injection_tac: Proof.context -> int -> tactic
    val clean_tac: Proof.context -> int -> tactic
    val descend_procedure_tac: Proof.context -> thm list -> int -> tactic
    val descend_tac: Proof.context -> thm list -> int -> tactic
    val injection_tac: Proof.context -> int -> tactic
    val lift_procedure_tac:
       Proof.context -> thm list -> thm -> int -> tactic
    val lift_tac: Proof.context -> thm list -> thm list -> int -> tactic
    val lifted: Proof.context -> typ list -> thm list -> thm -> thm
    val lifted_attrib: attribute
    val partiality_descend_procedure_tac:
       Proof.context -> thm list -> int -> tactic
    val partiality_descend_tac: Proof.context -> thm list -> int -> tactic
    val regularize_tac: Proof.context -> int -> tactic
  end
structure Quotient_Tacs: QUOTIENT_TACS
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
### theory "HOL.Lattices_Big"
### 0.948s elapsed time, 3.745s cpu time, 0.454s GC time
### ML warning (line 212 of "~~/src/HOL/Tools/Function/function_core.ML"):
### Value identifier (thms) has not been referenced.
### ML warning (line 440 of "~~/src/HOL/Tools/Function/function_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 465 of "~~/src/HOL/Tools/Function/function_core.ML"):
### Matches are not exhaustive.
### ML warning (line 527 of "~~/src/HOL/Tools/Function/function_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 776 of "~~/src/HOL/Tools/Function/function_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 851 of "~~/src/HOL/Tools/Function/function_core.ML"):
### Value identifier (G_induct) has not been referenced.
### ML warning (line 825 of "~~/src/HOL/Tools/Function/function_core.ML"):
### Matches are not exhaustive.
signature FUNCTION_CORE =
  sig
    val prepare_function:
       Function_Common.function_config ->
         binding ->
           ((binding * typ) * mixfix) list ->
             ((string * typ) list * term list * term * term) list ->
               local_theory ->
                 (term * thm *
                  (Proof.context -> thm -> Function_Common.function_result))
                 *
                 local_theory
    val trace: bool ref
  end
structure Function_Core: FUNCTION_CORE
### ML warning (line 92 of "~~/src/HOL/Tools/Function/mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 175 of "~~/src/HOL/Tools/Function/mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 249 of "~~/src/HOL/Tools/Function/mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 273 of "~~/src/HOL/Tools/Function/mutual.ML"):
### Pattern is not exhaustive.
### ML warning (line 277 of "~~/src/HOL/Tools/Function/mutual.ML"):
### Matches are not exhaustive.
### ML warning (line 283 of "~~/src/HOL/Tools/Function/mutual.ML"):
### Matches are not exhaustive.
signature FUNCTION_MUTUAL =
  sig
    val prepare_function_mutual:
       Function_Common.function_config ->
         binding ->
           ((binding * typ) * mixfix) list ->
             term list ->
               local_theory ->
                 (thm *
                  (Proof.context -> thm -> Function_Common.function_result))
                 *
                 local_theory
  end
structure Function_Mutual: FUNCTION_MUTUAL
### ML warning (line 23 of "~~/src/HOL/Tools/Function/pattern_split.ML"):
### Pattern is not exhaustive.
### ML warning (line 34 of "~~/src/HOL/Tools/Function/pattern_split.ML"):
### Value identifier (join_product) has not been referenced.
### ML warning (line 41 of "~~/src/HOL/Tools/Function/pattern_split.ML"):
### Value identifier (v2) has not been referenced.
### ML warning (line 41 of "~~/src/HOL/Tools/Function/pattern_split.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 73 of "~~/src/HOL/Tools/Function/pattern_split.ML"):
### Pattern is not exhaustive.
### ML warning (line 74 of "~~/src/HOL/Tools/Function/pattern_split.ML"):
### Pattern is not exhaustive.
### ML warning (line 101 of "~~/src/HOL/Tools/Function/pattern_split.ML"):
### Value identifier (prev) has not been referenced.
signature FUNCTION_SPLIT =
  sig
    val split_all_equations: Proof.context -> term list -> term list list
    val split_some_equations:
       Proof.context -> (bool * term) list -> term list list
  end
structure Function_Split: FUNCTION_SPLIT
signature FUNCTION_RELATION =
  sig
    val relation_infer_tac: Proof.context -> term -> int -> tactic
    val relation_tac: Proof.context -> (typ -> term) -> int -> tactic
  end
structure Function_Relation: FUNCTION_RELATION
### ML warning (line 125 of "~~/src/HOL/Tools/Function/function_elims.ML"):
### Matches are not exhaustive.
signature FUNCTION_ELIMS =
  sig
    val dest_funprop: term -> (term * term list) * term
    val mk_partial_elim_rules:
       Proof.context -> Function_Common.function_result -> thm list list
  end
structure Function_Elims: FUNCTION_ELIMS
### ML warning (line 103 of "~~/src/HOL/Tools/Function/function.ML"):
### Pattern is not exhaustive.
### ML warning (line 91 of "~~/src/HOL/Tools/Function/function.ML"):
### Matches are not exhaustive.
### ML warning (line 186 of "~~/src/HOL/Tools/Function/function.ML"):
### Matches are not exhaustive.
### ML warning (line 223 of "~~/src/HOL/Tools/Function/function.ML"):
### Value identifier (termination) has not been referenced.
signature FUNCTION =
  sig
    val add_function:
       (binding * typ option * mixfix) list ->
         Specification.multi_specs ->
           Function_Common.function_config ->
             (Proof.context -> tactic) ->
               local_theory -> info * local_theory
    val add_function_cmd:
       (binding * string option * mixfix) list ->
         Specification.multi_specs_cmd ->
           Function_Common.function_config ->
             (Proof.context -> tactic) ->
               bool -> local_theory -> info * local_theory
    val function:
       (binding * typ option * mixfix) list ->
         Specification.multi_specs ->
           Function_Common.function_config -> local_theory -> Proof.state
    val function_cmd:
       (binding * string option * mixfix) list ->
         Specification.multi_specs_cmd ->
           Function_Common.function_config ->
             bool -> local_theory -> Proof.state
    val get_congs: Proof.context -> thm list
    val get_info: Proof.context -> term -> info
    type info = Function_Common.info
    val prove_termination:
       term option -> tactic -> local_theory -> info * local_theory
    val prove_termination_cmd:
       string option -> tactic -> local_theory -> info * local_theory
    val termination: term option -> local_theory -> Proof.state
    val termination_cmd: string option -> local_theory -> Proof.state
  end
structure Function: FUNCTION
### ML warning (line 27 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Pattern is not exhaustive.
### ML warning (line 86 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 86 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 86 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Value identifier (idx) has not been referenced.
### ML warning (line 86 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 85 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Value identifier (idx) has not been referenced.
### ML warning (line 85 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Value identifier (P) has not been referenced.
### ML warning (line 90 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Matches are not exhaustive.
### ML warning (line 96 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Pattern is not exhaustive.
### ML warning (line 97 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Pattern is not exhaustive.
### ML warning (line 125 of "~~/src/HOL/Tools/Function/pat_completeness.ML"):
### Pattern is not exhaustive.
signature PAT_COMPLETENESS =
  sig
    val pat_completeness_tac: Proof.context -> int -> tactic
    val prove_completeness:
       Proof.context ->
         term list -> term -> term list list -> term list list -> thm
  end
structure Pat_Completeness: PAT_COMPLETENESS
### ML warning (line 42 of "~~/src/HOL/Tools/Function/fun.ML"):
### Matches are not exhaustive.
signature FUNCTION_FUN =
  sig
    val add_fun:
       (binding * typ option * mixfix) list ->
         Specification.multi_specs ->
           Function_Common.function_config -> local_theory -> Proof.context
    val add_fun_cmd:
       (binding * string option * mixfix) list ->
         Specification.multi_specs_cmd ->
           Function_Common.function_config ->
             bool -> local_theory -> Proof.context
    val fun_config: Function_Common.function_config
  end
structure Function_Fun: FUNCTION_FUN
### ML warning (line 65 of "~~/src/HOL/Tools/Function/induction_schema.ML"):
### Pattern is not exhaustive.
### ML warning (line 75 of "~~/src/HOL/Tools/Function/induction_schema.ML"):
### Pattern is not exhaustive.
### ML warning (line 87 of "~~/src/HOL/Tools/Function/induction_schema.ML"):
### Pattern is not exhaustive.
### ML warning (line 95 of "~~/src/HOL/Tools/Function/induction_schema.ML"):
### Pattern is not exhaustive.
### ML warning (line 124 of "~~/src/HOL/Tools/Function/induction_schema.ML"):
### Pattern is not exhaustive.
### ML warning (line 352 of "~~/src/HOL/Tools/Function/induction_schema.ML"):
### Pattern is not exhaustive.
signature INDUCTION_SCHEMA =
  sig
    val induction_schema_tac: Proof.context -> thm list -> tactic
    val mk_ind_tac:
       (int -> tactic) ->
         (int -> tactic) ->
           (int -> tactic) -> Proof.context -> thm list -> tactic
  end
structure Induction_Schema: INDUCTION_SCHEMA
Proofs for inductive predicate(s) "is_measure"
  Proving monotonicity ...
### ML warning (line 24 of "~~/src/HOL/Tools/Function/measure_functions.ML"):
### Matches are not exhaustive.
signature MEASURE_FUNCTIONS =
  sig val get_measure_functions: Proof.context -> typ -> term list end
structure Measure_Functions: MEASURE_FUNCTIONS
### ML warning (line 32 of "~~/src/HOL/Tools/Function/lexicographic_order.ML"):
### Value identifier (n) has not been referenced.
### ML warning (line 125 of "~~/src/HOL/Tools/Function/lexicographic_order.ML"):
### Value identifier (j) has not been referenced.
### ML warning (line 125 of "~~/src/HOL/Tools/Function/lexicographic_order.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 178 of "~~/src/HOL/Tools/Function/lexicographic_order.ML"):
### Pattern is not exhaustive.
signature LEXICOGRAPHIC_ORDER =
  sig
    val lex_order_tac: bool -> Proof.context -> tactic -> tactic
    val lexicographic_order_tac: bool -> Proof.context -> tactic
  end
structure Lexicographic_Order: LEXICOGRAPHIC_ORDER
### ML warning (line 95 of "~~/src/HOL/Tools/Function/termination.ML"):
### Matches are not exhaustive.
### ML warning (line 131 of "~~/src/HOL/Tools/Function/termination.ML"):
### Pattern is not exhaustive.
### ML warning (line 129 of "~~/src/HOL/Tools/Function/termination.ML"):
### Matches are not exhaustive.
### ML warning (line 156 of "~~/src/HOL/Tools/Function/termination.ML"):
### Pattern is not exhaustive.
### ML warning (line 213 of "~~/src/HOL/Tools/Function/termination.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 234 of "~~/src/HOL/Tools/Function/termination.ML"):
### Matches are not exhaustive.
### ML warning (line 276 of "~~/src/HOL/Tools/Function/termination.ML"):
### Pattern is not exhaustive.
### ML warning (line 326 of "~~/src/HOL/Tools/Function/termination.ML"):
### Matches are not exhaustive.
### ML warning (line 351 of "~~/src/HOL/Tools/Function/termination.ML"):
### Value identifier (SCC) has not been referenced.
### ML warning (line 351 of "~~/src/HOL/Tools/Function/termination.ML"):
### Matches are not exhaustive.
signature TERMINATION =
  sig
    val CALLS: (term list * int -> tactic) -> int -> tactic
    val TERMINATION: Proof.context -> tactic -> ttac -> int -> tactic
    datatype cell
    = False of thm | Less of thm | LessEq of thm * thm | None of thm * thm
    type data
    val decompose_tac: Proof.context -> ttac
    val dest_call:
       data -> term -> (string * typ) list * int * term * int * term * term
    val get_chain: data -> term -> term -> thm option option
    val get_descent: data -> term -> term -> term -> cell option
    val get_measures: data -> int -> term list
    val get_num_points: data -> int
    val get_types: data -> int -> typ
    val mk_sumcases: data -> typ -> term list -> term
    type ttac = data -> int -> tactic
    val wf_union_tac: Proof.context -> tactic
  end
structure Termination: TERMINATION
### ML warning (line 48 of "~~/src/HOL/Tools/Function/scnp_solve.ML"):
### Value identifier (gl) has not been referenced.
### ML warning (line 115 of "~~/src/HOL/Tools/Function/scnp_solve.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 115 of "~~/src/HOL/Tools/Function/scnp_solve.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 214 of "~~/src/HOL/Tools/Function/scnp_solve.ML"):
### Value identifier (WEAK) has not been referenced.
### ML warning (line 215 of "~~/src/HOL/Tools/Function/scnp_solve.ML"):
### Matches are not exhaustive.
signature SCNP_SOLVE =
  sig
    type certificate =
       label * (int * int) list list * int list *
       (int -> bool -> int -> (int * int) option)
    datatype edge = GEQ | GTR
    val generate_certificate:
       bool -> label list -> graph_problem -> certificate option
    datatype graph = G of int * int * (int * edge * int) list
    datatype graph_problem = GP of int list * graph list
    datatype label = MAX | MIN | MS
    val solver: string ref
  end
structure ScnpSolve: SCNP_SOLVE
### theory "HOL.Extraction"
### 1.970s elapsed time, 6.840s cpu time, 0.756s GC time
### ML warning (line 227 of "~~/src/HOL/Tools/Function/scnp_reconstruct.ML"):
### Value identifier (b) has not been referenced.
### ML warning (line 215 of "~~/src/HOL/Tools/Function/scnp_reconstruct.ML"):
### Pattern is not exhaustive.
### ML warning (line 198 of "~~/src/HOL/Tools/Function/scnp_reconstruct.ML"):
### Pattern is not exhaustive.
signature SCNP_RECONSTRUCT =
  sig
    val decomp_scnp_tac: ScnpSolve.label list -> Proof.context -> tactic
    val multiset_setup: multiset_setup -> theory -> theory
    datatype multiset_setup
    =
         Multiset of
             {mk_mset: typ -> term list -> term,
              msetT: typ -> typ,
              mset_member_tac: Proof.context -> int -> int -> tactic,
              mset_nonempty_tac: Proof.context -> int -> tactic,
              mset_pwleq_tac: Proof.context -> int -> tactic,
              mset_regroup_conv: Proof.context -> int list -> conv,
              reduction_pair: thm,
              set_of_simps: thm list, smsI': thm, wmsI1: thm, wmsI2'': thm}
    val sizechange_tac: Proof.context -> tactic -> tactic
  end
structure ScnpReconstruct: SCNP_RECONSTRUCT
signature FUN_CASES =
  sig
    val fun_cases:
       (Attrib.binding * term list) list ->
         local_theory -> (string * thm list) list * local_theory
    val fun_cases_cmd:
       (Attrib.binding * string list) list ->
         local_theory -> (string * thm list) list * local_theory
    val mk_fun_cases: Proof.context -> term -> thm
  end
structure Fun_Cases: FUN_CASES
val it = fn: theory -> theory
### theory "HOL.Fun_Def"
### 1.304s elapsed time, 4.202s cpu time, 0.365s GC time
signature BNF_LIFT =
  sig
    val copy_bnf:
       (((lift_bnf_option list *
          (binding option * (string * sort option)) list)
         *
         string)
        *
        thm option)
       *
       (binding * binding * binding)
         -> local_theory -> local_theory
    val copy_bnf_cmd:
       (((lift_bnf_option list *
          (binding option * (string * string option)) list)
         *
         string)
        *
        (Facts.ref * Token.src list) option)
       *
       (binding * binding * binding)
         -> local_theory -> local_theory
    val lift_bnf:
       ((((lift_bnf_option list *
           (binding option * (string * sort option)) list)
          *
          string)
         *
         term list option)
        *
        thm list option)
       *
       (binding * binding * binding)
         ->
         ({context: Proof.context, prems: thm list} -> tactic) list ->
           local_theory -> local_theory
    val lift_bnf_cmd:
       ((((lift_bnf_option list *
           (binding option * (string * string option)) list)
          *
          string)
         *
         string list)
        *
        (Facts.ref * Token.src list) list option)
       *
       (binding * binding * binding)
         -> local_theory -> Proof.state
    datatype lift_bnf_option
    =
         No_Warn_Transfer
       | No_Warn_Wits
       | Plugins_Option of Proof.context -> Plugin_Name.filter
  end
structure BNF_Lift: BNF_LIFT
### theory "HOL.Quotient"
### 3.640s elapsed time, 9.281s cpu time, 1.000s GC time
Loading theory "HOL.Int" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity" via "HOL.Euclidean_Division")
instantiation
  int :: comm_ring_1
  uminus_int == uminus :: int => int
  one_int == one_class.one :: int
  times_int == times :: int => int => int
  zero_int == zero_class.zero :: int
  minus_int == minus :: int => int => int
  plus_int == plus :: int => int => int
instantiation
  int :: linorder
  less_eq_int == less_eq :: int => int => bool
  less_int == less :: int => int => bool
instantiation
  int :: distrib_lattice
  inf_int == inf :: int => int => int
  sup_int == sup :: int => int => int
instantiation
  int :: linordered_idom
  sgn_int == sgn :: int => int
  abs_int == abs :: int => int
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
class division_ring = inverse + ring_1_no_zero_divisors +
  assumes "left_inverse": "!!a. a ~= (0::'a) ==> inverse a * a = (1::'a)"
  assumes "right_inverse": "!!a. a ~= (0::'a) ==> a * inverse a = (1::'a)"
  assumes "divide_inverse": "!!a b. a / b = a * inverse b"
  assumes "inverse_zero": "inverse (0::'a) = (0::'a)"
signature INT_ARITH = sig val zero_one_idom_simproc: simproc end
structure Int_Arith: INT_ARITH
instantiation
  int :: equal
  equal_int == equal_class.equal :: int => int => bool
### theory "HOL.Int"
### 1.748s elapsed time, 1.876s cpu time, 0.175s GC time
Loading theory "HOL.Euclidean_Division" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides" via "HOL.Parity")
class euclidean_semiring = semidom_modulo +
  fixes euclidean_size :: "'a => nat"
  assumes "size_0": "euclidean_size (0::'a) = 0"
  assumes
    "mod_size_less":
      "!!b a. b ~= (0::'a) ==> euclidean_size (a mod b) < euclidean_size b"
  assumes
    "size_mult_mono":
      "!!b a. b ~= (0::'a) ==> euclidean_size a <= euclidean_size (a * b)"
class euclidean_semiring_cancel = euclidean_semiring +
  assumes
    "div_mult_self1":
      "!!b a c. b ~= (0::'a) ==> (a + c * b) div b = c + a div b"
    and
    "div_mult_mult1":
      "!!c a b. c ~= (0::'a) ==> c * a div (c * b) = a div b"
class unique_euclidean_semiring = euclidean_semiring +
  fixes division_segment :: "'a => 'a"
  assumes
    "euclidean_size_mult":
      "!!a b. euclidean_size (a * b) = euclidean_size a * euclidean_size b"
  assumes "is_unit_division_segment": "!!a. is_unit (division_segment a)"
    and
    "division_segment_mult":
      "!!a b.
          [| a ~= (0::'a); b ~= (0::'a) |]
          ==> division_segment (a * b) =
              division_segment a * division_segment b"
    and
    "division_segment_mod":
      "!!b a.
          [| b ~= (0::'a); ~ b dvd a |]
          ==> division_segment (a mod b) = division_segment b"
  assumes
    "div_bounded":
      "!!b r q.
          [| b ~= (0::'a); division_segment r = division_segment b;
             euclidean_size r < euclidean_size b |]
          ==> (q * b + r) div b = q"
instantiation
  nat :: normalization_semidom
  normalize_nat == normalize :: nat => nat
  unit_factor_nat == unit_factor :: nat => nat
  divide_nat == divide :: nat => nat => nat
instantiation
  nat :: unique_euclidean_semiring
  division_segment_nat == division_segment :: nat => nat
  euclidean_size_nat == euclidean_size :: nat => nat
  modulo_nat == modulo :: nat => nat => nat
structure Cancel_Div_Mod_Nat: CANCEL_DIV_MOD
instantiation
  int :: normalization_semidom
  normalize_int == normalize :: int => int
  unit_factor_int == unit_factor :: int => int
  divide_int == divide :: int => int => int
instantiation
  int :: idom_modulo
  modulo_int == modulo :: int => int => int
instantiation
  int :: unique_euclidean_ring
  division_segment_int == division_segment :: int => int
  euclidean_size_int == euclidean_size :: int => nat
class unique_euclidean_semiring_with_nat = unique_euclidean_semiring +
  semiring_char_0 +
  assumes "of_nat_div": "!!m n. of_nat (m div n) = of_nat m div of_nat n"
    and
    "division_segment_of_nat": "!!n. division_segment (of_nat n) = (1::'a)"
    and
    "division_segment_euclidean_size":
      "!!a. division_segment a * of_nat (euclidean_size a) = a"
### theory "HOL.Euclidean_Division"
### 3.411s elapsed time, 3.667s cpu time, 0.352s GC time
Loading theory "HOL.Parity" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs" via "HOL.Divides")
class semiring_parity = semiring_modulo +
  assumes
    "even_iff_mod_2_eq_zero":
      "!!a. ((2::'a) dvd a) = (a mod (2::'a) = (0::'a))"
    and
    "odd_iff_mod_2_eq_one":
      "!!a. (~ (2::'a) dvd a) = (a mod (2::'a) = (1::'a))"
    and "odd_one": "~ (2::'a) dvd (1::'a)"
class unique_euclidean_semiring_with_nat = unique_euclidean_semiring +
  semiring_char_0 +
  assumes "of_nat_div": "!!m n. of_nat (m div n) = of_nat m div of_nat n"
    and
    "division_segment_of_nat": "!!n. division_segment (of_nat n) = (1::'a)"
    and
    "division_segment_euclidean_size":
      "!!a. division_segment a * of_nat (euclidean_size a) = a"
class semiring_parity = semiring_modulo +
  assumes
    "even_iff_mod_2_eq_zero": "!!a. even a = (a mod (2::'a) = (0::'a))"
    and "odd_iff_mod_2_eq_one": "!!a. odd a = (a mod (2::'a) = (1::'a))"
    and "odd_one": "odd (1::'a)"
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
class unique_euclidean_semiring_with_nat = unique_euclidean_semiring +
  semiring_char_0 + semiring_parity +
  assumes "of_nat_div": "!!m n. of_nat (m div n) = of_nat m div of_nat n"
    and
    "division_segment_of_nat": "!!n. division_segment (of_nat n) = (1::'a)"
    and
    "division_segment_euclidean_size":
      "!!a. division_segment a * of_nat (euclidean_size a) = a"
### theory "HOL.Parity"
### 1.465s elapsed time, 1.608s cpu time, 0.181s GC time
Loading theory "HOL.Divides" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization" via "HOL.Numeral_Simprocs")
Proofs for inductive predicate(s) "eucl_rel_int"
  Proving monotonicity ...
class unique_euclidean_semiring_numeral =
  unique_euclidean_semiring_with_nat + linordered_semidom +
  fixes divmod :: "num => num => 'a * 'a"
    and divmod_step :: "num => 'a * 'a => 'a * 'a"
  assumes
    "div_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a div b = (0::'a)"
    and "mod_less": "!!a b. [| (0::'a) <= a; a < b |] ==> a mod b = a"
    and
    "div_positive": "!!b a. [| (0::'a) < b; b <= a |] ==> (0::'a) < a div b"
    and "mod_less_eq_dividend": "!!a b. (0::'a) <= a ==> a mod b <= a"
    and "pos_mod_bound": "!!b a. (0::'a) < b ==> a mod b < b"
    and "pos_mod_sign": "!!b a. (0::'a) < b ==> (0::'a) <= a mod b"
    and
    "mod_mult2_eq":
      "!!c a b.
          (0::'a) <= c ==> a mod (b * c) = b * (a div b mod c) + a mod b"
    and
    "div_mult2_eq":
      "!!c a b. (0::'a) <= c ==> a div (b * c) = a div b div c"
  assumes "discrete": "!!a b. (a < b) = (a + (1::'a) <= b)"
  assumes
    "divmod_def":
      "!!m n.
          divmod m n = (numeral m div numeral n, numeral m mod numeral n)"
    and
    "divmod_step_def":
      "!!l qr.
          divmod_step l qr =
          (let (q, r) = qr
           in if numeral l <= r then ((2::'a) * q + (1::'a), r - numeral l)
              else ((2::'a) * q, r))"
instantiation
  nat :: unique_euclidean_semiring_numeral
  divmod_nat == divmod :: num => num => nat * nat
  divmod_step_nat == divmod_step :: num => nat * nat => nat * nat
instantiation
  int :: unique_euclidean_semiring_numeral
  divmod_int == divmod :: num => num => int * int
  divmod_step_int == divmod_step :: num => int * int => int * int
### theory "HOL.Divides"
### 1.200s elapsed time, 1.318s cpu time, 0.151s GC time
Loading theory "HOL.Numeral_Simprocs" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis" via "HOL.Semiring_Normalization")
Loading theory "HOL.Set_Interval" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger")
### ML warning (line 27 of "~~/src/Provers/Arith/assoc_fold.ML"):
### Value identifier (plus) has not been referenced.
signature ASSOC_FOLD_DATA =
  sig
    val assoc_ss: simpset
    val eq_reflection: thm
    val is_numeral: term -> bool
  end
signature ASSOC_FOLD = sig val proc: Proof.context -> term -> thm option end
functor Assoc_Fold (Data: ASSOC_FOLD_DATA): ASSOC_FOLD
signature CANCEL_NUMERALS_DATA =
  sig
    val bal_add1: thm
    val bal_add2: thm
    val dest_bal: term -> term * term
    val dest_coeff: term -> int * term
    val dest_sum: term -> term list
    val find_first_coeff: term -> term list -> int * term list
    val mk_bal: term * term -> term
    val mk_coeff: int * term -> term
    val mk_sum: typ -> term list -> term
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
signature CANCEL_NUMERALS =
  sig val proc: Proof.context -> cterm -> thm option end
functor CancelNumeralsFun (Data: CANCEL_NUMERALS_DATA): CANCEL_NUMERALS
### ML warning (line 57 of "~~/src/Provers/Arith/combine_numerals.ML"):
### Value identifier (tab) has not been referenced.
signature COMBINE_NUMERALS_DATA =
  sig
    val add: coeff * coeff -> coeff
    eqtype coeff
    val dest_coeff: term -> coeff * term
    val dest_sum: term -> term list
    val iszero: coeff -> bool
    val left_distrib: thm
    val mk_coeff: coeff * term -> term
    val mk_sum: typ -> term list -> term
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
functor CombineNumeralsFun (Data: COMBINE_NUMERALS_DATA): 
  sig val proc: Proof.context -> cterm -> thm option end
signature CANCEL_NUMERAL_FACTOR_DATA =
  sig
    val cancel: thm
    val dest_bal: term -> term * term
    val dest_coeff: term -> int * term
    val mk_bal: term * term -> term
    val mk_coeff: int * term -> term
    val neg_exchanges: bool
    val norm_tac: Proof.context -> tactic
    val numeral_simp_tac: Proof.context -> tactic
    val prove_conv:
       tactic list -> Proof.context -> thm list -> term * term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm
    val trans_tac: Proof.context -> thm option -> tactic
  end
functor CancelNumeralFactorFun (Data: CANCEL_NUMERAL_FACTOR_DATA): 
  sig val proc: Proof.context -> cterm -> thm option end
### ML warning (line 51 of "~~/src/Provers/Arith/extract_common_term.ML"):
### Value identifier (prems) has not been referenced.
signature EXTRACT_COMMON_TERM_DATA =
  sig
    val dest_bal: term -> term * term
    val dest_sum: term -> term list
    val find_first: term -> term list -> term list
    val mk_bal: term * term -> term
    val mk_eq: term * term -> term
    val mk_sum: typ -> term list -> term
    val norm_tac: Proof.context -> tactic
    val simp_conv: Proof.context -> term -> thm option
    val simplify_meta_eq: Proof.context -> thm -> thm -> thm
  end
functor ExtractCommonTermFun (Data: EXTRACT_COMMON_TERM_DATA): 
  sig val proc: Proof.context -> term -> thm option end
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
class preorder = ord +
  assumes "less_le_not_le": "!!x y. (x < y) = (x <= y & ~ y <= x)"
    and "order_refl": "!!x. x <= x"
    and "order_trans": "!!x y z. [| x <= y; y <= z |] ==> x <= z"
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
class no_top = order +
  assumes "gt_ex": "!!x. EX y. x < y"
class no_bot = order +
  assumes "lt_ex": "!!x. EX y. y < x"
class no_top = order +
  assumes "gt_ex": "!!x. EX y. x < y"
### Ignoring duplicate rewrite rule:
### - (- ?y) == ?y
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 + ?c1 == ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 == ?b1 + ?a1
### Ignoring duplicate rewrite rule:
### ?b1 + (?a1 + ?c1) == ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 * ?c1 == ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 == ?b1 * ?a1
### Ignoring duplicate rewrite rule:
### ?b1 * (?a1 * ?c1) == ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### (?a1 & ?b1) & ?c1 == ?a1 & ?b1 & ?c1
### Ignoring duplicate rewrite rule:
### ?a1 & ?b1 == ?b1 & ?a1
### Ignoring duplicate rewrite rule:
### ?b1 & ?a1 & ?c1 == ?a1 & ?b1 & ?c1
### Ignoring duplicate rewrite rule:
### (?a1 | ?b1) | ?c1 == ?a1 | ?b1 | ?c1
### Ignoring duplicate rewrite rule:
### ?a1 | ?b1 == ?b1 | ?a1
### Ignoring duplicate rewrite rule:
### ?b1 | ?a1 | ?c1 == ?a1 | ?b1 | ?c1
### Ignoring duplicate rewrite rule:
### ?a1 \<sqinter> ?b1 \<sqinter> ?c1 == ?a1 \<sqinter> (?b1 \<sqinter> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<sqinter> ?b1 == ?b1 \<sqinter> ?a1
### Ignoring duplicate rewrite rule:
### ?b1 \<sqinter> (?a1 \<sqinter> ?c1) == ?a1 \<sqinter> (?b1 \<sqinter> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<squnion> ?b1 \<squnion> ?c1 == ?a1 \<squnion> (?b1 \<squnion> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<squnion> ?b1 == ?b1 \<squnion> ?a1
### Ignoring duplicate rewrite rule:
### ?b1 \<squnion> (?a1 \<squnion> ?c1) == ?a1 \<squnion> (?b1 \<squnion> ?c1)
### Ignoring duplicate rewrite rule:
### min (min ?a1 ?b1) ?c1 == min ?a1 (min ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### min ?a1 ?b1 == min ?b1 ?a1
### Ignoring duplicate rewrite rule:
### min ?b1 (min ?a1 ?c1) == min ?a1 (min ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### max (max ?a1 ?b1) ?c1 == max ?a1 (max ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### max ?a1 ?b1 == max ?b1 ?a1
### Ignoring duplicate rewrite rule:
### max ?b1 (max ?a1 ?c1) == max ?a1 (max ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### coprime ?b1 ?a1 == coprime ?a1 ?b1
### Ignoring duplicate rewrite rule:
### ?a1 dvd ?c1 - ?b1 == ?a1 dvd ?b1 - ?c1
### Ignoring duplicate rewrite rule:
### (0::?'a1) + ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y + (0::?'a1) == ?y
### Ignoring duplicate rewrite rule:
### (0::?'a1) + ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y + (0::?'a1) == ?y
### Ignoring duplicate rewrite rule:
### (0::?'a1) + ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y + (0::?'a1) == ?y
### Ignoring duplicate rewrite rule:
### (0::?'a1) + ?y == ?y
### ML warning (line 84 of "~~/src/HOL/Tools/numeral_simprocs.ML"):
### Value identifier (past) has not been referenced.
### ML warning (line 98 of "~~/src/HOL/Tools/numeral_simprocs.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 98 of "~~/src/HOL/Tools/numeral_simprocs.ML"):
### Value identifier (past) has not been referenced.
### ML warning (line 465 of "~~/src/HOL/Tools/numeral_simprocs.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 465 of "~~/src/HOL/Tools/numeral_simprocs.ML"):
### Value identifier (past) has not been referenced.
### ML warning (line 611 of "~~/src/HOL/Tools/numeral_simprocs.ML"):
### Pattern is not exhaustive.
### ML warning (line 642 of "~~/src/HOL/Tools/numeral_simprocs.ML"):
### Value identifier (ctxt) has not been referenced.
signature NUMERAL_SIMPROCS =
  sig
    val assoc_fold: Proof.context -> cterm -> thm option
    val combine_numerals: Proof.context -> cterm -> thm option
    val div_cancel_factor: Proof.context -> cterm -> thm option
    val div_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val divide_cancel_factor: Proof.context -> cterm -> thm option
    val divide_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val dvd_cancel_factor: Proof.context -> cterm -> thm option
    val eq_cancel_factor: Proof.context -> cterm -> thm option
    val eq_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val eq_cancel_numerals: Proof.context -> cterm -> thm option
    val field_combine_numerals: Proof.context -> cterm -> thm option
    val field_comp_conv: Proof.context -> conv
    val field_divide_cancel_numeral_factor: simproc
    val le_cancel_factor: Proof.context -> cterm -> thm option
    val le_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val le_cancel_numerals: Proof.context -> cterm -> thm option
    val less_cancel_factor: Proof.context -> cterm -> thm option
    val less_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val less_cancel_numerals: Proof.context -> cterm -> thm option
    val mod_cancel_factor: Proof.context -> cterm -> thm option
    val num_ss: simpset
    val trans_tac: Proof.context -> thm option -> tactic
  end
structure Numeral_Simprocs: NUMERAL_SIMPROCS
class no_bot = order +
  assumes "lt_ex": "!!x. EX y. y < x"
class no_top = order +
  assumes "gt_ex": "!!x. EX y. x < y"
class no_bot = order +
  assumes "lt_ex": "!!x. EX y. y < x"
### Ignoring duplicate rewrite rule:
### numeral ?m1 + numeral ?n1 == numeral (?m1 + ?n1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) - ?a1 == - ?a1
### Ignoring duplicate rewrite rule:
### numeral ?m1 * numeral ?n1 == numeral (?m1 * ?n1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 + ?c1 == ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 == ?b1 + ?a1
### Ignoring duplicate rewrite rule:
### ?b1 + (?a1 + ?c1) == ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 * ?c1 == ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 == ?b1 * ?a1
### Ignoring duplicate rewrite rule:
### ?b1 * (?a1 * ?c1) == ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### (?a1 & ?b1) & ?c1 == ?a1 & ?b1 & ?c1
### Ignoring duplicate rewrite rule:
### ?a1 & ?b1 == ?b1 & ?a1
### Ignoring duplicate rewrite rule:
### ?b1 & ?a1 & ?c1 == ?a1 & ?b1 & ?c1
### Ignoring duplicate rewrite rule:
### (?a1 | ?b1) | ?c1 == ?a1 | ?b1 | ?c1
### Ignoring duplicate rewrite rule:
### ?a1 | ?b1 == ?b1 | ?a1
### Ignoring duplicate rewrite rule:
### ?b1 | ?a1 | ?c1 == ?a1 | ?b1 | ?c1
### Ignoring duplicate rewrite rule:
### ?a1 \<sqinter> ?b1 \<sqinter> ?c1 == ?a1 \<sqinter> (?b1 \<sqinter> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<sqinter> ?b1 == ?b1 \<sqinter> ?a1
### Ignoring duplicate rewrite rule:
### ?b1 \<sqinter> (?a1 \<sqinter> ?c1) == ?a1 \<sqinter> (?b1 \<sqinter> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<squnion> ?b1 \<squnion> ?c1 == ?a1 \<squnion> (?b1 \<squnion> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<squnion> ?b1 == ?b1 \<squnion> ?a1
### Ignoring duplicate rewrite rule:
### ?b1 \<squnion> (?a1 \<squnion> ?c1) == ?a1 \<squnion> (?b1 \<squnion> ?c1)
### Ignoring duplicate rewrite rule:
### min (min ?a1 ?b1) ?c1 == min ?a1 (min ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### min ?a1 ?b1 == min ?b1 ?a1
### Ignoring duplicate rewrite rule:
### min ?b1 (min ?a1 ?c1) == min ?a1 (min ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### max (max ?a1 ?b1) ?c1 == max ?a1 (max ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### max ?a1 ?b1 == max ?b1 ?a1
### Ignoring duplicate rewrite rule:
### max ?b1 (max ?a1 ?c1) == max ?a1 (max ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### coprime ?b1 ?a1 == coprime ?a1 ?b1
### Ignoring duplicate rewrite rule:
### ?a1 dvd ?c1 - ?b1 == ?a1 dvd ?b1 - ?c1
### Ignoring duplicate rewrite rule:
### numeral ?m1 + numeral ?n1 == numeral (?m1 + ?n1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) - ?a1 == - ?a1
### Ignoring duplicate rewrite rule:
### numeral ?m1 * numeral ?n1 == numeral (?m1 * ?n1)
### Ignoring duplicate rewrite rule:
### numeral ?m1 + numeral ?n1 == numeral (?m1 + ?n1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) - ?a1 == - ?a1
### Ignoring duplicate rewrite rule:
### numeral ?m1 * numeral ?n1 == numeral (?m1 * ?n1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 + ?c1 == ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 == ?b1 + ?a1
### Ignoring duplicate rewrite rule:
### ?b1 + (?a1 + ?c1) == ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 * ?c1 == ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 == ?b1 * ?a1
### Ignoring duplicate rewrite rule:
### ?b1 * (?a1 * ?c1) == ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### (?a1 & ?b1) & ?c1 == ?a1 & ?b1 & ?c1
### Ignoring duplicate rewrite rule:
### ?a1 & ?b1 == ?b1 & ?a1
### Ignoring duplicate rewrite rule:
### ?b1 & ?a1 & ?c1 == ?a1 & ?b1 & ?c1
### Ignoring duplicate rewrite rule:
### (?a1 | ?b1) | ?c1 == ?a1 | ?b1 | ?c1
### Ignoring duplicate rewrite rule:
### ?a1 | ?b1 == ?b1 | ?a1
### Ignoring duplicate rewrite rule:
### ?b1 | ?a1 | ?c1 == ?a1 | ?b1 | ?c1
### Ignoring duplicate rewrite rule:
### ?a1 \<sqinter> ?b1 \<sqinter> ?c1 == ?a1 \<sqinter> (?b1 \<sqinter> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<sqinter> ?b1 == ?b1 \<sqinter> ?a1
### Ignoring duplicate rewrite rule:
### ?b1 \<sqinter> (?a1 \<sqinter> ?c1) == ?a1 \<sqinter> (?b1 \<sqinter> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<squnion> ?b1 \<squnion> ?c1 == ?a1 \<squnion> (?b1 \<squnion> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<squnion> ?b1 == ?b1 \<squnion> ?a1
### Ignoring duplicate rewrite rule:
### ?b1 \<squnion> (?a1 \<squnion> ?c1) == ?a1 \<squnion> (?b1 \<squnion> ?c1)
### Ignoring duplicate rewrite rule:
### min (min ?a1 ?b1) ?c1 == min ?a1 (min ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### min ?a1 ?b1 == min ?b1 ?a1
### Ignoring duplicate rewrite rule:
### min ?b1 (min ?a1 ?c1) == min ?a1 (min ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### max (max ?a1 ?b1) ?c1 == max ?a1 (max ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### max ?a1 ?b1 == max ?b1 ?a1
### Ignoring duplicate rewrite rule:
### max ?b1 (max ?a1 ?c1) == max ?a1 (max ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### coprime ?b1 ?a1 == coprime ?a1 ?b1
### Ignoring duplicate rewrite rule:
### ?a1 dvd ?c1 - ?b1 == ?a1 dvd ?b1 - ?c1
### Ignoring duplicate rewrite rule:
### numeral ?m1 + numeral ?n1 == numeral (?m1 + ?n1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) - ?a1 == - ?a1
### Ignoring duplicate rewrite rule:
### numeral ?m1 * numeral ?n1 == numeral (?m1 * ?n1)
### Ignoring duplicate rewrite rule:
### numeral ?m1 + numeral ?n1 == numeral (?m1 + ?n1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) - ?a1 == - ?a1
### Ignoring duplicate rewrite rule:
### numeral ?m1 * numeral ?n1 == numeral (?m1 * ?n1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 + ?c1 == ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 + ?b1 == ?b1 + ?a1
### Ignoring duplicate rewrite rule:
### ?b1 + (?a1 + ?c1) == ?a1 + (?b1 + ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 * ?c1 == ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 * ?b1 == ?b1 * ?a1
### Ignoring duplicate rewrite rule:
### ?b1 * (?a1 * ?c1) == ?a1 * (?b1 * ?c1)
### Ignoring duplicate rewrite rule:
### (?a1 & ?b1) & ?c1 == ?a1 & ?b1 & ?c1
### Ignoring duplicate rewrite rule:
### ?a1 & ?b1 == ?b1 & ?a1
### Ignoring duplicate rewrite rule:
### ?b1 & ?a1 & ?c1 == ?a1 & ?b1 & ?c1
### Ignoring duplicate rewrite rule:
### (?a1 | ?b1) | ?c1 == ?a1 | ?b1 | ?c1
### Ignoring duplicate rewrite rule:
### ?a1 | ?b1 == ?b1 | ?a1
### Ignoring duplicate rewrite rule:
### ?b1 | ?a1 | ?c1 == ?a1 | ?b1 | ?c1
### Ignoring duplicate rewrite rule:
### ?a1 \<sqinter> ?b1 \<sqinter> ?c1 == ?a1 \<sqinter> (?b1 \<sqinter> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<sqinter> ?b1 == ?b1 \<sqinter> ?a1
### Ignoring duplicate rewrite rule:
### ?b1 \<sqinter> (?a1 \<sqinter> ?c1) == ?a1 \<sqinter> (?b1 \<sqinter> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<squnion> ?b1 \<squnion> ?c1 == ?a1 \<squnion> (?b1 \<squnion> ?c1)
### Ignoring duplicate rewrite rule:
### ?a1 \<squnion> ?b1 == ?b1 \<squnion> ?a1
### Ignoring duplicate rewrite rule:
### ?b1 \<squnion> (?a1 \<squnion> ?c1) == ?a1 \<squnion> (?b1 \<squnion> ?c1)
### Ignoring duplicate rewrite rule:
### min (min ?a1 ?b1) ?c1 == min ?a1 (min ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### min ?a1 ?b1 == min ?b1 ?a1
### Ignoring duplicate rewrite rule:
### min ?b1 (min ?a1 ?c1) == min ?a1 (min ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### max (max ?a1 ?b1) ?c1 == max ?a1 (max ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### max ?a1 ?b1 == max ?b1 ?a1
### Ignoring duplicate rewrite rule:
### max ?b1 (max ?a1 ?c1) == max ?a1 (max ?b1 ?c1)
### Ignoring duplicate rewrite rule:
### coprime ?b1 ?a1 == coprime ?a1 ?b1
### Ignoring duplicate rewrite rule:
### ?a1 dvd ?c1 - ?b1 == ?a1 dvd ?b1 - ?c1
### Ignoring duplicate rewrite rule:
### numeral ?m1 + numeral ?n1 == numeral (?m1 + ?n1)
### Ignoring duplicate rewrite rule:
### (0::?'a1) - ?a1 == - ?a1
### Ignoring duplicate rewrite rule:
### numeral ?m1 * numeral ?n1 == numeral (?m1 * ?n1)
### ML warning (line 42 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (past) has not been referenced.
### ML warning (line 91 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 91 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (past) has not been referenced.
### ML warning (line 109 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (w) has not been referenced.
### ML warning (line 152 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 224 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 337 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (u) has not been referenced.
### ML warning (line 337 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (past) has not been referenced.
### ML warning (line 352 of "~~/src/HOL/Tools/nat_numeral_simprocs.ML"):
### Value identifier (T) has not been referenced.
signature NAT_NUMERAL_SIMPROCS =
  sig
    val combine_numerals: Proof.context -> cterm -> thm option
    val diff_cancel_numerals: Proof.context -> cterm -> thm option
    val div_cancel_factor: Proof.context -> cterm -> thm option
    val div_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val dvd_cancel_factor: Proof.context -> cterm -> thm option
    val dvd_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val eq_cancel_factor: Proof.context -> cterm -> thm option
    val eq_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val eq_cancel_numerals: Proof.context -> cterm -> thm option
    val le_cancel_factor: Proof.context -> cterm -> thm option
    val le_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val le_cancel_numerals: Proof.context -> cterm -> thm option
    val less_cancel_factor: Proof.context -> cterm -> thm option
    val less_cancel_numeral_factor: Proof.context -> cterm -> thm option
    val less_cancel_numerals: Proof.context -> cterm -> thm option
  end
structure Nat_Numeral_Simprocs: NAT_NUMERAL_SIMPROCS
### theory "HOL.Numeral_Simprocs"
### 0.760s elapsed time, 1.673s cpu time, 0.316s GC time
Loading theory "HOL.Semiring_Normalization" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger" via "HOL.Groebner_Basis")
Loading theory "HOL.SMT" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer")
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
class complete_lattice = Inf + ccpo + bounded_lattice +
  assumes "Inf_lower": "!!x A. x : A ==> \<Sqinter> A <= x"
    and
    "Inf_greatest": "!!A z. (!!x. x : A ==> z <= x) ==> z <= \<Sqinter> A"
    and "Sup_upper": "!!x A. x : A ==> x <= \<Squnion> A"
    and "Sup_least": "!!A z. (!!x. x : A ==> x <= z) ==> \<Squnion> A <= z"
    and "Inf_empty": "\<Sqinter> {} = \<top>"
    and "Sup_empty": "\<Squnion> {} = \<bottom>"
val moura_tac = fn: Proof.context -> int -> tactic
class comm_semiring_1_cancel_crossproduct = comm_semiring_1_cancel +
  assumes
    "crossproduct_eq":
      "!!w y x z. (w * y + x * z = w * z + x * y) = (w = x | y = z)"
class linordered_semidom = linordered_comm_semiring_strict +
  linordered_nonzero_semiring + semidom +
  assumes "le_add_diff_inverse2": "!!b a. b <= a ==> a - b + b = a"
### Ignoring duplicate rewrite rule:
### (0::?'a1) + ?y == ?y
### ML warning (line 289 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Pattern is not exhaustive.
### ML warning (line 295 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Pattern is not exhaustive.
### ML warning (line 295 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Value identifier (cn) has not been referenced.
### ML warning (line 296 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Pattern is not exhaustive.
### ML warning (line 297 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Pattern is not exhaustive.
### ML warning (line 615 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 859 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Value identifier (mk_const) has not been referenced.
### ML warning (line 859 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Value identifier (dest_const) has not been referenced.
### ML warning (line 858 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Value identifier (ideal) has not been referenced.
### ML warning (line 858 of "~~/src/HOL/Tools/semiring_normalizer.ML"):
### Value identifier (idom) has not been referenced.
signature SEMIRING_NORMALIZER =
  sig
    val declare:
       thm ->
         {field: term list * thm list,
          ideal: thm list,
          idom: thm list,
          ring: term list * thm list, semiring: term list * thm list}
           -> local_theory -> local_theory
    type entry
    val match: Proof.context -> cterm -> entry option
    val semiring_normalize_conv: Proof.context -> conv
    val semiring_normalize_ord_conv: Proof.context -> cterm ord -> conv
    val semiring_normalize_ord_wrapper:
       Proof.context -> entry -> cterm ord -> conv
    val semiring_normalize_wrapper: Proof.context -> entry -> conv
    val semiring_normalizers_conv:
       cterm list ->
         cterm list * thm list ->
           cterm list * thm list ->
             cterm list * thm list ->
               (cterm -> bool) * conv * conv * conv ->
                 cterm ord ->
                   {add: Proof.context -> conv,
                    main: Proof.context -> conv,
                    mul: Proof.context -> conv,
                    neg: Proof.context -> conv,
                    pow: Proof.context -> conv, sub: Proof.context -> conv}
    val semiring_normalizers_ord_wrapper:
       Proof.context ->
         entry ->
           cterm ord ->
             {add: Proof.context -> conv,
              main: Proof.context -> conv,
              mul: Proof.context -> conv,
              neg: Proof.context -> conv,
              pow: Proof.context -> conv, sub: Proof.context -> conv}
    val the_field: Proof.context -> thm -> cterm list * thm list
    val the_ideal: Proof.context -> thm -> thm list
    val the_idom: Proof.context -> thm -> thm list
    val the_ring: Proof.context -> thm -> cterm list * thm list
    val the_semiring: Proof.context -> thm -> cterm list * thm list
  end
structure Semiring_Normalizer: SEMIRING_NORMALIZER
### ML warning (line 166 of "~~/src/HOL/Tools/SMT/smt_util.ML"):
### Matches are not exhaustive.
signature SMT_UTIL =
  sig
    val basicC: class
    val binders_conv: (Proof.context -> conv) -> Proof.context -> conv
    type class = string list
    val dest_all_cabs: cterm -> Proof.context -> cterm * Proof.context
    val dest_all_cbinders: cterm -> Proof.context -> cterm * Proof.context
    val dest_cabs: cterm -> Proof.context -> cterm * Proof.context
    val dest_cbinder: cterm -> Proof.context -> cterm * Proof.context
    val dest_conj: term -> term * term
    val dest_cprop: cterm -> cterm
    val dest_disj: term -> term * term
    val dest_funT: int -> typ -> typ list * typ
    val dest_symb_list: term -> term list
    type 'a dict = (class * 'a) list
    val dict_get: 'a dict -> class -> 'a option
    val dict_lookup: 'a dict -> class -> 'a list
    val dict_map_default: class * 'a -> ('a -> 'a) -> 'a dict -> 'a dict
    val dict_merge: ('a * 'a -> 'a) -> 'a dict * 'a dict -> 'a dict
    val dict_update: class * 'a -> 'a dict -> 'a dict
    val if_conv: (term -> bool) -> conv -> conv -> conv
    val if_exists_conv: (term -> bool) -> conv -> conv
    val if_true_conv: (term -> bool) -> conv -> conv
    val instT: ctyp -> ctyp * cterm -> cterm
    val instT': cterm -> ctyp * cterm -> cterm
    val instTs: ctyp list -> ctyp list * cterm -> cterm
    val is_number: term -> bool
    val mk_cequals: cterm -> cterm -> cterm
    val mk_const_pat: theory -> string -> (ctyp -> 'a) -> 'a * cterm
    val mk_cprop: cterm -> cterm
    val mk_symb_list: typ -> term list -> term
    datatype order = First_Order | Higher_Order
    val prop_conv: conv -> conv
    val prop_of: thm -> term
    val repeat: ('a -> 'a option) -> 'a -> 'a
    val repeat_yield: ('a -> 'b -> ('a * 'b) option) -> 'a -> 'b -> 'a * 'b
    val string_of_class: class -> string
    val symb_cons_const: typ -> term
    val symb_nil_const: typ -> term
    val term_of: cterm -> term
    val under_quant: (term -> 'a) -> term -> 'a
    val under_quant_conv:
       (Proof.context * cterm list -> conv) -> Proof.context -> conv
  end
structure SMT_Util: SMT_UTIL
signature SMT_FAILURE =
  sig
    exception SMT of failure
    datatype failure
    =
         Abnormal_Termination of int
       | Counterexample of bool
       | Other_Failure of string
       | Out_Of_Memory
       | Time_Out
    val string_of_failure: failure -> string
  end
structure SMT_Failure: SMT_FAILURE
signature SMT_CONFIG =
  sig
    val add_solver: solver_info -> Context.generic -> Context.generic
    val available_solvers_of: Proof.context -> string list
    val certificates_of: Proof.context -> Cache_IO.cache option
    val compress_verit_proofs: Proof.context -> bool
    val debug_files: string Config.T
    val explicit_application: int Config.T
    val get_timeout: Proof.context -> Time.time option
    val higher_order: bool Config.T
    val infer_triggers: bool Config.T
    val is_available: Proof.context -> string -> bool
    val monomorph_instances: int Config.T
    val monomorph_limit: int Config.T
    val nat_as_int: bool Config.T
    val native_bv: bool Config.T
    val oracle: bool Config.T
    val print_setup: Proof.context -> unit
    val random_seed: int Config.T
    val read_only_certificates: bool Config.T
    val reconstruction_step_timeout: real Config.T
    val sat_solver: string Config.T
    val select_certificates: string -> Context.generic -> Context.generic
    val select_solver: string -> Context.generic -> Context.generic
    val set_solver_options:
       string * string -> Context.generic -> Context.generic
    val solver_class_of: Proof.context -> SMT_Util.class
    type solver_info =
       {avail: unit -> bool,
        class: Proof.context -> SMT_Util.class,
        name: string, options: Proof.context -> string list}
    val solver_of: Proof.context -> string
    val solver_options_of: Proof.context -> string list
    val spy_Z3: Proof.context -> bool
    val spy_verit: Proof.context -> bool
    val statistics: bool Config.T
    val statistics_msg: Proof.context -> ('a -> string) -> 'a -> unit
    val timeout: real Config.T
    val trace: bool Config.T
    val trace_msg: Proof.context -> ('a -> string) -> 'a -> unit
    val verbose: bool Config.T
    val verbose_msg: Proof.context -> ('a -> string) -> 'a -> unit
    val verit_arith_msg: Proof.context -> (unit -> 'a) -> unit
    val verit_msg: Proof.context -> (unit -> 'a) -> unit
    val with_time_limit:
       Proof.context -> real Config.T -> ('a -> 'b) -> 'a -> 'b
    val with_timeout: Proof.context -> ('a -> 'b) -> 'a -> 'b
  end
structure SMT_Config: SMT_CONFIG
signature SMT_BUILTIN =
  sig
    val add_builtin_fun:
       SMT_Util.class ->
         (string * typ) * bfunr option bfun ->
           Context.generic -> Context.generic
    val add_builtin_fun':
       SMT_Util.class -> term * string -> Context.generic -> Context.generic
    val add_builtin_fun_ext:
       (string * typ) * term list bfun -> Context.generic -> Context.generic
    val add_builtin_fun_ext':
       string * typ -> Context.generic -> Context.generic
    val add_builtin_fun_ext'': string -> Context.generic -> Context.generic
    val add_builtin_typ:
       SMT_Util.class ->
         typ * (typ -> (string * typ list) option) *
         (typ -> int -> string option)
           -> Context.generic -> Context.generic
    val add_builtin_typ_ext:
       typ * (Proof.context -> typ -> bool) ->
         Context.generic -> Context.generic
    type 'a bfun = Proof.context -> typ -> term list -> 'a
    type bfunr = string * int * term list * (term list -> term)
    val dest_builtin:
       Proof.context -> string * typ -> term list -> bfunr option
    val dest_builtin_conn:
       Proof.context -> string * typ -> term list -> bfunr option
    val dest_builtin_eq: Proof.context -> term -> term -> bfunr option
    val dest_builtin_ext:
       Proof.context -> string * typ -> term list -> term list option
    val dest_builtin_fun:
       Proof.context -> string * typ -> term list -> bfunr option
    val dest_builtin_num: Proof.context -> term -> (string * typ) option
    val dest_builtin_pred:
       Proof.context -> string * typ -> term list -> bfunr option
    val dest_builtin_typ: Proof.context -> typ -> (string * typ list) option
    val filter_builtins: (typ -> bool) -> Proof.context -> Proof.context
    val is_builtin_fun: Proof.context -> string * typ -> term list -> bool
    val is_builtin_fun_ext:
       Proof.context -> string * typ -> term list -> bool
    val is_builtin_num: Proof.context -> term -> bool
    val is_builtin_num_ext: Proof.context -> term -> bool
    val is_builtin_typ_ext: Proof.context -> typ -> bool
  end
structure SMT_Builtin: SMT_BUILTIN
class comm_semiring_1_cancel_crossproduct = comm_semiring_1_cancel +
  assumes
    "crossproduct_eq":
      "!!w y x z. (w * y + x * z = w * z + x * y) = (w = x | y = z)"
### ML warning (line 96 of "~~/src/HOL/Tools/SMT/smt_datatypes.ML"):
### Pattern is not exhaustive.
signature SMT_DATATYPES =
  sig
    val add_decls:
       BNF_Util.fp_kind list ->
         typ ->
           (BNF_Util.fp_kind * (typ * (term * term list) list)) list list *
           Proof.context
             ->
             (BNF_Util.fp_kind * (typ * (term * term list) list)) list list
             *
             Proof.context
  end
structure SMT_Datatypes: SMT_DATATYPES
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
signature SMT_NORMALIZE =
  sig
    val abs_min_max_table: (string * thm) list
    val add_extra_norm:
       SMT_Util.class * extra_norm -> Context.generic -> Context.generic
    val atomize_conv: Proof.context -> conv
    val case_bool_entry: string * thm
    val drop_fact_warning: Proof.context -> thm -> unit
    type extra_norm =
       Proof.context -> thm list * thm list -> thm list * thm list
    val normalize: Proof.context -> thm list -> (int * thm) list
    val special_quant_table: (string * thm) list
  end
structure SMT_Normalize: SMT_NORMALIZE
locale comm_monoid_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_set (\<^bold>*) \<^bold>1"
class field = division_ring + idom_divide +
  assumes "field_inverse": "!!a. a ~= (0::'a) ==> inverse a * a = (1::'a)"
  assumes "field_divide_inverse": "!!a b. a / b = a * inverse b"
  assumes "field_inverse_zero": "inverse (0::'a) = (0::'a)"
### ML warning (line 152 of "~~/src/HOL/Tools/SMT/smt_translate.ML"):
### Value identifier (Ts) has not been referenced.
signature SMT_TRANSLATE =
  sig
    val add_config:
       SMT_Util.class * (Proof.context -> config) ->
         Context.generic -> Context.generic
    type config =
       {fp_kinds: BNF_Util.fp_kind list,
        logic: string -> term list -> string,
        order: SMT_Util.order,
        serialize:
        (string * string) list ->
          string list -> sign -> sterm list -> string}
    type replay_data =
       {assms: (int * thm) list,
        context: Proof.context,
        ll_defs: term list,
        rewrite_rules: thm list,
        terms: term Symtab.table, typs: typ Symtab.table}
    type sign =
       {dtyps:
        (BNF_Util.fp_kind *
         (string * (string * (string * string) list) list)
        )
        list
        ,
        funcs: (string * (string list * string)) list,
        logic: string, sorts: string list}
    datatype 'a spattern = SNoPat of 'a list | SPat of 'a list
    datatype squant = SExists | SForall
    datatype sterm
    =
         SConst of string * sterm list
       | SQua of squant * string list * sterm spattern list * sterm
       | SVar of int * sterm list
    val translate:
       Proof.context ->
         string ->
           (string * string) list ->
             string list -> (int * thm) list -> string * replay_data
  end
structure SMT_Translate: SMT_TRANSLATE
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### theory "HOL.Semiring_Normalization"
### 1.316s elapsed time, 4.052s cpu time, 0.661s GC time
Loading theory "HOL.Groebner_Basis" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer" via "HOL.Presburger")
signature SMTLIB =
  sig
    exception PARSE of int * string
    val parse: string list -> tree
    val pretty_tree: tree -> Pretty.T
    val str_of: tree -> string
    datatype tree
    =
         Dec of int * int
       | Key of string
       | Num of int
       | S of tree list
       | Str of string
       | Sym of string
  end
structure SMTLIB: SMTLIB
### ML warning (line 46 of "~~/src/HOL/Tools/SMT/smtlib_interface.ML"):
### Matches are not exhaustive.
signature SMTLIB_INTERFACE =
  sig
    val add_logic:
       int * (string -> term list -> string option) ->
         Context.generic -> Context.generic
    val assert_index_of_name: string -> int
    val assert_name_of_index: int -> string
    val assert_prefix: string
    val bvsmlibC: SMT_Util.class
    val del_logic:
       int * (string -> term list -> string option) ->
         Context.generic -> Context.generic
    val hosmtlibC: SMT_Util.class
    val smtlibC: SMT_Util.class
    val translate_config:
       SMT_Util.order -> Proof.context -> SMT_Translate.config
  end
structure SMTLIB_Interface: SMTLIB_INTERFACE
### ML warning (line 333 of "~~/src/HOL/Tools/SMT/smtlib_proof.ML"):
### Value identifier (body) has not been referenced.
### ML warning (line 333 of "~~/src/HOL/Tools/SMT/smtlib_proof.ML"):
### Value identifier (bindings) has not been referenced.
signature SMTLIB_PROOF =
  sig
    exception SMTLIB_PARSE of string * SMTLIB.tree
    val add_term_parser: term_parser -> Context.generic -> Context.generic
    val add_type_parser: type_parser -> Context.generic -> Context.generic
    type ('a, 'b) context
    val ctxt_of: ('a, 'b) context -> Proof.context
    val declare_fun:
       string ->
         typ ->
           ((string * typ) list, 'a) context ->
             ((string * typ) list, 'a) context
    val dest_binding: SMTLIB.tree -> string * 'a shared
    val empty_context:
       Proof.context ->
         typ Symtab.table -> term Symtab.table -> ('a list, 'b) context
    val empty_name_binding: name_bindings
    val expand_name_bindings:
       SMTLIB.tree -> name_bindings -> SMTLIB.tree * name_bindings
    val extract_and_update_name_bindings:
       SMTLIB.tree ->
         name_bindings -> (SMTLIB.tree * name_bindings) * string list
    val extract_name_bindings:
       SMTLIB.tree -> name_bindings -> name_bindings * string list
    val lookup_binding: ('a, 'b) context -> string -> 'b shared
    val mk_context:
       Proof.context ->
         int ->
           'a shared Symtab.table ->
             typ Symtab.table -> term Symtab.table -> 'b -> ('b, 'a) context
    type name_bindings
    val next_id: ('a, 'b) context -> int * ('a, 'b) context
    val remove_name_bindings: SMTLIB.tree -> SMTLIB.tree
    datatype 'a shared
    = None | Proof of 'a | Term of term | Tree of SMTLIB.tree
    val term_of:
       SMTLIB.tree ->
         ((string * (string * typ)) list, 'a) context ->
           term * ((string * (string * typ)) list, 'a) context
    type term_parser = SMTLIB.tree * term list -> term option
    val type_of: ('a, 'b) context -> SMTLIB.tree -> typ
    type type_parser = SMTLIB.tree * typ list -> typ option
    val update_binding:
       string * 'a shared -> ('b, 'a) context -> ('b, 'a) context
    val update_name_binding:
       Symtab.key * SMTLIB.tree -> name_bindings -> name_bindings
    val with_bindings:
       (string * 'a shared) list ->
         (('b, 'a) context -> 'c * ('d, 'a) context) ->
           ('b, 'a) context -> 'c * ('d, 'a) context
    val with_fresh_names:
       (('a list, 'b) context ->
          term * ((string * (string * typ)) list, 'b) context)
         -> ('c, 'b) context -> term * string list
  end
structure SMTLIB_Proof: SMTLIB_PROOF
### ML warning (line 41 of "~~/src/HOL/Tools/SMT/smtlib_isar.ML"):
### Matches are not exhaustive.
signature SMTLIB_ISAR =
  sig
    val distinguish_conjecture_and_hypothesis:
       ''a list ->
         ''b ->
           ''b ->
             ''b list ->
               (''a * term) list ->
                 term list ->
                   term -> (ATP_Problem.atp_formula_role * term) option
    val normalizing_prems:
       Proof.context -> term -> (string * string list) list
    val postprocess_step_conclusion:
       Proof.context -> thm list -> term list -> term -> term
    val unlift_term: term list -> term -> term
    val unskolemize_names: Proof.context -> term -> term
  end
structure SMTLIB_Isar: SMTLIB_ISAR
class unique_euclidean_semiring_with_nat = unique_euclidean_semiring +
  semiring_char_0 + semiring_parity +
  assumes "of_nat_div": "!!m n. of_nat (m div n) = of_nat m div of_nat n"
    and
    "division_segment_of_nat": "!!n. division_segment (of_nat n) = (1::'a)"
    and
    "division_segment_euclidean_size":
      "!!a. division_segment a * of_nat (euclidean_size a) = a"
### ML warning (line 121 of "~~/src/HOL/Tools/SMT/z3_proof.ML"):
### Value identifier (string_of_node) has not been referenced.
signature Z3_PROOF =
  sig
    val is_assumption: z3_rule -> bool
    val parse:
       typ Symtab.table ->
         term Symtab.table ->
           string list -> Proof.context -> z3_step list * Proof.context
    val string_of_rule: z3_rule -> string
    datatype z3_rule
    =
         And_Elim
       | Apply_Def
       | Asserted
       | Cnf_Star
       | Commutativity
       | Def_Axiom
       | Dest_Eq_Res
       | Distributivity
       | Elim_Unused_Vars
       | Goal
       | Hypothesis
       | Iff_False
       | Iff_Oeq
       | Iff_True
       | Intro_Def
       | Lemma
       | Modus_Ponens
       | Modus_Ponens_Oeq
       | Monotonicity
       | ...
    datatype z3_step
    =
         Z3_Step of
             {concl: term,
              fixes: string list,
              id: int, is_fix_step: bool, prems: int list, rule: z3_rule}
  end
structure Z3_Proof: Z3_PROOF
signature Z3_ISAR =
  sig
    val atp_proof_of_z3_proof:
       Proof.context ->
         term list ->
           thm list ->
             term list ->
               term ->
                 (string * term) list ->
                   int list ->
                     int ->
                       (int * string) list ->
                         Z3_Proof.z3_step list ->
                           (term, string) ATP_Proof.atp_step list
  end
structure Z3_Isar: Z3_ISAR
### Rewrite rule not in simpset:
### Wellfounded.accp fold_atLeastAtMost_nat_rel (?f1, ?a1, ?b1, ?acc1) ==>
### fold_atLeastAtMost_nat ?f1 ?a1 ?b1 ?acc1 ==
### if ?b1 < ?a1 then ?acc1
### else fold_atLeastAtMost_nat ?f1 (?a1 + 1) ?b1 (?f1 ?a1 ?acc1)
### theory "HOL.Set_Interval"
### 2.394s elapsed time, 6.701s cpu time, 1.103s GC time
Loading theory "HOL.Conditionally_Complete_Lattices" (required by "Draft.Pairing_AxiomTemplates" via "Main")
Loading theory "HOL.Filter" (required by "Draft.Pairing_AxiomTemplates" via "Main")
signature SMT_SOLVER =
  sig
    val add_solver: solver_config -> theory -> theory
    val default_max_relevant: Proof.context -> string -> int
    datatype outcome = Sat | Time_Out | Unknown | Unsat
    type parsed_proof =
       {atp_proof: unit -> (term, string) ATP_Proof.atp_step list,
        fact_ids:
        (int * ((string * ATP_Problem_Generate.stature) * thm)) list option,
        outcome: SMT_Failure.failure option}
    val smt_filter:
       Proof.context ->
         thm ->
           ((string * ATP_Problem_Generate.stature) * thm) list ->
             int -> Time.time -> parsed_proof
    val smt_tac: Proof.context -> thm list -> int -> tactic
    val smt_tac': Proof.context -> thm list -> int -> tactic
    type solver_config =
       {avail: unit -> bool,
        class: Proof.context -> SMT_Util.class,
        command: unit -> string list,
        default_max_relevant: int,
        name: string,
        options: Proof.context -> string list,
        outcome: string -> string list -> outcome * string list,
        parse_proof:
        (Proof.context ->
           SMT_Translate.replay_data ->
             ((string * ATP_Problem_Generate.stature) * thm) list ->
               term list -> term -> string list -> parsed_proof
        )
        option
        ,
        replay:
        (Proof.context -> SMT_Translate.replay_data -> string list -> thm)
        option
        ,
        smt_options: (string * string) list}
  end
structure SMT_Solver: SMT_SOLVER
signature CVC4_INTERFACE =
  sig
    val hosmtlib_cvc4C: SMT_Util.class
    val smtlib_cvc4C: SMT_Util.class
  end
structure CVC4_Interface: CVC4_INTERFACE
locale preordering_bdd
  fixes
    less_eq :: "'a => 'a => bool"  (infix \<open>\<^bold>\<le>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<^bold><\<close> 50)
  assumes "preordering_bdd (\<^bold>\<le>) (\<^bold><)"
signature CVC4_PROOF_PARSE =
  sig
    val parse_proof:
       SMT_Translate.replay_data ->
         ((string * ATP_Problem_Generate.stature) * thm) list ->
           term list -> term -> string list -> SMT_Solver.parsed_proof
  end
structure CVC4_Proof_Parse: CVC4_PROOF_PARSE
class preorder = ord +
  assumes "less_le_not_le": "!!x y. (x < y) = (x <= y & ~ y <= x)"
    and "order_refl": "!!x. x <= x"
    and "order_trans": "!!x y z. [| x <= y; y <= z |] ==> x <= z"
### ML warning (line 448 of "~~/src/HOL/Tools/groebner.ML"):
### Matches are not exhaustive.
### ML warning (line 458 of "~~/src/HOL/Tools/groebner.ML"):
### Matches are not exhaustive.
### ML warning (line 546 of "~~/src/HOL/Tools/groebner.ML"):
### Pattern is not exhaustive.
### ML warning (line 547 of "~~/src/HOL/Tools/groebner.ML"):
### Pattern is not exhaustive.
### ML warning (line 560 of "~~/src/HOL/Tools/groebner.ML"):
### Pattern is not exhaustive.
### ML warning (line 561 of "~~/src/HOL/Tools/groebner.ML"):
### Pattern is not exhaustive.
### ML warning (line 701 of "~~/src/HOL/Tools/groebner.ML"):
### Pattern is not exhaustive.
signature GROEBNER =
  sig
    val algebra_tac: thm list -> thm list -> Proof.context -> int -> tactic
    val ideal_tac: thm list -> thm list -> Proof.context -> int -> tactic
    val ring_and_ideal_conv:
       {field: cterm list * thm list,
        ideal: thm list,
        idom: thm list,
        ring: cterm list * thm list,
        semiring: cterm list * thm list, vars: cterm list}
         ->
         (cterm -> Rat.rat) ->
           (Rat.rat -> cterm) ->
             conv ->
               conv ->
                 {multi_ideal:
                  cterm list ->
                    cterm list -> cterm list -> (cterm * cterm) list
                  ,
                  poly_eq_ss: simpset,
                  ring_conv: Proof.context -> conv,
                  simple_ideal:
                  cterm list -> cterm -> cterm ord -> cterm list,
                  unwind_conv: Proof.context -> conv}
    val ring_tac: thm list -> thm list -> Proof.context -> int -> tactic
  end
structure Groebner: GROEBNER
class semiring_parity = semiring_modulo +
  assumes
    "even_iff_mod_2_eq_zero": "!!a. even a = (a mod (2::'a) = (0::'a))"
    and "odd_iff_mod_2_eq_one": "!!a. odd a = (a mod (2::'a) = (1::'a))"
    and "odd_one": "odd (1::'a)"
class order_top = order + top +
  assumes "top_greatest": "!!a. a <= \<top>"
locale is_filter
  fixes F :: "('a => bool) => bool"
  assumes "is_filter F"
class order_bot = bot + order +
  assumes "bot_least": "!!a. \<bottom> <= a"
### theory "HOL.Groebner_Basis"
### 0.679s elapsed time, 2.360s cpu time, 0.322s GC time
Loading theory "HOL.Presburger" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List" via "HOL.Sledgehammer")
val eventually_elim_tac = fn: thm list -> int -> context_tactic
instantiation
  filter :: (type) complete_lattice
  Inf_filter == Inf :: 'a filter set => 'a filter
  Sup_filter == Sup :: 'a filter set => 'a filter
  bot_filter == bot :: 'a filter
  sup_filter == sup :: 'a filter => 'a filter => 'a filter
  top_filter == top :: 'a filter
  inf_filter == inf :: 'a filter => 'a filter => 'a filter
  less_eq_filter == less_eq :: 'a filter => 'a filter => bool
  less_filter == less :: 'a filter => 'a filter => bool
### ML warning (line 274 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Value identifier (find_type_in_formula) has not been referenced.
### ML warning (line 301 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 324 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 333 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 332 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 365 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 392 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 446 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Pattern is not exhaustive.
### ML warning (line 437 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Pattern is not exhaustive.
### ML warning (line 470 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 505 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 511 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 542 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 583 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Value identifier (typ) has not been referenced.
### ML warning (line 586 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 593 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 605 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 703 of "~~/src/HOL/Tools/SMT/verit_proof.ML"):
### Matches are not exhaustive.
signature VERIT_PROOF =
  sig
    val all_veriT_stgies: Context.generic -> string list
    val contract_rule: string
    val eq_congruent_pred_rule: string
    val eq_congruent_rule: string
    val equiv_pos2_rule: string
    val input_rule: string
    val is_skolemization: string -> bool
    val is_skolemization_step: veriT_replay_node -> bool
    val ite_intro_rule: string
    val keep_app_symbols: string -> bool
    val keep_raw_lifting: string -> bool
    val la_generic_rule: string
    val local_input_rule: string
    val normalized_input_rule: string
    val not_not_rule: string
    val number_of_steps: veriT_replay_node list -> int
    val parse:
       typ Symtab.table ->
         term Symtab.table ->
           string list -> Proof.context -> veriT_step list * Proof.context
    val parse_replay:
       typ Symtab.table ->
         term Symtab.table ->
           string list ->
             Proof.context -> veriT_replay_node list * Proof.context
    val rewrite_rule: string
    val select_veriT_stgy: string -> Context.generic -> Context.generic
    val simp_arith_rule: string
    val skolemization_steps: string list
    val step_prefix: string
    val subproof_rule: string
    val th_resolution_rule: string
    val theory_resolution2_rule: string
    val valid_veriT_stgy: string -> Context.generic -> bool
    val veriT_current_strategy: Context.generic -> string list
    val veriT_deep_skolemize_rule: string
    val veriT_def: string
    datatype veriT_replay_node
    =
         VeriT_Replay_Node of
             {args: term list,
              bounds: (string * typ) list,
              concl: term,
              declarations: (string * term) list,
              id: string,
              insts: term Symtab.table,
              prems: string list,
              proof_ctxt: term list,
              rule: string,
              subproof:
              (string * typ) list * term list * term list *
              veriT_replay_node list}
    datatype veriT_step
    =
         VeriT_Step of
             {concl: term,
              fixes: string list,
              id: string,
              prems: string list, proof_ctxt: term list, rule: string}
    val veriT_strategy: string Config.T
    val verit_add_stgy:
       string * string list -> Context.generic -> Context.generic
    val verit_rm_stgy: string -> Context.generic -> Context.generic
    val verit_tac: Proof.context -> thm list -> int -> tactic
    val verit_tac_stgy: string -> Proof.context -> thm list -> int -> tactic
  end
structure Verit_Proof: VERIT_PROOF
signature VERIT_ISAR =
  sig
    val atp_proof_of_veriT_proof:
       Proof.context ->
         term list ->
           thm list ->
             term list ->
               term ->
                 (string * term) list ->
                   int list ->
                     int ->
                       (int * string) list ->
                         Verit_Proof.veriT_step list ->
                           (term, string) ATP_Proof.atp_step list
    type ('a, 'b) atp_step = ('a, 'b) ATP_Proof.atp_step
  end
structure VeriT_Isar: VERIT_ISAR
signature VERIT_PROOF_PARSE =
  sig
    type ('a, 'b) atp_step = ('a, 'b) ATP_Proof.atp_step
    val parse_proof:
       SMT_Translate.replay_data ->
         ((string * ATP_Problem_Generate.stature) * thm) list ->
           term list -> term -> string list -> SMT_Solver.parsed_proof
  end
structure VeriT_Proof_Parse: VERIT_PROOF_PARSE
### ML warning (line 21 of "~~/src/HOL/Tools/Qelim/qelim.ML"):
### Value identifier (ctxt) has not been referenced.
signature QELIM =
  sig
    val gen_qelim_conv:
       Proof.context ->
         conv ->
           conv ->
             conv ->
               (cterm -> 'a -> 'a) ->
                 'a -> ('a -> conv) -> ('a -> conv) -> ('a -> conv) -> conv
    val standard_qelim_conv:
       Proof.context ->
         (cterm list -> conv) ->
           (cterm list -> conv) -> (cterm list -> conv) -> conv
  end
structure Qelim: QELIM
signature CONJ_DISJ_PERM =
  sig val conj_disj_perm_tac: Proof.context -> int -> tactic end
structure Conj_Disj_Perm: CONJ_DISJ_PERM
class conditionally_complete_lattice = Inf + Sup + lattice +
  assumes
    "cInf_lower": "!!x X. [| x : X; bdd_below X |] ==> \<Sqinter> X <= x"
    and
    "cInf_greatest":
      "!!X z. [| X ~= {}; !!x. x : X ==> z <= x |] ==> z <= \<Sqinter> X"
  assumes
    "cSup_upper": "!!x X. [| x : X; bdd_above X |] ==> x <= \<Squnion> X"
    and
    "cSup_least":
      "!!X z. [| X ~= {}; !!x. x : X ==> x <= z |] ==> \<Squnion> X <= z"
signature SMT_REPLAY_METHODS =
  sig
    type abs_context = int * term Termtab.table
    val abstract_arith:
       Proof.context -> term -> abs_context -> term * abs_context
    val abstract_arith_shallow:
       Proof.context -> term -> abs_context -> term * abs_context
    val abstract_bool: term -> abs_context -> term * abs_context
    val abstract_bool_shallow: term -> abs_context -> term * abs_context
    val abstract_bool_shallow_equivalence:
       term -> abs_context -> term * abs_context
    val abstract_conj: term -> abs_context -> term * abs_context
    val abstract_disj: term -> abs_context -> term * abs_context
    val abstract_eq:
       (term ->
          int * term Termtab.table -> term * (int * term Termtab.table))
         ->
         term ->
           int * term Termtab.table -> term * (int * term Termtab.table)
    val abstract_lit: term -> abs_context -> term * abs_context
    val abstract_neq:
       (term ->
          int * term Termtab.table -> term * (int * term Termtab.table))
         ->
         term ->
           int * term Termtab.table -> term * (int * term Termtab.table)
    val abstract_not:
       (term -> abs_context -> term * abs_context) ->
         term -> abs_context -> term * abs_context
    val abstract_prop: term -> abs_context -> term * abs_context
    val abstract_term: term -> abs_context -> term * abs_context
    val abstract_unit: term -> abs_context -> term * abs_context
    type 'a abstracter = term -> abs_context -> 'a * abs_context
    val add_arith_abstracter:
       (term abstracter -> term option abstracter) ->
         Context.generic -> Context.generic
    val add_th_lemma_method:
       string * th_lemma_method -> Context.generic -> Context.generic
    val arith_th_lemma: Proof.context -> thm list -> term -> thm
    val arith_th_lemma_tac_with_wo:
       Proof.context -> thm list -> int -> tactic
    val arith_th_lemma_wo: Proof.context -> thm list -> term -> thm
    val arith_th_lemma_wo_shallow: Proof.context -> thm list -> term -> thm
    val certify_prop: Proof.context -> term -> cterm
    val cong_basic: Proof.context -> thm list -> term -> thm
    val cong_full: Proof.context -> thm list -> term -> thm
    val cong_unfolding_first: Proof.context -> thm list -> term -> thm
    val cong_unfolding_trivial: Proof.context -> thm list -> term -> thm
    val dest_prop: term -> term
    val dest_thm: thm -> term
    val discharge: int -> thm list -> thm -> thm
    val get_th_lemma_method: Proof.context -> th_lemma_method Symtab.table
    val match_instantiate: Proof.context -> term -> thm -> thm
    val pretty_goal:
       Proof.context -> string -> string -> thm list -> term -> Pretty.T
    val prop_tac: Proof.context -> thm list -> int -> tactic
    val prove:
       Proof.context -> term -> (Proof.context -> int -> tactic) -> thm
    val prove_abstract:
       Proof.context ->
         thm list ->
           term ->
             (Proof.context -> thm list -> int -> tactic) ->
               (abs_context -> (term list * term) * abs_context) -> thm
    val prove_abstract':
       Proof.context ->
         term ->
           (Proof.context -> thm list -> int -> tactic) ->
             (abs_context -> term * abs_context) -> thm
    val prove_arith_rewrite:
       ((term ->
           int * term Termtab.table -> term * (int * term Termtab.table))
          ->
          term ->
            int * term Termtab.table -> term * (int * term Termtab.table))
         -> Proof.context -> term -> thm
    val replay_error:
       Proof.context -> string -> string -> thm list -> term -> 'a
    val replay_rule_error:
       string -> Proof.context -> string -> thm list -> term -> 'a
    type th_lemma_method = Proof.context -> thm list -> term -> thm
    val trace: Proof.context -> (unit -> string) -> unit
    val trace_goal: Proof.context -> string -> thm list -> term -> unit
    val try_provers:
       string ->
         Proof.context ->
           string -> (string * (term -> 'a)) list -> thm list -> term -> 'a
  end
structure SMT_Replay_Methods: SMT_REPLAY_METHODS
### ML warning (line 30 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (times) has not been referenced.
### ML warning (line 33 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (times_dvd) has not been referenced.
### ML warning (line 44 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (one) has not been referenced.
### ML warning (line 51 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (plus) has not been referenced.
### ML warning (line 63 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (plus_semigroup_add) has not been referenced.
### ML warning (line 67 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (one_numeral) has not been referenced.
### ML warning (line 68 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semigroup_add_numeral) has not been referenced.
### ML warning (line 78 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (one_power) has not been referenced.
### ML warning (line 79 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (times_power) has not been referenced.
### ML warning (line 86 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (minus) has not been referenced.
### ML warning (line 114 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 122 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (divide) has not been referenced.
### ML warning (line 126 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 135 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (divide_modulo) has not been referenced.
### ML warning (line 136 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (dvd_modulo) has not been referenced.
### ML warning (line 144 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semigroup_add_ab_semigroup_add) has not been referenced.
### ML warning (line 149 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semigroup_add_monoid_add) has not been referenced.
### ML warning (line 151 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (zero_monoid_add) has not been referenced.
### ML warning (line 156 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (ab_semigroup_add_comm_monoid_add) has not been referenced.
### ML warning (line 158 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (monoid_add_comm_monoid_add) has not been referenced.
### ML warning (line 162 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (times_mult_zero) has not been referenced.
### ML warning (line 166 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (times_semigroup_mult) has not been referenced.
### ML warning (line 172 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (ab_semigroup_add_semiring) has not been referenced.
### ML warning (line 174 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semigroup_mult_semiring) has not been referenced.
### ML warning (line 180 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (comm_monoid_add_semiring_0) has not been referenced.
### ML warning (line 184 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_semiring_0) has not been referenced.
### ML warning (line 188 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_0_semiring_no_zero_divisors) has not been
###    referenced.
### ML warning (line 194 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semigroup_mult_monoid_mult) has not been referenced.
### ML warning (line 196 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (power_monoid_mult) has not been referenced.
### ML warning (line 202 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (monoid_mult_semiring_numeral) has not been referenced.
### ML warning (line 204 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (numeral_semiring_numeral) has not been referenced.
### ML warning (line 206 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_semiring_numeral) has not been referenced.
### ML warning (line 210 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (one_zero_neq_one) has not been referenced.
### ML warning (line 211 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (zero_zero_neq_one) has not been referenced.
### ML warning (line 217 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_numeral_semiring_1) has not been referenced.
### ML warning (line 221 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (zero_neq_one_semiring_1) has not been referenced.
### ML warning (line 228 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_1_semiring_1_no_zero_divisors) has not been
###    referenced.
### ML warning (line 231 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_no_zero_divisors_semiring_1_no_zero_divisors) has
###    not been referenced.
### ML warning (line 237 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semigroup_add_cancel_semigroup_add) has not been
###    referenced.
### ML warning (line 244 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (ab_semigroup_add_cancel_ab_semigroup_add) has not been
###    referenced.
### ML warning (line 247 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (cancel_semigroup_add_cancel_ab_semigroup_add) has not been
###    referenced.
### ML warning (line 250 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (minus_cancel_ab_semigroup_add) has not been referenced.
### ML warning (line 256 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (cancel_ab_semigroup_add_cancel_comm_monoid_add) has not
###    been referenced.
### ML warning (line 259 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (comm_monoid_add_cancel_comm_monoid_add) has not been
###    referenced.
### ML warning (line 266 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (cancel_comm_monoid_add_semiring_0_cancel) has not been
###    referenced.
### ML warning (line 269 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_0_semiring_0_cancel) has not been referenced.
### ML warning (line 274 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semigroup_mult_ab_semigroup_mult) has not been referenced.
### ML warning (line 280 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (ab_semigroup_mult_comm_semiring) has not been referenced.
### ML warning (line 282 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_comm_semiring) has not been referenced.
### ML warning (line 288 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (comm_semiring_comm_semiring_0) has not been referenced.
### ML warning (line 290 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_0_comm_semiring_0) has not been referenced.
### ML warning (line 296 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (comm_semiring_0_comm_semiring_0_cancel) has not been
###    referenced.
### ML warning (line 299 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_0_cancel_comm_semiring_0_cancel) has not been
###    referenced.
### ML warning (line 306 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_0_cancel_semiring_1_cancel) has not been
###    referenced.
### ML warning (line 308 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_1_semiring_1_cancel) has not been referenced.
### ML warning (line 315 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (ab_semigroup_mult_comm_monoid_mult) has not been
###    referenced.
### ML warning (line 317 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (monoid_mult_comm_monoid_mult) has not been referenced.
### ML warning (line 319 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (dvd_comm_monoid_mult) has not been referenced.
### ML warning (line 326 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (comm_monoid_mult_comm_semiring_1) has not been referenced.
### ML warning (line 328 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (comm_semiring_0_comm_semiring_1) has not been referenced.
### ML warning (line 337 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (comm_semiring_0_cancel_comm_semiring_1_cancel) has not
###    been referenced.
### ML warning (line 343 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_1_cancel_comm_semiring_1_cancel) has not been
###    referenced.
### ML warning (line 352 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_1_no_zero_divisors_semidom) has not been
###    referenced.
### ML warning (line 484 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier
###    (semiring_no_zero_divisors_semiring_no_zero_divisors_cancel) has not been
###    referenced.
### ML warning (line 492 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (divide_semidom_divide) has not been referenced.
### ML warning (line 496 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (semiring_no_zero_divisors_cancel_semidom_divide) has not
###    been referenced.
### ML warning (line 519 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (comm_semiring_1_cancel_semiring_modulo) has not been
###    referenced.
### ML warning (line 597 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 597 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 596 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 596 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 595 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 595 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 595 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 595 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 594 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 594 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 594 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 594 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 593 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 593 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 592 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 592 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 591 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 591 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 591 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 590 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 590 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 590 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 589 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 589 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 589 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 588 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 588 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 588 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 587 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 587 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 587 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 586 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 586 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 586 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x1) has not been referenced.
### ML warning (line 585 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 585 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 585 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 585 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 584 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 584 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 584 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 584 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 583 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 583 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 582 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 582 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 581 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 581 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 581 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 580 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 580 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 580 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 579 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 579 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 579 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 578 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 578 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 578 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 577 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 577 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 577 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 576 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 576 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 576 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x2) has not been referenced.
### ML warning (line 575 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 575 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 575 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 575 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 574 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 574 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 574 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 574 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 573 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 573 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 573 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 573 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 573 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 572 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 572 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 572 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 572 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 572 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 571 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 571 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 571 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 571 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 571 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 570 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 570 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 570 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 570 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 570 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 569 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 569 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 569 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 569 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 569 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 568 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 568 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 568 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x33) has not been referenced.
### ML warning (line 568 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x32) has not been referenced.
### ML warning (line 568 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x31) has not been referenced.
### ML warning (line 567 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 567 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 567 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 566 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 566 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 566 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 565 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 565 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 565 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 564 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 564 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 564 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 563 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 563 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 563 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 562 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 562 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 562 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 561 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 561 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 561 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 561 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 560 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 560 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 560 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 560 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 559 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 559 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 559 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 559 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 558 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 558 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 558 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x52) has not been referenced.
### ML warning (line 558 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x51) has not been referenced.
### ML warning (line 557 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 557 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 557 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 557 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 556 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x72) has not been referenced.
### ML warning (line 556 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x71) has not been referenced.
### ML warning (line 556 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x62) has not been referenced.
### ML warning (line 556 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x61) has not been referenced.
### ML warning (line 614 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (less) has not been referenced.
### ML warning (line 655 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 997 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 996 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 995 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 994 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 993 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 992 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 991 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 990 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 989 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 988 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 987 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 986 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 985 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 985 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 984 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 984 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 983 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 983 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 982 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 982 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 981 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 980 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 979 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 979 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 978 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 978 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 977 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 977 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 976 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 976 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 975 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 975 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 974 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 974 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 973 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 973 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 972 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 972 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 971 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 970 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 969 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 968 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 967 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 966 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 965 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 964 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 963 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 962 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 961 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 960 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 959 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 958 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 957 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 956 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 955 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 954 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 953 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 952 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 951 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 951 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 950 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 950 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 949 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 949 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 948 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 948 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 947 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 946 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 945 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 945 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 944 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 944 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 943 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 943 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 942 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 942 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 941 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 941 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 940 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 940 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 939 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 939 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 938 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 938 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 937 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 936 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 935 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 934 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 933 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 932 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 931 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 930 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 929 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 929 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 928 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 928 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 927 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 927 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 926 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 926 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 925 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 925 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 924 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 924 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 923 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 923 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 922 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 922 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 921 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 921 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 920 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 920 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 919 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 919 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 919 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 918 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 918 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 918 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 917 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 917 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 917 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 916 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 916 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 916 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 915 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 915 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 914 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 914 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 913 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 913 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 913 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 912 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 912 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 912 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 911 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 911 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 911 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 910 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 910 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 910 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 909 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 909 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 909 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 908 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 908 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 908 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 907 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 907 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 907 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 906 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 906 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 906 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 905 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 905 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 904 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 904 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 903 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 903 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 902 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 902 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 901 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 901 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 900 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 900 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 899 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 899 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 898 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 898 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x3) has not been referenced.
### ML warning (line 897 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 897 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 896 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 896 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 895 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 895 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 894 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 894 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 893 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 893 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 892 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 892 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 891 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 891 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 890 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 890 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 889 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 889 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 889 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 888 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 888 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 888 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 887 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 887 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 887 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 886 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 886 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 886 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 885 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 885 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 884 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 884 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 883 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 883 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 883 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 882 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 882 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 882 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 881 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 881 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 881 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 880 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 880 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 880 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 879 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 879 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 879 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 878 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 878 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 878 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 877 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 877 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 877 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 876 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 876 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 876 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 875 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 875 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 874 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 874 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 873 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 873 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 872 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 872 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 871 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 871 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 870 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 870 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 869 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 869 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 868 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 868 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x4) has not been referenced.
### ML warning (line 867 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 867 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 866 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 866 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 865 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 865 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 864 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 864 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 863 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 863 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 862 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 862 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 861 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 861 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 861 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 860 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 860 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 860 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 859 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 859 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 859 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 858 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 858 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 858 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 857 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 857 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 856 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 856 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 855 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 855 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 855 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 854 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 854 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 854 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 853 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 853 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 853 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 852 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 852 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 852 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 851 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 851 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 851 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 850 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 850 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 850 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 849 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 849 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 849 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 848 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 848 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 848 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 847 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 847 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 846 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 846 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 845 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 845 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 844 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 844 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 843 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 843 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 842 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 842 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 841 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 841 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 840 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 840 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x5) has not been referenced.
### ML warning (line 839 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 839 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 838 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 838 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 837 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 837 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 836 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 836 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 835 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 835 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 835 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 834 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 834 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 834 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 833 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 833 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 833 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 832 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 832 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 832 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 831 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 831 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 830 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 830 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 829 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 829 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 829 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 828 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 828 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 828 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 827 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 827 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 827 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 826 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 826 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 826 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 825 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 825 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 825 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 824 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 824 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 824 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 823 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 823 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 823 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 822 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 822 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 822 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 821 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 821 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 820 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 820 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 819 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 819 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 818 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 818 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 817 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 817 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 816 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 816 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 815 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 815 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 814 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 814 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x6) has not been referenced.
### ML warning (line 813 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 813 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 812 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 812 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 811 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 811 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 811 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 810 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 810 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 810 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 809 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 809 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 809 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 808 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 808 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 808 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 807 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 807 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 806 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 806 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 805 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 805 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 805 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 804 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 804 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 804 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 803 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 803 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 803 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 802 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 802 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 802 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 801 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 801 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 801 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 800 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 800 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 800 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 799 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 799 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 799 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 798 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 798 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 798 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 797 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 797 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 796 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 796 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 795 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 795 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 794 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 794 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 793 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 793 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 792 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 792 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 791 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 791 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 790 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 790 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x7) has not been referenced.
### ML warning (line 789 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 789 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 789 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 788 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 788 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 788 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 787 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 787 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 787 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 786 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 786 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 786 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 785 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 785 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 784 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 784 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 783 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 783 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 783 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 782 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 782 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 782 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 781 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 781 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 781 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 780 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 780 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 780 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 779 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 779 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 779 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 778 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 778 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 778 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 777 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 777 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 777 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 776 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 776 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 776 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 775 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 775 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 774 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 774 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 773 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 773 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 772 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 772 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 771 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 771 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 770 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 770 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 769 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 769 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 768 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 768 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x8) has not been referenced.
### ML warning (line 767 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 767 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 767 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 767 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 766 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 766 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 766 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 766 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 765 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 765 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 765 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 764 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 764 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 764 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 763 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 763 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 763 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 763 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 762 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 762 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 762 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 762 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 761 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 761 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 761 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 761 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 760 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 760 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 760 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 760 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 759 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 759 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 759 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 759 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 758 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 758 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 758 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 758 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 757 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 757 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 757 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 757 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 756 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 756 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 756 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 756 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 755 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 755 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 755 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 754 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 754 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 754 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 753 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 753 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 753 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 752 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 752 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 752 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 751 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 751 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 751 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 750 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 750 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 750 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 749 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 749 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 749 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 748 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 748 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x92) has not been referenced.
### ML warning (line 748 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x91) has not been referenced.
### ML warning (line 747 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 747 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 747 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 746 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 746 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 746 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 745 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 745 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 745 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 745 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 744 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 744 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 744 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 744 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 743 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 743 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 743 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 743 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 742 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 742 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 742 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 742 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 741 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 741 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 741 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 741 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 740 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 740 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 740 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 740 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 739 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 739 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 739 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 739 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 738 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 738 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 738 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 738 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 737 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 737 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 737 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 736 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 736 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 736 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 735 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 735 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 735 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 734 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 734 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 734 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 733 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 733 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 733 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 732 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 732 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 732 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 731 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 731 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 731 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 730 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 730 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x102) has not been referenced.
### ML warning (line 730 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x101) has not been referenced.
### ML warning (line 729 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 729 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 729 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 728 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 728 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 728 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 727 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 727 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 727 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 726 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 726 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 726 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 725 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 725 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 725 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 724 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 724 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 724 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 723 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 723 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 723 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 722 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 722 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 722 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 721 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 721 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 720 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 720 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 719 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 719 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 718 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 718 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 717 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 717 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 716 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 716 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 715 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 715 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 714 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 714 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x11) has not been referenced.
### ML warning (line 713 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 713 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 713 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 713 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 712 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 712 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 712 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 712 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 711 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 711 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 711 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 711 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 710 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 710 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 710 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 710 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 709 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 709 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 709 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 709 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 708 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 708 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 708 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 708 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 707 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 707 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 707 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 706 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 706 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 706 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 705 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 705 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 705 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 704 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 704 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 704 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 703 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 703 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 703 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 702 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 702 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 702 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 701 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 701 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 701 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 700 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 700 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x122) has not been referenced.
### ML warning (line 700 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x121) has not been referenced.
### ML warning (line 699 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 699 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 699 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 699 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 698 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 698 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 698 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 698 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 697 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 697 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 697 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 697 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 696 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 696 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 696 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 696 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 695 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 695 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 695 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 694 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 694 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 694 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 693 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 693 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 693 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 692 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 692 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 692 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 691 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 691 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 691 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 690 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 690 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 690 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 689 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 689 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 689 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 688 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 688 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x132) has not been referenced.
### ML warning (line 688 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x131) has not been referenced.
### ML warning (line 687 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 687 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 687 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 687 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 686 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 686 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 686 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 686 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 685 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 685 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 685 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 684 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 684 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 684 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 683 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 683 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 683 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 682 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 682 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 682 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 681 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 681 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 681 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 680 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 680 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 680 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 679 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 679 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 679 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 678 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 678 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x142) has not been referenced.
### ML warning (line 678 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x141) has not been referenced.
### ML warning (line 677 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 677 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 677 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 676 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 676 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 676 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 675 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 675 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 675 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 674 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 674 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 674 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 673 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 673 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 673 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 672 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 672 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 672 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 671 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 671 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 671 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 670 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 670 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x152) has not been referenced.
### ML warning (line 670 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x151) has not been referenced.
### ML warning (line 669 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 669 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 668 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 668 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 667 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 667 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 666 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 666 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 665 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 665 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 664 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 664 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x16) has not been referenced.
### ML warning (line 663 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 663 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 662 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 662 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 661 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 661 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 660 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 660 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x17) has not been referenced.
### ML warning (line 659 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 659 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 658 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x19) has not been referenced.
### ML warning (line 658 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x18) has not been referenced.
### ML warning (line 1118 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 1121 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1147 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1146 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1132 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1131 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 1131 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Matches are not exhaustive.
### ML warning (line 1388 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 1451 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1450 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1449 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1448 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1447 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1446 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1445 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1444 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1443 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1442 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1441 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1440 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1439 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1438 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1437 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1436 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1435 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1434 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1433 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1432 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1431 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1430 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1429 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1428 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1427 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1426 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1425 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1424 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1423 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1422 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1421 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1420 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1419 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1418 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1417 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1416 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1415 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1414 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1413 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1412 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1411 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1410 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1409 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1408 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1407 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1406 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1405 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1404 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1403 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1402 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1401 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1400 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1399 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1398 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1397 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1396 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1395 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (k) has not been referenced.
### ML warning (line 1527 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1527 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1525 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1525 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1524 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1523 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1522 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1521 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1520 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1520 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1519 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1519 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1518 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1517 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1517 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1517 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1516 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1516 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1516 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1515 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1515 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1515 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1514 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1514 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1513 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1513 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1512 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1512 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1511 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1511 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1511 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1510 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1510 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1510 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1509 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1509 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1509 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1508 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1508 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1507 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1507 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1506 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1506 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1505 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1504 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1503 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1502 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1501 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1500 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1586 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1584 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1583 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1583 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1582 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1582 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1580 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1579 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1578 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1577 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1576 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1575 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1574 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1574 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1573 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1573 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1572 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1571 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1571 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1570 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1570 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1569 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1569 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1568 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1568 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1567 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1567 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1566 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1565 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1564 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1563 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1563 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1562 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1562 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1561 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1561 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1560 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1559 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1558 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1557 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1557 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1556 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1556 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1555 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1555 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1554 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1553 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1552 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1551 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1551 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1550 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1550 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1549 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1549 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1548 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1547 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1546 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1545 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1545 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1544 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1544 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1543 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1543 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1542 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1541 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1540 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1539 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1539 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1538 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1538 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1537 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1537 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1536 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1535 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1534 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1655 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1655 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1653 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1653 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (i) has not been referenced.
### ML warning (line 1652 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1651 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1650 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1649 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1648 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1647 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1646 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1645 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1644 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1643 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1642 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1642 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1641 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1641 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1640 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1639 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1639 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1639 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1638 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1638 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1638 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1637 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1637 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1637 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1636 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1636 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1635 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1635 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1634 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1634 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1633 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1633 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1633 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1632 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1632 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1632 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1631 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vc) has not been referenced.
### ML warning (line 1631 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1631 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1630 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1630 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1629 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1629 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1628 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1628 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1627 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1627 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1626 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1626 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1625 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1625 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1624 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1623 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1622 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1621 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1621 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1620 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1620 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1619 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1619 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1618 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1617 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1616 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1615 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1615 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1614 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1614 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1613 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1613 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1612 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1611 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1610 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1609 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1609 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1608 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1608 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1607 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1607 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1606 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1605 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1604 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1603 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1603 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1602 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1602 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1601 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1601 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1600 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1599 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1598 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1597 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1597 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1596 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1596 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1595 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1595 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1594 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1593 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1592 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1714 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1712 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1710 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1709 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1708 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1708 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1707 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (e) has not been referenced.
### ML warning (line 1707 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (c) has not been referenced.
### ML warning (line 1706 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1705 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1704 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1703 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1702 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1702 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1701 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1701 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1700 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1699 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1699 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1698 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1698 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (v) has not been referenced.
### ML warning (line 1697 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1697 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1696 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1696 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1695 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1695 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1694 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1693 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1692 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1691 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1691 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1690 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1690 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1689 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1689 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1688 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1687 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1686 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1685 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1685 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1684 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1684 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1683 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1683 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1682 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1681 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1680 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1679 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1679 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1678 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1678 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1677 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1677 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1676 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1675 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1674 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1673 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1673 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1672 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1672 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1671 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1671 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1670 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1669 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1668 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1667 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1667 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1666 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1666 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1665 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (vb) has not been referenced.
### ML warning (line 1665 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1664 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1663 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1662 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (va) has not been referenced.
### ML warning (line 1801 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 1801 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (A_) has not been referenced.
### ML warning (line 1804 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (A_) has not been referenced.
### ML warning (line 1996 of "~~/src/HOL/Tools/Qelim/cooper_procedure.ML"):
### Value identifier (f) has not been referenced.
structure Cooper_Procedure:
  sig
    datatype fm
    =
         A of fm
       | And of fm * fm
       | Closed of nat
       | Dvd of inta * numa
       | E of fm
       | Eq of numa
       | F
       | Ge of numa
       | Gt of numa
       | Iff of fm * fm
       | Imp of fm * fm
       | Le of numa
       | Lt of numa
       | NClosed of nat
       | NDvd of inta * numa
       | NEq of numa
       | Not of fm
       | Or of ...
       | ...
    datatype inta = Int_of_integer of int
    val integer_of_int: inta -> int
    val integer_of_nat: nat -> int
    type nat
    val nat_of_integer: int -> nat
    datatype numa
    =
         Add of numa * numa
       | Bound of nat
       | C of inta
       | CN of nat * inta * numa
       | Mul of inta * numa
       | Neg of numa
       | Sub of numa * numa
    val pa: fm -> fm
  end
signature SMT_REPLAY =
  sig
    val add_asserted:
       ('a * ('b * thm) -> 'c -> 'c) ->
         'c ->
           ('d -> 'a * 'e * term * 'b) ->
             ('e -> bool) ->
               Proof.context ->
                 thm list ->
                   (int * thm) list ->
                     'd list ->
                       Proof.context ->
                         ((int * ('a * thm)) list * thm list) *
                         (Proof.context * 'c)
    val add_simproc: simproc -> Context.generic -> Context.generic
    val compose: compose_data -> thm -> thm
    type compose_data = cterm list * (cterm -> cterm list) * thm
    val discharge: thm -> thm -> thm
    val intermediate_statistics:
       Proof.context -> Timing.start -> int -> int -> unit
    val make_simpset: Proof.context -> thm list -> simpset
    val net_instances: (int * thm) Net.net -> cterm -> (int * thm) list
    val params_of: term -> (string * typ) list
    val precompose: (cterm -> cterm list) -> thm -> compose_data
    val precompose2: (cterm -> cterm * cterm) -> thm -> compose_data
    val pretty_statistics:
       string -> int -> int list Symtab.table -> Pretty.T
    val print_stats: (string * int list) list -> string
    val spying: bool -> Proof.context -> (unit -> string) -> string -> unit
    val thm_net_of: ('a -> thm) -> 'a list -> 'a Net.net
    val under_assumption: (thm -> thm) -> cterm -> thm
    val varify: Proof.context -> thm -> thm
  end
structure SMT_Replay: SMT_REPLAY
Proofs for inductive predicate(s) "rel_filter"
  Proving monotonicity ...
### ML warning (line 64 of "~~/src/HOL/Tools/SMT/smt_replay_arith.ML"):
### Pattern is not exhaustive.
signature SMT_REPLAY_ARITH =
  sig
    val la_farkas: term list -> Proof.context -> int -> tactic
    val la_farkas_tac: Subgoal.focus -> term list -> thm -> thm Seq.seq
  end
structure SMT_Replay_Arith: SMT_REPLAY_ARITH
instantiation
  filter :: (equal) equal
  equal_filter == equal_class.equal :: 'a filter => 'a filter => bool
### theory "HOL.Filter"
### 1.075s elapsed time, 4.169s cpu time, 0.621s GC time
signature Z3_INTERFACE =
  sig
    val add_mk_builtins: mk_builtins -> Context.generic -> Context.generic
    val is_builtin_theory_term: Proof.context -> term -> bool
    val mk_builtin_fun: Proof.context -> sym -> cterm list -> cterm option
    val mk_builtin_num: Proof.context -> int -> typ -> cterm option
    val mk_builtin_typ: Proof.context -> sym -> typ option
    type mk_builtins =
       {mk_builtin_fun: theory -> sym -> cterm list -> cterm option,
        mk_builtin_num: theory -> int -> typ -> cterm option,
        mk_builtin_typ: sym -> typ option}
    val smtlib_z3C: SMT_Util.class
    datatype sym = Sym of string * sym list
  end
structure Z3_Interface: Z3_INTERFACE
signature Z3_REPLAY_RULES =
  sig val apply: Proof.context -> cterm -> thm option end
structure Z3_Replay_Rules: Z3_REPLAY_RULES
signature Z3_REPLAY_METHODS =
  sig
    val and_elim: z3_method
    val apply_def: z3_method
    val arith_th_lemma: z3_method
    val comm: z3_method
    val cong: z3_method
    val def_axiom: z3_method
    val dest_eq_res: z3_method
    val distrib: z3_method
    val elim_unused: z3_method
    val iff_false: z3_method
    val iff_oeq: z3_method
    val iff_true: z3_method
    val lemma: z3_method
    val method_for: Z3_Proof.z3_rule -> z3_method
    val mp: z3_method
    val mp_oeq: z3_method
    val nnf_neg: z3_method
    val nnf_pos: z3_method
    val not_or_elim: z3_method
    val pull_quant: z3_method
    val push_quant: z3_method
    val quant_inst: z3_method
    val quant_intro: z3_method
    val refl: z3_method
    val rewrite: z3_method
    val rewrite_star: z3_method
    val symm: z3_method
    val th_lemma: string -> z3_method
    val trans: z3_method
    val true_axiom: z3_method
    val unit_res: z3_method
    type z3_method = Proof.context -> thm list -> term -> thm
  end
structure Z3_Replay_Methods: Z3_REPLAY_METHODS
### ML warning (line 138 of "~~/src/HOL/Tools/SMT/z3_replay.ML"):
### Matches are not exhaustive.
signature Z3_REPLAY =
  sig
    val parse_proof:
       Proof.context ->
         SMT_Translate.replay_data ->
           ((string * ATP_Problem_Generate.stature) * thm) list ->
             term list -> term -> string list -> SMT_Solver.parsed_proof
    val replay:
       Proof.context -> SMT_Translate.replay_data -> string list -> thm
  end
structure Z3_Replay: Z3_REPLAY
### Ignoring duplicate rewrite rule:
### is_unit ?x1 == \<bar>?x1\<bar> = 1
### Ignoring duplicate rewrite rule:
### if False then ?x1 else ?y == ?y
### Ignoring duplicate rewrite rule:
### if True then ?y else ?y1 == ?y
### Ignoring duplicate rewrite rule:
### (0::?'a1) + ?y == ?y
### Ignoring duplicate rewrite rule:
### ~ ~ ?y == ?y
### Ignoring duplicate rewrite rule:
### (~ ?P1) = (~ ?Q1) == ?P1 = ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 ~= ?Q1 == ?P1 = (~ ?Q1)
### Ignoring duplicate rewrite rule:
### ?P1 | ~ ?P1 == True
### Ignoring duplicate rewrite rule:
### ~ ?P1 | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?x1 = ?x1 == True
### Ignoring duplicate rewrite rule:
### ~ True == False
### Ignoring duplicate rewrite rule:
### ~ False == True
### Ignoring duplicate rewrite rule:
### (~ ?P1) = ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 = (~ ?P1) == False
### Ignoring duplicate rewrite rule:
### True = ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y = True == ?y
### Ignoring duplicate rewrite rule:
### False = ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 = False == ~ ?P1
### Ignoring duplicate rewrite rule:
### True --> ?y == ?y
### Ignoring duplicate rewrite rule:
### False --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> True == True
### Ignoring duplicate rewrite rule:
### ?P1 --> ?P1 == True
### Ignoring duplicate rewrite rule:
### ?P1 --> False == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?P1 --> ~ ?P1 == ~ ?P1
### Ignoring duplicate rewrite rule:
### ?y & True == ?y
### Ignoring duplicate rewrite rule:
### True & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & False == False
### Ignoring duplicate rewrite rule:
### False & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?y & ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 & ?P1 & ?Q1 == ?P1 & ?Q1
### Ignoring duplicate rewrite rule:
### ?P1 & ~ ?P1 == False
### Ignoring duplicate rewrite rule:
### ~ ?P1 & ?P1 == False
### Ignoring duplicate rewrite rule:
### ?P1 | True == True
### Ignoring duplicate rewrite rule:
### True | ?P1 == True
### Ignoring duplicate rewrite rule:
### ?y | False == ?y
### Ignoring duplicate rewrite rule:
### False | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?y | ?y == ?y
### Ignoring duplicate rewrite rule:
### ?P1 | ?P1 | ?Q1 == ?P1 | ?Q1
### Ignoring duplicate rewrite rule:
### ALL x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. ?y == ?y
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 == True
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x == True
### Ignoring duplicate rewrite rule:
### EX x. x = ?t1 & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### EX x. ?t1 = x & ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x = ?t1 --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 = x --> ?P1 x == ?P1 ?t1
### Ignoring duplicate rewrite rule:
### ALL x. x ~= ?t1 == False
### Ignoring duplicate rewrite rule:
### ALL x. ?t1 ~= x == False
### Ignoring duplicate rewrite rule:
### ?a1 div ?c1 + ?b1 div ?c1 + (?a1 mod ?c1 + ?b1 mod ?c1) div ?c1 ==
### (?a1 + ?b1) div ?c1
### ML warning (line 158 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Matches are not exhaustive.
### ML warning (line 189 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Matches are not exhaustive.
### ML warning (line 209 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Matches are not exhaustive.
### ML warning (line 231 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (tm) has not been referenced.
### ML warning (line 238 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (y) has not been referenced.
### ML warning (line 238 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (x) has not been referenced.
### ML warning (line 297 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 372 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Pattern is not exhaustive.
### ML warning (line 494 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Matches are not exhaustive.
### ML warning (line 597 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (a) has not been referenced.
### ML warning (line 615 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 614 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 613 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 612 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 657 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 653 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 651 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 649 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 647 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 632 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 632 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 631 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 631 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 660 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 689 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 686 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 685 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 684 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 683 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 682 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 680 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 674 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 674 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 673 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 673 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Value identifier (ps) has not been referenced.
### ML warning (line 673 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Matches are not exhaustive.
### ML warning (line 788 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Matches are not exhaustive.
### ML warning (line 791 of "~~/src/HOL/Tools/Qelim/cooper.ML"):
### Matches are not exhaustive.
signature COOPER =
  sig
    exception COOPER of string
    val add: term list -> attribute
    val conv: Proof.context -> conv
    val del: term list -> attribute
    type entry
    val get: Proof.context -> entry
    val tac: bool -> thm list -> thm list -> Proof.context -> int -> tactic
  end
structure Cooper: COOPER
class semiring_parity = semiring_modulo +
  assumes
    "even_iff_mod_2_eq_zero": "!!a. even a = (a mod (2::'a) = (0::'a))"
    and "odd_iff_mod_2_eq_one": "!!a. odd a = (a mod (2::'a) = (1::'a))"
    and "odd_one": "odd (1::'a)"
### ML warning (line 353 of "~~/src/HOL/Tools/SMT/verit_replay_methods.ML"):
### Matches are not exhaustive.
### ML warning (line 812 of "~~/src/HOL/Tools/SMT/verit_replay_methods.ML"):
### Matches are not exhaustive.
### ML warning (line 817 of "~~/src/HOL/Tools/SMT/verit_replay_methods.ML"):
### Matches are not exhaustive.
### ML warning (line 822 of "~~/src/HOL/Tools/SMT/verit_replay_methods.ML"):
### Matches are not exhaustive.
### ML warning (line 827 of "~~/src/HOL/Tools/SMT/verit_replay_methods.ML"):
### Matches are not exhaustive.
### ML warning (line 1188 of "~~/src/HOL/Tools/SMT/verit_replay_methods.ML"):
### Matches are not exhaustive.
signature VERIT_REPLAY_METHODS =
  sig
    val discharge: Proof.context -> thm list -> term -> thm
    val eq_congruent_pred: Proof.context -> 'a -> term -> thm
    val method_for:
       string ->
         Proof.context ->
           thm list ->
             term list ->
               term Symtab.table -> (string * term) list -> term -> thm
    val requires_local_input: string list -> string -> bool
    val requires_subproof_assms: string list -> string -> bool
  end
structure Verit_Replay_Methods: VERIT_REPLAY_METHODS
class linear_continuum = conditionally_complete_linorder + dense_linorder +
  assumes "UNIV_not_singleton": "EX a b. a ~= b"
instantiation
  nat :: conditionally_complete_linorder
  Inf_nat == Inf :: nat set => nat
  Sup_nat == Sup :: nat set => nat
instantiation
  int :: conditionally_complete_linorder
  Inf_int == Inf :: int set => int
  Sup_int == Sup :: int set => int
### theory "HOL.Conditionally_Complete_Lattices"
### 1.970s elapsed time, 6.927s cpu time, 1.144s GC time
### ML warning (line 117 of "~~/src/HOL/Tools/SMT/verit_replay.ML"):
### Matches are not exhaustive.
signature VERIT_REPLAY =
  sig
    val replay:
       Proof.context -> SMT_Translate.replay_data -> string list -> thm
  end
structure Verit_Replay: VERIT_REPLAY
signature SMT_SYSTEMS =
  sig
    val cvc4_extensions: bool Config.T
    val z3_extensions: bool Config.T
  end
structure SMT_Systems: SMT_SYSTEMS
### theory "HOL.SMT"
### 3.802s elapsed time, 12.431s cpu time, 2.090s GC time
class linordered_idom = ring_char_0 + idom_abs_sgn +
  linordered_ring_strict + linordered_semidom +
  linordered_semiring_1_strict + ordered_comm_ring + ordered_ring_abs +
  assumes
    "sgn_if":
      "!!x. sgn x =
            (if x = (0::'a) then 0::'a
             else if (0::'a) < x then 1::'a else - (1::'a))"
signature TRY0 =
  sig
    val noneN: string
    val silence_methods: bool -> Proof.context -> Proof.context
    val try0:
       Time.time option ->
         string list * string list * string list * string list ->
           Proof.state -> bool
  end
structure Try0: TRY0
### theory "HOL.Presburger"
### 1.956s elapsed time, 6.271s cpu time, 1.140s GC time
Loading theory "HOL.Sledgehammer" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.List")
### ML warning (line 30 of "~~/src/HOL/Tools/ATP/system_on_tptp.ML"):
### Matches are not exhaustive.
signature SYSTEM_ON_TPTP =
  sig
    val get_url: unit -> string
    val list_systems: unit -> {systems: string list, url: string}
    val run_system:
       {extra: string, problem: Path.T, system: string, timeout: Time.time}
         -> {output: string, timing: Time.time}
    val run_system_encoded:
       string list -> {output: string, timing: Time.time}
  end
structure SystemOnTPTP: SYSTEM_ON_TPTP
### ML warning (line 24 of "~~/src/HOL/Tools/Sledgehammer/async_manager_legacy.ML"):
### Handler catches all exceptions.
signature ASYNC_MANAGER_LEGACY =
  sig
    val has_running_threads: string -> bool
    val thread:
       string ->
         Time.time ->
           Time.time -> string * string -> (unit -> bool * string) -> unit
  end
structure Async_Manager_Legacy: ASYNC_MANAGER_LEGACY
### ML warning (line 38 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_util.ML"):
### Matches are not exhaustive.
### ML warning (line 96 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_util.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER_UTIL =
  sig
    val app_hd: ('a -> 'a) -> 'a list -> 'a list
    val hackish_string_of_term: Proof.context -> term -> string
    val log2: real -> real
    val one_day: Time.time
    val one_year: Time.time
    val parse_bool_option: bool -> string -> string -> bool option
    val parse_time: string -> string -> Time.time
    val plural_s: int -> string
    val serial_commas: string -> string list -> string list
    val simplify_spaces: string -> string
    val sledgehammerN: string
    val spying:
       bool -> (unit -> Proof.state * int * string * string) -> unit
    val subgoal_count: Proof.state -> int
    val thms_in_proof:
       int ->
         (string Symtab.table * string Symtab.table) option ->
           thm -> string list option
    val thms_of_name: Proof.context -> string -> thm list
    val with_cleanup: ('a -> unit) -> ('a -> 'b) -> 'a -> 'b
  end
structure Sledgehammer_Util: SLEDGEHAMMER_UTIL
### ML warning (line 359 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_fact.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER_FACT =
  sig
    val all_facts:
       Proof.context ->
         bool ->
           Keyword.keywords ->
             thm list -> thm list -> status Termtab.table -> lazy_fact list
    val build_name_tables:
       (thm -> string) ->
         ('a * thm) list -> string Symtab.table * string Symtab.table
    val cartouche_thm: Proof.context -> thm -> string
    val clasimpset_rule_table_of: Proof.context -> status Termtab.table
    val drop_duplicate_facts: lazy_fact list -> lazy_fact list
    type fact = (string * stature) * thm
    val fact_distinct:
       (term * term -> bool) -> ('a * thm) list -> ('a * thm) list
    val fact_of_lazy_fact: lazy_fact -> fact
    val fact_of_ref:
       Proof.context ->
         Keyword.keywords ->
           thm list ->
             status Termtab.table ->
               Facts.ref * Token.src list -> ((string * stature) * thm) list
    type fact_override =
       {add: (Facts.ref * Token.src list) list,
        del: (Facts.ref * Token.src list) list, only: bool}
    val instantiate_inducts:
       Proof.context ->
         term list ->
           term ->
             (((unit -> string) * 'a) * thm) list ->
               (((unit -> string) * 'a) * thm) list
    val is_blacklisted_or_something: string -> bool
    val is_useful_unnamed_local_fact: Proof.context -> thm -> bool
    type lazy_fact = ((unit -> string) * stature) * thm
    val nearly_all_facts:
       Proof.context ->
         bool ->
           fact_override ->
             Keyword.keywords ->
               status Termtab.table ->
                 thm list -> term list -> term -> lazy_fact list
    val no_fact_override: fact_override
    type stature = ATP_Problem_Generate.stature
    eqtype status
  end
structure Sledgehammer_Fact: SLEDGEHAMMER_FACT
### ML warning (line 143 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_proof_methods.ML"):
### Matches are not exhaustive.
### ML warning (line 174 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_proof_methods.ML"):
### Value identifier (used_chaineds) has not been referenced.
signature SLEDGEHAMMER_PROOF_METHODS =
  sig
    datatype SMT_backend = SMT_Verit of string | SMT_Z3
    val is_proof_method_direct: proof_method -> bool
    type one_line_params =
       ((string * stature) list * (proof_method * play_outcome)) * string *
       int * int
    val one_line_proof_text:
       Proof.context -> int -> one_line_params -> string
    datatype play_outcome
    = Play_Failed | Play_Timed_Out of Time.time | Played of Time.time
    val play_outcome_ord: play_outcome ord
    datatype proof_method
    =
         Algebra_Method
       | Auto_Method
       | Blast_Method
       | Fastforce_Method
       | Force_Method
       | Linarith_Method
       | Meson_Method
       | Metis_Method of string option * string option
       | Moura_Method
       | Presburger_Method
       | SATx_Method
       | SMT_Method of SMT_backend
       | Simp_Method
    type stature = ATP_Problem_Generate.stature
    val string_of_play_outcome: play_outcome -> string
    val string_of_proof_method: string list -> proof_method -> string
    val tac_of_proof_method:
       Proof.context -> thm list * thm list -> proof_method -> int -> tactic
  end
structure Sledgehammer_Proof_Methods: SLEDGEHAMMER_PROOF_METHODS
### ML warning (line 35 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_annotate.ML"):
### Pattern is not exhaustive.
signature SLEDGEHAMMER_ISAR_ANNOTATE =
  sig val annotate_types_in_term: Proof.context -> term -> term end
structure Sledgehammer_Isar_Annotate: SLEDGEHAMMER_ISAR_ANNOTATE
### ML warning (line 328 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 453 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_proof.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER_ISAR_PROOF =
  sig
    structure Canonical_Label_Tab: TABLE
    val add_isar_steps: isar_step list -> int -> int
    val canonical_label_ord: label ord
    val chain_isar_proof: isar_proof -> isar_proof
    val comment_isar_proof:
       (label -> proof_method list -> string) -> isar_proof -> isar_proof
    type facts = label list * string list
    val facts_of_isar_step: isar_step -> facts
    val fold_isar_steps:
       (isar_step -> 'a -> 'a) -> isar_step list -> 'a -> 'a
    datatype isar_proof
    =
         Proof of
             {assumptions: (label * term) list,
              fixes: (string * typ) list, steps: isar_step list}
    val isar_proof_with_steps: isar_proof -> isar_step list -> isar_proof
    datatype isar_qualifier = Show | Then
    datatype isar_step
    =
         Let of {lhs: term, rhs: term}
       | Prove of
           {comment: string,
            facts: facts,
            goal: term,
            label: label,
            obtains: (string * typ) list,
            proof_methods: proof_method list,
            qualifiers: isar_qualifier list, subproofs: isar_proof list}
    val kill_useless_labels_in_isar_proof: isar_proof -> isar_proof
    type label = string * int
    val label_of_isar_step: isar_step -> label option
    val label_ord: label ord
    val map_isar_steps: (isar_step -> isar_step) -> isar_proof -> isar_proof
    val no_label: label
    eqtype proof_method
    val proof_methods_of_isar_step: isar_step -> proof_method list
    val rationalize_obtains_in_isar_proofs:
       Proof.context -> isar_proof -> isar_proof
    val relabel_isar_proof_canonically: isar_proof -> isar_proof
    val relabel_isar_proof_nicely: isar_proof -> isar_proof
    val sort_facts: facts -> facts
    val steps_of_isar_proof: isar_proof -> isar_step list
    val string_of_isar_proof:
       Proof.context -> int -> int -> isar_proof -> string
    val string_of_label: label -> string
  end
structure Sledgehammer_Isar_Proof: SLEDGEHAMMER_ISAR_PROOF
### ML warning (line 131 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_preplay.ML"):
### Matches are not exhaustive.
### ML warning (line 188 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_preplay.ML"):
### Matches are not exhaustive.
### ML warning (line 219 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_preplay.ML"):
### Pattern is not exhaustive.
signature SLEDGEHAMMER_ISAR_PREPLAY =
  sig
    val enrich_context_with_local_facts:
       isar_proof -> Proof.context -> Proof.context
    val fastest_method_of_isar_step:
       isar_preplay_data -> label -> proof_method
    val forced_intermediate_preplay_outcome_of_isar_step:
       isar_preplay_data -> label -> play_outcome
    type isar_preplay_data
    eqtype isar_proof
    eqtype isar_step
    type label = Sledgehammer_Isar_Proof.label
    val peek_at_outcome: play_outcome lazy -> play_outcome
    eqtype play_outcome
    val preplay_isar_step:
       Proof.context ->
         thm list ->
           Time.time ->
             proof_method list ->
               isar_step -> (proof_method * play_outcome) list
    val preplay_isar_step_for_method:
       Proof.context ->
         thm list -> Time.time -> proof_method -> isar_step -> play_outcome
    val preplay_outcome_of_isar_proof:
       isar_preplay_data -> isar_proof -> play_outcome
    val preplay_outcome_of_isar_step_for_method:
       isar_preplay_data -> label -> proof_method -> play_outcome lazy
    eqtype proof_method
    val set_preplay_outcomes_of_isar_step:
       Proof.context ->
         Time.time ->
           isar_preplay_data ref ->
             isar_step -> (proof_method * play_outcome) list -> unit
    val trace: bool Config.T
  end
structure Sledgehammer_Isar_Preplay: SLEDGEHAMMER_ISAR_PREPLAY
### ML warning (line 107 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_compress.ML"):
### Matches are not exhaustive.
### ML warning (line 206 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_compress.ML"):
### Pattern is not exhaustive.
### ML warning (line 198 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_compress.ML"):
### Matches are not exhaustive.
### ML warning (line 183 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_compress.ML"):
### Matches are not exhaustive.
### ML warning (line 252 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_compress.ML"):
### Pattern is not exhaustive.
### ML warning (line 257 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_compress.ML"):
### Matches are not exhaustive.
### ML warning (line 269 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_compress.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER_ISAR_COMPRESS =
  sig
    val compress_isar_proof:
       Proof.context ->
         real ->
           Time.time -> isar_preplay_data ref -> isar_proof -> isar_proof
    type isar_preplay_data = Sledgehammer_Isar_Preplay.isar_preplay_data
    eqtype isar_proof
  end
structure Sledgehammer_Isar_Compress: SLEDGEHAMMER_ISAR_COMPRESS
### ML warning (line 49 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_minimize.ML"):
### Matches are not exhaustive.
### ML warning (line 135 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar_minimize.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER_ISAR_MINIMIZE =
  sig
    type isar_preplay_data = Sledgehammer_Isar_Preplay.isar_preplay_data
    eqtype isar_proof
    eqtype isar_step
    val keep_fastest_method_of_isar_step:
       isar_preplay_data -> isar_step -> isar_step
    val minimize_isar_step_dependencies:
       Proof.context -> isar_preplay_data ref -> isar_step -> isar_step
    val minimized_isar_step:
       Proof.context ->
         thm list -> Time.time -> isar_step -> Time.time * isar_step
    val postprocess_isar_proof_remove_show_stuttering:
       isar_proof -> isar_proof
    val postprocess_isar_proof_remove_unreferenced_steps:
       (isar_step -> isar_step) -> isar_proof -> isar_proof
  end
structure Sledgehammer_Isar_Minimize: SLEDGEHAMMER_ISAR_MINIMIZE
### ML warning (line 161 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar.ML"):
### Matches are not exhaustive.
### ML warning (line 255 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar.ML"):
### Matches are not exhaustive.
### ML warning (line 440 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar.ML"):
### Matches are not exhaustive.
### ML warning (line 467 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_isar.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER_ISAR =
  sig
    type 'a atp_proof = 'a ATP_Proof.atp_proof
    type ('a, 'b) atp_step = ('a, 'b) ATP_Proof.atp_step
    type atp_step_name = ATP_Proof.atp_step_name
    type isar_params =
       bool * (string option * string option) * Time.time * real option *
       bool * bool * (term, string) atp_step list * thm
    type one_line_params = Sledgehammer_Proof_Methods.one_line_params
    val proof_text:
       Proof.context ->
         bool ->
           bool option ->
             bool ->
               (unit -> isar_params) -> int -> one_line_params -> string
    type stature = ATP_Problem_Generate.stature
    val trace: bool Config.T
  end
structure Sledgehammer_Isar: SLEDGEHAMMER_ISAR
signature SLEDGEHAMMER_ATP_SYSTEMS =
  sig
    val add_atp: string * (unit -> atp_config) -> theory -> theory
    type atp_config =
       {arguments:
        Proof.context ->
          bool ->
            string ->
              Time.time ->
                Path.T ->
                  term_order * (unit -> (string * int) list) *
                  (unit -> (string * real) list)
                    -> string list
        ,
        best_max_mono_iters: int,
        best_max_new_mono_instances: int,
        best_slices: Proof.context -> (real * (slice_spec * string)) list,
        exec: string list * string list,
        known_failures: (atp_failure * string) list,
        prem_role: atp_formula_role, proof_delims: (string * string) list}
    eqtype atp_failure
    eqtype atp_format
    eqtype atp_formula_role
    val default_max_mono_iters: int
    val default_max_new_mono_instances: int
    val e_autoN: string
    val e_default_fun_weight: real Config.T
    val e_default_sym_offs_weight: real Config.T
    val e_fun_weightN: string
    val e_fun_weight_base: real Config.T
    val e_fun_weight_span: real Config.T
    val e_selection_heuristic: string Config.T
    val e_smartN: string
    val e_sym_offs_weight_base: real Config.T
    val e_sym_offs_weight_span: real Config.T
    val e_sym_offset_weightN: string
    val effective_term_order: Proof.context -> string -> term_order
    val force_sos: bool Config.T
    val get_atp: theory -> string -> unit -> atp_config
    val is_atp_installed: theory -> string -> bool
    val isabelle_scala_function: string list * string list
    val refresh_systems_on_tptp: unit -> unit
    val remote_atp:
       string ->
         string ->
           string list ->
             (string * string) list ->
               (atp_failure * string) list ->
                 atp_formula_role ->
                   (Proof.context -> slice_spec * string) ->
                     string * (unit -> atp_config)
    type slice_spec = (int * string) * atp_format * string * string * bool
    val spass_H1SOS: string
    val spass_H2: string
    val spass_H2LR0LT0: string
    val spass_H2NuVS0: string
    val spass_H2NuVS0Red2: string
    val spass_H2SOS: string
    val supported_atps: theory -> string list
    val term_order: string Config.T
    type term_order = ATP_Problem.term_order
  end
structure Sledgehammer_ATP_Systems: SLEDGEHAMMER_ATP_SYSTEMS
signature SLEDGEHAMMER_PROVER =
  sig
    val SledgehammerN: string
    eqtype atp_failure
    val bunches_of_proof_methods:
       Proof.context ->
         bool -> bool -> bool -> string -> proof_method list list
    type fact = Sledgehammer_Fact.fact
    val filter_used_facts:
       bool ->
         (''a * stature) list ->
           ((''a * stature) * 'b) list -> ((''a * stature) * 'b) list
    datatype induction_rules = Exclude | Include | Instantiate
    val induction_rules_of_string: string -> induction_rules option
    val is_atp: theory -> string -> bool
    val is_fact_chained: ('a * stature) * 'b -> bool
    datatype mode = Auto_Try | MaSh | Minimize | Normal | Try
    val overlord_file_location_of_prover: string -> string * string
    type params =
       {compress: real option,
        debug: bool,
        expect: string,
        fact_filter: string option,
        fact_thresholds: real * real,
        induction_rules: induction_rules option,
        isar_proofs: bool option,
        lam_trans: string option,
        learn: bool,
        max_facts: int option,
        max_mono_iters: int option,
        max_new_mono_instances: int option,
        minimize: bool,
        overlord: bool,
        preplay_timeout: Time.time,
        provers: string list, slice: bool, smt_proofs: bool, ...}
    eqtype play_outcome
    val proof_banner: mode -> string -> string
    eqtype proof_method
    type prover = params -> prover_problem -> prover_result
    type prover_problem =
       {comment: string,
        factss: (string * fact list) list,
        found_proof: unit -> unit,
        goal: thm, state: Proof.state, subgoal: int, subgoal_count: int}
    type prover_result =
       {message:
        (unit -> (string * stature) list * (proof_method * play_outcome)) ->
          string
        ,
        outcome: atp_failure option,
        preferred_methss: proof_method * proof_method list list,
        run_time: Time.time,
        used_facts: (string * stature) list, used_from: fact list}
    val repair_monomorph_context:
       int option ->
         int -> int option -> int -> Proof.context -> Proof.context
    type stature = ATP_Problem_Generate.stature
    val str_of_mode: mode -> string
    val supported_provers: Proof.context -> unit
    eqtype type_enc
  end
structure Sledgehammer_Prover: SLEDGEHAMMER_PROVER
### ML warning (line 348 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_prover_atp.ML"):
### Pattern is not exhaustive.
signature SLEDGEHAMMER_PROVER_ATP =
  sig
    val atp_completish: int Config.T
    val atp_dest_dir: string Config.T
    val atp_full_names: bool Config.T
    val atp_problem_prefix: string Config.T
    val is_ho_atp: Proof.context -> string -> bool
    eqtype mode
    type prover = Sledgehammer_Prover.prover
    val run_atp: mode -> string -> prover
  end
structure Sledgehammer_Prover_ATP: SLEDGEHAMMER_PROVER_ATP
### ML warning (line 124 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_prover_smt.ML"):
### Handler catches all exceptions.
### ML warning (line 152 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_prover_smt.ML"):
### Matches are not exhaustive.
### ML warning (line 150 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_prover_smt.ML"):
### Pattern is not exhaustive.
### ML warning (line 100 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_prover_smt.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER_PROVER_SMT =
  sig
    val is_smt_prover: Proof.context -> string -> bool
    eqtype mode
    type prover = Sledgehammer_Prover.prover
    val run_smt_solver: mode -> string -> prover
    val smt_builtins: bool Config.T
    val smt_max_slices: int Config.T
    val smt_slice_fact_frac: real Config.T
    val smt_slice_min_secs: int Config.T
    val smt_slice_time_frac: real Config.T
    val smt_triggers: bool Config.T
    type stature = ATP_Problem_Generate.stature
  end
structure Sledgehammer_Prover_SMT: SLEDGEHAMMER_PROVER_SMT
signature SLEDGEHAMMER_PROVER_MINIMIZE =
  sig
    val binary_min_facts: int Config.T
    val default_max_facts_of_prover: Proof.context -> string -> int
    val get_minimizing_prover:
       Proof.context -> mode -> (thm list -> unit) -> string -> prover
    val get_prover: Proof.context -> mode -> string -> prover
    val is_prover_installed: Proof.context -> string -> bool
    val is_prover_supported: Proof.context -> string -> bool
    val minimize_facts:
       (thm list -> unit) ->
         string ->
           params ->
             bool ->
               int ->
                 int ->
                   Proof.state ->
                     thm ->
                       ((string * stature) * thm list) list ->
                         ((string * stature) * thm list) list option *
                         ((unit ->
                             (string * stature) list *
                             (proof_method * play_outcome))
                            -> string)
    eqtype mode
    type params = Sledgehammer_Prover.params
    eqtype play_outcome
    eqtype proof_method
    type prover = Sledgehammer_Prover.prover
    type stature = ATP_Problem_Generate.stature
  end
structure Sledgehammer_Prover_Minimize: SLEDGEHAMMER_PROVER_MINIMIZE
### ML warning (line 424 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_mepo.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER_MEPO =
  sig
    val default_relevance_fudge: relevance_fudge
    type fact = Sledgehammer_Fact.fact
    type lazy_fact = Sledgehammer_Fact.lazy_fact
    val mepo_suggested_facts:
       Proof.context ->
         params ->
           int ->
             relevance_fudge option ->
               term list -> term -> lazy_fact list -> fact list
    type params = Sledgehammer_Prover.params
    val pseudo_abs_name: string
    type relevance_fudge =
       {abs_irrel_weight: real,
        abs_rel_weight: real,
        assum_bonus: real,
        chained_bonus: real,
        chained_const_irrel_weight: real,
        elim_bonus: real,
        higher_order_irrel_weight: real,
        intro_bonus: real,
        local_bonus: real,
        local_const_multiplier: real,
        max_imperfect: real,
        max_imperfect_exp: real,
        ridiculous_threshold: real,
        simp_bonus: real,
        theory_const_irrel_weight: real,
        theory_const_rel_weight: real,
        threshold_divisor: real, worse_irrel_freq: real}
    type stature = ATP_Problem_Generate.stature
    val trace: bool Config.T
  end
structure Sledgehammer_MePo: SLEDGEHAMMER_MEPO
### ML warning (line 501 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_mash.ML"):
### Matches are not exhaustive.
### ML warning (line 517 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_mash.ML"):
### Matches are not exhaustive.
### ML warning (line 583 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_mash.ML"):
### Handler catches all exceptions.
### ML warning (line 1095 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_mash.ML"):
### Matches are not exhaustive.
### ML warning (line 1104 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_mash.ML"):
### Pattern is not exhaustive.
signature SLEDGEHAMMER_MASH =
  sig
    val MaShN: string
    val MePoN: string
    val MeShN: string
    val attach_parents_to_facts:
       ('a * thm) list -> ('a * thm) list -> (string list * ('a * thm)) list
    val crude_thm_ord: Proof.context -> thm ord
    val decode_str: string -> string
    val decode_strs: string -> string list
    val duplicates: bool Config.T
    val encode_str: string -> string
    val encode_strs: string list -> string
    val extra_feature_factor: real
    type fact = Sledgehammer_Fact.fact
    val fact_filters: string list
    type fact_override = Sledgehammer_Fact.fact_override
    val features_of:
       Proof.context -> string -> stature -> term list -> string list
    val find_mash_suggestions:
       Proof.context ->
         int ->
           string list ->
             ('a * thm) list ->
               ('a * thm) list ->
                 ('a * thm) list -> ('a * thm) list * ('a * thm) list
    val find_suggested_facts:
       Proof.context -> ('a * thm) list -> string list -> ('a * thm) list
    val generous_max_suggestions: int -> int
    val goal_of_thm: theory -> thm -> thm
    val is_mash_enabled: unit -> bool
    val isar_dependencies_of:
       string Symtab.table * string Symtab.table ->
         thm -> string list option
    type lazy_fact = Sledgehammer_Fact.lazy_fact
    val learn_isarN: string
    val learn_proverN: string
    val mashN: string
    datatype mash_algorithm
    = MaSh_NB | MaSh_NB_Ext | MaSh_NB_kNN | MaSh_kNN | MaSh_kNN_Ext
    val mash_can_suggest_facts: Proof.context -> bool
    val mash_can_suggest_facts_fast: Proof.context -> bool
    val mash_learn:
       Proof.context -> params -> fact_override -> thm list -> bool -> unit
    val mash_learn_facts:
       Proof.context ->
         params ->
           string -> int -> bool -> Time.time -> lazy_fact list -> string
    val mash_learn_proof:
       Proof.context -> params -> term -> thm list -> unit
    val mash_suggested_facts:
       Proof.context ->
         string ->
           params ->
             int ->
               term list -> term -> lazy_fact list -> fact list * fact list
    val mash_unlearn: Proof.context -> unit
    val mash_weight: real
    val mepoN: string
    val mepo_weight: real
    val meshN: string
    val mesh_facts:
       ('a list -> 'a list) ->
         ('a * 'a -> bool) ->
           int -> (real * (('a * real) list * 'a list)) list -> 'a list
    val nickname_of_thm: thm -> string
    val num_extra_feature_facts: int
    type params = Sledgehammer_Prover.params
    val prover_dependencies_of:
       Proof.context ->
         params ->
           string ->
             int ->
               lazy_fact list ->
                 string Symtab.table * string Symtab.table ->
                   thm -> bool * string list
    type prover_result = Sledgehammer_Prover.prover_result
    val relearn_isarN: string
    val relearn_proverN: string
    val relevant_facts:
       Proof.context ->
         params ->
           string ->
             int ->
               fact_override ->
                 term list ->
                   term -> lazy_fact list -> (string * fact list) list
    val run_prover_for_mash:
       Proof.context ->
         params -> string -> string -> fact list -> thm -> prover_result
    type stature = ATP_Problem_Generate.stature
    val str_of_mash_algorithm: mash_algorithm -> string
    val the_mash_algorithm: unit -> mash_algorithm
    val thm_less: thm * thm -> bool
    val trace: bool Config.T
    val trim_dependencies: string list -> string list option
    val unlearnN: string
    val weight_facts_smoothly: 'a list -> ('a * real) list
    val weight_facts_steeply: 'a list -> ('a * real) list
  end
structure Sledgehammer_MaSh: SLEDGEHAMMER_MASH
### ML warning (line 204 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer.ML"):
### Handler catches all exceptions.
### ML warning (line 118 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer.ML"):
### Matches are not exhaustive.
signature SLEDGEHAMMER =
  sig
    type fact = Sledgehammer_Fact.fact
    type fact_override = Sledgehammer_Fact.fact_override
    eqtype mode
    val noneN: string
    type params = Sledgehammer_Prover.params
    val play_one_line_proof:
       bool ->
         Time.time ->
           (string * stature) list ->
             Proof.state ->
               int ->
                 proof_method * proof_method list list ->
                   (string * stature) list * (proof_method * play_outcome)
    eqtype play_outcome
    eqtype proof_method
    val run_sledgehammer:
       params ->
         mode ->
           (string -> unit) option ->
             int ->
               fact_override -> Proof.state -> bool * (string * string list)
    val someN: string
    type stature = ATP_Problem_Generate.stature
    val string_of_factss: (string * fact list) list -> string
    val timeoutN: string
    val unknownN: string
  end
structure Sledgehammer: SLEDGEHAMMER
### ML warning (line 405 of "~~/src/HOL/Tools/Sledgehammer/sledgehammer_commands.ML"):
### Pattern is not exhaustive.
signature SLEDGEHAMMER_COMMANDS =
  sig
    val default_params: theory -> (string * string) list -> params
    type params = Sledgehammer_Prover.params
    val parse_params: (string * string) list parser
    val provers: string ref
  end
structure Sledgehammer_Commands: SLEDGEHAMMER_COMMANDS
signature SLEDGEHAMMER_TACTICS =
  sig
    type fact_override = Sledgehammer_Fact.fact_override
    val sledgehammer_as_oracle_tac:
       Proof.context ->
         (string * string) list ->
           fact_override -> thm list -> int -> tactic
    val sledgehammer_with_metis_tac:
       Proof.context ->
         (string * string) list ->
           fact_override -> thm list -> int -> tactic
  end
structure Sledgehammer_Tactics: SLEDGEHAMMER_TACTICS
### theory "HOL.Sledgehammer"
### 3.156s elapsed time, 6.540s cpu time, 4.632s GC time
Loading theory "HOL.List" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random")
consts
  last :: "'a list => 'a"
consts
  butlast :: "'a list => 'a list"
consts
  append :: "'a list => 'a list => 'a list"
consts
  rev :: "'a list => 'a list"
consts
  filter :: "('a => bool) => 'a list => 'a list"
consts
  fold :: "('a => 'b => 'b) => 'a list => 'b => 'b"
consts
  foldr :: "('a => 'b => 'b) => 'a list => 'b => 'b"
consts
  foldl :: "('b => 'a => 'b) => 'b => 'a list => 'b"
consts
  concat :: "'a list list => 'a list"
consts
  drop :: "nat => 'a list => 'a list"
consts
  take :: "nat => 'a list => 'a list"
consts
  nth :: "'a list => nat => 'a"
consts
  list_update :: "'a list => nat => 'a => 'a list"
consts
  takeWhile :: "('a => bool) => 'a list => 'a list"
consts
  dropWhile :: "('a => bool) => 'a list => 'a list"
consts
  zip :: "'a list => 'b list => ('a * 'b) list"
consts
  product :: "'a list => 'b list => ('a * 'b) list"
consts
  product_lists :: "'a list list => 'a list list"
consts
  upt :: "nat => nat => nat list"
consts
  find :: "('a => bool) => 'a list => 'a option"
consts
  count_list :: "'a list => 'a => nat"
consts
  those :: "'a option list => 'a list option"
consts
  remove1 :: "'a => 'a list => 'a list"
consts
  removeAll :: "'a => 'a list => 'a list"
consts
  distinct :: "'a list => bool"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
consts
  remdups :: "'a list => 'a list"
Found termination order: "size <*mlex*> {}"
consts
  replicate :: "nat => 'a => 'a list"
consts
  rotate1 :: "'a list => 'a list"
consts
  subseqs :: "'a list => 'a list list"
consts
  n_lists :: "nat => 'a list => 'a list list"
### Missing patterns in function definition:
### min_list [] = undefined
Found termination order: "length <*mlex*> {}"
### Missing patterns in function definition:
### !!a. arg_min_list a [] = undefined
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
consts
  insort_key :: "('b => 'a) => 'b => 'b list => 'b list"
### ML warning (line 608 of "~~/src/HOL/List.thy"):
### Matches are not exhaustive.
### ML warning (line 672 of "~~/src/HOL/List.thy"):
### Pattern is not exhaustive.
### ML warning (line 743 of "~~/src/HOL/List.thy"):
### Pattern is not exhaustive.
signature LIST_TO_SET_COMPREHENSION =
  sig val simproc: Proof.context -> cterm -> thm option end
structure List_to_Set_Comprehension: LIST_TO_SET_COMPREHENSION
val it = true: bool
consts
  partition :: "('a => bool) => 'a list => 'a list * 'a list"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### sorted [] == True
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### sorted [?x] == True
### Partially applied constant "Orderings.ord_class.less_eq" on left hand side of equation, in theorem:
### sorted (?x # ?y # ?zs) == ?x <= ?y & sorted (?y # ?zs)
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
locale folding_insort_key
  fixes less_eq :: "'a => 'a => bool"  (infix \<open>\<preceq>\<close> 50)
    and less :: "'a => 'a => bool"  (infix \<open>\<prec>\<close> 50)
    and S :: "'b set"
    and f :: "'b => 'a"
  assumes "folding_insort_key (\<preceq>) (\<prec>) S f"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
### Cannot skip proof of schematic goal statement
Proofs for inductive predicate(s) "listsp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "ListMem"
  Proving monotonicity ...
consts
  listset :: "'a set list => 'a list set"
consts
  lexn :: "('a * 'a) set => nat => ('a list * 'a list) set"
class ord = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
Proofs for inductive predicate(s) "lexordp"
  Proving monotonicity ...
Proofs for inductive predicate(s) "lexordp_eq"
  Proving monotonicity ...
class order = preorder +
  assumes "order_antisym": "!!x y. [| x <= y; y <= x |] ==> x = y"
class linorder = order +
  assumes "linear": "!!x y. x <= y | y <= x"
Proofs for inductive predicate(s) "listrelp"
  Proving monotonicity ...
Found termination order: "(%p. length (fst (snd p))) <*mlex*> {}"
### ML warning (line 7871 of "~~/src/HOL/List.thy"):
### Matches are not exhaustive.
signature LIST_CODE =
  sig val add_literal_list: string -> theory -> theory end
structure List_Code: LIST_CODE
### theory "HOL.List"
### 4.652s elapsed time, 5.248s cpu time, 0.675s GC time
Loading theory "HOL.Groups_List" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random")
Loading theory "HOL.Map" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Code_Evaluation" via "HOL.Typerep" via "HOL.String" via "HOL.Enum")
locale monoid_list
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "monoid_list (\<^bold>*) \<^bold>1"
locale comm_monoid_list
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_list (\<^bold>*) \<^bold>1"
locale comm_monoid_list_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and z :: "'a"  (\<open>\<^bold>1\<close>)
  assumes "comm_monoid_list_set (\<^bold>*) \<^bold>1"
consts
  map_of :: "('a * 'b) list => 'a => 'b option"
class monoid_add = semigroup_add + zero +
  assumes "add_0_left": "!!a. (0::'a) + a = a"
    and "add_0_right": "!!a. a + (0::'a) = a"
class comm_monoid_add = ab_semigroup_add + monoid_add +
  assumes "add_0": "!!a. (0::'a) + a = a"
### Cannot skip proof of schematic goal statement
class canonically_ordered_monoid_add = ordered_comm_monoid_add +
  assumes "le_iff_add": "!!a b. (a <= b) = (EX c. b = a + c)"
### theory "HOL.Map"
### 0.398s elapsed time, 0.969s cpu time, 0.176s GC time
class monoid_mult = semigroup_mult + power +
  assumes "mult_1_left": "!!a. (1::'a) * a = a"
    and "mult_1_right": "!!a. a * (1::'a) = a"
class comm_monoid_mult = ab_semigroup_mult + monoid_mult + dvd +
  assumes "mult_1": "!!a. (1::'a) * a = a"
### Cannot skip proof of schematic goal statement
### theory "HOL.Groups_List"
### 0.616s elapsed time, 1.189s cpu time, 0.176s GC time
Loading theory "HOL.Bit_Operations" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random" via "HOL.Code_Numeral")
Loading theory "HOL.Factorial" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Binomial")
Loading theory "HOL.Enum" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Code_Evaluation" via "HOL.Typerep" via "HOL.String")
class semiring_char_0 = semiring_1 +
  assumes "inj_of_nat": "inj of_nat"
class enum = type +
  fixes enum :: "'a list"
    and enum_all :: "('a => bool) => bool"
    and enum_ex :: "('a => bool) => bool"
  assumes "UNIV_enum": "UNIV = set enum"
    and "enum_distinct": "distinct enum"
  assumes "enum_all_UNIV": "!!P. enum_all P = Ball UNIV P"
  assumes "enum_ex_UNIV": "!!P. enum_ex P = Bex UNIV P"
instantiation
  fun :: (enum, equal) equal
  equal_fun == equal_class.equal :: ('a => 'b) => ('a => 'b) => bool
consts
  bacc :: "('a * 'a) set => nat => 'a set"
instantiation
  fun :: (enum, enum) enum
  enum_fun == enum :: ('a => 'b) list
  enum_all_fun == enum_all :: (('a => 'b) => bool) => bool
  enum_ex_fun == enum_ex :: (('a => 'b) => bool) => bool
instantiation
  set :: (enum) enum
  enum_set == enum :: 'a set list
  enum_all_set == enum_all :: ('a set => bool) => bool
  enum_ex_set == enum_ex :: ('a set => bool) => bool
instantiation
  unit :: enum
  enum_unit == enum :: unit list
  enum_all_unit == enum_all :: (unit => bool) => bool
  enum_ex_unit == enum_ex :: (unit => bool) => bool
instantiation
  bool :: enum
  enum_bool == enum :: bool list
  enum_all_bool == enum_all :: (bool => bool) => bool
  enum_ex_bool == enum_ex :: (bool => bool) => bool
instantiation
  prod :: (enum, enum) enum
  enum_prod == enum :: ('a * 'b) list
  enum_all_prod == enum_all :: ('a * 'b => bool) => bool
  enum_ex_prod == enum_ex :: ('a * 'b => bool) => bool
instantiation
  sum :: (enum, enum) enum
  enum_sum == enum :: ('a + 'b) list
  enum_all_sum == enum_all :: ('a + 'b => bool) => bool
  enum_ex_sum == enum_ex :: ('a + 'b => bool) => bool
instantiation
  option :: (enum) enum
  enum_option == enum :: 'a option list
  enum_all_option == enum_all :: ('a option => bool) => bool
  enum_ex_option == enum_ex :: ('a option => bool) => bool
### theory "HOL.Factorial"
### 0.476s elapsed time, 1.466s cpu time, 0.178s GC time
Loading theory "HOL.Binomial" (required by "Draft.Pairing_AxiomTemplates" via "Main")
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
instantiation
  finite_1 :: enum
  enum_finite_1 == enum :: finite_1 list
  enum_all_finite_1 == enum_all :: (finite_1 => bool) => bool
  enum_ex_finite_1 == enum_ex :: (finite_1 => bool) => bool
instantiation
  finite_1 :: linorder
  less_eq_finite_1 == less_eq :: finite_1 => finite_1 => bool
  less_finite_1 == less :: finite_1 => finite_1 => bool
instantiation
  finite_1 :: complete_lattice
  Inf_finite_1 == Inf :: finite_1 set => finite_1
  Sup_finite_1 == Sup :: finite_1 set => finite_1
  bot_finite_1 == bot :: finite_1
  sup_finite_1 == sup :: finite_1 => finite_1 => finite_1
  top_finite_1 == top :: finite_1
  inf_finite_1 == inf :: finite_1 => finite_1 => finite_1
instantiation
  finite_1 :: complete_boolean_algebra
  minus_finite_1 == minus :: finite_1 => finite_1 => finite_1
  uminus_finite_1 == uminus :: finite_1 => finite_1
instantiation
  finite_1 ::
    {inverse,comm_monoid_mult,ordered_cancel_comm_monoid_diff,sgn,linordered_comm_semiring_strict,linordered_ring_strict,modulo,ordered_comm_ring,ordered_ring_abs}
  modulo_finite_1 == modulo :: finite_1 => finite_1 => finite_1
  abs_finite_1 == abs :: finite_1 => finite_1
  sgn_finite_1 == sgn :: finite_1 => finite_1
  zero_finite_1 == zero_class.zero :: finite_1
  plus_finite_1 == plus :: finite_1 => finite_1 => finite_1
  one_finite_1 == one_class.one :: finite_1
  times_finite_1 == times :: finite_1 => finite_1 => finite_1
  inverse_finite_1 == inverse :: finite_1 => finite_1
  divide_finite_1 == divide :: finite_1 => finite_1 => finite_1
instantiation
  finite_2 :: enum
  enum_finite_2 == enum :: finite_2 list
  enum_all_finite_2 == enum_all :: (finite_2 => bool) => bool
  enum_ex_finite_2 == enum_ex :: (finite_2 => bool) => bool
instantiation
  finite_2 :: linorder
  less_eq_finite_2 == less_eq :: finite_2 => finite_2 => bool
  less_finite_2 == less :: finite_2 => finite_2 => bool
instantiation
  finite_2 :: complete_lattice
  Inf_finite_2 == Inf :: finite_2 set => finite_2
  Sup_finite_2 == Sup :: finite_2 set => finite_2
  bot_finite_2 == bot :: finite_2
  sup_finite_2 == sup :: finite_2 => finite_2 => finite_2
  top_finite_2 == top :: finite_2
  inf_finite_2 == inf :: finite_2 => finite_2 => finite_2
instantiation
  finite_2 :: {field,idom_abs_sgn,idom_modulo}
  modulo_finite_2 == modulo :: finite_2 => finite_2 => finite_2
  abs_finite_2 == abs :: finite_2 => finite_2
  sgn_finite_2 == sgn :: finite_2 => finite_2
  inverse_finite_2 == inverse :: finite_2 => finite_2
  divide_finite_2 == divide :: finite_2 => finite_2 => finite_2
  uminus_finite_2 == uminus :: finite_2 => finite_2
  minus_finite_2 == minus :: finite_2 => finite_2 => finite_2
  one_finite_2 == one_class.one :: finite_2
  times_finite_2 == times :: finite_2 => finite_2 => finite_2
  zero_finite_2 == zero_class.zero :: finite_2
  plus_finite_2 == plus :: finite_2 => finite_2 => finite_2
instantiation
  nat :: semiring_bits
  bit_nat == bit :: nat => nat => bool
### theory "HOL.Binomial"
### 0.270s elapsed time, 0.819s cpu time, 0.074s GC time
instantiation
  finite_2 :: {unique_euclidean_semiring,normalization_semidom}
  normalize_finite_2 == normalize :: finite_2 => finite_2
  unit_factor_finite_2 == unit_factor :: finite_2 => finite_2
  division_segment_finite_2 == division_segment :: finite_2 => finite_2
  euclidean_size_finite_2 == euclidean_size :: finite_2 => nat
instantiation
  finite_3 :: enum
  enum_finite_3 == enum :: finite_3 list
  enum_all_finite_3 == enum_all :: (finite_3 => bool) => bool
  enum_ex_finite_3 == enum_ex :: (finite_3 => bool) => bool
class semiring_bits = semiring_parity +
  fixes bit :: "'a => nat => bool"
  assumes
    "bits_induct":
      "!!P a.
          [| !!a. a div (2::'a) = a ==> P a;
             !!a b.
                [| P a; (of_bool b + (2::'a) * a) div (2::'a) = a |]
                ==> P (of_bool b + (2::'a) * a) |]
          ==> P a"
  assumes "bits_div_0": "!!a. (0::'a) div a = (0::'a)"
    and "bits_div_by_1": "!!a. a div (1::'a) = a"
    and "bits_mod_div_trivial": "!!a b. a mod b div b = (0::'a)"
    and
    "even_succ_div_2":
      "!!a. even a ==> ((1::'a) + a) div (2::'a) = a div (2::'a)"
    and
    "even_mask_div_iff":
      "!!m n.
          even (((2::'a) ^ m - (1::'a)) div (2::'a) ^ n) =
          ((2::'a) ^ n = (0::'a) | m <= n)"
    and
    "exp_div_exp_eq":
      "!!m n.
          (2::'a) ^ m div (2::'a) ^ n =
          of_bool ((2::'a) ^ m ~= (0::'a) & n <= m) * (2::'a) ^ (m - n)"
    and
    "div_exp_eq":
      "!!a m n. a div (2::'a) ^ m div (2::'a) ^ n = a div (2::'a) ^ (m + n)"
    and
    "mod_exp_eq":
      "!!a m n. a mod (2::'a) ^ m mod (2::'a) ^ n = a mod (2::'a) ^ min m n"
    and
    "mult_exp_mod_exp_eq":
      "!!m n a.
          m <= n ==>
          a * (2::'a) ^ m mod (2::'a) ^ n =
          a mod (2::'a) ^ (n - m) * (2::'a) ^ m"
    and
    "div_exp_mod_exp_eq":
      "!!a n m.
          a div (2::'a) ^ n mod (2::'a) ^ m =
          a mod (2::'a) ^ (n + m) div (2::'a) ^ n"
    and
    "even_mult_exp_div_exp_iff":
      "!!a m n.
          even (a * (2::'a) ^ m div (2::'a) ^ n) =
          (n < m |
           (2::'a) ^ n = (0::'a) | m <= n & even (a div (2::'a) ^ (n - m)))"
  assumes "bit_iff_odd": "!!a n. bit a n = odd (a div (2::'a) ^ n)"
instantiation
  int :: semiring_bits
  bit_int == bit :: int => nat => bool
instantiation
  finite_3 :: linorder
  less_eq_finite_3 == less_eq :: finite_3 => finite_3 => bool
  less_finite_3 == less :: finite_3 => finite_3 => bool
class finite_lattice = Inf + Sup + finite + lattice + bot + top +
  assumes "Inf_finite_empty": "\<Sqinter> {} = \<Squnion> UNIV"
  assumes
    "Inf_finite_insert":
      "!!a A. \<Sqinter> insert a A = a \<sqinter> \<Sqinter> A"
  assumes "Sup_finite_empty": "\<Squnion> {} = \<Sqinter> UNIV"
  assumes
    "Sup_finite_insert":
      "!!a A. \<Squnion> insert a A = a \<squnion> \<Squnion> A"
  assumes "bot_finite_def": "\<bottom> = \<Sqinter> UNIV"
  assumes "top_finite_def": "\<top> = \<Squnion> UNIV"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (a AND b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (a OR b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (a XOR b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = a OR push_bit n (1::'a)"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and "flip_bit_eq_xor": "!!n a. flip_bit n a = a XOR push_bit n (1::'a)"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
instantiation
  finite_3 :: finite_lattice
  Inf_finite_3 == Inf :: finite_3 set => finite_3
  Sup_finite_3 == Sup :: finite_3 set => finite_3
  bot_finite_3 == bot :: finite_3
  sup_finite_3 == sup :: finite_3 => finite_3 => finite_3
  top_finite_3 == top :: finite_3
  inf_finite_3 == inf :: finite_3 => finite_3 => finite_3
instantiation
  finite_3 :: {field,idom_abs_sgn,idom_modulo}
  modulo_finite_3 == modulo :: finite_3 => finite_3 => finite_3
  abs_finite_3 == abs :: finite_3 => finite_3
  sgn_finite_3 == sgn :: finite_3 => finite_3
  inverse_finite_3 == inverse :: finite_3 => finite_3
  divide_finite_3 == divide :: finite_3 => finite_3 => finite_3
  uminus_finite_3 == uminus :: finite_3 => finite_3
  minus_finite_3 == minus :: finite_3 => finite_3 => finite_3
  one_finite_3 == one_class.one :: finite_3
  times_finite_3 == times :: finite_3 => finite_3 => finite_3
  zero_finite_3 == zero_class.zero :: finite_3
  plus_finite_3 == plus :: finite_3 => finite_3 => finite_3
instantiation
  finite_3 :: {unique_euclidean_semiring,normalization_semidom}
  normalize_finite_3 == normalize :: finite_3 => finite_3
  unit_factor_finite_3 == unit_factor :: finite_3 => finite_3
  division_segment_finite_3 == division_segment :: finite_3 => finite_3
  euclidean_size_finite_3 == euclidean_size :: finite_3 => nat
instantiation
  finite_4 :: enum
  enum_finite_4 == enum :: finite_4 list
  enum_all_finite_4 == enum_all :: (finite_4 => bool) => bool
  enum_ex_finite_4 == enum_ex :: (finite_4 => bool) => bool
instantiation
  finite_4 :: finite_distrib_lattice
  Inf_finite_4 == Inf :: finite_4 set => finite_4
  Sup_finite_4 == Sup :: finite_4 set => finite_4
  bot_finite_4 == bot :: finite_4
  sup_finite_4 == sup :: finite_4 => finite_4 => finite_4
  top_finite_4 == top :: finite_4
  inf_finite_4 == inf :: finite_4 => finite_4 => finite_4
  less_eq_finite_4 == less_eq :: finite_4 => finite_4 => bool
  less_finite_4 == less :: finite_4 => finite_4 => bool
instantiation
  finite_4 :: complete_boolean_algebra
  minus_finite_4 == minus :: finite_4 => finite_4 => finite_4
  uminus_finite_4 == uminus :: finite_4 => finite_4
instantiation
  finite_5 :: enum
  enum_finite_5 == enum :: finite_5 list
  enum_all_finite_5 == enum_all :: (finite_5 => bool) => bool
  enum_ex_finite_5 == enum_ex :: (finite_5 => bool) => bool
instantiation
  finite_5 :: finite_lattice
  Inf_finite_5 == Inf :: finite_5 set => finite_5
  Sup_finite_5 == Sup :: finite_5 set => finite_5
  bot_finite_5 == bot :: finite_5
  sup_finite_5 == sup :: finite_5 => finite_5 => finite_5
  top_finite_5 == top :: finite_5
  inf_finite_5 == inf :: finite_5 => finite_5 => finite_5
  less_eq_finite_5 == less_eq :: finite_5 => finite_5 => bool
  less_finite_5 == less :: finite_5 => finite_5 => bool
### theory "HOL.Enum"
### 2.114s elapsed time, 5.130s cpu time, 0.514s GC time
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (NOT a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = NOT (a - (1::'a))"
instantiation
  int :: ring_bit_operations
  not_int == not :: int => int
  and_int == and :: int => int => int
  or_int == or :: int => int => int
  xor_int == xor :: int => int => int
  mask_int == mask :: nat => int
  set_bit_int == set_bit :: nat => int => int
  unset_bit_int == unset_bit :: nat => int => int
  flip_bit_int == flip_bit :: nat => int => int
  push_bit_int == push_bit :: nat => int => int
  drop_bit_int == drop_bit :: nat => int => int
  take_bit_int == take_bit :: nat => int => int
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (NOT a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = NOT (a - (1::'a))"
instantiation
  nat :: semiring_bit_operations
  and_nat == and :: nat => nat => nat
  or_nat == or :: nat => nat => nat
  xor_nat == xor :: nat => nat => nat
  mask_nat == mask :: nat => nat
  set_bit_nat == set_bit :: nat => nat => nat
  unset_bit_nat == unset_bit :: nat => nat => nat
  flip_bit_nat == flip_bit :: nat => nat => nat
  push_bit_nat == push_bit :: nat => nat => nat
  drop_bit_nat == drop_bit :: nat => nat => nat
  take_bit_nat == take_bit :: nat => nat => nat
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (a AND b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (a OR b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (a XOR b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = a OR push_bit n (1::'a)"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and "flip_bit_eq_xor": "!!n a. flip_bit n a = a XOR push_bit n (1::'a)"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (a AND b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (a OR b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (a XOR b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = a OR push_bit n (1::'a)"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and "flip_bit_eq_xor": "!!n a. flip_bit n a = a XOR push_bit n (1::'a)"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (NOT a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = NOT (a - (1::'a))"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (a AND b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (a OR b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (a XOR b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = a OR push_bit n (1::'a)"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and "flip_bit_eq_xor": "!!n a. flip_bit n a = a XOR push_bit n (1::'a)"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
class ring_bit_operations = semiring_bit_operations + ring_parity +
  fixes not :: "'a => 'a"
  assumes
    "bit_not_iff_eq":
      "!!a n. bit (NOT a) n = ((2::'a) ^ n ~= (0::'a) & ~ bit a n)"
  assumes "minus_eq_not_minus_1": "!!a. - a = NOT (a - (1::'a))"
class semiring_bit_operations = semiring_bits +
  fixes "and" :: "'a => 'a => 'a"
    and or :: "'a => 'a => 'a"
    and xor :: "'a => 'a => 'a"
    and mask :: "nat => 'a"
    and set_bit :: "nat => 'a => 'a"
    and unset_bit :: "nat => 'a => 'a"
    and flip_bit :: "nat => 'a => 'a"
    and push_bit :: "nat => 'a => 'a"
    and drop_bit :: "nat => 'a => 'a"
    and take_bit :: "nat => 'a => 'a"
  assumes "bit_and_iff": "!!a b n. bit (a AND b) n = (bit a n & bit b n)"
    and "bit_or_iff": "!!a b n. bit (a OR b) n = (bit a n | bit b n)"
    and "bit_xor_iff": "!!a b n. bit (a XOR b) n = (bit a n ~= bit b n)"
    and "mask_eq_exp_minus_1": "!!n. mask n = (2::'a) ^ n - (1::'a)"
    and "set_bit_eq_or": "!!n a. set_bit n a = a OR push_bit n (1::'a)"
    and
    "bit_unset_bit_iff":
      "!!m a n. bit (unset_bit m a) n = (bit a n & m ~= n)"
    and "flip_bit_eq_xor": "!!n a. flip_bit n a = a XOR push_bit n (1::'a)"
    and "push_bit_eq_mult": "!!n a. push_bit n a = a * (2::'a) ^ n"
    and "drop_bit_eq_div": "!!n a. drop_bit n a = a div (2::'a) ^ n"
    and "take_bit_eq_mod": "!!n a. take_bit n a = a mod (2::'a) ^ n"
bundle bit_operations_syntax
### theory "HOL.Bit_Operations"
### 6.935s elapsed time, 10.277s cpu time, 0.939s GC time
Loading theory "HOL.Code_Numeral" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Random")
instantiation
  integer :: ring_1
  uminus_integer == uminus :: integer => integer
  one_integer == one_class.one :: integer
  times_integer == times :: integer => integer => integer
  zero_integer == zero_class.zero :: integer
  minus_integer == minus :: integer => integer => integer
  plus_integer == plus :: integer => integer => integer
instantiation
  integer :: {equal,linordered_idom}
  sgn_integer == sgn :: integer => integer
  abs_integer == abs :: integer => integer
  less_eq_integer == less_eq :: integer => integer => bool
  less_integer == less :: integer => integer => bool
  equal_integer == equal_class.equal :: integer => integer => bool
instantiation
  integer :: unique_euclidean_ring
  division_segment_integer == division_segment :: integer => integer
  euclidean_size_integer == euclidean_size :: integer => nat
  modulo_integer == modulo :: integer => integer => integer
  divide_integer == divide :: integer => integer => integer
instantiation
  integer :: ring_bit_operations
  not_integer == not :: integer => integer
  and_integer == and :: integer => integer => integer
  or_integer == or :: integer => integer => integer
  xor_integer == xor :: integer => integer => integer
  mask_integer == mask :: nat => integer
  set_bit_integer == set_bit :: nat => integer => integer
  unset_bit_integer == unset_bit :: nat => integer => integer
  flip_bit_integer == flip_bit :: nat => integer => integer
  push_bit_integer == push_bit :: nat => integer => integer
  drop_bit_integer == drop_bit :: nat => integer => integer
  take_bit_integer == take_bit :: nat => integer => integer
  bit_integer == bit :: integer => nat => bool
instantiation
  integer :: unique_euclidean_semiring_numeral
  divmod_integer == divmod :: num => num => integer * integer
  divmod_step_integer == divmod_step ::
    num => integer * integer => integer * integer
instantiation
  natural :: {comm_monoid_diff,semiring_1}
  one_natural == one_class.one :: natural
  times_natural == times :: natural => natural => natural
  zero_natural == zero_class.zero :: natural
  minus_natural == minus :: natural => natural => natural
  plus_natural == plus :: natural => natural => natural
instantiation
  natural :: {equal,linordered_semiring}
  less_eq_natural == less_eq :: natural => natural => bool
  less_natural == less :: natural => natural => bool
  equal_natural == equal_class.equal :: natural => natural => bool
instantiation
  natural :: unique_euclidean_semiring
  division_segment_natural == division_segment :: natural => natural
  euclidean_size_natural == euclidean_size :: natural => nat
  modulo_natural == modulo :: natural => natural => natural
  divide_natural == divide :: natural => natural => natural
instantiation
  natural :: semiring_bit_operations
  and_natural == and :: natural => natural => natural
  or_natural == or :: natural => natural => natural
  xor_natural == xor :: natural => natural => natural
  mask_natural == mask :: nat => natural
  set_bit_natural == set_bit :: nat => natural => natural
  unset_bit_natural == unset_bit :: nat => natural => natural
  flip_bit_natural == flip_bit :: nat => natural => natural
  push_bit_natural == push_bit :: nat => natural => natural
  drop_bit_natural == drop_bit :: nat => natural => natural
  take_bit_natural == take_bit :: nat => natural => natural
  bit_natural == bit :: natural => nat => bool
### Code generator: dropping subsumed code equation
### mask ?n == 2 ^ ?n - 1
Proofs for inductive predicate(s) "rec_set_natural"
instantiation
  natural :: size
  size_natural == size :: natural => nat
Warning: Value identifier (less) has not been referenced.
At (line 17 of "generated code")
Warning: Value identifier (x2) has not been referenced.
At (line 33 of "generated code")
Warning: Value identifier (x1) has not been referenced.
At (line 35 of "generated code")
structure Code_Numeral:
  sig
    val divide_natural: natural -> natural -> natural
    val integer_of_natural: natural -> int
    val minus_natural: natural -> natural -> natural
    val modulo_natural: natural -> natural -> natural
    type natural
    val natural_of_integer: int -> natural
    type num
    val one_natural: natural
    val plus_natural: natural -> natural -> natural
    val suc: natural -> natural
    val times_natural: natural -> natural -> natural
    val zero_natural: natural
  end
### theory "HOL.Code_Numeral"
### 0.767s elapsed time, 0.911s cpu time, 0.095s GC time
Loading theory "HOL.GCD" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Nunchaku" via "HOL.Nitpick")
Loading theory "HOL.String" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Code_Evaluation" via "HOL.Typerep")
Loading theory "HOL.Random" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random")
locale bounded_quasi_semilattice
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and top :: "'a"  (\<open>\<^bold>\<top>\<close>)
    and bot :: "'a"  (\<open>\<^bold>\<bottom>\<close>)
    and normalize :: "'a => 'a"
  assumes
    "bounded_quasi_semilattice (\<^bold>*) \<^bold>\<top> \<^bold>\<bottom>
      normalize"
locale bounded_quasi_semilattice_set
  fixes f :: "'a => 'a => 'a"  (infixl \<open>\<^bold>*\<close> 70)
    and top :: "'a"  (\<open>\<^bold>\<top>\<close>)
    and bot :: "'a"  (\<open>\<^bold>\<bottom>\<close>)
    and normalize :: "'a => 'a"
  assumes
    "bounded_quasi_semilattice_set (\<^bold>*) \<^bold>\<top>
      \<^bold>\<bottom> normalize"
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
consts
  next :: "natural * natural => natural * natural * natural"
class gcd = one + zero + dvd +
  fixes gcd :: "'a => 'a => 'a"
    and lcm :: "'a => 'a => 'a"
Found termination order: "(%p. nat_of_natural (fst p)) <*mlex*> {}"
### No equation for constructor "[]"
consts
  pick :: "(natural * 'a) list => natural => 'a"
class Gcd = gcd +
  fixes Gcd :: "'a set => 'a"
    and Lcm :: "'a set => 'a"
Warning: Value identifier (times) has not been referenced.
At (line 53 of "generated code")
Warning: Value identifier (one_power) has not been referenced.
At (line 56 of "generated code")
Warning: Value identifier (times_power) has not been referenced.
At (line 57 of "generated code")
Warning: Value identifier (semigroup_add_ab_semigroup_add) has not been referenced.
At (line 65 of "generated code")
Warning: Value identifier (times_semigroup_mult) has not been referenced.
At (line 69 of "generated code")
Warning: Value identifier (ab_semigroup_add_semiring) has not been referenced.
At (line 75 of "generated code")
Warning: Value identifier (semigroup_mult_semiring) has not been referenced.
At (line 77 of "generated code")
Warning: Value identifier (times_mult_zero) has not been referenced.
At (line 93 of "generated code")
Warning: Value identifier (ab_semigroup_add_comm_monoid_add) has not been referenced.
At (line 109 of "generated code")
Warning: Value identifier (monoid_add_comm_monoid_add) has not been referenced.
At (line 111 of "generated code")
Warning: Value identifier (comm_monoid_add_semiring_0) has not been referenced.
At (line 117 of "generated code")
Warning: Value identifier (semiring_semiring_0) has not been referenced.
At (line 121 of "generated code")
Warning: Value identifier (semigroup_mult_monoid_mult) has not been referenced.
At (line 142 of "generated code")
Warning: Value identifier (power_monoid_mult) has not been referenced.
At (line 144 of "generated code")
Warning: Value identifier (monoid_mult_semiring_numeral) has not been referenced.
At (line 150 of "generated code")
Warning: Value identifier (semiring_semiring_numeral) has not been referenced.
At (line 154 of "generated code")
Warning: Value identifier (one_zero_neq_one) has not been referenced.
At (line 158 of "generated code")
Warning: Value identifier (zero_zero_neq_one) has not been referenced.
At (line 159 of "generated code")
Warning: Value identifier (zero_neq_one_semiring_1) has not been referenced.
At (line 169 of "generated code")
Warning: Value identifier (xs) has not been referenced.
At (line 212 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 211 of "generated code")
Warning: Matches are not exhaustive.
fun nth (x :: xs) (... ...) = nth xs n | nth (... :: ...) ... = x
At (line 211 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 214 of "generated code")
Warning: Value identifier (x1) has not been referenced.
At (line 267 of "generated code")
Warning: Value identifier (x2) has not been referenced.
At (line 269 of "generated code")
Warning: Matches are not exhaustive.
fun
   pick (x :: xs) i
         =
         (if ... ... (... ...) then snd x else ... ... (... ...))
At (line 271 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 296 of "generated code")
Warning: Value identifier (inc) has not been referenced.
At (line 299 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 299 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 359 of "generated code")
structure Random_Engine:
  sig
    type nat
    type num
    val range:
       Code_Numeral.natural ->
         Code_Numeral.natural * Code_Numeral.natural ->
           Code_Numeral.natural *
           (Code_Numeral.natural * Code_Numeral.natural)
    val select:
       'a list ->
         Code_Numeral.natural * Code_Numeral.natural ->
           'a * (Code_Numeral.natural * Code_Numeral.natural)
    val select_weight:
       (Code_Numeral.natural * 'a) list ->
         Code_Numeral.natural * Code_Numeral.natural ->
           'a * (Code_Numeral.natural * Code_Numeral.natural)
  end
structure Random_Engine:
  sig
    eqtype nat
    val next_seed: unit -> Code_Numeral.natural * Code_Numeral.natural
    eqtype num
    val range:
       Code_Numeral.natural ->
         Code_Numeral.natural * Code_Numeral.natural ->
           Code_Numeral.natural *
           (Code_Numeral.natural * Code_Numeral.natural)
    val run:
       (Code_Numeral.natural * Code_Numeral.natural ->
          'a * (Code_Numeral.natural * Code_Numeral.natural))
         -> 'a
    type seed = Code_Numeral.natural * Code_Numeral.natural
    val select:
       'a list ->
         Code_Numeral.natural * Code_Numeral.natural ->
           'a * (Code_Numeral.natural * Code_Numeral.natural)
    val select_weight:
       (Code_Numeral.natural * 'a) list ->
         Code_Numeral.natural * Code_Numeral.natural ->
           'a * (Code_Numeral.natural * Code_Numeral.natural)
  end
### theory "HOL.Random"
### 0.481s elapsed time, 1.486s cpu time, 0.195s GC time
class semiring_gcd = gcd + normalization_semidom +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
    and "normalize_gcd": "!!a b. normalize (gcd a b) = gcd a b"
    and "lcm_gcd": "!!a b. lcm a b = normalize (a * b div gcd a b)"
signature STRING_SYNTAX =
  sig
    val ascii_ord_of: string -> int
    datatype character = Char of string | Ord of int
    val classify_character: int -> character
    val dest_bits_syntax: term list -> int
    val hex: int -> string
    val mk_bits_syntax: int -> int -> term list
    val plain_strings_of: string -> string list
  end
structure String_Syntax: STRING_SYNTAX
instantiation
  char :: enum
  enum_char == enum_class.enum :: char list
  enum_all_char == enum_class.enum_all :: (char => bool) => bool
  enum_ex_char == enum_class.enum_ex :: (char => bool) => bool
instantiation
  String.literal :: zero
  zero_literal == zero_class.zero :: String.literal
### ML warning (line 27 of "~~/src/HOL/Tools/literal.ML"):
### Value identifier (t) has not been referenced.
### ML warning (line 56 of "~~/src/HOL/Tools/literal.ML"):
### Matches are not exhaustive.
### ML warning (line 57 of "~~/src/HOL/Tools/literal.ML"):
### Matches are not exhaustive.
### ML warning (line 104 of "~~/src/HOL/Tools/literal.ML"):
### Matches are not exhaustive.
signature LITERAL = sig val add_code: string -> theory -> theory end
structure Literal: LITERAL
instantiation
  String.literal :: plus
  plus_literal == plus :: String.literal => String.literal => String.literal
instantiation
  String.literal :: size
  size_literal == size :: String.literal => nat
instantiation
  String.literal :: equal
  equal_literal == equal_class.equal ::
    String.literal => String.literal => bool
instantiation
  String.literal :: linorder
  less_eq_literal == less_eq :: String.literal => String.literal => bool
  less_literal == less :: String.literal => String.literal => bool
### theory "HOL.String"
### 1.229s elapsed time, 3.028s cpu time, 0.326s GC time
Loading theory "HOL.BNF_Greatest_Fixpoint" (required by "Draft.Pairing_AxiomTemplates" via "Main")
Loading theory "HOL.Predicate" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Code_Evaluation" via "HOL.Limited_Sequence" via "HOL.Lazy_Sequence")
Loading theory "HOL.Typerep" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Code_Evaluation")
instantiation
  pred :: (type) complete_lattice
  Inf_pred == Inf :: 'a pred set => 'a pred
  Sup_pred == Sup :: 'a pred set => 'a pred
  bot_pred == bot :: 'a pred
  sup_pred == sup :: 'a pred => 'a pred => 'a pred
  top_pred == top :: 'a pred
  inf_pred == inf :: 'a pred => 'a pred => 'a pred
  less_eq_pred == less_eq :: 'a pred => 'a pred => bool
  less_pred == less :: 'a pred => 'a pred => bool
class typerep = type +
  fixes typerep :: "'a itself => typerep"
instantiation
  pred :: (type) complete_boolean_algebra
  minus_pred == minus :: 'a pred => 'a pred => 'a pred
  uminus_pred == uminus :: 'a pred => 'a pred
signature BNF_GFP_UTIL =
  sig
    val dest_listT: typ -> typ
    val mk_Cons: term -> term -> term
    val mk_Id_on: term -> term
    val mk_InN: typ list -> term -> int -> term
    val mk_InN_Field: int -> int -> thm
    val mk_InN_inject: int -> int -> thm
    val mk_InN_not_InM: int -> int -> thm
    val mk_Shift: term -> term -> term
    val mk_Succ: term -> term -> term
    val mk_Times: term * term -> term
    val mk_append: term * term -> term
    val mk_congruent: term -> term -> term
    val mk_equiv: term -> term -> term
    val mk_fromCard: term -> term -> term
    val mk_in_rel: term -> term
    val mk_proj: term -> term
    val mk_quotient: term -> term -> term
    val mk_rec_list: term -> term -> term
    val mk_rec_nat: term -> term -> term
    val mk_rec_simps: int -> thm -> thm list -> thm list list
    val mk_shift: term -> term -> term
    val mk_size: term -> term
    val mk_specN: int -> thm -> thm
    val mk_sumEN: int -> thm
    val mk_toCard: term -> term -> term
    val mk_undefined: typ -> term
    val mk_univ: term -> term
  end
structure BNF_GFP_Util: BNF_GFP_UTIL
consts
  pred_of_seq :: "'a seq => 'a pred"
consts
  member :: "'a seq => 'a => bool"
consts
  apply :: "('a => 'b pred) => 'a seq => 'b seq"
consts
  adjunct :: "'a pred => 'a seq => 'a seq"
consts
  contained :: "'a seq => 'a pred => bool"
instantiation
  pred :: (type) equal
  equal_pred == equal_class.equal :: 'a pred => 'a pred => bool
Proofs for inductive predicate(s) "eq"
  Proving monotonicity ...
consts
  null :: "'a seq => bool"
consts
  the_only :: "(unit => 'a) => 'a seq => 'a"
structure Predicate:
  sig
    datatype 'a pred = Seq of unit -> 'a seq
    datatype 'a seq =
        Empty
      | Insert of 'a * 'a pred
      | Join of 'a pred * 'a seq
  end
signature PREDICATE =
  sig
    val anamorph: ('a -> ('b * 'a) option) -> int -> 'a -> 'b list * 'a
    val map: ('a -> 'b) -> 'a pred -> 'b pred
    datatype 'a pred = Seq of unit -> 'a seq
    datatype 'a seq
    = Empty | Insert of 'a * 'a pred | Join of 'a pred * 'a seq
    val yield: 'a pred -> ('a * 'a pred) option
    val yieldn: int -> 'a pred -> 'a list * 'a pred
  end
structure Predicate: PREDICATE
### theory "HOL.Typerep"
### 2.166s elapsed time, 8.206s cpu time, 5.665s GC time
### theory "HOL.Predicate"
### 2.296s elapsed time, 8.594s cpu time, 5.701s GC time
Loading theory "HOL.Lazy_Sequence" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Code_Evaluation" via "HOL.Limited_Sequence")
consts
  list_of_lazy_sequence :: "'a lazy_sequence => 'a list"
structure Lazy_Sequence:
  sig
    datatype 'a lazy_sequence =
        Lazy_Sequence of unit -> ('a * 'a lazy_sequence) option
  end
signature LAZY_SEQUENCE =
  sig
    datatype 'a lazy_sequence
    = Lazy_Sequence of unit -> ('a * 'a Lazy_Sequence.lazy_sequence) option
    val map: ('a -> 'b) -> 'a lazy_sequence -> 'b lazy_sequence
    val yield: 'a lazy_sequence -> ('a * 'a lazy_sequence) option
    val yieldn: int -> 'a lazy_sequence -> 'a list * 'a lazy_sequence
  end
structure Lazy_Sequence: LAZY_SEQUENCE
class small_lazy = type +
  fixes small_lazy :: "natural => 'a lazy_sequence"
instantiation
  unit :: small_lazy
  small_lazy_unit == small_lazy :: natural => unit lazy_sequence
instantiation
  int :: small_lazy
  small_lazy_int == small_lazy :: natural => int lazy_sequence
class semiring_Gcd = Gcd + semiring_gcd +
  assumes "Gcd_dvd": "!!a A. a : A ==> Gcd A dvd a"
    and "Gcd_greatest": "!!A a. (!!b. b : A ==> a dvd b) ==> a dvd Gcd A"
    and "normalize_Gcd": "!!A. normalize (Gcd A) = Gcd A"
  assumes "dvd_Lcm": "!!a A. a : A ==> a dvd Lcm A"
    and "Lcm_least": "!!A a. (!!b. b : A ==> b dvd a) ==> Lcm A dvd a"
    and "normalize_Lcm": "!!A. normalize (Lcm A) = Lcm A"
instantiation
  prod :: (small_lazy, small_lazy) small_lazy
  small_lazy_prod == small_lazy :: natural => ('a * 'b) lazy_sequence
instantiation
  list :: (small_lazy) small_lazy
  small_lazy_list == small_lazy :: natural => 'a list lazy_sequence
Found termination order: "nat_of_natural <*mlex*> {}"
### theory "HOL.Lazy_Sequence"
### 0.456s elapsed time, 1.379s cpu time, 0.121s GC time
Loading theory "HOL.Limited_Sequence" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random" via "HOL.Code_Evaluation")
signature LIMITED_SEQUENCE =
  sig
    type 'a dseq =
       Code_Numeral.natural -> bool -> 'a Lazy_Sequence.lazy_sequence option
    val map: ('a -> 'b) -> 'a dseq -> 'b dseq
    val yield:
       'a dseq -> Code_Numeral.natural -> bool -> ('a * 'a dseq) option
    val yieldn:
       int -> 'a dseq -> Code_Numeral.natural -> bool -> 'a list * 'a dseq
  end
structure Limited_Sequence: LIMITED_SEQUENCE
### theory "HOL.Limited_Sequence"
### 0.180s elapsed time, 0.541s cpu time, 0.036s GC time
Loading theory "HOL.Code_Evaluation" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred" via "HOL.Quickcheck_Random")
class semiring_gcd = gcd + normalization_semidom +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
    and "normalize_gcd": "!!a b. normalize (gcd a b) = gcd a b"
    and "lcm_gcd": "!!a b. lcm a b = normalize (a * b div gcd a b)"
class semiring_Gcd = Gcd + semiring_gcd +
  assumes "Gcd_dvd": "!!a A. a : A ==> Gcd A dvd a"
    and "Gcd_greatest": "!!A a. (!!b. b : A ==> a dvd b) ==> a dvd Gcd A"
    and "normalize_Gcd": "!!A. normalize (Gcd A) = Gcd A"
  assumes "dvd_Lcm": "!!a A. a : A ==> a dvd Lcm A"
    and "Lcm_least": "!!A a. (!!b. b : A ==> b dvd a) ==> Lcm A dvd a"
    and "normalize_Lcm": "!!A. normalize (Lcm A) = Lcm A"
class term_of = typerep +
  fixes term_of :: "'a => term"
bundle term_syntax
class semiring_gcd = gcd + normalization_semidom +
  assumes "gcd_dvd1": "!!a b. gcd a b dvd a"
    and "gcd_dvd2": "!!a b. gcd a b dvd b"
    and "gcd_greatest": "!!c a b. [| c dvd a; c dvd b |] ==> c dvd gcd a b"
    and "normalize_gcd": "!!a b. normalize (gcd a b) = gcd a b"
    and "lcm_gcd": "!!a b. lcm a b = normalize (a * b div gcd a b)"
### ML warning (line 81 of "~~/src/HOL/Tools/code_evaluation.ML"):
### Matches are not exhaustive.
### ML warning (line 111 of "~~/src/HOL/Tools/code_evaluation.ML"):
### Matches are not exhaustive.
signature CODE_EVALUATION =
  sig
    val dynamic_value: Proof.context -> term -> term option
    val dynamic_value_exn: Proof.context -> term -> term Exn.result
    val dynamic_value_strict: Proof.context -> term -> term
    val put_term: (unit -> term) -> Proof.context -> Proof.context
    val tracing: string -> 'a -> 'a
  end
structure Code_Evaluation: CODE_EVALUATION
signature VALUE_COMMAND =
  sig
    val add_evaluator:
       binding * (Proof.context -> term -> term) ->
         theory -> string * theory
    val value: Proof.context -> term -> term
    val value_cmd:
       xstring -> string list -> string -> Toplevel.state -> unit
    val value_select: string -> Proof.context -> term -> term
  end
structure Value_Command: VALUE_COMMAND
instantiation
  fun :: (typerep, typerep) term_of
  term_of_fun == term_of :: ('a => 'b) => term
### ML warning (line 18 of "~~/src/HOL/Tools/reification.ML"):
### Matches are not exhaustive.
### ML warning (line 50 of "~~/src/HOL/Tools/reification.ML"):
### Pattern is not exhaustive.
### ML warning (line 52 of "~~/src/HOL/Tools/reification.ML"):
### Pattern is not exhaustive.
### ML warning (line 86 of "~~/src/HOL/Tools/reification.ML"):
### Pattern is not exhaustive.
### ML warning (line 98 of "~~/src/HOL/Tools/reification.ML"):
### Pattern is not exhaustive.
### ML warning (line 148 of "~~/src/HOL/Tools/reification.ML"):
### Matches are not exhaustive.
### ML warning (line 186 of "~~/src/HOL/Tools/reification.ML"):
### Value identifier (bds) has not been referenced.
### ML warning (line 186 of "~~/src/HOL/Tools/reification.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 186 of "~~/src/HOL/Tools/reification.ML"):
### Value identifier (ct) has not been referenced.
### ML warning (line 207 of "~~/src/HOL/Tools/reification.ML"):
### Matches are not exhaustive.
### ML warning (line 214 of "~~/src/HOL/Tools/reification.ML"):
### Matches are not exhaustive.
### ML warning (line 268 of "~~/src/HOL/Tools/reification.ML"):
### Pattern is not exhaustive.
### ML warning (line 286 of "~~/src/HOL/Tools/reification.ML"):
### Matches are not exhaustive.
signature REIFICATION =
  sig
    val conv: Proof.context -> thm list -> conv
    val dereify: Proof.context -> thm list -> conv
    val lift_conv: Proof.context -> conv -> term option -> int -> tactic
    val tac: Proof.context -> thm list -> term option -> int -> tactic
  end
structure Reification: REIFICATION
### theory "HOL.Code_Evaluation"
### 0.841s elapsed time, 2.526s cpu time, 0.205s GC time
Loading theory "HOL.Quickcheck_Random" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence" via "HOL.Random_Pred")
class semiring_Gcd = Gcd + semiring_gcd +
  assumes "Gcd_dvd": "!!a A. a : A ==> Gcd A dvd a"
    and "Gcd_greatest": "!!A a. (!!b. b : A ==> a dvd b) ==> a dvd Gcd A"
    and "normalize_Gcd": "!!A. normalize (Gcd A) = Gcd A"
  assumes "dvd_Lcm": "!!a A. a : A ==> a dvd Lcm A"
    and "Lcm_least": "!!A a. (!!b. b : A ==> b dvd a) ==> Lcm A dvd a"
    and "normalize_Lcm": "!!A. normalize (Lcm A) = Lcm A"
class random = typerep +
  fixes
    random ::
      "natural
       => natural * natural => ('a * (unit => term)) * natural * natural"
instantiation
  bool :: random
  random_bool == random ::
    natural
    => natural * natural => (bool * (unit => term)) * natural * natural
instantiation
  itself :: (typerep) random
  random_itself == random ::
    natural
    => natural * natural => ('a itself * (unit => term)) * natural * natural
instantiation
  char :: random
  random_char == random ::
    natural
    => natural * natural => (char * (unit => term)) * natural * natural
instantiation
  String.literal :: random
  random_literal == random ::
    natural
    => natural * natural
       => (String.literal * (unit => term)) * natural * natural
instantiation
  nat :: random
  random_nat == random ::
    natural
    => natural * natural => (nat * (unit => term)) * natural * natural
instantiation
  int :: random
  random_int == random ::
    natural
    => natural * natural => (int * (unit => term)) * natural * natural
instantiation
  natural :: random
  random_natural == random ::
    natural
    => natural * natural => (natural * (unit => term)) * natural * natural
instantiation
  integer :: random
  random_integer == random ::
    natural
    => natural * natural => (integer * (unit => term)) * natural * natural
instantiation
  fun :: ({term_of,equal}, random) random
  random_fun == random ::
    natural
    => natural * natural
       => (('a => 'b) * (unit => term)) * natural * natural
instantiation
  set :: (random) random
  random_set == random ::
    natural
    => natural * natural => ('a set * (unit => term)) * natural * natural
### Additional type variable(s) in specification of "random_aux_set_rel": 'b
### Additional type variable(s) in specification of "random_aux_set_dom": 'b
Found termination order: "(%p. nat_of_natural (fst p)) <*mlex*> {}"
### ML warning (line 267 of "~~/src/HOL/Tools/Quickcheck/quickcheck_common.ML"):
### Matches are not exhaustive.
### ML warning (line 268 of "~~/src/HOL/Tools/Quickcheck/quickcheck_common.ML"):
### Matches are not exhaustive.
### ML warning (line 271 of "~~/src/HOL/Tools/Quickcheck/quickcheck_common.ML"):
### Pattern is not exhaustive.
### ML warning (line 269 of "~~/src/HOL/Tools/Quickcheck/quickcheck_common.ML"):
### Matches are not exhaustive.
### ML warning (line 426 of "~~/src/HOL/Tools/Quickcheck/quickcheck_common.ML"):
### Matches are not exhaustive.
### ML warning (line 472 of "~~/src/HOL/Tools/Quickcheck/quickcheck_common.ML"):
### Value identifier (T1) has not been referenced.
### ML warning (line 478 of "~~/src/HOL/Tools/Quickcheck/quickcheck_common.ML"):
### Matches are not exhaustive.
### ML warning (line 497 of "~~/src/HOL/Tools/Quickcheck/quickcheck_common.ML"):
### Matches are not exhaustive.
signature QUICKCHECK_COMMON =
  sig
    val collect_results:
       ('a -> Quickcheck.result) ->
         'a list -> Quickcheck.result list -> Quickcheck.result list
    val compat_prefs: BNF_LFP_Compat.preference list
    val datatype_interpretation:
       string -> sort * instantiation -> theory -> theory
    val define_functions:
       (term list -> term list) * (Proof.context -> tactic) option ->
         string ->
           string list ->
             string list -> typ list -> Proof.context -> Proof.context
    val ensure_common_sort_datatype:
       sort * instantiation ->
         Old_Datatype_Aux.config -> string list -> theory -> theory
    val ensure_sort:
       ((sort * sort) * sort) *
       ((theory ->
           string list ->
             Old_Datatype_Aux.descr * (string * sort) list * string list *
             string * (string list * string list) * (typ list * typ list))
        *
        instantiation)
         -> Old_Datatype_Aux.config -> string list -> theory -> theory
    val gen_mk_parametric_generator_expr:
       ((Proof.context -> term * term list -> term) * term) * typ ->
         Proof.context -> (term * term list) list -> term
    type generator =
       string *
       ((theory -> typ list -> bool) *
        (Proof.context ->
           (term * term list) list -> bool -> int list -> result))
    val generator_test_goal_terms:
       generator ->
         Proof.context ->
           bool ->
             (string * typ) list ->
               (term * term list) list -> Quickcheck.result list
    val instantiate_goals:
       Proof.context ->
         (string * typ) list ->
           (term * term list) list ->
             (typ option * (term * term list)) list list
    type instantiation =
       Old_Datatype_Aux.config ->
         Old_Datatype_Aux.descr ->
           (string * sort) list ->
             string list ->
               string ->
                 string list * string list ->
                   typ list * typ list -> theory -> theory
    val mk_fun_upd: typ -> typ -> term * term -> term -> term
    val mk_safe_if:
       term -> term -> term * term * (bool -> term) -> bool -> term
    val perhaps_constrain:
       theory ->
         (typ * sort) list ->
           (string * sort) list -> (string * sort -> string * sort) option
    val post_process_term: term -> term
    val reflect_bool: bool -> term
    val register_predicate:
       term * string -> Context.generic -> Context.generic
    type result = (bool * term list) option * Quickcheck.report option
    val strip_imp: term -> term list * term
    val test_term:
       generator ->
         Proof.context -> bool -> term * term list -> Quickcheck.result
  end
structure Quickcheck_Common: QUICKCHECK_COMMON
instantiation
  nat :: gcd
  gcd_nat == gcd :: nat => nat => nat
  lcm_nat == lcm :: nat => nat => nat
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  int :: gcd
  gcd_int == gcd :: int => int => int
  lcm_int == lcm :: int => int => int
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
instantiation
  nat :: semiring_Gcd
  Gcd_nat == Gcd :: nat set => nat
  Lcm_nat == Lcm :: nat set => nat
instantiation
  int :: Gcd
  Gcd_int == Gcd :: int set => int
  Lcm_int == Lcm :: int set => int
instantiation
  integer :: gcd
  gcd_integer == gcd :: integer => integer => integer
  lcm_integer == lcm :: integer => integer => integer
signature BNF_GFP_TACTICS =
  sig
    val mk_Jset_minimal_tac: Proof.context -> int -> thm -> tactic
    val mk_bis_Gr_tac:
       Proof.context ->
         thm -> thm list -> thm list -> thm list -> thm list -> tactic
    val mk_bis_O_tac:
       Proof.context -> int -> thm -> thm list -> thm list -> tactic
    val mk_bis_Union_tac: Proof.context -> thm -> thm list -> tactic
    val mk_bis_converse_tac:
       Proof.context -> int -> thm -> thm list -> thm list -> tactic
    val mk_bis_rel_tac:
       Proof.context ->
         int ->
           thm ->
             thm list -> thm list -> thm list -> thm list list -> tactic
    val mk_coalgT_tac:
       Proof.context ->
         int -> thm list -> thm list -> thm list list -> tactic
    val mk_coalg_final_tac:
       Proof.context ->
         int ->
           thm ->
             thm list ->
               thm list -> thm list list -> thm list list -> tactic
    val mk_coalg_set_tac: Proof.context -> thm -> tactic
    val mk_coind_wit_tac:
       Proof.context -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_col_bd_tac:
       Proof.context ->
         int ->
           int ->
             cterm option list ->
               thm list -> thm list -> thm -> thm -> thm list list -> tactic
    val mk_col_minimal_tac:
       Proof.context ->
         int -> cterm option list -> thm list -> thm list -> tactic
    val mk_col_natural_tac:
       Proof.context ->
         cterm option list ->
           thm list -> thm list -> thm list -> thm list list -> tactic
    val mk_congruent_str_final_tac:
       Proof.context -> int -> thm -> thm -> thm -> thm list -> tactic
    val mk_corec_tac:
       Proof.context -> int -> thm list -> thm -> thm -> thm list -> tactic
    val mk_corec_unique_mor_tac:
       Proof.context -> thm list -> thm list -> thm -> tactic
    val mk_dtor_coinduct_tac:
       Proof.context -> int -> thm -> thm -> thm list -> tactic
    val mk_dtor_corec_transfer_tac:
       Proof.context ->
         int ->
           int -> thm list -> thm list -> thm list -> thm list -> tactic
    val mk_dtor_map_unique_tac: Proof.context -> thm -> thm list -> tactic
    val mk_dtor_o_ctor_tac:
       Proof.context -> thm -> thm -> thm -> thm -> thm list -> tactic
    val mk_dtor_rel_tac:
       Proof.context ->
         thm list ->
           int ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm list ->
                       thm ->
                         thm ->
                           thm list -> thm list -> thm list list -> tactic
    val mk_equiv_lsbis_tac:
       Proof.context -> thm -> thm -> thm -> thm -> thm -> thm -> tactic
    val mk_incl_lsbis_tac: Proof.context -> int -> int -> thm -> tactic
    val mk_le_rel_OO_tac:
       Proof.context -> thm -> thm list -> thm list -> tactic
    val mk_length_Lev'_tac: Proof.context -> thm -> tactic
    val mk_length_Lev_tac:
       Proof.context -> cterm option list -> thm list -> thm list -> tactic
    val mk_map_comp0_tac:
       Proof.context -> thm list -> thm list -> thm -> tactic
    val mk_map_id0_tac: Proof.context -> thm list -> thm -> thm -> tactic
    val mk_map_tac:
       Proof.context -> int -> int -> thm -> thm -> thm -> thm -> tactic
    val mk_mcong_tac:
       Proof.context ->
         int ->
           (int -> tactic) ->
             thm list ->
               thm list ->
                 thm list ->
                   thm list list ->
                     thm list list ->
                       thm list list list -> thm list -> tactic
    val mk_mor_Abs_tac: Proof.context -> thm list -> thm list -> tactic
    val mk_mor_Rep_tac:
       Proof.context ->
         thm list ->
           thm list ->
             thm list -> thm list list -> thm list -> thm list -> tactic
    val mk_mor_T_final_tac:
       Proof.context -> thm -> thm list -> thm list -> tactic
    val mk_mor_UNIV_tac: Proof.context -> thm list -> thm -> tactic
    val mk_mor_beh_tac:
       Proof.context ->
         int ->
           thm ->
             thm ->
               thm list ->
                 thm list ->
                   thm list ->
                     thm list ->
                       thm list list ->
                         thm list list ->
                           thm list ->
                             thm list ->
                               thm list ->
                                 thm list ->
                                   thm list ->
                                     thm list ->
                                       thm list list ->
   thm list list list -> thm list list list -> thm list list -> ...
    val mk_mor_col_tac:
       Proof.context ->
         int ->
           int ->
             cterm option list ->
               int ->
                 thm list ->
                   thm list ->
                     thm list -> thm list list -> thm list list -> tactic
    val mk_mor_comp_tac:
       Proof.context -> thm -> thm list -> thm list -> thm list -> tactic
    val mk_mor_elim_tac: Proof.context -> thm -> tactic
    val mk_mor_incl_tac: Proof.context -> thm -> thm list -> tactic
    val mk_mor_str_tac: Proof.context -> 'a list -> thm -> tactic
    val mk_mor_unfold_tac:
       Proof.context ->
         int ->
           thm ->
             thm list ->
               thm list ->
                 thm list -> thm list -> thm list -> thm list -> tactic
    val mk_raw_coind_tac:
       Proof.context ->
         thm ->
           thm ->
             thm ->
               thm ->
                 thm ->
                   thm ->
                     thm ->
                       thm ->
                         thm ->
                           thm list ->
                             thm list ->
                               thm list -> thm -> thm list -> tactic
    val mk_rel_coinduct_coind_tac:
       Proof.context ->
         bool ->
           int ->
             thm ->
               int list ->
                 thm list ->
                   thm list ->
                     thm list ->
                       thm list list ->
                         thm list -> thm list -> thm list -> tactic
    val mk_rel_coinduct_ind_tac:
       Proof.context ->
         int ->
           int list -> thm list -> thm list list -> int -> thm -> tactic
    val mk_rel_coinduct_tac:
       Proof.context ->
         thm list ->
           thm list ->
             thm list -> thm list list -> thm list -> thm list -> tactic
    val mk_rv_last_tac:
       Proof.context ->
         ctyp option list ->
           cterm option list -> thm list -> thm list -> tactic
    val mk_sbis_lsbis_tac: Proof.context -> thm list -> thm -> thm -> tactic
    val mk_set_Jset_incl_Jset_tac:
       Proof.context -> int -> thm -> int -> tactic
    val mk_set_Lev_tac:
       Proof.context ->
         cterm option list ->
           thm list ->
             thm list -> thm list -> thm list -> thm list list -> tactic
    val mk_set_bd_tac: Proof.context -> thm -> thm -> tactic
    val mk_set_ge_tac: Proof.context -> int -> thm -> thm list -> tactic
    val mk_set_image_Lev_tac:
       Proof.context ->
         cterm option list ->
           thm list ->
             thm list ->
               thm list ->
                 thm list -> thm list list -> thm list list -> tactic
    val mk_set_incl_Jset_tac: Proof.context -> thm -> tactic
    val mk_set_le_tac:
       Proof.context -> int -> thm -> thm list -> thm list list -> tactic
    val mk_set_map0_tac: Proof.context -> thm -> tactic
    val mk_unfold_transfer_tac:
       Proof.context -> int -> thm -> thm list -> thm list -> tactic
    val mk_unfold_unique_mor_tac:
       Proof.context -> thm list -> thm -> thm -> thm list -> tactic
    val mk_wit_tac:
       Proof.context ->
         int -> thm list -> thm list -> thm list -> thm list -> tactic
  end
structure BNF_GFP_Tactics: BNF_GFP_TACTICS
### theory "HOL.GCD"
### 6.625s elapsed time, 20.991s cpu time, 7.083s GC time
### ML warning (line 91 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 93 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 120 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Value identifier (auxname) has not been referenced.
### ML warning (line 128 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 128 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 134 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Value identifier (T) has not been referenced.
### ML warning (line 134 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 141 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 120 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 166 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 308 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 352 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 438 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 458 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 466 of "~~/src/HOL/Tools/Quickcheck/random_generators.ML"):
### Matches are not exhaustive.
signature RANDOM_GENERATORS =
  sig
    val compile_generator_expr:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val instantiate_random_datatype:
       Old_Datatype_Aux.config ->
         Old_Datatype_Aux.descr ->
           (string * sort) list ->
             string list ->
               string ->
                 string list * string list ->
                   typ list * typ list -> theory -> theory
    val put_counterexample:
       (unit ->
          Code_Numeral.natural ->
            bool ->
              Code_Numeral.natural ->
                seed -> (bool * term list) option * seed)
         -> Proof.context -> Proof.context
    val put_counterexample_report:
       (unit ->
          Code_Numeral.natural ->
            bool ->
              Code_Numeral.natural ->
                seed ->
                  ((bool * term list) option * (bool list * bool)) * seed)
         -> Proof.context -> Proof.context
    val random_fun:
       typ ->
         typ ->
           ('a -> 'a -> bool) ->
             ('a -> term) ->
               (seed -> ('b * (unit -> term)) * seed) ->
                 (seed -> seed * seed) ->
                   seed -> (('a -> 'b) * (unit -> term)) * seed
    type seed = Random_Engine.seed
  end
structure Random_Generators: RANDOM_GENERATORS
### theory "HOL.Quickcheck_Random"
### 1.781s elapsed time, 5.393s cpu time, 0.778s GC time
Loading theory "HOL.Quickcheck_Exhaustive" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile")
Loading theory "HOL.Random_Pred" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile" via "HOL.Random_Sequence")
Loading theory "HOL.Quickcheck_Narrowing" (required by "Draft.Pairing_AxiomTemplates" via "Main")
class exhaustive = term_of +
  fixes
    exhaustive ::
      "('a => (bool * term list) option)
       => natural => (bool * term list) option"
class full_exhaustive = term_of +
  fixes
    full_exhaustive ::
      "('a * (unit => term) => (bool * term list) option)
       => natural => (bool * term list) option"
instantiation
  natural :: full_exhaustive
  full_exhaustive_natural == full_exhaustive ::
    (natural * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  natural :: exhaustive
  exhaustive_natural == exhaustive ::
    (natural => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  integer :: exhaustive
  exhaustive_integer == exhaustive ::
    (integer => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (fst (snd p))) <*mlex*> {}"
instantiation
  integer :: full_exhaustive
  full_exhaustive_integer == full_exhaustive ::
    (integer * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
### theory "HOL.Random_Pred"
### 0.428s elapsed time, 1.667s cpu time, 0.175s GC time
Loading theory "HOL.Random_Sequence" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Predicate_Compile")
instantiation
  nat :: exhaustive
  exhaustive_nat == exhaustive ::
    (nat => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  nat :: full_exhaustive
  full_exhaustive_nat == full_exhaustive ::
    (nat * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  int :: exhaustive
  exhaustive_int == exhaustive ::
    (int => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  int :: full_exhaustive
  full_exhaustive_int == full_exhaustive ::
    (int * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  prod :: (exhaustive, exhaustive) exhaustive
  exhaustive_prod == exhaustive ::
    ('a * 'b => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  prod :: (full_exhaustive, full_exhaustive) full_exhaustive
  full_exhaustive_prod == full_exhaustive ::
    (('a * 'b) * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  set :: (exhaustive) exhaustive
  exhaustive_set == exhaustive ::
    ('a set => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  set :: (full_exhaustive) full_exhaustive
  full_exhaustive_set == full_exhaustive ::
    ('a set * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
consts
  map_cons :: "('a => 'b) => 'a narrowing_cons => 'b narrowing_cons"
class partial_term_of = typerep +
  fixes partial_term_of :: "'a itself => narrowing_term => term"
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
instantiation
  fun :: ({equal,exhaustive}, exhaustive) exhaustive
  exhaustive_fun == exhaustive ::
    (('a => 'b) => (bool * term list) option)
    => natural => (bool * term list) option
Found termination order: "{}"
Found termination order: "{}"
Found termination order: "(%p. nat_of_natural (fst (snd p))) <*mlex*> {}"
Found termination order: "(%p. nat_of_natural (fst (snd p))) <*mlex*> {}"
instantiation
  fun :: ({equal,full_exhaustive}, full_exhaustive) full_exhaustive
  full_exhaustive_fun == full_exhaustive ::
    (('a => 'b) * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
class narrowing = type +
  fixes narrowing :: "integer => 'a narrowing_cons"
### theory "HOL.Random_Sequence"
### 0.725s elapsed time, 2.807s cpu time, 0.551s GC time
Found termination order: "(%p. nat_of_natural (fst (snd p))) <*mlex*> {}"
class check_all = term_of + enum +
  fixes
    check_all ::
      "('a * (unit => term) => (bool * term list) option)
       => (bool * term list) option"
    and enum_term_of :: "'a itself => unit => term list"
Found termination order: "(%p. nat_of_natural (snd p)) <*mlex*> {}"
### Additional type variable(s) in specification of "termify_fun_upd": 'a, 'b
instantiation
  fun :: ({equal,check_all}, check_all) check_all
  check_all_fun == check_all ::
    (('a => 'b) * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_fun == enum_term_of :: ('a => 'b) itself => unit => term list
Found termination order: "(%p. size_list size (snd p)) <*mlex*> {}"
### Additional type variable(s) in specification of "term_emptyset": 'a
### Additional type variable(s) in specification of "termify_insert": 'a
instantiation
  set :: (check_all) check_all
  check_all_set == check_all ::
    ('a set * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_set == enum_term_of :: 'a set itself => unit => term list
instantiation
  unit :: check_all
  check_all_unit == check_all ::
    (unit * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_unit == enum_term_of :: unit itself => unit => term list
instantiation
  bool :: check_all
  check_all_bool == check_all ::
    (bool * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_bool == enum_term_of :: bool itself => unit => term list
### Additional type variable(s) in specification of "termify_pair": 'a, 'b
instantiation
  prod :: (check_all, check_all) check_all
  check_all_prod == check_all ::
    (('a * 'b) * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_prod == enum_term_of :: ('a * 'b) itself => unit => term list
instantiation
  sum :: (check_all, check_all) check_all
  check_all_sum == check_all ::
    (('a + 'b) * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_sum == enum_term_of :: ('a + 'b) itself => unit => term list
instantiation
  char :: check_all
  check_all_char == check_all ::
    (char * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_char == enum_term_of :: char itself => unit => term list
consts
  check_all_char' ::
    "(char * (unit => term) => (bool * term list) option)
     => char list => (bool * term list) option"
instantiation
  option :: (check_all) check_all
  check_all_option == check_all ::
    ('a option * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_option == enum_term_of ::
    'a option itself => unit => term list
consts
  eval_ffun :: "('a, 'b) ffun => 'a => 'b"
instantiation
  Enum.finite_1 :: check_all
  check_all_finite_1 == check_all ::
    (Enum.finite_1 * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_finite_1 == enum_term_of ::
    Enum.finite_1 itself => unit => term list
instantiation
  Enum.finite_2 :: check_all
  check_all_finite_2 == check_all ::
    (Enum.finite_2 * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_finite_2 == enum_term_of ::
    Enum.finite_2 itself => unit => term list
instantiation
  Enum.finite_3 :: check_all
  check_all_finite_3 == check_all ::
    (Enum.finite_3 * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_finite_3 == enum_term_of ::
    Enum.finite_3 itself => unit => term list
### ML warning (line 2602 of "~~/src/HOL/Tools/BNF/bnf_gfp.ML"):
### A function value is being discarded.
signature BNF_GFP =
  sig
    val construct_gfp:
       mixfix list ->
         binding list ->
           binding list ->
             binding list ->
               binding list list ->
                 binding list ->
                   (string * sort) list ->
                     typ list * typ list list ->
                       BNF_Def.bnf list ->
                         BNF_Comp.absT_info list ->
                           local_theory ->
                             BNF_FP_Util.fp_result * local_theory
  end
structure BNF_GFP: BNF_GFP
instantiation
  Enum.finite_4 :: check_all
  check_all_finite_4 == check_all ::
    (Enum.finite_4 * (unit => term) => (bool * term list) option)
    => (bool * term list) option
  enum_term_of_finite_4 == enum_term_of ::
    Enum.finite_4 itself => unit => term list
consts
  eval_cfun :: "'b cfun => 'a => 'b"
### ML warning (line 100 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar_tactics.ML"):
### Matches are not exhaustive.
### ML warning (line 116 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar_tactics.ML"):
### Matches are not exhaustive.
signature BNF_GFP_REC_SUGAR_TACTICS =
  sig
    val mk_primcorec_assumption_tac:
       Proof.context -> thm list -> int -> tactic
    val mk_primcorec_code_tac:
       Proof.context -> thm list -> thm list -> thm -> tactic
    val mk_primcorec_ctr_tac:
       Proof.context -> int -> thm -> thm option -> thm list -> tactic
    val mk_primcorec_disc_iff_tac:
       Proof.context ->
         string list ->
           thm -> thm list -> thm list list -> thm list -> tactic
    val mk_primcorec_disc_tac:
       Proof.context ->
         thm list -> thm -> int -> int -> thm list list list -> tactic
    val mk_primcorec_exhaust_tac:
       Proof.context -> string list -> int -> thm -> tactic
    val mk_primcorec_nchotomy_tac: Proof.context -> thm list -> tactic
    val mk_primcorec_raw_code_tac:
       Proof.context ->
         thm list ->
           thm list ->
             thm list ->
               thm list -> int list -> thm list -> thm option -> tactic
    val mk_primcorec_sel_tac:
       Proof.context ->
         thm list ->
           thm list ->
             thm list ->
               thm list ->
                 thm list ->
                   thm list ->
                     thm list ->
                       thm -> int -> int -> thm list list list -> tactic
  end
structure BNF_GFP_Rec_Sugar_Tactics: BNF_GFP_REC_SUGAR_TACTICS
class bounded_forall = type +
  fixes bounded_forall :: "('a => bool) => natural => bool"
class fast_exhaustive = term_of +
  fixes fast_exhaustive :: "('a => unit) => natural => unit"
### ML warning (line 187 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 212 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 232 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 357 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 428 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 488 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Pattern is not exhaustive.
### ML warning (line 527 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 558 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 580 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 886 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 956 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 957 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 958 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1071 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1072 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1073 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1091 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1093 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1105 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1107 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1119 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1121 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1140 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1178 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1178 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1219 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1229 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1228 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1228 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1336 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1397 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
### ML warning (line 1459 of "~~/src/HOL/Tools/BNF/bnf_gfp_rec_sugar.ML"):
### Matches are not exhaustive.
signature BNF_GFP_REC_SUGAR =
  sig
    val abs_tuple_balanced: term list -> term -> term
    val abstract_over_list: term list -> term -> term
    val case_of: Proof.context -> string -> (string * bool) option
    val case_thms_of_term:
       Proof.context ->
         term -> thm list * thm list * thm list * thm list * thm list
    val conjuncts_s: term -> term list
    datatype corec_call
    =
         Dummy_No_Corec of int
       | Mutual_Corec of int * int * int
       | Nested_Corec of int
       | No_Corec of int
    type corec_ctr_spec =
       {calls: corec_call list,
        collapse: thm,
        corec_disc: thm,
        corec_sels: thm list,
        corec_thm: thm,
        ctr: term,
        disc: term,
        discI: thm,
        distinct_discss: thm list list,
        pred: int option, sel_thms: thm list, sels: term list}
    datatype corec_option
    =
         Exhaustive_Option
       | Plugins_Option of Proof.context -> Plugin_Name.filter
       | Sequential_Option
       | Transfer_Option
    type corec_spec =
       {T: typ,
        corec: term,
        ctr_specs: corec_ctr_spec list,
        exhaust_discs: thm list,
        fp_nesting_map_comps: thm list,
        fp_nesting_map_ident0s: thm list,
        fp_nesting_maps: thm list, sel_defs: thm list}
    val corec_specs_of:
       binding list ->
         typ list ->
           typ list ->
             term list ->
               (term * term list list) list list ->
                 local_theory ->
                   corec_spec list * typ list * thm * thm * thm list *
                   thm list * (Token.src list * Token.src list) * bool *
                   local_theory
    val expand_to_ctr_term: Proof.context -> typ -> term -> term
    val fold_rev_corec_code_rhs:
       Proof.context ->
         (term list -> term -> term list -> 'a -> 'a) ->
           typ list -> term -> 'a -> 'a
    val fold_rev_let_if_case:
       Proof.context ->
         (term list -> term -> 'a -> 'a) -> typ list -> term -> 'a -> 'a
    val gfp_rec_sugar_interpretation:
       string ->
         (BNF_FP_Rec_Sugar_Util.fp_rec_sugar ->
            local_theory -> local_theory)
           -> theory -> theory
    val map_thms_of_type: Proof.context -> typ -> thm list
    val massage_corec_code_rhs:
       Proof.context ->
         (typ list -> term -> term list -> term) -> typ list -> term -> term
    val massage_let_if_case:
       Proof.context ->
         (term -> bool) ->
           (typ list -> term -> term) ->
             (typ list -> term -> unit) ->
               (typ list -> term -> term) -> typ list -> term -> term
    val massage_nested_corec_call:
       Proof.context ->
         (term -> bool) ->
           (typ list -> typ -> typ -> term -> term) ->
             (typ list -> typ -> typ -> term -> term) ->
               typ list -> typ -> typ -> term -> term
    val mk_conjs: term list -> term
    val mk_disjs: term list -> term
    val mk_dnf: term list list -> term
    val primcorec_cmd:
       bool ->
         corec_option list ->
           (binding * string option * mixfix) list *
           ((Attrib.binding * string) * string option) list
             -> local_theory -> local_theory
    val primcorec_ursive:
       bool ->
         bool ->
           corec_option list ->
             ((binding * typ) * mixfix) list ->
               ((binding * Token.T list list) * term) list ->
                 term option list ->
                   Proof.context ->
                     (term * 'a list) list list *
                     (thm list list -> local_theory -> local_theory) *
                     local_theory
    val primcorec_ursive_cmd:
       bool ->
         bool ->
           corec_option list ->
             (binding * string option * mixfix) list *
             ((Attrib.binding * string) * string option) list
               ->
               Proof.context ->
                 (term * 'a list) list list *
                 (thm list list -> local_theory -> local_theory) *
                 local_theory
    val primcorecursive_cmd:
       bool ->
         corec_option list ->
           (binding * string option * mixfix) list *
           ((Attrib.binding * string) * string option) list
             -> Proof.context -> Proof.state
    val s_conjs: term list -> term
    val s_disjs: term list -> term
    val s_dnf: term list list -> term list
    val s_not: term -> term
    val s_not_conj: term list -> term list
  end
structure BNF_GFP_Rec_Sugar: BNF_GFP_REC_SUGAR
### theory "HOL.BNF_Greatest_Fixpoint"
### 30.567s elapsed time, 104.305s cpu time, 84.715s GC time
### ML warning (line 100 of "~~/src/HOL/Tools/Quickcheck/narrowing_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 101 of "~~/src/HOL/Tools/Quickcheck/narrowing_generators.ML"):
### Value identifier (const) has not been referenced.
### ML warning (line 390 of "~~/src/HOL/Tools/Quickcheck/narrowing_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 426 of "~~/src/HOL/Tools/Quickcheck/narrowing_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 434 of "~~/src/HOL/Tools/Quickcheck/narrowing_generators.ML"):
### Matches are not exhaustive.
signature NARROWING_GENERATORS =
  sig
    val active: bool Config.T
    val allow_existentials: bool Config.T
    datatype counterexample
    =
         Empty_Assignment
       | Existential_Counterexample of (term * counterexample) list
       | Universal_Counterexample of term * counterexample
    val finite_functions: bool Config.T
    val ghc_options: string Config.T
    val overlord: bool Config.T
    val put_counterexample:
       (unit -> (bool * term list) option) -> Proof.context -> Proof.context
    val put_existential_counterexample:
       (unit -> counterexample option) -> Proof.context -> Proof.context
  end
structure Narrowing_Generators: NARROWING_GENERATORS
instantiation
  set :: (narrowing) narrowing
  narrowing_set == narrowing :: integer => 'a set narrowing_cons
instantiation
  int :: narrowing
  narrowing_int == narrowing :: integer => int narrowing_cons
instantiation
  integer :: narrowing
  narrowing_integer == narrowing :: integer => integer narrowing_cons
signature FIND_UNUSED_ASSMS =
  sig
    val check_unused_assms:
       Proof.context -> string * thm -> string * int list list option
    val find_unused_assms:
       Proof.context -> string -> (string * int list list option) list
    val print_unused_assms: Proof.context -> string option -> unit
  end
structure Find_Unused_Assms: FIND_UNUSED_ASSMS
### theory "HOL.Quickcheck_Narrowing"
### 25.261s elapsed time, 86.389s cpu time, 77.925s GC time
### ML warning (line 59 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 325 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 331 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 358 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 365 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 380 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 391 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 422 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Pattern is not exhaustive.
### ML warning (line 424 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 486 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Matches are not exhaustive.
### ML warning (line 494 of "~~/src/HOL/Tools/Quickcheck/exhaustive_generators.ML"):
### Matches are not exhaustive.
signature EXHAUSTIVE_GENERATORS =
  sig
    exception Counterexample of term list
    val compile_generator_expr:
       Proof.context ->
         (term * term list) list ->
           bool ->
             int list ->
               (bool * term list) option * Quickcheck.report option
    val compile_generator_exprs:
       Proof.context -> term list -> (int -> term list option) list
    val compile_validator_exprs:
       Proof.context -> term list -> (int -> bool) list
    val instantiate_exhaustive_datatype:
       Old_Datatype_Aux.config ->
         Old_Datatype_Aux.descr ->
           (string * sort) list ->
             string list ->
               string ->
                 string list * string list ->
                   typ list * typ list -> theory -> theory
    val instantiate_full_exhaustive_datatype:
       Old_Datatype_Aux.config ->
         Old_Datatype_Aux.descr ->
           (string * sort) list ->
             string list ->
               string ->
                 string list * string list ->
                   typ list * typ list -> theory -> theory
    val optimise_equality: bool Config.T
    val put_counterexample:
       (unit ->
          Code_Numeral.natural ->
            bool -> Code_Numeral.natural -> (bool * term list) option)
         -> Proof.context -> Proof.context
    val put_counterexample_batch:
       (unit -> (Code_Numeral.natural -> term list option) list) ->
         Proof.context -> Proof.context
    val put_validator_batch:
       (unit -> (Code_Numeral.natural -> bool) list) ->
         Proof.context -> Proof.context
    val quickcheck_pretty: bool Config.T
    val setup_bounded_forall_datatype_interpretation: theory -> theory
    val setup_exhaustive_datatype_interpretation: theory -> theory
    val smart_quantifier: bool Config.T
  end
structure Exhaustive_Generators: EXHAUSTIVE_GENERATORS
signature ABSTRACT_GENERATORS =
  sig
    val quickcheck_generator:
       string -> term option -> term list -> theory -> theory
  end
structure Abstract_Generators: ABSTRACT_GENERATORS
### theory "HOL.Quickcheck_Exhaustive"
### 25.462s elapsed time, 86.581s cpu time, 77.925s GC time
Loading theory "HOL.Record" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Nunchaku" via "HOL.Nitpick")
Loading theory "HOL.Predicate_Compile" (required by "Draft.Pairing_AxiomTemplates" via "Main")
consts
  repr :: "('a, 'b, 'c) tuple_isomorphism => 'a => 'b * 'c"
consts
  abst :: "('a, 'b, 'c) tuple_isomorphism => 'b * 'c => 'a"
### ML warning (line 173 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 172 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 171 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 177 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Value identifier (f) has not been referenced.
### ML warning (line 175 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Matches are not exhaustive.
### ML warning (line 199 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Matches are not exhaustive.
### ML warning (line 250 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Matches are not exhaustive.
### ML warning (line 821 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 843 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 865 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 875 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 898 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 908 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 909 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 936 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 937 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 947 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 1008 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Matches are not exhaustive.
### ML warning (line 1062 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 1129 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
### ML warning (line 1141 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML"):
### Pattern is not exhaustive.
signature PREDICATE_COMPILE_AUX =
  sig
    val all_modes_of_typ: typ -> mode list
    val all_smodes_of_typ: typ -> mode list
    val ascii_string_of_mode: mode -> string
    val bool_options: string list
    val case_betapply: theory -> term -> term
    val compilation: options -> compilation
    datatype compilation
    =
         Annotated
       | DSeq
       | Depth_Limited
       | Depth_Limited_Random
       | Neg_Generator_CPS
       | Neg_Generator_DSeq
       | Neg_Random_DSeq
       | New_Neg_Random_DSeq
       | New_Pos_Random_DSeq
       | Pos_Generator_CPS
       | Pos_Generator_DSeq
       | Pos_Random_DSeq
       | Pred
       | Random
    val compilation_for_polarity: bool -> compilation -> compilation
    datatype compilation_funs
    =
         CompilationFuns of
             {dest_monadT: typ -> typ,
              mk_bind: term * term -> term,
              mk_empty: typ -> term,
              mk_if: term -> term,
              mk_iterate_upto: typ -> term * term * term -> term,
              mk_map: typ -> typ -> term -> term -> term,
              mk_monadT: typ -> typ,
              mk_not: term -> term,
              mk_plus: term * term -> term, mk_single: term -> term}
    val compilation_names: (string * compilation) list
    val default_options: options
    val define_quickcheck_predicate:
       term ->
         theory -> (((string * typ) * (string * typ) list) * thm) * theory
    val dest_conjunct_prem: thm -> thm list
    val dest_fun_mode: mode -> mode list
    val dest_indprem: indprem -> term
    val dest_monadT: compilation_funs -> typ -> typ
    val dest_tuple_mode: mode -> mode list
    val detect_switches: options -> bool
    val eq_mode: mode * mode -> bool
    val eta_contract_ho_arguments: theory -> thm -> thm
    val expand_tuples: theory -> thm -> thm
    val expected_modes: options -> (string * mode list) option
    val fail_safe_function_flattening: options -> bool
    val find_indices: ('a -> bool) -> 'a list -> int list
    val find_split_thm: theory -> term -> thm option
    val focus_ex:
       term -> Name.context -> ((string * typ) list * term) * Name.context
    val fold_atoms: (term -> 'a -> 'a) -> term -> 'a -> 'a
    val fold_map_aterms_prodT:
       ('a -> 'a -> 'a) -> (typ -> 'b -> 'a * 'b) -> typ -> 'b -> 'a * 'b
    val fold_map_atoms: (term -> 'a -> term * 'a) -> term -> 'a -> term * 'a
    val funT_of: compilation_funs -> mode -> typ -> typ
    val function_flattening: options -> bool
    val ho_arg_modes_of: mode -> mode list
    val ho_argsT_of: mode -> typ list -> typ list
    val ho_argsT_of_typ: typ list -> typ list
    val ho_args_of: mode -> term list -> term list
    val ho_args_of_typ: typ -> term list -> term list
    val imp_prems_conv: conv -> conv
    datatype indprem
    =
         Generator of string * typ
       | Negprem of term
       | Prem of term
       | Sidecond of term
    val is_constrt: Proof.context -> term -> bool
    val is_depth_limited_compilation: compilation -> bool
    val is_equationlike: thm -> bool
    val is_inductify: options -> bool
    val is_intro: string -> thm -> bool
    val is_predT: typ -> bool
    val is_pred_equation: thm -> bool
    val list_fun_mode: mode list -> mode
    val lookup_constr: Proof.context -> string * typ -> int option
    val map_atoms: (term -> term) -> term -> term
    val map_concl: (term -> term) -> term -> term
    val map_filter_prod: (term -> term option) -> term -> term option
    val map_indprem: (term -> term) -> indprem -> indprem
    val map_term: theory -> (term -> term) -> thm -> thm
    val maps_premises: (term -> term list) -> term -> term
    val mk_bind: compilation_funs -> term * term -> term
    val mk_casesrule: Proof.context -> term -> thm list -> term
    val mk_empty: compilation_funs -> typ -> term
    val mk_if: compilation_funs -> term -> term
    val mk_iterate_upto:
       compilation_funs -> typ -> term * term * term -> term
    val mk_map: compilation_funs -> typ -> typ -> term -> term -> term
    val mk_monadT: compilation_funs -> typ -> typ
    val mk_not: compilation_funs -> term -> term
    val mk_plus: compilation_funs -> term * term -> term
    val mk_single: compilation_funs -> term -> term
    datatype mode
    = Bool | Fun of mode * mode | Input | Output | Pair of mode * mode
    val mode_ord: mode ord
    val negative_compilation_of: compilation -> compilation
    val no_higher_order_predicate: options -> string list
    val no_topmost_reordering: options -> bool
    val non_random_compilations: compilation list
    datatype options
    =
         Options of
             {compilation: compilation,
              detect_switches: bool,
              expected_modes: (string * mode list) option,
              fail_safe_function_flattening: bool,
              function_flattening: bool,
              inductify: bool,
              no_higher_order_predicate: string list,
              no_topmost_reordering: bool,
              proposed_modes: (string * mode list) list,
              proposed_names: ((string * mode) * string) list,
              show_caught_failures: bool,
              show_compilation: bool,
              show_intermediate_results: bool,
              show_invalid_clauses: bool,
              show_mode_inference: bool,
              show_modes: bool, show_proof_trace: bool, ...}
    val peephole_optimisation: theory -> thm -> thm option
    val prepare_split_thm: Proof.context -> thm -> thm
    val preprocess_intro: theory -> thm -> thm
    val print_step: options -> string -> unit
    val proposed_modes: options -> string -> mode list option
    val proposed_names: options -> string -> mode -> string option
    val random_compilations: compilation list
    val remove_equalities: theory -> thm -> thm
    val remove_pointless_clauses: thm -> thm list
    val replace_ho_args: mode -> term list -> term list -> term list
    val show_caught_failures: options -> bool
    val show_compilation: options -> bool
    val show_intermediate_results: options -> bool
    val show_invalid_clauses: options -> bool
    val show_mode_inference: options -> bool
    val show_modes: options -> bool
    val show_proof_trace: options -> bool
    val show_steps: options -> bool
    val skip_proof: options -> bool
    val smart_depth_limiting: options -> bool
    val specialise: options -> bool
    val split_conjuncts_in_assms: Proof.context -> thm -> thm
    val split_map_mode:
       (mode -> term -> term option * term option) ->
         mode -> term list -> term list * term list
    val split_map_modeT:
       (mode -> typ -> typ option * typ option) ->
         mode -> typ list -> typ list * typ list
    val split_mode: mode -> term list -> term list * term list
    val split_modeT: mode -> typ list -> typ list * typ list
    val string_of_compilation: compilation -> string
    val string_of_mode: mode -> string
    val strip_all: term -> (string * typ) list * term
    val strip_ex: term -> (string * typ) list * term
    val strip_fun_mode: mode -> mode list
    val strip_intro_concl: thm -> term * term list
    val unify_consts:
       theory -> term list -> term list -> term list * term list
  end
structure Predicate_Compile_Aux: PREDICATE_COMPILE_AUX
locale isomorphic_tuple
  fixes isom :: "('a, 'b, 'c) tuple_isomorphism"
  assumes "isomorphic_tuple isom"
### ML warning (line 22 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 43 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 55 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Matches are not exhaustive.
### ML warning (line 86 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 137 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 196 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 253 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 302 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 348 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 355 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 416 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 423 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 485 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 492 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 560 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 567 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
### ML warning (line 633 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML"):
### Pattern is not exhaustive.
structure Predicate_Comp_Funs:
  sig
    val compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_Eval: term -> term * term
    val dest_monadT: typ -> typ
    val mk_Enum: term -> term
    val mk_Eval: term * term -> term
    val mk_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: typ -> term * term * term -> term
    val mk_map: typ -> typ -> term -> term -> term
    val mk_monadT: typ -> typ
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_single: term -> term
  end
structure CPS_Comp_Funs:
  sig
    val compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_Eval: 'a -> 'b
    val dest_monadT: typ -> typ
    val mk_Enum: 'a -> 'b
    val mk_Eval: 'a -> 'b
    val mk_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: 'a -> 'b -> 'c
    val mk_map: 'a -> 'b -> 'c -> 'd -> 'e
    val mk_monadT: typ -> typ
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_single: term -> term
  end
structure Pos_Bounded_CPS_Comp_Funs:
  sig
    val compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_Eval: 'a -> 'b
    val dest_monadT: typ -> typ
    val mk_Enum: 'a -> 'b
    val mk_Eval: 'a -> 'b
    val mk_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: 'a -> 'b -> 'c
    val mk_map: 'a -> 'b -> 'c -> 'd -> 'e
    val mk_monadT: typ -> typ
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_single: term -> term
    val resultT: typ
  end
structure Neg_Bounded_CPS_Comp_Funs:
  sig
    val compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_Eval: 'a -> 'b
    val dest_monadT: typ -> typ
    val mk_Enum: 'a -> 'b
    val mk_Eval: 'a -> 'b
    val mk_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: 'a -> 'b -> 'c
    val mk_map: 'a -> 'b -> 'c -> 'd -> 'e
    val mk_monadT: typ -> typ
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_single: term -> term
  end
structure RandomPredCompFuns:
  sig
    val compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_randompredT: typ -> typ
    val mk_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: typ -> term * term * term -> term
    val mk_map: typ -> typ -> term -> term -> term
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_randompredT: typ -> typ
    val mk_single: term -> term
  end
structure DSequence_CompFuns:
  sig
    val compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_dseqT: typ -> typ
    val mk_bind: term * term -> term
    val mk_dseqT: typ -> typ
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: 'a -> 'b -> 'c
    val mk_map: typ -> typ -> term -> term -> term
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_single: term -> term
  end
structure New_Pos_DSequence_CompFuns:
  sig
    val depth_limited_compfuns: Predicate_Compile_Aux.compilation_funs
    val depth_unlimited_compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_pos_dseqT: typ -> typ
    val mk_bind: term * term -> term
    val mk_decr_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: 'a -> 'b -> 'c
    val mk_map: typ -> typ -> term -> term -> term
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_pos_dseqT: typ -> typ
    val mk_single: term -> term
  end
structure New_Neg_DSequence_CompFuns:
  sig
    val depth_limited_compfuns: Predicate_Compile_Aux.compilation_funs
    val depth_unlimited_compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_neg_dseqT: typ -> typ
    val mk_bind: term * term -> term
    val mk_decr_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: 'a -> 'b -> 'c
    val mk_map: typ -> typ -> term -> term -> term
    val mk_neg_dseqT: typ -> typ
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_single: term -> term
  end
structure New_Pos_Random_Sequence_CompFuns:
  sig
    val depth_limited_compfuns: Predicate_Compile_Aux.compilation_funs
    val depth_unlimited_compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_pos_random_dseqT: typ -> typ
    val mk_bind: term * term -> term
    val mk_decr_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: typ -> term * term * term -> term
    val mk_map: typ -> typ -> term -> term -> term
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_pos_random_dseqT: typ -> typ
    val mk_single: term -> term
  end
structure New_Neg_Random_Sequence_CompFuns:
  sig
    val depth_limited_compfuns: Predicate_Compile_Aux.compilation_funs
    val depth_unlimited_compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_neg_random_dseqT: typ -> typ
    val mk_bind: term * term -> term
    val mk_decr_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: typ -> term * term * term -> term
    val mk_map: typ -> typ -> term -> term -> term
    val mk_neg_random_dseqT: typ -> typ
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_single: term -> term
  end
structure Random_Sequence_CompFuns:
  sig
    val compfuns: Predicate_Compile_Aux.compilation_funs
    val dest_random_dseqT: typ -> typ
    val mk_bind: term * term -> term
    val mk_empty: typ -> term
    val mk_if: term -> term
    val mk_iterate_upto: 'a -> 'b -> 'c
    val mk_map: typ -> typ -> term -> term -> term
    val mk_not: term -> term
    val mk_plus: term * term -> term
    val mk_random_dseqT: typ -> typ
    val mk_single: term -> term
  end
### ML warning (line 411 of "~~/src/HOL/Tools/Predicate_Compile/core_data.ML"):
### Pattern is not exhaustive.
signature CORE_DATA =
  sig
    structure PredData: THEORY_DATA
    val add_intro: string option * thm -> theory -> theory
    val add_predfun_data:
       string ->
         mode -> thm * ((thm * thm) * thm option) -> theory -> theory
    val all_modes_of:
       compilation -> Proof.context -> (string * mode list) list
    val all_preds_of: Proof.context -> string list
    val all_random_modes_of: Proof.context -> (string * mode list) list
    val alternative_compilation_of:
       Proof.context ->
         string -> mode -> (compilation_funs -> typ -> term) option
    val alternative_compilation_of_global:
       theory -> string -> mode -> (compilation_funs -> typ -> term) option
    eqtype compilation
    type compilation_funs
    val defined_function_of: compilation -> string -> theory -> theory
    val defined_functions: compilation -> Proof.context -> string -> bool
    val extend_intro_graph: string list -> theory -> theory
    val force_modes_and_compilations:
       string ->
         (mode * ((compilation_funs -> typ -> term) * bool)) list ->
           theory -> theory
    val force_modes_and_functions:
       string -> (mode * (string * bool)) list -> theory -> theory
    val function_name_of:
       compilation -> Proof.context -> string -> mode -> string
    val functional_compilation:
       string -> mode -> compilation_funs -> typ -> term
    val has_elim: Proof.context -> string -> bool
    val intros_graph_of: Proof.context -> thm list Graph.T
    val intros_of: Proof.context -> string -> thm list
    val is_registered: Proof.context -> string -> bool
    eqtype mode
    val modes_of: compilation -> Proof.context -> string -> mode list
    val names_of: Proof.context -> string -> string option list
    val needs_random: Proof.context -> string -> mode -> bool
    datatype pred_data
    =
         PredData of
             {elim: thm option,
              function_names: (compilation * (mode * string) list) list,
              intros: (string option * thm) list,
              needs_random: mode list,
              pos: Position.T,
              predfun_data: (mode * predfun_data) list, preprocessed: bool}
    datatype predfun_data
    =
         PredfunData of
             {definition: thm, elim: thm, intro: thm, neg_intro: thm option}
    val predfun_definition_of: Proof.context -> string -> mode -> thm
    val predfun_elim_of: Proof.context -> string -> mode -> thm
    val predfun_intro_of: Proof.context -> string -> mode -> thm
    val predfun_neg_intro_of: Proof.context -> string -> mode -> thm option
    val preprocess_intros: string -> theory -> theory
    val register_alternative_function:
       string -> mode -> string -> theory -> theory
    val register_intros: string * thm list -> theory -> theory
    val register_predicate: string * thm list * thm -> theory -> theory
    val set_elim: thm -> theory -> theory
    val set_function_name:
       compilation -> string -> mode -> string -> theory -> theory
    val set_needs_random: string -> mode list -> theory -> theory
    val the_elim_of: Proof.context -> string -> thm
  end
structure Core_Data: CORE_DATA
### ML warning (line 143 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Matches are not exhaustive.
### ML warning (line 172 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 174 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 185 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 211 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (ctxt) has not been referenced.
### ML warning (line 233 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Matches are not exhaustive.
### ML warning (line 251 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (modes) has not been referenced.
### ML warning (line 278 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 278 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (modes) has not been referenced.
### ML warning (line 277 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 276 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (vs) has not been referenced.
### ML warning (line 282 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (ord) has not been referenced.
### ML warning (line 281 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (ord) has not been referenced.
### ML warning (line 280 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (ord) has not been referenced.
### ML warning (line 299 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Matches are not exhaustive.
### ML warning (line 307 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (x') has not been referenced.
### ML warning (line 307 of "~~/src/HOL/Tools/Predicate_Compile/mode_inference.ML"):
### Value identifier (x) has not been referenced.
signature MODE_INFERENCE =
  sig
    val all_derivations_of:
       Proof.context ->
         (string * mode list) list ->
           string list -> term -> (mode_derivation * string list) list
    val all_input_of: typ -> mode
    val collect_context_modes: mode_derivation -> mode list
    val collect_non_invertible_subterms:
       Proof.context ->
         term -> string list * term list -> term * (string list * term list)
    val head_mode_of: mode_derivation -> mode
    val infer_modes:
       mode_analysis_options ->
         Predicate_Compile_Aux.options ->
           (string -> mode list) * (string -> mode list) *
           (string -> mode -> bool)
             ->
             Proof.context ->
               (string * typ) list ->
                 (string * mode list) list ->
                   string list ->
                     (string *
                      (term list * Predicate_Compile_Aux.indprem list) list
                     )
                     list
                       ->
                       (moded_clause list pred_mode_table *
                        (string * mode list) list)
                       *
                       string list
    val is_all_input: mode -> bool
    eqtype mode
    type mode_analysis_options =
       {infer_pos_and_neg_modes: bool,
        reorder_premises: bool, use_generators: bool}
    datatype mode_derivation
    =
         Context of mode
       | Mode_App of mode_derivation * mode_derivation
       | Mode_Pair of mode_derivation * mode_derivation
       | Term of mode
    type moded_clause =
       term list * (Predicate_Compile_Aux.indprem * mode_derivation) list
    val param_derivations_of: mode_derivation -> mode_derivation list
    type 'a pred_mode_table = (string * ((bool * mode) * 'a) list) list
    val term_vs: term -> string list
    val terms_vs: term list -> string list
  end
structure Mode_Inference: MODE_INFERENCE
### ML warning (line 63 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 107 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_proof.ML"):
### Value identifier (concl) has not been referenced.
### ML warning (line 114 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_proof.ML"):
### Pattern is not exhaustive.
### ML warning (line 87 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 133 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_proof.ML"):
### Pattern is not exhaustive.
### ML warning (line 210 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_proof.ML"):
### Matches are not exhaustive.
### ML warning (line 305 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_proof.ML"):
### Pattern is not exhaustive.
### ML warning (line 424 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_proof.ML"):
### Matches are not exhaustive.
signature PREDICATE_COMPILE_PROOF =
  sig
    eqtype indprem
    eqtype mode
    val prove_pred:
       Predicate_Compile_Aux.options ->
         theory ->
           (string * (term list * indprem list) list) list ->
             (string * typ) list ->
               string ->
                 bool * mode ->
                   (term list *
                    (indprem * Mode_Inference.mode_derivation) list
                   )
                   list
                   *
                   term
                     -> thm
  end
structure Predicate_Compile_Proof: PREDICATE_COMPILE_PROOF
### ML warning (line 139 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 454 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 536 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 764 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 857 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 926 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 942 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 1180 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 1380 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 1471 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 1562 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 1573 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 1579 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 1620 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 1621 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 1645 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 1739 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 1793 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 1804 of "~~/src/HOL/Tools/record.ML"):
### Value identifier (ctxt0) has not been referenced.
### ML warning (line 1865 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 1950 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 1975 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 1988 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 2045 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 2065 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 2095 of "~~/src/HOL/Tools/record.ML"):
### Matches are not exhaustive.
### ML warning (line 2196 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
### ML warning (line 2224 of "~~/src/HOL/Tools/record.ML"):
### Pattern is not exhaustive.
signature RECORD =
  sig
    val add_record:
       {overloaded: bool} ->
         (string * sort) list * binding ->
           (typ list * string) option ->
             (binding * typ * mixfix) list -> theory -> theory
    val codegen: bool Config.T
    val dest_recTs: typ -> (string * typ list) list
    val eq_simproc: simproc
    val ex_sel_eq_simproc: simproc
    val extN: string
    val ext_typeN: string
    val get_extT_fields:
       theory -> typ -> (string * typ) list * (string * typ)
    val get_extension: theory -> string -> (string * typ list) option
    val get_extinjects: theory -> thm list
    val get_hierarchy:
       theory ->
         string * typ list -> (string * ((string * sort) * typ) list) list
    val get_info: theory -> string -> info option
    val get_parent: theory -> string -> (typ list * string) option
    val get_recT_fields:
       theory -> typ -> (string * typ) list * (string * typ)
    val get_simpset: theory -> simpset
    type info =
       {args: (string * sort) list,
        cases: thm,
        cases_scheme: thm,
        defs: thm list,
        equality: thm,
        ext_def: thm,
        ext_induct: thm,
        ext_inject: thm,
        ext_split: thm,
        ext_surjective: thm,
        extension: string * typ list,
        fields: (string * typ) list,
        fold_congs: thm list,
        iffs: thm list,
        induct: thm,
        induct_scheme: thm, parent: ... option, select_convs: thm list, ...}
    val last_extT: typ -> (string * typ list) option
    val pretty_recT: Proof.context -> typ -> Pretty.T
    val simproc: simproc
    val split_simp_tac:
       Proof.context -> thm list -> (term -> int) -> int -> tactic
    val split_simproc: (term -> int) -> simproc
    val split_tac: Proof.context -> int -> tactic
    val split_wrapper: string * (Proof.context -> wrapper)
    val string_of_record: Proof.context -> string -> string
    val the_info: theory -> string -> info
    val timing: bool Config.T
    val type_abbr: bool Config.T
    val type_as_fields: bool Config.T
    val upd_simproc: simproc
    val updateN: string
  end
signature ISO_TUPLE_SUPPORT =
  sig
    val add_iso_tuple_type:
       {overloaded: bool} ->
         binding * (string * sort) list ->
           typ * typ -> theory -> (term * term) * theory
    val dest_cons_tuple: term -> term * term
    val iso_tuple_intros_tac: Proof.context -> int -> tactic
    val mk_cons_tuple: term * term -> term
  end
structure Iso_Tuple_Support: ISO_TUPLE_SUPPORT
structure Record: RECORD
### theory "HOL.Record"
### 1.211s elapsed time, 2.527s cpu time, 0.287s GC time
Loading theory "HOL.Nitpick" (required by "Draft.Pairing_AxiomTemplates" via "Main" via "HOL.Nunchaku")
### ML warning (line 213 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 269 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Value identifier (compfuns) has not been referenced.
### ML warning (line 313 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Value identifier (s) has not been referenced.
### ML warning (line 315 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 327 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 350 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 377 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 398 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 598 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 669 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 793 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 802 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 808 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 842 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 836 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 1147 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 1218 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 1232 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 1269 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 1707 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Value identifier (get_pred_random_result) has not been referenced.
### ML warning (line 1729 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 1770 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 1809 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 1846 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 1858 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Matches are not exhaustive.
### ML warning (line 1923 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 1891 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
### ML warning (line 1962 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML"):
### Pattern is not exhaustive.
signature PREDICATE_COMPILE_CORE =
  sig
    val add_depth_limited_random_equations:
       options -> string list -> theory -> theory
    val add_equations: options -> string list -> theory -> theory
    val add_generator_cps_equations:
       options -> string list -> theory -> theory
    val add_generator_dseq_equations:
       options -> string list -> theory -> theory
    val add_new_random_dseq_equations:
       options -> string list -> theory -> theory
    val add_random_dseq_equations:
       options -> string list -> theory -> theory
    val code_pred: options -> string -> Proof.context -> Proof.state
    val code_pred_cmd: options -> string -> Proof.context -> Proof.state
    val code_pred_intro_attrib: attribute
    eqtype compilation
    type compilation_funs
    val head_mode_of: mode_derivation -> mode
    val mk_tracing: string -> term -> term
    eqtype mode
    type mode_analysis_options =
       {infer_pos_and_neg_modes: bool,
        reorder_premises: bool, use_generators: bool}
    datatype mode_derivation
    =
         Context of mode
       | Mode_App of mode_derivation * mode_derivation
       | Mode_Pair of mode_derivation * mode_derivation
       | Term of mode
    type moded_clause =
       term list * (Predicate_Compile_Aux.indprem * mode_derivation) list
    eqtype options
    type 'a pred_mode_table = (string * ((bool * mode) * 'a) list) list
    val prepare_intrs:
       options ->
         Proof.context ->
           string list ->
             thm list ->
               (string * typ) list * string list * string list *
               (string * mode list) list *
               (string *
                (term list * Predicate_Compile_Aux.indprem list) list
               )
               list
    val print_all_modes: compilation -> Proof.context -> unit
    val print_stored_rules: Proof.context -> unit
    val put_dseq_random_result:
       (unit ->
          Code_Numeral.natural ->
            Code_Numeral.natural ->
              seed -> term Limited_Sequence.dseq * seed)
         -> Proof.context -> Proof.context
    val put_dseq_result:
       (unit -> term Limited_Sequence.dseq) ->
         Proof.context -> Proof.context
    val put_lseq_random_result:
       (unit ->
          Code_Numeral.natural ->
            Code_Numeral.natural ->
              seed ->
                Code_Numeral.natural -> term Lazy_Sequence.lazy_sequence)
         -> Proof.context -> Proof.context
    val put_lseq_random_stats_result:
       (unit ->
          Code_Numeral.natural ->
            Code_Numeral.natural ->
              seed ->
                Code_Numeral.natural ->
                  (term * Code_Numeral.natural) Lazy_Sequence.lazy_sequence)
         -> Proof.context -> Proof.context
    val put_new_dseq_result:
       (unit -> Code_Numeral.natural -> term Lazy_Sequence.lazy_sequence) ->
         Proof.context -> Proof.context
    val put_pred_random_result:
       (unit -> seed -> term Predicate.pred * seed) ->
         Proof.context -> Proof.context
    val put_pred_result:
       (unit -> term Predicate.pred) -> Proof.context -> Proof.context
    type seed = Random_Engine.seed
    val values_cmd:
       string list ->
         mode option list option ->
           (string option * bool) * (compilation * int list) ->
             int -> string -> Toplevel.state -> unit
    val values_timeout: real Config.T
  end
structure Predicate_Compile_Core: PREDICATE_COMPILE_CORE
### ML warning (line 66 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_data.ML"):
### Pattern is not exhaustive.
### ML warning (line 138 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_data.ML"):
### Pattern is not exhaustive.
signature PREDICATE_COMPILE_DATA =
  sig
    val get_specification:
       Predicate_Compile_Aux.options -> theory -> term -> thm list
    val ignore_consts: string list -> theory -> theory
    val keep_function: theory -> string -> bool
    val keep_functions: string list -> theory -> theory
    val normalize_equation: theory -> thm -> thm
    val obtain_specification_graph:
       Predicate_Compile_Aux.options ->
         theory -> term -> thm list Term_Graph.T
    val processed_specs: theory -> string -> (string * thm list) list option
    val store_processed_specs:
       string * (string * thm list) list -> theory -> theory
  end
structure Predicate_Compile_Data: PREDICATE_COMPILE_DATA
### ML warning (line 161 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 148 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 173 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 182 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 173 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 182 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Pattern is not exhaustive.
### ML warning (line 138 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Matches are not exhaustive.
### ML warning (line 288 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Matches are not exhaustive.
### ML warning (line 303 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_fun.ML"):
### Matches are not exhaustive.
signature PREDICATE_COMPILE_FUN =
  sig
    val add_function_predicate_translation: term * term -> theory -> theory
    val define_predicates:
       (string * thm list) list ->
         theory -> (string * thm list) list * theory
    val pred_of_function: theory -> string -> string option
    val rewrite_intro: theory -> thm -> thm list
  end
structure Predicate_Compile_Fun: PREDICATE_COMPILE_FUN
### ML warning (line 40 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_pred.ML"):
### Pattern is not exhaustive.
### ML warning (line 65 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_pred.ML"):
### Pattern is not exhaustive.
### ML warning (line 89 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_pred.ML"):
### Pattern is not exhaustive.
### ML warning (line 160 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_pred.ML"):
### Pattern is not exhaustive.
### ML warning (line 243 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_pred.ML"):
### Pattern is not exhaustive.
### ML warning (line 281 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_pred.ML"):
### Value identifier (f) has not been referenced.
signature PREDICATE_COMPILE_PRED =
  sig
    val flat_higher_order_arguments:
       (string * thm list) list * theory ->
         (string * thm list) list * ((string * thm list) list * theory)
    val preprocess:
       Predicate_Compile_Aux.options ->
         string * thm list -> theory -> (string * thm list) list * theory
  end
structure Predicate_Compile_Pred: PREDICATE_COMPILE_PRED
### ML warning (line 99 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_specialisation.ML"):
### Pattern is not exhaustive.
### ML warning (line 104 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_specialisation.ML"):
### Pattern is not exhaustive.
### ML warning (line 128 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_specialisation.ML"):
### Value identifier (thy) has not been referenced.
### ML warning (line 142 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_specialisation.ML"):
### Matches are not exhaustive.
### ML warning (line 128 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile_specialisation.ML"):
### Matches are not exhaustive.
signature PREDICATE_COMPILE_SPECIALISATION =
  sig
    val find_specialisations:
       string list ->
         (string * thm list) list ->
           theory -> (string * thm list) list * theory
  end
structure Predicate_Compile_Specialisation: PREDICATE_COMPILE_SPECIALISATION
### ML warning (line 83 of "~~/src/HOL/Tools/Predicate_Compile/predicate_compile.ML"):
### Matches are not exhaustive.
signature PREDICATE_COMPILE =
  sig
    val intro_hook: (theory -> thm -> unit) option ref
    val preprocess:
       Predicate_Compile_Aux.options -> term -> theory -> theory
  end
structure Predicate_Compile: PREDICATE_COMPILE
### theory "HOL.Predicate_Compile"
### 1.845s elapsed time, 3.813s cpu time, 0.335s GC time
Loading theory "HOL.Mirabelle" (required by "Draft.Pairing_AxiomTemplates" via "Main")
Proofs for inductive predicate(s) "fold_graph'"
  Proving monotonicity ...
### ML warning (line 96 of "~~/src/HOL/Tools/Mirabelle/mirabelle.ML"):
### Handler catches all exceptions.
signature MIRABELLE =
  sig
    type action = {finalize: unit -> string, run_action: command -> string}
    type action_context =
       {arguments: Properties.T,
        index: int,
        label: string, name: string, output_dir: Path.T, timeout: Time.time}
    val can_apply:
       Time.time -> (Proof.context -> int -> tactic) -> Proof.state -> bool
    type command =
       {name: string,
        pos: Position.T,
        post: Toplevel.state, pre: Proof.state, theory_index: int}
    val cpu_time: ('a -> 'b) -> 'a -> 'b * int
    val get_argument: (string * string) list -> string * string -> string
    val get_bool_argument: (string * string) list -> string * bool -> bool
    val get_int_argument: (string * string) list -> string * int -> int
    val print_exn: exn -> string
    val register_action: string -> (action_context -> action) -> unit
    val theorems_in_proof_term: theory -> thm -> thm list
    val theorems_of_sucessful_proof: Toplevel.state -> thm list
  end
structure Mirabelle: MIRABELLE
signature MIRABELLE_ACTION =
  sig val make_action: Mirabelle.action_context -> Mirabelle.action end
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### Redefining Mirabelle action: "arith"
structure Mirabelle_Arith: MIRABELLE_ACTION
### Redefining Mirabelle action: "metis"
structure Mirabelle_Metis: MIRABELLE_ACTION
### Redefining Mirabelle action: "presburger"
structure Mirabelle_Presburger: MIRABELLE_ACTION
### Redefining Mirabelle action: "quickcheck"
structure Mirabelle_Quickcheck: MIRABELLE_ACTION
### Redefining Mirabelle action: "sledgehammer_filter"
structure Mirabelle_Sledgehammer_Filter: MIRABELLE_ACTION
### Redefining Mirabelle action: "sledgehammer"
structure Mirabelle_Sledgehammer: MIRABELLE_ACTION
### Redefining Mirabelle action: "try0"
structure Mirabelle_Try0: MIRABELLE_ACTION
### theory "HOL.Mirabelle"
### 0.292s elapsed time, 0.606s cpu time, 0.056s GC time
### ML warning (line 1025 of "~~/src/HOL/Tools/Nitpick/kodkod.ML"):
### Handler catches all exceptions.
signature KODKOD =
  sig
    exception SYNTAX of string * string
    val arity_of_rel_expr: rel_expr -> int
    type bound = (n_ary_index * string) list * tuple_set list
    datatype decl
    =
         DeclLone of n_ary_index * rel_expr
       | DeclNo of n_ary_index * rel_expr
       | DeclOne of n_ary_index * rel_expr
       | DeclSet of n_ary_index * rel_expr
       | DeclSome of n_ary_index * rel_expr
    datatype expr_assign
    =
         AssignFormulaReg of int * formula
       | AssignIntReg of int * int_expr
       | AssignRelReg of n_ary_index * rel_expr
    val fold_bound:
       'a fold_expr_funcs -> 'a fold_tuple_funcs -> bound -> 'a -> 'a
    val fold_decl: 'a fold_expr_funcs -> decl -> 'a -> 'a
    val fold_expr_assign: 'a fold_expr_funcs -> expr_assign -> 'a -> 'a
    type 'a fold_expr_funcs =
       {formula_func: formula -> 'a -> 'a,
        int_expr_func: int_expr -> 'a -> 'a,
        rel_expr_func: rel_expr -> 'a -> 'a}
    val fold_formula: 'a fold_expr_funcs -> formula -> 'a -> 'a
    val fold_int_bound: 'a fold_tuple_funcs -> int_bound -> 'a -> 'a
    val fold_int_expr: 'a fold_expr_funcs -> int_expr -> 'a -> 'a
    val fold_rel_expr: 'a fold_expr_funcs -> rel_expr -> 'a -> 'a
    val fold_tuple: 'a fold_tuple_funcs -> tuple -> 'a -> 'a
    val fold_tuple_assign: 'a fold_tuple_funcs -> tuple_assign -> 'a -> 'a
    type 'a fold_tuple_funcs =
       {tuple_func: tuple -> 'a -> 'a,
        tuple_set_func: tuple_set -> 'a -> 'a}
    val fold_tuple_set: 'a fold_tuple_funcs -> tuple_set -> 'a -> 'a
    datatype formula
    =
         Acyclic of n_ary_index
       | All of decl list * formula
       | And of formula * formula
       | Exist of decl list * formula
       | False
       | FormulaIf of formula * formula * formula
       | FormulaLet of expr_assign list * formula
       | FormulaReg of int
       | Function of n_ary_index * rel_expr * rel_expr
       | Functional of n_ary_index * rel_expr * rel_expr
       | Iff of formula * formula
       | Implies of formula * formula
       | IntEq of int_expr * int_expr
       | LE of int_expr * int_expr
       | LT of int_expr * int_expr
       | Lone of rel_expr
       | No of rel_expr
       | Not of formula
       | One of rel_expr
       | ...
    type int_bound = int option * tuple_set list
    datatype int_expr
    =
         Absolute of int_expr
       | Add of int_expr * int_expr
       | BitAnd of int_expr * int_expr
       | BitNot of int_expr
       | BitOr of int_expr * int_expr
       | BitXor of int_expr * int_expr
       | Cardinality of rel_expr
       | Div of int_expr * int_expr
       | IntIf of formula * int_expr * int_expr
       | IntLet of expr_assign list * int_expr
       | IntReg of int
       | Mod of int_expr * int_expr
       | Mult of int_expr * int_expr
       | Neg of int_expr
       | Num of int
       | SHA of int_expr * int_expr
       | SHL of int_expr * int_expr
       | SHR of int_expr * int_expr
       | SetSum of rel_expr
       | ...
    val is_problem_trivially_false: problem -> bool
    val kodkod_scala: bool Config.T
    val max_arity: int -> int
    type n_ary_index = int * int
    datatype outcome
    =
         Error of string * int list
       | Normal of (int * raw_bound list) list * int list * string
       | TimedOut of int list
    type problem =
       {bounds: bound list,
        comment: string,
        expr_assigns: expr_assign list,
        formula: formula,
        int_bounds: int_bound list,
        settings: setting list,
        tuple_assigns: tuple_assign list, univ_card: int}
    val problems_equivalent: problem * problem -> bool
    type raw_bound = n_ary_index * int list list
    datatype rel_expr
    =
         Atom of int
       | AtomSeq of int * int
       | Bits of int_expr
       | Closure of rel_expr
       | Comprehension of decl list * formula
       | Difference of rel_expr * rel_expr
       | Iden
       | IfNo of rel_expr * rel_expr
       | Int of int_expr
       | Intersect of rel_expr * rel_expr
       | Ints
       | Join of rel_expr * rel_expr
       | None
       | Override of rel_expr * rel_expr
       | Product of rel_expr * rel_expr
       | Project of rel_expr * int_expr list
       | ReflexiveClosure of rel_expr
       | Rel of n_ary_index
       | RelIf of ...
       | ...
    type setting = string * string
    val solve_any_problem:
       bool ->
         bool -> bool -> Time.time -> int -> int -> problem list -> outcome
    datatype tuple
    =
         Tuple of int list
       | TupleIndex of n_ary_index
       | TupleReg of n_ary_index
    datatype tuple_assign
    =
         AssignTuple of n_ary_index * tuple
       | AssignTupleSet of n_ary_index * tuple_set
    datatype tuple_set
    =
         TupleArea of tuple * tuple
       | TupleAtomSeq of int * int
       | TupleDifference of tuple_set * tuple_set
       | TupleIntersect of tuple_set * tuple_set
       | TupleProduct of tuple_set * tuple_set
       | TupleProject of tuple_set * int
       | TupleRange of tuple * tuple
       | TupleSet of tuple list
       | TupleSetReg of n_ary_index
       | TupleUnion of tuple_set * tuple_set
  end
structure Kodkod: KODKOD
signature KODKOD_SAT =
  sig
    val configured_sat_solvers: bool -> string list
    val sat_solver_spec: string -> string * string list
    val smart_sat_solver_name: bool -> string
  end
structure Kodkod_SAT: KODKOD_SAT
signature NITPICK_UTIL =
  sig
    exception ARG of string * string
    exception BAD of string * string
    val DETERM_TIMEOUT: Time.time -> tactic -> tactic
    exception NOT_SUPPORTED of string
    exception SAME of unit
    exception TOO_LARGE of string * string
    exception TOO_SMALL of string * string
    val all_combinations: (int * int) list -> int list list
    val all_distinct_unordered_pairs_of: ''a list -> (''a * ''a) list
    val all_permutations: 'a list -> 'a list list
    val bool_T: typ
    val chunk_list: int -> 'a list -> 'a list list
    val chunk_list_unevenly: int list -> 'a list -> 'a list list
    val curry3: ('a * 'b * 'c -> 'd) -> 'a -> 'b -> 'c -> 'd
    val double_lookup:
       ('a * 'a -> bool) -> ('a option * 'b) list -> 'a -> 'b option
    val eta_expand: typ list -> term -> int -> term
    val exact_log: int -> int -> int
    val exact_root: int -> int -> int
    val filter_indices: int list -> 'a list -> 'a list
    val filter_out_indices: int list -> 'a list -> 'a list
    val flip_polarity: polarity -> polarity
    val fold1: ('a -> 'a -> 'a) -> 'a list -> 'a
    val fun_from_pair: 'a * 'a -> bool -> 'a
    val get_class_def: theory -> string -> (string * term) option
    val hash_term: term -> int
    val indent_size: int
    val index_seq: int -> int -> int list
    val instantiate_type: theory -> typ -> typ -> typ -> typ
    val int_T: typ
    val int_from_bool: bool -> int
    val is_of_class_const: theory -> string * typ -> bool
    val is_substring_of: string -> string -> bool
    val n_fold_cartesian_product: 'a list list -> 'a list list
    val nat_T: typ
    val nat_minus: int -> int -> int
    val nat_subscript: int -> string
    val nitpick_prefix: string
    val nth_combination: (int * int) list -> int -> int list
    val num_binder_types: typ -> int
    val offset_list: int list -> int list
    val pair_from_fun: (bool -> 'a) -> 'a * 'a
    val pairf: ('a -> 'b) -> ('a -> 'c) -> 'a -> 'b * 'c
    val parse_bool_option: bool -> string -> string -> bool option
    val parse_time: string -> string -> Time.time
    val plural_s: int -> string
    val plural_s_for_list: 'a list -> string
    datatype polarity = Neg | Neut | Pos
    val pretty_maybe_quote: Keyword.keywords -> Pretty.T -> Pretty.T
    val pretty_serial_commas: string -> Pretty.T list -> Pretty.T list
    val prop_T: typ
    val reasonable_power: int -> int -> int
    val replicate_list: int -> 'a list -> 'a list
    val serial_commas: string -> string list -> string list
    val simple_string_of_typ: typ -> string
    val specialize_type: theory -> string * typ -> term -> term
    val spying: bool -> (unit -> Proof.state * int * string) -> unit
    val string_of_time: Time.time -> string
    val triple_lookup:
       (''a * ''a -> bool) -> (''a option * 'b) list -> ''a -> 'b option
    val varify_and_instantiate_type:
       Proof.context -> typ -> typ -> typ -> typ
    val varify_and_instantiate_type_global:
       theory -> typ -> typ -> typ -> typ
    val varify_type: Proof.context -> typ -> typ
  end
structure Nitpick_Util: NITPICK_UTIL
### ML warning (line 603 of "~~/src/HOL/Tools/Nitpick/nitpick_hol.ML"):
### Matches are not exhaustive.
### ML warning (line 1461 of "~~/src/HOL/Tools/Nitpick/nitpick_hol.ML"):
### Matches are not exhaustive.
### ML warning (line 1778 of "~~/src/HOL/Tools/Nitpick/nitpick_hol.ML"):
### Matches are not exhaustive.
### ML warning (line 1789 of "~~/src/HOL/Tools/Nitpick/nitpick_hol.ML"):
### Matches are not exhaustive.
### ML warning (line 2030 of "~~/src/HOL/Tools/Nitpick/nitpick_hol.ML"):
### Value identifier (pred_T) has not been referenced.
signature NITPICK_HOL =
  sig
    val abs_var: indexname * typ -> term -> term
    val add_simps: const_table ref -> string -> term list -> unit
    val all_defs_of: theory -> (term * term) list -> term list
    val all_nondefs_of: Proof.context -> (term * term) list -> term list
    val arity_of_built_in_const: string * typ -> int option
    val base_prefix: string
    val binarize_nat_and_int_in_term: term -> term
    val binarize_nat_and_int_in_type: typ -> typ
    val binarized_and_boxed_constr_for_sel:
       hol_context -> bool -> string * typ -> string * typ
    val binarized_and_boxed_data_type_constrs:
       hol_context -> bool -> typ -> (string * typ) list
    val binarized_and_boxed_nth_sel_for_constr:
       hol_context -> bool -> string * typ -> int -> string * typ
    val bounded_card_of_type: int -> int -> (typ * int) list -> typ -> int
    val bounded_exact_card_of_type:
       hol_context ->
         typ list -> int -> int -> (typ * int) list -> typ -> int
    val box_type: hol_context -> boxability -> typ -> typ
    datatype boxability
    = InConstr | InExpr | InFunLHS | InFunRHS1 | InFunRHS2 | InPair | InSel
    val card_of_type: (typ * int) list -> typ -> int
    val case_const_names: Proof.context -> (string * int) list
    val close_form: term -> term
    val codatatype_bisim_axioms: hol_context -> typ -> term list
    val coerce_term: hol_context -> typ list -> typ -> typ -> term -> term
    val conjuncts_of: term -> term list
    val const_choice_spec_table:
       Proof.context -> (term * term) list -> const_table
    val const_def_tables:
       Proof.context ->
         (term * term) list -> term list -> const_table * const_table
    val const_for_iterator_type: typ -> string * typ
    val const_match: theory -> (string * typ) * (string * typ) -> bool
    val const_nondef_table: term list -> const_table
    val const_psimp_table:
       Proof.context -> (term * term) list -> const_table
    val const_simp_table: Proof.context -> (term * term) list -> const_table
    type const_table = term list Symtab.table
    val constr_name_for_sel_like: string -> string
    val construct_value: Proof.context -> string * typ -> term list -> term
    val curried_binder_types: typ -> typ list
    val def_of_const:
       theory -> const_table * const_table -> string * typ -> term option
    val dest_n_tuple: int -> term -> term list
    val discr_for_constr: string * typ -> string * typ
    val discriminate_value: hol_context -> string * typ -> term -> term
    val disjuncts_of: term -> term list
    val distinctness_formula: typ -> term list -> term
    val elem_type: typ -> typ
    val equational_fun_axioms: hol_context -> string * typ -> term list
    val ersatz_table: Proof.context -> (string * string) list
    val eval_prefix: string
    datatype fixpoint_kind = Gfp | Lfp | NoFp
    val fixpoint_kind_of_const:
       theory -> const_table * const_table -> string * typ -> fixpoint_kind
    val fixpoint_kind_of_rhs: term -> fixpoint_kind
    val frac_from_term_pair: typ -> term -> term -> term
    val ground_theorem_table: theory -> term list Inttab.table
    val ground_types_in_terms: hol_context -> bool -> term list -> typ list
    val ground_types_in_type: hol_context -> bool -> typ -> typ list
    type hol_context =
       {binary_ints: bool option,
        boxes: (typ option * bool option) list,
        case_names: (string * int) list,
        choice_spec_table: const_table,
        constr_cache: (typ * (string * typ) list) list ref,
        ctxt: Proof.context,
        debug: bool,
        def_tables: const_table * const_table,
        destroy_constrs: bool,
        ersatz_table: (string * string) list,
        evals: term list,
        ground_thm_table: term list Inttab.table,
        intro_table: const_table,
        max_bisim_depth: int,
        needs: term list option,
        nondef_table: const_table,
        nondefs: term list, psimp_table: const_table, ...}
    val inductive_intro_table:
       Proof.context ->
         (term * term) list -> const_table * const_table -> const_table
    val inverse_axioms_for_rep_fun:
       Proof.context -> string * typ -> term list
    val is_abs_fun: Proof.context -> string * typ -> bool
    val is_bit_type: typ -> bool
    val is_boolean_type: typ -> bool
    val is_built_in_const: string * typ -> bool
    val is_choice_spec_axiom: Proof.context -> const_table -> term -> bool
    val is_choice_spec_fun: hol_context -> string * typ -> bool
    val is_codatatype: Proof.context -> typ -> bool
    val is_constr: Proof.context -> string * typ -> bool
    val is_constr_pattern: Proof.context -> term -> bool
    val is_constr_pattern_formula: Proof.context -> term -> bool
    val is_constr_pattern_lhs: Proof.context -> term -> bool
    val is_data_type: Proof.context -> typ -> bool
    val is_equational_fun: hol_context -> string * typ -> bool
    val is_equational_fun_surely_complete:
       hol_context -> string * typ -> bool
    val is_finite_type: hol_context -> typ -> bool
    val is_fp_iterator_type: typ -> bool
    val is_free_constr: Proof.context -> string * typ -> bool
    val is_fun_or_set_type: typ -> bool
    val is_fun_type: typ -> bool
    val is_funky_typedef: Proof.context -> typ -> bool
    val is_gfp_iterator_type: typ -> bool
    val is_higher_order_type: typ -> bool
    val is_integer_like_type: typ -> bool
    val is_integer_type: typ -> bool
    val is_iterator_type: typ -> bool
    val is_lfp_iterator_type: typ -> bool
    val is_nonfree_constr: Proof.context -> string * typ -> bool
    val is_number_type: Proof.context -> typ -> bool
    val is_pair_type: typ -> bool
    val is_pure_typedef: Proof.context -> typ -> bool
    val is_quot_abs_fun: Proof.context -> string * typ -> bool
    val is_quot_rep_fun: Proof.context -> string * typ -> bool
    val is_quot_type: Proof.context -> typ -> bool
    val is_raw_equational_fun: hol_context -> string * typ -> bool
    val is_raw_inductive_pred: hol_context -> string * typ -> bool
    val is_record_get: theory -> string * typ -> bool
    val is_record_update: theory -> string * typ -> bool
    val is_rep_fun: Proof.context -> string * typ -> bool
    val is_sel: string -> bool
    val is_sel_like_and_no_discr: string -> bool
    val is_set_like_type: typ -> bool
    val is_set_type: typ -> bool
    val is_special_eligible_arg: bool -> typ list -> term -> bool
    val is_univ_typedef: Proof.context -> typ -> bool
    val is_well_founded_inductive_pred: hol_context -> string * typ -> bool
    val is_word_type: typ -> bool
    val iter_var_prefix: string
    val lbfp_prefix: string
    val mate_of_rep_fun: Proof.context -> string * typ -> string * typ
    val merge_type_vars_in_term:
       theory -> bool -> (sort * string) list -> term -> term
    val merged_type_var_table_for_terms:
       theory -> term list -> (sort * string) list
    val mk_flat_tuple: typ -> term list -> term
    val name_sep: string
    val nondef_props_for_const:
       theory -> bool -> const_table -> string * typ -> term list
    val nth_range_type: int -> typ -> typ
    val nth_sel_for_constr: string * typ -> int -> string * typ
    val nth_sel_name_for_constr_name: string -> int -> string
    val num_factors_in_type: typ -> int
    val num_sels_for_constr_type: typ -> int
    val numeral_prefix: string
    val optimized_quot_type_axioms:
       Proof.context -> string * typ list -> term list
    val optimized_typedef_axioms:
       Proof.context -> string * typ list -> term list
    val original_name: string -> string
    val prefix_name: string -> string -> string
    val pretty_for_type: Proof.context -> typ -> Pretty.T
    val pseudo_domain_type: typ -> typ
    val pseudo_range_type: typ -> typ
    val quot_normal_prefix: string
    val register_codatatype:
       typ ->
         string ->
           (string * typ) list ->
             morphism -> Context.generic -> Context.generic
    val register_codatatype_global:
       typ -> string -> (string * typ) list -> theory -> theory
    val register_ersatz:
       (string * string) list ->
         morphism -> Context.generic -> Context.generic
    val register_ersatz_global: (string * string) list -> theory -> theory
    val register_frac_type:
       string ->
         (string * string) list ->
           morphism -> Context.generic -> Context.generic
    val register_frac_type_global:
       string -> (string * string) list -> theory -> theory
    val s_betapply: typ list -> term * term -> term
    val s_betapplys: typ list -> term * term list -> term
    val s_conj: term * term -> term
    val s_disj: term * term -> term
    val s_let:
       typ list ->
         string -> int -> typ -> typ -> (term -> term) -> term -> term
    val sel_no_from_name: string -> int
    val select_nth_constr_arg:
       Proof.context -> string * typ -> term -> int -> typ -> term
    val short_name: string -> string
    val shorten_names_in_term: term -> term
    val shortest_name: string -> string
    val skolem_prefix: string
    val special_bounds: term list -> (indexname * typ) list
    type special_fun =
       ((string * typ) * int list * term list) * (string * typ)
    val special_prefix: string
    val step_prefix: string
    val strict_type_match: theory -> typ * typ -> bool
    val string_for_type: Proof.context -> typ -> string
    val strip_any_connective: term -> term list * term
    val strip_first_name_sep: string -> string * string
    val strip_n_binders: int -> typ -> typ list * typ
    val term_match: theory -> term * term -> bool
    val term_under_def: term -> term
    val type_match: theory -> typ * typ -> bool
    val typical_card_of_type: typ -> int
    val ubfp_prefix: string
    val unarize_unbox_etc_type: typ -> typ
    val uncurry_prefix: string
    val unfold_defs_in_term: hol_context -> term -> term
    val uniterize_unarize_unbox_etc_type: typ -> typ
    val unregister_codatatype:
       typ -> morphism -> Context.generic -> Context.generic
    val unregister_codatatype_global: typ -> theory -> theory
    val unregister_frac_type:
       string -> morphism -> Context.generic -> Context.generic
    val unregister_frac_type_global: string -> theory -> theory
    type unrolled = (string * typ) * (string * typ)
    val unrolled_inductive_pred_const:
       hol_context -> bool -> string * typ -> term
    val unrolled_prefix: string
    type wf_cache = ((string * typ) * (bool * bool)) list
  end
structure Nitpick_HOL: NITPICK_HOL
signature NITPICK_MONO =
  sig
    val formulas_monotonic:
       hol_context -> bool -> typ -> term list * term list -> bool
    type hol_context = Nitpick_HOL.hol_context
    val trace: bool ref
  end
structure Nitpick_Mono: NITPICK_MONO
signature NITPICK_PREPROC =
  sig
    type hol_context = Nitpick_HOL.hol_context
    val preprocess_formulas:
       hol_context ->
         term list ->
           term -> term list * term list * term list * bool * bool * bool
  end
structure Nitpick_Preproc: NITPICK_PREPROC
signature NITPICK_SCOPE =
  sig
    val all_scopes:
       hol_context ->
         bool ->
           (typ option * int list) list ->
             ((string * typ) option * int list) list ->
               ((string * typ) option * int list) list ->
                 int list ->
                   int list ->
                     typ list ->
                       typ list -> typ list -> typ list -> int * scope list
    val constr_spec: data_type_spec list -> string * typ -> constr_spec
    type constr_spec =
       {const: string * typ,
        delta: int,
        epsilon: int, exclusive: bool, explicit_max: int, total: bool}
    val data_type_spec: data_type_spec list -> typ -> data_type_spec option
    type data_type_spec =
       {card: int,
        co: bool,
        complete: bool * bool,
        concrete: bool * bool,
        constrs: constr_spec list, deep: bool, self_rec: bool, typ: typ}
    type hol_context = Nitpick_HOL.hol_context
    val is_asymmetric_non_data_type: typ -> bool
    val is_complete_type: data_type_spec list -> bool -> typ -> bool
    val is_concrete_type: data_type_spec list -> bool -> typ -> bool
    val is_exact_type: data_type_spec list -> bool -> typ -> bool
    val is_self_recursive_constr_type: typ -> bool
    val multiline_string_for_scope: scope -> string
    val offset_of_type: int Typtab.table -> typ -> int
    val pretties_for_scope: scope -> bool -> Pretty.T list
    type scope =
       {binarize: bool,
        bisim_depth: int,
        bits: int,
        card_assigns: (typ * int) list,
        data_types: data_type_spec list,
        hol_ctxt: hol_context, ofs: int Typtab.table}
    val scope_less_eq: scope -> scope -> bool
    val scopes_equivalent: scope * scope -> bool
    val spec_of_type: scope -> typ -> int * int
  end
structure Nitpick_Scope: NITPICK_SCOPE
signature NITPICK_PEEPHOLE =
  sig
    val atom_for_bool: int -> bool -> rel_expr
    val atom_for_int: int * int -> int -> int
    val atom_for_nat: int * int -> int -> int
    val atom_seq_for_suc_rel: n_ary_index -> (int * int) * bool
    eqtype decl
    val empty_n_ary_rel: int -> rel_expr
    eqtype expr_assign
    eqtype formula
    val formula_for_bool: bool -> formula
    val gcd_rel: n_ary_index
    val initial_pool: name_pool
    val inline_rel_expr: rel_expr -> bool
    val int_add_rel: n_ary_index
    val int_divide_rel: n_ary_index
    eqtype int_expr
    val int_for_atom: int * int -> int -> int
    val int_less_rel: n_ary_index
    val int_multiply_rel: n_ary_index
    val int_subtract_rel: n_ary_index
    val is_twos_complement_representable: int -> int -> bool
    val kodkod_constrs: bool -> int -> int -> int -> kodkod_constrs
    type kodkod_constrs =
       {kk_all: decl list -> formula -> formula,
        kk_and: formula -> formula -> formula,
        kk_closure: rel_expr -> rel_expr,
        kk_comprehension: decl list -> formula -> rel_expr,
        kk_difference: rel_expr -> rel_expr -> rel_expr,
        kk_exist: decl list -> formula -> formula,
        kk_formula_if: formula -> formula -> formula -> formula,
        kk_formula_let: expr_assign list -> formula -> formula,
        kk_iff: formula -> formula -> formula,
        kk_implies: formula -> formula -> formula,
        kk_int_less: rel_expr -> rel_expr -> rel_expr,
        kk_intersect: rel_expr -> rel_expr -> rel_expr,
        kk_join: rel_expr -> rel_expr -> rel_expr,
        kk_lone: rel_expr -> formula,
        kk_nat_less: rel_expr -> rel_expr -> rel_expr,
        kk_no: rel_expr -> formula,
        kk_not: formula -> formula, kk_not3: ..., ...}
    val lcm_rel: n_ary_index
    val max_int_for_card: int -> int
    val min_int_for_card: int -> int
    type n_ary_index = Kodkod.n_ary_index
    type name_pool =
       {formula_reg: int,
        rel_reg: int, rels: n_ary_index list, vars: n_ary_index list}
    val nat_add_rel: n_ary_index
    val nat_divide_rel: n_ary_index
    val nat_less_rel: n_ary_index
    val nat_multiply_rel: n_ary_index
    val nat_subtract_rel: n_ary_index
    val norm_frac_rel: n_ary_index
    val not3_rel: n_ary_index
    val num_seq: int -> int -> int_expr list
    eqtype rel_expr
    val s_and: formula -> formula -> formula
    val signed_bit_word_sel_rel: n_ary_index
    val suc_rel: n_ary_index
    val suc_rel_for_atom_seq: (int * int) * bool -> n_ary_index
    val suc_rels_base: int
    val unsigned_bit_word_sel_rel: n_ary_index
  end
structure Nitpick_Peephole: NITPICK_PEEPHOLE
signature NITPICK_REP =
  sig
    exception REP of string * rep list
    val all_combinations_for_rep: rep -> int list list
    val all_combinations_for_reps: rep list -> int list list
    val arity_of_rep: rep -> int
    val atom_schema_of_rep: rep -> (int * int) list
    val atom_schema_of_reps: rep list -> (int * int) list
    val best_non_opt_set_rep_for_type: scope -> typ -> rep
    val best_non_opt_symmetric_reps_for_fun_type: scope -> typ -> rep * rep
    val best_one_rep_for_type: scope -> typ -> rep
    val best_opt_set_rep_for_type: scope -> typ -> rep
    val best_set_rep_for_type: scope -> typ -> rep
    val binder_reps: rep -> rep list
    val body_rep: rep -> rep
    val card_of_domain_from_rep: int -> rep -> int
    val card_of_rep: rep -> int
    val dest_Func: rep -> rep * rep
    val flip_rep_polarity: rep -> rep
    val is_Func: rep -> bool
    val is_Opt: rep -> bool
    val is_lone_rep: rep -> bool
    val is_one_rep: rep -> bool
    val is_opt_rep: rep -> bool
    val lazy_range_rep:
       int Typtab.table -> typ -> (unit -> int) -> rep -> rep
    val min_rep: rep -> rep -> rep
    val min_reps: rep list -> rep list -> rep list
    val min_univ_card_of_rep: rep -> int
    val one_rep: int Typtab.table -> typ -> rep -> rep
    val opt_rep: int Typtab.table -> typ -> rep -> rep
    val optable_rep: int Typtab.table -> typ -> rep -> rep
    eqtype polarity
    datatype rep
    =
         Any
       | Atom of int * int
       | Formula of polarity
       | Func of rep * rep
       | Opt of rep
       | Struct of rep list
       | Vect of int * rep
    val rep_to_binary_rel_rep: int Typtab.table -> typ -> rep -> rep
    type scope = Nitpick_Scope.scope
    val string_for_polarity: polarity -> string
    val string_for_rep: rep -> string
    val type_schema_of_rep: typ -> rep -> typ list
    val type_schema_of_reps: typ list -> rep list -> typ list
    val unopt_rep: rep -> rep
  end
structure Nitpick_Rep: NITPICK_REP
### ML warning (line 565 of "~~/src/HOL/Tools/Nitpick/nitpick_nut.ML"):
### Value identifier (T) has not been referenced.
signature NITPICK_NUT =
  sig
    exception NUT of string * nut list
    structure NameTable: TABLE
    val add_free_and_const_names:
       nut -> nut list * nut list -> nut list * nut list
    val choose_reps_for_all_sels:
       scope -> rep NameTable.table -> nut list * rep NameTable.table
    val choose_reps_for_consts:
       scope ->
         bool ->
           nut list -> rep NameTable.table -> nut list * rep NameTable.table
    val choose_reps_for_free_vars:
       scope ->
         (string * typ) list ->
           nut list -> rep NameTable.table -> nut list * rep NameTable.table
    val choose_reps_in_nut:
       scope -> bool -> rep NameTable.table -> bool -> nut -> nut
    datatype cst
    =
         Add
       | Divide
       | False
       | Fracs
       | Gcd
       | Iden
       | IntToNat
       | Lcm
       | Multiply
       | NatToInt
       | NormFrac
       | Num of int
       | Subtract
       | Suc
       | True
       | Unknown
       | Unrep
    val fold_nut: (nut -> 'a -> 'a) -> nut -> 'a -> 'a
    type hol_context = Nitpick_HOL.hol_context
    val inline_nut: nut -> bool
    val is_Cst: cst -> nut -> bool
    val is_eval_name: nut -> bool
    val is_fully_representable_set: nut -> bool
    val is_skolem_name: nut -> bool
    val map_nut: (nut -> nut) -> nut -> nut
    val name_ord: nut ord
    type name_pool = Nitpick_Peephole.name_pool
    val nickname_of: nut -> string
    datatype nut
    =
         BoundName of int * typ * rep * string
       | BoundRel of Kodkod.n_ary_index * typ * rep * string
       | ConstName of string * typ * rep
       | Construct of nut list * typ * rep * nut list
       | Cst of cst * typ * rep
       | FormulaReg of int * typ * rep
       | FreeName of string * typ * rep
       | FreeRel of Kodkod.n_ary_index * typ * rep * string
       | Op1 of op1 * typ * rep * nut
       | Op2 of op2 * typ * rep * nut * nut
       | Op3 of op3 * typ * rep * nut * nut * nut
       | RelReg of int * typ * rep
       | Tuple of typ * rep * nut list
    val nut_from_term: hol_context -> op2 -> term -> nut
    datatype op1
    =
         Cast
       | Closure
       | Converse
       | Finite
       | First
       | IsUnknown
       | Not
       | SafeThe
       | Second
       | SingletonSet
    datatype op2
    =
         All
       | And
       | Apply
       | Composition
       | DefEq
       | Eq
       | Exist
       | Lambda
       | Less
       | Or
       | Triad
    datatype op3 = If | Let
    val rename_free_vars:
       nut list ->
         name_pool ->
           nut NameTable.table -> nut list * name_pool * nut NameTable.table
    val rename_vars_in_nut: name_pool -> nut NameTable.table -> nut -> nut
    eqtype rep
    val rep_of: nut -> rep
    type scope = Nitpick_Scope.scope
    val string_for_nut: Proof.context -> nut -> string
    val the_name: 'a NameTable.table -> nut -> 'a
    val the_rel: nut NameTable.table -> nut -> Kodkod.n_ary_index
    val type_of: nut -> typ
    val untuple: (nut -> 'a) -> nut -> 'a list
  end
structure Nitpick_Nut: NITPICK_NUT
### ML warning (line 1363 of "~~/src/HOL/Tools/Nitpick/nitpick_kodkod.ML"):
### Value identifier (to_set_bool_op) has not been referenced.
signature NITPICK_KODKOD =
  sig
    structure NameTable: TABLE
    val bound_for_plain_rel: Proof.context -> bool -> nut -> Kodkod.bound
    val bound_for_sel_rel:
       Proof.context ->
         bool ->
           (typ * (nut * int) list option) list ->
             data_type_spec list -> nut -> Kodkod.bound
    val bounds_and_axioms_for_built_in_rels_in_formulas:
       bool ->
         int ->
           int ->
             int ->
               int ->
                 Kodkod.formula list ->
                   Kodkod.bound list * Kodkod.formula list
    val check_arity: string -> int -> int -> unit
    val check_bits: int -> Kodkod.formula -> unit
    type data_type_spec = Nitpick_Scope.data_type_spec
    val declarative_axiom_for_plain_rel:
       kodkod_constrs -> nut -> Kodkod.formula
    val declarative_axioms_for_data_types:
       hol_context ->
         bool ->
           nut list ->
             (typ * (nut * int) list option) list ->
               int ->
                 int ->
                   int Typtab.table ->
                     kodkod_constrs ->
                       nut NameTable.table ->
                         data_type_spec list -> Kodkod.formula list
    type hol_context = Nitpick_HOL.hol_context
    val kk_tuple: bool -> int -> int list -> Kodkod.tuple
    type kodkod_constrs = Nitpick_Peephole.kodkod_constrs
    val kodkod_formula_from_nut:
       int Typtab.table -> kodkod_constrs -> nut -> Kodkod.formula
    val merge_bounds: Kodkod.bound list -> Kodkod.bound list
    val needed_values_for_data_type:
       nut list ->
         int Typtab.table -> data_type_spec -> (nut * int) list option
    eqtype nut
    val pow_of_two_int_bounds: int -> int -> Kodkod.int_bound list
    val sequential_int_bounds: int -> Kodkod.int_bound list
    val tuple_set_from_atom_schema: (int * int) list -> Kodkod.tuple_set
    val univ_card:
       int -> int -> int -> Kodkod.bound list -> Kodkod.formula -> int
  end
structure Nitpick_Kodkod: NITPICK_KODKOD
signature NITPICK_MODEL =
  sig
    structure NameTable: TABLE
    val dest_plain_fun: term -> bool * (term list * term list)
    val irrelevant: string
    eqtype nut
    type params = {show_consts: bool, show_skolems: bool, show_types: bool}
    val reconstruct_hol_model:
       params ->
         scope ->
           (term option * int list) list ->
             (typ option * string list) list ->
               (string * typ) list ->
                 (string * typ) list ->
                   nut list ->
                     nut list ->
                       nut list ->
                         nut NameTable.table ->
                           Kodkod.raw_bound list -> Pretty.T * bool
    val register_term_postprocessor:
       typ ->
         term_postprocessor ->
           morphism -> Context.generic -> Context.generic
    val register_term_postprocessor_global:
       typ -> term_postprocessor -> theory -> theory
    eqtype rep
    type scope = Nitpick_Scope.scope
    type term_postprocessor =
       Proof.context -> string -> (typ -> term list) -> typ -> term -> term
    val tuple_list_for_name:
       nut NameTable.table -> Kodkod.raw_bound list -> nut -> int list list
    val unknown: string
    val unregister_term_postprocessor:
       typ -> morphism -> Context.generic -> Context.generic
    val unregister_term_postprocessor_global: typ -> theory -> theory
    val unrep_mixfix: unit -> string
  end
structure Nitpick_Model: NITPICK_MODEL
### ML warning (line 170 of "~~/src/HOL/Tools/Nitpick/nitpick.ML"):
### Value identifier (j) has not been referenced.
### ML warning (line 632 of "~~/src/HOL/Tools/Nitpick/nitpick.ML"):
### Value identifier (assms_prop) has not been referenced.
### ML warning (line 806 of "~~/src/HOL/Tools/Nitpick/nitpick.ML"):
### Value identifier (j) has not been referenced.
signature NITPICK =
  sig
    val genuineN: string
    datatype mode = Auto_Try | Normal | TPTP | Try
    val noneN: string
    type params =
       {assms: bool,
        atomss: (typ option * string list) list,
        batch_size: int,
        binary_ints: bool option,
        bisim_depths: int list,
        bitss: int list,
        boxes: (typ option * bool option) list,
        cards_assigns: (typ option * int list) list,
        datatype_sym_break: int,
        debug: bool,
        destroy_constrs: bool,
        evals: term list,
        expect: string,
        falsify: bool,
        finitizes: (typ option * bool option) list,
        formats: (term option * int list) list,
        iters_assigns: ... list, kodkod_sym_break: int, ...}
    val pick_nits_in_subgoal:
       Proof.state -> params -> mode -> int -> int -> string * string list
    val pick_nits_in_term:
       Proof.state ->
         params ->
           mode ->
             int ->
               int ->
                 int ->
                   (term * term) list ->
                     term list -> term list -> term -> string * string list
    val potentialN: string
    val quasi_genuineN: string
    val register_codatatype:
       typ -> string -> (string * typ) list -> theory -> theory
    val register_frac_type:
       string -> (string * string) list -> theory -> theory
    val register_term_postprocessor:
       typ -> term_postprocessor -> theory -> theory
    type term_postprocessor = Nitpick_Model.term_postprocessor
    val unknownN: string
    val unregister_codatatype: typ -> theory -> theory
    val unregister_frac_type: string -> theory -> theory
    val unregister_term_postprocessor: typ -> theory -> theory
  end
structure Nitpick: NITPICK
signature NITPICK_COMMANDS =
  sig
    val default_params: theory -> (string * string) list -> params
    val nitpickN: string
    val nitpick_paramsN: string
    type params = Nitpick.params
  end
structure Nitpick_Commands: NITPICK_COMMANDS
signature NITPICK_TESTS = sig val run_all_tests: Proof.context -> unit end
structure Nitpick_Tests: NITPICK_TESTS
### theory "HOL.Nitpick"
### 4.052s elapsed time, 5.212s cpu time, 0.407s GC time
Loading theory "HOL.Nunchaku" (required by "Draft.Pairing_AxiomTemplates" via "Main")
signature NUNCHAKU_UTIL =
  sig
    val DETERM_TIMEOUT: Time.time -> tactic -> tactic
    val ascii_of: string -> string
    val attach_typeS: term -> term
    val const_match: theory -> (string * typ) * (string * typ) -> bool
    val double_lookup:
       ('a * 'a -> bool) -> ('a option * 'b) list -> 'a -> 'b option
    val elide_string: int -> string -> string
    val nat_subscript: int -> string
    val num_binder_types: typ -> int
    val parse_bool_option: bool -> string -> string -> bool option
    val parse_time: string -> string -> Time.time
    val plural_s_for_list: 'a list -> string
    val simplify_spaces: string -> string
    val specialize_type: theory -> string * typ -> term -> term
    val spying: bool -> (unit -> Proof.state * int * string) -> unit
    val string_of_time: Time.time -> string
    val strip_fun_type: typ -> typ list * typ
    val term_match: theory -> term * term -> bool
    val timestamp: unit -> string
    val triple_lookup:
       (''a * ''a -> bool) -> (''a option * 'b) list -> ''a -> 'b option
    val typ_match: theory -> typ * typ -> bool
    val unascii_of: string -> string
    val with_overlord_file: string -> string -> (Path.T -> 'a) -> 'a
    val with_tmp_or_overlord_file:
       bool -> string -> string -> (Path.T -> 'a) -> 'a
  end
structure Nunchaku_Util: NUNCHAKU_UTIL
### ML warning (line 127 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 138 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 256 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 263 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 283 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 301 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Pattern is not exhaustive.
### ML warning (line 300 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 321 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 336 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Pattern is not exhaustive.
### ML warning (line 342 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 337 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Pattern is not exhaustive.
### ML warning (line 333 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 358 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 366 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 374 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 382 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 521 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 581 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 584 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 610 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 637 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 643 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 645 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 648 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 649 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 650 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 670 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Pattern is not exhaustive.
### ML warning (line 743 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Pattern is not exhaustive.
### ML warning (line 817 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 841 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 900 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 932 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
### ML warning (line 1042 of "~~/src/HOL/Tools/Nunchaku/nunchaku_collect.ML"):
### Matches are not exhaustive.
signature NUNCHAKU_COLLECT =
  sig
    exception CYCLIC_DEPS of unit
    exception TOO_DEEP_DEPS of unit
    exception TOO_META of term
    exception UNEXPECTED_POLYMORPHISM of term
    exception UNEXPECTED_VAR of term
    exception UNSUPPORTED_FUNC of term
    val dest_co_datatype_case:
       Proof.context -> string * typ -> (string * typ) list
    type isa_co_data_spec = {ctrs: term list, typ: typ}
    datatype isa_command
    =
         IAxiom of term
       | ICoData of BNF_Util.fp_kind * isa_co_data_spec list
       | ICoPred of BNF_Util.fp_kind * bool * isa_const_spec list
       | IEval of term
       | IGoal of term
       | IQuotient of isa_type_spec
       | IRec of isa_rec_spec list
       | ISpec of isa_consts_spec
       | ITVal of typ * (int option * int option)
       | ITypedef of isa_type_spec
       | IVal of term
    type isa_const_spec = {const: term, props: term list}
    type isa_consts_spec = {consts: term list, props: term list}
    type isa_problem =
       {commandss: isa_command list list, complete: bool, sound: bool}
    val isa_problem_of_subgoal:
       Proof.context ->
         bool ->
           ((string * typ) option * bool option) list ->
             (term option * bool) list ->
               (typ option * (int option * int option)) list ->
                 bool ->
                   Time.time ->
                     term list ->
                       term list -> term -> term list * isa_problem
    type isa_rec_spec = {const: term, pat_complete: bool, props: term list}
    type isa_type_spec =
       {abs: term, abs_typ: typ, rep: term, rep_typ: typ, wrt: term}
    val pat_completes_of_isa_problem: isa_problem -> term list
    val str_of_isa_problem: Proof.context -> isa_problem -> string
  end
structure Nunchaku_Collect: NUNCHAKU_COLLECT
### ML warning (line 351 of "~~/src/HOL/Tools/Nunchaku/nunchaku_problem.ML"):
### Matches are not exhaustive.
### ML warning (line 403 of "~~/src/HOL/Tools/Nunchaku/nunchaku_problem.ML"):
### Matches are not exhaustive.
### ML warning (line 589 of "~~/src/HOL/Tools/Nunchaku/nunchaku_problem.ML"):
### Matches are not exhaustive.
signature NUNCHAKU_PROBLEM =
  sig
    val abs_tms: tm list -> tm -> tm
    val allocate_nice: name_pool -> string * string -> string * name_pool
    val dummy_ty: ty
    val encode_args: string list -> string
    val eta_expandN_tm: int -> tm -> tm
    val eta_expand_builtin_tm: tm -> tm
    val fold_map_nun_command_idents:
       (string -> 'a -> string * 'a) ->
         nun_command -> 'a -> nun_command * 'a
    val fold_map_nun_problem_idents:
       (string -> 'a -> string * 'a) ->
         nun_problem -> 'a -> nun_problem * 'a
    val fold_map_tm_idents:
       (string -> 'a -> string * 'a) -> tm -> 'a -> tm * 'a
    val fold_map_ty_idents:
       (string -> 'a -> string * 'a) -> ty -> 'a -> ty * 'a
    eqtype ident
    val ident_of_str: string -> ident
    val mk_arrow_ty: ty * ty -> ty
    val mk_arrows_ty: ty list * ty -> ty
    val nabss: tm list * tm -> tm
    type name_pool =
       {nice_of_ugly: string Symtab.table,
        ugly_of_nice: string Symtab.table}
    val napps: tm * tm list -> tm
    val nice_nun_problem: nun_problem -> nun_problem * name_pool
    val nun__witness_of: string
    val nun_abstract: string
    val nun_and: string
    val nun_arrow: string
    val nun_asserting: string
    val nun_assign: string
    val nun_at: string
    val nun_axiom: string
    val nun_bar: string
    val nun_choice: string
    type nun_co_data_spec = {ctrs: nun_ctr_spec list, ty: ty}
    val nun_codata: string
    val nun_colon: string
    val nun_comma: string
    datatype nun_command
    =
         NAxiom of tm
       | NCodata of nun_co_data_spec list
       | NCopred of nun_const_spec list
       | NCopy of nun_copy_spec
       | NData of nun_co_data_spec list
       | NEval of tm
       | NGoal of tm
       | NPred of bool * nun_const_spec list
       | NRec of nun_const_spec list
       | NSpec of nun_consts_spec
       | NTVal of ty * (int option * int option)
       | NVal of tm * ty
    val nun_concrete: string
    val nun_conj: string
    val nun_const_of_str: string list -> string -> ident
    type nun_const_spec = {const: tm, props: tm list}
    type nun_consts_spec = {consts: tm list, props: tm list}
    val nun_copred: string
    val nun_copy: string
    type nun_copy_spec =
       {abs: tm,
        abs_ty: ty,
        quotient: tm option, rep: tm, rep_ty: ty, subset: tm option}
    type nun_ctr_spec = {arg_tys: ty list, ctr: tm}
    val nun_data: string
    val nun_disj: string
    val nun_dollar: string
    val nun_dollar_anon_fun_prefix: string
    val nun_dot: string
    val nun_dummy: string
    val nun_else: string
    val nun_end: string
    val nun_equals: string
    val nun_eval: string
    val nun_exists: string
    val nun_false: string
    val nun_forall: string
    val nun_free_of_str: string -> ident
    val nun_goal: string
    val nun_hash: string
    val nun_if: string
    val nun_implies: string
    val nun_irrelevant: string
    val nun_lambda: string
    val nun_lbrace: string
    val nun_lbracket: string
    val nun_lparen: string
    val nun_match: string
    val nun_mu: string
    val nun_not: string
    val nun_partial_quotient: string
    val nun_pred: string
    type nun_problem =
       {commandss: nun_command list list, complete: bool, sound: bool}
    val nun_prop: string
    val nun_quotient: string
    val nun_rbrace: string
    val nun_rbracket: string
    val nun_rec: string
    val nun_rparen: string
    val nun_semicolon: string
    val nun_spec: string
    val nun_subset: string
    val nun_tconst_of_str: string list -> string -> ident
    val nun_tfree_of_str: string -> ident
    val nun_then: string
    val nun_true: string
    val nun_type: string
    val nun_unique: string
    val nun_unique_unsafe: string
    val nun_unparsable: string
    val nun_val: string
    val nun_var_of_str: string -> ident
    val nun_wf: string
    val nun_with: string
    val prop_ty: ty
    val rcomb_tms: tm list -> tm -> tm
    val safe_ty_of: tm -> ty
    val str_of_ident: ident -> string
    val str_of_nun_const: ident -> string list * string
    val str_of_nun_free: ident -> string
    val str_of_nun_problem: nun_problem -> string
    val str_of_nun_tconst: ident -> string list * string
    val str_of_nun_tfree: ident -> string
    val str_of_nun_var: ident -> string
    val str_of_tm: tm -> string
    val str_of_tmty: tm -> string
    val str_of_ty: ty -> string
    datatype tm
    =
         NAbs of tm * tm
       | NApp of tm * tm
       | NAtom of int * ty
       | NConst of ident * ty list * ty
       | NMatch of tm * (ident * tm list * tm) list
    datatype ty = NType of ident * ty list
    val ty_of: tm -> ty
  end
structure Nunchaku_Problem: NUNCHAKU_PROBLEM
### ML warning (line 35 of "~~/src/HOL/Tools/Nunchaku/nunchaku_translate.ML"):
### Matches are not exhaustive.
### ML warning (line 90 of "~~/src/HOL/Tools/Nunchaku/nunchaku_translate.ML"):
### Pattern is not exhaustive.
signature NUNCHAKU_TRANSLATE =
  sig
    val flip_quote: string -> string
    type isa_problem = Nunchaku_Collect.isa_problem
    val lowlevel_str_of_ty: ty -> string
    type nun_problem = Nunchaku_Problem.nun_problem
    val nun_problem_of_isa: Proof.context -> isa_problem -> nun_problem
    eqtype ty
  end
structure Nunchaku_Translate: NUNCHAKU_TRANSLATE
### ML warning (line 186 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
### ML warning (line 189 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
### ML warning (line 197 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
### ML warning (line 207 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
### ML warning (line 225 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
### ML warning (line 229 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
### ML warning (line 233 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
### ML warning (line 241 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
### ML warning (line 269 of "~~/src/HOL/Tools/Nunchaku/nunchaku_model.ML"):
### Matches are not exhaustive.
signature NUNCHAKU_MODEL =
  sig
    val allocate_ugly: name_pool -> string * string -> string * name_pool
    eqtype ident
    type name_pool = Nunchaku_Problem.name_pool
    type nun_model =
       {auxiliary_model: tm_entry list,
        const_model: tm_entry list,
        skolem_model: tm_entry list, type_model: ty_entry list}
    val nun_model_of_str: string -> nun_model
    val parse_atom: token list -> (ident * int) * token list
    val parse_id: ident -> token list -> token * token list
    val parse_ident: token list -> ident * token list
    val parse_sym: ident -> token list -> token * token list
    val parse_tok: ''a -> ''a list -> ''a * ''a list
    val str_of_nun_model: nun_model -> string
    eqtype tm
    type tm_entry = tm * tm
    datatype token
    = Atom of ident * int | End_of_Stream | Ident of ident | Symbol of ident
    eqtype ty
    type ty_entry = ty * tm list
    val ugly_nun_model: name_pool -> nun_model -> nun_model
  end
structure Nunchaku_Model: NUNCHAKU_MODEL
### ML warning (line 218 of "~~/src/HOL/Tools/Nunchaku/nunchaku_reconstruct.ML"):
### Pattern is not exhaustive.
### ML warning (line 267 of "~~/src/HOL/Tools/Nunchaku/nunchaku_reconstruct.ML"):
### Matches are not exhaustive.
signature NUNCHAKU_RECONSTRUCT =
  sig
    val clean_up_isa_model: Proof.context -> isa_model -> isa_model
    type isa_model =
       {auxiliary_model: term_entry list,
        free_model: term_entry list,
        pat_complete_model: term_entry list,
        pat_incomplete_model: term_entry list,
        skolem_model: term_entry list, type_model: typ_entry list}
    val isa_model_of_nun:
       Proof.context ->
         term list ->
           (typ option * string list) list -> nun_model -> isa_model
    type nun_model = Nunchaku_Model.nun_model
    val str_of_isa_model: Proof.context -> isa_model -> string
    type term_entry = term * term
    type typ_entry = typ * term list
  end
structure Nunchaku_Reconstruct: NUNCHAKU_RECONSTRUCT
signature NUNCHAKU_DISPLAY =
  sig
    type isa_model = Nunchaku_Reconstruct.isa_model
    val pretty_of_isa_model_opt:
       Proof.context -> isa_model option -> Pretty.T
  end
structure Nunchaku_Display: NUNCHAKU_DISPLAY
### ML warning (line 135 of "~~/src/HOL/Tools/Nunchaku/nunchaku_tool.ML"):
### Value identifier (solvers) has not been referenced.
signature NUNCHAKU_TOOL =
  sig
    datatype nun_outcome
    =
         CVC4_Cannot_Execute
       | CVC4_Not_Found
       | Nunchaku_Cannot_Execute
       | Nunchaku_Not_Found
       | Nunchaku_Var_Not_Set
       | Sat of string * string * nun_solution
       | Timeout
       | Unknown of (string * string * nun_solution) option
       | Unknown_Error of int * string
       | Unsat of string
    type nun_problem = Nunchaku_Problem.nun_problem
    type nun_solution = {tms: (tm * tm) list, tys: (ty * tm list) list}
    val nunchaku_home_env_var: string
    val solve_nun_problem: tool_params -> nun_problem -> nun_outcome
    eqtype tm
    type tool_params =
       {bound_increment: int,
        debug: bool,
        max_bound: int option,
        min_bound: int,
        overlord: bool,
        solvers: string list, specialize: bool, timeout: Time.time}
    eqtype ty
  end
structure Nunchaku_Tool: NUNCHAKU_TOOL
signature NUNCHAKU =
  sig
    val genuineN: string
    type isa_model = Nunchaku_Reconstruct.isa_model
    datatype mode = Auto_Try | Normal | Try
    type mode_of_operation_params =
       {assms: bool,
        expect: string,
        falsify: bool, overlord: bool, solvers: string list, spy: bool}
    val no_nunchakuN: string
    val noneN: string
    type optimization_params = {multithread: bool, specialize: bool}
    type output_format_params =
       {atomss: (typ option * string list) list,
        debug: bool,
        evals: term list,
        max_genuine: int, max_potential: int, verbose: bool}
    type params =
       {mode_of_operation_params: mode_of_operation_params,
        optimization_params: optimization_params,
        output_format_params: output_format_params,
        scope_of_search_params: scope_of_search_params,
        timeout_params: timeout_params}
    val potentialN: string
    val quasi_genuineN: string
    val run_chaku_on_prop:
       Proof.state ->
         params ->
           mode -> int -> term list -> term -> string * isa_model option
    val run_chaku_on_subgoal:
       Proof.state -> params -> mode -> int -> string * isa_model option
    type scope_of_search_params =
       {bound_increment: int,
        cards: (typ option * (int option * int option)) list,
        max_bound: int option,
        min_bound: int,
        monos: (typ option * bool option) list,
        wfs: ((string * typ) option * bool option) list,
        whacks: (term option * bool) list}
    type timeout_params = {timeout: Time.time, wf_timeout: Time.time}
    val unknownN: string
  end
structure Nunchaku: NUNCHAKU
signature NUNCHAKU_COMMANDS =
  sig
    val default_params: theory -> (string * string) list -> params
    type params = Nunchaku.params
  end
structure Nunchaku_Commands: NUNCHAKU_COMMANDS
### theory "HOL.Nunchaku"
### 0.691s elapsed time, 0.716s cpu time, 0.032s GC time
Loading theory "Main" (required by "Draft.Pairing_AxiomTemplates")
bundle cardinal_syntax
bundle lattice_syntax
bundle no_lattice_syntax
### theory "Main"
### 1.338s elapsed time, 1.387s cpu time, 0.055s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Tree" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.120s elapsed time, 0.472s cpu time, 0.066s GC time
Loading theory "HOL.Archimedean_Field" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series" via "HOL.Limits" via "HOL.Real_Vector_Spaces" via "HOL.Real" via "HOL.Rat")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Set_Algebras"
### 0.249s elapsed time, 0.985s cpu time, 0.066s GC time
Loading theory "HOL.Hull" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series" via "HOL.Limits" via "HOL.Real_Vector_Spaces" via "HOL.Vector_Spaces" via "HOL.Modules")
### theory "HOL-Library.Nat_Bijection"
### 0.338s elapsed time, 1.326s cpu time, 0.199s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs")
### theory "HOL.Hull"
### 0.102s elapsed time, 0.396s cpu time, 0.133s GC time
Loading theory "HOL.Modules" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series" via "HOL.Limits" via "HOL.Real_Vector_Spaces" via "HOL.Vector_Spaces")
locale additive
  fixes f :: "'a => 'b"
  assumes "additive f"
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
locale module_hom
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
    and f :: "'b => 'c"
  assumes "module_hom (*a) (*b) f"
consts
  shift :: "'a list => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
locale module_pair
  fixes s1 :: "'a => 'b => 'b"
    and s2 :: "'a => 'c => 'c"
  assumes "module_pair s1 s2"
Found termination order: "size <*mlex*> {}"
locale module
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "module (*s)"
consts
  snth :: "'a stream => nat => 'a"
### theory "HOL.Modules"
### 0.506s elapsed time, 2.010s cpu time, 0.192s GC time
Loading theory "HOL.Vector_Spaces" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series" via "HOL.Limits" via "HOL.Real_Vector_Spaces")
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
locale vector_space
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "vector_space (*s)"
Found termination order: "size <*mlex*> {}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
locale linear
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
    and f :: "'b => 'c"
  assumes "linear (*a) (*b) f"
locale vector_space
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
  assumes "vector_space (*s)"
consts
  cycle :: "'a list => 'a stream"
### Cannot skip proof of schematic goal statement
Found termination order: "size <*mlex*> {}"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 0.882s elapsed time, 3.479s cpu time, 0.400s GC time
Loading theory "HOL.Topological_Spaces" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series" via "HOL.Limits" via "HOL.Real_Vector_Spaces")
Found termination order: "size <*mlex*> {}"
locale vector_space_pair
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
  assumes "vector_space_pair (*a) (*b)"
### Cannot skip proof of schematic goal statement
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
locale finite_dimensional_vector_space
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
    and Basis :: "'b set"
  assumes "finite_dimensional_vector_space (*s) Basis"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
class open = type +
  fixes "open" :: "'a set => bool"
Found termination order: "size <*mlex*> {}"
class topological_space = open +
  assumes "open_UNIV": "open UNIV"
  assumes "open_Int": "!!S T. [| open S; open T |] ==> open (S Int T)"
  assumes "open_Union": "!!K. Ball K open ==> open (\<Union> K)"
locale finite_dimensional_vector_space_pair_1
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and B1 :: "'b set"
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
  assumes "finite_dimensional_vector_space_pair_1 (*a) B1 (*b)"
locale finite_dimensional_vector_space_pair
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and B1 :: "'b set"
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
    and B2 :: "'c set"
  assumes "finite_dimensional_vector_space_pair (*a) B1 (*b) B2"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
class archimedean_field = linordered_field +
  assumes "ex_le_of_int": "!!x. EX z. x <= of_int z"
locale finite_dimensional_vector_space
  fixes scale :: "'a => 'b => 'b"  (infixr \<open>*s\<close> 75)
    and Basis :: "'b set"
  assumes "finite_dimensional_vector_space (*s) Basis"
class t0_space = topological_space +
  assumes "t0_space": "!!x y. x ~= y ==> EX U. open U & (x : U) ~= (y : U)"
locale finite_dimensional_vector_space_pair
  fixes s1 :: "'a => 'b => 'b"  (infixr \<open>*a\<close> 75)
    and B1 :: "'b set"
    and s2 :: "'a => 'c => 'c"  (infixr \<open>*b\<close> 75)
    and B2 :: "'c set"
  assumes "finite_dimensional_vector_space_pair (*a) B1 (*b) B2"
class t1_space = topological_space +
  assumes "t1_space": "!!x y. x ~= y ==> EX U. open U & x : U & y ~: U"
### theory "HOL.Vector_Spaces"
### 0.943s elapsed time, 3.722s cpu time, 0.530s GC time
class t1_space = t0_space +
  assumes "t1_space": "!!x y. x ~= y ==> EX U. open U & x : U & y ~: U"
Found termination order: "size <*mlex*> {}"
class t2_space = topological_space +
  assumes
    "hausdorff":
      "!!x y.
          x ~= y ==> EX U V. open U & open V & x : U & y : V & U Int V = {}"
### theory "HOL-Library.Tree"
### 2.094s elapsed time, 8.037s cpu time, 1.001s GC time
Loading theory "Draft.Templates" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs")
class t3_space = t2_space +
  assumes
    "t3_space":
      "!!S y.
          [| closed S; y ~: S |]
          ==> EX U V. open U & open V & y : U & S <= V & U Int V = {}"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.080s elapsed time, 0.268s cpu time, 0.068s GC time
class t4_space = t2_space +
  assumes
    "t4_space":
      "!!S T.
          [| closed S; closed T; S Int T = {} |]
          ==> EX U V. open U & open V & S <= U & T <= V & U Int V = {}"
class perfect_space = topological_space +
  assumes "not_open_singleton": "!!x. ~ open {x}"
Proofs for inductive predicate(s) "generate_topology"
  Proving monotonicity ...
class order_topology = order + open +
  assumes
    "open_generated_order":
      "open = generate_topology (range lessThan Un range greaterThan)"
class floor_ceiling = archimedean_field +
  fixes floor :: "'a => int"
  assumes
    "floor_correct":
      "!!x. of_int \<lfloor>x\<rfloor> <= x &
            x < of_int (\<lfloor>x\<rfloor> + 1)"
class discrete_topology = topological_space +
  assumes "open_discrete": "!!A. open A"
### theory "HOL.Archimedean_Field"
### 3.133s elapsed time, 10.052s cpu time, 1.150s GC time
Loading theory "HOL.Rat" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series" via "HOL.Limits" via "HOL.Real_Vector_Spaces" via "HOL.Real")
instantiation
  bool :: linorder_topology
  open_bool == open :: bool set => bool
instantiation
  nat :: linorder_topology
  open_nat == open :: nat set => bool
instantiation
  int :: linorder_topology
  open_int == open :: int set => bool
instantiation
  rat :: field
  inverse_rat == inverse :: rat => rat
  divide_rat == divide :: rat => rat => rat
  uminus_rat == uminus :: rat => rat
  minus_rat == minus :: rat => rat => rat
  one_rat == one_class.one :: rat
  times_rat == times :: rat => rat => rat
  zero_rat == zero_class.zero :: rat
  plus_rat == plus :: rat => rat => rat
instantiation
  rat :: linordered_field
  sgn_rat == sgn :: rat => rat
  abs_rat == abs :: rat => rat
  less_eq_rat == less_eq :: rat => rat => bool
  less_rat == less :: rat => rat => bool
instantiation
  rat :: distrib_lattice
  inf_rat == inf :: rat => rat => rat
  sup_rat == sup :: rat => rat => rat
instantiation
  rat :: floor_ceiling
  floor_rat == floor :: rat => int
class topological_space = open +
  assumes "open_UNIV": "open UNIV"
  assumes "open_Int": "!!S T. [| open S; open T |] ==> open (S Int T)"
  assumes "open_Union": "!!K. Ball K open ==> open (\<Union> K)"
instantiation
  rat :: equal
  equal_rat == equal_class.equal :: rat => rat => bool
instantiation
  rat :: random
  random_rat == random_class.random ::
    natural
    => natural * natural => (rat * (unit => term)) * natural * natural
instantiation
  rat :: exhaustive
  exhaustive_rat == exhaustive_class.exhaustive ::
    (rat => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  rat :: full_exhaustive
  full_exhaustive_rat == full_exhaustive_class.full_exhaustive ::
    (rat * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  rat :: narrowing
  narrowing_rat == narrowing ::
    integer => rat ??.Quickcheck_Narrowing.narrowing_cons
### theory "HOL.Rat"
### 1.001s elapsed time, 2.083s cpu time, 0.182s GC time
Loading theory "HOL.Real" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series" via "HOL.Limits" via "HOL.Real_Vector_Spaces")
instantiation
  real :: field
  inverse_real == inverse :: real => real
  divide_real == divide :: real => real => real
  uminus_real == uminus :: real => real
  minus_real == minus :: real => real => real
  one_real == one_class.one :: real
  times_real == times :: real => real => real
  zero_real == zero_class.zero :: real
  plus_real == plus :: real => real => real
instantiation
  real :: linordered_field
  sgn_real == sgn :: real => real
  abs_real == abs :: real => real
  less_eq_real == less_eq :: real => real => bool
  less_real == less :: real => real => bool
instantiation
  real :: distrib_lattice
  inf_real == inf :: real => real => real
  sup_real == sup :: real => real => real
instantiation
  real :: floor_ceiling
  floor_real == floor :: real => int
instantiation
  real :: linear_continuum
  Inf_real == Inf :: real set => real
  Sup_real == Sup :: real set => real
class first_countable_topology = topological_space +
  assumes
    "first_countable_basis":
      "!!x. EX A. (ALL i. x : A i & open (A i)) &
                  (ALL S. open S & x : S --> (EX i. A i <= S))"
instantiation
  real :: equal
  equal_real == equal_class.equal :: real => real => bool
instantiation
  real :: random
  random_real == random_class.random ::
    natural
    => natural * natural => (real * (unit => term)) * natural * natural
instantiation
  real :: exhaustive
  exhaustive_real == exhaustive_class.exhaustive ::
    (real => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  real :: full_exhaustive
  full_exhaustive_real == full_exhaustive_class.full_exhaustive ::
    (real * (unit => term) => (bool * term list) option)
    => natural => (bool * term list) option
instantiation
  real :: narrowing
  narrowing_real == narrowing ::
    integer => real ??.Quickcheck_Narrowing.narrowing_cons
structure SMT_Real: sig end
structure Z3_Real: sig end
class topological_space = open +
  assumes "open_UNIV": "open UNIV"
  assumes "open_Int": "!!S T. [| open S; open T |] ==> open (S Int T)"
  assumes "open_Union": "!!K. Ball K open ==> open (\<Union> K)"
structure Argo_Real: sig end
### theory "HOL.Real"
### 1.011s elapsed time, 2.215s cpu time, 0.431s GC time
class topological_space = open +
  assumes "open_UNIV": "open UNIV"
  assumes "open_Int": "!!S T. [| open S; open T |] ==> open (S Int T)"
  assumes "open_Union": "!!K. Ball K open ==> open (\<Union> K)"
class uniformity = type +
  fixes uniformity :: "('a * 'a) filter"
class open_uniformity = open + uniformity +
  assumes
    "open_uniformity":
      "!!U. open U =
            (ALL x:U.
                \<forall>\<^sub>F (x', y) in uniformity. x' = x --> y : U)"
class uniform_space = open_uniformity +
  assumes "uniformity_refl": "!!E x. eventually E uniformity ==> E (x, x)"
    and
    "uniformity_sym":
      "!!E. eventually E uniformity ==>
            \<forall>\<^sub>F (x, y) in uniformity. E (y, x)"
    and
    "uniformity_trans":
      "!!E. eventually E uniformity ==>
            EX D. eventually D uniformity &
                  (ALL x y z. D (x, y) --> D (y, z) --> E (x, z))"
instantiation
  prod :: (topological_space, topological_space) topological_space
  open_prod == open :: ('a * 'b) set => bool
### theory "HOL.Topological_Spaces"
### 5.215s elapsed time, 11.234s cpu time, 1.421s GC time
Loading theory "HOL.Real_Vector_Spaces" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series" via "HOL.Limits")
class scaleR = type +
  fixes scaleR :: "real => 'a => 'a"
class real_vector = ab_group_add + scaleR +
  assumes
    "scaleR_add_right":
      "!!a x y. a *\<^sub>R (x + y) = a *\<^sub>R x + a *\<^sub>R y"
    and
    "scaleR_add_left":
      "!!a b x. (a + b) *\<^sub>R x = a *\<^sub>R x + b *\<^sub>R x"
    and
    "scaleR_scaleR":
      "!!a b x. a *\<^sub>R b *\<^sub>R x = (a * b) *\<^sub>R x"
    and "scaleR_one": "!!x. 1 *\<^sub>R x = x"
class real_algebra = real_vector + ring +
  assumes
    "mult_scaleR_left": "!!a x y. a *\<^sub>R x * y = a *\<^sub>R (x * y)"
    and
    "mult_scaleR_right": "!!x a y. x * a *\<^sub>R y = a *\<^sub>R (x * y)"
instantiation
  real :: real_field
  scaleR_real == scaleR :: real => real => real
locale Real_Vector_Spaces.linear
  fixes f :: "'a => 'b"
  assumes "linear f"
### Cannot skip proof of schematic goal statement
### Cannot skip proof of schematic goal statement
class ordered_real_vector = ordered_ab_group_add + real_vector +
  assumes
    "scaleR_left_mono":
      "!!x y a. [| x <= y; 0 <= a |] ==> a *\<^sub>R x <= a *\<^sub>R y"
    and
    "scaleR_right_mono":
      "!!a b x.
          [| a <= b; (0::'a) <= x |] ==> a *\<^sub>R x <= b *\<^sub>R x"
class dist = type +
  fixes dist :: "'a => 'a => real"
class norm = type +
  fixes norm :: "'a => real"
class sgn_div_norm = sgn + norm + scaleR +
  assumes "sgn_div_norm": "!!x. sgn x = x /\<^sub>R norm x"
class dist_norm = minus + dist + norm +
  assumes "dist_norm": "!!x y. dist x y = norm (x - y)"
class uniformity_dist = dist + uniformity +
  assumes
    "uniformity_dist":
      "uniformity = (INF e\<in>{0<..}. principal {(x, y). dist x y < e})"
class real_normed_vector = dist_norm + real_vector + sgn_div_norm +
  uniformity_dist + open_uniformity +
  assumes "norm_eq_zero": "!!x. (norm x = 0) = (x = (0::'a))"
    and "norm_triangle_ineq": "!!x y. norm (x + y) <= norm x + norm y"
    and
    "norm_scaleR": "!!a x. norm (a *\<^sub>R x) = \<bar>a\<bar> * norm x"
class real_normed_algebra = real_algebra + real_normed_vector +
  assumes "norm_mult_ineq": "!!x y. norm (x * y) <= norm x * norm y"
class real_normed_algebra_1 = real_algebra_1 + real_normed_algebra +
  assumes "norm_one": "norm (1::'a) = 1"
class real_normed_div_algebra = real_div_algebra + real_normed_vector +
  assumes "norm_mult": "!!x y. norm (x * y) = norm x * norm y"
class real_normed_vector = dist_norm + real_vector + sgn_div_norm +
  uniformity_dist + open_uniformity +
  assumes "norm_eq_zero": "!!x. (norm x = 0) = (x = (0::'a))"
    and "norm_triangle_ineq": "!!x y. norm (x + y) <= norm x + norm y"
    and
    "norm_scaleR": "!!a x. norm (a *\<^sub>R x) = \<bar>a\<bar> * norm x"
class metric_space = uniformity_dist + open_uniformity +
  assumes "dist_eq_0_iff": "!!x y. (dist x y = 0) = (x = y)"
    and "dist_triangle2": "!!x y z. dist x y <= dist x z + dist y z"
instantiation
  real :: real_normed_field
  norm_real == norm :: real => real
  dist_real == dist :: real => real => real
  uniformity_real == uniformity :: (real * real) filter
  open_real == open :: real set => bool
locale bounded_linear
  fixes f :: "'a => 'b"
  assumes "bounded_linear f"
locale bounded_bilinear
  fixes prod :: "'a => 'b => 'c"  (infixl \<open>**\<close> 70)
  assumes "bounded_bilinear (**)"
class complete_space = metric_space +
  assumes "Cauchy_convergent": "!!X. Cauchy X ==> convergent X"
### theory "HOL.Real_Vector_Spaces"
### 7.426s elapsed time, 8.032s cpu time, 0.816s GC time
Loading theory "HOL.Inequalities" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series")
Loading theory "HOL.Limits" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental" via "HOL.Series")
### theory "HOL.Inequalities"
### 0.041s elapsed time, 0.119s cpu time, 0.000s GC time
class topological_monoid_add = monoid_add + topological_space +
  assumes
    "tendsto_add_Pair":
      "!!a b.
          ((%x. fst x + snd x) \<longlongrightarrow> a + b)
           (nhds a \<times>\<^sub>F nhds b)"
class topological_group_add = group_add + topological_monoid_add +
  assumes
    "tendsto_uminus_nhds":
      "!!a. (uminus \<longlongrightarrow> - a) (nhds a)"
class topological_semigroup_mult = semigroup_mult + topological_space +
  assumes
    "tendsto_mult_Pair":
      "!!a b.
          ((%x. fst x * snd x) \<longlongrightarrow> a * b)
           (nhds a \<times>\<^sub>F nhds b)"
### theory "HOL.Limits"
### 5.260s elapsed time, 10.468s cpu time, 7.005s GC time
Loading theory "HOL.Deriv" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental")
Loading theory "HOL.Series" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental")
### theory "HOL.Series"
### 0.682s elapsed time, 1.423s cpu time, 0.137s GC time
### theory "HOL.Deriv"
### 1.022s elapsed time, 1.810s cpu time, 0.227s GC time
Loading theory "HOL.NthRoot" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex" via "HOL.Transcendental")
### theory "HOL.NthRoot"
### 0.246s elapsed time, 0.321s cpu time, 0.103s GC time
Loading theory "HOL.Transcendental" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main" via "HOL.Complex")
class ln = banach + real_normed_algebra_1 +
  fixes ln :: "'a => 'a"
  assumes "ln_one": "ln (1::'a) = (0::'a)"
instantiation
  real :: ln
  ln_real == ln :: real => real
### ML warning (line 7299 of "~~/src/HOL/Transcendental.thy"):
### Pattern is not exhaustive.
### ML warning (line 7316 of "~~/src/HOL/Transcendental.thy"):
### Pattern is not exhaustive.
### ML warning (line 7317 of "~~/src/HOL/Transcendental.thy"):
### Pattern is not exhaustive.
### ML warning (line 7318 of "~~/src/HOL/Transcendental.thy"):
### Pattern is not exhaustive.
### ML warning (line 7325 of "~~/src/HOL/Transcendental.thy"):
### Pattern is not exhaustive.
signature ROOT_NUMERAL_SIMPROC =
  sig
    val nth_root: int option -> int -> int -> int option
    val nth_root': int option -> int -> int -> int option
    val powr_simproc: int * int -> Proof.context -> cterm -> thm option
    val root_simproc: int * int -> Proof.context -> cterm -> thm option
    val sqrt: int option -> int -> int option
    val sqrt': int option -> int -> int option
    val sqrt_simproc: Proof.context -> cterm -> thm option
  end
structure Root_Numeral_Simproc: ROOT_NUMERAL_SIMPROC
### theory "HOL.Transcendental"
### 2.392s elapsed time, 2.803s cpu time, 0.562s GC time
Loading theory "HOL.Complex" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main")
Loading theory "HOL.MacLaurin" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO" via "Complex_Main")
### theory "HOL.MacLaurin"
### 2.010s elapsed time, 7.310s cpu time, 6.964s GC time
instantiation
  complex :: ab_group_add
  uminus_complex == uminus :: complex => complex
  zero_complex == zero_class.zero :: complex
  minus_complex == minus :: complex => complex => complex
  plus_complex == plus :: complex => complex => complex
consts
  zero_complex :: "complex"
consts
  plus_complex :: "complex => complex => complex"
consts
  uminus_complex :: "complex => complex"
consts
  minus_complex :: "complex => complex => complex"
instantiation
  complex :: field
  inverse_complex == inverse :: complex => complex
  divide_complex == divide :: complex => complex => complex
  one_complex == one_class.one :: complex
  times_complex == times :: complex => complex => complex
consts
  one_complex :: "complex"
consts
  times_complex :: "complex => complex => complex"
consts
  inverse_complex :: "complex => complex"
instantiation
  complex :: real_field
  scaleR_complex == scaleR :: real => complex => complex
consts
  scaleR_complex :: "real => complex => complex"
consts
  imaginary_unit :: "complex"
instantiation
  complex :: real_normed_field
  sgn_complex == sgn :: complex => complex
  norm_complex == norm :: complex => real
  dist_complex == dist :: complex => complex => real
  uniformity_complex == uniformity :: (complex * complex) filter
  open_complex == open :: complex set => bool
instantiation
  complex :: field_abs_sgn
  abs_complex == abs :: complex => complex
consts
  cnj :: "complex => complex"
consts
  cis :: "real => complex"
consts
  csqrt :: "complex => complex"
### theory "HOL.Complex"
### 2.761s elapsed time, 8.175s cpu time, 7.129s GC time
Loading theory "Complex_Main" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
### theory "Complex_Main"
### 0.163s elapsed time, 0.167s cpu time, 0.000s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Pairing_AxiomTemplates" via "Draft.ExtrEqs")
### theory "HOL-Library.BigO"
### 0.675s elapsed time, 0.774s cpu time, 0.133s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Pairing_AxiomTemplates")
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.561s elapsed time, 0.561s cpu time, 0.000s GC time
Loading theory "Draft.Pairing_AxiomTemplates"
*** exception THEORY raised (line 246 of "context.ML"):
*** Duplicate theory name
*** {..., ZF.Trancl, ZF.WF, ZF.Ordinal, ZF.OrdQuant, ZF.Nat}
*** {..., HOL.Ctr_Sugar, HOL.Inductive, HOL.Typedef, HOL.Rings, HOL.Nat}
*** At command "theory" (line 1 of "~/ResearchIdeas/templateAnalysis/Isabelle/GeneratedThys/DebugAFP/Forcing/Pairing_AxiomTemplates.thy")
Exception- TOPLEVEL_ERROR raised
