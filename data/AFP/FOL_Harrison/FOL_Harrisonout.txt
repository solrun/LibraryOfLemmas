Loading theory "Draft.FOL_Harrison" (required by "Draft.FOL_HarrisonMoreTemplates")
Loading theory "HOL-Library.Nat_Bijection" (required by "Draft.FOL_HarrisonMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.Stream")
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.FOL_HarrisonMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.FOL_HarrisonMoreTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
### theory "HOL-Library.Function_Algebras"
### 0.130s elapsed time, 0.531s cpu time, 0.034s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.FOL_HarrisonMoreTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "HOL-Library.Set_Algebras"
### 0.198s elapsed time, 0.803s cpu time, 0.034s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.FOL_HarrisonMoreTemplates" via "Draft.ExtrEqs")
Found termination order: "size_list size <*mlex*> {}"
### theory "HOL-Library.Nat_Bijection"
### 0.333s elapsed time, 1.324s cpu time, 0.114s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.FOL_HarrisonMoreTemplates" via "Draft.ExtrEqs")
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
Found termination order: "size <*mlex*> {}"
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
consts
  sdrop :: "nat => 'a stream => 'a stream"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
### theory "HOL-Library.BigO"
### 0.995s elapsed time, 3.765s cpu time, 0.875s GC time
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.079s elapsed time, 3.921s cpu time, 0.882s GC time
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "HOL-Library.Tree"
### 1.971s elapsed time, 6.173s cpu time, 1.101s GC time
Loading theory "Draft.Templates" (required by "Draft.FOL_HarrisonMoreTemplates" via "Draft.ExtrEqs")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.052s elapsed time, 0.104s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.FOL_HarrisonMoreTemplates")
consts
  occurs_in :: "String.literal => tm => bool"
  occurs_in_list :: "String.literal => tm list => bool"
consts
  free_in :: "String.literal => fol fm => bool"
consts
  equal_length :: "tm list => tm list => bool"
See theory exports
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.542s elapsed time, 1.129s cpu time, 0.103s GC time
See theory exports
See theory exports
consts
  semantics_term ::
    "(String.literal => 'a)
     => (String.literal => 'a list => 'a) => tm => 'a"
  semantics_list ::
    "(String.literal => 'a)
     => (String.literal => 'a list => 'a) => tm list => 'a list"
consts
  semantics ::
    "(String.literal => 'a)
     => (String.literal => 'a list => 'a)
        => (String.literal => 'a list => bool) => fol fm => bool"
Proofs for inductive predicate(s) "OK"
  Proving monotonicity ...
Warning: Value identifier (A_) has not been referenced.
At (line 38 of "generated code")
Warning: Value identifier (x22) has not been referenced.
At (line 35 of "generated code")
Warning: Value identifier (x21) has not been referenced.
At (line 35 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 35 of "generated code")
Warning: Value identifier (x22) has not been referenced.
At (line 34 of "generated code")
Warning: Value identifier (x21) has not been referenced.
At (line 34 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 34 of "generated code")
Warning: Value identifier (x1) has not been referenced.
At (line 44 of "generated code")
Warning: Value identifier (x22) has not been referenced.
At (line 44 of "generated code")
Warning: Value identifier (x21) has not been referenced.
At (line 44 of "generated code")
Warning: Value identifier (x22) has not been referenced.
At (line 43 of "generated code")
Warning: Value identifier (x21) has not been referenced.
At (line 43 of "generated code")
Warning: Value identifier (x1) has not been referenced.
At (line 43 of "generated code")
Warning: Value identifier (ys) has not been referenced.
At (line 67 of "generated code")
Warning: Value identifier (xs) has not been referenced.
At (line 66 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 69 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 72 of "generated code")
Warning: Value identifier (uv) has not been referenced.
At (line 81 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 84 of "generated code")
Warning: Value identifier (uv) has not been referenced.
At (line 87 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 86 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 213 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 212 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 197 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 196 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 195 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 195 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 194 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 194 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 193 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 193 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 193 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 192 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 192 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 192 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 191 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 191 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 191 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 190 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 190 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 190 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 189 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 189 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 189 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 188 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 188 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 188 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 187 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 187 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 187 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 186 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 186 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 186 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 185 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 185 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 184 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 184 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 183 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 183 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 183 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 182 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 182 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 182 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 181 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 181 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 181 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 180 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 180 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 180 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 179 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 179 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 178 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 178 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 177 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 177 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 177 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 176 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 176 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 176 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 175 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 175 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 175 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 174 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 174 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 174 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 173 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 173 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 173 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 172 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 172 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 172 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 171 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 171 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 171 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 170 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 170 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 170 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 169 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 169 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 168 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 168 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 167 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 167 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 167 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 166 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 166 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 166 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 165 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 165 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 165 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 164 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 164 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 164 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 163 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 163 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 163 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 163 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 162 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 162 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 162 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 162 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 161 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 161 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 161 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 161 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 160 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 160 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 160 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 160 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 159 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 159 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 159 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 159 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 158 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 158 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 158 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 158 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 157 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 157 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 157 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 157 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 156 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 156 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 156 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 156 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 155 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 155 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 155 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 154 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 154 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 154 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 153 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 153 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 153 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 153 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 152 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 152 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 152 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 152 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 151 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 151 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 151 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 151 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 150 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 150 of "generated code")
Warning: Value identifier (x3) has not been referenced.
At (line 150 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 150 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 149 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 149 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 149 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 149 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 149 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 148 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 148 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 148 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 148 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 148 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 147 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 147 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 147 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 147 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 147 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 146 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 146 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 146 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 146 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 146 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 145 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 145 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 145 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 145 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 145 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 144 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 144 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 144 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 144 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 144 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 143 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 143 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 143 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 143 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 142 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 142 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 142 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 142 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 140 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 140 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 140 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 140 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 140 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 139 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 139 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 139 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 139 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 139 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 138 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 138 of "generated code")
Warning: Value identifier (x42) has not been referenced.
At (line 138 of "generated code")
Warning: Value identifier (x41) has not been referenced.
At (line 138 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 138 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 137 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 137 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 137 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 137 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 137 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 135 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 135 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 135 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 135 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 135 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 134 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 134 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 134 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 134 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 134 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 133 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 133 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 133 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 133 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 132 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 132 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 132 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 132 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 131 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 131 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 131 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 131 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 131 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 130 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 130 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 130 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 130 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 130 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 129 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 129 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 129 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 129 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 129 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 128 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 128 of "generated code")
Warning: Value identifier (x52) has not been referenced.
At (line 128 of "generated code")
Warning: Value identifier (x51) has not been referenced.
At (line 128 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 128 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 127 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 127 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 127 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 127 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 127 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 126 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 126 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 126 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 126 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 126 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 125 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 125 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 125 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 125 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 124 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 124 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 124 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 124 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 123 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 123 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 123 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 123 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 123 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 122 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 122 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 122 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 122 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 122 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 121 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 121 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 121 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 121 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 121 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 120 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 120 of "generated code")
Warning: Value identifier (x62) has not been referenced.
At (line 120 of "generated code")
Warning: Value identifier (x61) has not been referenced.
At (line 120 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 120 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 119 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 119 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 119 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 119 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 118 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 118 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 118 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 118 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 117 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 117 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 117 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 117 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 117 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 116 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 116 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 116 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 116 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 116 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 114 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 114 of "generated code")
Warning: Value identifier (x72) has not been referenced.
At (line 114 of "generated code")
Warning: Value identifier (x71) has not been referenced.
At (line 114 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 114 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 113 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 113 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 113 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 113 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 112 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 112 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 112 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 112 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 111 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 111 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 111 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 111 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 110 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 110 of "generated code")
Warning: Value identifier (x8) has not been referenced.
At (line 110 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 110 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 109 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 109 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 109 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 109 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 109 of "generated code")
Warning: Value identifier (x102) has not been referenced.
At (line 108 of "generated code")
Warning: Value identifier (x101) has not been referenced.
At (line 108 of "generated code")
Warning: Value identifier (x92) has not been referenced.
At (line 108 of "generated code")
Warning: Value identifier (x91) has not been referenced.
At (line 108 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 108 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 246 of "generated code")
structure Proven:
  sig
    val axiom_addimp: fol fm -> fol fm -> thm
    val axiom_allimp: string -> fol fm -> fol fm -> thm
    val axiom_and: fol fm -> fol fm -> thm
    val axiom_distribimp: fol fm -> fol fm -> fol fm -> thm
    val axiom_doubleneg: fol fm -> thm
    val axiom_eqrefl: tm -> thm
    val axiom_exists: string -> fol fm -> thm
    val axiom_existseq: string -> tm -> thm
    val axiom_funcong: string -> tm list -> tm list -> thm
    val axiom_iffimp1: fol fm -> fol fm -> thm
    val axiom_iffimp2: fol fm -> fol fm -> thm
    val axiom_impall: string -> fol fm -> thm
    val axiom_impiff: fol fm -> fol fm -> thm
    val axiom_not: fol fm -> thm
    val axiom_or: fol fm -> fol fm -> thm
    val axiom_predcong: string -> tm list -> tm list -> thm
    val axiom_true: thm
    val concl: thm -> fol fm
    datatype 'a fm =
        And of 'a fm * 'a fm
      | Atom of 'a
      | Exists of string * 'a fm
      | Falsity
      | Forall of string * 'a fm
      | Iff of 'a fm * 'a fm
      | Imp of 'a fm * 'a fm
      | Not of 'a fm
      | Or of 'a fm * 'a fm
      | Truth
    datatype fol = Rl of string * tm list
    val gen: string -> thm -> thm
    val modusponens: thm -> thm -> thm
    type thm
    datatype tm = Fn of string * tm list | Var of string
  end
datatype fol = Rl of string * Proven.tm list
eqtype thm
datatype 'a fm
=
     And of 'a fm * 'a fm
   | Atom of 'a
   | Exists of string * 'a fm
   | Falsity
   | Forall of string * 'a fm
   | Iff of 'a fm * 'a fm
   | Imp of 'a fm * 'a fm
   | Not of 'a fm
   | Or of 'a fm * 'a fm
   | Truth
datatype tm = Fn of string * tm list | Var of string
constructor Imp: 'a fm * 'a fm -> 'a fm
val axiom_funcong = fn: string -> tm list -> tm list -> thm
val axiom_iffimp2 = fn: fol fm -> fol fm -> thm
constructor Forall: string * 'a fm -> 'a fm
val axiom_predcong = fn: string -> tm list -> tm list -> thm
val concl = fn: thm -> fol fm
constructor Falsity: 'a fm
val axiom_allimp = fn: string -> fol fm -> fol fm -> thm
val axiom_impiff = fn: fol fm -> fol fm -> thm
constructor Exists: string * 'a fm -> 'a fm
val axiom_iffimp1 = fn: fol fm -> fol fm -> thm
constructor Atom: 'a -> 'a fm
constructor Iff: 'a fm * 'a fm -> 'a fm
val axiom_impall = fn: string -> fol fm -> thm
constructor Truth: 'a fm
val axiom_not = fn: fol fm -> thm
val axiom_or = fn: fol fm -> fol fm -> thm
constructor Var: string -> tm
val axiom_existseq = fn: string -> tm -> thm
constructor Rl: string * tm list -> fol
constructor Fn: string * tm list -> tm
val gen = fn: string -> thm -> thm
val axiom_true = Thm (Iff (Truth, Imp (Falsity, Falsity))): thm
val axiom_exists = fn: string -> fol fm -> thm
constructor And: 'a fm * 'a fm -> 'a fm
constructor Not: 'a fm -> 'a fm
val axiom_eqrefl = fn: tm -> thm
val axiom_addimp = fn: fol fm -> fol fm -> thm
val axiom_distribimp = fn: fol fm -> fol fm -> fol fm -> thm
val axiom_doubleneg = fn: fol fm -> thm
val axiom_and = fn: fol fm -> fol fm -> thm
val modusponens = fn: thm -> thm -> thm
constructor Or: 'a fm * 'a fm -> 'a fm
val print = fn: string -> unit
val it = "format_simple.sml": string
val set_margin = fn: 'a -> unit
val print_string = fn: string -> unit
val open_box = fn: 'a -> unit
val close_box = fn: unit -> unit
val print_space = fn: unit -> unit
val print_break = fn: 'a -> 'b -> unit
val open_hbox = fn: unit -> unit
val print_flush = fn: unit -> unit
val print_newline = fn: unit -> unit
val print_int = fn: int -> unit
val open_hvbox = fn: 'a -> unit
### ML warning (line 861 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (ys) has not been referenced.
### ML warning (line 906 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (l2) has not been referenced.
### ML warning (line 948 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (time) has not been referenced.
### ML warning (line 1027 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
### ML warning (line 1031 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
### ML warning (line 1048 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (b) has not been referenced.
### ML warning (line 1108 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (y) has not been referenced.
### ML warning (line 1110 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (b) has not been referenced.
### ML warning (line 1168 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (lis) has not been referenced.
### ML warning (line 1158 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (lis) has not been referenced.
val it = "lib.sml": string
val str_ord = fn: string -> string -> int
val sip_ord = fn: string * int -> string * int -> int
infix 6 lxor
infix 6 land
val to_int_fun = fn: (word * word -> word) -> int -> int -> int
val lxor = fn: int * int -> int
val land = fn: int * int -> int
val list_hash = fn: ('a -> int) -> 'a list -> int
val str_hash = fn: string -> int
val fst = fn: 'a * 'b -> 'a
val snd = fn: 'a * 'b -> 'b
val identity = fn: 'a -> 'a
val non = fn: ('a -> bool) -> 'a -> bool
val check = fn: ('a -> bool) -> 'a -> 'a
val funpow = fn: int -> ('a -> 'a) -> 'a -> 'a
val can = fn: ('a -> 'b) -> 'a -> bool
val repeat = fn: ('a -> 'a) -> 'a -> 'a
infix 6 --
val -- = fn: int * int -> int list
val map2 = fn: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val itlist = fn: ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val end_itlist = fn: ('a -> 'a -> 'a) -> 'a list -> 'a
val itlist2 = fn: ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val zip = fn: 'a list -> 'b list -> ('a * 'b) list
val chop_list = fn: int -> 'a list -> 'a list * 'a list
val index = fn: ''a -> ''a list -> int
val unzip = fn: ('a * 'b) list -> 'a list * 'b list
val assoc = fn: ''a -> (''a * 'b) list -> 'b
val merge = fn: ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
val sort = fn: (''a -> ''a -> bool) -> ''a list -> ''a list
val increasing = fn: ('a -> int) -> 'a -> 'a -> bool
val decreasing = fn: ('a -> int) -> 'a -> 'a -> bool
val uniq = fn: ''a list -> ''a list
val tryfind = fn: ('a -> 'b) -> 'a list -> 'b
val setify = fn: (''a -> ''a -> int) -> ''a list -> ''a list
val union = fn: (''a -> ''a -> int) -> ''a list -> ''a list -> ''a list
val union_str = fn: string list -> string list -> string list
val union_sip = fn:
   (string * int) list -> (string * int) list -> (string * int) list
val subtract = fn: (''a -> ''a -> int) -> ''a list -> ''a list -> ''a list
val subtract_str = fn: string list -> string list -> string list
val insert = fn: (''a -> ''a -> int) -> ''a -> ''a list -> ''a list
val insert_str = fn: string -> string list -> string list
val unions = fn: (''a -> ''a -> int) -> ''a list list -> ''a list
val unions_str = fn: string list list -> string list
val mem = fn: ''a -> ''a list -> bool
val time = fn: ('a -> 'b) -> 'a -> 'b
datatype ('a, 'b) func
=
     Branch of int * int * ('a, 'b) func * ('a, 'b) func
   | Empty
   | Leaf of int * ('a * 'b) list
constructor Branch:
   int * int * ('a, 'b) func * ('a, 'b) func -> ('a, 'b) func
constructor Empty: ('a, 'b) func
constructor Leaf: int * ('a * 'b) list -> ('a, 'b) func
val undefined = Empty: ('a, 'b) func
val is_undefined = fn: ('a, 'b) func -> bool
val mapf = fn: ('a -> 'b) -> ('c, 'a) func -> ('c, 'b) func
val applyd = fn:
   (''a -> ''a -> int) ->
     (''a -> int) -> (''a, 'b) func -> (''a -> 'b) -> ''a -> 'b
val apply = fn:
   (''a -> ''a -> int) -> (''a -> int) -> (''a, 'b) func -> ''a -> 'b
val apply_str = fn: (string, 'a) func -> string -> 'a
val tryapplyd = fn:
   (''a -> ''a -> int) -> (''a -> int) -> (''a, 'b) func -> ''a -> 'b -> 'b
val tryapplyd_str = fn: (string, 'a) func -> string -> 'a -> 'a
val tryapplyl = fn:
   (''a -> ''a -> int) ->
     (''a -> int) -> (''a, 'b list) func -> ''a -> 'b list
val defined = fn:
   (''a -> ''a -> int) -> (''a -> int) -> (''a, 'b) func -> ''a -> bool
val defined_str = fn: (string, 'a) func -> string -> bool
val undefine = fn:
   ('a -> ''b -> int) ->
     ('a -> int) -> 'a -> (''b, ''c) func -> (''b, ''c) func
infix 6 |->
val undefine_str = fn: string -> (string, ''a) func -> (string, ''a) func
val |-> = fn:
   'a * 'b ->
     ('a, 'b) func -> ('a -> 'a -> int) -> ('a -> int) -> ('a, 'b) func
val combine = fn:
   (''a -> ''a -> int) ->
     (''b -> ''b -> ''b) ->
       (''b -> bool) ->
         (''a, ''b) func -> (''a, ''b) func -> (''a, ''b) func
infix 6 |-->
val |--> = fn: string * 'a -> (string, 'a) func -> (string, 'a) func
infix 6 |=>
val |=> = fn: 'a * 'b -> ('a -> 'a -> int) -> ('a -> int) -> ('a, 'b) func
infix 6 |==>
val |==> = fn: string * 'a -> (string, 'a) func
### ML warning (line 1255 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (c) has not been referenced.
val it = "intro.sml": string
val matches = fn: string -> char -> bool
val space = fn: char -> bool
val punctuation = fn: char -> bool
val symbolic = fn: char -> bool
val numeric = fn: char -> bool
val alphanumeric = fn: char -> bool
val lexwhile = fn: (char -> bool) -> char list -> string * char list
val lex = fn: char list -> string list
val make_parser = fn: (string list -> 'a * ''b list) -> string -> 'a
### ML warning (line 1442 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 1442 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
### ML warning (line 1440 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 1440 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
### ML warning (line 1542 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
### ML warning (line 1541 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
val it = "formulas.sml": string
val fm_ord = fn: ('a -> 'b -> int) -> 'a fm -> 'b fm -> int
val fm_pair_ord = fn:
   ('a -> 'b -> int) -> 'a fm * 'a fm -> 'b fm * 'b fm -> int
val fm_quant_ord = fn:
   ('a -> 'b -> int) -> string * 'a fm -> string * 'b fm -> int
val parse_ginfix = fn:
   ''a ->
     (('b -> 'c) -> 'b -> 'b -> 'c) ->
       ('b -> 'c) ->
         (''a list -> 'b * ''a list) -> ''a list -> 'c * ''a list
val parse_left_infix = fn:
   ''a ->
     ('b * 'b -> 'b) ->
       (''a list -> 'b * ''a list) -> ''a list -> 'b * ''a list
val parse_right_infix = fn:
   ''a ->
     ('b * 'b -> 'b) ->
       (''a list -> 'b * ''a list) -> ''a list -> 'b * ''a list
val parse_list = fn:
   ''a -> (''a list -> 'b * ''a list) -> ''a list -> 'b list * ''a list
val papply = fn: ('a -> 'b) -> 'a * 'c -> 'b * 'c
val nextin = fn: ''a list -> ''a -> bool
val parse_bracketed = fn:
   ('a -> 'b * ''c list) -> ''c -> 'a -> 'b * ''c list
val parse_atomic_formula = fn:
   (string list -> string list -> 'a fm * string list) *
   (string list -> string list -> 'a fm * string list)
     -> string list -> string list -> 'a fm * string list
val parse_quant = fn:
   (string list -> string list -> 'a fm * string list) *
   (string list -> string list -> 'a fm * string list)
     ->
     string list ->
       (string * 'a fm -> 'a fm) ->
         string -> string list -> 'a fm * string list
val parse_formula = fn:
   (string list -> string list -> 'a fm * string list) *
   (string list -> string list -> 'a fm * string list)
     -> string list -> string list -> 'a fm * string list
val bracket = fn: bool -> 'a -> ('b -> 'c -> 'd) -> 'b -> 'c -> unit
val strip_quant = fn: 'a fm -> string list * 'a fm
val print_formula_aux = fn: (int -> 'a -> unit) -> 'a fm -> unit
val print_formula = fn: (int -> 'a -> unit) -> 'a fm -> unit
val print_qformula_aux = fn: (int -> 'a -> unit) -> 'a fm -> unit
val print_qformula = fn: (int -> 'a -> unit) -> 'a fm -> unit
val mk_and = fn: 'a fm -> 'a fm -> 'a fm
val mk_or = fn: 'a fm -> 'a fm -> 'a fm
val mk_imp = fn: 'a fm -> 'a fm -> 'a fm
val mk_iff = fn: 'a fm -> 'a fm -> 'a fm
val mk_forall = fn: string -> 'a fm -> 'a fm
val mk_exists = fn: string -> 'a fm -> 'a fm
val dest_iff = fn: 'a fm -> 'a fm * 'a fm
val dest_and = fn: 'a fm -> 'a fm * 'a fm
val conjuncts = fn: 'a fm -> 'a fm list
val dest_or = fn: 'a fm -> 'a fm * 'a fm
val disjuncts = fn: 'a fm -> 'a fm list
val dest_imp = fn: 'a fm -> 'a fm * 'a fm
val antecedent = fn: 'a fm -> 'a fm
val consequent = fn: 'a fm -> 'a fm
val onatoms = fn: ('a -> 'a fm) -> 'a fm -> 'a fm
val overatoms = fn: ('a -> 'b -> 'b) -> 'a fm -> 'b -> 'b
val atom_union = fn:
   (''a -> ''a -> int) -> ('b -> ''a list) -> 'b fm -> ''a list
val atom_union_sip = fn:
   ('a -> (string * int) list) -> 'a fm -> (string * int) list
val it = "prop.sml": string
val list_conj = fn: ''a fm list -> ''a fm
### ML warning (line 1619 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (r2) has not been referenced.
### ML warning (line 1619 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (r1) has not been referenced.
### ML warning (line 1762 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (prec) has not been referenced.
### ML warning (line 1781 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (f) has not been referenced.
### ML warning (line 1789 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 1804 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
val it = "fol.sml": string
val t_ord = fn: tm -> tm -> int
val tl_ord = fn: tm list -> tm list -> int
val t_hash = fn: tm -> int
infix 6 |--->
val |---> = fn: tm * 'a -> (tm, 'a) func -> (tm, 'a) func
infix 6 |===>
val |===> = fn: tm * 'a -> (tm, 'a) func
val apply_t = fn: (tm, 'a) func -> tm -> 'a
val fol_ord = fn: fol -> fol -> int
val folfm_ord = fn: fol fm -> fol fm -> int
val union_folfm = fn: fol fm list -> fol fm list -> fol fm list
val ftp_ord = fn: fol fm * tm -> fol fm * tm -> int
val setify_ftp = fn: (fol fm * tm) list -> (fol fm * tm) list
val onformula = fn: (tm -> tm) -> fol fm -> fol fm
val is_const_name = fn: string -> bool
val parse_atomic_term = fn: string list -> string list -> tm * string list
val parse_term = fn: string list -> string list -> tm * string list
val parset = fn: string -> tm
val parse_infix_atom = fn:
   string list -> string list -> fol fm * string list
val parse_atom = fn: string list -> string list -> fol fm * string list
val parse = fn: string -> fol fm
val default_parser = fn: string -> fol fm
datatype default_parser_end = !>
constructor !> : default_parser_end
val <! = fn: string -> default_parser_end -> fol fm
val secondary_parser = fn: string -> tm
datatype secondary_parser_end = |!>
constructor |!> : secondary_parser_end
val <!| = fn: string -> secondary_parser_end -> tm
val print_term_aux = fn: int -> tm -> unit
val print_fargs_aux = fn: string -> tm list -> unit
val print_infix_term_aux = fn:
   bool -> int -> int -> string -> tm -> tm -> unit
val print_term = fn: int -> tm -> unit
val print_fargs = fn: string -> tm list -> unit
val print_infix_term = fn: bool -> int -> int -> string -> tm -> tm -> unit
val printert_aux = fn: tm -> unit
val printert = fn: tm -> unit
val print_atom_aux = fn: 'a -> fol -> unit
val print_atom = fn: 'a -> fol -> unit
val print_fol_formula_aux = fn: fol fm -> unit
val print_fol_formula = fn: fol fm -> unit
val fvt = fn: tm -> string list
val var = fn: fol fm -> string list
val fv = fn: fol fm -> string list
val tsubst = fn: (string, tm) func -> tm -> tm
val variant = fn: string -> string list -> string
val subst = fn: (string, tm) func -> fol fm -> fol fm
val substq = fn:
   (string, tm) func ->
     (string -> fol fm -> fol fm) -> string -> fol fm -> fol fm
### ML warning (line 1876 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
### ML warning (line 1880 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
val it = "skolem.sml": string
val funcs = fn: tm -> (string * int) list
val functions = fn: fol fm -> (string * int) list
### ML warning (line 1893 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (f) has not been referenced.
val it = "unif.sml": string
val istriv = fn: (string, tm) func -> string -> tm -> bool
val unify = fn: (string, tm) func -> (tm * tm) list -> (string, tm) func
val solve = fn: (string, tm) func -> (string, tm) func
val fullunify = fn: (tm * tm) list -> (string, tm) func
val unify_and_apply = fn: (tm * tm) list -> (tm * tm) list
val it = "tableaux.sml": string
val deepen = fn: (int -> 'a) -> int -> 'a
val it = "resolution.sml": string
val term_match = fn:
   (string, tm) func -> (tm * tm) list -> (string, tm) func
val it = "equal.sml": string
val mk_eq = fn: tm -> tm -> fol fm
val dest_eq = fn: fol fm -> tm * tm
val lhs = fn: fol fm -> tm
val rhs = fn: fol fm -> tm
### ML warning (line 2005 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (f) has not been referenced.
### ML warning (line 2004 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
val it = "order.sml": string
val termsize = fn: tm -> int
val it = "eqelim.sml": string
val replacet = fn: (tm, tm) func -> tm -> tm
val it = "lcf.sml": string
val print_thm_aux = fn: thm -> unit
val print_thm = fn: thm -> unit
### ML warning (line 2079 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 2119 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 2241 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Pattern is not exhaustive.
### ML warning (line 2242 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Pattern is not exhaustive.
### ML warning (line 2242 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (r') has not been referenced.
### ML warning (line 2348 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (r) has not been referenced.
### ML warning (line 2468 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (q) has not been referenced.
### ML warning (line 2468 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 2476 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
val it = "lcfprop.sml": string
val imp_refl = fn: fol fm -> thm
val imp_unduplicate = fn: thm -> thm
val negatef = fn: 'a fm -> 'a fm
val negativef = fn: 'a fm -> bool
val add_assum = fn: fol fm -> thm -> thm
val imp_add_assum = fn: fol fm -> thm -> thm
val imp_trans = fn: thm -> thm -> thm
val imp_insert = fn: fol fm -> thm -> thm
val imp_swap = fn: thm -> thm
val imp_trans_th = fn: fol fm -> fol fm -> fol fm -> thm
val imp_add_concl = fn: fol fm -> thm -> thm
val imp_swap_th = fn: fol fm -> fol fm -> fol fm -> thm
val imp_swap2 = fn: thm -> thm
val right_mp = fn: thm -> thm -> thm
val iff_imp1 = fn: thm -> thm
val iff_imp2 = fn: thm -> thm
val imp_antisym = fn: thm -> thm -> thm
val right_doubleneg = fn: thm -> thm
val ex_falso = fn: fol fm -> thm
val imp_trans2 = fn: thm -> thm -> thm
val imp_trans_chain = fn: thm list -> thm -> thm
val imp_truefalse = fn: fol fm -> fol fm -> thm
val imp_mono_th = fn: fol fm -> fol fm -> fol fm -> fol fm -> thm
val truth = Thm Truth: thm
val contrapos = fn: thm -> thm
val and_left = fn: fol fm -> fol fm -> thm
val and_right = fn: fol fm -> fol fm -> thm
val conjths = fn: fol fm -> thm list
val and_pair = fn: fol fm -> fol fm -> thm
val shunt = fn: thm -> thm
val unshunt = fn: thm -> thm
val iff_def = fn: fol fm -> fol fm -> thm
val iff_def = fn: fol fm -> fol fm -> thm
val expand_connective = fn: fol fm -> thm
val eliminate_connective = fn: fol fm -> thm
val imp_false_conseqs = fn: fol fm -> fol fm -> thm list
val imp_false_rule = fn: thm -> thm
val imp_true_rule = fn: thm -> thm -> thm
val imp_contr = fn: fol fm -> fol fm -> thm
val imp_front_th = fn: int -> fol fm -> thm
val imp_front = fn: int -> thm -> thm
val is_false = fn: 'a fm -> bool
val is_true = fn: ''a fm -> bool
val is_conj = fn: 'a fm -> bool
val dest_conj = fn: 'a fm -> 'a fm * 'a fm
val is_disj = fn: ''a fm -> bool
val dest_disj = fn: 'a fm -> 'a fm * 'a fm
val is_prop_lit = fn: 'a fm -> bool
val lcfptab = fn: fol fm list -> fol fm list -> thm
val lcftaut = fn: fol fm -> thm
### ML warning (line 2635 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 2650 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (q) has not been referenced.
### ML warning (line 2650 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
val it = "folderived.sml": string
val eq_sym = fn: tm -> tm -> thm
val eq_trans = fn: tm -> tm -> tm -> thm
val icongruence = fn: tm -> tm -> tm -> tm -> thm
val gen_right_th = fn: string -> fol fm -> fol fm -> thm
val genimp = fn: string -> thm -> thm
val gen_right = fn: string -> thm -> thm
val exists_left_th = fn: string -> fol fm -> fol fm -> thm
val exists_left = fn: string -> thm -> thm
val subspec = fn: thm -> thm
val subalpha = fn: thm -> thm
val isubst = fn: tm -> tm -> fol fm -> fol fm -> thm
val alpha = fn: string -> fol fm -> thm
val ispec = fn: tm -> fol fm -> thm
val spec = fn: tm -> thm -> thm
### ML warning (line 2761 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (i') has not been referenced.
### ML warning (line 2761 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (q') has not been referenced.
### ML warning (line 2761 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 2759 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 2782 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (s) has not been referenced.
### ML warning (line 2785 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (s) has not been referenced.
### ML warning (line 2797 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Pattern is not exhaustive.
### ML warning (line 2797 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p') has not been referenced.
### ML warning (line 2796 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 2819 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 2824 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 2886 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
### ML warning (line 2885 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (x) has not been referenced.
### ML warning (line 2897 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 2897 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (y) has not been referenced.
### ML warning (line 2897 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 2909 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (f2) has not been referenced.
### ML warning (line 2909 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (f1) has not been referenced.
### ML warning (line 2949 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 2952 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (k) has not been referenced.
### ML warning (line 2965 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (px) has not been referenced.
### ML warning (line 2966 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Pattern is not exhaustive.
### ML warning (line 2981 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (k) has not been referenced.
### ML warning (line 2986 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
val it = "lcffol.sml": string
val unify_complementsf = fn:
   (string, tm) func -> fol fm * fol fm -> (string, tm) func
val use_laterimp = fn: fol fm -> fol fm -> thm
val imp_false_rule' = fn: ('a -> thm) -> 'a -> thm
val imp_true_rule' = fn: ('a -> thm) -> ('a -> thm) -> 'a -> thm
val imp_front' = fn: int -> ('a -> thm) -> 'a -> thm
val add_assum' = fn:
   fol fm -> ((tm -> tm) * 'a -> thm) -> (tm -> tm) * 'a -> thm
val eliminate_connective' = fn:
   fol fm -> ((tm -> tm) * 'a -> thm) -> (tm -> tm) * 'a -> thm
val spec' = fn:
   tm -> fol fm -> int -> ((tm -> tm) * 'a -> thm) -> (tm -> tm) * 'a -> thm
val ex_falso' = fn: fol fm list -> (tm -> tm) * fol fm -> thm
val complits' = fn:
   fol fm list * fol fm list -> int -> (tm -> tm) * fol fm -> thm
val deskol' = fn:
   fol fm -> ((tm -> tm) * 'a -> thm) -> (tm -> tm) * 'a -> thm
val is_lit = fn: 'a fm -> bool
val is_uni = fn: 'a fm -> bool
val dest_uni = fn: 'a fm -> string * 'a fm
val is_exi = fn: 'a fm -> bool
val dest_exi = fn: 'a fm -> string * 'a fm * 'a fm
val lcftab = fn:
   (fol fm -> tm) ->
     fol fm list * fol fm list * int ->
       (((tm -> tm) * fol fm -> thm) ->
          (string, tm) func * (fol fm * tm) list * int -> 'a)
         -> (string, tm) func * (fol fm * tm) list * int -> 'a
val quantforms = fn: bool -> fol fm -> fol fm list
val skolemfuns = fn: fol fm -> (fol fm * tm) list
val form_match = fn:
   fol fm * fol fm -> (string, tm) func -> (string, tm) func
val lcfrefute = fn:
   fol fm ->
     int ->
       (((tm -> tm) * fol fm -> thm) ->
          (string, tm) func * (fol fm * tm) list * int -> 'a)
         -> 'a
val mk_skol = fn: fol fm * tm -> fol fm -> fol fm
val simpcont = fn:
   ((tm -> tm) * fol fm -> 'a) ->
     (string, tm) func * (fol fm * tm) list * 'b -> 'a
val elim_skolemvar = fn: thm -> thm
val deskolcont = fn:
   ((tm -> tm) * fol fm -> thm) ->
     (string, tm) func * (fol fm * tm) list * 'a -> thm
val lcffol = fn: fol fm -> thm
### ML warning (line 3028 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (jfn) has not been referenced.
### ML warning (line 3057 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3074 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3073 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3083 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3098 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3110 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Pattern is not exhaustive.
### ML warning (line 3120 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3128 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3137 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (jfn) has not been referenced.
### ML warning (line 3137 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (gls) has not been referenced.
### ML warning (line 3137 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (w) has not been referenced.
### ML warning (line 3137 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3154 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 3178 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (jfn) has not been referenced.
### ML warning (line 3178 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (gls) has not been referenced.
### ML warning (line 3178 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (w) has not been referenced.
### ML warning (line 3178 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 3178 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3209 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (jfn) has not been referenced.
### ML warning (line 3209 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (gls) has not been referenced.
### ML warning (line 3209 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (w) has not been referenced.
### ML warning (line 3210 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3209 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3216 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (gl) has not been referenced.
### ML warning (line 3216 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (p) has not been referenced.
### ML warning (line 3216 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (once) has not been referenced.
### ML warning (line 3223 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (asl) has not been referenced.
### ML warning (line 3223 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3232 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3243 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Pattern is not exhaustive.
### ML warning (line 3242 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3258 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (s) has not been referenced.
### ML warning (line 3272 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Pattern is not exhaustive.
### ML warning (line 3273 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3270 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3290 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3302 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (w) has not been referenced.
### ML warning (line 3302 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3317 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3330 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (jfn) has not been referenced.
### ML warning (line 3330 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (gls) has not been referenced.
### ML warning (line 3330 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (asl) has not been referenced.
### ML warning (line 3330 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (thesis) has not been referenced.
### ML warning (line 3330 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3338 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (asl) has not been referenced.
### ML warning (line 3338 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3391 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Value identifier (gl) has not been referenced.
### ML warning (line 3393 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
### ML warning (line 3391 of "$AFP/FOL_Harrison/FOL_Harrison.thy"):
### Matches are not exhaustive.
val it = "tactics.sml": string
datatype goals
= Goals of ((string * fol fm) list * fol fm) list * (thm list -> thm)
constructor Goals:
   ((string * fol fm) list * fol fm) list * (thm list -> thm) -> goals
val print_goal_aux = fn: goals -> unit
val print_goal = fn: goals -> unit
val set_goal = fn: fol fm -> goals
val extract_thm = fn: goals -> thm
val tac_proof = fn: goals -> (goals -> goals) list -> thm
val prove = fn: fol fm -> (goals -> goals) list -> thm
val conj_intro_tac = fn: goals -> goals
val jmodify = fn: ('a list -> 'b) -> ('a -> 'a) -> 'a list -> 'b
val gen_right_alpha = fn: string -> string -> thm -> thm
val forall_intro_tac = fn: string -> goals -> goals
val right_exists = fn: string -> tm -> fol fm -> thm
val exists_intro_tac = fn: tm -> goals -> goals
val imp_intro_tac = fn: string -> goals -> goals
val assumptate = fn: goals -> thm -> thm
val firstassum = fn: (''a * fol fm) list -> thm
val using = fn: thm list -> 'a -> goals -> thm list
val assumps = fn: ('a * fol fm) list -> ('a * thm) list
val by = fn: string list -> 'a -> goals -> thm list
val justify = fn:
   ('a -> fol fm -> goals -> thm list) -> 'a -> fol fm -> goals -> thm
val proof = fn: (goals -> goals) list -> fol fm -> goals -> thm list
val at = fn: 'a -> 'b -> 'c -> 'd list
val once = []: 'a list
val auto_tac = fn:
   ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val lemma_tac = fn:
   string ->
     fol fm -> ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val exists_elim_tac = fn:
   string ->
     fol fm -> ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val ante_disj = fn: thm -> thm -> thm
val disj_elim_tac = fn:
   string ->
     fol fm -> ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val multishunt = fn: int -> thm -> thm
val assume = fn: (string * fol fm) list -> goals -> goals
val note = fn:
   string * fol fm ->
     ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val have = fn:
   fol fm -> ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val so = fn:
   ('a -> ('b -> 'c -> goals -> thm list) -> 'd) ->
     'a -> ('b -> 'c -> goals -> thm list) -> 'd
val fix = fn: string -> goals -> goals
val consider = fn:
   string * fol fm ->
     ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val take = fn: tm -> goals -> goals
val cases = fn:
   fol fm -> ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val conclude = fn:
   fol fm -> ('a -> fol fm -> goals -> thm list) -> 'a -> goals -> goals
val our = fn:
   'a -> ('b -> fol fm -> goals -> thm list) -> 'b -> goals -> goals
val thesis = "": string
val qed = fn: goals -> goals
val ewd954 =
   Thm (
          Imp (And (Forall
                     ("x",
                      Forall
                       ("y",
                        Iff (Atom (Rl ("<=", [Var "x", Var "y"])),
                             Atom
                              (
                                 Rl ("=",
                                     [Fn ("*", [Var "x", Var "y"]),
Var "x"])
                                 )))),
                    Forall
                     ("x",
                      Forall
                       ("y",
                        Atom
                         (
                            Rl ("=",
                                [Fn ("f", [Fn ("*", [Var "x", Var "y"])]),
                                 Fn ("*",
                                     [Fn ("f", [Var "x"]),
Fn ("f", [Var "y"])])])
                            )))),
               Forall
                ("x",
                 Forall
                  ("y",
                   Imp (Atom (Rl ("<=", [Var "x", Var "y"])),
                        Atom
                         (
                            Rl ("<=",
                                [Fn ("f", [Var "x"]), Fn ("f", [Var "y"])])
                            )))))
          ):
   thm
val it =
   Thm (
          Imp (Exists ("x", Atom (Rl ("p", [Var "x"]))),
               Imp (Forall
                     ("x",
                      Imp (Atom (Rl ("p", [Var "x"])),
                           Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                    Exists
                     ("y",
                      Atom
                       (
                          Rl ("p",
                              [Fn ("f",
                                   [Fn ("f",
  [Fn ("f", [Fn ("f", [Var "y"])])])])])
                          ))))
          ):
   thm
val it =
   Thm (
          Imp (Exists ("x", Atom (Rl ("p", [Var "x"]))),
               Imp (Forall
                     ("x",
                      Imp (Atom (Rl ("p", [Var "x"])),
                           Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                    Exists
                     ("y",
                      Atom
                       (
                          Rl ("p",
                              [Fn ("f",
                                   [Fn ("f",
  [Fn ("f", [Fn ("f", [Var "y"])])])])])
                          ))))
          ):
   thm
val it =
   Thm (
          Imp (Atom (Rl ("p", [Var "a"])),
               Imp (Forall
                     ("x",
                      Imp (Atom (Rl ("p", [Var "x"])),
                           Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                    Exists
                     ("y",
                      And (Atom (Rl ("p", [Var "y"])),
                           Atom (Rl ("p", [Fn ("f", [Var "y"])]))))))
          ):
   thm
val it =
   Thm (
          Imp (Exists ("x", Atom (Rl ("p", [Var "x"]))),
               Imp (Forall
                     ("x",
                      Imp (Atom (Rl ("p", [Var "x"])),
                           Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                    Exists
                     ("y",
                      Atom
                       (
                          Rl ("p",
                              [Fn ("f",
                                   [Fn ("f",
  [Fn ("f", [Fn ("f", [Var "y"])])])])])
                          ))))
          ):
   thm
val it =
   Thm (
          Forall
           ("a",
            Imp (Atom (Rl ("p", [Var "a"])),
                 Imp (Forall
                       ("x",
                        Imp (Atom (Rl ("p", [Var "x"])),
                             Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                      Exists
                       ("y",
                        And (Atom (Rl ("p", [Var "y"])),
                             Atom (Rl ("p", [Fn ("f", [Var "y"])])))))))
          ):
   thm
val it =
   Thm (
          Imp (Atom (Rl ("p", [Var "c"])),
               Imp (Forall
                     ("x",
                      Imp (Atom (Rl ("p", [Var "x"])),
                           Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                    Exists
                     ("y",
                      And (Atom (Rl ("p", [Var "y"])),
                           Atom (Rl ("p", [Fn ("f", [Var "y"])]))))))
          ):
   thm
val it =
   Thm (
          Forall
           ("a",
            Imp (Atom (Rl ("p", [Var "a"])),
                 Imp (Forall
                       ("x",
                        Imp (Atom (Rl ("p", [Var "x"])),
                             Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                      Exists
                       ("y",
                        And (Atom (Rl ("p", [Var "y"])),
                             Atom (Rl ("p", [Fn ("f", [Var "y"])])))))))
          ):
   thm
val it =
   Thm (
          Forall
           ("a",
            Imp (Atom (Rl ("p", [Var "a"])),
                 Imp (Forall
                       ("x",
                        Imp (Atom (Rl ("p", [Var "x"])),
                             Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                      Exists
                       ("y",
                        And (Atom (Rl ("p", [Var "y"])),
                             Atom (Rl ("p", [Fn ("f", [Var "y"])])))))))
          ):
   thm
val it =
   Thm (
          Imp (Or (Atom (Rl ("p", [Var "a"])), Atom (Rl ("p", [Var "b"]))),
               Imp (Atom (Rl ("q", [])),
                    Exists ("y", Atom (Rl ("p", [Var "y"])))))
          ):
   thm
val it =
   Thm (
          Imp (And (Or (Atom (Rl ("p", [Var "a"])),
                        Atom (Rl ("p", [Var "b"]))),
                    Forall
                     ("x",
                      Imp (Atom (Rl ("p", [Var "x"])),
                           Atom (Rl ("p", [Fn ("f", [Var "x"])]))))),
               Exists ("y", Atom (Rl ("p", [Fn ("f", [Var "y"])]))))
          ):
   thm
val it =
   Thm (
          Imp (Exists ("x", Atom (Rl ("p", [Var "x"]))),
               Imp (Forall
                     ("x",
                      Imp (Atom (Rl ("p", [Var "x"])),
                           Atom (Rl ("p", [Fn ("f", [Var "x"])])))),
                    Exists ("y", Atom (Rl ("p", [Fn ("f", [Var "y"])])))))
          ):
   thm
val it =
   Thm (
          Imp (Forall
                ("x",
                 Imp (Atom (Rl ("p", [Var "x"])),
                      Atom (Rl ("q", [Var "x"])))),
               Imp (Forall
                     ("x",
                      Imp (Atom (Rl ("q", [Var "x"])),
                           Atom (Rl ("p", [Var "x"])))),
                    Iff (Atom (Rl ("p", [Var "a"])),
                         Atom (Rl ("q", [Var "a"])))))
          ):
   thm
val by_mp = fn: string * string -> fol fm -> goals -> thm list
val auto = fn: string -> thm
### theory "Draft.FOL_Harrison"
### 3.717s elapsed time, 8.894s cpu time, 1.311s GC time
Loading theory "Draft.FOL_HarrisonMoreTemplates"
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Imp (And (Atom (Rl ("P", [Var "x"])),
                                Forall
                                 ("y",
                                  Imp (And
  (Atom (Rl ("...", [...])), Atom (Rl ("...", [...]))),
 Atom (Rl ("G", [Var "y"]))))),
                           Atom (Rl ("G", [Var "x"])))),
                    And (Imp (Exists
                               ("x",
                                And (Atom (Rl ("P", [Var "x"])),
                                     Not (Atom (Rl ("G", [Var "x"]))))),
                              Exists
                               ("x",
                                And (Atom (Rl ("P", [Var "x"])),
                                     And
(Not (Atom (Rl ("G", [Var "..."]))),
 Forall ("y", Imp (And (..., ...), Atom ...)))))),
                         Forall
                          ("x",
                           Forall
                            ("y",
                             Imp (And (Atom (Rl ("P", [Var "x"])),
 And (Atom (Rl ("...", [...])), Atom (Rl ("...", [...])))),
                                  Not (
   Atom (Rl ("J", [Var "y", Var "x"]))
   )))))),
               Forall
                ("x",
                 Imp (Atom (Rl ("P", [Var "x"])),
                      Atom (Rl ("G", [Var "x"])))))
          ):
   thm
val it = Thm (Imp (Atom (Rl ("A", [])), Atom (Rl ("A", [])))): thm
val it =
   Thm (
          Imp (And (Forall ("x", Atom (Rl ("<=", [Var "x", Var "x"]))),
                    And (Forall
                          ("x",
                           Forall
                            ("y",
                             Forall
                              ("z",
                               Imp (And (Atom (Rl ("...", [...])),
   Atom (Rl ("...", [...]))),
                                    Atom
                                     (Rl ("<=", [Var "x", Var "..."])))))),
                         Forall
                          ("x",
                           Forall
                            ("y",
                             Iff (Atom
                                   (
Rl ("<=", [Fn ("f", [Var "x"]), Var "y"])
),
                                  Atom
                                   (
Rl ("<=", [Var "x", Fn ("g", [Var "..."])])
)))))),
               And (Forall
                     ("x",
                      Forall
                       ("y",
                        Imp (Atom (Rl ("<=", [Var "x", Var "y"])),
                             Atom
                              (
                                 Rl ("<=",
                                     [Fn ("f", [Var "x"]),
Fn ("f", [Var "y"])])
                                 )))),
                    Forall
                     ("x",
                      Forall
                       ("y",
                        Imp (Atom (Rl ("<=", [Var "x", Var "y"])),
                             Atom
                              (
                                 Rl ("<=",
                                     [Fn ("g", [Var "x"]),
Fn ("g", [Var "y"])])
                                 ))))))
          ):
   thm
val it =
   Thm (
          Exists
           ("x",
            Imp (Atom (Rl ("D", [Var "x"])),
                 Forall ("x", Atom (Rl ("D", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Imp (Forall
                ("x",
                 Imp (Not (Atom (Rl ("R", [Var "x"]))),
                      Atom (Rl ("R", [Fn ("f", [Var "x"])])))),
               Exists
                ("x",
                 And (Atom (Rl ("R", [Var "x"])),
                      Atom (Rl ("R", [Fn ("f", [Fn ("f", [Var "x"])])])))))
          ):
   thm
val it =
   Thm (
          Iff (Imp (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
               Imp (Not (Atom (Rl ("q", []))), Not (Atom (Rl ("p", [])))))
          ):
   thm
val it = Thm (Iff (Not (Not (Atom (Rl ("p", [])))), Atom (Rl ("p", [])))):
   thm
val it =
   Thm (
          Imp (Not (Imp (Atom (Rl ("p", [])), Atom (Rl ("q", [])))),
               Imp (Atom (Rl ("q", [])), Atom (Rl ("p", []))))
          ):
   thm
val it =
   Thm (
          Iff (Imp (Not (Atom (Rl ("p", []))), Atom (Rl ("q", []))),
               Imp (Not (Atom (Rl ("q", []))), Atom (Rl ("p", []))))
          ):
   thm
val it =
   Thm (
          Imp (Imp (Or (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
                    Or (Atom (Rl ("p", [])), Atom (Rl ("r", [])))),
               Or (Atom (Rl ("p", [])),
                   Imp (Atom (Rl ("q", [])), Atom (Rl ("r", [])))))
          ):
   thm
val it = Thm (Or (Atom (Rl ("p", [])), Not (Atom (Rl ("p", []))))): thm
val it =
   Thm (Or (Atom (Rl ("p", [])), Not (Not (Not (Atom (Rl ("p", []))))))):
   thm
val it =
   Thm (
          Imp (Imp (Imp (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
                    Atom (Rl ("p", []))),
               Atom (Rl ("p", [])))
          ):
   thm
val it =
   Thm (
          Imp (And (Or (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
                    And (Or (Not (Atom (Rl ("p", []))),
                             Atom (Rl ("q", []))),
                         Or (Atom (Rl ("p", [])),
                             Not (Atom (Rl ("q", [])))))),
               Not (
                      Or (Not (Atom (Rl ("q", []))),
                          Not (Atom (Rl ("q", []))))
                      ))
          ):
   thm
val it =
   Thm (
          Imp (And (Imp (Atom (Rl ("q", [])), Atom (Rl ("r", []))),
                    And (Imp (Atom (Rl ("r", [])),
                              And (Atom (Rl ("p", [])),
                                   Atom (Rl ("q", [])))),
                         Imp (Atom (Rl ("p", [])),
                              And (Atom (Rl ("q", [])),
                                   Atom (Rl ("r", [])))))),
               Iff (Atom (Rl ("p", [])), Atom (Rl ("q", []))))
          ):
   thm
val it = Thm (Iff (Atom (Rl ("p", [])), Atom (Rl ("p", [])))): thm
val it =
   Thm (
          Iff (Iff (Iff (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
                    Atom (Rl ("r", []))),
               Iff (Atom (Rl ("p", [])),
                    Iff (Atom (Rl ("q", [])), Atom (Rl ("r", [])))))
          ):
   thm
val it =
   Thm (
          Iff (Or (Atom (Rl ("p", [])),
                   And (Atom (Rl ("q", [])), Atom (Rl ("r", [])))),
               And (Or (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
                    Or (Atom (Rl ("p", [])), Atom (Rl ("r", [])))))
          ):
   thm
val it =
   Thm (
          Iff (Iff (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
               And (Or (Atom (Rl ("q", [])), Not (Atom (Rl ("p", [])))),
                    Or (Not (Atom (Rl ("q", []))), Atom (Rl ("p", [])))))
          ):
   thm
val it =
   Thm (
          Iff (Imp (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
               Or (Not (Atom (Rl ("p", []))), Atom (Rl ("q", []))))
          ):
   thm
val it =
   Thm (
          Or (Imp (Atom (Rl ("p", [])), Atom (Rl ("q", []))),
              Imp (Atom (Rl ("q", [])), Atom (Rl ("p", []))))
          ):
   thm
val it =
   Thm (
          Forall
           ("x",
            Exists
             ("v",
              Exists
               ("w",
                Forall
                 ("y",
                  Forall
                   ("z",
                    Imp (And (Atom (Rl ("P", [Var "x"])),
                              Atom (Rl ("Q", [Var "y"]))),
                         And (Or (Atom (Rl ("...", [...])),
                                  Atom (Rl ("...", [...]))),
                              Imp (Atom (Rl ("...", [...])),
                                   Atom (Rl ("...", [...]))))))))))
          ):
   thm
val it =
   Thm (
          Exists
           ("y",
            Forall
             ("x",
              Imp (Atom (Rl ("P", [Var "y"])), Atom (Rl ("P", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Iff (Imp (And (Atom (Rl ("p", [])),
                         Imp (Atom (Rl ("q", [])), Atom (Rl ("r", [])))),
                    Atom (Rl ("s", []))),
               And (Or (Not (Atom (Rl ("p", []))),
                        Or (Atom (Rl ("q", [])), Atom (Rl ("s", [])))),
                    Or (Not (Atom (Rl ("p", []))),
                        Or (Not (Atom (Rl ("r", []))),
                            Atom (Rl ("s", []))))))
          ):
   thm
val it =
   Thm (
          Imp (Forall
                ("x",
                 Forall
                  ("y",
                   Exists
                    ("z",
                     Forall
                      ("w",
                       Imp (And (Atom (Rl ("P", [Var "x"])),
                                 Atom (Rl ("Q", [Var "y"]))),
                            And (Atom (Rl ("R", [Var "z"])),
                                 Atom (Rl ("U", [Var "w"])))))))),
               Imp (Exists
                     ("x",
                      Exists
                       ("y",
                        And (Atom (Rl ("P", [Var "x"])),
                             Atom (Rl ("Q", [Var "y"]))))),
                    Exists ("z", Atom (Rl ("R", [Var "z"])))))
          ):
   thm
val it =
   Thm (
          Exists
           ("x",
            Forall
             ("y",
              Forall
               ("z",
                Imp (Imp (Atom (Rl ("P", [Var "y"])),
                          Atom (Rl ("Q", [Var "z"]))),
                     Imp (Atom (Rl ("P", [Var "x"])),
                          Atom (Rl ("Q", [Var "x"])))))))
          ):
   thm
val it =
   Thm (
          Imp (Forall
                ("x",
                 Iff (Atom (Rl ("P", [])), Atom (Rl ("Q", [Var "x"])))),
               Iff (Atom (Rl ("P", [])),
                    Forall ("x", Atom (Rl ("Q", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Imp (And (Exists
                     ("x",
                      Imp (Atom (Rl ("P", [])),
                           Atom (Rl ("Q", [Var "x"])))),
                    Exists
                     ("x",
                      Imp (Atom (Rl ("Q", [Var "x"])),
                           Atom (Rl ("P", []))))),
               Exists
                ("x",
                 Iff (Atom (Rl ("P", [])), Atom (Rl ("Q", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Iff (Forall
                ("x", Or (Atom (Rl ("P", [])), Atom (Rl ("Q", [Var "x"])))),
               Or (Atom (Rl ("P", [])),
                   Forall ("x", Atom (Rl ("Q", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Imp (And (Exists ("x", Atom (Rl ("P", [Var "x"]))),
                    And (Forall
                          ("x",
                           Imp (Atom (Rl ("U", [Var "x"])),
                                And (Not (Atom (Rl ("G", [Var "x"]))),
                                     Atom (Rl ("R", [Var "x"]))))),
                         And (Forall
                               ("x",
                                Imp (Atom (Rl ("P", [Var "x"])),
                                     And
(Atom (Rl ("G", [Var "x"])), Atom (Rl ("U", [Var "x"]))))),
                              Or (Forall
                                   ("x",
                                    Imp (Atom (Rl ("P", [Var "x"])),
   Atom (Rl ("Q", [Var "x"])))),
                                  Exists
                                   ("x",
                                    And (Atom (Rl ("Q", [Var "x"])),
   Atom (Rl ("P", [Var "x"])))))))),
               Exists
                ("x",
                 And (Atom (Rl ("Q", [Var "x"])),
                      Atom (Rl ("P", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Imp (And (Not (
                           Exists
                            ("x",
                             And (Atom (Rl ("U", [Var "x"])),
                                  Atom (Rl ("Q", [Var "x"]))))
                           ),
                    And (Forall
                          ("x",
                           Imp (Atom (Rl ("P", [Var "x"])),
                                Or (Atom (Rl ("Q", [Var "x"])),
                                    Atom (Rl ("R", [Var "x"]))))),
                         And (Not (
                                     Exists
("x",
 Imp (Atom (Rl ("P", [Var "x"])),
      Exists ("x", Atom (Rl ("Q", [Var "..."])))))
                                     ),
                              Forall
                               ("x",
                                Imp (And
(Atom (Rl ("Q", [Var "x"])), Atom (Rl ("R", [Var "x"]))),
                                     Atom (Rl ("U", [Var "x"]))))))),
               Exists
                ("x",
                 And (Atom (Rl ("P", [Var "x"])),
                      Atom (Rl ("R", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Imp (And (Exists
                     ("x",
                      And (Atom (Rl ("P", [Var "x"])),
                           Not (Atom (Rl ("Q", [Var "x"]))))),
                    And (Forall
                          ("x",
                           Imp (Atom (Rl ("P", [Var "x"])),
                                Atom (Rl ("R", [Var "x"])))),
                         And (Forall
                               ("x",
                                Imp (And
(Atom (Rl ("U", [Var "x"])), Atom (Rl ("V", [Var "x"]))),
                                     Atom (Rl ("P", [Var "x"])))),
                              Exists
                               ("x",
                                And (Atom (Rl ("R", [Var "x"])),
                                     Not (Atom (Rl ("Q", [Var "x"])))))))),
               Imp (Forall
                     ("x",
                      Imp (Atom (Rl ("V", [Var "x"])),
                           Not (Atom (Rl ("R", [Var "x"]))))),
                    Forall
                     ("x",
                      Imp (Atom (Rl ("U", [Var "x"])),
                           Not (Atom (Rl ("V", [Var "x"])))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Imp (Atom (Rl ("P", [Var "x"])),
                           Forall ("x", Atom (Rl ("Q", [Var "x"]))))),
                    And (Imp (Forall
                               ("x",
                                Or (Atom (Rl ("Q", [Var "x"])),
                                    Atom (Rl ("R", [Var "x"])))),
                              Exists
                               ("x",
                                And (Atom (Rl ("Q", [Var "x"])),
                                     Atom (Rl ("R", [Var "x"]))))),
                         Imp (Exists ("x", Atom (Rl ("R", [Var "x"]))),
                              Forall
                               ("x",
                                Imp (Atom (Rl ("L", [Var "x"])),
                                     Atom (Rl ("M", [Var "x"]))))))),
               Forall
                ("x",
                 Imp (And (Atom (Rl ("P", [Var "x"])),
                           Atom (Rl ("L", [Var "x"]))),
                      Atom (Rl ("M", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Imp (And (Iff (Exists ("x", Atom (Rl ("P", [Var "x"]))),
                         Exists ("x", Atom (Rl ("Q", [Var "x"])))),
                    Forall
                     ("x",
                      Forall
                       ("y",
                        Imp (And (Atom (Rl ("P", [Var "x"])),
                                  Atom (Rl ("Q", [Var "y"]))),
                             Iff (Atom (Rl ("R", [Var "x"])),
                                  Atom (Rl ("U", [Var "y"]))))))),
               Iff (Forall
                     ("x",
                      Imp (Atom (Rl ("P", [Var "x"])),
                           Atom (Rl ("R", [Var "x"])))),
                    Forall
                     ("x",
                      Imp (Atom (Rl ("Q", [Var "x"])),
                           Atom (Rl ("U", [Var "x"]))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Imp (Or (Atom (Rl ("P", [Var "x"])),
                               Atom (Rl ("G", [Var "x"]))),
                           Not (Atom (Rl ("H", [Var "x"]))))),
                    Forall
                     ("x",
                      Imp (Imp (Atom (Rl ("G", [Var "x"])),
                                Not (Atom (Rl ("U", [Var "x"])))),
                           And (Atom (Rl ("P", [Var "x"])),
                                Atom (Rl ("H", [Var "x"])))))),
               Forall ("x", Atom (Rl ("U", [Var "x"]))))
          ):
   thm
val it =
   Thm (
          Imp (And (Exists ("x", Atom (Rl ("P", [Var "x"]))),
                    Exists ("x", Atom (Rl ("G", [Var "x"])))),
               Iff (And (Forall
                          ("x",
                           Imp (Atom (Rl ("P", [Var "x"])),
                                Atom (Rl ("H", [Var "x"])))),
                         Forall
                          ("x",
                           Imp (Atom (Rl ("G", [Var "x"])),
                                Atom (Rl ("J", [Var "x"]))))),
                    Forall
                     ("x",
                      Forall
                       ("y",
                        Imp (And (Atom (Rl ("P", [Var "x"])),
                                  Atom (Rl ("G", [Var "y"]))),
                             And (Atom (Rl ("H", [Var "x"])),
                                  Atom (Rl ("J", [Var "y"]))))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Not (
                           Exists
                            ("x",
                             And (Atom (Rl ("P", [Var "x"])),
                                  Or (Atom (Rl ("G", [Var "x"])),
Atom (Rl ("H", [Var "x"])))))
                           ),
                    And (Exists
                          ("x",
                           And (Atom (Rl ("Q", [Var "x"])),
                                Atom (Rl ("P", [Var "x"])))),
                         Forall
                          ("x",
                           Imp (Not (Atom (Rl ("H", [Var "x"]))),
                                Atom (Rl ("J", [Var "x"])))))),
               Exists
                ("x",
                 And (Atom (Rl ("Q", [Var "x"])),
                      Atom (Rl ("J", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Imp (And (Atom (Rl ("P", [Var "x"])),
                                Or (Atom (Rl ("G", [Var "x"])),
                                    Atom (Rl ("H", [Var "x"])))),
                           Atom (Rl ("Q", [Var "x"])))),
                    And (Forall
                          ("x",
                           Imp (And (Atom (Rl ("Q", [Var "x"])),
                                     Atom (Rl ("H", [Var "x"]))),
                                Atom (Rl ("J", [Var "x"])))),
                         Forall
                          ("x",
                           Imp (Atom (Rl ("R", [Var "x"])),
                                Atom (Rl ("H", [Var "x"])))))),
               Forall
                ("x",
                 Imp (And (Atom (Rl ("P", [Var "x"])),
                           Atom (Rl ("R", [Var "x"]))),
                      Atom (Rl ("J", [Var "x"])))))
          ):
   thm
val it =
   Thm (
          Imp (Forall
                ("x",
                 Forall
                  ("y",
                   Iff (Atom (Rl ("Q", [Var "x", Var "y"])),
                        Forall
                         ("z",
                          Iff (Atom (Rl ("P", [Var "z", Var "x"])),
                               Atom (Rl ("P", [Var "z", Var "y"]))))))),
               Forall
                ("x",
                 Forall
                  ("y",
                   Iff (Atom (Rl ("Q", [Var "x", Var "y"])),
                        Atom (Rl ("Q", [Var "y", Var "x"]))))))
          ):
   thm
val it =
   Thm (
          Exists
           ("x",
            Exists
             ("y",
              Imp (Atom (Rl ("P", [Var "x", Var "y"])),
                   Forall
                    ("x",
                     Forall ("y", Atom (Rl ("P", [Var "x", Var "y"])))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Exists ("y", Atom (Rl ("P", [Var "x", Var "y"])))),
                    And (Forall
                          ("x",
                           Exists
                            ("y", Atom (Rl ("G", [Var "x", Var "y"])))),
                         Forall
                          ("x",
                           Forall
                            ("y",
                             Imp (Or (Atom (Rl ("P", [Var "x", Var "..."])),
Atom (Rl ("G", [Var "x", Var "..."]))),
                                  Forall
                                   ("z",
                                    Imp (Or (Atom ..., Atom ...),
   Atom (Rl ("...", [...]))))))))),
               Forall
                ("x", Exists ("y", Atom (Rl ("H", [Var "x", Var "y"])))))
          ):
   thm
val it =
   Thm (
          Iff (Forall
                ("x",
                 Imp (And (Atom (Rl ("P", [Var "a"])),
                           Imp (Atom (Rl ("P", [Var "x"])),
                                Atom (Rl ("P", [Var "b"])))),
                      Atom (Rl ("P", [Var "c"])))),
               And (Forall
                     ("x",
                      Imp (Atom (Rl ("P", [Var "a"])),
                           Or (Atom (Rl ("P", [Var "x"])),
                               Atom (Rl ("P", [Var "c"]))))),
                    Imp (Atom (Rl ("P", [Var "a"])),
                         Imp (Atom (Rl ("P", [Var "b"])),
                              Atom (Rl ("P", [Var "c"]))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("z",
                      Exists
                       ("w",
                        Forall
                         ("x",
                          Exists
                           ("y",
                            And (Imp (Atom (Rl ("...", [...])),
Atom (Rl ("...", [...]))),
                                 And (Atom (Rl ("...", [...])),
Imp (Atom ..., Exists ("...", ...)))))))),
                    And (Forall
                          ("x",
                           Forall
                            ("z",
                             Imp (Not (Atom (Rl ("P", [Var "x", Var "z"]))),
                                  Exists
                                   ("y",
                                    Atom
                                     (Rl ("Q", [Var "y", Var "..."])))))),
                         Imp (Exists
                               ("x",
                                Exists
                                 ("y",
                                  Atom (Rl ("Q", [Var "x", Var "y"])))),
                              Forall
                               ("x",
                                Atom (Rl ("R", [Var "x", Var "x"])))))),
               Forall
                ("x", Exists ("y", Atom (Rl ("R", [Var "x", Var "y"])))))
          ):
   thm
val it =
   Thm (
          Not (
                 Exists
                  ("x",
                   Forall
                    ("y",
                     Iff (Atom (Rl ("P", [Var "y", Var "x"])),
                          Not (Atom (Rl ("P", [Var "y", Var "y"]))))))
                 )
          ):
   thm
val templateLemmas =
   [("FOL_Harrison.equal_length_sym",
     "equal_length ?l ?l' ==> equal_length ?l' ?l",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 0, template_var 1),
              template_var 0)
            )],
       template_predicate
        (
           template_app
            (template_app (template_hole 0, template_var 0), template_var 1)
           ))),
    ("FOL_Harrison.soundness", "\<turnstile> ?p ==> semantics ?e ?f ?g ?p",
     template_implication
      ([template_predicate
         (template_app (template_hole 1, template_var 3))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app (template_hole 0, template_var 2),
                 template_var 1),
               template_var 0),
             template_var 3)
           ))),
    ("FOL_Harrison.equal_length2",
     "equal_length ?l ?l' ==> length2 ?l = length2 ?l'",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 2, template_var 1),
              template_var 0)
            )],
       template_equation
        (template_app (template_hole 0, template_var 1),
         template_app (template_hole 0, template_var 0)))),
    ("FOL_Harrison.length2_equiv",
     "length2 ?l = ([hd ?l, hd (tl ?l)] = ?l)",
     template_implication
      ([template_predicate
         (template_app (template_hole 5, template_var 0))],
       template_equation
        (template_app
          (template_app
            (template_hole 3,
             template_app (template_hole 2, template_var 0)),
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_hole 2,
                 template_app (template_hole 1, template_var 0))),
             template_hole 0)),
         template_var 0))),
    ("FOL_Harrison.map'",
     "~ occurs_in ?x ?t ==>
      semantics_term ?e ?f ?t = semantics_term (?e(?x := ?v)) ?f ?t",
     template_implication
      ([template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 3, template_var 4),
                  template_var 3)
                )
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 3),
         template_app
          (template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 2),
                   template_var 4),
                 template_var 0)),
             template_var 1),
           template_var 3)))),
    ("FOL_Harrison.map'",
     "~ occurs_in_list ?x ?l ==>
      semantics_list ?e ?f ?l = semantics_list (?e(?x := ?v)) ?f ?l",
     template_implication
      ([template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 3, template_var 4),
                  template_var 3)
                )
            )],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 3),
         template_app
          (template_app
            (template_app
              (template_hole 1,
               template_app
                (template_app
                  (template_app (template_hole 0, template_var 2),
                   template_var 4),
                 template_var 0)),
             template_var 1),
           template_var 3)))),
    ("FOL_Harrison.map",
     "~ free_in ?x ?p ==>
      semantics ?e ?f ?g ?p = semantics (?e(?x := ?v)) ?f ?g ?p",
     template_implication
      ([template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 3, template_var 5),
                  template_var 4)
                )
            )],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_app (template_hole 1, template_var 3),
               template_var 2),
             template_var 1),
           template_var 4),
         template_app
          (template_app
            (template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app
                    (template_app (template_hole 0, template_var 3),
                     template_var 5),
                   template_var 0)),
               template_var 2),
             template_var 1),
           template_var 4)))),
    ("FOL_Harrison.predcong",
     "equal_length ?l ?l' ==>
      semantics ?e ?f ?g
       (foldr Imp (zip_eq ?l ?l')
         (Imp (Atom (Rl ?i ?l)) (Atom (Rl ?i ?l'))))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 6, template_var 5),
              template_var 4)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app (template_hole 5, template_var 3),
                 template_var 2),
               template_var 1),
             template_app
              (template_app
                (template_app (template_hole 4, template_hole 3),
                 template_app
                  (template_app (template_hole 2, template_var 5),
                   template_var 4)),
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_hole 1,
                     template_app
                      (template_app (template_hole 0, template_var 0),
                       template_var 5))),
                 template_app
                  (template_hole 1,
                   template_app
                    (template_app (template_hole 0, template_var 0),
                     template_var 4)))))
           ))),
    ("FOL_Harrison.imp_chain_equiv",
     "semantics ?e ?f ?g (foldr Imp ?l ?p) =
      ((ALL q:set ?l. semantics ?e ?f ?g q) --> semantics ?e ?f ?g ?p)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 5, template_var 4),
             template_var 3),
           template_var 2),
         template_app
          (template_app
            (template_app (template_hole 4, template_hole 3),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app
              (template_hole 1,
               template_app (template_hole 0, template_var 1)),
             t_empty)),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 5, template_var 4),
               template_var 3),
             template_var 2),
           template_var 0)))),
    ("FOL_Harrison.imp_chain_zip_eq",
     "equal_length ?l ?l' ==>
      semantics ?e ?f ?g (foldr Imp (zip_eq ?l ?l') ?p) =
      (semantics_list ?e ?f ?l = semantics_list ?e ?f ?l' -->
       semantics ?e ?f ?g ?p)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 8, template_var 5),
              template_var 4)
            )],
       template_implication
        ([template_predicate
           (
              template_app
               (template_app
                 (template_app
                   (template_app (template_hole 6, template_var 3),
                    template_var 2),
                  template_var 1),
                template_app
                 (template_app
                   (template_app (template_hole 5, template_hole 4),
                    template_app
                     (template_app (template_hole 3, template_var 5),
                      template_var 4)),
                  template_var 0))
              )],
         template_predicate
          (
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app
                    (template_hole 1,
                     template_app
                      (template_app
                        (template_app (template_hole 0, template_var 3),
                         template_var 2),
                       template_var 5)),
                   template_app
                    (template_app
                      (template_app (template_hole 0, template_var 3),
                       template_var 2),
                     template_var 4))),
               template_app
                (template_app
                  (template_app
                    (template_app (template_hole 6, template_var 3),
                     template_var 2),
                   template_var 1),
                 template_var 0))
             )))),
    ("FOL_Harrison.funcong",
     "equal_length ?l ?l' ==>
      semantics ?e ?f ?g
       (foldr Imp (zip_eq ?l ?l')
         (Atom (Rl STR ''='' [Fn ?i ?l, Fn ?i ?l'])))",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 13, template_var 5),
              template_var 4)
            )],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app (template_hole 12, template_var 3),
                 template_var 2),
               template_var 1),
             template_app
              (template_app
                (template_app (template_hole 11, template_hole 10),
                 template_app
                  (template_app (template_hole 9, template_var 5),
                   template_var 4)),
               template_app
                (template_hole 8,
                 template_app
                  (template_app
                    (template_hole 7,
                     template_app
                      (template_app
                        (template_app
                          (template_app
                            (template_app
                              (template_app
                                (template_app
                                  (template_app
                                    (template_hole 6, template_hole 5),
                                   template_hole 4),
                                 template_hole 5),
                               template_hole 5),
                             template_hole 5),
                           template_hole 5),
                         template_hole 4),
                       template_hole 3)),
                   template_app
                    (template_app
                      (template_hole 2,
                       template_app
                        (template_app (template_hole 1, template_var 0),
                         template_var 5)),
                     template_app
                      (template_app
                        (template_hole 2,
                         template_app
                          (template_app (template_hole 1, template_var 0),
                           template_var 4)),
                       template_hole 0))))))
           )))]:
   (string * Thm.thm * template) list
### theory "Draft.FOL_HarrisonMoreTemplates"
### 0.443s elapsed time, 1.751s cpu time, 0.051s GC time
val it =
   Thm (
          Imp (Forall
                ("z",
                 Exists
                  ("y",
                   Forall
                    ("x",
                     Iff (Atom (Rl ("P", [Var "x", Var "y"])),
                          And (Atom (Rl ("P", [Var "x", Var "z"])),
                               Not (
Atom (Rl ("P", [Var "x", Var "x"]))
)))))),
               Not (
                      Exists
                       ("z",
                        Forall ("x", Atom (Rl ("P", [Var "x", Var "z"]))))
                      ))
          ):
   thm
val it =
   Thm (
          Imp (Exists
                ("y",
                 Forall
                  ("x",
                   Iff (Atom (Rl ("P", [Var "x", Var "y"])),
                        Atom (Rl ("P", [Var "x", Var "x"]))))),
               Not (
                      Forall
                       ("x",
                        Exists
                         ("y",
                          Forall
                           ("z",
                            Iff (Atom (Rl ("P", [Var "z", Var "y"])),
                                 Not (
  Atom (Rl ("P", [Var "z", Var "x"]))
  )))))
                      ))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Imp (Atom (Rl ("P", [Var "x"])),
                           And (Exists
                                 ("y",
                                  And (Atom (Rl ("G", [Var "y"])),
 Atom (Rl ("H", [Var "x", Var "..."])))),
                                Exists
                                 ("y",
                                  And (Atom (Rl ("G", [Var "y"])),
 Not (Atom (Rl ("H", [Var "...", ...])))))))),
                    Exists
                     ("x",
                      And (Atom (Rl ("J", [Var "x"])),
                           Forall
                            ("y",
                             Imp (Atom (Rl ("G", [Var "y"])),
                                  Atom (Rl ("H", [Var "x", Var "y"]))))))),
               Exists
                ("x",
                 And (Atom (Rl ("J", [Var "x"])),
                      Not (Atom (Rl ("P", [Var "x"]))))))
          ):
   thm
val it =
   Thm (
          Not (
                 Exists
                  ("y",
                   Forall
                    ("x",
                     Iff (Atom (Rl ("P", [Var "x", Var "y"])),
                          Not (
                                 Exists
                                  ("z",
                                   And (Atom (Rl ("P", [Var "x", Var "z"])),
  Atom (Rl ("P", [Var "z", Var "x"]))))
                                 ))))
                 )
          ):
   thm
val it =
   Thm (
          Iff (Forall
                ("x",
                 Imp (And (Atom (Rl ("P", [Var "a"])),
                           Imp (Atom (Rl ("P", [Var "x"])),
                                Exists
                                 ("y",
                                  And (Atom (Rl ("P", [Var "y"])),
 Atom (Rl ("R", [Var "x", Var "..."])))))),
                      Exists
                       ("z",
                        Exists
                         ("w",
                          And (Atom (Rl ("P", [Var "z"])),
                               And (Atom (Rl ("R", [Var "x", Var "..."])),
                                    Atom
                                     (Rl ("R", [Var "w", Var "..."])))))))),
               Forall
                ("x",
                 And (Or (Not (Atom (Rl ("P", [Var "a"]))),
                          Or (Atom (Rl ("P", [Var "x"])),
                              Exists
                               ("z",
                                Exists
                                 ("w",
                                  And (Atom (Rl ("...", [...])),
 And (Atom ..., Atom ...)))))),
                      Or (Not (Atom (Rl ("P", [Var "a"]))),
                          Or (Not (
                                     Exists
("y", And (Atom (Rl ("P", [Var "..."])), Atom (Rl ("R", [Var "...", ...]))))
                                     ),
                              Exists
                               ("z",
                                Exists
                                 ("w",
                                  And (Atom (Rl ("...", [...])),
 And (Atom ..., Atom ...)))))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Atom
                     (
                        Rl ("P",
                            [Fn ("f", [Var "a", Var "b"]),
                             Fn ("f", [Var "b", Var "c"])])
                        ),
                    And (Atom
                          (
                             Rl ("P",
                                 [Fn ("f", [Var "b", Var "c"]),
                                  Fn ("f", [Var "a", Var "c"])])
                             ),
                         Forall
                          ("x",
                           Forall
                            ("y",
                             Forall
                              ("z",
                               Imp (And (Atom (Rl ("...", [...])),
   Atom (Rl ("...", [...]))),
                                    Atom
                                     (Rl ("P", [Var "x", Var "..."])))))))),
               Atom
                (
                   Rl ("P",
                       [Fn ("f", [Var "a", Var "b"]),
                        Fn ("f", [Var "a", Var "c"])])
                   ))
          ):
   thm
val it =
   Thm (
          Imp (Forall
                ("x",
                 Iff (Atom (Rl ("P", [Var "x"])),
                      Not (Atom (Rl ("P", [Fn ("f", [Var "x"])]))))),
               Exists
                ("x",
                 And (Atom (Rl ("P", [Var "x"])),
                      Not (Atom (Rl ("P", [Fn ("f", [Var "x"])]))))))
          ):
   thm
val it =
   Thm (
          Forall
           ("x",
            Iff (Atom (Rl ("P", [Var "x", Fn ("f", [Var "x"])])),
                 Exists
                  ("y",
                   And (Forall
                         ("z",
                          Imp (Atom (Rl ("P", [Var "z", Var "y"])),
                               Atom
                                (
                                   Rl ("P",
 [Var "z", Fn ("f", [Var "..."])])
                                   ))),
                        Atom (Rl ("P", [Var "x", Var "y"]))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Imp (And (Atom (Rl ("P", [Var "x"])),
                                Forall
                                 ("y",
                                  Imp (And
  (Atom (Rl ("...", [...])), Atom (Rl ("...", [...]))),
 Atom (Rl ("J", [Var "x", Var "..."]))))),
                           Forall
                            ("y",
                             Imp (And (Atom (Rl ("G", [Var "y"])),
 Atom (Rl ("H", [Var "x", Var "..."]))),
                                  Atom (Rl ("R", [Var "y"])))))),
                    And (Not (
                                Exists
                                 ("y",
                                  And (Atom (Rl ("L", [Var "y"])),
 Atom (Rl ("R", [Var "y"]))))
                                ),
                         Exists
                          ("x",
                           And (Atom (Rl ("P", [Var "x"])),
                                And (Forall
("y", Imp (Atom (Rl ("...", [...])), Atom (Rl ("...", [...])))),
                                     Forall
("y", Imp (And (Atom ..., Atom ...), Atom (Rl ("...", [...]))))))))),
               Exists
                ("x",
                 And (Atom (Rl ("P", [Var "x"])),
                      Not (
                             Exists
                              ("y",
                               And (Atom (Rl ("G", [Var "y"])),
                                    Atom (Rl ("H", [Var "x", Var "y"]))))
                             ))))
          ):
   thm
val it =
   Thm (
          Exists
           ("x",
            Forall
             ("y",
              Forall
               ("z",
                Imp (And (Imp (Imp (Atom (Rl ("F", [Var "y", Var "..."])),
                                    Imp (Atom (Rl ("...", [...])),
   Atom (Rl ("...", [...])))),
                               Atom (Rl ("F", [Var "x", Var "x"]))),
                          And (Imp (Imp (Atom (Rl ("...", [...])),
   Atom (Rl ("...", [...]))),
                                    Atom (Rl ("H", [Var "z"]))),
                               Atom (Rl ("F", [Var "x", Var "y"])))),
                     Atom (Rl ("F", [Var "z", Var "z"]))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Exists
                       ("y",
                        Or (Atom (Rl ("F", [Var "x", Var "y"])),
                            Atom (Rl ("F", [Var "y", Var "x"]))))),
                    Forall
                     ("x",
                      Forall
                       ("y",
                        Imp (Atom (Rl ("F", [Var "y", Var "x"])),
                             Atom (Rl ("F", [Var "y", Var "y"])))))),
               Exists ("z", Atom (Rl ("F", [Var "z", Var "z"]))))
          ):
   thm
val it =
   Thm (
          Forall
           ("x",
            Exists
             ("y",
              Imp (Exists
                    ("u",
                     Forall
                      ("v",
                       Imp (Atom (Rl ("F", [Var "u", Var "x"])),
                            And (Atom (Rl ("G", [Var "v", Var "..."])),
                                 Atom (Rl ("G", [Var "u", Var "..."])))))),
                   Or (Exists
                        ("u",
                         Forall
                          ("v",
                           Imp (Atom (Rl ("F", [Var "u", Var "..."])),
                                And (Atom (Rl ("...", [...])),
                                     Atom (Rl ("...", [...])))))),
                       Forall
                        ("u",
                         Forall
                          ("v",
                           Exists
                            ("w",
                             Imp (Or (Atom ..., Atom ...),
                                  Atom (Rl ("...", [...]))))))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall
                     ("x",
                      Imp (Atom (Rl ("K", [Var "x"])),
                           Exists
                            ("y",
                             And (Atom (Rl ("L", [Var "y"])),
                                  Imp (Atom
  (Rl ("F", [Var "x", Var "..."])),
 Atom (Rl ("G", [Var "x", Var "..."]))))))),
                    Exists
                     ("z",
                      And (Atom (Rl ("K", [Var "z"])),
                           Forall
                            ("u",
                             Imp (Atom (Rl ("L", [Var "u"])),
                                  Atom (Rl ("F", [Var "z", Var "u"]))))))),
               Exists
                ("v",
                 Exists
                  ("w",
                   And (Atom (Rl ("K", [Var "v"])),
                        And (Atom (Rl ("L", [Var "w"])),
                             Atom (Rl ("G", [Var "v", Var "w"])))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Atom (Rl ("lives", [Var "agatha"])),
                    And (Atom (Rl ("lives", [Var "butler"])),
                         And (Atom (Rl ("lives", [Var "charles"])),
                              And (Or (Atom
  (Rl ("killed", [Var "agatha", Var "agatha"])),
 Or (Atom (Rl ("killed", [Var "butler", Var "..."])),
     Atom (Rl ("killed", [Var "charles", Var "..."])))),
                                   And (Forall
   ("x", Forall ("y", Imp (Atom ..., And (..., ...)))),
  And (Forall ("x", Imp (Atom ..., Not ...)),
       And (And (Atom ..., Atom ...),
            And (Forall ("...", ...), And (..., ...))))))))),
               And (Atom (Rl ("killed", [Var "agatha", Var "agatha"])),
                    And (Not (
                                Atom
                                 (
                                    Rl ("killed",
  [Var "butler", Var "agatha"])
                                    )
                                ),
                         Not (
                                Atom
                                 (
                                    Rl ("killed",
  [Var "charles", Var "agatha"])
                                    )
                                ))))
          ):
   thm
val it =
   Thm (
          Exists
           ("x",
            Exists
             ("y",
              Forall
               ("z",
                And (Imp (Atom (Rl ("F", [Var "x", Var "y"])),
                          And (Atom (Rl ("F", [Var "y", Var "z"])),
                               Atom (Rl ("F", [Var "z", Var "z"])))),
                     Imp (And (Atom (Rl ("F", [Var "x", Var "y"])),
                               Atom (Rl ("G", [Var "x", Var "y"]))),
                          And (Atom (Rl ("G", [Var "x", Var "z"])),
                               Atom (Rl ("G", [Var "z", Var "z"]))))))))
          ):
   thm
val it =
   Thm (
          Exists
           ("x",
            Forall
             ("y",
              Forall
               ("z",
                Imp (And (Imp (Imp (Atom (Rl ("F", [Var "y", Var "..."])),
                                    Imp (Atom (Rl ("...", [...])),
   Forall ("u", Exists ("...", ...)))),
                               Atom (Rl ("F", [Var "x", Var "x"]))),
                          And (Imp (Imp (Atom (Rl ("...", [...])),
   Atom (Rl ("...", [...]))),
                                    Forall ("u", Exists ("v", Atom ...))),
                               Atom (Rl ("F", [Var "x", Var "y"])))),
                     Atom (Rl ("F", [Var "z", Var "z"]))))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall ("x", Atom (Rl ("<=", [Var "x", Var "x"]))),
                    And (Forall
                          ("x",
                           Forall
                            ("y",
                             Forall
                              ("z",
                               Imp (And (Atom (Rl ("...", [...])),
   Atom (Rl ("...", [...]))),
                                    Atom
                                     (Rl ("<=", [Var "x", Var "..."])))))),
                         Forall
                          ("x",
                           Forall
                            ("y",
                             Iff (Atom
                                   (
Rl ("<=", [Fn ("f", [Var "x"]), Var "y"])
),
                                  Atom
                                   (
Rl ("<=", [Var "x", Fn ("g", [Var "..."])])
)))))),
               Forall
                ("x",
                 Forall
                  ("y",
                   Imp (Atom (Rl ("<=", [Var "x", Var "y"])),
                        Atom
                         (
                            Rl ("<=",
                                [Fn ("f", [Var "x"]), Fn ("f", [Var "y"])])
                            )))))
          ):
   thm
val it =
   Thm (
          Imp (And (Forall ("x", Atom (Rl ("<=", [Var "x", Var "x"]))),
                    And (Forall
                          ("x",
                           Forall
                            ("y",
                             Forall
                              ("z",
                               Imp (And (Atom (Rl ("...", [...])),
   Atom (Rl ("...", [...]))),
                                    Atom
                                     (Rl ("<=", [Var "x", Var "..."])))))),
                         Forall
                          ("x",
                           Forall
                            ("y",
                             Iff (Atom
                                   (
Rl ("<=", [Fn ("f", [Var "x"]), Var "y"])
),
                                  Atom
                                   (
Rl ("<=", [Var "x", Fn ("g", [Var "..."])])
)))))),
               Forall
                ("x",
                 Forall
                  ("y",
                   Imp (Atom (Rl ("<=", [Var "x", Var "y"])),
                        Atom
                         (
                            Rl ("<=",
                                [Fn ("g", [Var "x"]), Fn ("g", [Var "y"])])
                            )))))
          ):
   thm
val it =
   Thm (
          Exists
           ("x",
            Exists
             ("y",
              Forall
               ("z",
                And (Imp (Atom (Rl ("F", [Var "x", Var "y"])),
                          And (Atom (Rl ("F", [Var "y", Var "z"])),
                               Atom (Rl ("F", [Var "z", Var "z"])))),
                     Imp (And (Atom (Rl ("F", [Var "x", Var "y"])),
                               Atom (Rl ("G", [Var "x", Var "y"]))),
                          And (Atom (Rl ("G", [Var "x", Var "z"])),
                               Atom (Rl ("G", [Var "z", Var "z"]))))))))
          ):
   thm
val it =
   Thm (
          Forall
           ("x",
            Exists
             ("y",
              Forall
               ("z",
                And (Imp (Forall
                           ("u",
                            Exists
                             ("v",
                              And (Atom (Rl ("...", [...])),
                                   And (Atom ..., Not ...)))),
                          Imp (Forall
                                ("u",
                                 Exists
                                  ("v", And (Atom ..., And (..., ...)))),
                               Forall
                                ("u",
                                 Exists
                                  ("v", And (Atom ..., And (..., ...)))))),
                     Imp (Forall
                           ("u",
                            Exists
                             ("v",
                              And (Atom (Rl ("...", [...])),
                                   And (Atom ..., Not ...)))),
                          Imp (Not (
Forall ("u", Exists ("v", And (..., ...)))
),
                               And (Forall
                                     ("u", Exists ("v", And (..., ...))),
                                    Forall
                                     ("u",
Exists ("v", And (..., ...))))))))))
          ):
   thm
val it =
   Thm (
          Iff (Iff (Exists
                     ("x",
                      Forall
                       ("y",
                        Iff (Atom (Rl ("P", [Var "x"])),
                             Atom (Rl ("P", [Var "y"]))))),
                    Iff (Exists ("x", Atom (Rl ("Q", [Var "x"]))),
                         Forall ("y", Atom (Rl ("Q", [Var "y"]))))),
               Iff (Exists
                     ("x",
                      Forall
                       ("y",
                        Iff (Atom (Rl ("Q", [Var "x"])),
                             Atom (Rl ("Q", [Var "y"]))))),
                    Iff (Exists ("x", Atom (Rl ("P", [Var "x"]))),
                         Forall ("y", Atom (Rl ("P", [Var "y"]))))))
          ):
   thm
val it = (): unit
