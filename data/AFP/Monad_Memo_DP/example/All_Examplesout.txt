Loading theory "Draft.Ground_Function" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford")
Loading theory "Draft.Solve_Cong" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main")
Loading theory "Draft.Indexing" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap")
Loading theory "Draft.Pure_Monad" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap" via "Draft.State_Heap" via "Draft.DP_CRelVS")
### ML warning (file "$AFP/Monad_Memo_DP/util/Ground_Function.ML"):
### Pattern is not exhaustive.
### ML warning (line 28 of "$AFP/Monad_Memo_DP/util/Ground_Function.ML"):
### Pattern is not exhaustive.
signature GROUND_FUNCTION =
  sig
    val mk_fun: bool -> thm list -> binding -> local_theory -> local_theory
  end
structure Ground_Function: GROUND_FUNCTION
### theory "Draft.Pure_Monad"
### 0.036s elapsed time, 0.177s cpu time, 0.000s GC time
Loading theory "Draft.State_Heap_Misc" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap" via "Draft.State_Heap")
val ground_function_cmd = fn:
   (''a option * binding) * (Facts.ref * Token.src list) list ->
     Proof.context -> local_theory
val ground_function_parser = fn:
   Token.T list ->
     ((string option * binding) * (Facts.ref * Token.src list) list) *
     Token.T list
### theory "Draft.Ground_Function"
### 0.053s elapsed time, 0.243s cpu time, 0.000s GC time
Loading theory "Draft.State_Monad_Ext" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap" via "Draft.State_Heap" via "Draft.DP_CRelVS")
bundle state_monad_syntax
### theory "Draft.State_Heap_Misc"
### 0.081s elapsed time, 0.310s cpu time, 0.022s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.All_ExamplesTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
### theory "Draft.State_Monad_Ext"
### 0.070s elapsed time, 0.259s cpu time, 0.022s GC time
Loading theory "Draft.DP_CRelVS" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap" via "Draft.State_Heap")
locale prod_order_def
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "{}"
### theory "HOL-Library.Function_Algebras"
### 0.109s elapsed time, 0.441s cpu time, 0.000s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.All_ExamplesTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
locale state_mem_defs
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
### theory "Draft.Solve_Cong"
### 0.261s elapsed time, 1.059s cpu time, 0.022s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.All_ExamplesTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
locale mem_correct
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
  assumes "mem_correct lookup update P"
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
locale prod_order
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
  assumes "prod_order less_eq0 less0 less_eq1 less1"
### theory "Draft.DP_CRelVS"
### 0.428s elapsed time, 1.675s cpu time, 0.167s GC time
Loading theory "Draft.Memory" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap" via "Draft.Pair_Memory")
### theory "HOL-Library.Set_Algebras"
### 0.288s elapsed time, 1.117s cpu time, 0.167s GC time
Loading theory "Draft.Templates" (required by "Draft.All_ExamplesTemplates" via "Draft.ExtrEqs")
locale option_order
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
  assumes "option_order less_eq0 less0"
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.056s elapsed time, 0.222s cpu time, 0.000s GC time
Loading theory "Draft.Heap_Monad_Ext" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap" via "Draft.State_Heap")
bundle heap_monad_syntax
consts
  shift :: "'a list => 'a stream => 'a stream"
### theory "Draft.Heap_Monad_Ext"
### 0.042s elapsed time, 0.163s cpu time, 0.000s GC time
Loading theory "Draft.State_Heap" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap")
Proofs for coinductive predicate(s) "streamsp"
Found termination order: "{}"
  Proving monotonicity ...
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
Found termination order: "{}"
consts
  snth :: "'a stream => nat => 'a"
locale dp_consistency_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and dp :: "'a => 'c"
    and empty :: "'b"
  assumes "dp_consistency_empty lookup update P empty"
locale dp_consistency_default
  fixes dp :: "'param => 'result"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
locale dp_consistency_mapping
  fixes dp :: "'param => 'result"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
locale state_mem_defs
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
locale mem_correct
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
  assumes "mem_correct lookup update P"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
locale dp_consistency_mapping_tracing
  fixes dp :: "'param => 'result"
consts
  flat :: "'a list stream => 'a stream"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
### theory "Draft.Memory"
### 0.627s elapsed time, 2.330s cpu time, 0.558s GC time
Loading theory "Draft.Bottom_Up_Computation" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Bottom_Up_Computation_Heap")
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
locale heap_mem_defs
  fixes P :: "heap => bool"
    and lookup :: "'k => 'v option Heap"
    and update :: "'k => 'v => unit Heap"
### Ambiguous input (line 63 of "$AFP/Monad_Memo_DP/heap_monad/State_Heap.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" rel_state)
###     ("_cargs" ("_position" R) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>HOL.All_binder" ("_position" heap)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" heap))
###       ("_case_syntax"
###         ("_applC" ("_position" State_Monad.run_state)
###           ("_cargs" ("_position" f) ("_position" heap)))
###         ("_case1"
###           ("_tuple" ("_position" v1) ("_tuple_arg" ("_position" heap1)))
###           ("_case_syntax"
###             ("_applC" ("_position" execute)
###               ("_cargs" ("_position" g) ("_position" heap)))
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" v2)
###                     ("_tuple_arg" ("_position" heap2))))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" R)
###                     ("_cargs" ("_position" v1) ("_position" v2)))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_position" heap1)
###                       ("_position" heap2))
###                     ("_applC" ("_position" P) ("_position" heap2)))))
###               ("_case1" ("_position" None) ("_position" False)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" rel_state)
###     ("_cargs" ("_position" R) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>HOL.All_binder" ("_position" heap)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" heap))
###       ("_case_syntax"
###         ("_applC" ("_position" State_Monad.run_state)
###           ("_cargs" ("_position" f) ("_position" heap)))
###         ("_case2"
###           ("_case1"
###             ("_tuple" ("_position" v1) ("_tuple_arg" ("_position" heap1)))
###             ("_case_syntax"
###               ("_applC" ("_position" execute)
###                 ("_cargs" ("_position" g) ("_position" heap)))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" v2)
###                     ("_tuple_arg" ("_position" heap2))))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" R)
###                     ("_cargs" ("_position" v1) ("_position" v2)))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_position" heap1)
###                       ("_position" heap2))
###                     ("_applC" ("_position" P) ("_position" heap2)))))))
###           ("_case1" ("_position" None) ("_position" False)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "HOL-Library.Stream"
### 0.994s elapsed time, 3.758s cpu time, 0.725s GC time
Loading theory "Draft.Pair_Memory" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap")
locale pair_mem_defs
  fixes lookup1 :: "'a => ('mem, 'v option) state"
    and lookup2 :: "'a => ('mem, 'v option) state"
    and update1 :: "'a => 'v => ('mem, unit) state"
    and update2 :: "'a => 'v => ('mem, unit) state"
    and move12 :: "'k1 => ('mem, unit) state"
    and get_k1 :: "('mem, 'k1) state"
    and get_k2 :: "('mem, 'k1) state"
    and P :: "'mem => bool"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'a"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale iterator_defs
  fixes cnt :: "'a => bool"
    and nxt :: "'a => 'a"
locale iterator
  fixes cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "iterator cnt nxt sizef"
locale heap_inv
  fixes P :: "heap => bool"
    and update :: "'k => 'v => unit Heap"
    and lookup :: "'k => 'v option Heap"
  assumes "heap_inv P update lookup"
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
locale heap_correct
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
  assumes "heap_correct P update lookup"
locale index_locale_def
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
locale dp_consistency_iterator
  fixes P :: "'b => bool"
    and dp :: "'a => 'c"
    and lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "dp_consistency_iterator P lookup update cnt nxt sizef"
locale heap_mem_defs
  fixes P :: "heap => bool"
    and lookup :: "'k => 'v option Heap"
    and update :: "'k => 'v => unit Heap"
### theory "Draft.State_Heap"
### 0.795s elapsed time, 2.971s cpu time, 0.651s GC time
Loading theory "Draft.DP_CRelVH" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main" via "Draft.Memory_Heap")
locale dp_consistency_iterator_empty
  fixes P :: "'a => bool"
    and dp :: "'b => 'c"
    and lookup :: "'b => ('a, 'c option) state"
    and update :: "'b => 'c => ('a, unit) state"
    and cnt :: "'b => bool"
    and nxt :: "'b => 'b"
    and sizef :: "'b => nat"
    and empty :: "'a"
  assumes
    "dp_consistency_iterator_empty P lookup update cnt nxt sizef empty"
### theory "Draft.Bottom_Up_Computation"
### 0.322s elapsed time, 1.257s cpu time, 0.093s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.All_ExamplesTemplates" via "Draft.ExtrEqs")
locale index_locale
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
  assumes "index_locale less_eq less idx size"
locale pair_mem
  fixes lookup1 :: "'a => ('b, 'c option) state"
    and lookup2 :: "'a => ('b, 'c option) state"
    and update1 :: "'a => 'c => ('b, unit) state"
    and update2 :: "'a => 'c => ('b, unit) state"
    and move12 :: "'d => ('b, unit) state"
    and get_k1 :: "('b, 'd) state"
    and get_k2 :: "('b, 'd) state"
    and P :: "'b => bool"
    and key1 :: "'e => 'd"
    and key2 :: "'e => 'a"
  assumes "pair_mem lookup1 lookup2 update1 update2 move12 get_k1 get_k2 P"
locale dp_heap
  fixes P :: "heap => bool"
    and Q :: "heap => bool"
    and dp :: "'k => 'v"
    and lookup :: "'k => 'v option Heap"
    and lookup_st :: "'k => (heap, 'v option) state"
    and update :: "'k => 'v => unit Heap"
    and update_st :: "'k => 'v => (heap, unit) state"
  assumes "dp_heap P Q lookup lookup_st update update_st"
locale prod_index_def
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
    and idx1 :: "'b bound => 'b => nat"
    and size1 :: "'b bound => nat"
Found termination order: "{}"
locale dp_consistency_heap
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
  assumes "dp_consistency_heap P update lookup"
Found termination order: "{}"
locale heap_correct_empty
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and empty :: "heap"
  assumes "heap_correct_empty P update lookup empty"
locale dp_consistency_heap_empty
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
    and empty :: "heap"
  assumes "dp_consistency_heap_empty P update lookup empty"
### theory "Draft.DP_CRelVH"
### 0.442s elapsed time, 1.746s cpu time, 0.120s GC time
Loading theory "Draft.Bottom_Up_Computation_Heap" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main")
locale prod_index
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
    and idx1 :: "'b bound => 'b => nat"
    and size1 :: "'b bound => nat"
  assumes "prod_index less_eq0 less0 idx0 size0 less_eq1 less1 idx1 size1"
locale option_index
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
  assumes "option_index less_eq0 less0 idx0 size0"
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
Found termination order: "{}"
locale nat_index_def
locale dp_consistency_iterator_heap
  fixes lookup :: "'a => 'c option Heap"
    and update :: "'a => 'c => unit Heap"
    and P :: "heap => bool"
    and dp :: "'a => 'c"
    and cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "dp_consistency_iterator_heap lookup update P cnt nxt sizef"
### theory "HOL-Library.BigO"
### 1.058s elapsed time, 3.991s cpu time, 0.965s GC time
Loading theory "Draft.Transform_Cmd" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main")
### theory "Draft.Bottom_Up_Computation_Heap"
### 0.674s elapsed time, 2.483s cpu time, 0.845s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.All_ExamplesTemplates")
Found termination order: "{}"
### theory "Draft.Pair_Memory"
### 1.341s elapsed time, 5.099s cpu time, 1.017s GC time
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"iter_heap"
  :: "('a => 'b Heap) => 'a => unit Heap"
"crel_vs"
  :: "('b => 'd => bool) => 'b => 'd Heap => bool"
### ML warning (line 17 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (import_function_info) has not been referenced.
### ML warning (line 27 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Pattern is not exhaustive.
### ML warning (line 30 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (head_of) has not been referenced.
### ML warning (line 31 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (bind_of) has not been referenced.
signature TRANSFORM_MISC =
  sig
    val add_function:
       binding -> term list -> local_theory -> Function.info * local_theory
    val behead: term -> term -> term * term list
    val get_const_pat: Proof.context -> string -> term
    val locale_term: Proof.context -> string -> string -> term
    val locale_thms: Proof.context -> string -> string -> thm list
    val rel_of: Function.info -> Proof.context -> thm
    val term_name: term -> string
    val the_element: int list -> int
    val totality_of: Function.info -> thm
    val uncurry: term -> term
  end
structure Transform_Misc: TRANSFORM_MISC
Found termination order: "{}"
### ML warning (line 18 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (pureapp) has not been referenced.
### ML warning (line 32 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (memT) has not been referenced.
### ML warning (line 45 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmem') has not been referenced.
### ML warning (line 48 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmemC) has not been referenced.
### ML warning (line 80 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmem') has not been referenced.
### ML warning (line 83 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmemC) has not been referenced.
signature TRANSFORM_CONST =
  sig
    type MONAD_CONSTS =
       {app: term * term -> term,
        checkmemVN: string,
        if_termN: string,
        mk_stateT: typ -> typ,
        monad_name: string,
        return: term -> term, rewrite_app_beta_conv: conv}
    val get_monad_const: string -> MONAD_CONSTS
  end
structure Transform_Const: TRANSFORM_CONST
### ML warning (line 104 of "$AFP/Monad_Memo_DP/transform/Transform_Data.ML"):
### Value identifier (put_monadified_terms_generic) has not been referenced.
signature TRANSFORM_DATA =
  sig
    val add_tmp_cmd_info:
       binding * term * string option -> local_theory -> local_theory
    type cmd_info =
       {dp_info: dp_info option,
        head: term, locale: string option, scope: binding}
    val commit_dp_info: string -> dp_info -> local_theory -> local_theory
    type dp_info =
       {new_def': thm list,
        new_defT: thm,
        new_head': term,
        new_headT: term, old_defs: thm list, old_head: term}
    val get_dp_info: string -> Proof.context -> term -> dp_info option
    val get_last_cmd_info: Proof.context -> cmd_info
    val get_or_last_cmd_info:
       Proof.context -> (string * term) option -> cmd_info
  end
structure Transform_Data: TRANSFORM_DATA
### ML warning (line 28 of "$AFP/Monad_Memo_DP/transform/Transform_Tactic.ML"):
### Value identifier (msg) has not been referenced.
signature TRANSFORM_TACTIC =
  sig
    val dp_unfold_defs_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val my_print_tac: string -> tactic
    val prepare_case_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val prepare_combinator_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val prepare_consistentDP_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val solve_consistentDP_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val solve_relator_tac: Proof.context -> int -> tactic
    val step_tac: Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val totality_replay_tac:
       Function.info -> Function.info -> Proof.context -> tactic
    val totality_resolve_tac: thm -> thm -> thm -> Proof.context -> tactic
    val transfer_raw_tac: Proof.context -> int -> tactic
  end
structure Transform_Tactic: TRANSFORM_TACTIC
locale nat_index
  assumes "nat_index"
locale int_index_def
Found termination order: "{}"
### ML warning (line 22 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (eta_conv_n) has not been referenced.
### ML warning (line 33 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (app_unmark_conv) has not been referenced.
### ML warning (line 36 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (eta_expand) has not been referenced.
### ML warning (line 282 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (monadify) has not been referenced.
signature TRANSFORM_TERM =
  sig
    val lift_equation:
       Transform_Const.MONAD_CONSTS ->
         Proof.context ->
           term * term ->
             term option -> (Proof.context -> conv) * term * int
    val repeat_sweep_conv: (Proof.context -> conv) -> Proof.context -> conv
    val rewrite_pureapp_beta_conv: conv
    val wrap_head: Transform_Const.MONAD_CONSTS -> term -> int -> term
  end
structure Transform_Term: TRANSFORM_TERM
Found termination order: "{}"
### ML warning (line 140 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Value identifier (prep_term) has not been referenced.
### ML warning (line 154 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Value identifier (dp_monadify_cmd) has not been referenced.
### ML warning (line 217 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Pattern is not exhaustive.
signature TRANSFORM_DP =
  sig
    val dp_correct_cmd: local_theory -> Proof.state
    val dp_fun_part1_cmd:
       (binding * string) *
       ((bool * (xstring * Position.T)) * (string * string) list) option
         -> local_theory -> local_theory
    val dp_fun_part2_cmd:
       string * (Facts.ref * Token.src list) list ->
         local_theory -> local_theory
  end
structure Transform_DP: TRANSFORM_DP
### ML warning (line 11 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (dp_fun_parser) has not been referenced.
### ML warning (line 19 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (memoizes_parser) has not been referenced.
### ML warning (line 22 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (monadifies_parser) has not been referenced.
### ML warning (line 29 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (dp_monadify_cmd_parser) has not been referenced.
signature TRANSFORM_PARSER =
  sig
    val dp_fun_part1_parser:
       ((binding * string) *
        ((bool * (string * Position.T)) * (string * string) list) option
       )
       parser
    val dp_fun_part2_parser:
       (string * (Facts.ref * Token.src list) list) parser
  end
structure Transform_Parser: TRANSFORM_PARSER
### theory "Draft.Transform_Cmd"
### 0.368s elapsed time, 1.124s cpu time, 0.096s GC time
Loading theory "Draft.State_Main" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Example_Misc")
locale int_index
  assumes "int_index"
class index = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
  assumes
    "is_locale":
      "index_locale index_class.less_eq index_class.less idx
        index_class.size"
locale bounded_index
  fixes bound :: "'k bound"
instantiation
  nat :: index
  less_eq_nat == index_class.less_eq :: nat => nat => bool
  less_nat == index_class.less :: nat => nat => bool
  idx_nat == idx :: nat bound => nat => nat
  size_nat == index_class.size :: nat bound => nat
index_locale (<=) (<) local.idx local.size
instantiation
  int :: index
  less_eq_int == index_class.less_eq :: int => int => bool
  less_int == index_class.less :: int => int => bool
  idx_int == idx :: int bound => int => nat
  size_int == index_class.size :: int bound => nat
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
index_locale (<=) (<) local.idx local.size
instantiation
  prod :: (index, index) index
  less_eq_prod == index_class.less_eq :: 'a * 'b => 'a * 'b => bool
  less_prod == index_class.less :: 'a * 'b => 'a * 'b => bool
  idx_prod == idx :: ('a * 'b) bound => 'a * 'b => nat
  size_prod == index_class.size :: ('a * 'b) bound => nat
Found termination order: "{}"
termination by default prover
consts
  comp\<^sub>T' ::
    "('c => ('e, 'b) state)
     => ('a => ('e, 'c) state) => ('d, 'a => ('e, 'b) state) state"
  comp\<^sub>T ::
    "('g,
      ('c => ('e, 'b) state)
      => ('f,
          ('a => ('e, 'c) state)
          => ('d, 'a => ('e, 'b) state) state) state) state"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.710s elapsed time, 2.158s cpu time, 0.170s GC time
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  map\<^sub>T' :: "('b => ('c, 'a) state) => 'b list => ('c, 'a list) state"
  map\<^sub>T ::
    "('e,
      ('b => ('c, 'a) state)
      => ('d, 'b list => ('c, 'a list) state) state) state"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  fold\<^sub>T' ::
    "('b => ('c, 'a => ('d, 'a) state) state)
     => 'b list => ('c, 'a => ('d, 'a) state) state"
  fold\<^sub>T ::
    "('f,
      ('b => ('c, 'a => ('d, 'a) state) state)
      => ('e, 'b list => ('c, 'a => ('d, 'a) state) state) state) state"
[| ?xs = ?ys; !!x. x : set ?ys ==> ?f x = ?g x |]
==> map ?f ?xs = map ?g ?ys
[| ?a = ?b; ?xs = ?ys; !!x. x : set ?xs ==> ?f x = ?g x |]
==> fold ?f ?xs ?a = fold ?g ?ys ?b
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
index_locale local.less_eq local.less local.idx local.size
### Type
### (int * int) bound => nat
### of constant "Indexing.bounded_index.size"
### is too specific compared to declared type
### ?'k::{} bound => nat, in theorem:
### bounded_index.size (Bound (?l1.0, ?l2.0) (?u1.0, ?u2.0)) ==
### nat (?u1.0 - ?l1.0) * nat (?u2.0 - ?l2.0)
### theory "Draft.Indexing"
### 3.643s elapsed time, 12.730s cpu time, 2.052s GC time
Loading theory "Draft.Memory_Heap" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford" via "Draft.Heap_Main")
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
[| option = option'; option' = None ==> f1 = g1;
   !!x2. option' = Some x2 ==> f2 x2 = g2 x2 |]
==> (case option of None => f1 | Some x2 => f2 x2) =
    (case option' of None => g1 | Some x2 => g2 x2)
[| prod = prod'; !!x1 x2. prod' = (x1, x2) ==> f x1 x2 = g x1 x2 |]
==> (case prod of (x1, x2) => f x1 x2) = (case prod' of (x1, x2) => g x1 x2)
[| nat = nat'; nat' = 0 ==> f1 = g1;
   !!x2. nat' = Suc x2 ==> f2 x2 = g2 x2 |]
==> (case nat of 0 => f1 | Suc x2 => f2 x2) =
    (case nat' of 0 => g1 | Suc x2 => g2 x2)
### theory "Draft.State_Main"
### 0.789s elapsed time, 1.996s cpu time, 0.150s GC time
Loading theory "Draft.Example_Misc" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford")
Loading theory "Draft.Longest_Common_Subsequence" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples")
### Missing patterns in function definition:
### min_list [] = undefined
Found termination order: "length <*mlex*> {}"
bundle app_syntax
### theory "Draft.Example_Misc"
### 0.391s elapsed time, 1.192s cpu time, 0.136s GC time
Loading theory "Draft.Counting_Tiles" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples")
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. size (snd p)) <*mlex*> (%p. size (fst p)) <*mlex*> {}"
Proofs for inductive predicate(s) "valid"
  Proving monotonicity ...
Proofs for inductive predicate(s) "valid'"
  Proving monotonicity ...
termination by replaying
consts
  lcs\<^sub>m' :: "nat => nat => ((nat * nat, nat) mapping, nat) state"
  lcs\<^sub>m ::
    "('c,
      nat
      => ('b, nat => ((nat * nat, nat) mapping, nat) state) state) state"
theorem
  lcs\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) (%(x, y). local.lcs_ia x y)
     (%(x, y). local.lcs\<^sub>m' x y)
theorem
  lcs\<^sub>m.memoized_correct:
    local.lcs_ia ?a ?b =
    fst (run_state (local.lcs\<^sub>m' ?a ?b) Mapping.empty)
### theory "Draft.Longest_Common_Subsequence"
### 1.759s elapsed time, 5.418s cpu time, 1.399s GC time
### theory "Draft.Memory_Heap"
### 1.919s elapsed time, 5.903s cpu time, 1.472s GC time
Loading theory "Draft.Heap_Main" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford")
Found termination order: "size <*mlex*> {}"
termination by replaying
consts
  lcount\<^sub>m' :: "nat => ((nat, nat) mapping, nat) state"
  lcount\<^sub>m :: "('a, nat => ((nat, nat) mapping, nat) state) state"
theorem
  lcount\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) local.lcount local.lcount\<^sub>m'
theorem
  lcount\<^sub>m.memoized_correct:
    local.lcount ?a =
    fst (run_state (local.lcount\<^sub>m' ?a) Mapping.empty)
### theory "Draft.Counting_Tiles"
### 1.732s elapsed time, 5.661s cpu time, 1.390s GC time
"4"
  :: "nat"
"3"
  :: "nat"
Found termination order: "{}"
termination by default prover
consts
  comp\<^sub>T' ::
    "('c => 'b Heap) => ('a => 'c Heap) => ('a => 'b Heap) Heap"
  comp\<^sub>T ::
    "(('c => 'b Heap)
      => (('a => 'c Heap) => ('a => 'b Heap) Heap) Heap) Heap"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  map\<^sub>T' :: "('b => 'a Heap) => 'b list => 'a list Heap"
  map\<^sub>T :: "(('b => 'a Heap) => ('b list => 'a list Heap) Heap) Heap"
"17"
  :: "nat"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  fold\<^sub>T' ::
    "('b => ('a => 'a Heap) Heap) => 'b list => ('a => 'a Heap) Heap"
  fold\<^sub>T ::
    "(('b => ('a => 'a Heap) Heap)
      => ('b list => ('a => 'a Heap) Heap) Heap) Heap"
"16475640049"
  :: "nat"
"673135"
  :: "nat"
"1089155"
  :: "nat"
"880711"
  :: "nat"
"1148904"
  :: "nat"
locale dp_consistency_heap
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
  assumes "dp_consistency_heap P update lookup"
locale heap_correct_init_defs
  fixes P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
locale heap_correct_init_inv
  fixes P :: "'a => heap => bool"
    and lookup :: "'a => 'b => 'c option Heap"
    and update :: "'a => 'b => 'c => unit Heap"
  assumes "heap_correct_init_inv P lookup update"
locale heap_correct_init
  fixes P :: "'a => heap => bool"
    and lookup :: "'a => 'b => 'c option Heap"
    and update :: "'a => 'b => 'c => unit Heap"
  assumes "heap_correct_init P lookup update"
locale dp_consistency_heap_init
  fixes P :: "'m => heap => bool"
    and update :: "'m => 'k => 'v => unit Heap"
    and lookup :: "'m => 'k => 'v option Heap"
    and dp :: "'k => 'v"
    and init :: "'m Heap"
  assumes "dp_consistency_heap_init P update lookup init"
"1327"
  :: "nat"
locale dp_consistency_heap_init'
  fixes P :: "'m => heap => bool"
    and update :: "'m => 'k => 'v => unit Heap"
    and lookup :: "'m => 'k => 'v option Heap"
    and dp :: "'k => 'v"
    and init :: "'m Heap"
  assumes "dp_consistency_heap_init' P update lookup init"
"297977"
  :: "nat"
"739652"
  :: "nat"
"910165"
  :: "nat"
"978181"
  :: "nat"
"1053389"
  :: "nat"
"1136998"
  :: "nat"
"1909447"
  :: "nat"
"30259917"
  :: "nat"
locale dp_consistency_new
  fixes dp :: "'k => 'v"
    and P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
    and init :: "'m Heap"
  assumes "dp_consistency_new P lookup update init"
"331281812352"
  :: "nat"
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
comp\<^sub>T' ?f ?g =
return
 (%x. Heap_Monad_Ext.fun_app_lifted (return ?f)
       (Heap_Monad_Ext.fun_app_lifted (return ?g) (return x)))
[| ?xs = ?ys; !!x. x : set ?ys ==> ?f x = ?g x |]
==> map ?f ?xs = map ?g ?ys
[| ?a = ?b; ?xs = ?ys; !!x. x : set ?xs ==> ?f x = ?g x |]
==> fold ?f ?xs ?a = fold ?g ?ys ?b
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
[| option = option'; option' = None ==> f1 = g1;
   !!x2. option' = Some x2 ==> f2 x2 = g2 x2 |]
==> (case option of None => f1 | Some x2 => f2 x2) =
    (case option' of None => g1 | Some x2 => g2 x2)
[| prod = prod'; !!x1 x2. prod' = (x1, x2) ==> f x1 x2 = g x1 x2 |]
==> (case prod of (x1, x2) => f x1 x2) = (case prod' of (x1, x2) => g x1 x2)
"53885318746850000447"
  :: "nat"
"16957185221606773207773767450387101315990"
  :: "nat"
locale dp_consistency_new'
  fixes dp :: "'k => 'v"
    and P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
    and init :: "'m Heap"
    and mem :: "'m"
  assumes "dp_consistency_new' P lookup update init mem"
locale dp_consistency_heap_array_new'
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and mem :: "'v option array"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array_new' size to_index mem"
consistentDP (?dp\<^sub>T (result_of (mem_empty size) Heap.empty)) ==>
dp ?x = result_of (mem_empty size >>= (%mem. ?dp\<^sub>T mem ?x)) Heap.empty
locale dp_consistency_heap_array_new
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array_new size to_index"
consistentDP (?dp\<^sub>T (result_of (mem_empty size) Heap.empty)) ==>
dp ?x = result_of (mem_empty size >>= (%mem. ?dp\<^sub>T mem ?x)) Heap.empty
locale dp_consistency_heap_array
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array size to_index"
locale dp_consistency_heap_array_pair'
  fixes size :: "nat"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'k2"
    and to_index :: "'k2 => nat"
    and dp :: "'k => 'v"
    and k1 :: "'k1"
    and k2 :: "'k1"
    and
    mem :: "'k1 ref * 'k1 ref * 'v option array ref * 'v option array ref"
  assumes
    "dp_consistency_heap_array_pair' size key1 key2 to_index k1 k2 mem"
locale dp_consistency_heap_array_pair_iterator
  fixes size :: "nat"
    and key1 :: "'k => 'a"
    and key2 :: "'k => 'b"
    and to_index :: "'b => nat"
    and k1 :: "'a"
    and k2 :: "'a"
    and mem :: "'a ref * 'a ref * 'v option array ref * 'v option array ref"
    and nxt :: "'k => 'k"
    and sizef :: "'k => nat"
    and dp :: "'k => 'v"
    and cnt :: "'k => bool"
  assumes
    "dp_consistency_heap_array_pair_iterator size key1 key2 to_index k1 k2
      mem nxt sizef cnt"
locale dp_consistency_heap_array_pair
  fixes size :: "nat"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'k2"
    and to_index :: "'k2 => nat"
    and dp :: "'k => 'v"
    and k1 :: "'k1"
    and k2 :: "'k1"
  assumes "dp_consistency_heap_array_pair size key1 key2 to_index k1 k2"
### theory "Draft.Heap_Main"
### 3.462s elapsed time, 8.833s cpu time, 0.708s GC time
Loading theory "Draft.Heap_Default" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Knapsack")
Loading theory "Draft.Tracing" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples" via "Draft.Bellman_Ford")
locale dp_consistency_heap_default
  fixes bound :: "'k bound"
    and mem :: "'v option array"
    and dp :: "'k => 'v"
### theory "Draft.Heap_Default"
### 0.170s elapsed time, 0.342s cpu time, 0.000s GC time
Loading theory "Draft.CYK" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples")
Loading theory "Draft.Knapsack" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples")
Loading theory "Draft.OptBST" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples")
### theory "Draft.Tracing"
### 0.444s elapsed time, 1.415s cpu time, 0.050s GC time
Loading theory "Draft.Bellman_Ford" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples")
Found termination order: "(%p. size_class.size (fst p)) <*mlex*> {}"
termination by replaying
consts
  knapsack\<^sub>m' :: "nat => nat => ((nat * nat, nat) mapping, nat) state"
  knapsack\<^sub>m ::
    "('b,
      nat
      => ('a, nat => ((nat * nat, nat) mapping, nat) state) state) state"
theorem
  knapsack\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) (%(x, y). local.knapsack x y)
     (%(x, y). local.knapsack\<^sub>m' x y)
theorem
  knapsack\<^sub>m.memoized_correct:
    local.knapsack ?a ?b =
    fst (run_state (local.knapsack\<^sub>m' ?a ?b) Mapping.empty)
### Missing patterns in function definition:
### !!a. argmin a [] = undefined
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "(%p. size_class.size (snd (snd p))) <*mlex*> {}"
locale dp_consistency_iterator
  fixes P :: "'b => bool"
    and dp :: "'a => 'c"
    and lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "dp_consistency_iterator P lookup update cnt nxt sizef"
instantiation
  extended :: (conditionally_complete_lattice) complete_lattice
  Inf_extended == Inf :: 'a extended set => 'a extended
  Sup_extended == Sup :: 'a extended set => 'a extended
Proofs for inductive predicate(s) "yield"
  Proving monotonicity ...
termination by replaying
consts
  knapsack\<^sub>T' :: "nat => nat => nat Heap"
  knapsack\<^sub>T :: "(nat => (nat => nat Heap) Heap) Heap"
### Undefined fact: "knapsack\<^sub>T.memoized"
theorem
  knapsack\<^sub>T.crel:
    knapsack\<^sub>T.consistentDP (%(x, y). local.knapsack\<^sub>T' x y)
Found termination order: "(%p. size_class.size (fst p)) <*mlex*> {}"
### Missing patterns in function definition:
### weight [] = undefined
Found termination order: "length <*mlex*> {}"
Found termination order: "size_list size_class.size <*mlex*> {}"
termination by replaying
consts
  su\<^sub>m' :: "nat => nat => ((nat * nat, nat) mapping, nat) state"
  su\<^sub>m ::
    "('b,
      nat
      => ('a, nat => ((nat * nat, nat) mapping, nat) state) state) state"
theorem
  su\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) (%(x, y). local.su x y) (%(x, y). local.su\<^sub>m' x y)
theorem
  su\<^sub>m.memoized_correct:
    local.su ?a ?b = fst (run_state (local.su\<^sub>m' ?a ?b) Mapping.empty)
termination by replaying
consts
  min_wpl\<^sub>T' :: "int => int => nat Heap"
  min_wpl\<^sub>T :: "(int => (int => nat Heap) Heap) Heap"
### Undefined fact: "min_wpl\<^sub>T.memoized"
theorem
  min_wpl\<^sub>T.crel:
    min_wpl\<^sub>T.consistentDP (%(x, y). local.min_wpl\<^sub>T' x y)
Found termination order: "(%p. size_class.size (fst p)) <*mlex*> {}"
Found termination order: "(%p. size_class.size (snd (snd p))) <*mlex*> {}"
termination by replaying
consts
  min_wpl\<^sub>m' :: "int => int => [(int * int, nat) mapping| nat]"
  min_wpl\<^sub>m ::
    "['b| int => ['a| int => [(int * int, nat) mapping| nat]]]"
theorem
  min_wpl\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#)) (%_. True)
     (%(x, y). local.min_wpl x y) (%(x, y). local.min_wpl\<^sub>m' x y)
theorem
  min_wpl\<^sub>m.memoized_correct:
    local.min_wpl ?a ?b =
    fst (run_state (local.min_wpl\<^sub>m' ?a ?b) Mapping.empty)
Warning: Value identifier (t) has not been referenced.
At (line 19 of "generated code")
Warning: Value identifier (less) has not been referenced.
At (line 41 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 66 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 82 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 84 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 93 of "generated code")
Warning: Value identifier (B_) has not been referenced.
At (line 96 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 96 of "generated code")
Warning: Matches are not exhaustive.
fun nth (x :: xs) n = (if ... ... zero_nat then x else ... ... (... ...))
At (line 147 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 150 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 153 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 155 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 193 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 203 of "generated code")
structure Test: sig val knapsack_test: unit -> nat type nat type num end
val it = Nat 7: Test.nat
### theory "Draft.Knapsack"
### 2.658s elapsed time, 10.368s cpu time, 1.186s GC time
Loading theory "Draft.Min_Ed_Dist0" (required by "Draft.All_ExamplesTemplates" via "Draft.All_Examples")
termination by replaying
consts
  bf\<^sub>m' ::
    "nat => nat => ((nat * nat, int extended) mapping, int extended) state"
  bf\<^sub>m ::
    "('b,
      nat
      => ('a,
          nat
          => ((nat * nat, int extended) mapping,
              int extended) state) state) state"
theorem
  bf\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) (%(x, y). local.bf x y) (%(x, y). local.bf\<^sub>m' x y)
theorem
  bf\<^sub>m.memoized_correct:
    local.bf ?a ?b = fst (run_state (local.bf\<^sub>m' ?a ?b) Mapping.empty)
Found termination order: "(%p. size_class.size (snd p)) <*mlex*> {}"
termination by replaying
consts
  opt_bst\<^sub>m' ::
    "int => int => [(int * int, int tree) mapping| int tree]"
  opt_bst\<^sub>m ::
    "['b| int => ['a| int => [(int * int, int tree) mapping| int tree]]]"
theorem
  opt_bst\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#)) (%_. True)
     (%(x, y). local.opt_bst x y) (%(x, y). local.opt_bst\<^sub>m' x y)
theorem
  opt_bst\<^sub>m.memoized_correct:
    local.opt_bst ?a ?b =
    fst (run_state (local.opt_bst\<^sub>m' ?a ?b) Mapping.empty)
Found termination order: "size_class.size <*mlex*> {}"
### Additional type variable(s) in specification of "cyk_ix\<^sub>m'_rel": 'n
### Additional type variable(s) in specification of "cyk_ix\<^sub>m'_dom": 'n
Found termination order: "(%p. size_class.size (snd p)) <*mlex*> {}"
Found termination order: "{}"
Found termination order: "(%p. size_class.size (snd p)) <*mlex*> {}"
termination by default prover
consts
  cyk_ix\<^sub>m' ::
    "nat * nat => ((nat * nat, 'n list) mapping, 'n list) state"
  cyk_ix\<^sub>m ::
    "('a, nat * nat => ((nat * nat, 'n list) mapping, 'n list) state) state"
theorem
  cyk_ix\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) local.cyk_ix local.cyk_ix\<^sub>m'
theorem
  cyk_ix\<^sub>m.memoized_correct:
    local.cyk_ix ?a =
    fst (run_state (local.cyk_ix\<^sub>m' ?a) Mapping.empty)
termination by replaying
consts
  W\<^sub>m' :: "int => int => ((int * int, nat) mapping, nat) state"
  W\<^sub>m ::
    "('b,
      int
      => ('a, int => ((int * int, nat) mapping, nat) state) state) state"
theorem
  W\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) (%(x, y). local.W_fun x y) (%(x, y). local.W\<^sub>m' x y)
theorem
  W\<^sub>m.memoized_correct:
    local.W_fun ?a ?b =
    fst (run_state (local.W\<^sub>m' ?a ?b) Mapping.empty)
termination by replaying
consts
  bf\<^sub>h' :: "nat => nat => int extended Heap"
  bf\<^sub>h :: "(nat => (nat => int extended Heap) Heap) Heap"
theorem
  bf\<^sub>h.crel: bf\<^sub>h.consistentDP (%(x, y). local.bf\<^sub>h' x y)
theorem
  bf\<^sub>h.memoized_correct:
    local.bf ?a ?b =
    result_of (local.bf\<^sub>h' ?a ?b)
     (heap_of (init_state (n + 1) 1 0) Heap.empty)
### Missing patterns in function definition:
### !!a. argmin a [] = undefined
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### !!a. argmin2 a [] = undefined
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### Additional type variable(s) in specification of "cyk_ix\<^sub>h'_rel": 'n
### Additional type variable(s) in specification of "cyk_ix\<^sub>h'_dom": 'n
Found termination order:
  "(%p. size_class.size (fst (snd (snd (snd (snd p)))))) <*mlex*> {}"
Found termination order: "(%p. size_class.size (snd p)) <*mlex*> {}"
termination by default prover
Warning: Value identifier (t) has not been referenced.
At (line 20 of "generated code")
Warning: Value identifier (less) has not been referenced.
At (line 48 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 68 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 84 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 101 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 103 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 112 of "generated code")
Warning: Value identifier (B_) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 160 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 163 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 165 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 216 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 226 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 233 of "generated code")
Warning: Matches are not exhaustive.
fun min_list A_ (... :: ...) = (case xs of [...] => x | ... => ...)
At (line 247 of "generated code")
structure Test:
  sig type inta val min_wpl_test: unit -> nat type nat type num end
val it = Nat 10: Test.nat
### theory "Draft.OptBST"
### 4.476s elapsed time, 17.411s cpu time, 2.073s GC time
consts
  cyk_ix\<^sub>h' :: "nat * nat => 'n list Heap"
  cyk_ix\<^sub>h :: "(nat * nat => 'n list Heap) Heap"
### Undefined fact: "cyk_ix\<^sub>h.memoized"
theorem
  cyk_ix\<^sub>h.crel: cyk_ix\<^sub>h.consistentDP local.cyk_ix\<^sub>h'
"''3''"
  :: "char list"
local.knapsack\<^sub>m' 0 ?W =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (0, ?W) #0#
local.knapsack\<^sub>m' (Suc ?i) ?W =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (Suc ?i, ?W)
 (State_Monad_Ext.if\<^sub>T #?W < w (Suc ?i)#
   (local.knapsack\<^sub>m' ?i ?W)
   (#%a. #%b. #max a b### . (local.knapsack\<^sub>m' ?i ?W) .
    (#%a. #v (Suc ?i) + a## .
     (local.knapsack\<^sub>m' ?i (?W - w (Suc ?i))))))
local.knapsack\<^sub>m == #%uu_. #local.knapsack\<^sub>m' uu_##
local.knapsack\<^sub>T' 0 ?Wa = knapsack\<^sub>T.checkmem (0, ?Wa) #0#
local.knapsack\<^sub>T' (Suc ?i) ?Wa =
knapsack\<^sub>T.checkmem (Suc ?i, ?Wa)
 (Heap_Monad_Ext.if\<^sub>T #?Wa < w (Suc ?i)#
   (local.knapsack\<^sub>T' ?i ?Wa)
   (#%a. #%b. #max a b### . (local.knapsack\<^sub>T' ?i ?Wa) .
    (#%a. #v (Suc ?i) + a## .
     (local.knapsack\<^sub>T' ?i (?Wa - w (Suc ?i))))))
local.knapsack\<^sub>T == #%uu_. #local.knapsack\<^sub>T' uu_##
local.su\<^sub>m' 0 ?W =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (0, ?W) #0#
local.su\<^sub>m' (Suc ?i) ?W =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (Suc ?i, ?W)
 (State_Monad_Ext.if\<^sub>T #?W < w (Suc ?i)# (local.su\<^sub>m' ?i ?W)
   (#%a. #%b. #max a b### . (local.su\<^sub>m' ?i ?W) .
    (#%a. #w (Suc ?i) + a## . (local.su\<^sub>m' ?i (?W - w (Suc ?i))))))
local.su\<^sub>m == #%uu_. #local.su\<^sub>m' uu_##
local.min_wpl\<^sub>T' ?i ?j =
min_wpl\<^sub>T.checkmem (?i, ?j)
 (Heap_Monad_Ext.if\<^sub>T #?j < ?i# #0#
   (#%a. #Example_Misc.min_list a## .
    (Heap_Main.map\<^sub>T .
     #%k. #%a. #%b. #a + b### .
          (#%a. #%b. #a + b### . (local.min_wpl\<^sub>T' ?i (k - 1)) .
           (local.min_wpl\<^sub>T' (k + 1) ?j)) .
          #W ?i ?j## .
     #[?i..?j]#)))
local.min_wpl\<^sub>T == #%uu_. #local.min_wpl\<^sub>T' uu_##
local.min_wpl\<^sub>m' ?i ?j =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, ?j)
 (State_Monad_Ext.if\<^sub>T #?j < ?i# #0#
   (#%a. #Example_Misc.min_list a## .
    (State_Main.map\<^sub>T .
     #%k. #%a. #%b. #a + b### .
          (#%a. #%b. #a + b### . (local.min_wpl\<^sub>m' ?i (k - 1)) .
           (local.min_wpl\<^sub>m' (k + 1) ?j)) .
          #W ?i ?j## .
     #[?i..?j]#)))
local.bf\<^sub>m' 0 ?v =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (0, ?v) #if t = ?v then 0 else \<infinity>#
local.bf\<^sub>m' (Suc ?i) ?v =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (Suc ?i, ?v)
 (#%a. #Example_Misc.min_list a## .
  (#%a. #%b. #a # b### . (local.bf\<^sub>m' ?i ?v) .
   (State_Main.map\<^sub>T .
    #%w. #%a. #W ?v w + a## . (local.bf\<^sub>m' ?i w)# .
    #[0..<Suc n]#)))
local.bf\<^sub>m == #%uu_. #local.bf\<^sub>m' uu_##
local.opt_bst\<^sub>m' ?i ?j =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, ?j)
 (State_Monad_Ext.if\<^sub>T #?j < ?i# #\<langle>\<rangle>#
   (#%a. #argmin (local.wpl ?i ?j) a## .
    (State_Main.map\<^sub>T .
     #%k. #%a. #%b. #%c. #\<langle>a, b, c\<rangle>#### .
          (local.opt_bst\<^sub>m' ?i (k - 1)) .
          #k# .
          (local.opt_bst\<^sub>m' (k + 1) ?j)# .
     #[?i..?j]#)))
local.cyk_ix\<^sub>m' (?i, 0) =
state_mem_defs.checkmem
 (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, 0) (State_Monad.return [])
local.cyk_ix\<^sub>m' (?i, Suc 0) =
state_mem_defs.checkmem
 (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, Suc 0)
 (State_Monad.return
   (concat
     (map (%(A, y).
              case_rhs (%n1 n2. []) (%a. if a = w ?i then [A] else []) y)
       P)))
local.cyk_ix\<^sub>m' (?i, Suc (Suc ?va)) =
state_mem_defs.checkmem
 (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, Suc (Suc ?va))
 (State_Monad_Ext.fun_app_lifted
   (State_Monad.return (%a. State_Monad.return (concat a)))
   (State_Monad_Ext.fun_app_lifted
     (State_Monad_Ext.fun_app_lifted State_Main.map\<^sub>T
       (State_Monad.return
         (%k. State_Monad_Ext.fun_app_lifted
               (State_Monad.return (%a. State_Monad.return (concat a)))
               (State_Monad_Ext.fun_app_lifted
                 (State_Monad_Ext.fun_app_lifted State_Main.map\<^sub>T
                   (State_Monad.return
                     (%B. State_Monad_Ext.fun_app_lifted
                           (State_Monad.return
                             (%a. State_Monad.return (concat a)))
                           (State_Monad_Ext.fun_app_lifted
                             (State_Monad.return
                               (%a. State_Monad.return
                                     (map
 (%C. concat
       (map (%(A, y).
                case_rhs
                 (%B' C'. if B' = B then if C' = C then [A] else [] else [])
                 (%t. []) y)
         P))
 a)))
                             (local.cyk_ix\<^sub>m'
                               (?i + k, Suc (Suc ?va) - k))))))
                 (local.cyk_ix\<^sub>m' (?i, k))))))
     (State_Monad.return [1..<Suc (Suc ?va)])))
Found termination order:
  "(%p. length (snd p)) <*mlex*>
   (%p. size_list size_class.size (fst p)) <*mlex*> {}"
Warning: Value identifier (t) has not been referenced.
At (line 21 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 47 of "generated code")
Warning: Value identifier (less) has not been referenced.
At (line 62 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 83 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 99 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 101 of "generated code")
Warning: Pattern 3 is redundant.
fun
   equal_bool p true = p |
      equal_bool p ... = not p |
      equal_bool ... = p |
      equal_bool ... = ...
At (line 112 of "generated code")
Warning: Pattern 4 is redundant.
fun
   equal_bool p true = p |
      equal_bool p ... = not p |
      equal_bool ... = p |
      equal_bool ... = ...
At (line 113 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 129 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 131 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 140 of "generated code")
Warning: Value identifier (B_) has not been referenced.
At (line 143 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 143 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 200 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 205 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 210 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 241 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 246 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 256 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 258 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 265 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 277 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 282 of "generated code")
structure Test:
  sig
    type char
    type inta
    type num
    type ('a, 'b) rhs
    val test: (unit -> inta list) list
  end
val it =
   [[Int_of_integer 0, Int_of_integer 1, Int_of_integer 1, Int_of_integer 0,
     Int_of_integer 3],
    [Int_of_integer 2]]:
   Test.inta list list
### theory "Draft.CYK"
### 5.310s elapsed time, 20.632s cpu time, 2.439s GC time
local.cyk_ix\<^sub>h' (?i, 0) = cyk_ix\<^sub>h.checkmem (?i, 0) #[]#
local.cyk_ix\<^sub>h' (?i, Suc 0) =
cyk_ix\<^sub>h.checkmem (?i, Suc 0)
 #concat
   (map (%(A, y).
            case_rhs (%n1 n2. []) (%a. if a = w ?i then [A] else []) y)
     P)#
local.cyk_ix\<^sub>h' (?i, Suc (Suc ?va)) =
cyk_ix\<^sub>h.checkmem (?i, Suc (Suc ?va))
 (#%a. #concat a## .
  (Heap_Main.map\<^sub>T .
   #%k. #%a. #concat a## .
        (Heap_Main.map\<^sub>T .
         #%B. #%a. #concat a## .
              (#%a. #map (%C. concat
                               (map (%(A, y).
  case_rhs (%B' C'. if B' = B then if C' = C then [A] else [] else [])
   (%t. []) y)
                                 P))
                      a## .
               (local.cyk_ix\<^sub>h' (?i + k, Suc (Suc ?va) - k)))# .
         (local.cyk_ix\<^sub>h' (?i, k)))# .
   #[1..<Suc (Suc ?va)]#))
local.cyk_ix\<^sub>h == #local.cyk_ix\<^sub>h'#
Code_Numeral.dup
  Code_Numeral.dup (Code_Numeral.Neg ?n) == Code_Numeral.Neg (num.Bit0 ?n)
  Code_Numeral.dup (Code_Numeral.Pos ?n) == Code_Numeral.Pos (num.Bit0 ?n)
  Code_Numeral.dup 0 == 0
Code_Numeral.sub
  Code_Numeral.sub (num.Bit0 ?m) (num.Bit1 ?n) ==
  Code_Numeral.dup (Code_Numeral.sub ?m ?n) - Code_Numeral.Pos num.One
  Code_Numeral.sub (num.Bit1 ?m) (num.Bit0 ?n) ==
  Code_Numeral.dup (Code_Numeral.sub ?m ?n) + Code_Numeral.Pos num.One
  Code_Numeral.sub (num.Bit1 ?m) (num.Bit1 ?n) ==
  Code_Numeral.dup (Code_Numeral.sub ?m ?n)
  Code_Numeral.sub (num.Bit0 ?m) (num.Bit0 ?n) ==
  Code_Numeral.dup (Code_Numeral.sub ?m ?n)
  Code_Numeral.sub num.One (num.Bit1 ?n) == Code_Numeral.Neg (num.Bit0 ?n)
  Code_Numeral.sub num.One (num.Bit0 ?n) == Code_Numeral.Neg (Num.BitM ?n)
  Code_Numeral.sub (num.Bit1 ?m) num.One == Code_Numeral.Pos (num.Bit0 ?m)
  Code_Numeral.sub (num.Bit0 ?m) num.One == Code_Numeral.Pos (Num.BitM ?m)
  Code_Numeral.sub num.One num.One == 0
Example_Misc.min_list
  Example_Misc.min_list (?x # ?xs) ==
  case ?xs of [] => ?x | a # list => min ?x (Example_Misc.min_list ?xs)
If
  if False then ?x else ?y == ?y
  if True then ?x else ?y == ?x
Mapping.empty
  Mapping.empty == RBT_Mapping.Mapping RBT.empty
Mapping.lookup
  Mapping.lookup (RBT_Mapping.Mapping ?t) == RBT.lookup ?t
Mapping.update
  Mapping.update ?k ?v (RBT_Mapping.Mapping ?t) ==
  RBT_Mapping.Mapping (RBT.insert ?k ?v ?t)
Num.BitM
  Num.BitM num.One == num.One
  Num.BitM (num.Bit0 ?n) == num.Bit1 (Num.BitM ?n)
  Num.BitM (num.Bit1 ?n) == num.Bit1 (num.Bit0 ?n)
RBT.empty
  rbt.impl_of RBT.empty == rbt.Empty
RBT.insert
  rbt.impl_of (RBT.insert ?xc ?xd ?xe) ==
  rbt_insert ?xc ?xd (rbt.impl_of ?xe)
RBT.lookup
  RBT.lookup ?x == rbt_lookup (rbt.impl_of ?x)
State_Main.map\<^sub>T'
  State_Main.map\<^sub>T' ?f [] == State_Monad.return []
  State_Main.map\<^sub>T' ?f (?x21.0 # ?x22.0) ==
  State_Monad_Ext.fun_app_lifted
   (State_Monad_Ext.fun_app_lifted
     (State_Monad.return
       (%a. State_Monad.return (%b. State_Monad.return (a # b))))
     (State_Monad_Ext.fun_app_lifted (State_Monad.return ?f)
       (State_Monad.return ?x21.0)))
   (State_Main.map\<^sub>T' ?f ?x22.0)
State_Monad.bind
  ?x >>= ?f ==
  State (%s. case run_state ?x s of (a, x) => run_state (?f a) x)
State_Monad.get
  State_Monad.get == State (%s. (s, s))
State_Monad.return
  State_Monad.return ?a == State (Pair ?a)
State_Monad.set
  State_Monad.set ?s == State (%_. ((), ?s))
State_Monad_Ext.fun_app_lifted
  State_Monad_Ext.fun_app_lifted ?f_T ?x_T == ?f_T >>= (>>=) ?x_T
State_Monad_Ext.if\<^sub>T
  State_Monad_Ext.if\<^sub>T ?b_T ?x_T ?y_T ==
  ?b_T >>= (%b. if b then ?x_T else ?y_T)
balance
  balance (Branch color.R ?a ?w ?x ?b) ?s ?t (Branch color.R ?c ?y ?z ?d) ==
  Branch color.R (Branch color.B ?a ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z ?d)
  balance (Branch color.R (Branch color.R ?a ?w ?x ?b) ?s ?t ?c) ?y ?z
   rbt.Empty ==
  Branch color.R (Branch color.B ?a ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z rbt.Empty)
  balance (Branch color.R (Branch color.R ?a ?w ?x ?b) ?s ?t ?c) ?y ?z
   (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.R (Branch color.B ?a ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z (Branch color.B ?va ?vb ?vc ?vd))
  balance (Branch color.R rbt.Empty ?w ?x (Branch color.R ?b ?s ?t ?c)) ?y
   ?z rbt.Empty ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z rbt.Empty)
  balance
   (Branch color.R (Branch color.B ?va ?vb ?vc ?vd) ?w ?x
     (Branch color.R ?b ?s ?t ?c))
   ?y ?z rbt.Empty ==
  Branch color.R (Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z rbt.Empty)
  balance (Branch color.R rbt.Empty ?w ?x (Branch color.R ?b ?s ?t ?c)) ?y
   ?z (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z (Branch color.B ?va ?vb ?vc ?vd))
  balance
   (Branch color.R (Branch color.B ?ve ?vf ?vg ?vh) ?w ?x
     (Branch color.R ?b ?s ?t ?c))
   ?y ?z (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.R (Branch color.B (Branch color.B ?ve ?vf ?vg ?vh) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z (Branch color.B ?va ?vb ?vc ?vd))
  balance rbt.Empty ?w ?x
   (Branch color.R ?b ?s ?t (Branch color.R ?c ?y ?z ?d)) ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z ?d)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?w ?x
   (Branch color.R ?b ?s ?t (Branch color.R ?c ?y ?z ?d)) ==
  Branch color.R (Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z ?d)
  balance rbt.Empty ?w ?x
   (Branch color.R (Branch color.R ?b ?s ?t ?c) ?y ?z rbt.Empty) ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z rbt.Empty)
  balance rbt.Empty ?w ?x
   (Branch color.R (Branch color.R ?b ?s ?t ?c) ?y ?z
     (Branch color.B ?va ?vb ?vc ?vd)) ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z (Branch color.B ?va ?vb ?vc ?vd))
  balance (Branch color.B ?va ?vb ?vc ?vd) ?w ?x
   (Branch color.R (Branch color.R ?b ?s ?t ?c) ?y ?z rbt.Empty) ==
  Branch color.R (Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z rbt.Empty)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?w ?x
   (Branch color.R (Branch color.R ?b ?s ?t ?c) ?y ?z
     (Branch color.B ?ve ?vf ?vg ?vh)) ==
  Branch color.R (Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z (Branch color.B ?ve ?vf ?vg ?vh))
  balance rbt.Empty ?s ?t rbt.Empty ==
  Branch color.B rbt.Empty ?s ?t rbt.Empty
  balance rbt.Empty ?s ?t (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B rbt.Empty ?s ?t (Branch color.B ?va ?vb ?vc ?vd)
  balance rbt.Empty ?s ?t (Branch ?v rbt.Empty ?vb ?vc rbt.Empty) ==
  Branch color.B rbt.Empty ?s ?t (Branch ?v rbt.Empty ?vb ?vc rbt.Empty)
  balance rbt.Empty ?s ?t
   (Branch ?v (Branch color.B ?ve ?vf ?vg ?vh) ?vb ?vc rbt.Empty) ==
  Branch color.B rbt.Empty ?s ?t
   (Branch ?v (Branch color.B ?ve ?vf ?vg ?vh) ?vb ?vc rbt.Empty)
  balance rbt.Empty ?s ?t
   (Branch ?v rbt.Empty ?vb ?vc (Branch color.B ?vf ?vg ?vh ?vi)) ==
  Branch color.B rbt.Empty ?s ?t
   (Branch ?v rbt.Empty ?vb ?vc (Branch color.B ?vf ?vg ?vh ?vi))
  balance rbt.Empty ?s ?t
   (Branch ?v (Branch color.B ?ve ?vj ?vk ?vl) ?vb ?vc
     (Branch color.B ?vf ?vg ?vh ?vi)) ==
  Branch color.B rbt.Empty ?s ?t
   (Branch ?v (Branch color.B ?ve ?vj ?vk ?vl) ?vb ?vc
     (Branch color.B ?vf ?vg ?vh ?vi))
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t rbt.Empty ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t rbt.Empty
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch color.B ?ve ?vf ?vg ?vh) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch color.B ?ve ?vf ?vg ?vh)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v rbt.Empty ?vf ?vg rbt.Empty) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v rbt.Empty ?vf ?vg rbt.Empty)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v (Branch color.B ?vi ?vj ?vk ?vl) ?vf ?vg rbt.Empty) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v (Branch color.B ?vi ?vj ?vk ?vl) ?vf ?vg rbt.Empty)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v rbt.Empty ?vf ?vg (Branch color.B ?vj ?vk ?vl ?vm)) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v rbt.Empty ?vf ?vg (Branch color.B ?vj ?vk ?vl ?vm))
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v (Branch color.B ?vi ?vn ?vo ?vp) ?vf ?vg
     (Branch color.B ?vj ?vk ?vl ?vm)) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v (Branch color.B ?vi ?vn ?vo ?vp) ?vf ?vg
     (Branch color.B ?vj ?vk ?vl ?vm))
  balance (Branch ?v rbt.Empty ?vb ?vc rbt.Empty) ?s ?t rbt.Empty ==
  Branch color.B (Branch ?v rbt.Empty ?vb ?vc rbt.Empty) ?s ?t rbt.Empty
  balance (Branch ?v rbt.Empty ?vb ?vc (Branch color.B ?ve ?vf ?vg ?vh)) ?s
   ?t rbt.Empty ==
  Branch color.B
   (Branch ?v rbt.Empty ?vb ?vc (Branch color.B ?ve ?vf ?vg ?vh)) ?s ?t
   rbt.Empty
  balance (Branch ?v (Branch color.B ?vf ?vg ?vh ?vi) ?vb ?vc rbt.Empty) ?s
   ?t rbt.Empty ==
  Branch color.B
   (Branch ?v (Branch color.B ?vf ?vg ?vh ?vi) ?vb ?vc rbt.Empty) ?s ?t
   rbt.Empty
  balance
   (Branch ?v (Branch color.B ?vf ?vg ?vh ?vi) ?vb ?vc
     (Branch color.B ?ve ?vj ?vk ?vl))
   ?s ?t rbt.Empty ==
  Branch color.B
   (Branch ?v (Branch color.B ?vf ?vg ?vh ?vi) ?vb ?vc
     (Branch color.B ?ve ?vj ?vk ?vl))
   ?s ?t rbt.Empty
  balance (Branch ?v rbt.Empty ?vf ?vg rbt.Empty) ?s ?t
   (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B (Branch ?v rbt.Empty ?vf ?vg rbt.Empty) ?s ?t
   (Branch color.B ?va ?vb ?vc ?vd)
  balance (Branch ?v rbt.Empty ?vf ?vg (Branch color.B ?vi ?vj ?vk ?vl)) ?s
   ?t (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B
   (Branch ?v rbt.Empty ?vf ?vg (Branch color.B ?vi ?vj ?vk ?vl)) ?s ?t
   (Branch color.B ?va ?vb ?vc ?vd)
  balance (Branch ?v (Branch color.B ?vj ?vk ?vl ?vm) ?vf ?vg rbt.Empty) ?s
   ?t (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B
   (Branch ?v (Branch color.B ?vj ?vk ?vl ?vm) ?vf ?vg rbt.Empty) ?s ?t
   (Branch color.B ?va ?vb ?vc ?vd)
  balance
   (Branch ?v (Branch color.B ?vj ?vk ?vl ?vm) ?vf ?vg
     (Branch color.B ?vi ?vn ?vo ?vp))
   ?s ?t (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B
   (Branch ?v (Branch color.B ?vj ?vk ?vl ?vm) ?vf ?vg
     (Branch color.B ?vi ?vn ?vo ?vp))
   ?s ?t (Branch color.B ?va ?vb ?vc ?vd)
case_list
  case ?x21.0 # ?x22.0 of [] => ?f1.0 | x # xa => ?f2.0 x xa ==
  ?f2.0 ?x21.0 ?x22.0
  case [] of [] => ?f1.0 | x # xa => ?f2.0 x xa == ?f1.0
case_option
  case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x == ?f2.0 ?x2.0
  case None of None => ?f1.0 | Some x => ?f2.0 x == ?f1.0
case_prod
  case (?a, ?b) of (x, xa) => ?f x xa == ?f ?a ?b
conj
  ?p & True == ?p
  ?p & False == False
  True & ?p == ?p
  False & ?p == False
disj
  ?p | True == True
  ?p | False == ?p
  True | ?p == True
  False | ?p == ?p
fst
  fst (?x1.0, ?x2.0) == ?x1.0
integer_of_int
  integer_of_int (int_of_integer ?k) == ?k
integer_of_nat
  integer_of_nat (Code_Target_Nat.Nat ?x) == ?x
min
  min ?a ?b == if ?a <= ?b then ?a else ?b
min_wpl
  min_wpl ?w ?a ?b ==
  fst (run_state (min_wpl\<^sub>m' ?w ?a ?b) Mapping.empty)
min_wpl\<^sub>m'
  min_wpl\<^sub>m' ?w ?i ?j ==
  State_Monad.get >>=
  (%m. State_Monad.return (Mapping.lookup m (?i, ?j))) >>=
  case_option
   (State_Monad_Ext.if\<^sub>T (State_Monad.return (?j < ?i))
     (State_Monad.return 0)
     (State_Monad_Ext.fun_app_lifted
       (State_Monad.return
         (%a. State_Monad.return (Example_Misc.min_list a)))
       (State_Monad_Ext.fun_app_lifted
         (State_Monad_Ext.fun_app_lifted
           (State_Monad.return
             (%uu_. State_Monad.return (State_Main.map\<^sub>T' uu_)))
           (State_Monad.return
             (%k. State_Monad_Ext.fun_app_lifted
                   (State_Monad_Ext.fun_app_lifted
                     (State_Monad.return
                       (%a. State_Monad.return
                             (%b. State_Monad.return (a + b))))
                     (State_Monad_Ext.fun_app_lifted
                       (State_Monad_Ext.fun_app_lifted
                         (State_Monad.return
                           (%a. State_Monad.return
                                 (%b. State_Monad.return (a + b))))
                         (min_wpl\<^sub>m' ?w ?i (k - 1)))
                       (min_wpl\<^sub>m' ?w (k + 1) ?j)))
                   (State_Monad.return (?w ?i ?j)))))
         (State_Monad.return [?i..?j]))) >>=
    (%x. State_Monad.get >>=
         (%m. State_Monad.set (Mapping.update (?i, ?j) x m)) >>=
         (%_. State_Monad.return x)))
   State_Monad.return
minus [int]
  ?k - ?l == int_of_integer (integer_of_int ?k - integer_of_int ?l)
minus [integer]
  Code_Numeral.Neg ?m - Code_Numeral.Neg ?n == Code_Numeral.sub ?n ?m
  Code_Numeral.Neg ?m - Code_Numeral.Pos ?n == Code_Numeral.Neg (?m + ?n)
  Code_Numeral.Pos ?m - Code_Numeral.Neg ?n == Code_Numeral.Pos (?m + ?n)
  Code_Numeral.Pos ?m - Code_Numeral.Pos ?n == Code_Numeral.sub ?m ?n
  0 - ?l == - ?l
  ?k - 0 == ?k
one_class.one [int]
  1 == int_of_integer (Code_Numeral.Pos num.One)
ord_class.less [int]
  ?k < ?l == integer_of_int ?k < integer_of_int ?l
ord_class.less [integer]
  Code_Numeral.Neg ?k < Code_Numeral.Neg ?l == ?l < ?k
  Code_Numeral.Neg ?k < Code_Numeral.Pos ?l == True
  Code_Numeral.Neg ?k < 0 == True
  Code_Numeral.Pos ?k < Code_Numeral.Neg ?l == False
  Code_Numeral.Pos ?k < Code_Numeral.Pos ?l == ?k < ?l
  Code_Numeral.Pos ?k < 0 == False
  0 < Code_Numeral.Neg ?l == False
  0 < Code_Numeral.Pos ?l == True
  0 < 0 == False
ord_class.less [nat]
  ?m < ?n == integer_of_nat ?m < integer_of_nat ?n
ord_class.less [num]
  num.Bit1 ?m < num.Bit0 ?n == ?m < ?n
  num.Bit1 ?m < num.Bit1 ?n == ?m < ?n
  num.Bit0 ?m < num.Bit1 ?n == ?m <= ?n
  num.Bit0 ?m < num.Bit0 ?n == ?m < ?n
  num.One < num.Bit1 ?n == True
  num.One < num.Bit0 ?n == True
  ?m < num.One == False
ord_class.less [prod]
  (?x1.0, ?y1.0) < (?x2.0, ?y2.0) ==
  ?x1.0 < ?x2.0 | ?x1.0 <= ?x2.0 & ?y1.0 < ?y2.0
ord_class.less_eq [int]
  ?k <= ?l == integer_of_int ?k <= integer_of_int ?l
ord_class.less_eq [integer]
  Code_Numeral.Neg ?k <= Code_Numeral.Neg ?l == ?l <= ?k
  Code_Numeral.Neg ?k <= Code_Numeral.Pos ?l == True
  Code_Numeral.Neg ?k <= 0 == True
  Code_Numeral.Pos ?k <= Code_Numeral.Neg ?l == False
  Code_Numeral.Pos ?k <= Code_Numeral.Pos ?l == ?k <= ?l
  Code_Numeral.Pos ?k <= 0 == False
  0 <= Code_Numeral.Neg ?l == False
  0 <= Code_Numeral.Pos ?l == True
  0 <= 0 == True
ord_class.less_eq [nat]
  ?m <= ?n == integer_of_nat ?m <= integer_of_nat ?n
ord_class.less_eq [num]
  num.Bit1 ?m <= num.Bit0 ?n == ?m < ?n
  num.Bit1 ?m <= num.Bit1 ?n == ?m <= ?n
  num.Bit0 ?m <= num.Bit1 ?n == ?m <= ?n
  num.Bit0 ?m <= num.Bit0 ?n == ?m <= ?n
  num.Bit1 ?m <= num.One == False
  num.Bit0 ?m <= num.One == False
  num.One <= ?n == True
ord_class.less_eq [prod]
  (?x1.0, ?y1.0) <= (?x2.0, ?y2.0) ==
  ?x1.0 < ?x2.0 | ?x1.0 <= ?x2.0 & ?y1.0 <= ?y2.0
paint
  paint ?c rbt.Empty == rbt.Empty
  paint ?c (Branch ?uu ?l ?k ?v ?r) == Branch ?c ?l ?k ?v ?r
plus [int]
  ?k + ?l == int_of_integer (integer_of_int ?k + integer_of_int ?l)
plus [integer]
  Code_Numeral.Neg ?m + Code_Numeral.Neg ?n == Code_Numeral.Neg (?m + ?n)
  Code_Numeral.Neg ?m + Code_Numeral.Pos ?n == Code_Numeral.sub ?n ?m
  Code_Numeral.Pos ?m + Code_Numeral.Neg ?n == Code_Numeral.sub ?m ?n
  Code_Numeral.Pos ?m + Code_Numeral.Pos ?n == Code_Numeral.Pos (?m + ?n)
  0 + ?l == ?l
  ?k + 0 == ?k
plus [nat]
  integer_of_nat (?m + ?n) == integer_of_nat ?m + integer_of_nat ?n
plus [num]
  num.Bit1 ?m + num.Bit1 ?n == num.Bit0 (?m + ?n + num.One)
  num.Bit1 ?m + num.Bit0 ?n == num.Bit1 (?m + ?n)
  num.Bit1 ?m + num.One == num.Bit0 (?m + num.One)
  num.Bit0 ?m + num.Bit1 ?n == num.Bit1 (?m + ?n)
  num.Bit0 ?m + num.Bit0 ?n == num.Bit0 (?m + ?n)
  num.Bit0 ?m + num.One == num.Bit1 ?m
  num.One + num.Bit1 ?n == num.Bit0 (?n + num.One)
  num.One + num.Bit0 ?n == num.Bit1 ?n
  num.One + num.One == num.Bit0 num.One
rbt.impl_of
  rbt.impl_of (RBT ?x) == ?x
rbt_ins
  rbt_ins ?f ?k ?v rbt.Empty == Branch color.R rbt.Empty ?k ?v rbt.Empty
  rbt_ins ?f ?k ?v (Branch color.B ?l ?x ?y ?r) ==
  if ?k < ?x then balance (rbt_ins ?f ?k ?v ?l) ?x ?y ?r
  else if ?x < ?k then balance ?l ?x ?y (rbt_ins ?f ?k ?v ?r)
       else Branch color.B ?l ?x (?f ?k ?y ?v) ?r
  rbt_ins ?f ?k ?v (Branch color.R ?l ?x ?y ?r) ==
  if ?k < ?x then Branch color.R (rbt_ins ?f ?k ?v ?l) ?x ?y ?r
  else if ?x < ?k then Branch color.R ?l ?x ?y (rbt_ins ?f ?k ?v ?r)
       else Branch color.R ?l ?x (?f ?k ?y ?v) ?r
rbt_insert
  rbt_insert == rbt_insert_with_key (%_ _ nv. nv)
rbt_insert_with_key
  rbt_insert_with_key ?f ?k ?v ?t == paint color.B (rbt_ins ?f ?k ?v ?t)
rbt_lookup
  rbt_lookup rbt.Empty ?k == None
  rbt_lookup (Branch ?uu ?l ?x ?y ?r) ?k ==
  if ?k < ?x then rbt_lookup ?l ?k
  else if ?x < ?k then rbt_lookup ?r ?k else Some ?y
run_state
  run_state (State ?x) == ?x
uminus [integer]
  - Code_Numeral.Neg ?m == Code_Numeral.Pos ?m
  - Code_Numeral.Pos ?m == Code_Numeral.Neg ?m
  - 0 == 0
upto
  [?i..?j] == upto_aux ?i ?j []
upto_aux
  upto_aux ?i ?j ?js ==
  if ?j < ?i then ?js else upto_aux ?i (?j - 1) (?j # ?js)
zero_class.zero [nat]
  integer_of_nat 0 == 0
Warning: Value identifier (t) has not been referenced.
At (line 12 of "generated code")
Warning: Value identifier (less) has not been referenced.
At (line 50 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 77 of "generated code")
Warning: Value identifier (x1) has not been referenced.
At (line 112 of "generated code")
Warning: Value identifier (x2) has not been referenced.
At (line 118 of "generated code")
Warning: Value identifier (sep) has not been referenced.
At (line 182 of "generated code")
Warning: Value identifier (sep) has not been referenced.
At (line 181 of "generated code")
Warning: Value identifier (s) has not been referenced.
At (line 181 of "generated code")
Warning: Value identifier (xs) has not been referenced.
At (line 186 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 186 of "generated code")
Warning: Value identifier (p) has not been referenced.
At (line 193 of "generated code")
Warning: Value identifier (shows_list) has not been referenced.
At (line 208 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 213 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 223 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 225 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 236 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 238 of "generated code")
Warning: Value identifier (v) has not been referenced.
At (line 255 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 255 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 254 of "generated code")
Warning: Value identifier (v) has not been referenced.
At (line 253 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 253 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 252 of "generated code")
Warning: Value identifier (v) has not been referenced.
At (line 251 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 251 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 250 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 250 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 288 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 292 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 295 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 297 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 302 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 307 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 350 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 349 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 348 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 347 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 347 of "generated code")
Warning: Value identifier (y) has not been referenced.
At (line 346 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 346 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 345 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 344 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 344 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 343 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 343 of "generated code")
Warning: Value identifier (p) has not been referenced.
At (line 370 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 384 of "generated code")
Warning: Value identifier (C2_) has not been referenced.
At (line 396 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 437 of "generated code")
Warning: Value identifier (C2_) has not been referenced.
At (line 444 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 463 of "generated code")
Warning: Matches are not exhaustive.
fun min_list A_ (... :: ...) = (case xs of [...] => x | ... => ...)
At (line 477 of "generated code")
structure Test:
  sig
    type 'a extended
    type inta
    type nat
    type num
    val test_bf: unit -> inta extended
  end
Miss (0, 0)
Miss (0, 1)
Miss (0, 2)
Miss (0, 3)
Miss (1, 0)
Hit (0, 0)
Hit (0, 0)
Hit (0, 1)
Hit (0, 2)
Hit (0, 3)
Miss (1, 1)
Hit (0, 1)
Hit (0, 0)
Hit (0, 1)
Hit (0, 2)
Hit (0, 3)
Miss (1, 2)
Hit (0, 2)
Hit (0, 0)
Hit (0, 1)
Hit (0, 2)
Hit (0, 3)
Miss (1, 3)
Hit (0, 3)
Hit (0, 0)
Hit (0, 1)
Hit (0, 2)
Hit (0, 3)
Miss (2, 0)
Hit (1, 0)
Hit (1, 0)
Hit (1, 1)
Hit (1, 2)
Hit (1, 3)
Miss (2, 1)
Hit (1, 1)
Hit (1, 0)
Hit (1, 1)
Hit (1, 2)
Hit (1, 3)
Miss (2, 2)
Hit (1, 2)
Hit (1, 0)
Hit (1, 1)
Hit (1, 2)
Hit (1, 3)
Miss (2, 3)
Hit (1, 3)
Hit (1, 0)
Hit (1, 1)
Hit (1, 2)
Hit (1, 3)
Miss (3, 0)
Hit (2, 0)
Hit (2, 0)
Hit (2, 1)
Hit (2, 2)
Hit (2, 3)
Miss (3, 1)
Hit (2, 1)
Hit (2, 0)
Hit (2, 1)
Hit (2, 2)
Hit (2, 3)
Miss (3, 2)
Hit (2, 2)
Hit (2, 0)
Hit (2, 1)
Hit (2, 2)
Hit (2, 3)
Miss (3, 3)
Hit (2, 3)
Hit (2, 0)
Hit (2, 1)
Hit (2, 2)
Hit (2, 3)
Hit (3, 0)
val it = Fin (Int_of_integer 4): Test.inta Test.extended
### Code generator: dropping subsumed code equation
### bf ?n ?W ?t ?a ?b ==
### fst (run_state (bf\<^sub>m' ?n ?W ?t ?a ?b) Mapping.empty)
### theory "Draft.Bellman_Ford"
### 5.230s elapsed time, 20.283s cpu time, 2.489s GC time
"[[0, 1, 1, 0, 3], [2]]"
  :: "int list list"
"[[0, 1, 1, 0, 3], [2]]"
  :: "int list list"
"[[0, 1, 1, 0, 3], [2]]"
  :: "int list list"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
"[Repl CHR ''b'', Copy, Repl CHR ''n'', Copy, Repl CHR ''n'', Copy, Copy,
  Del, Del, Del]"
  :: "char ed list"
termination by replaying
consts
  min_ed_ix\<^sub>m' :: "nat * nat => ((nat * nat, nat) mapping, nat) state"
  min_ed_ix\<^sub>m ::
    "('b, nat * nat => ((nat * nat, nat) mapping, nat) state) state"
theorem
  min_ed_ix\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) local.min_ed_ix local.min_ed_ix\<^sub>m'
theorem
  min_ed_ix\<^sub>m.memoized_correct:
    local.min_ed_ix ?a =
    fst (run_state (local.min_ed_ix\<^sub>m' ?a) Mapping.empty)
local.min_ed_ix\<^sub>m' (?i, ?j) =
state_mem_defs.checkmem
 (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, ?j)
 (State_Monad_Ext.if\<^sub>T (State_Monad.return (m <= ?i))
   (State_Monad.return (if n <= ?j then 0 else n - ?j))
   (State_Monad_Ext.if\<^sub>T (State_Monad.return (n <= ?j))
     (State_Monad.return (m - ?i))
     (State_Monad_Ext.fun_app_lifted
       (State_Monad.return
         (%a. State_Monad.return (Example_Misc.min_list a)))
       (State_Monad_Ext.fun_app_lifted
         (State_Monad_Ext.fun_app_lifted
           (State_Monad.return
             (%a. State_Monad.return (%b. State_Monad.return (a # b))))
           (State_Monad_Ext.fun_app_lifted
             (State_Monad.return (%a. State_Monad.return (1 + a)))
             (local.min_ed_ix\<^sub>m' (?i, ?j + 1))))
         (State_Monad_Ext.fun_app_lifted
           (State_Monad_Ext.fun_app_lifted
             (State_Monad.return
               (%a. State_Monad.return (%b. State_Monad.return (a # b))))
             (State_Monad_Ext.fun_app_lifted
               (State_Monad.return (%a. State_Monad.return (1 + a)))
               (local.min_ed_ix\<^sub>m' (?i + 1, ?j))))
           (State_Monad_Ext.fun_app_lifted
             (State_Monad_Ext.fun_app_lifted
               (State_Monad.return
                 (%a. State_Monad.return (%b. State_Monad.return (a # b))))
               (State_Monad_Ext.fun_app_lifted
                 (State_Monad.return
                   (%a. State_Monad.return
                         ((if xs ?i = ys ?j then 0 else 1) + a)))
                 (local.min_ed_ix\<^sub>m' (?i + 1, ?j + 1))))
             (State_Monad.return [])))))))
termination by replaying
consts
  min_ed_ix\<^sub>h' :: "nat * nat => nat Heap"
  min_ed_ix\<^sub>h :: "(nat * nat => nat Heap) Heap"
theorem
  min_ed_ix\<^sub>h.crel:
    min_ed_ix\<^sub>h.consistentDP local.min_ed_ix\<^sub>h'
theorem
  min_ed_ix\<^sub>h.memoized_correct:
    local.min_ed_ix ?a =
    result_of (local.min_ed_ix\<^sub>h' ?a)
     (heap_of (init_state (n + 1) m (m + 1)) Heap.empty)
See theory exports
Warning: Value identifier (t) has not been referenced.
At (line 19 of "generated code")
Warning: Value identifier (x1) has not been referenced.
At (line 63 of "generated code")
Warning: Value identifier (x2) has not been referenced.
At (line 69 of "generated code")
Warning: Value identifier (less) has not been referenced.
At (line 77 of "generated code")
Warning: Value identifier (sep) has not been referenced.
At (line 137 of "generated code")
Warning: Value identifier (sep) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (s) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (xs) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (p) has not been referenced.
At (line 148 of "generated code")
Warning: Value identifier (shows_list) has not been referenced.
At (line 163 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 172 of "generated code")
Warning: Pattern 3 is redundant.
fun
   equal_bool p true = p |
      equal_bool p ... = not p |
      equal_bool ... = p |
      equal_bool ... = ...
At (line 184 of "generated code")
Warning: Pattern 4 is redundant.
fun
   equal_bool p true = p |
      equal_bool p ... = not p |
      equal_bool ... = p |
      equal_bool ... = ...
At (line 185 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 199 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 201 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 238 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 240 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 243 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 245 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 252 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 285 of "generated code")
Warning: Matches are not exhaustive.
fun min_list A_ (... :: ...) = (case xs of [...] => x | ... => ...)
At (line 290 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 315 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 322 of "generated code")
Warning: Value identifier (p) has not been referenced.
At (line 352 of "generated code")
Warning: Value identifier (C2_) has not been referenced.
At (line 369 of "generated code")
Warning: Value identifier (C2_) has not been referenced.
At (line 410 of "generated code")
structure Test: sig type char type nat val test_case: unit -> nat end
Miss (10, 7)
Miss (10, 6)
Miss (10, 5)
Miss (10, 4)
Miss (10, 3)
Miss (10, 2)
Miss (10, 1)
Miss (10, 0)
Miss (9, 7)
Miss (9, 6)
Hit (9, 7)
Hit (10, 6)
Hit (10, 7)
Miss (9, 5)
Hit (9, 6)
Hit (10, 5)
Hit (10, 6)
Miss (9, 4)
Hit (9, 5)
Hit (10, 4)
Hit (10, 5)
Miss (9, 3)
Hit (9, 4)
Hit (10, 3)
Hit (10, 4)
Miss (9, 2)
Hit (9, 3)
Hit (10, 2)
Hit (10, 3)
Miss (9, 1)
Hit (9, 2)
Hit (10, 1)
Hit (10, 2)
Miss (9, 0)
Hit (9, 1)
Hit (10, 0)
Hit (10, 1)
Miss (8, 7)
Miss (8, 6)
Hit (8, 7)
Hit (9, 6)
Hit (9, 7)
Miss (8, 5)
Hit (8, 6)
Hit (9, 5)
Hit (9, 6)
Miss (8, 4)
Hit (8, 5)
Hit (9, 4)
Hit (9, 5)
Miss (8, 3)
Hit (8, 4)
Hit (9, 3)
Hit (9, 4)
Miss (8, 2)
Hit (8, 3)
Hit (9, 2)
Hit (9, 3)
Miss (8, 1)
Hit (8, 2)
Hit (9, 1)
Hit (9, 2)
Miss (8, 0)
Hit (8, 1)
Hit (9, 0)
Hit (9, 1)
Miss (7, 7)
Miss (7, 6)
Hit (7, 7)
Hit (8, 6)
Hit (8, 7)
Miss (7, 5)
Hit (7, 6)
Hit (8, 5)
Hit (8, 6)
Miss (7, 4)
Hit (7, 5)
Hit (8, 4)
Hit (8, 5)
Miss (7, 3)
Hit (7, 4)
Hit (8, 3)
Hit (8, 4)
Miss (7, 2)
Hit (7, 3)
Hit (8, 2)
Hit (8, 3)
Miss (7, 1)
Hit (7, 2)
Hit (8, 1)
Hit (8, 2)
Miss (7, 0)
Hit (7, 1)
Hit (8, 0)
Hit (8, 1)
Miss (6, 7)
Miss (6, 6)
Hit (6, 7)
Hit (7, 6)
Hit (7, 7)
Miss (6, 5)
Hit (6, 6)
Hit (7, 5)
Hit (7, 6)
Miss (6, 4)
Hit (6, 5)
Hit (7, 4)
Hit (7, 5)
Miss (6, 3)
Hit (6, 4)
Hit (7, 3)
Hit (7, 4)
Miss (6, 2)
Hit (6, 3)
Hit (7, 2)
Hit (7, 3)
Miss (6, 1)
Hit (6, 2)
Hit (7, 1)
Hit (7, 2)
Miss (6, 0)
Hit (6, 1)
Hit (7, 0)
Hit (7, 1)
Miss (5, 7)
Miss (5, 6)
Hit (5, 7)
Hit (6, 6)
Hit (6, 7)
Miss (5, 5)
Hit (5, 6)
Hit (6, 5)
Hit (6, 6)
Miss (5, 4)
Hit (5, 5)
Hit (6, 4)
Hit (6, 5)
Miss (5, 3)
Hit (5, 4)
Hit (6, 3)
Hit (6, 4)
Miss (5, 2)
Hit (5, 3)
Hit (6, 2)
Hit (6, 3)
Miss (5, 1)
Hit (5, 2)
Hit (6, 1)
Hit (6, 2)
Miss (5, 0)
Hit (5, 1)
Hit (6, 0)
Hit (6, 1)
Miss (4, 7)
Miss (4, 6)
Hit (4, 7)
Hit (5, 6)
Hit (5, 7)
Miss (4, 5)
Hit (4, 6)
Hit (5, 5)
Hit (5, 6)
Miss (4, 4)
Hit (4, 5)
Hit (5, 4)
Hit (5, 5)
Miss (4, 3)
Hit (4, 4)
Hit (5, 3)
Hit (5, 4)
Miss (4, 2)
Hit (4, 3)
Hit (5, 2)
Hit (5, 3)
Miss (4, 1)
Hit (4, 2)
Hit (5, 1)
Hit (5, 2)
Miss (4, 0)
Hit (4, 1)
Hit (5, 0)
Hit (5, 1)
Miss (3, 7)
Miss (3, 6)
Hit (3, 7)
Hit (4, 6)
Hit (4, 7)
Miss (3, 5)
Hit (3, 6)
Hit (4, 5)
Hit (4, 6)
Miss (3, 4)
Hit (3, 5)
Hit (4, 4)
Hit (4, 5)
Miss (3, 3)
Hit (3, 4)
Hit (4, 3)
Hit (4, 4)
Miss (3, 2)
Hit (3, 3)
Hit (4, 2)
Hit (4, 3)
Miss (3, 1)
Hit (3, 2)
Hit (4, 1)
Hit (4, 2)
Miss (3, 0)
Hit (3, 1)
Hit (4, 0)
Hit (4, 1)
Miss (2, 7)
Miss (2, 6)
Hit (2, 7)
Hit (3, 6)
Hit (3, 7)
Miss (2, 5)
Hit (2, 6)
Hit (3, 5)
Hit (3, 6)
Miss (2, 4)
Hit (2, 5)
Hit (3, 4)
Hit (3, 5)
Miss (2, 3)
Hit (2, 4)
Hit (3, 3)
Hit (3, 4)
Miss (2, 2)
Hit (2, 3)
Hit (3, 2)
Hit (3, 3)
Miss (2, 1)
Hit (2, 2)
Hit (3, 1)
Hit (3, 2)
Miss (2, 0)
Hit (2, 1)
Hit (3, 0)
Hit (3, 1)
Miss (1, 7)
Miss (1, 6)
Hit (1, 7)
Hit (2, 6)
Hit (2, 7)
Miss (1, 5)
Hit (1, 6)
Hit (2, 5)
Hit (2, 6)
Miss (1, 4)
Hit (1, 5)
Hit (2, 4)
Hit (2, 5)
Miss (1, 3)
Hit (1, 4)
Hit (2, 3)
Hit (2, 4)
Miss (1, 2)
Hit (1, 3)
Hit (2, 2)
Hit (2, 3)
Miss (1, 1)
Hit (1, 2)
Hit (2, 1)
Hit (2, 2)
Miss (1, 0)
Hit (1, 1)
Hit (2, 0)
Hit (2, 1)
Miss (0, 0)
Miss (0, 1)
Miss (0, 2)
Miss (0, 3)
Miss (0, 4)
Miss (0, 5)
Miss (0, 6)
Miss (0, 7)
Hit (1, 6)
Hit (1, 7)
Hit (1, 5)
Hit (1, 6)
Hit (1, 4)
Hit (1, 5)
Hit (1, 3)
Hit (1, 4)
Hit (1, 2)
Hit (1, 3)
Hit (1, 1)
Hit (1, 2)
Hit (1, 0)
Hit (1, 1)
val it = Nat 6: Test.nat
### theory "Draft.Min_Ed_Dist0"
### 7.051s elapsed time, 17.915s cpu time, 2.287s GC time
Loading theory "Draft.All_Examples" (required by "Draft.All_ExamplesTemplates")
### theory "Draft.All_Examples"
### 1.122s elapsed time, 1.204s cpu time, 0.108s GC time
Loading theory "Draft.All_ExamplesTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.All_ExamplesTemplates"
### 1.280s elapsed time, 2.987s cpu time, 2.118s GC time
val it = (): unit
