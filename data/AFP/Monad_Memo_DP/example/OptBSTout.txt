Loading theory "Draft.Indexing" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.Heap_Default" via "Draft.Heap_Main" via "Draft.Memory_Heap")
Loading theory "Draft.Pure_Monad" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main" via "Draft.Transform_Cmd")
Loading theory "Draft.State_Heap_Misc" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main" via "Draft.Transform_Cmd" via "Draft.DP_CRelVH" via "Draft.State_Heap")
Loading theory "Draft.Solve_Cong" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.Heap_Default" via "Draft.Heap_Main")
### theory "Draft.Pure_Monad"
### 0.031s elapsed time, 0.154s cpu time, 0.000s GC time
Loading theory "Draft.State_Monad_Ext" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main" via "Draft.Transform_Cmd" via "Draft.DP_CRelVS")
### theory "Draft.State_Heap_Misc"
### 0.053s elapsed time, 0.252s cpu time, 0.000s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.OptBSTTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
bundle state_monad_syntax
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
### theory "Draft.State_Monad_Ext"
### 0.049s elapsed time, 0.203s cpu time, 0.000s GC time
Loading theory "Draft.DP_CRelVS" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main" via "Draft.Transform_Cmd")
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
locale prod_order_def
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
### theory "HOL-Library.Function_Algebras"
### 0.106s elapsed time, 0.400s cpu time, 0.028s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.OptBSTTemplates" via "Draft.ExtrEqs")
Found termination order: "{}"
### theory "Draft.Solve_Cong"
### 0.215s elapsed time, 0.884s cpu time, 0.028s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.OptBSTTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
locale state_mem_defs
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
Found termination order: "{}"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
locale mem_correct
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
  assumes "mem_correct lookup update P"
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
locale prod_order
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
  assumes "prod_order less_eq0 less0 less_eq1 less1"
### theory "HOL-Library.Set_Algebras"
### 0.216s elapsed time, 0.842s cpu time, 0.100s GC time
Loading theory "Draft.Templates" (required by "Draft.OptBSTTemplates" via "Draft.ExtrEqs")
### theory "Draft.DP_CRelVS"
### 0.368s elapsed time, 1.433s cpu time, 0.127s GC time
Loading theory "Draft.Memory" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.083s elapsed time, 0.320s cpu time, 0.072s GC time
Loading theory "Draft.Heap_Monad_Ext" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main" via "Draft.Transform_Cmd" via "Draft.DP_CRelVH" via "Draft.State_Heap")
bundle heap_monad_syntax
### theory "Draft.Heap_Monad_Ext"
### 0.048s elapsed time, 0.194s cpu time, 0.000s GC time
Loading theory "Draft.State_Heap" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main" via "Draft.Transform_Cmd" via "Draft.DP_CRelVH")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
locale option_order
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
  assumes "option_order less_eq0 less0"
  Proving monotonicity ...
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
consts
  snth :: "'a stream => nat => 'a"
Found termination order: "{}"
consts
  stake :: "nat => 'a stream => 'a list"
locale dp_consistency_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and dp :: "'a => 'c"
    and empty :: "'b"
  assumes "dp_consistency_empty lookup update P empty"
consts
  sdrop :: "nat => 'a stream => 'a stream"
locale dp_consistency_default
  fixes dp :: "'param => 'result"
Found termination order: "{}"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
locale dp_consistency_mapping
  fixes dp :: "'param => 'result"
consts
  cycle :: "'a list => 'a stream"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
locale state_mem_defs
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
locale mem_correct
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
  assumes "mem_correct lookup update P"
consts
  flat :: "'a list stream => 'a stream"
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
locale dp_consistency_mapping_tracing
  fixes dp :: "'param => 'result"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
locale heap_mem_defs
  fixes P :: "heap => bool"
    and lookup :: "'k => 'v option Heap"
    and update :: "'k => 'v => unit Heap"
### Ambiguous input (line 63 of "$AFP/Monad_Memo_DP/heap_monad/State_Heap.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" rel_state)
###     ("_cargs" ("_position" R) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>HOL.All_binder" ("_position" heap)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" heap))
###       ("_case_syntax"
###         ("_applC" ("_position" State_Monad.run_state)
###           ("_cargs" ("_position" f) ("_position" heap)))
###         ("_case1"
###           ("_tuple" ("_position" v1) ("_tuple_arg" ("_position" heap1)))
###           ("_case_syntax"
###             ("_applC" ("_position" execute)
###               ("_cargs" ("_position" g) ("_position" heap)))
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" v2)
###                     ("_tuple_arg" ("_position" heap2))))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" R)
###                     ("_cargs" ("_position" v1) ("_position" v2)))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_position" heap1)
###                       ("_position" heap2))
###                     ("_applC" ("_position" P) ("_position" heap2)))))
###               ("_case1" ("_position" None) ("_position" False)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" rel_state)
###     ("_cargs" ("_position" R) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>HOL.All_binder" ("_position" heap)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" heap))
###       ("_case_syntax"
###         ("_applC" ("_position" State_Monad.run_state)
###           ("_cargs" ("_position" f) ("_position" heap)))
###         ("_case2"
###           ("_case1"
###             ("_tuple" ("_position" v1) ("_tuple_arg" ("_position" heap1)))
###             ("_case_syntax"
###               ("_applC" ("_position" execute)
###                 ("_cargs" ("_position" g) ("_position" heap)))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" v2)
###                     ("_tuple_arg" ("_position" heap2))))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" R)
###                     ("_cargs" ("_position" v1) ("_position" v2)))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_position" heap1)
###                       ("_position" heap2))
###                     ("_applC" ("_position" P) ("_position" heap2)))))))
###           ("_case1" ("_position" None) ("_position" False)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
### theory "HOL-Library.Stream"
### 1.077s elapsed time, 4.035s cpu time, 0.839s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.OptBSTTemplates" via "Draft.ExtrEqs")
### theory "Draft.Memory"
### 0.794s elapsed time, 2.930s cpu time, 0.739s GC time
Loading theory "Draft.Bottom_Up_Computation" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.Heap_Default" via "Draft.Heap_Main" via "Draft.Bottom_Up_Computation_Heap")
locale heap_inv
  fixes P :: "heap => bool"
    and update :: "'k => 'v => unit Heap"
    and lookup :: "'k => 'v option Heap"
  assumes "heap_inv P update lookup"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale iterator_defs
  fixes cnt :: "'a => bool"
    and nxt :: "'a => 'a"
locale heap_correct
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
  assumes "heap_correct P update lookup"
locale iterator
  fixes cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "iterator cnt nxt sizef"
locale heap_mem_defs
  fixes P :: "heap => bool"
    and lookup :: "'k => 'v option Heap"
    and update :: "'k => 'v => unit Heap"
### theory "Draft.State_Heap"
### 0.844s elapsed time, 3.119s cpu time, 0.713s GC time
Loading theory "Draft.Pair_Memory" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.Heap_Default" via "Draft.Heap_Main" via "Draft.Memory_Heap")
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
locale pair_mem_defs
  fixes lookup1 :: "'a => ('mem, 'v option) state"
    and lookup2 :: "'a => ('mem, 'v option) state"
    and update1 :: "'a => 'v => ('mem, unit) state"
    and update2 :: "'a => 'v => ('mem, unit) state"
    and move12 :: "'k1 => ('mem, unit) state"
    and get_k1 :: "('mem, 'k1) state"
    and get_k2 :: "('mem, 'k1) state"
    and P :: "'mem => bool"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'a"
locale dp_consistency_iterator
  fixes P :: "'b => bool"
    and dp :: "'a => 'c"
    and lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "dp_consistency_iterator P lookup update cnt nxt sizef"
locale index_locale_def
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
locale dp_consistency_iterator_empty
  fixes P :: "'a => bool"
    and dp :: "'b => 'c"
    and lookup :: "'b => ('a, 'c option) state"
    and update :: "'b => 'c => ('a, unit) state"
    and cnt :: "'b => bool"
    and nxt :: "'b => 'b"
    and sizef :: "'b => nat"
    and empty :: "'a"
  assumes
    "dp_consistency_iterator_empty P lookup update cnt nxt sizef empty"
### theory "Draft.Bottom_Up_Computation"
### 0.345s elapsed time, 1.350s cpu time, 0.119s GC time
Loading theory "Draft.DP_CRelVH" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main" via "Draft.Transform_Cmd")
locale index_locale
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
  assumes "index_locale less_eq less idx size"
locale prod_index_def
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
    and idx1 :: "'b bound => 'b => nat"
    and size1 :: "'b bound => nat"
locale dp_heap
  fixes P :: "heap => bool"
    and Q :: "heap => bool"
    and dp :: "'k => 'v"
    and lookup :: "'k => 'v option Heap"
    and lookup_st :: "'k => (heap, 'v option) state"
    and update :: "'k => 'v => unit Heap"
    and update_st :: "'k => 'v => (heap, unit) state"
  assumes "dp_heap P Q lookup lookup_st update update_st"
locale pair_mem
  fixes lookup1 :: "'a => ('b, 'c option) state"
    and lookup2 :: "'a => ('b, 'c option) state"
    and update1 :: "'a => 'c => ('b, unit) state"
    and update2 :: "'a => 'c => ('b, unit) state"
    and move12 :: "'d => ('b, unit) state"
    and get_k1 :: "('b, 'd) state"
    and get_k2 :: "('b, 'd) state"
    and P :: "'b => bool"
    and key1 :: "'e => 'd"
    and key2 :: "'e => 'a"
  assumes "pair_mem lookup1 lookup2 update1 update2 move12 get_k1 get_k2 P"
Found termination order: "{}"
Found termination order: "{}"
locale dp_consistency_heap
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
  assumes "dp_consistency_heap P update lookup"
locale heap_correct_empty
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and empty :: "heap"
  assumes "heap_correct_empty P update lookup empty"
locale dp_consistency_heap_empty
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
    and empty :: "heap"
  assumes "dp_consistency_heap_empty P update lookup empty"
locale prod_index
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
    and idx1 :: "'b bound => 'b => nat"
    and size1 :: "'b bound => nat"
  assumes "prod_index less_eq0 less0 idx0 size0 less_eq1 less1 idx1 size1"
### theory "Draft.DP_CRelVH"
### 0.467s elapsed time, 1.822s cpu time, 0.237s GC time
Loading theory "Draft.Bottom_Up_Computation_Heap" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.Heap_Default" via "Draft.Heap_Main")
### theory "HOL-Library.BigO"
### 0.874s elapsed time, 3.411s cpu time, 0.356s GC time
Loading theory "Draft.Transform_Cmd" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.State_Main")
### ML warning (line 17 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (import_function_info) has not been referenced.
### ML warning (line 27 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Pattern is not exhaustive.
### ML warning (line 30 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (head_of) has not been referenced.
### ML warning (line 31 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (bind_of) has not been referenced.
signature TRANSFORM_MISC =
  sig
    val add_function:
       binding -> term list -> local_theory -> Function.info * local_theory
    val behead: term -> term -> term * term list
    val get_const_pat: Proof.context -> string -> term
    val locale_term: Proof.context -> string -> string -> term
    val locale_thms: Proof.context -> string -> string -> thm list
    val rel_of: Function.info -> Proof.context -> thm
    val term_name: term -> string
    val the_element: int list -> int
    val totality_of: Function.info -> thm
    val uncurry: term -> term
  end
structure Transform_Misc: TRANSFORM_MISC
### ML warning (line 18 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (pureapp) has not been referenced.
### ML warning (line 32 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (memT) has not been referenced.
### ML warning (line 45 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmem') has not been referenced.
### ML warning (line 48 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmemC) has not been referenced.
### ML warning (line 80 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmem') has not been referenced.
### ML warning (line 83 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmemC) has not been referenced.
signature TRANSFORM_CONST =
  sig
    type MONAD_CONSTS =
       {app: term * term -> term,
        checkmemVN: string,
        if_termN: string,
        mk_stateT: typ -> typ,
        monad_name: string,
        return: term -> term, rewrite_app_beta_conv: conv}
    val get_monad_const: string -> MONAD_CONSTS
  end
structure Transform_Const: TRANSFORM_CONST
### ML warning (line 104 of "$AFP/Monad_Memo_DP/transform/Transform_Data.ML"):
### Value identifier (put_monadified_terms_generic) has not been referenced.
signature TRANSFORM_DATA =
  sig
    val add_tmp_cmd_info:
       binding * term * string option -> local_theory -> local_theory
    type cmd_info =
       {dp_info: dp_info option,
        head: term, locale: string option, scope: binding}
    val commit_dp_info: string -> dp_info -> local_theory -> local_theory
    type dp_info =
       {new_def': thm list,
        new_defT: thm,
        new_head': term,
        new_headT: term, old_defs: thm list, old_head: term}
    val get_dp_info: string -> Proof.context -> term -> dp_info option
    val get_last_cmd_info: Proof.context -> cmd_info
    val get_or_last_cmd_info:
       Proof.context -> (string * term) option -> cmd_info
  end
structure Transform_Data: TRANSFORM_DATA
locale option_index
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
  assumes "option_index less_eq0 less0 idx0 size0"
### ML warning (line 28 of "$AFP/Monad_Memo_DP/transform/Transform_Tactic.ML"):
### Value identifier (msg) has not been referenced.
signature TRANSFORM_TACTIC =
  sig
    val dp_unfold_defs_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val my_print_tac: string -> tactic
    val prepare_case_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val prepare_combinator_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val prepare_consistentDP_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val solve_consistentDP_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val solve_relator_tac: Proof.context -> int -> tactic
    val step_tac: Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val totality_replay_tac:
       Function.info -> Function.info -> Proof.context -> tactic
    val totality_resolve_tac: thm -> thm -> thm -> Proof.context -> tactic
    val transfer_raw_tac: Proof.context -> int -> tactic
  end
structure Transform_Tactic: TRANSFORM_TACTIC
Found termination order: "{}"
locale nat_index_def
### ML warning (line 22 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (eta_conv_n) has not been referenced.
### ML warning (line 33 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (app_unmark_conv) has not been referenced.
### ML warning (line 36 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (eta_expand) has not been referenced.
### ML warning (line 282 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (monadify) has not been referenced.
signature TRANSFORM_TERM =
  sig
    val lift_equation:
       Transform_Const.MONAD_CONSTS ->
         Proof.context ->
           term * term ->
             term option -> (Proof.context -> conv) * term * int
    val repeat_sweep_conv: (Proof.context -> conv) -> Proof.context -> conv
    val rewrite_pureapp_beta_conv: conv
    val wrap_head: Transform_Const.MONAD_CONSTS -> term -> int -> term
  end
structure Transform_Term: TRANSFORM_TERM
locale dp_consistency_iterator_heap
  fixes lookup :: "'a => 'c option Heap"
    and update :: "'a => 'c => unit Heap"
    and P :: "heap => bool"
    and dp :: "'a => 'c"
    and cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "dp_consistency_iterator_heap lookup update P cnt nxt sizef"
Found termination order: "{}"
### ML warning (line 140 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Value identifier (prep_term) has not been referenced.
### ML warning (line 154 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Value identifier (dp_monadify_cmd) has not been referenced.
### ML warning (line 217 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Pattern is not exhaustive.
signature TRANSFORM_DP =
  sig
    val dp_correct_cmd: local_theory -> Proof.state
    val dp_fun_part1_cmd:
       (binding * string) *
       ((bool * (xstring * Position.T)) * (string * string) list) option
         -> local_theory -> local_theory
    val dp_fun_part2_cmd:
       string * (Facts.ref * Token.src list) list ->
         local_theory -> local_theory
  end
structure Transform_DP: TRANSFORM_DP
### theory "Draft.Bottom_Up_Computation_Heap"
### 0.669s elapsed time, 2.483s cpu time, 0.774s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.OptBSTTemplates")
### ML warning (line 11 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (dp_fun_parser) has not been referenced.
### ML warning (line 19 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (memoizes_parser) has not been referenced.
### ML warning (line 22 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (monadifies_parser) has not been referenced.
### ML warning (line 29 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (dp_monadify_cmd_parser) has not been referenced.
signature TRANSFORM_PARSER =
  sig
    val dp_fun_part1_parser:
       ((binding * string) *
        ((bool * (string * Position.T)) * (string * string) list) option
       )
       parser
    val dp_fun_part2_parser:
       (string * (Facts.ref * Token.src list) list) parser
  end
structure Transform_Parser: TRANSFORM_PARSER
Found termination order: "{}"
### theory "Draft.Transform_Cmd"
### 0.666s elapsed time, 2.461s cpu time, 0.833s GC time
Loading theory "Draft.State_Main" (required by "Draft.OptBSTTemplates" via "Draft.OptBST")
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
locale nat_index
  assumes "nat_index"
locale int_index_def
### theory "Draft.Pair_Memory"
### 1.485s elapsed time, 5.662s cpu time, 1.142s GC time
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
Found termination order: "{}"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"iter_heap"
  :: "('a => 'b Heap) => 'a => unit Heap"
"crel_vs"
  :: "('b => 'd => bool) => 'b => 'd Heap => bool"
Found termination order: "{}"
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
locale int_index
  assumes "int_index"
Found termination order: "{}"
termination by default prover
class index = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
  assumes
    "is_locale":
      "index_locale index_class.less_eq index_class.less idx
        index_class.size"
locale bounded_index
  fixes bound :: "'k bound"
consts
  comp\<^sub>T' ::
    "('c => ('e, 'b) state)
     => ('a => ('e, 'c) state) => ('d, 'a => ('e, 'b) state) state"
  comp\<^sub>T ::
    "('g,
      ('c => ('e, 'b) state)
      => ('f,
          ('a => ('e, 'c) state)
          => ('d, 'a => ('e, 'b) state) state) state) state"
instantiation
  nat :: index
  less_eq_nat == index_class.less_eq :: nat => nat => bool
  less_nat == index_class.less :: nat => nat => bool
  idx_nat == idx :: nat bound => nat => nat
  size_nat == index_class.size :: nat bound => nat
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
index_locale (<=) (<) local.idx local.size
consts
  map\<^sub>T' :: "('b => ('c, 'a) state) => 'b list => ('c, 'a list) state"
  map\<^sub>T ::
    "('e,
      ('b => ('c, 'a) state)
      => ('d, 'b list => ('c, 'a list) state) state) state"
instantiation
  int :: index
  less_eq_int == index_class.less_eq :: int => int => bool
  less_int == index_class.less :: int => int => bool
  idx_int == idx :: int bound => int => nat
  size_int == index_class.size :: int bound => nat
index_locale (<=) (<) local.idx local.size
instantiation
  prod :: (index, index) index
  less_eq_prod == index_class.less_eq :: 'a * 'b => 'a * 'b => bool
  less_prod == index_class.less :: 'a * 'b => 'a * 'b => bool
  idx_prod == idx :: ('a * 'b) bound => 'a * 'b => nat
  size_prod == index_class.size :: ('a * 'b) bound => nat
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  fold\<^sub>T' ::
    "('b => ('c, 'a => ('d, 'a) state) state)
     => 'b list => ('c, 'a => ('d, 'a) state) state"
  fold\<^sub>T ::
    "('f,
      ('b => ('c, 'a => ('d, 'a) state) state)
      => ('e, 'b list => ('c, 'a => ('d, 'a) state) state) state) state"
[| ?xs = ?ys; !!x. x : set ?ys ==> ?f x = ?g x |]
==> map ?f ?xs = map ?g ?ys
[| ?a = ?b; ?xs = ?ys; !!x. x : set ?xs ==> ?f x = ?g x |]
==> fold ?f ?xs ?a = fold ?g ?ys ?b
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.685s elapsed time, 2.249s cpu time, 0.231s GC time
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
[| option = option'; option' = None ==> f1 = g1;
   !!x2. option' = Some x2 ==> f2 x2 = g2 x2 |]
==> (case option of None => f1 | Some x2 => f2 x2) =
    (case option' of None => g1 | Some x2 => g2 x2)
[| prod = prod'; !!x1 x2. prod' = (x1, x2) ==> f x1 x2 = g x1 x2 |]
==> (case prod of (x1, x2) => f x1 x2) = (case prod' of (x1, x2) => g x1 x2)
[| nat = nat'; nat' = 0 ==> f1 = g1;
   !!x2. nat' = Suc x2 ==> f2 x2 = g2 x2 |]
==> (case nat of 0 => f1 | Suc x2 => f2 x2) =
    (case nat' of 0 => g1 | Suc x2 => g2 x2)
### theory "Draft.State_Main"
### 0.847s elapsed time, 2.496s cpu time, 0.243s GC time
Loading theory "Draft.Example_Misc" (required by "Draft.OptBSTTemplates" via "Draft.OptBST")
index_locale local.less_eq local.less local.idx local.size
### Type
### (int * int) bound => nat
### of constant "Indexing.bounded_index.size"
### is too specific compared to declared type
### ?'k::{} bound => nat, in theorem:
### bounded_index.size (Bound (?l1.0, ?l2.0) (?u1.0, ?u2.0)) ==
### nat (?u1.0 - ?l1.0) * nat (?u2.0 - ?l2.0)
### theory "Draft.Indexing"
### 3.754s elapsed time, 13.356s cpu time, 2.299s GC time
Loading theory "Draft.Memory_Heap" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.Heap_Default" via "Draft.Heap_Main")
### Missing patterns in function definition:
### min_list [] = undefined
Found termination order: "length <*mlex*> {}"
bundle app_syntax
### theory "Draft.Example_Misc"
### 0.359s elapsed time, 0.779s cpu time, 0.066s GC time
### theory "Draft.Memory_Heap"
### 1.254s elapsed time, 1.626s cpu time, 0.172s GC time
Loading theory "Draft.Heap_Main" (required by "Draft.OptBSTTemplates" via "Draft.OptBST" via "Draft.Heap_Default")
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
Found termination order: "{}"
termination by default prover
consts
  comp\<^sub>T' ::
    "('c => 'b Heap) => ('a => 'c Heap) => ('a => 'b Heap) Heap"
  comp\<^sub>T ::
    "(('c => 'b Heap)
      => (('a => 'c Heap) => ('a => 'b Heap) Heap) Heap) Heap"
comp\<^sub>T' ?f ?g =
return
 (%x. Heap_Monad_Ext.fun_app_lifted (return ?f)
       (Heap_Monad_Ext.fun_app_lifted (return ?g) (return x)))
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  map\<^sub>T' :: "('b => 'a Heap) => 'b list => 'a list Heap"
  map\<^sub>T :: "(('b => 'a Heap) => ('b list => 'a list Heap) Heap) Heap"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  fold\<^sub>T' ::
    "('b => ('a => 'a Heap) Heap) => 'b list => ('a => 'a Heap) Heap"
  fold\<^sub>T ::
    "(('b => ('a => 'a Heap) Heap)
      => ('b list => ('a => 'a Heap) Heap) Heap) Heap"
[| ?xs = ?ys; !!x. x : set ?ys ==> ?f x = ?g x |]
==> map ?f ?xs = map ?g ?ys
[| ?a = ?b; ?xs = ?ys; !!x. x : set ?xs ==> ?f x = ?g x |]
==> fold ?f ?xs ?a = fold ?g ?ys ?b
locale dp_consistency_heap
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
  assumes "dp_consistency_heap P update lookup"
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
[| option = option'; option' = None ==> f1 = g1;
   !!x2. option' = Some x2 ==> f2 x2 = g2 x2 |]
==> (case option of None => f1 | Some x2 => f2 x2) =
    (case option' of None => g1 | Some x2 => g2 x2)
[| prod = prod'; !!x1 x2. prod' = (x1, x2) ==> f x1 x2 = g x1 x2 |]
==> (case prod of (x1, x2) => f x1 x2) = (case prod' of (x1, x2) => g x1 x2)
locale heap_correct_init_defs
  fixes P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
locale heap_correct_init_inv
  fixes P :: "'a => heap => bool"
    and lookup :: "'a => 'b => 'c option Heap"
    and update :: "'a => 'b => 'c => unit Heap"
  assumes "heap_correct_init_inv P lookup update"
locale heap_correct_init
  fixes P :: "'a => heap => bool"
    and lookup :: "'a => 'b => 'c option Heap"
    and update :: "'a => 'b => 'c => unit Heap"
  assumes "heap_correct_init P lookup update"
locale dp_consistency_heap_init
  fixes P :: "'m => heap => bool"
    and update :: "'m => 'k => 'v => unit Heap"
    and lookup :: "'m => 'k => 'v option Heap"
    and dp :: "'k => 'v"
    and init :: "'m Heap"
  assumes "dp_consistency_heap_init P update lookup init"
locale dp_consistency_heap_init'
  fixes P :: "'m => heap => bool"
    and update :: "'m => 'k => 'v => unit Heap"
    and lookup :: "'m => 'k => 'v option Heap"
    and dp :: "'k => 'v"
    and init :: "'m Heap"
  assumes "dp_consistency_heap_init' P update lookup init"
locale dp_consistency_new
  fixes dp :: "'k => 'v"
    and P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
    and init :: "'m Heap"
  assumes "dp_consistency_new P lookup update init"
locale dp_consistency_new'
  fixes dp :: "'k => 'v"
    and P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
    and init :: "'m Heap"
    and mem :: "'m"
  assumes "dp_consistency_new' P lookup update init mem"
locale dp_consistency_heap_array_new'
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and mem :: "'v option array"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array_new' size to_index mem"
consistentDP (?dp\<^sub>T (result_of (mem_empty size) Heap.empty)) ==>
dp ?x = result_of (mem_empty size >>= (%mem. ?dp\<^sub>T mem ?x)) Heap.empty
locale dp_consistency_heap_array_new
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array_new size to_index"
consistentDP (?dp\<^sub>T (result_of (mem_empty size) Heap.empty)) ==>
dp ?x = result_of (mem_empty size >>= (%mem. ?dp\<^sub>T mem ?x)) Heap.empty
locale dp_consistency_heap_array
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array size to_index"
locale dp_consistency_heap_array_pair'
  fixes size :: "nat"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'k2"
    and to_index :: "'k2 => nat"
    and dp :: "'k => 'v"
    and k1 :: "'k1"
    and k2 :: "'k1"
    and
    mem :: "'k1 ref * 'k1 ref * 'v option array ref * 'v option array ref"
  assumes
    "dp_consistency_heap_array_pair' size key1 key2 to_index k1 k2 mem"
locale dp_consistency_heap_array_pair_iterator
  fixes size :: "nat"
    and key1 :: "'k => 'a"
    and key2 :: "'k => 'b"
    and to_index :: "'b => nat"
    and k1 :: "'a"
    and k2 :: "'a"
    and mem :: "'a ref * 'a ref * 'v option array ref * 'v option array ref"
    and nxt :: "'k => 'k"
    and sizef :: "'k => nat"
    and dp :: "'k => 'v"
    and cnt :: "'k => bool"
  assumes
    "dp_consistency_heap_array_pair_iterator size key1 key2 to_index k1 k2
      mem nxt sizef cnt"
locale dp_consistency_heap_array_pair
  fixes size :: "nat"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'k2"
    and to_index :: "'k2 => nat"
    and dp :: "'k => 'v"
    and k1 :: "'k1"
    and k2 :: "'k1"
  assumes "dp_consistency_heap_array_pair size key1 key2 to_index k1 k2"
### theory "Draft.Heap_Main"
### 3.213s elapsed time, 3.910s cpu time, 0.996s GC time
Loading theory "Draft.Heap_Default" (required by "Draft.OptBSTTemplates" via "Draft.OptBST")
locale dp_consistency_heap_default
  fixes bound :: "'k bound"
    and mem :: "'v option array"
    and dp :: "'k => 'v"
### theory "Draft.Heap_Default"
### 0.167s elapsed time, 0.169s cpu time, 0.000s GC time
Loading theory "Draft.OptBST" (required by "Draft.OptBSTTemplates")
### Missing patterns in function definition:
### !!a. argmin a [] = undefined
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order: "(%p. size_class.size (snd (snd p))) <*mlex*> {}"
termination by replaying
consts
  min_wpl\<^sub>T' :: "int => int => nat Heap"
  min_wpl\<^sub>T :: "(int => (int => nat Heap) Heap) Heap"
### Undefined fact: "min_wpl\<^sub>T.memoized"
theorem
  min_wpl\<^sub>T.crel:
    min_wpl\<^sub>T.consistentDP (%(x, y). local.min_wpl\<^sub>T' x y)
local.min_wpl\<^sub>T' ?i ?j =
min_wpl\<^sub>T.checkmem (?i, ?j)
 (Heap_Monad_Ext.if\<^sub>T #?j < ?i# #0#
   (#%a. #Example_Misc.min_list a## .
    (Heap_Main.map\<^sub>T .
     #%k. #%a. #%b. #a + b### .
          (#%a. #%b. #a + b### . (local.min_wpl\<^sub>T' ?i (k - 1)) .
           (local.min_wpl\<^sub>T' (k + 1) ?j)) .
          #W ?i ?j## .
     #[?i..?j]#)))
local.min_wpl\<^sub>T == #%uu_. #local.min_wpl\<^sub>T' uu_##
termination by replaying
consts
  min_wpl\<^sub>m' :: "int => int => [(int * int, nat) mapping| nat]"
  min_wpl\<^sub>m ::
    "['b| int => ['a| int => [(int * int, nat) mapping| nat]]]"
local.min_wpl\<^sub>m' ?i ?j =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, ?j)
 (State_Monad_Ext.if\<^sub>T #?j < ?i# #0#
   (#%a. #Example_Misc.min_list a## .
    (State_Main.map\<^sub>T .
     #%k. #%a. #%b. #a + b### .
          (#%a. #%b. #a + b### . (local.min_wpl\<^sub>m' ?i (k - 1)) .
           (local.min_wpl\<^sub>m' (k + 1) ?j)) .
          #W ?i ?j## .
     #[?i..?j]#)))
theorem
  min_wpl\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#)) (%_. True)
     (%(x, y). local.min_wpl x y) (%(x, y). local.min_wpl\<^sub>m' x y)
theorem
  min_wpl\<^sub>m.memoized_correct:
    local.min_wpl ?a ?b =
    fst (run_state (local.min_wpl\<^sub>m' ?a ?b) Mapping.empty)
termination by replaying
consts
  opt_bst\<^sub>m' ::
    "int => int => [(int * int, int tree) mapping| int tree]"
  opt_bst\<^sub>m ::
    "['b| int => ['a| int => [(int * int, int tree) mapping| int tree]]]"
local.opt_bst\<^sub>m' ?i ?j =
state_mem_defs.checkmem (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, ?j)
 (State_Monad_Ext.if\<^sub>T #?j < ?i# #\<langle>\<rangle>#
   (#%a. #argmin (local.wpl ?i ?j) a## .
    (State_Main.map\<^sub>T .
     #%k. #%a. #%b. #%c. #\<langle>a, b, c\<rangle>#### .
          (local.opt_bst\<^sub>m' ?i (k - 1)) .
          #k# .
          (local.opt_bst\<^sub>m' (k + 1) ?j)# .
     #[?i..?j]#)))
theorem
  opt_bst\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. #Mapping.lookup m k#)) (%_. True)
     (%(x, y). local.opt_bst x y) (%(x, y). local.opt_bst\<^sub>m' x y)
theorem
  opt_bst\<^sub>m.memoized_correct:
    local.opt_bst ?a ?b =
    fst (run_state (local.opt_bst\<^sub>m' ?a ?b) Mapping.empty)
Found termination order: "size_class.size <*mlex*> {}"
Found termination order: "(%p. size_class.size (snd p)) <*mlex*> {}"
Found termination order: "{}"
termination by replaying
consts
  W\<^sub>m' :: "int => int => ((int * int, nat) mapping, nat) state"
  W\<^sub>m ::
    "('b,
      int
      => ('a, int => ((int * int, nat) mapping, nat) state) state) state"
theorem
  W\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) (%(x, y). local.W_fun x y) (%(x, y). local.W\<^sub>m' x y)
theorem
  W\<^sub>m.memoized_correct:
    local.W_fun ?a ?b =
    fst (run_state (local.W\<^sub>m' ?a ?b) Mapping.empty)
Code_Numeral.dup
  Code_Numeral.dup (Code_Numeral.Neg ?n) == Code_Numeral.Neg (num.Bit0 ?n)
  Code_Numeral.dup (Code_Numeral.Pos ?n) == Code_Numeral.Pos (num.Bit0 ?n)
  Code_Numeral.dup 0 == 0
Code_Numeral.sub
  Code_Numeral.sub (num.Bit0 ?m) (num.Bit1 ?n) ==
  Code_Numeral.dup (Code_Numeral.sub ?m ?n) - Code_Numeral.Pos num.One
  Code_Numeral.sub (num.Bit1 ?m) (num.Bit0 ?n) ==
  Code_Numeral.dup (Code_Numeral.sub ?m ?n) + Code_Numeral.Pos num.One
  Code_Numeral.sub (num.Bit1 ?m) (num.Bit1 ?n) ==
  Code_Numeral.dup (Code_Numeral.sub ?m ?n)
  Code_Numeral.sub (num.Bit0 ?m) (num.Bit0 ?n) ==
  Code_Numeral.dup (Code_Numeral.sub ?m ?n)
  Code_Numeral.sub num.One (num.Bit1 ?n) == Code_Numeral.Neg (num.Bit0 ?n)
  Code_Numeral.sub num.One (num.Bit0 ?n) == Code_Numeral.Neg (Num.BitM ?n)
  Code_Numeral.sub (num.Bit1 ?m) num.One == Code_Numeral.Pos (num.Bit0 ?m)
  Code_Numeral.sub (num.Bit0 ?m) num.One == Code_Numeral.Pos (Num.BitM ?m)
  Code_Numeral.sub num.One num.One == 0
Example_Misc.min_list
  Example_Misc.min_list (?x # ?xs) ==
  case ?xs of [] => ?x | a # list => min ?x (Example_Misc.min_list ?xs)
If
  if False then ?x else ?y == ?y
  if True then ?x else ?y == ?x
Mapping.empty
  Mapping.empty == RBT_Mapping.Mapping RBT.empty
Mapping.lookup
  Mapping.lookup (RBT_Mapping.Mapping ?t) == RBT.lookup ?t
Mapping.update
  Mapping.update ?k ?v (RBT_Mapping.Mapping ?t) ==
  RBT_Mapping.Mapping (RBT.insert ?k ?v ?t)
Num.BitM
  Num.BitM num.One == num.One
  Num.BitM (num.Bit0 ?n) == num.Bit1 (Num.BitM ?n)
  Num.BitM (num.Bit1 ?n) == num.Bit1 (num.Bit0 ?n)
RBT.empty
  rbt.impl_of RBT.empty == rbt.Empty
RBT.insert
  rbt.impl_of (RBT.insert ?xc ?xd ?xe) ==
  rbt_insert ?xc ?xd (rbt.impl_of ?xe)
RBT.lookup
  RBT.lookup ?x == rbt_lookup (rbt.impl_of ?x)
State_Main.map\<^sub>T'
  State_Main.map\<^sub>T' ?f [] == State_Monad.return []
  State_Main.map\<^sub>T' ?f (?x21.0 # ?x22.0) ==
  State_Monad_Ext.fun_app_lifted
   (State_Monad_Ext.fun_app_lifted
     (State_Monad.return
       (%a. State_Monad.return (%b. State_Monad.return (a # b))))
     (State_Monad_Ext.fun_app_lifted (State_Monad.return ?f)
       (State_Monad.return ?x21.0)))
   (State_Main.map\<^sub>T' ?f ?x22.0)
State_Monad.bind
  ?x >>= ?f ==
  State (%s. case run_state ?x s of (a, x) => run_state (?f a) x)
State_Monad.get
  State_Monad.get == State (%s. (s, s))
State_Monad.return
  State_Monad.return ?a == State (Pair ?a)
State_Monad.set
  State_Monad.set ?s == State (%_. ((), ?s))
State_Monad_Ext.fun_app_lifted
  State_Monad_Ext.fun_app_lifted ?f_T ?x_T == ?f_T >>= (>>=) ?x_T
State_Monad_Ext.if\<^sub>T
  State_Monad_Ext.if\<^sub>T ?b_T ?x_T ?y_T ==
  ?b_T >>= (%b. if b then ?x_T else ?y_T)
balance
  balance (Branch color.R ?a ?w ?x ?b) ?s ?t (Branch color.R ?c ?y ?z ?d) ==
  Branch color.R (Branch color.B ?a ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z ?d)
  balance (Branch color.R (Branch color.R ?a ?w ?x ?b) ?s ?t ?c) ?y ?z
   rbt.Empty ==
  Branch color.R (Branch color.B ?a ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z rbt.Empty)
  balance (Branch color.R (Branch color.R ?a ?w ?x ?b) ?s ?t ?c) ?y ?z
   (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.R (Branch color.B ?a ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z (Branch color.B ?va ?vb ?vc ?vd))
  balance (Branch color.R rbt.Empty ?w ?x (Branch color.R ?b ?s ?t ?c)) ?y
   ?z rbt.Empty ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z rbt.Empty)
  balance
   (Branch color.R (Branch color.B ?va ?vb ?vc ?vd) ?w ?x
     (Branch color.R ?b ?s ?t ?c))
   ?y ?z rbt.Empty ==
  Branch color.R (Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z rbt.Empty)
  balance (Branch color.R rbt.Empty ?w ?x (Branch color.R ?b ?s ?t ?c)) ?y
   ?z (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z (Branch color.B ?va ?vb ?vc ?vd))
  balance
   (Branch color.R (Branch color.B ?ve ?vf ?vg ?vh) ?w ?x
     (Branch color.R ?b ?s ?t ?c))
   ?y ?z (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.R (Branch color.B (Branch color.B ?ve ?vf ?vg ?vh) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z (Branch color.B ?va ?vb ?vc ?vd))
  balance rbt.Empty ?w ?x
   (Branch color.R ?b ?s ?t (Branch color.R ?c ?y ?z ?d)) ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z ?d)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?w ?x
   (Branch color.R ?b ?s ?t (Branch color.R ?c ?y ?z ?d)) ==
  Branch color.R (Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z ?d)
  balance rbt.Empty ?w ?x
   (Branch color.R (Branch color.R ?b ?s ?t ?c) ?y ?z rbt.Empty) ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z rbt.Empty)
  balance rbt.Empty ?w ?x
   (Branch color.R (Branch color.R ?b ?s ?t ?c) ?y ?z
     (Branch color.B ?va ?vb ?vc ?vd)) ==
  Branch color.R (Branch color.B rbt.Empty ?w ?x ?b) ?s ?t
   (Branch color.B ?c ?y ?z (Branch color.B ?va ?vb ?vc ?vd))
  balance (Branch color.B ?va ?vb ?vc ?vd) ?w ?x
   (Branch color.R (Branch color.R ?b ?s ?t ?c) ?y ?z rbt.Empty) ==
  Branch color.R (Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z rbt.Empty)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?w ?x
   (Branch color.R (Branch color.R ?b ?s ?t ?c) ?y ?z
     (Branch color.B ?ve ?vf ?vg ?vh)) ==
  Branch color.R (Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?w ?x ?b)
   ?s ?t (Branch color.B ?c ?y ?z (Branch color.B ?ve ?vf ?vg ?vh))
  balance rbt.Empty ?s ?t rbt.Empty ==
  Branch color.B rbt.Empty ?s ?t rbt.Empty
  balance rbt.Empty ?s ?t (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B rbt.Empty ?s ?t (Branch color.B ?va ?vb ?vc ?vd)
  balance rbt.Empty ?s ?t (Branch ?v rbt.Empty ?vb ?vc rbt.Empty) ==
  Branch color.B rbt.Empty ?s ?t (Branch ?v rbt.Empty ?vb ?vc rbt.Empty)
  balance rbt.Empty ?s ?t
   (Branch ?v (Branch color.B ?ve ?vf ?vg ?vh) ?vb ?vc rbt.Empty) ==
  Branch color.B rbt.Empty ?s ?t
   (Branch ?v (Branch color.B ?ve ?vf ?vg ?vh) ?vb ?vc rbt.Empty)
  balance rbt.Empty ?s ?t
   (Branch ?v rbt.Empty ?vb ?vc (Branch color.B ?vf ?vg ?vh ?vi)) ==
  Branch color.B rbt.Empty ?s ?t
   (Branch ?v rbt.Empty ?vb ?vc (Branch color.B ?vf ?vg ?vh ?vi))
  balance rbt.Empty ?s ?t
   (Branch ?v (Branch color.B ?ve ?vj ?vk ?vl) ?vb ?vc
     (Branch color.B ?vf ?vg ?vh ?vi)) ==
  Branch color.B rbt.Empty ?s ?t
   (Branch ?v (Branch color.B ?ve ?vj ?vk ?vl) ?vb ?vc
     (Branch color.B ?vf ?vg ?vh ?vi))
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t rbt.Empty ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t rbt.Empty
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch color.B ?ve ?vf ?vg ?vh) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch color.B ?ve ?vf ?vg ?vh)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v rbt.Empty ?vf ?vg rbt.Empty) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v rbt.Empty ?vf ?vg rbt.Empty)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v (Branch color.B ?vi ?vj ?vk ?vl) ?vf ?vg rbt.Empty) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v (Branch color.B ?vi ?vj ?vk ?vl) ?vf ?vg rbt.Empty)
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v rbt.Empty ?vf ?vg (Branch color.B ?vj ?vk ?vl ?vm)) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v rbt.Empty ?vf ?vg (Branch color.B ?vj ?vk ?vl ?vm))
  balance (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v (Branch color.B ?vi ?vn ?vo ?vp) ?vf ?vg
     (Branch color.B ?vj ?vk ?vl ?vm)) ==
  Branch color.B (Branch color.B ?va ?vb ?vc ?vd) ?s ?t
   (Branch ?v (Branch color.B ?vi ?vn ?vo ?vp) ?vf ?vg
     (Branch color.B ?vj ?vk ?vl ?vm))
  balance (Branch ?v rbt.Empty ?vb ?vc rbt.Empty) ?s ?t rbt.Empty ==
  Branch color.B (Branch ?v rbt.Empty ?vb ?vc rbt.Empty) ?s ?t rbt.Empty
  balance (Branch ?v rbt.Empty ?vb ?vc (Branch color.B ?ve ?vf ?vg ?vh)) ?s
   ?t rbt.Empty ==
  Branch color.B
   (Branch ?v rbt.Empty ?vb ?vc (Branch color.B ?ve ?vf ?vg ?vh)) ?s ?t
   rbt.Empty
  balance (Branch ?v (Branch color.B ?vf ?vg ?vh ?vi) ?vb ?vc rbt.Empty) ?s
   ?t rbt.Empty ==
  Branch color.B
   (Branch ?v (Branch color.B ?vf ?vg ?vh ?vi) ?vb ?vc rbt.Empty) ?s ?t
   rbt.Empty
  balance
   (Branch ?v (Branch color.B ?vf ?vg ?vh ?vi) ?vb ?vc
     (Branch color.B ?ve ?vj ?vk ?vl))
   ?s ?t rbt.Empty ==
  Branch color.B
   (Branch ?v (Branch color.B ?vf ?vg ?vh ?vi) ?vb ?vc
     (Branch color.B ?ve ?vj ?vk ?vl))
   ?s ?t rbt.Empty
  balance (Branch ?v rbt.Empty ?vf ?vg rbt.Empty) ?s ?t
   (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B (Branch ?v rbt.Empty ?vf ?vg rbt.Empty) ?s ?t
   (Branch color.B ?va ?vb ?vc ?vd)
  balance (Branch ?v rbt.Empty ?vf ?vg (Branch color.B ?vi ?vj ?vk ?vl)) ?s
   ?t (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B
   (Branch ?v rbt.Empty ?vf ?vg (Branch color.B ?vi ?vj ?vk ?vl)) ?s ?t
   (Branch color.B ?va ?vb ?vc ?vd)
  balance (Branch ?v (Branch color.B ?vj ?vk ?vl ?vm) ?vf ?vg rbt.Empty) ?s
   ?t (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B
   (Branch ?v (Branch color.B ?vj ?vk ?vl ?vm) ?vf ?vg rbt.Empty) ?s ?t
   (Branch color.B ?va ?vb ?vc ?vd)
  balance
   (Branch ?v (Branch color.B ?vj ?vk ?vl ?vm) ?vf ?vg
     (Branch color.B ?vi ?vn ?vo ?vp))
   ?s ?t (Branch color.B ?va ?vb ?vc ?vd) ==
  Branch color.B
   (Branch ?v (Branch color.B ?vj ?vk ?vl ?vm) ?vf ?vg
     (Branch color.B ?vi ?vn ?vo ?vp))
   ?s ?t (Branch color.B ?va ?vb ?vc ?vd)
case_list
  case ?x21.0 # ?x22.0 of [] => ?f1.0 | x # xa => ?f2.0 x xa ==
  ?f2.0 ?x21.0 ?x22.0
  case [] of [] => ?f1.0 | x # xa => ?f2.0 x xa == ?f1.0
case_option
  case Some ?x2.0 of None => ?f1.0 | Some x => ?f2.0 x == ?f2.0 ?x2.0
  case None of None => ?f1.0 | Some x => ?f2.0 x == ?f1.0
case_prod
  case (?a, ?b) of (x, xa) => ?f x xa == ?f ?a ?b
conj
  ?p & True == ?p
  ?p & False == False
  True & ?p == ?p
  False & ?p == False
disj
  ?p | True == True
  ?p | False == ?p
  True | ?p == True
  False | ?p == ?p
fst
  fst (?x1.0, ?x2.0) == ?x1.0
integer_of_int
  integer_of_int (int_of_integer ?k) == ?k
integer_of_nat
  integer_of_nat (Code_Target_Nat.Nat ?x) == ?x
min
  min ?a ?b == if ?a <= ?b then ?a else ?b
min_wpl
  min_wpl ?w ?a ?b ==
  fst (run_state (min_wpl\<^sub>m' ?w ?a ?b) Mapping.empty)
min_wpl\<^sub>m'
  min_wpl\<^sub>m' ?w ?i ?j ==
  State_Monad.get >>=
  (%m. State_Monad.return (Mapping.lookup m (?i, ?j))) >>=
  case_option
   (State_Monad_Ext.if\<^sub>T (State_Monad.return (?j < ?i))
     (State_Monad.return 0)
     (State_Monad_Ext.fun_app_lifted
       (State_Monad.return
         (%a. State_Monad.return (Example_Misc.min_list a)))
       (State_Monad_Ext.fun_app_lifted
         (State_Monad_Ext.fun_app_lifted
           (State_Monad.return
             (%uu_. State_Monad.return (State_Main.map\<^sub>T' uu_)))
           (State_Monad.return
             (%k. State_Monad_Ext.fun_app_lifted
                   (State_Monad_Ext.fun_app_lifted
                     (State_Monad.return
                       (%a. State_Monad.return
                             (%b. State_Monad.return (a + b))))
                     (State_Monad_Ext.fun_app_lifted
                       (State_Monad_Ext.fun_app_lifted
                         (State_Monad.return
                           (%a. State_Monad.return
                                 (%b. State_Monad.return (a + b))))
                         (min_wpl\<^sub>m' ?w ?i (k - 1)))
                       (min_wpl\<^sub>m' ?w (k + 1) ?j)))
                   (State_Monad.return (?w ?i ?j)))))
         (State_Monad.return [?i..?j]))) >>=
    (%x. State_Monad.get >>=
         (%m. State_Monad.set (Mapping.update (?i, ?j) x m)) >>=
         (%_. State_Monad.return x)))
   State_Monad.return
minus [int]
  ?k - ?l == int_of_integer (integer_of_int ?k - integer_of_int ?l)
minus [integer]
  Code_Numeral.Neg ?m - Code_Numeral.Neg ?n == Code_Numeral.sub ?n ?m
  Code_Numeral.Neg ?m - Code_Numeral.Pos ?n == Code_Numeral.Neg (?m + ?n)
  Code_Numeral.Pos ?m - Code_Numeral.Neg ?n == Code_Numeral.Pos (?m + ?n)
  Code_Numeral.Pos ?m - Code_Numeral.Pos ?n == Code_Numeral.sub ?m ?n
  0 - ?l == - ?l
  ?k - 0 == ?k
one_class.one [int]
  1 == int_of_integer (Code_Numeral.Pos num.One)
ord_class.less [int]
  ?k < ?l == integer_of_int ?k < integer_of_int ?l
ord_class.less [integer]
  Code_Numeral.Neg ?k < Code_Numeral.Neg ?l == ?l < ?k
  Code_Numeral.Neg ?k < Code_Numeral.Pos ?l == True
  Code_Numeral.Neg ?k < 0 == True
  Code_Numeral.Pos ?k < Code_Numeral.Neg ?l == False
  Code_Numeral.Pos ?k < Code_Numeral.Pos ?l == ?k < ?l
  Code_Numeral.Pos ?k < 0 == False
  0 < Code_Numeral.Neg ?l == False
  0 < Code_Numeral.Pos ?l == True
  0 < 0 == False
ord_class.less [nat]
  ?m < ?n == integer_of_nat ?m < integer_of_nat ?n
ord_class.less [num]
  num.Bit1 ?m < num.Bit0 ?n == ?m < ?n
  num.Bit1 ?m < num.Bit1 ?n == ?m < ?n
  num.Bit0 ?m < num.Bit1 ?n == ?m <= ?n
  num.Bit0 ?m < num.Bit0 ?n == ?m < ?n
  num.One < num.Bit1 ?n == True
  num.One < num.Bit0 ?n == True
  ?m < num.One == False
ord_class.less [prod]
  (?x1.0, ?y1.0) < (?x2.0, ?y2.0) ==
  ?x1.0 < ?x2.0 | ?x1.0 <= ?x2.0 & ?y1.0 < ?y2.0
ord_class.less_eq [int]
  ?k <= ?l == integer_of_int ?k <= integer_of_int ?l
ord_class.less_eq [integer]
  Code_Numeral.Neg ?k <= Code_Numeral.Neg ?l == ?l <= ?k
  Code_Numeral.Neg ?k <= Code_Numeral.Pos ?l == True
  Code_Numeral.Neg ?k <= 0 == True
  Code_Numeral.Pos ?k <= Code_Numeral.Neg ?l == False
  Code_Numeral.Pos ?k <= Code_Numeral.Pos ?l == ?k <= ?l
  Code_Numeral.Pos ?k <= 0 == False
  0 <= Code_Numeral.Neg ?l == False
  0 <= Code_Numeral.Pos ?l == True
  0 <= 0 == True
ord_class.less_eq [nat]
  ?m <= ?n == integer_of_nat ?m <= integer_of_nat ?n
ord_class.less_eq [num]
  num.Bit1 ?m <= num.Bit0 ?n == ?m < ?n
  num.Bit1 ?m <= num.Bit1 ?n == ?m <= ?n
  num.Bit0 ?m <= num.Bit1 ?n == ?m <= ?n
  num.Bit0 ?m <= num.Bit0 ?n == ?m <= ?n
  num.Bit1 ?m <= num.One == False
  num.Bit0 ?m <= num.One == False
  num.One <= ?n == True
ord_class.less_eq [prod]
  (?x1.0, ?y1.0) <= (?x2.0, ?y2.0) ==
  ?x1.0 < ?x2.0 | ?x1.0 <= ?x2.0 & ?y1.0 <= ?y2.0
paint
  paint ?c rbt.Empty == rbt.Empty
  paint ?c (Branch ?uu ?l ?k ?v ?r) == Branch ?c ?l ?k ?v ?r
plus [int]
  ?k + ?l == int_of_integer (integer_of_int ?k + integer_of_int ?l)
plus [integer]
  Code_Numeral.Neg ?m + Code_Numeral.Neg ?n == Code_Numeral.Neg (?m + ?n)
  Code_Numeral.Neg ?m + Code_Numeral.Pos ?n == Code_Numeral.sub ?n ?m
  Code_Numeral.Pos ?m + Code_Numeral.Neg ?n == Code_Numeral.sub ?m ?n
  Code_Numeral.Pos ?m + Code_Numeral.Pos ?n == Code_Numeral.Pos (?m + ?n)
  0 + ?l == ?l
  ?k + 0 == ?k
plus [nat]
  integer_of_nat (?m + ?n) == integer_of_nat ?m + integer_of_nat ?n
plus [num]
  num.Bit1 ?m + num.Bit1 ?n == num.Bit0 (?m + ?n + num.One)
  num.Bit1 ?m + num.Bit0 ?n == num.Bit1 (?m + ?n)
  num.Bit1 ?m + num.One == num.Bit0 (?m + num.One)
  num.Bit0 ?m + num.Bit1 ?n == num.Bit1 (?m + ?n)
  num.Bit0 ?m + num.Bit0 ?n == num.Bit0 (?m + ?n)
  num.Bit0 ?m + num.One == num.Bit1 ?m
  num.One + num.Bit1 ?n == num.Bit0 (?n + num.One)
  num.One + num.Bit0 ?n == num.Bit1 ?n
  num.One + num.One == num.Bit0 num.One
rbt.impl_of
  rbt.impl_of (RBT ?x) == ?x
rbt_ins
  rbt_ins ?f ?k ?v rbt.Empty == Branch color.R rbt.Empty ?k ?v rbt.Empty
  rbt_ins ?f ?k ?v (Branch color.B ?l ?x ?y ?r) ==
  if ?k < ?x then balance (rbt_ins ?f ?k ?v ?l) ?x ?y ?r
  else if ?x < ?k then balance ?l ?x ?y (rbt_ins ?f ?k ?v ?r)
       else Branch color.B ?l ?x (?f ?k ?y ?v) ?r
  rbt_ins ?f ?k ?v (Branch color.R ?l ?x ?y ?r) ==
  if ?k < ?x then Branch color.R (rbt_ins ?f ?k ?v ?l) ?x ?y ?r
  else if ?x < ?k then Branch color.R ?l ?x ?y (rbt_ins ?f ?k ?v ?r)
       else Branch color.R ?l ?x (?f ?k ?y ?v) ?r
rbt_insert
  rbt_insert == rbt_insert_with_key (%_ _ nv. nv)
rbt_insert_with_key
  rbt_insert_with_key ?f ?k ?v ?t == paint color.B (rbt_ins ?f ?k ?v ?t)
rbt_lookup
  rbt_lookup rbt.Empty ?k == None
  rbt_lookup (Branch ?uu ?l ?x ?y ?r) ?k ==
  if ?k < ?x then rbt_lookup ?l ?k
  else if ?x < ?k then rbt_lookup ?r ?k else Some ?y
run_state
  run_state (State ?x) == ?x
uminus [integer]
  - Code_Numeral.Neg ?m == Code_Numeral.Pos ?m
  - Code_Numeral.Pos ?m == Code_Numeral.Neg ?m
  - 0 == 0
upto
  [?i..?j] == upto_aux ?i ?j []
upto_aux
  upto_aux ?i ?j ?js ==
  if ?j < ?i then ?js else upto_aux ?i (?j - 1) (?j # ?js)
zero_class.zero [nat]
  integer_of_nat 0 == 0
Warning: Value identifier (t) has not been referenced.
At (line 20 of "generated code")
Warning: Value identifier (less) has not been referenced.
At (line 48 of "generated code")
Warning: Value identifier (uu) has not been referenced.
At (line 68 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 84 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 101 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 103 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 112 of "generated code")
Warning: Value identifier (B_) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 115 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 160 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 163 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 165 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 216 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 226 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 233 of "generated code")
Warning: Matches are not exhaustive.
fun min_list A_ (... :: ...) = (case xs of [...] => x | ... => ...)
At (line 247 of "generated code")
structure Test:
  sig type inta val min_wpl_test: unit -> nat type nat type num end
val it = Nat 10: Test.nat
### theory "Draft.OptBST"
### 2.944s elapsed time, 3.436s cpu time, 0.256s GC time
Loading theory "Draft.OptBSTTemplates"
val templateLemmas =
   [("OptBST.cost'_Leaf", "cost' ?p \<langle>\<rangle> = 0",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_hole 0)),
    ("OptBST.depth_not_neg_inf", "(depth ?x ?t = -\<infinity>) = False",
     template_equation
      (template_app
        (template_app
          (template_hole 3,
           template_app
            (template_app (template_hole 2, template_var 1),
             template_var 0)),
         template_hole 1),
       template_hole 0)),
    ("OptBST.W_fun_correct", "W_fun ?p ?i ?j = OptBST.W ?p ?i ?j",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 1, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app (template_hole 0, template_var 2), template_var 1),
         template_var 0))),
    ("OptBST.opt_bst_correct", "inorder (opt_bst ?W ?i ?j) = [?i..?j]",
     template_equation
      (template_app
        (template_hole 2,
         template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app (template_hole 0, template_var 1), template_var 0))),
    ("OptBST.min_wpl'_correct",
     "min_wpl' ?p ?i ?j = min_wpl (OptBST.W ?p) ?i ?j",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 2, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 2)),
           template_var 1),
         template_var 0))),
    ("OptBST.opt_bst'_correct",
     "opt_bst' ?p ?i ?j = opt_bst (OptBST.W ?p) ?i ?j",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 2, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 1,
             template_app (template_hole 0, template_var 2)),
           template_var 1),
         template_var 0))),
    ("OptBST.depth_inf_iff",
     "(depth ?x ?t = \<infinity>) = (?x ~: set_tree ?t)",
     template_equation
      (template_app
        (template_app
          (template_hole 5,
           template_app
            (template_app (template_hole 4, template_var 1),
             template_var 0)),
         template_hole 3),
       template_app
        (template_hole 2,
         template_app
          (template_app (template_hole 1, template_var 1),
           template_app (template_hole 0, template_var 0))))),
    ("OptBST.weight_correct",
     "distinct (inorder ?t) ==> cost' ?p ?t = cost ?p ?t",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 4,
              template_app (template_hole 3, template_var 1))
            )],
       template_equation
        (template_app
          (template_app (template_hole 1, template_var 0), template_var 1),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_var 1)))),
    ("OptBST.set_tree_depth",
     "?x ~: set_tree ?t ==> depth ?x ?t = \<infinity>",
     template_implication
      ([template_negation
         (
            template_predicate
             (
                template_app
                 (template_app (template_hole 4, template_var 1),
                  template_app (template_hole 3, template_var 0))
                )
            )],
       template_equation
        (template_app
          (template_app (template_hole 1, template_var 1), template_var 0),
         template_hole 0))),
    ("OptBST.min_wpl_tree",
     "cost ?p (opt_bst (OptBST.W ?p) ?i ?j) = min_wpl (OptBST.W ?p) ?i ?j",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 2),
         template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 2)),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_app
            (template_hole 0,
             template_app (template_hole 1, template_var 2)),
           template_var 1),
         template_var 0))),
    ("OptBST.wpl_opt_bst",
     "wpl ?W ?i ?j (opt_bst ?W ?i ?j) = min_wpl ?W ?i ?j",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app (template_hole 2, template_var 2),
             template_var 1),
           template_var 0),
         template_app
          (template_app
            (template_app (template_hole 1, template_var 2),
             template_var 1),
           template_var 0)),
       template_app
        (template_app
          (template_app (template_hole 0, template_var 2), template_var 1),
         template_var 0))),
    ("OptBST.min_wpl_heap",
     "min_wpl ?W ?i ?j =
      result_of (min_wpl\<^sub>h ?W ?n ?i ?j) Heap.empty",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 5, template_var 3), template_var 2),
         template_var 1),
       template_app
        (template_hole 4,
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_app
                    (template_app (template_hole 1, template_var 3),
                     template_var 0),
                   template_var 2),
                 template_var 1)),
             template_hole 0))))),
    ("OptBST.atLeastAtMost_split_insert",
     "?i <= ?k ==> {?i..?k} = insert ?k {?i..?k - 1}",
     template_implication
      ([template_inequation (less_equals, template_var 1, template_var 0)],
       template_equation
        (template_app
          (template_app (template_hole 3, template_var 1), template_var 0),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_app
            (template_app (template_hole 3, template_var 1),
             template_app
              (template_app (template_hole 1, template_var 0),
               template_hole 0)))))),
    ("OptBST.argmin_Min",
     "?xs ~= [] ==> ?f (argmin ?f ?xs) = Min (?f ` set ?xs)",
     template_implication
      ([template_negation
         (template_equation (template_var 1, template_hole 5))],
       template_equation
        (template_app
          (template_var 0,
           template_app
            (template_app (template_hole 3, template_var 0),
             template_var 1)),
         template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 0),
             template_app (template_hole 0, template_var 1)))))),
    ("OptBST.min_wpl_minimal_cost",
     "inorder ?t = [?i..?j] ==> min_wpl (OptBST.W ?p) ?i ?j <= cost ?p ?t",
     template_implication
      ([template_equation
         (template_app (template_hole 5, template_var 3),
          template_app
           (template_app (template_hole 4, template_var 2),
            template_var 1))],
       template_inequation
        (less_equals,
         template_app
          (template_app
            (template_app
              (template_hole 2,
               template_app (template_hole 1, template_var 0)),
             template_var 2),
           template_var 1),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_var 3)))),
    ("OptBST.inorder_wpl_correct",
     "inorder ?t = [?i..?j] ==> wpl (OptBST.W ?p) ?i ?j ?t = cost ?p ?t",
     template_implication
      ([template_equation
         (template_app (template_hole 5, template_var 3),
          template_app
           (template_app (template_hole 4, template_var 2),
            template_var 1))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_app
                (template_hole 2,
                 template_app (template_hole 1, template_var 0)),
               template_var 2),
             template_var 1),
           template_var 3),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_var 3)))),
    ("OptBST.min_wpl_minimal",
     "inorder ?t = [?i..?j] ==> min_wpl ?W ?i ?j <= wpl ?W ?i ?j ?t",
     template_implication
      ([template_equation
         (template_app (template_hole 4, template_var 3),
          template_app
           (template_app (template_hole 3, template_var 2),
            template_var 1))],
       template_inequation
        (less_equals,
         template_app
          (template_app
            (template_app (template_hole 1, template_var 0),
             template_var 2),
           template_var 1),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 0, template_var 0),
               template_var 2),
             template_var 1),
           template_var 3)))),
    ("OptBST.compute_W_correct",
     "Mapping.lookup (compute_W ?p ?n) (?i, ?j) = Some ?x ==>
      OptBST.W ?p ?i ?j = ?x",
     template_implication
      ([template_equation
         (template_app
           (template_app
             (template_hole 5,
              template_app
               (template_app (template_hole 4, template_var 4),
                template_var 3)),
            template_app
             (template_app (template_hole 3, template_var 2),
              template_var 1)),
          template_app (template_hole 2, template_var 0))],
       template_equation
        (template_app
          (template_app
            (template_app (template_hole 0, template_var 4),
             template_var 2),
           template_var 1),
         template_var 0))),
    ("OptBST.W_rec",
     "OptBST.W ?p ?i ?j =
      (if ?i <= ?j then OptBST.W ?p ?i (?j - 1) + ?p ?j else 0)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 6, template_var 2), template_var 1),
         template_var 0),
       template_app
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 4, template_var 1),
               template_var 0)),
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app
                  (template_app (template_hole 6, template_var 2),
                   template_var 1),
                 template_app
                  (template_app (template_hole 2, template_var 0),
                   template_hole 1))),
             template_app (template_var 2, template_var 0))),
         template_hole 0))),
    ("OptBST.W_compute",
     "OptBST.W ?p ?i ?j =
      (case Mapping.lookup (compute_W ?p ?n) (?i, ?j) of
       None => OptBST.W ?p ?i ?j | Some x => x)",
     template_equation
      (template_app
        (template_app
          (template_app (template_hole 4, template_var 3), template_var 2),
         template_var 1),
       template_app
        (template_app
          (template_app
            (template_hole 3,
             template_app
              (template_app
                (template_app (template_hole 4, template_var 3),
                 template_var 2),
               template_var 1)),
           t_empty),
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 1, template_var 3),
               template_var 0)),
           template_app
            (template_app (template_hole 0, template_var 2),
             template_var 1))))),
    ("OptBST.opt_bst_has_optimal_cost",
     "inorder ?t = [?i..?j] ==>
      cost ?p (opt_bst (OptBST.W ?p) ?i ?j) <= cost ?p ?t",
     template_implication
      ([template_equation
         (template_app (template_hole 5, template_var 3),
          template_app
           (template_app (template_hole 4, template_var 2),
            template_var 1))],
       template_inequation
        (less_equals,
         template_app
          (template_app (template_hole 2, template_var 0),
           template_app
            (template_app
              (template_app
                (template_hole 1,
                 template_app (template_hole 0, template_var 0)),
               template_var 2),
             template_var 1)),
         template_app
          (template_app (template_hole 2, template_var 0),
           template_var 3)))),
    ("OptBST.depth_FinD",
     "[| ?x : set_tree ?t; !!d. depth ?x ?t = Fin d ==> ?thesis |]
      ==> ?thesis",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app (template_hole 5, template_var 2),
              template_app (template_hole 4, template_var 1))
            ),
        template_predicate (template_app (template_hole 3, t_empty))],
       template_predicate (template_var 0))),
    ("OptBST.opt_bst_is_optimal",
     "inorder ?t = [?i..?j] ==>
      wpl ?W ?i ?j (opt_bst ?W ?i ?j) <= wpl ?W ?i ?j ?t",
     template_implication
      ([template_equation
         (template_app (template_hole 4, template_var 3),
          template_app
           (template_app (template_hole 3, template_var 2),
            template_var 1))],
       template_inequation
        (less_equals,
         template_app
          (template_app
            (template_app
              (template_app (template_hole 1, template_var 0),
               template_var 2),
             template_var 1),
           template_app
            (template_app
              (template_app (template_hole 0, template_var 0),
               template_var 2),
             template_var 1)),
         template_app
          (template_app
            (template_app
              (template_app (template_hole 1, template_var 0),
               template_var 2),
             template_var 1),
           template_var 3)))),
    ("OptBST.argmin_forall",
     "[| ?xs ~= []; !!x. x : set ?xs ==> ?P x |] ==> ?P (argmin ?f ?xs)",
     template_implication
      ([template_negation
         (template_equation (template_var 2, template_hole 4)),
        template_predicate (template_app (template_hole 3, t_empty))],
       template_predicate
        (
           template_app
            (template_var 1,
             template_app
              (template_app (template_hole 0, template_var 0),
               template_var 2))
           ))),
    ("OptBST.atLeastAtMost_split",
     "[| ?i <= ?k; ?k <= ?j |] ==> {?i..?j} = {?i..?k} Un {?k + 1..?j}",
     template_implication
      ([template_inequation (less_equals, template_var 2, template_var 1),
        template_inequation (less_equals, template_var 1, template_var 0)],
       template_equation
        (template_app
          (template_app (template_hole 3, template_var 2), template_var 0),
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app (template_hole 3, template_var 2),
               template_var 1)),
           template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_hole 0)),
             template_var 0))))),
    ("OptBST.upto_join",
     "[| ?i <= ?j; ?j <= ?k |]
      ==> [?i..?j - 1] @ ?j # [?j + 1..?k] = [?i..?k]",
     template_implication
      ([template_inequation (less_equals, template_var 2, template_var 1),
        template_inequation (less_equals, template_var 1, template_var 0)],
       template_equation
        (template_app
          (template_app
            (template_hole 5,
             template_app
              (template_app (template_hole 4, template_var 2),
               template_app
                (template_app (template_hole 3, template_var 1),
                 template_hole 2))),
           template_app
            (template_app (template_hole 1, template_var 1),
             template_app
              (template_app
                (template_hole 4,
                 template_app
                  (template_app (template_hole 0, template_var 1),
                   template_hole 2)),
               template_var 0))),
         template_app
          (template_app (template_hole 4, template_var 2),
           template_var 0)))),
    ("OptBST.cost'_Node",
     "distinct (inorder \<langle>?l, ?x, ?r\<rangle>) ==>
      cost' ?p \<langle>?l, ?x, ?r\<rangle> =
      sum ?p (set_tree ?l) + cost' ?p ?l + ?p ?x + cost' ?p ?r +
      sum ?p (set_tree ?r)",
     template_implication
      ([template_predicate
         (
            template_app
             (template_hole 7,
              template_app
               (template_hole 6,
                template_app
                 (template_app
                   (template_app (template_hole 5, template_var 3),
                    template_var 2),
                  template_var 1)))
            )],
       template_equation
        (template_app
          (template_app (template_hole 3, template_var 0),
           template_app
            (template_app
              (template_app (template_hole 5, template_var 3),
               template_var 2),
             template_var 1)),
         template_app
          (template_app
            (template_hole 2,
             template_app
              (template_app
                (template_hole 2,
                 template_app
                  (template_app
                    (template_hole 2,
                     template_app
                      (template_app
                        (template_hole 2,
                         template_app
                          (template_app (template_hole 1, template_var 0),
                           template_app (template_hole 0, template_var 3))),
                       template_app
                        (template_app (template_hole 3, template_var 0),
                         template_var 3))),
                   template_app (template_var 0, template_var 2))),
               template_app
                (template_app (template_hole 3, template_var 0),
                 template_var 1))),
           template_app
            (template_app (template_hole 1, template_var 0),
             template_app (template_hole 0, template_var 1)))))),
    ("OptBST.W\<^sub>m_crel",
     "(?m, ?x) = (?m, ?y) ==>
      dp_consistency.crel_vs
       (%k. State_Monad.get >>=
            (%m. State_Monad.return (Mapping.lookup m k)))
       (%_. True) (%(a, b). W_fun ?p a b) (=) (W_fun ?p ?m ?x)
       (W\<^sub>m' ?p ?m ?y)",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 10, template_var 3),
            template_var 2),
          template_app
           (template_app (template_hole 10, template_var 3),
            template_var 1))],
       template_predicate
        (
           template_app
            (template_app
              (template_app
                (template_app
                  (template_app
                    (template_app (template_hole 9, t_empty), t_empty),
                   template_app (template_hole 3, t_empty)),
                 template_hole 1),
               template_app
                (template_app
                  (template_app (template_hole 2, template_var 0),
                   template_var 3),
                 template_var 2)),
             template_app
              (template_app
                (template_app (template_hole 0, template_var 0),
                 template_var 3),
               template_var 1))
           ))),
    ("OptBST.memoized_empty",
     "[| dp_heap.consistentDP
          (%heap.
              Array.length heap ?mem =
              bounded_index.size (Bound (0, 0) (int ?n, int ?n)))
          (%heap.
              Array.length heap ?mem =
              bounded_index.size (Bound (0, 0) (int ?n, int ?n)))
          (%(a, b). min_wpl ?W a b)
          (heap_mem_defs.lookup'
            (mem_lookup (bounded_index.size (Bound (0, 0) (int ?n, int ?n)))
              (bounded_index.checked_idx (Bound (0, 0) (int ?n, int ?n)))
              ?mem))
          (?dp\<^sub>T ?mem);
         ?mem =
         result_of
          (mem_empty (bounded_index.size (Bound (0, 0) (int ?n, int ?n))))
          Heap.empty |]
      ==> (case ?x of (a, b) => min_wpl ?W a b) =
          result_of
           (mem_empty
             (bounded_index.size (Bound (0, 0) (int ?n, int ?n))) >>=
            (%mem. ?dp\<^sub>T mem ?x))
           Heap.empty",
     template_implication
      ([template_predicate
         (
            template_app
             (template_app
               (template_app
                 (template_app
                   (template_app (template_hole 22, t_empty), t_empty),
                  template_app (template_hole 14, t_empty)),
                template_app
                 (template_hole 12,
                  template_app
                   (template_app
                     (template_app
                       (template_hole 11,
                        template_app
                         (template_hole 19,
                          template_app
                           (template_app
                             (template_hole 18,
                              template_app
                               (template_app
                                 (template_hole 17, template_hole 16),
                                template_hole 16)),
                            template_app
                             (template_app
                               (template_hole 17,
                                template_app
                                 (template_hole 15, template_var 3)),
                              template_app
                               (template_hole 15, template_var 3))))),
                      template_app
                       (template_hole 10,
                        template_app
                         (template_app
                           (template_hole 18,
                            template_app
                             (template_app
                               (template_hole 17, template_hole 16),
                              template_hole 16)),
                          template_app
                           (template_app
                             (template_hole 17,
                              template_app
                               (template_hole 15, template_var 3)),
                            template_app
                             (template_hole 15, template_var 3))))),
                    template_var 4))),
              template_app (template_var 1, template_var 4))
            ),
        template_equation
         (template_var 4,
          template_app
           (template_hole 8,
            template_app
             (template_hole 7,
              template_app
               (template_app
                 (template_hole 6,
                  template_app
                   (template_hole 5,
                    template_app
                     (template_hole 19,
                      template_app
                       (template_app
                         (template_hole 18,
                          template_app
                           (template_app
                             (template_hole 17, template_hole 16),
                            template_hole 16)),
                        template_app
                         (template_app
                           (template_hole 17,
                            template_app
                             (template_hole 15, template_var 3)),
                          template_app
                           (template_hole 15, template_var 3)))))),
                template_hole 4))))],
       template_equation
        (template_app
          (template_app (template_hole 14, t_empty), template_var 0),
         template_app
          (template_hole 3,
           template_app
            (template_hole 2,
             template_app
              (template_app
                (template_hole 1,
                 template_app
                  (template_app
                    (template_hole 0,
                     template_app
                      (template_hole 5,
                       template_app
                        (template_hole 19,
                         template_app
                          (template_app
                            (template_hole 18,
                             template_app
                              (template_app
                                (template_hole 17, template_hole 16),
                               template_hole 16)),
                           template_app
                            (template_app
                              (template_hole 17,
                               template_app
                                (template_hole 15, template_var 3)),
                             template_app
                              (template_hole 15, template_var 3)))))),
                   t_empty)),
               template_hole 4))))))]:
   (string * thm * template) list
### theory "Draft.OptBSTTemplates"
### 0.562s elapsed time, 0.743s cpu time, 0.090s GC time
val it = (): unit
