Loading theory "Draft.Ground_Function" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0")
Loading theory "Draft.Indexing" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.Heap_Main" via "Draft.Memory_Heap")
Loading theory "Draft.Pure_Monad" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main" via "Draft.Transform_Cmd")
Loading theory "Draft.Solve_Cong" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.Heap_Main")
### ML warning (file "$AFP/Monad_Memo_DP/util/Ground_Function.ML"):
### Pattern is not exhaustive.
### ML warning (line 28 of "$AFP/Monad_Memo_DP/util/Ground_Function.ML"):
### Pattern is not exhaustive.
signature GROUND_FUNCTION =
  sig
    val mk_fun: bool -> thm list -> binding -> local_theory -> local_theory
  end
structure Ground_Function: GROUND_FUNCTION
### theory "Draft.Pure_Monad"
### 0.040s elapsed time, 0.192s cpu time, 0.000s GC time
Loading theory "Draft.State_Heap_Misc" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main" via "Draft.Transform_Cmd" via "Draft.DP_CRelVH" via "Draft.State_Heap")
val ground_function_cmd = fn:
   (''a option * binding) * (Facts.ref * Token.src list) list ->
     Proof.context -> local_theory
val ground_function_parser = fn:
   Token.T list ->
     ((string option * binding) * (Facts.ref * Token.src list) list) *
     Token.T list
### theory "Draft.Ground_Function"
### 0.051s elapsed time, 0.236s cpu time, 0.000s GC time
Loading theory "Draft.State_Monad_Ext" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main" via "Draft.Transform_Cmd" via "Draft.DP_CRelVS")
bundle state_monad_syntax
### theory "Draft.State_Monad_Ext"
### 0.060s elapsed time, 0.224s cpu time, 0.032s GC time
Loading theory "Draft.DP_CRelVS" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main" via "Draft.Transform_Cmd")
### theory "Draft.State_Heap_Misc"
### 0.072s elapsed time, 0.277s cpu time, 0.032s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
locale prod_order_def
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
Found termination order: "{}"
### theory "HOL-Library.Function_Algebras"
### 0.095s elapsed time, 0.381s cpu time, 0.000s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.ExtrEqs")
Found termination order: "{}"
### theory "Draft.Solve_Cong"
### 0.229s elapsed time, 0.938s cpu time, 0.032s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
locale state_mem_defs
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
locale mem_correct
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
  assumes "mem_correct lookup update P"
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
locale prod_order
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
  assumes "prod_order less_eq0 less0 less_eq1 less1"
### theory "HOL-Library.Set_Algebras"
### 0.216s elapsed time, 0.843s cpu time, 0.090s GC time
Loading theory "Draft.Templates" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.ExtrEqs")
### theory "Draft.DP_CRelVS"
### 0.378s elapsed time, 1.483s cpu time, 0.154s GC time
Loading theory "Draft.Memory" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main")
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.078s elapsed time, 0.303s cpu time, 0.065s GC time
Loading theory "Draft.Heap_Monad_Ext" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main" via "Draft.Transform_Cmd" via "Draft.DP_CRelVH" via "Draft.State_Heap")
bundle heap_monad_syntax
### theory "Draft.Heap_Monad_Ext"
### 0.043s elapsed time, 0.174s cpu time, 0.000s GC time
Loading theory "Draft.State_Heap" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main" via "Draft.Transform_Cmd" via "Draft.DP_CRelVH")
locale option_order
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
  assumes "option_order less_eq0 less0"
consts
  shift :: "'a list => 'a stream => 'a stream"
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
Found termination order: "{}"
locale dp_consistency_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and dp :: "'a => 'c"
    and empty :: "'b"
  assumes "dp_consistency_empty lookup update P empty"
locale dp_consistency_default
  fixes dp :: "'param => 'result"
Found termination order: "{}"
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
locale dp_consistency_mapping
  fixes dp :: "'param => 'result"
consts
  sdrop :: "nat => 'a stream => 'a stream"
locale state_mem_defs
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
locale mem_correct
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
  assumes "mem_correct lookup update P"
consts
  cycle :: "'a list => 'a stream"
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
locale dp_consistency_mapping_tracing
  fixes dp :: "'param => 'result"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
consts
  flat :: "'a list stream => 'a stream"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
### theory "Draft.Memory"
### 0.698s elapsed time, 2.599s cpu time, 0.696s GC time
Loading theory "Draft.Bottom_Up_Computation" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.Heap_Main" via "Draft.Bottom_Up_Computation_Heap")
locale heap_mem_defs
  fixes P :: "heap => bool"
    and lookup :: "'k => 'v option Heap"
    and update :: "'k => 'v => unit Heap"
### Ambiguous input (line 63 of "$AFP/Monad_Memo_DP/heap_monad/State_Heap.thy") produces 2 parse trees:
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" rel_state)
###     ("_cargs" ("_position" R) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>HOL.All_binder" ("_position" heap)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" heap))
###       ("_case_syntax"
###         ("_applC" ("_position" State_Monad.run_state)
###           ("_cargs" ("_position" f) ("_position" heap)))
###         ("_case1"
###           ("_tuple" ("_position" v1) ("_tuple_arg" ("_position" heap1)))
###           ("_case_syntax"
###             ("_applC" ("_position" execute)
###               ("_cargs" ("_position" g) ("_position" heap)))
###             ("_case2"
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" v2)
###                     ("_tuple_arg" ("_position" heap2))))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" R)
###                     ("_cargs" ("_position" v1) ("_position" v2)))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_position" heap1)
###                       ("_position" heap2))
###                     ("_applC" ("_position" P) ("_position" heap2)))))
###               ("_case1" ("_position" None) ("_position" False)))))))))
### ("\<^const>Pure.eq"
###   ("_applC" ("_position" rel_state)
###     ("_cargs" ("_position" R) ("_cargs" ("_position" f) ("_position" g))))
###   ("\<^const>HOL.All_binder" ("_position" heap)
###     ("\<^const>HOL.implies" ("_applC" ("_position" P) ("_position" heap))
###       ("_case_syntax"
###         ("_applC" ("_position" State_Monad.run_state)
###           ("_cargs" ("_position" f) ("_position" heap)))
###         ("_case2"
###           ("_case1"
###             ("_tuple" ("_position" v1) ("_tuple_arg" ("_position" heap1)))
###             ("_case_syntax"
###               ("_applC" ("_position" execute)
###                 ("_cargs" ("_position" g) ("_position" heap)))
###               ("_case1"
###                 ("_applC" ("_position" Some)
###                   ("_tuple" ("_position" v2)
###                     ("_tuple_arg" ("_position" heap2))))
###                 ("\<^const>HOL.conj"
###                   ("_applC" ("_position" R)
###                     ("_cargs" ("_position" v1) ("_position" v2)))
###                   ("\<^const>HOL.conj"
###                     ("\<^const>HOL.eq" ("_position" heap1)
###                       ("_position" heap2))
###                     ("_applC" ("_position" P) ("_position" heap2)))))))
###           ("_case1" ("_position" None) ("_position" False)))))))
### Fortunately, only one parse tree is well-formed and type-correct,
### but you may still want to disambiguate your grammar or your input.
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
### theory "HOL-Library.Stream"
### 1.094s elapsed time, 4.143s cpu time, 0.898s GC time
Loading theory "Draft.Pair_Memory" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.Heap_Main" via "Draft.Memory_Heap")
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
locale heap_inv
  fixes P :: "heap => bool"
    and update :: "'k => 'v => unit Heap"
    and lookup :: "'k => 'v option Heap"
  assumes "heap_inv P update lookup"
locale iterator_defs
  fixes cnt :: "'a => bool"
    and nxt :: "'a => 'a"
locale pair_mem_defs
  fixes lookup1 :: "'a => ('mem, 'v option) state"
    and lookup2 :: "'a => ('mem, 'v option) state"
    and update1 :: "'a => 'v => ('mem, unit) state"
    and update2 :: "'a => 'v => ('mem, unit) state"
    and move12 :: "'k1 => ('mem, unit) state"
    and get_k1 :: "('mem, 'k1) state"
    and get_k2 :: "('mem, 'k1) state"
    and P :: "'mem => bool"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'a"
locale iterator
  fixes cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "iterator cnt nxt sizef"
locale heap_correct
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
  assumes "heap_correct P update lookup"
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
locale heap_mem_defs
  fixes P :: "heap => bool"
    and lookup :: "'k => 'v option Heap"
    and update :: "'k => 'v => unit Heap"
### theory "Draft.State_Heap"
### 0.835s elapsed time, 3.143s cpu time, 0.744s GC time
Loading theory "Draft.DP_CRelVH" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main" via "Draft.Transform_Cmd")
locale index_locale_def
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
locale dp_consistency_iterator
  fixes P :: "'b => bool"
    and dp :: "'a => 'c"
    and lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "dp_consistency_iterator P lookup update cnt nxt sizef"
locale dp_heap
  fixes P :: "heap => bool"
    and Q :: "heap => bool"
    and dp :: "'k => 'v"
    and lookup :: "'k => 'v option Heap"
    and lookup_st :: "'k => (heap, 'v option) state"
    and update :: "'k => 'v => unit Heap"
    and update_st :: "'k => 'v => (heap, unit) state"
  assumes "dp_heap P Q lookup lookup_st update update_st"
locale index_locale
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
  assumes "index_locale less_eq less idx size"
locale dp_consistency_iterator_empty
  fixes P :: "'a => bool"
    and dp :: "'b => 'c"
    and lookup :: "'b => ('a, 'c option) state"
    and update :: "'b => 'c => ('a, unit) state"
    and cnt :: "'b => bool"
    and nxt :: "'b => 'b"
    and sizef :: "'b => nat"
    and empty :: "'a"
  assumes
    "dp_consistency_iterator_empty P lookup update cnt nxt sizef empty"
### theory "Draft.Bottom_Up_Computation"
### 0.401s elapsed time, 1.569s cpu time, 0.115s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.ExtrEqs")
locale prod_index_def
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
    and idx1 :: "'b bound => 'b => nat"
    and size1 :: "'b bound => nat"
locale pair_mem
  fixes lookup1 :: "'a => ('b, 'c option) state"
    and lookup2 :: "'a => ('b, 'c option) state"
    and update1 :: "'a => 'c => ('b, unit) state"
    and update2 :: "'a => 'c => ('b, unit) state"
    and move12 :: "'d => ('b, unit) state"
    and get_k1 :: "('b, 'd) state"
    and get_k2 :: "('b, 'd) state"
    and P :: "'b => bool"
    and key1 :: "'e => 'd"
    and key2 :: "'e => 'a"
  assumes "pair_mem lookup1 lookup2 update1 update2 move12 get_k1 get_k2 P"
locale dp_consistency_heap
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
  assumes "dp_consistency_heap P update lookup"
Found termination order: "{}"
Found termination order: "{}"
locale heap_correct_empty
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and empty :: "heap"
  assumes "heap_correct_empty P update lookup empty"
locale dp_consistency_heap_empty
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
    and empty :: "heap"
  assumes "dp_consistency_heap_empty P update lookup empty"
### theory "Draft.DP_CRelVH"
### 0.469s elapsed time, 1.826s cpu time, 0.195s GC time
Loading theory "Draft.Bottom_Up_Computation_Heap" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.Heap_Main")
locale prod_index
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
    and less_eq1 :: "'b => 'b => bool"
    and less1 :: "'b => 'b => bool"
    and idx1 :: "'b bound => 'b => nat"
    and size1 :: "'b bound => nat"
  assumes "prod_index less_eq0 less0 idx0 size0 less_eq1 less1 idx1 size1"
locale option_index
  fixes less_eq0 :: "'a => 'a => bool"
    and less0 :: "'a => 'a => bool"
    and idx0 :: "'a bound => 'a => nat"
    and size0 :: "'a bound => nat"
  assumes "option_index less_eq0 less0 idx0 size0"
locale dp_consistency_iterator_heap
  fixes lookup :: "'a => 'c option Heap"
    and update :: "'a => 'c => unit Heap"
    and P :: "heap => bool"
    and dp :: "'a => 'c"
    and cnt :: "'a => bool"
    and nxt :: "'a => 'a"
    and sizef :: "'a => nat"
  assumes "dp_consistency_iterator_heap lookup update P cnt nxt sizef"
Found termination order: "{}"
### theory "Draft.Bottom_Up_Computation_Heap"
### 0.457s elapsed time, 1.793s cpu time, 0.171s GC time
Loading theory "Draft.Transform_Cmd" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.State_Main")
locale nat_index_def
### ML warning (line 17 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (import_function_info) has not been referenced.
### ML warning (line 27 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Pattern is not exhaustive.
### ML warning (line 30 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (head_of) has not been referenced.
### ML warning (line 31 of "$AFP/Monad_Memo_DP/transform/Transform_Misc.ML"):
### Value identifier (bind_of) has not been referenced.
signature TRANSFORM_MISC =
  sig
    val add_function:
       binding -> term list -> local_theory -> Function.info * local_theory
    val behead: term -> term -> term * term list
    val get_const_pat: Proof.context -> string -> term
    val locale_term: Proof.context -> string -> string -> term
    val locale_thms: Proof.context -> string -> string -> thm list
    val rel_of: Function.info -> Proof.context -> thm
    val term_name: term -> string
    val the_element: int list -> int
    val totality_of: Function.info -> thm
    val uncurry: term -> term
  end
structure Transform_Misc: TRANSFORM_MISC
Found termination order: "{}"
### ML warning (line 18 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (pureapp) has not been referenced.
### ML warning (line 32 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (memT) has not been referenced.
### ML warning (line 45 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmem') has not been referenced.
### ML warning (line 48 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmemC) has not been referenced.
### ML warning (line 80 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmem') has not been referenced.
### ML warning (line 83 of "$AFP/Monad_Memo_DP/transform/Transform_Const.ML"):
### Value identifier (checkmemC) has not been referenced.
signature TRANSFORM_CONST =
  sig
    type MONAD_CONSTS =
       {app: term * term -> term,
        checkmemVN: string,
        if_termN: string,
        mk_stateT: typ -> typ,
        monad_name: string,
        return: term -> term, rewrite_app_beta_conv: conv}
    val get_monad_const: string -> MONAD_CONSTS
  end
structure Transform_Const: TRANSFORM_CONST
locale mem_correct_empty
  fixes lookup :: "'a => ('b, 'c option) state"
    and update :: "'a => 'c => ('b, unit) state"
    and P :: "'b => bool"
    and empty :: "'b"
  assumes "mem_correct_empty lookup update P empty"
Found termination order: "{}"
### ML warning (line 104 of "$AFP/Monad_Memo_DP/transform/Transform_Data.ML"):
### Value identifier (put_monadified_terms_generic) has not been referenced.
signature TRANSFORM_DATA =
  sig
    val add_tmp_cmd_info:
       binding * term * string option -> local_theory -> local_theory
    type cmd_info =
       {dp_info: dp_info option,
        head: term, locale: string option, scope: binding}
    val commit_dp_info: string -> dp_info -> local_theory -> local_theory
    type dp_info =
       {new_def': thm list,
        new_defT: thm,
        new_head': term,
        new_headT: term, old_defs: thm list, old_head: term}
    val get_dp_info: string -> Proof.context -> term -> dp_info option
    val get_last_cmd_info: Proof.context -> cmd_info
    val get_or_last_cmd_info:
       Proof.context -> (string * term) option -> cmd_info
  end
structure Transform_Data: TRANSFORM_DATA
### theory "HOL-Library.BigO"
### 0.890s elapsed time, 3.489s cpu time, 0.378s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.Min_Ed_Dist0Templates")
### ML warning (line 28 of "$AFP/Monad_Memo_DP/transform/Transform_Tactic.ML"):
### Value identifier (msg) has not been referenced.
signature TRANSFORM_TACTIC =
  sig
    val dp_unfold_defs_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val my_print_tac: string -> tactic
    val prepare_case_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val prepare_combinator_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val prepare_consistentDP_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val solve_consistentDP_tac:
       Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val solve_relator_tac: Proof.context -> int -> tactic
    val step_tac: Proof.context -> Transform_Data.cmd_info -> int -> tactic
    val totality_replay_tac:
       Function.info -> Function.info -> Proof.context -> tactic
    val totality_resolve_tac: thm -> thm -> thm -> Proof.context -> tactic
    val transfer_raw_tac: Proof.context -> int -> tactic
  end
structure Transform_Tactic: TRANSFORM_TACTIC
### theory "Draft.Pair_Memory"
### 1.221s elapsed time, 4.788s cpu time, 0.444s GC time
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"0::'a"
  :: "'a"
"iter_heap"
  :: "('a => 'b Heap) => 'a => unit Heap"
"crel_vs"
  :: "('b => 'd => bool) => 'b => 'd Heap => bool"
locale nat_index
  assumes "nat_index"
locale int_index_def
### ML warning (line 22 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (eta_conv_n) has not been referenced.
### ML warning (line 33 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (app_unmark_conv) has not been referenced.
### ML warning (line 36 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (eta_expand) has not been referenced.
### ML warning (line 282 of "$AFP/Monad_Memo_DP/transform/Transform_Term.ML"):
### Value identifier (monadify) has not been referenced.
signature TRANSFORM_TERM =
  sig
    val lift_equation:
       Transform_Const.MONAD_CONSTS ->
         Proof.context ->
           term * term ->
             term option -> (Proof.context -> conv) * term * int
    val repeat_sweep_conv: (Proof.context -> conv) -> Proof.context -> conv
    val rewrite_pureapp_beta_conv: conv
    val wrap_head: Transform_Const.MONAD_CONSTS -> term -> int -> term
  end
structure Transform_Term: TRANSFORM_TERM
Found termination order: "{}"
### ML warning (line 140 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Value identifier (prep_term) has not been referenced.
### ML warning (line 154 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Value identifier (dp_monadify_cmd) has not been referenced.
### ML warning (line 217 of "$AFP/Monad_Memo_DP/transform/Transform.ML"):
### Pattern is not exhaustive.
signature TRANSFORM_DP =
  sig
    val dp_correct_cmd: local_theory -> Proof.state
    val dp_fun_part1_cmd:
       (binding * string) *
       ((bool * (xstring * Position.T)) * (string * string) list) option
         -> local_theory -> local_theory
    val dp_fun_part2_cmd:
       string * (Facts.ref * Token.src list) list ->
         local_theory -> local_theory
  end
structure Transform_DP: TRANSFORM_DP
### ML warning (line 11 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (dp_fun_parser) has not been referenced.
### ML warning (line 19 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (memoizes_parser) has not been referenced.
### ML warning (line 22 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (monadifies_parser) has not been referenced.
### ML warning (line 29 of "$AFP/Monad_Memo_DP/transform/Transform_Parser.ML"):
### Value identifier (dp_monadify_cmd_parser) has not been referenced.
signature TRANSFORM_PARSER =
  sig
    val dp_fun_part1_parser:
       ((binding * string) *
        ((bool * (string * Position.T)) * (string * string) list) option
       )
       parser
    val dp_fun_part2_parser:
       (string * (Facts.ref * Token.src list) list) parser
  end
structure Transform_Parser: TRANSFORM_PARSER
Found termination order: "{}"
### theory "Draft.Transform_Cmd"
### 0.362s elapsed time, 1.274s cpu time, 0.152s GC time
Loading theory "Draft.State_Main" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0")
locale int_index
  assumes "int_index"
class index = type +
  fixes less_eq :: "'a => 'a => bool"
    and less :: "'a => 'a => bool"
    and idx :: "'a bound => 'a => nat"
    and size :: "'a bound => nat"
  assumes
    "is_locale":
      "index_locale index_class.less_eq index_class.less idx
        index_class.size"
locale bounded_index
  fixes bound :: "'k bound"
instantiation
  nat :: index
  less_eq_nat == index_class.less_eq :: nat => nat => bool
  less_nat == index_class.less :: nat => nat => bool
  idx_nat == idx :: nat bound => nat => nat
  size_nat == index_class.size :: nat bound => nat
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
index_locale (<=) (<) local.idx local.size
instantiation
  int :: index
  less_eq_int == index_class.less_eq :: int => int => bool
  less_int == index_class.less :: int => int => bool
  idx_int == idx :: int bound => int => nat
  size_int == index_class.size :: int bound => nat
index_locale (<=) (<) local.idx local.size
Found termination order: "{}"
termination by default prover
instantiation
  prod :: (index, index) index
  less_eq_prod == index_class.less_eq :: 'a * 'b => 'a * 'b => bool
  less_prod == index_class.less :: 'a * 'b => 'a * 'b => bool
  idx_prod == idx :: ('a * 'b) bound => 'a * 'b => nat
  size_prod == index_class.size :: ('a * 'b) bound => nat
consts
  comp\<^sub>T' ::
    "('c => ('e, 'b) state)
     => ('a => ('e, 'c) state) => ('d, 'a => ('e, 'b) state) state"
  comp\<^sub>T ::
    "('g,
      ('c => ('e, 'b) state)
      => ('f,
          ('a => ('e, 'c) state)
          => ('d, 'a => ('e, 'b) state) state) state) state"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  map\<^sub>T' :: "('b => ('c, 'a) state) => 'b list => ('c, 'a list) state"
  map\<^sub>T ::
    "('e,
      ('b => ('c, 'a) state)
      => ('d, 'b list => ('c, 'a list) state) state) state"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.691s elapsed time, 2.144s cpu time, 0.202s GC time
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  fold\<^sub>T' ::
    "('b => ('c, 'a => ('d, 'a) state) state)
     => 'b list => ('c, 'a => ('d, 'a) state) state"
  fold\<^sub>T ::
    "('f,
      ('b => ('c, 'a => ('d, 'a) state) state)
      => ('e, 'b list => ('c, 'a => ('d, 'a) state) state) state) state"
[| ?xs = ?ys; !!x. x : set ?ys ==> ?f x = ?g x |]
==> map ?f ?xs = map ?g ?ys
[| ?a = ?b; ?xs = ?ys; !!x. x : set ?xs ==> ?f x = ?g x |]
==> fold ?f ?xs ?a = fold ?g ?ys ?b
locale dp_consistency
  fixes lookup :: "'param => ('mem, 'result option) state"
    and update :: "'param => 'result => ('mem, unit) state"
    and P :: "'mem => bool"
    and dp :: "'param => 'result"
  assumes "dp_consistency lookup update P"
index_locale local.less_eq local.less local.idx local.size
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
### Type
### (int * int) bound => nat
### of constant "Indexing.bounded_index.size"
### is too specific compared to declared type
### ?'k::{} bound => nat, in theorem:
### bounded_index.size (Bound (?l1.0, ?l2.0) (?u1.0, ?u2.0)) ==
### nat (?u1.0 - ?l1.0) * nat (?u2.0 - ?l2.0)
### theory "Draft.Indexing"
### 3.472s elapsed time, 12.398s cpu time, 1.641s GC time
Loading theory "Draft.Memory_Heap" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0" via "Draft.Heap_Main")
[| option = option'; option' = None ==> f1 = g1;
   !!x2. option' = Some x2 ==> f2 x2 = g2 x2 |]
==> (case option of None => f1 | Some x2 => f2 x2) =
    (case option' of None => g1 | Some x2 => g2 x2)
[| prod = prod'; !!x1 x2. prod' = (x1, x2) ==> f x1 x2 = g x1 x2 |]
==> (case prod of (x1, x2) => f x1 x2) = (case prod' of (x1, x2) => g x1 x2)
[| nat = nat'; nat' = 0 ==> f1 = g1;
   !!x2. nat' = Suc x2 ==> f2 x2 = g2 x2 |]
==> (case nat of 0 => f1 | Suc x2 => f2 x2) =
    (case nat' of 0 => g1 | Suc x2 => g2 x2)
### theory "Draft.State_Main"
### 0.823s elapsed time, 2.193s cpu time, 0.193s GC time
Loading theory "Draft.Example_Misc" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0")
### Missing patterns in function definition:
### min_list [] = undefined
Found termination order: "length <*mlex*> {}"
bundle app_syntax
### theory "Draft.Example_Misc"
### 0.343s elapsed time, 0.702s cpu time, 0.039s GC time
### theory "Draft.Memory_Heap"
### 1.269s elapsed time, 1.782s cpu time, 0.168s GC time
Loading theory "Draft.Heap_Main" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0")
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
Found termination order: "{}"
termination by default prover
consts
  comp\<^sub>T' ::
    "('c => 'b Heap) => ('a => 'c Heap) => ('a => 'b Heap) Heap"
  comp\<^sub>T ::
    "(('c => 'b Heap)
      => (('a => 'c Heap) => ('a => 'b Heap) Heap) Heap) Heap"
comp\<^sub>T' ?f ?g =
return
 (%x. Heap_Monad_Ext.fun_app_lifted (return ?f)
       (Heap_Monad_Ext.fun_app_lifted (return ?g) (return x)))
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  map\<^sub>T' :: "('b => 'a Heap) => 'b list => 'a list Heap"
  map\<^sub>T :: "(('b => 'a Heap) => ('b list => 'a list Heap) Heap) Heap"
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
termination by default prover
consts
  fold\<^sub>T' ::
    "('b => ('a => 'a Heap) Heap) => 'b list => ('a => 'a Heap) Heap"
  fold\<^sub>T ::
    "(('b => ('a => 'a Heap) Heap)
      => ('b list => ('a => 'a Heap) Heap) Heap) Heap"
[| ?xs = ?ys; !!x. x : set ?ys ==> ?f x = ?g x |]
==> map ?f ?xs = map ?g ?ys
[| ?a = ?b; ?xs = ?ys; !!x. x : set ?xs ==> ?f x = ?g x |]
==> fold ?f ?xs ?a = fold ?g ?ys ?b
locale dp_consistency_heap
  fixes P :: "heap => bool"
    and update :: "'a => 'b => unit Heap"
    and lookup :: "'a => 'b option Heap"
    and dp :: "'a => 'b"
  assumes "dp_consistency_heap P update lookup"
[| ?b = ?c; ?c ==> ?x = ?u; ~ ?c ==> ?y = ?v |]
==> (if ?b then ?x else ?y) = (if ?c then ?u else ?v)
[| option = option'; option' = None ==> f1 = g1;
   !!x2. option' = Some x2 ==> f2 x2 = g2 x2 |]
==> (case option of None => f1 | Some x2 => f2 x2) =
    (case option' of None => g1 | Some x2 => g2 x2)
[| prod = prod'; !!x1 x2. prod' = (x1, x2) ==> f x1 x2 = g x1 x2 |]
==> (case prod of (x1, x2) => f x1 x2) = (case prod' of (x1, x2) => g x1 x2)
locale heap_correct_init_defs
  fixes P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
locale heap_correct_init_inv
  fixes P :: "'a => heap => bool"
    and lookup :: "'a => 'b => 'c option Heap"
    and update :: "'a => 'b => 'c => unit Heap"
  assumes "heap_correct_init_inv P lookup update"
locale heap_correct_init
  fixes P :: "'a => heap => bool"
    and lookup :: "'a => 'b => 'c option Heap"
    and update :: "'a => 'b => 'c => unit Heap"
  assumes "heap_correct_init P lookup update"
locale dp_consistency_heap_init
  fixes P :: "'m => heap => bool"
    and update :: "'m => 'k => 'v => unit Heap"
    and lookup :: "'m => 'k => 'v option Heap"
    and dp :: "'k => 'v"
    and init :: "'m Heap"
  assumes "dp_consistency_heap_init P update lookup init"
locale dp_consistency_heap_init'
  fixes P :: "'m => heap => bool"
    and update :: "'m => 'k => 'v => unit Heap"
    and lookup :: "'m => 'k => 'v option Heap"
    and dp :: "'k => 'v"
    and init :: "'m Heap"
  assumes "dp_consistency_heap_init' P update lookup init"
locale dp_consistency_new
  fixes dp :: "'k => 'v"
    and P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
    and init :: "'m Heap"
  assumes "dp_consistency_new P lookup update init"
locale dp_consistency_new'
  fixes dp :: "'k => 'v"
    and P :: "'m => heap => bool"
    and lookup :: "'m => 'k => 'v option Heap"
    and update :: "'m => 'k => 'v => unit Heap"
    and init :: "'m Heap"
    and mem :: "'m"
  assumes "dp_consistency_new' P lookup update init mem"
locale dp_consistency_heap_array_new'
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and mem :: "'v option array"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array_new' size to_index mem"
consistentDP (?dp\<^sub>T (result_of (mem_empty size) Heap.empty)) ==>
dp ?x = result_of (mem_empty size >>= (%mem. ?dp\<^sub>T mem ?x)) Heap.empty
locale dp_consistency_heap_array_new
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array_new size to_index"
consistentDP (?dp\<^sub>T (result_of (mem_empty size) Heap.empty)) ==>
dp ?x = result_of (mem_empty size >>= (%mem. ?dp\<^sub>T mem ?x)) Heap.empty
locale dp_consistency_heap_array
  fixes size :: "nat"
    and to_index :: "'k => nat"
    and dp :: "'k => 'v"
  assumes "dp_consistency_heap_array size to_index"
locale dp_consistency_heap_array_pair'
  fixes size :: "nat"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'k2"
    and to_index :: "'k2 => nat"
    and dp :: "'k => 'v"
    and k1 :: "'k1"
    and k2 :: "'k1"
    and
    mem :: "'k1 ref * 'k1 ref * 'v option array ref * 'v option array ref"
  assumes
    "dp_consistency_heap_array_pair' size key1 key2 to_index k1 k2 mem"
locale dp_consistency_heap_array_pair_iterator
  fixes size :: "nat"
    and key1 :: "'k => 'a"
    and key2 :: "'k => 'b"
    and to_index :: "'b => nat"
    and k1 :: "'a"
    and k2 :: "'a"
    and mem :: "'a ref * 'a ref * 'v option array ref * 'v option array ref"
    and nxt :: "'k => 'k"
    and sizef :: "'k => nat"
    and dp :: "'k => 'v"
    and cnt :: "'k => bool"
  assumes
    "dp_consistency_heap_array_pair_iterator size key1 key2 to_index k1 k2
      mem nxt sizef cnt"
locale dp_consistency_heap_array_pair
  fixes size :: "nat"
    and key1 :: "'k => 'k1"
    and key2 :: "'k => 'k2"
    and to_index :: "'k2 => nat"
    and dp :: "'k => 'v"
    and k1 :: "'k1"
    and k2 :: "'k1"
  assumes "dp_consistency_heap_array_pair size key1 key2 to_index k1 k2"
### theory "Draft.Heap_Main"
### 2.819s elapsed time, 2.957s cpu time, 0.199s GC time
Loading theory "Draft.Tracing" (required by "Draft.Min_Ed_Dist0Templates" via "Draft.Min_Ed_Dist0")
### theory "Draft.Tracing"
### 0.338s elapsed time, 0.355s cpu time, 0.013s GC time
Loading theory "Draft.Min_Ed_Dist0" (required by "Draft.Min_Ed_Dist0Templates")
"''3''"
  :: "char list"
### Missing patterns in function definition:
### !!a. argmin a [] = undefined
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
### Missing patterns in function definition:
### !!a. argmin2 a [] = undefined
Found termination order: "(%p. length (snd p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd p)) <*mlex*>
   (%p. size_list size_class.size (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
Found termination order:
  "(%p. length (snd p)) <*mlex*> (%p. length (fst p)) <*mlex*> {}"
"[Repl CHR ''b'', Copy, Repl CHR ''n'', Copy, Repl CHR ''n'', Copy, Copy,
  Del, Del, Del]"
  :: "char ed list"
termination by replaying
consts
  min_ed_ix\<^sub>m' :: "nat * nat => ((nat * nat, nat) mapping, nat) state"
  min_ed_ix\<^sub>m ::
    "('b, nat * nat => ((nat * nat, nat) mapping, nat) state) state"
theorem
  min_ed_ix\<^sub>m.crel:
    dp_consistency.consistentDP
     (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
     (%_. True) local.min_ed_ix local.min_ed_ix\<^sub>m'
theorem
  min_ed_ix\<^sub>m.memoized_correct:
    local.min_ed_ix ?a =
    fst (run_state (local.min_ed_ix\<^sub>m' ?a) Mapping.empty)
local.min_ed_ix\<^sub>m' (?i, ?j) =
state_mem_defs.checkmem
 (%k. State_Monad.get >>= (%m. State_Monad.return (Mapping.lookup m k)))
 (%k v. State_Monad.get >>= (%m. State_Monad.set (Mapping.update k v m)))
 (?i, ?j)
 (State_Monad_Ext.if\<^sub>T (State_Monad.return (m <= ?i))
   (State_Monad.return (if n <= ?j then 0 else n - ?j))
   (State_Monad_Ext.if\<^sub>T (State_Monad.return (n <= ?j))
     (State_Monad.return (m - ?i))
     (State_Monad_Ext.fun_app_lifted
       (State_Monad.return
         (%a. State_Monad.return (Example_Misc.min_list a)))
       (State_Monad_Ext.fun_app_lifted
         (State_Monad_Ext.fun_app_lifted
           (State_Monad.return
             (%a. State_Monad.return (%b. State_Monad.return (a # b))))
           (State_Monad_Ext.fun_app_lifted
             (State_Monad.return (%a. State_Monad.return (1 + a)))
             (local.min_ed_ix\<^sub>m' (?i, ?j + 1))))
         (State_Monad_Ext.fun_app_lifted
           (State_Monad_Ext.fun_app_lifted
             (State_Monad.return
               (%a. State_Monad.return (%b. State_Monad.return (a # b))))
             (State_Monad_Ext.fun_app_lifted
               (State_Monad.return (%a. State_Monad.return (1 + a)))
               (local.min_ed_ix\<^sub>m' (?i + 1, ?j))))
           (State_Monad_Ext.fun_app_lifted
             (State_Monad_Ext.fun_app_lifted
               (State_Monad.return
                 (%a. State_Monad.return (%b. State_Monad.return (a # b))))
               (State_Monad_Ext.fun_app_lifted
                 (State_Monad.return
                   (%a. State_Monad.return
                         ((if xs ?i = ys ?j then 0 else 1) + a)))
                 (local.min_ed_ix\<^sub>m' (?i + 1, ?j + 1))))
             (State_Monad.return [])))))))
termination by replaying
consts
  min_ed_ix\<^sub>h' :: "nat * nat => nat Heap"
  min_ed_ix\<^sub>h :: "(nat * nat => nat Heap) Heap"
theorem
  min_ed_ix\<^sub>h.crel:
    min_ed_ix\<^sub>h.consistentDP local.min_ed_ix\<^sub>h'
theorem
  min_ed_ix\<^sub>h.memoized_correct:
    local.min_ed_ix ?a =
    result_of (local.min_ed_ix\<^sub>h' ?a)
     (heap_of (init_state (n + 1) m (m + 1)) Heap.empty)
See theory exports
Warning: Value identifier (t) has not been referenced.
At (line 19 of "generated code")
Warning: Value identifier (x1) has not been referenced.
At (line 63 of "generated code")
Warning: Value identifier (x2) has not been referenced.
At (line 69 of "generated code")
Warning: Value identifier (less) has not been referenced.
At (line 77 of "generated code")
Warning: Value identifier (sep) has not been referenced.
At (line 137 of "generated code")
Warning: Value identifier (sep) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (s) has not been referenced.
At (line 136 of "generated code")
Warning: Value identifier (xs) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 141 of "generated code")
Warning: Value identifier (p) has not been referenced.
At (line 148 of "generated code")
Warning: Value identifier (shows_list) has not been referenced.
At (line 163 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 172 of "generated code")
Warning: Pattern 3 is redundant.
fun
   equal_bool p true = p |
      equal_bool p ... = not p |
      equal_bool ... = p |
      equal_bool ... = ...
At (line 184 of "generated code")
Warning: Pattern 4 is redundant.
fun
   equal_bool p true = p |
      equal_bool p ... = not p |
      equal_bool ... = p |
      equal_bool ... = ...
At (line 185 of "generated code")
Warning: Value identifier (t) has not been referenced.
At (line 199 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 201 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 238 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 240 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 243 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 245 of "generated code")
Warning: Value identifier (f) has not been referenced.
At (line 252 of "generated code")
Warning: Value identifier (x) has not been referenced.
At (line 285 of "generated code")
Warning: Matches are not exhaustive.
fun min_list A_ (... :: ...) = (case xs of [...] => x | ... => ...)
At (line 290 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 315 of "generated code")
Warning: Value identifier (A_) has not been referenced.
At (line 322 of "generated code")
Warning: Value identifier (p) has not been referenced.
At (line 352 of "generated code")
Warning: Value identifier (C2_) has not been referenced.
At (line 369 of "generated code")
Warning: Value identifier (C2_) has not been referenced.
At (line 410 of "generated code")
structure Test: sig type char type nat val test_case: unit -> nat end
Miss (10, 7)
Miss (10, 6)
Miss (10, 5)
Miss (10, 4)
Miss (10, 3)
Miss (10, 2)
Miss (10, 1)
Miss (10, 0)
Miss (9, 7)
Miss (9, 6)
Hit (9, 7)
Hit (10, 6)
Hit (10, 7)
Miss (9, 5)
Hit (9, 6)
Hit (10, 5)
Hit (10, 6)
Miss (9, 4)
Hit (9, 5)
Hit (10, 4)
Hit (10, 5)
Miss (9, 3)
Hit (9, 4)
Hit (10, 3)
Hit (10, 4)
Miss (9, 2)
Hit (9, 3)
Hit (10, 2)
Hit (10, 3)
Miss (9, 1)
Hit (9, 2)
Hit (10, 1)
Hit (10, 2)
Miss (9, 0)
Hit (9, 1)
Hit (10, 0)
Hit (10, 1)
Miss (8, 7)
Miss (8, 6)
Hit (8, 7)
Hit (9, 6)
Hit (9, 7)
Miss (8, 5)
Hit (8, 6)
Hit (9, 5)
Hit (9, 6)
Miss (8, 4)
Hit (8, 5)
Hit (9, 4)
Hit (9, 5)
Miss (8, 3)
Hit (8, 4)
Hit (9, 3)
Hit (9, 4)
Miss (8, 2)
Hit (8, 3)
Hit (9, 2)
Hit (9, 3)
Miss (8, 1)
Hit (8, 2)
Hit (9, 1)
Hit (9, 2)
Miss (8, 0)
Hit (8, 1)
Hit (9, 0)
Hit (9, 1)
Miss (7, 7)
Miss (7, 6)
Hit (7, 7)
Hit (8, 6)
Hit (8, 7)
Miss (7, 5)
Hit (7, 6)
Hit (8, 5)
Hit (8, 6)
Miss (7, 4)
Hit (7, 5)
Hit (8, 4)
Hit (8, 5)
Miss (7, 3)
Hit (7, 4)
Hit (8, 3)
Hit (8, 4)
Miss (7, 2)
Hit (7, 3)
Hit (8, 2)
Hit (8, 3)
Miss (7, 1)
Hit (7, 2)
Hit (8, 1)
Hit (8, 2)
Miss (7, 0)
Hit (7, 1)
Hit (8, 0)
Hit (8, 1)
Miss (6, 7)
Miss (6, 6)
Hit (6, 7)
Hit (7, 6)
Hit (7, 7)
Miss (6, 5)
Hit (6, 6)
Hit (7, 5)
Hit (7, 6)
Miss (6, 4)
Hit (6, 5)
Hit (7, 4)
Hit (7, 5)
Miss (6, 3)
Hit (6, 4)
Hit (7, 3)
Hit (7, 4)
Miss (6, 2)
Hit (6, 3)
Hit (7, 2)
Hit (7, 3)
Miss (6, 1)
Hit (6, 2)
Hit (7, 1)
Hit (7, 2)
Miss (6, 0)
Hit (6, 1)
Hit (7, 0)
Hit (7, 1)
Miss (5, 7)
Miss (5, 6)
Hit (5, 7)
Hit (6, 6)
Hit (6, 7)
Miss (5, 5)
Hit (5, 6)
Hit (6, 5)
Hit (6, 6)
Miss (5, 4)
Hit (5, 5)
Hit (6, 4)
Hit (6, 5)
Miss (5, 3)
Hit (5, 4)
Hit (6, 3)
Hit (6, 4)
Miss (5, 2)
Hit (5, 3)
Hit (6, 2)
Hit (6, 3)
Miss (5, 1)
Hit (5, 2)
Hit (6, 1)
Hit (6, 2)
Miss (5, 0)
Hit (5, 1)
Hit (6, 0)
Hit (6, 1)
Miss (4, 7)
Miss (4, 6)
Hit (4, 7)
Hit (5, 6)
Hit (5, 7)
Miss (4, 5)
Hit (4, 6)
Hit (5, 5)
Hit (5, 6)
Miss (4, 4)
Hit (4, 5)
Hit (5, 4)
Hit (5, 5)
Miss (4, 3)
Hit (4, 4)
Hit (5, 3)
Hit (5, 4)
Miss (4, 2)
Hit (4, 3)
Hit (5, 2)
Hit (5, 3)
Miss (4, 1)
Hit (4, 2)
Hit (5, 1)
Hit (5, 2)
Miss (4, 0)
Hit (4, 1)
Hit (5, 0)
Hit (5, 1)
Miss (3, 7)
Miss (3, 6)
Hit (3, 7)
Hit (4, 6)
Hit (4, 7)
Miss (3, 5)
Hit (3, 6)
Hit (4, 5)
Hit (4, 6)
Miss (3, 4)
Hit (3, 5)
Hit (4, 4)
Hit (4, 5)
Miss (3, 3)
Hit (3, 4)
Hit (4, 3)
Hit (4, 4)
Miss (3, 2)
Hit (3, 3)
Hit (4, 2)
Hit (4, 3)
Miss (3, 1)
Hit (3, 2)
Hit (4, 1)
Hit (4, 2)
Miss (3, 0)
Hit (3, 1)
Hit (4, 0)
Hit (4, 1)
Miss (2, 7)
Miss (2, 6)
Hit (2, 7)
Hit (3, 6)
Hit (3, 7)
Miss (2, 5)
Hit (2, 6)
Hit (3, 5)
Hit (3, 6)
Miss (2, 4)
Hit (2, 5)
Hit (3, 4)
Hit (3, 5)
Miss (2, 3)
Hit (2, 4)
Hit (3, 3)
Hit (3, 4)
Miss (2, 2)
Hit (2, 3)
Hit (3, 2)
Hit (3, 3)
Miss (2, 1)
Hit (2, 2)
Hit (3, 1)
Hit (3, 2)
Miss (2, 0)
Hit (2, 1)
Hit (3, 0)
Hit (3, 1)
Miss (1, 7)
Miss (1, 6)
Hit (1, 7)
Hit (2, 6)
Hit (2, 7)
Miss (1, 5)
Hit (1, 6)
Hit (2, 5)
Hit (2, 6)
Miss (1, 4)
Hit (1, 5)
Hit (2, 4)
Hit (2, 5)
Miss (1, 3)
Hit (1, 4)
Hit (2, 3)
Hit (2, 4)
Miss (1, 2)
Hit (1, 3)
Hit (2, 2)
Hit (2, 3)
Miss (1, 1)
Hit (1, 2)
Hit (2, 1)
Hit (2, 2)
Miss (1, 0)
Hit (1, 1)
Hit (2, 0)
Hit (2, 1)
Miss (0, 0)
Miss (0, 1)
Miss (0, 2)
Miss (0, 3)
Miss (0, 4)
Miss (0, 5)
Miss (0, 6)
Miss (0, 7)
Hit (1, 6)
Hit (1, 7)
Hit (1, 5)
Hit (1, 6)
Hit (1, 4)
Hit (1, 5)
Hit (1, 3)
Hit (1, 4)
Hit (1, 2)
Hit (1, 3)
Hit (1, 1)
Hit (1, 2)
Hit (1, 0)
Hit (1, 1)
val it = Nat 6: Test.nat
### theory "Draft.Min_Ed_Dist0"
### 5.808s elapsed time, 7.848s cpu time, 1.444s GC time
Loading theory "Draft.Min_Ed_Dist0Templates"
val templateLemmas =
   [("Min_Ed_Dist0.min_ed_Nil1", "min_ed [] ?ys = length ?ys",
     template_equation
      (template_app
        (template_app (template_hole 2, template_hole 1), template_var 0),
       template_app (template_hole 0, template_var 0))),
    ("Min_Ed_Dist0.min_ed_Nil2", "min_ed ?xs [] = length ?xs",
     template_equation
      (template_app
        (template_app (template_hole 2, template_var 0), template_hole 1),
       template_app (template_hole 0, template_var 0))),
    ("Min_Ed_Dist0.min_eds_correct", "edit (min_eds ?xs ?ys) ?xs = ?ys",
     template_equation
      (template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0)),
         template_var 1),
       template_var 0)),
    ("Min_Ed_Dist0.min_eds_Nil", "min_eds [] ?ys = map Ins ?ys",
     template_equation
      (template_app
        (template_app (template_hole 3, template_hole 2), template_var 0),
       template_app
        (template_app (template_hole 1, template_hole 0), template_var 0))),
    ("Min_Ed_Dist0.min_eds_Nil2",
     "min_eds ?xs [] = replicate (length ?xs) Del",
     template_equation
      (template_app
        (template_app (template_hole 4, template_var 0), template_hole 3),
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_hole 0))),
    ("Min_Ed_Dist0.min_eds_same",
     "min_eds ?xs ?xs = replicate (length ?xs) Copy",
     template_equation
      (template_app
        (template_app (template_hole 3, template_var 0), template_var 0),
       template_app
        (template_app
          (template_hole 2, template_app (template_hole 1, template_var 0)),
         template_hole 0))),
    ("Min_Ed_Dist0.min_eds_eq_Nil_iff",
     "(min_eds ?xs ?ys = []) = (?xs = [] & ?ys = [])",
     template_bimplication
      (template_equation
        (template_app
          (template_app (template_hole 4, template_var 1), template_var 0),
         template_hole 3),
       template_predicate
        (
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app (template_hole 1, template_var 1),
                 template_hole 0)),
             template_app
              (template_app (template_hole 1, template_var 0),
               template_hole 0))
           ))),
    ("Min_Ed_Dist0.min_ed_min_eds",
     "min_ed ?xs ?ys = cost (min_eds ?xs ?ys)",
     template_equation
      (template_app
        (template_app (template_hole 6, template_var 1), template_var 0),
       template_app
        (template_hole 5,
         template_app
          (template_app (template_hole 4, t_empty),
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 0))))),
    ("Min_Ed_Dist0.min_ed_ix'_min_ed",
     "min_ed_ix' ?xs ?ys (length ?xs) (length ?ys) (?i, ?j) =
      min_ed (drop ?i ?xs) (drop ?j ?ys)",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app (template_hole 4, template_var 3),
               template_var 2),
             template_app (template_hole 3, template_var 3)),
           template_app (template_hole 3, template_var 2)),
         template_app
          (template_app (template_hole 2, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 1,
           template_app
            (template_app (template_hole 0, template_var 1),
             template_var 3)),
         template_app
          (template_app (template_hole 0, template_var 0),
           template_var 2)))),
    ("Min_Ed_Dist0.if_edit_Nil2",
     "edit ?es [] = ?ys ==> length ?ys <= cost ?es",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 8, template_var 1),
            template_hole 7),
          template_var 0)],
       template_inequation
        (less_equals, template_app (template_hole 5, template_var 0),
         template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, t_empty), template_var 1))))),
    ("Min_Ed_Dist0.if_edit_eq_Nil",
     "edit ?es ?xs = [] ==> length ?xs <= cost ?es",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 8, template_var 1), template_var 0),
          template_hole 7)],
       template_inequation
        (less_equals, template_app (template_hole 5, template_var 0),
         template_app
          (template_hole 4,
           template_app
            (template_app (template_hole 3, t_empty), template_var 1))))),
    ("Min_Ed_Dist0.min_ed_ix_min_ed",
     "min_ed_ix ?xs ?ys ?m ?n (?i, ?j) =
      min_ed (map ?xs [?i..<?m]) (map ?ys [?j..<?n])",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app (template_hole 4, template_var 5),
               template_var 4),
             template_var 3),
           template_var 2),
         template_app
          (template_app (template_hole 3, template_var 1), template_var 0)),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_app (template_hole 1, template_var 5),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 3))),
         template_app
          (template_app (template_hole 1, template_var 4),
           template_app
            (template_app (template_hole 0, template_var 0),
             template_var 2))))),
    ("Min_Ed_Dist0.bf_impl_correct",
     "min_ed_ix ?xs ?ys ?m ?n (?i, ?j) =
      result_of (min_ed_ix_impl ?xs ?ys ?m ?n ?i ?j) Heap.empty",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app (template_hole 6, template_var 5),
               template_var 4),
             template_var 3),
           template_var 2),
         template_app
          (template_app (template_hole 5, template_var 1), template_var 0)),
       template_app
        (template_hole 4,
         template_app
          (template_hole 3,
           template_app
            (template_app
              (template_hole 2,
               template_app
                (template_app
                  (template_app
                    (template_app
                      (template_app
                        (template_app (template_hole 1, template_var 5),
                         template_var 4),
                       template_var 3),
                     template_var 2),
                   template_var 1),
                 template_var 0)),
             template_hole 0))))),
    ("Min_Ed_Dist0.cost_Copy_Del",
     "cost (min_eds ?xs ?ys) <= cost (min_eds ?xs (?x # ?ys)) + 1",
     template_inequation
      (less_equals,
       template_app
        (template_hole 8,
         template_app
          (template_app (template_hole 7, t_empty),
           template_app
            (template_app (template_hole 3, template_var 2),
             template_var 1))),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_hole 8,
             template_app
              (template_app (template_hole 7, t_empty),
               template_app
                (template_app (template_hole 3, template_var 2),
                 template_app
                  (template_app (template_hole 1, template_var 0),
                   template_var 1))))),
         template_hole 0))),
    ("Min_Ed_Dist0.cost_Copy_Ins",
     "cost (min_eds ?xs ?ys) <= cost (min_eds (?x # ?xs) ?ys) + 1",
     template_inequation
      (less_equals,
       template_app
        (template_hole 8,
         template_app
          (template_app (template_hole 7, t_empty),
           template_app
            (template_app (template_hole 3, template_var 2),
             template_var 1))),
       template_app
        (template_app
          (template_hole 2,
           template_app
            (template_hole 8,
             template_app
              (template_app (template_hole 7, t_empty),
               template_app
                (template_app
                  (template_hole 3,
                   template_app
                    (template_app (template_hole 1, template_var 0),
                     template_var 2)),
                 template_var 1)))),
         template_hole 0))),
    ("Min_Ed_Dist0.min_eds_minimal",
     "edit ?es ?xs = ?ys ==> cost (min_eds ?xs ?ys) <= cost ?es",
     template_implication
      ([template_equation
         (template_app
           (template_app (template_hole 7, template_var 2), template_var 1),
          template_var 0)],
       template_inequation
        (less_equals,
         template_app
          (template_hole 5,
           template_app
            (template_app (template_hole 4, t_empty),
             template_app
              (template_app (template_hole 0, template_var 1),
               template_var 0))),
         template_app
          (template_hole 5,
           template_app
            (template_app (template_hole 4, t_empty), template_var 2))))),
    ("Min_Ed_Dist0.iter_min_ed_ix_unfold",
     "iter_min_ed_ix ?xs ?ys ?m ?n ?mem =
      (%(i, j).
          if 0 < i & i <= ?m & j <= ?n
          then min_ed_ix\<^sub>h'_impl ?xs ?ys ?m ?n ?mem (i, j) >>=
               (%_. iter_min_ed_ix ?xs ?ys ?m ?n ?mem
                     (if 0 < j then (i, j - 1) else (i - 1, ?n)))
          else return ())",
     template_equation
      (template_app
        (template_app
          (template_app
            (template_app
              (template_app (template_hole 14, template_var 4),
               template_var 3),
             template_var 2),
           template_var 1),
         template_var 0),
       template_app (template_hole 13, t_empty))),
    ("Min_Ed_Dist0.memoized_empty",
     "?mem = result_of (init_state (?n + 1) ?m (?m + 1)) Heap.empty ==>
      min_ed_ix ?xs ?ys ?m ?n ?x =
      result_of
       (init_state (?n + 1) ?m (?m + 1) >>=
        (%mem. iterator_defs.iter_heap
                (%a. case a of (x, y) => x <= ?m & y <= ?n & 0 < x)
                (%a. case a of
                     (x, y) => if 0 < y then (x, y - 1) else (x - 1, ?n))
                (min_ed_ix\<^sub>h' ?xs ?ys ?m ?n ?mem) (?y mem) >>=
               (%_. min_ed_ix\<^sub>h' ?xs ?ys ?m ?n ?mem ?x)))
       Heap.empty",
     template_implication
      ([template_equation
         (template_var 6,
          template_app
           (template_hole 24,
            template_app
             (template_hole 23,
              template_app
               (template_app
                 (template_hole 22,
                  template_app
                   (template_app
                     (template_app
                       (template_hole 21,
                        template_app
                         (template_app (template_hole 20, template_var 5),
                          template_hole 19)),
                      template_var 4),
                    template_app
                     (template_app (template_hole 20, template_var 4),
                      template_hole 19))),
                template_hole 18))))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_app
                (template_app (template_hole 16, template_var 3),
                 template_var 2),
               template_var 4),
             template_var 5),
           template_var 1),
         template_app
          (template_hole 15,
           template_app
            (template_hole 14,
             template_app
              (template_app
                (template_hole 13,
                 template_app
                  (template_app
                    (template_hole 12,
                     template_app
                      (template_app
                        (template_app
                          (template_hole 21,
                           template_app
                            (template_app
                              (template_hole 20, template_var 5),
                             template_hole 19)),
                         template_var 4),
                       template_app
                        (template_app (template_hole 20, template_var 4),
                         template_hole 19))),
                   t_empty)),
               template_hole 18)))))),
    ("Min_Ed_Dist0.iter_heap_unfold",
     "?mem = result_of (init_state (?n + 1) ?m (?m + 1)) Heap.empty ==>
      iterator_defs.iter_heap (%(x, y). x <= ?m & y <= ?n & 0 < x)
       (%(x, y). if 0 < y then (x, y - 1) else (x - 1, ?n)) ?f ?x =
      (if case ?x of (x, y) => x <= ?m & y <= ?n & 0 < x
       then ?f ?x >>=
            (%_. iterator_defs.iter_heap
                  (%(x, y). x <= ?m & y <= ?n & 0 < x)
                  (%(x, y). if 0 < y then (x, y - 1) else (x - 1, ?n)) ?f
                  (case ?x of
                   (x, y) => if 0 < y then (x, y - 1) else (x - 1, ?n)))
       else return ())",
     template_implication
      ([template_equation
         (template_var 4,
          template_app
           (template_hole 21,
            template_app
             (template_hole 20,
              template_app
               (template_app
                 (template_hole 19,
                  template_app
                   (template_app
                     (template_app
                       (template_hole 18,
                        template_app
                         (template_app (template_hole 17, template_var 3),
                          template_hole 16)),
                      template_var 2),
                    template_app
                     (template_app (template_hole 17, template_var 2),
                      template_hole 16))),
                template_hole 15))))],
       template_equation
        (template_app
          (template_app
            (template_app
              (template_app
                (template_hole 13,
                 template_app (template_hole 12, t_empty)),
               template_app (template_hole 7, t_empty)),
             template_var 1),
           template_var 0),
         template_app
          (template_app
            (template_app
              (template_hole 3,
               template_app
                (template_app (template_hole 12, t_empty), template_var 0)),
             template_app
              (template_app
                (template_hole 2,
                 template_app (template_var 1, template_var 0)),
               t_empty)),
           template_app (template_hole 1, template_hole 0)))))]:
   (string * thm * template) list
### theory "Draft.Min_Ed_Dist0Templates"
### 0.604s elapsed time, 0.800s cpu time, 0.096s GC time
val it = (): unit
