Loading theory "Draft.ETTS_Tools" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions" via "Draft.SML_Introduction" via "Draft.Introduction" via "Draft.ETTS_Auxiliary" via "Draft.ETTS")
Loading theory "Draft.Lifting_Set_Ext" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
Loading theory "Draft.Product_Type_Ext" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
Loading theory "Draft.SML_Relations" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
Proofs for inductive predicate(s) "trancl_onp"
### theory "Draft.Product_Type_Ext"
### 0.043s elapsed time, 0.198s cpu time, 0.000s GC time
Loading theory "Draft.Set_Ext" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
  Proving monotonicity ...
signature LIBRARY =
  sig
    val ? : bool * ('a -> 'a) -> 'a -> 'a
    structure Any: sig type T end
    val I: 'a -> 'a
    val K: 'a -> 'b -> 'a
    val align_right: string -> int -> string -> string
    val andf: ('a -> bool) * ('a -> bool) -> 'a -> bool
    val apdupl: ('a -> 'b) -> 'a -> 'b * 'a
    val apdupr: ('a -> 'b) -> 'a -> 'a * 'b
    val apfst: ('a -> 'b) -> 'a * 'c -> 'b * 'c
    val apply2: ('a -> 'b) -> 'a * 'a -> 'b * 'b
    val apsnd: ('a -> 'b) -> 'c * 'a -> 'c * 'b
    val bool_ord: bool ord
    val build: ('a list -> 'a list) -> 'a list
    val build_rev: ('a list -> 'a list) -> 'a list
    val burrow: ('a list -> 'b list) -> 'a list list -> 'b list list
    val burrow_fst: ('a list -> 'b list) -> ('a * 'c) list -> ('b * 'c) list
    val burrow_options:
       ('a list -> 'b list) -> 'a option list -> 'b option list
    val cartouche: string -> string
    val cat_lines: string list -> string
    val chop: int -> 'a list -> 'a list * 'a list
    val chop_common_prefix:
       ('a * 'b -> bool) ->
         'a list * 'b list -> 'a list * ('a list * 'b list)
    val chop_groups: int -> 'a list -> 'a list list
    val chop_prefix: ('a -> bool) -> 'a list -> 'a list * 'a list
    val chop_suffix: ('a -> bool) -> 'a list -> 'a list * 'a list
    val combine: ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list
    val commas: string list -> string
    val commas_quote: string list -> string
    val compare_each: ('a * 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val curry: ('a * 'b -> 'c) -> 'a -> 'b -> 'c
    val decode_lines: string -> string
    val dict_ord: ('a * 'b -> order) -> 'a list * 'b list -> order
    val distinct: ('a * 'a -> bool) -> 'a list -> 'a list
    val divide_and_conquer: ('a -> 'a list * ('b list -> 'b)) -> 'a -> 'b
    val divide_and_conquer':
       ('a -> 'b -> ('a list * ('c list * 'b -> 'c * 'b)) * 'b) ->
         'a -> 'b -> 'c * 'b
    val downto: int * int -> int list
    val drop: int -> 'a list -> 'a list
    val drop_prefix: ('a -> bool) -> 'a list -> 'a list
    val drop_suffix: ('a -> bool) -> 'a list -> 'a list
    val dup: 'a -> 'a * 'a
    val duplicates: ('a * 'a -> bool) -> 'a list -> 'a list
    val enclose: string -> string -> string -> string
    val encode_lines: string -> string
    val eq_fst: ('a * 'b -> bool) -> ('a * 'c) * ('b * 'd) -> bool
    val eq_list: ('a * 'a -> bool) -> 'a list * 'a list -> bool
    val eq_pair:
       ('a * 'b -> bool) ->
         ('c * 'd -> bool) -> ('a * 'c) * ('b * 'd) -> bool
    val eq_set: ('a * 'a -> bool) -> 'a list * 'a list -> bool
    val eq_snd: ('a * 'b -> bool) -> ('c * 'a) * ('d * 'b) -> bool
    val equal: ''a -> ''a -> bool
    val exists: ('a -> bool) -> 'a list -> bool
    val exists_string: (string -> bool) -> string -> bool
    val fast_string_ord: string ord
    val filter: ('a -> bool) -> 'a list -> 'a list
    val filter_out: ('a -> bool) -> 'a list -> 'a list
    val find_first: ('a -> bool) -> 'a list -> 'a option
    val find_index: ('a -> bool) -> 'a list -> int
    val find_indices: ('a -> bool) -> 'a list -> int list
    val first_field: string -> string -> (string * string) option
    val flat: 'a list list -> 'a list
    val flip: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
    val fold2: ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val fold_burrow:
       ('a list -> 'b -> 'c list * 'd) ->
         'a list list -> 'b -> 'c list list * 'd
    val fold_index: (int * 'a -> 'b -> 'b) -> 'a list -> 'b -> 'b
    val fold_product:
       ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
    val fold_range: (int -> 'a -> 'a) -> int -> 'a -> 'a
    val fold_string: (string -> 'a -> 'a) -> string -> 'a -> 'a
    val foldl: ('a * 'b -> 'a) -> 'a * 'b list -> 'a
    val foldl1: ('a * 'a -> 'a) -> 'a list -> 'a
    val foldr: ('a * 'b -> 'b) -> 'a list * 'b -> 'b
    val foldr1: ('a * 'a -> 'a) -> 'a list -> 'a
    val forall: ('a -> bool) -> 'a list -> bool
    val forall_string: (string -> bool) -> string -> bool
    val fst: 'a * 'b -> 'a
    val funpow: int -> ('a -> 'a) -> 'a -> 'a
    val funpow_yield: int -> ('a -> 'b * 'a) -> 'a -> 'b list * 'a
    val get_first: ('a -> 'b option) -> 'a list -> 'b option
    val get_index: ('a -> 'b option) -> 'a list -> (int * 'b) option
    val getenv: string -> string
    val getenv_strict: string -> string
    val grouped:
       int ->
         (('a list -> 'b list) -> 'c list list -> 'd list list) ->
           ('a -> 'b) -> 'c list -> 'd list
    val has_duplicates: ('a * 'a -> bool) -> 'a list -> bool
    val hex_digit: int -> string
    val insert: ('a * 'a -> bool) -> 'a -> 'a list -> 'a list
    val int_ord: int ord
    val inter: ('a * 'b -> bool) -> 'b list -> 'a list -> 'a list
    val is_equal: order -> bool
    val is_greater: order -> bool
    val is_greater_equal: order -> bool
    val is_less: order -> bool
    val is_less_equal: order -> bool
    val is_prefix: ('a * 'a -> bool) -> 'a list -> 'a list -> bool
    val kw_bc: string parser
    val kw_bo: string parser
    val kw_col: string parser
    val length_ord: 'a list * 'b list -> order
    val list_of_pair: 'a * 'a -> 'a list
    val list_of_triple: 'a * 'a * 'a -> 'a list
    val list_ord: ('a * 'b -> order) -> 'a list * 'b list -> order
    val make_ord: ('a * 'a -> bool) -> 'a ord
    val map2: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val map_filter: ('a -> 'b option) -> 'a list -> 'b list
    val map_index: (int * 'a -> 'b) -> 'a list -> 'b list
    val map_product: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
    val map_range: (int -> 'a) -> int -> 'a list
    val map_slice_l:
       ('a list -> 'b list) -> ('a * 'c) list -> ('b * 'c) list
    val map_slice_r:
       ('a list -> 'b list) -> ('c * 'a) list -> ('c * 'b) list
    val map_slice_side_l:
       ('a list -> 'b list * 'c) -> ('a * 'd) list -> ('b * 'd) list * 'c
    val map_slice_side_r:
       ('a list -> 'b list * 'c) -> ('d * 'a) list -> ('d * 'b) list * 'c
    val map_split: ('a -> 'b * 'c) -> 'a list -> 'b list * 'c list
    val map_transpose: ('a list -> 'b) -> 'a list list -> 'b list
    val maps: ('a -> 'b list) -> 'a list -> 'b list
    val match_string: string -> string -> bool
    val member: ('a * 'b -> bool) -> 'b list -> 'a -> bool
    val member_string: string -> string -> bool
    val merge: ('a * 'a -> bool) -> 'a list * 'a list -> 'a list
    val min_list: int list -> int
    val mk_opt_id: ('a -> 'b) -> ('a -> 'b option) -> 'a -> 'b
    val normalize_lines: string -> string
    val not_equal: ''a -> ''a -> bool
    val nth: 'a list -> int -> 'a
    val nth_drop: int -> 'a list -> 'a list
    val nth_list: 'a list list -> int -> 'a list
    val nth_map: int -> ('a -> 'a) -> 'a list -> 'a list
    val nth_string: string -> int -> string
    val numdup: ('a * 'a -> bool) -> 'a list -> int
    val oct_char: string -> string
    val oo: ('a -> 'b) * ('c -> 'd -> 'a) -> 'c -> 'd -> 'b
    val ooo: ('a -> 'b) * ('c -> 'd -> 'e -> 'a) -> 'c -> 'd -> 'e -> 'b
    val oooo:
       ('a -> 'b) * ('c -> 'd -> 'e -> 'f -> 'a) ->
         'c -> 'd -> 'e -> 'f -> 'b
    val option_ord: ('a * 'b -> order) -> 'a option * 'b option -> order
    type 'a ord = 'a * 'a -> order
    val order_list: (int * 'a) list -> 'a list
    val orf: ('a -> bool) * ('a -> bool) -> 'a -> bool
    val pair: 'a -> 'b -> 'a * 'b
    val pair_of_list: 'a list -> 'a * 'a
    val partition_eq: ('a * 'a -> bool) -> 'a list -> 'a list list
    val partition_list:
       (int -> 'a -> bool) -> int -> int -> 'a list -> 'a list list
    val perhaps_apply: ('a -> 'a option) list -> 'a -> 'a option
    val perhaps_loop: ('a -> 'a option) -> 'a -> 'a option
    val plain_words: string -> string
    val pointer_eq_ord: ('a * 'a -> order) -> 'a * 'a -> order
    val prefix: string -> string -> string
    val prefix_lines: string -> string -> string
    val prefixes: 'a list -> 'a list list
    val prefixes1: 'a list -> 'a list list
    val prod_ord:
       ('a * 'b -> order) ->
         ('c * 'd -> order) -> ('a * 'c) * ('b * 'd) -> order
    val quote: string -> string
    val radixpand: int * int -> int list
    val radixstring: int * string * int -> string
    val read_int: string list -> int * string list
    val read_radix_int: int -> string list -> int * string list
    val remove: ('a * 'b -> bool) -> 'a -> 'b list -> 'b list
    val remove1: ('a * 'b -> bool) -> 'a -> 'b list -> 'b list
    val replicate: int -> 'a -> 'a list
    val replicate_string: int -> string -> string
    val reroute_ps_sp: ('a * 'b) * 'c -> 'a * ('b * 'c)
    val reroute_ps_triple: ('a * 'b) * 'c -> 'a * 'b * 'c
    val reroute_sp_ps: 'a * ('b * 'c) -> ('a * 'b) * 'c
    val reroute_sp_triple: 'a * ('b * 'c) -> 'a * 'b * 'c
    val reroute_triple_ps: 'a * 'b * 'c -> ('a * 'b) * 'c
    val reroute_triple_sp: 'a * 'b * 'c -> 'a * ('b * 'c)
    val rev_order: order -> order
    val rotate_list: 'a list -> 'a list
    val rpair: 'a -> 'b -> 'b * 'a
    val separate: 'a -> 'a list -> 'a list
    val serial: unit -> serial
    eqtype serial
    val serial_string: unit -> string
    val signed_string_of_int: int -> string
    val signed_string_of_real: real -> string
    val single: 'a -> 'a list
    val singleton: ('a list -> 'b list) -> 'a -> 'b
    val size_ord: string ord
    val snd: 'a * 'b -> 'b
    val sort: 'a ord -> 'a list -> 'a list
    val sort_by: ('a -> string) -> 'a list -> 'a list
    val sort_distinct: 'a ord -> 'a list -> 'a list
    val sort_strings: string list -> string list
    val space_explode: string -> string -> string list
    val space_implode: string -> string list -> string
    val split_last: 'a list -> 'a list * 'a
    val split_lines: string -> string list
    val split_list: ('a * 'b) list -> 'a list * 'b list
    val stamp: unit -> stamp
    eqtype stamp
    val string_of_indexname: string * int -> string
    val string_of_int: int -> string
    val string_of_real: real -> string
    val string_ord: string ord
    val submultiset: ('a * 'b -> bool) -> 'a list * 'b list -> bool
    val subset: ('a * 'b -> bool) -> 'a list * 'b list -> bool
    val subtract: ('a * 'b -> bool) -> 'a list -> 'b list -> 'b list
    val suffix: string -> string -> string
    val suffixes: 'a list -> 'a list list
    val suffixes1: 'a list -> 'a list list
    val surround: 'a -> 'a list -> 'a list
    val swap: 'a * 'b -> 'b * 'a
    val tabulate: string -> string
    val tag_list: int -> 'a list -> (int * 'a) list
    val take: int -> 'a list -> 'a list
    val take_prefix: ('a -> bool) -> 'a list -> 'a list
    val take_suffix: ('a -> bool) -> 'a list -> 'a list
    val the_single: 'a list -> 'a
    val translate_string: (string -> string) -> string -> string
    val trim: ('a -> bool) -> 'a list -> 'a list
    val trim_line: string -> string
    val trim_split_lines: string -> string list
    val triple_of_list: 'a list -> 'a * 'a * 'a
    val uncurry: ('a -> 'b -> 'c) -> 'a * 'b -> 'c
    val undefined: 'a -> 'b
    val unenclose: string -> string
    val unflat: 'a list list -> 'b list -> 'b list list
    val union: ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list
    val unprefix: string -> string -> string
    val unsuffix: string -> string -> string
    val untag_list: (int * 'a) list -> 'a list
    val update: ('a * 'a -> bool) -> 'a -> 'a list -> 'a list
    val upto: int * int -> int list
    val yield_singleton:
       ('a list -> 'b -> 'c list * 'b) -> 'a -> 'b -> 'c * 'b
    val zip_options: 'a list -> 'b option list -> ('a * 'b) list
    val ||| : ('a -> order) * ('a -> order) -> 'a -> order
    val ~~ : 'a list * 'b list -> ('a * 'b) list
  end
structure Library: LIBRARY
type 'a ord = 'a * 'a -> order
eqtype serial
eqtype stamp
structure Any: sig type T end
val apfst = fn: ('a -> 'b) -> 'a * 'c -> 'b * 'c
val equal = fn: ''a -> ''a -> bool
val normalize_lines = fn: string -> string
val build = fn: ('a list -> 'a list) -> 'a list
val dup = fn: 'a -> 'a * 'a
val funpow_yield = fn: int -> ('a -> 'b * 'a) -> 'a -> 'b list * 'a
val order_list = fn: (int * 'a) list -> 'a list
val trim_split_lines = fn: string -> string list
val suffixes = fn: 'a list -> 'a list list
val eq_fst = fn: ('a * 'b -> bool) -> ('a * 'c) * ('b * 'd) -> bool
val quote = fn: string -> string
val map_slice_side_r = fn:
   ('a list -> 'b list * 'c) -> ('d * 'a) list -> ('d * 'b) list * 'c
val numdup = fn: ('a * 'a -> bool) -> 'a list -> int
val snd = fn: 'a * 'b -> 'b
val commas = fn: string list -> string
val the_single = fn: 'a list -> 'a
val partition_eq = fn: ('a * 'a -> bool) -> 'a list -> 'a list list
val ||| = fn: ('a -> order) * ('a -> order) -> 'a -> order
val prefix = fn: string -> string -> string
val is_less = fn: order -> bool
val find_indices = fn: ('a -> bool) -> 'a list -> int list
val drop_prefix = fn: ('a -> bool) -> 'a list -> 'a list
val inter = fn: ('a * 'b -> bool) -> 'b list -> 'a list -> 'a list
val cat_lines = fn: string list -> string
val map_index = fn: (int * 'a -> 'b) -> 'a list -> 'b list
val take = fn: int -> 'a list -> 'a list
val align_right = fn: string -> int -> string -> string
val eq_snd = fn: ('a * 'b -> bool) -> ('c * 'a) * ('d * 'b) -> bool
val compare_each = fn: ('a * 'b -> 'c) -> 'a list -> 'b list -> 'c list
val ~~ = fn: 'a list * 'b list -> ('a * 'b) list
val downto = fn: int * int -> int list
val rotate_list = fn: 'a list -> 'a list
val update = fn: ('a * 'a -> bool) -> 'a -> 'a list -> 'a list
val translate_string = fn: (string -> string) -> string -> string
val union = fn: ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list
val fold_index = fn: (int * 'a -> 'b -> 'b) -> 'a list -> 'b -> 'b
val separate = fn: 'a -> 'a list -> 'a list
val build_rev = fn: ('a list -> 'a list) -> 'a list
val radixstring = fn: int * string * int -> string
val apdupl = fn: ('a -> 'b) -> 'a -> 'b * 'a
val match_string = fn: string -> string -> bool
val signed_string_of_int = fn: int -> string
val ? = fn: bool * ('a -> 'a) -> 'a -> 'a
val map2 = fn: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val drop_suffix = fn: ('a -> bool) -> 'a list -> 'a list
val suffixes1 = fn: 'a list -> 'a list list
val K = fn: 'a -> 'b -> 'a
val rev_order = fn: order -> order
val nth_list = fn: 'a list list -> int -> 'a list
val uncurry = fn: ('a -> 'b -> 'c) -> 'a * 'b -> 'c
val fold_product = fn:
   ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val merge = fn: ('a * 'a -> bool) -> 'a list * 'a list -> 'a list
val I = fn: 'a -> 'a
val is_less_equal = fn: order -> bool
val subtract = fn: ('a * 'b -> bool) -> 'a list -> 'b list -> 'b list
val map_slice_side_l = fn:
   ('a list -> 'b list * 'c) -> ('a * 'd) list -> ('b * 'd) list * 'c
val map_transpose = fn: ('a list -> 'b) -> 'a list list -> 'b list
val nth_map = fn: int -> ('a -> 'a) -> 'a list -> 'a list
val chop_common_prefix = fn:
   ('a * 'b -> bool) -> 'a list * 'b list -> 'a list * ('a list * 'b list)
val string_ord = fn: string ord
val pointer_eq_ord = fn: ('a * 'a -> order) -> 'a * 'a -> order
val has_duplicates = fn: ('a * 'a -> bool) -> 'a list -> bool
val reroute_triple_sp = fn: 'a * 'b * 'c -> 'a * ('b * 'c)
val replicate_string = fn: int -> string -> string
val perhaps_apply = fn: ('a -> 'a option) list -> 'a -> 'a option
val remove = fn: ('a * 'b -> bool) -> 'a -> 'b list -> 'b list
val remove1 = fn: ('a * 'b -> bool) -> 'a -> 'b list -> 'b list
val apdupr = fn: ('a -> 'b) -> 'a -> 'a * 'b
val suffix = fn: string -> string -> string
val zip_options = fn: 'a list -> 'b option list -> ('a * 'b) list
val submultiset = fn: ('a * 'b -> bool) -> 'a list * 'b list -> bool
val nth_string = fn: string -> int -> string
val kw_bc = fn: string parser
val foldl1 = fn: ('a * 'a -> 'a) -> 'a list -> 'a
val take_prefix = fn: ('a -> bool) -> 'a list -> 'a list
val andf = fn: ('a -> bool) * ('a -> bool) -> 'a -> bool
val not_equal = fn: ''a -> ''a -> bool
val string_of_indexname = fn: string * int -> string
val reroute_sp_ps = fn: 'a * ('b * 'c) -> ('a * 'b) * 'c
val unprefix = fn: string -> string -> string
val undefined = fn: 'a -> 'b
val reroute_sp_triple = fn: 'a * ('b * 'c) -> 'a * 'b * 'c
val kw_bo = fn: string parser
val read_int = fn: string list -> int * string list
val tabulate = fn: string -> string
val map_slice_l = fn:
   ('a list -> 'b list) -> ('a * 'c) list -> ('b * 'c) list
val pair_of_list = fn: 'a list -> 'a * 'a
val curry = fn: ('a * 'b -> 'c) -> 'a -> 'b -> 'c
val prod_ord = fn:
   ('a * 'b -> order) ->
     ('c * 'd -> order) -> ('a * 'c) * ('b * 'd) -> order
val foldr1 = fn: ('a * 'a -> 'a) -> 'a list -> 'a
val find_index = fn: ('a -> bool) -> 'a list -> int
val filter_out = fn: ('a -> bool) -> 'a list -> 'a list
val reroute_ps_triple = fn: ('a * 'b) * 'c -> 'a * 'b * 'c
val eq_pair = fn:
   ('a * 'b -> bool) -> ('c * 'd -> bool) -> ('a * 'c) * ('b * 'd) -> bool
val map_filter = fn: ('a -> 'b option) -> 'a list -> 'b list
val yield_singleton = fn:
   ('a list -> 'b -> 'c list * 'b) -> 'a -> 'b -> 'c * 'b
val take_suffix = fn: ('a -> bool) -> 'a list -> 'a list
val enclose = fn: string -> string -> string -> string
val orf = fn: ('a -> bool) * ('a -> bool) -> 'a -> bool
val map_product = fn: ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list
val burrow = fn: ('a list -> 'b list) -> 'a list list -> 'b list list
val space_explode = fn: string -> string -> string list
val make_ord = fn: ('a * 'a -> bool) -> 'a ord
val dict_ord = fn: ('a * 'b -> order) -> 'a list * 'b list -> order
val getenv = fn: string -> string
val map_range = fn: (int -> 'a) -> int -> 'a list
val list_of_triple = fn: 'a * 'a * 'a -> 'a list
val unflat = fn: 'a list list -> 'b list -> 'b list list
val insert = fn: ('a * 'a -> bool) -> 'a -> 'a list -> 'a list
val mk_opt_id = fn: ('a -> 'b) -> ('a -> 'b option) -> 'a -> 'b
val surround = fn: 'a -> 'a list -> 'a list
val divide_and_conquer' = fn:
   ('a -> 'b -> ('a list * ('c list * 'b -> 'c * 'b)) * 'b) ->
     'a -> 'b -> 'c * 'b
val split_list = fn: ('a * 'b) list -> 'a list * 'b list
val hex_digit = fn: int -> string
val singleton = fn: ('a list -> 'b list) -> 'a -> 'b
val unsuffix = fn: string -> string -> string
val subset = fn: ('a * 'b -> bool) -> 'a list * 'b list -> bool
val fast_string_ord = fn: string ord
val find_first = fn: ('a -> bool) -> 'a list -> 'a option
val is_prefix = fn: ('a * 'a -> bool) -> 'a list -> 'a list -> bool
val sort_by = fn: ('a -> string) -> 'a list -> 'a list
val decode_lines = fn: string -> string
val upto = fn: int * int -> int list
val is_greater = fn: order -> bool
val rpair = fn: 'a -> 'b -> 'b * 'a
val commas_quote = fn: string list -> string
val sort = fn: 'a ord -> 'a list -> 'a list
val plain_words = fn: string -> string
val apsnd = fn: ('a -> 'b) -> 'c * 'a -> 'c * 'b
val cartouche = fn: string -> string
val signed_string_of_real = fn: real -> string
val untag_list = fn: (int * 'a) list -> 'a list
val grouped = fn:
   int ->
     (('a list -> 'b list) -> 'c list list -> 'd list list) ->
       ('a -> 'b) -> 'c list -> 'd list
val member = fn: ('a * 'b -> bool) -> 'b list -> 'a -> bool
val fst = fn: 'a * 'b -> 'a
val fold2 = fn: ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c
val option_ord = fn: ('a * 'b -> order) -> 'a option * 'b option -> order
val chop = fn: int -> 'a list -> 'a list * 'a list
val triple_of_list = fn: 'a list -> 'a * 'a * 'a
val apply2 = fn: ('a -> 'b) -> 'a * 'a -> 'b * 'b
val string_of_int = fn: int -> string
val exists = fn: ('a -> bool) -> 'a list -> bool
val tag_list = fn: int -> 'a list -> (int * 'a) list
val member_string = fn: string -> string -> bool
val combine = fn: ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list
val is_equal = fn: order -> bool
val eq_list = fn: ('a * 'a -> bool) -> 'a list * 'a list -> bool
val map_split = fn: ('a -> 'b * 'c) -> 'a list -> 'b list * 'c list
val length_ord = fn: 'a list * 'b list -> order
val getenv_strict = fn: string -> string
val exists_string = fn: (string -> bool) -> string -> bool
val funpow = fn: int -> ('a -> 'a) -> 'a -> 'a
val sort_strings = fn: string list -> string list
val radixpand = fn: int * int -> int list
val trim_line = fn: string -> string
val oct_char = fn: string -> string
val divide_and_conquer = fn: ('a -> 'a list * ('b list -> 'b)) -> 'a -> 'b
val serial = fn: unit -> serial
val chop_groups = fn: int -> 'a list -> 'a list list
val pair = fn: 'a -> 'b -> 'a * 'b
val fold_string = fn: (string -> 'a -> 'a) -> string -> 'a -> 'a
val oooo = fn:
   ('a -> 'b) * ('c -> 'd -> 'e -> 'f -> 'a) -> 'c -> 'd -> 'e -> 'f -> 'b
val fold_range = fn: (int -> 'a -> 'a) -> int -> 'a -> 'a
val encode_lines = fn: string -> string
val read_radix_int = fn: int -> string list -> int * string list
val trim = fn: ('a -> bool) -> 'a list -> 'a list
val ooo = fn: ('a -> 'b) * ('c -> 'd -> 'e -> 'a) -> 'c -> 'd -> 'e -> 'b
val oo = fn: ('a -> 'b) * ('c -> 'd -> 'a) -> 'c -> 'd -> 'b
val flip = fn: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
val split_lines = fn: string -> string list
val foldl = fn: ('a * 'b -> 'a) -> 'a * 'b list -> 'a
val distinct = fn: ('a * 'a -> bool) -> 'a list -> 'a list
val partition_list = fn:
   (int -> 'a -> bool) -> int -> int -> 'a list -> 'a list list
val is_greater_equal = fn: order -> bool
val space_implode = fn: string -> string list -> string
val filter = fn: ('a -> bool) -> 'a list -> 'a list
val get_index = fn: ('a -> 'b option) -> 'a list -> (int * 'b) option
val nth = fn: 'a list -> int -> 'a
val kw_col = fn: string parser
val serial_string = fn: unit -> string
val foldr = fn: ('a * 'b -> 'b) -> 'a list * 'b -> 'b
val get_first = fn: ('a -> 'b option) -> 'a list -> 'b option
val prefixes = fn: 'a list -> 'a list list
val fold_burrow = fn:
   ('a list -> 'b -> 'c list * 'd) ->
     'a list list -> 'b -> 'c list list * 'd
val drop = fn: int -> 'a list -> 'a list
val bool_ord = fn: bool ord
val swap = fn: 'a * 'b -> 'b * 'a
val flat = fn: 'a list list -> 'a list
val forall = fn: ('a -> bool) -> 'a list -> bool
val maps = fn: ('a -> 'b list) -> 'a list -> 'b list
val min_list = fn: int list -> int
val chop_prefix = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val burrow_options = fn:
   ('a list -> 'b list) -> 'a option list -> 'b option list
val sort_distinct = fn: 'a ord -> 'a list -> 'a list
val unenclose = fn: string -> string
val map_slice_r = fn:
   ('a list -> 'b list) -> ('c * 'a) list -> ('c * 'b) list
val reroute_ps_sp = fn: ('a * 'b) * 'c -> 'a * ('b * 'c)
val first_field = fn: string -> string -> (string * string) option
val stamp = fn: unit -> stamp
val split_last = fn: 'a list -> 'a list * 'a
val burrow_fst = fn:
   ('a list -> 'b list) -> ('a * 'c) list -> ('b * 'c) list
val single = fn: 'a -> 'a list
val forall_string = fn: (string -> bool) -> string -> bool
val list_ord = fn: ('a * 'b -> order) -> 'a list * 'b list -> order
val eq_set = fn: ('a * 'a -> bool) -> 'a list * 'a list -> bool
val list_of_pair = fn: 'a * 'a -> 'a list
val size_ord = fn: string ord
val prefix_lines = fn: string -> string -> string
val replicate = fn: int -> 'a -> 'a list
val prefixes1 = fn: 'a list -> 'a list list
val int_ord = fn: int ord
val chop_suffix = fn: ('a -> bool) -> 'a list -> 'a list * 'a list
val reroute_triple_ps = fn: 'a * 'b * 'c -> ('a * 'b) * 'c
val nth_drop = fn: int -> 'a list -> 'a list
val string_of_real = fn: real -> string
val perhaps_loop = fn: ('a -> 'a option) -> 'a -> 'a option
val duplicates = fn: ('a * 'a -> bool) -> 'a list -> 'a list
signature TERM =
  sig
    val ---> : typ list * typ -> typ
    val --> : typ * typ -> typ
    exception TERM of string * term list
    exception TYPE of string * typ list * term list
    exception USED_FREE of string * term
    val aT: sort -> typ
    val a_itselfT: typ
    val abs: string * typ -> term -> term
    val absdummy: typ -> term -> term
    val absfree: string * typ -> term -> term
    val abstract_over: term * term -> term
    val aconv: term * term -> bool
    val aconv_untyped: term * term -> bool
    val add_const_names: term -> string list -> string list
    val add_consts: term -> (string * typ) list -> (string * typ) list
    val add_free_names: term -> string list -> string list
    val add_frees: term -> (string * typ) list -> (string * typ) list
    val add_loose_bnos: term * int * int list -> int list
    val add_tfree_names: term -> string list -> string list
    val add_tfree_namesT: typ -> string list -> string list
    val add_tfrees: term -> (string * sort) list -> (string * sort) list
    val add_tfreesT: typ -> (string * sort) list -> (string * sort) list
    val add_tvar_names: term -> indexname list -> indexname list
    val add_tvar_namesT: typ -> indexname list -> indexname list
    val add_tvars:
       term -> (indexname * sort) list -> (indexname * sort) list
    val add_tvarsT:
       typ -> (indexname * sort) list -> (indexname * sort) list
    val add_var_names: term -> indexname list -> indexname list
    val add_vars: term -> (indexname * typ) list -> (indexname * typ) list
    val args_of: term -> term list
    val argument_type_of: term -> int -> typ
    type arity = string * sort list * sort
    val betapply: term * term -> term
    val betapplys: term * term list -> term
    val binder_types: typ -> typ list
    val body_type: typ -> typ
    val burrow_types: (typ list -> typ list) -> term list -> term list
    eqtype class
    val close_schematic_term: term -> term
    val could_beta_contract: term -> bool
    val could_beta_eta_contract: term -> bool
    val could_eta_contract: term -> bool
    val could_match_const: (''a * typ) * (''a * typ) -> bool
    val could_unify: term * term -> bool
    val declare_term_frees: term -> Name.context -> Name.context
    val declare_term_names: term -> Name.context -> Name.context
    val declare_typ_names: typ -> Name.context -> Name.context
    val dependent_lambda_name: string * term -> term -> term
    val dest_Const: term -> string * typ
    val dest_Free: term -> string * typ
    val dest_TFree: typ -> string * sort
    val dest_TVar: typ -> indexname * sort
    val dest_Type: typ -> string * typ list
    val dest_Var: term -> indexname * typ
    val dest_abs_fresh: string -> term -> (string * typ) * term
    val dest_abs_global: term -> (string * typ) * term
    val dest_comb: term -> term * term
    val dest_funT: typ -> typ * typ
    val domain_type: typ -> typ
    val dummy: term
    val dummyS: sort
    val dummyT: typ
    val dummy_pattern: typ -> term
    val dummy_prop: term
    val eq_ix: indexname * indexname -> bool
    val eq_tvar: (indexname * sort) * (indexname * sort) -> bool
    val eq_var: (indexname * typ) * (indexname * typ) -> bool
    val exists_Const: (string * typ -> bool) -> term -> bool
    val exists_subterm: (term -> bool) -> term -> bool
    val exists_subtype: (typ -> bool) -> typ -> bool
    val exists_type: (typ -> bool) -> term -> bool
    val fastype_of: term -> typ
    val fastype_of1: typ list * term -> typ
    val fold_aterms: (term -> 'a -> 'a) -> term -> 'a -> 'a
    val fold_atyps: (typ -> 'a -> 'a) -> typ -> 'a -> 'a
    val fold_atyps_sorts: (typ * sort -> 'a -> 'a) -> typ -> 'a -> 'a
    val fold_subtypes: (typ -> 'a -> 'a) -> typ -> 'a -> 'a
    val fold_term_types: (term -> typ -> 'a -> 'a) -> term -> 'a -> 'a
    val fold_types: (typ -> 'a -> 'a) -> term -> 'a -> 'a
    val free_dummy_patterns: term -> Name.context -> term * Name.context
    val has_tfreesT: typ -> bool
    val head_of: term -> term
    val hidden_polymorphism: term -> (indexname * sort) list
    val incr_boundvars: int -> term -> term
    val incr_bv: int * int * term -> term
    type indexname = string * int
    val is_Bound: term -> bool
    val is_Const: term -> bool
    val is_Free: term -> bool
    val is_TFree: typ -> bool
    val is_TVar: typ -> bool
    val is_Type: typ -> bool
    val is_Var: term -> bool
    val is_comb: term -> bool
    val is_cv: term -> bool
    val is_dependent: term -> bool
    val is_dummy_pattern: term -> bool
    val is_first_order: string list -> term -> bool
    val is_open: term -> bool
    val itselfT: typ -> typ
    val lambda: term -> term -> term
    val lambda_name: string * term -> term -> term
    val list_comb: term * term list -> term
    val loose_bnos: term -> int list
    val loose_bvar: term * int -> bool
    val loose_bvar1: term * int -> bool
    val map_abs_vars: (string -> string) -> term -> term
    val map_aterms: (term -> term) -> term -> term
    val map_atyps: (typ -> typ) -> typ -> typ
    val map_const: (string * typ -> term) -> term -> term
    val map_fv: (string * typ -> term) -> term -> term
    val map_sv: (indexname * typ -> term) -> term -> term
    val map_tfree: (string * sort -> typ) -> term -> term
    val map_type_tfree: (string * sort -> typ) -> typ -> typ
    val map_type_tvar: (indexname * sort -> typ) -> typ -> typ
    val map_types: (typ -> typ) -> term -> term
    val match_bvars:
       term * term -> (string * string) list -> (string * string) list
    val maxidx_of_term: term -> int
    val maxidx_of_typ: typ -> int
    val maxidx_of_typs: typ list -> int
    val maxidx_term: term -> int -> int
    val maxidx_typ: typ -> int -> int
    val maxidx_typs: typ list -> int -> int
    val no_dummyT: typ -> typ
    val no_dummy_patterns: term -> term
    val propT: typ
    val range_type: typ -> typ
    val rename_abs: term -> term -> term -> term option
    val rename_wrt_term: term -> (string * 'a) list -> (string * 'a) list
    val replace_dummy_patterns: term -> int -> term * int
    val show_dummy_patterns: term -> term
    val size_of_term: term -> int
    val size_of_typ: typ -> int
    type sort = class list
    val sort_eqT: theory -> typ * typ -> bool
    val sort_of_tvar: typ -> sort
    val string_of_vname: indexname -> string
    val string_of_vname': indexname -> string
    val strip_abs: term -> (string * typ) list * term
    val strip_abs_body: term -> term
    val strip_abs_eta: int -> term -> (string * typ) list * term
    val strip_abs_vars: term -> (string * typ) list
    val strip_all_body: term -> term
    val strip_all_vars: term -> (string * typ) list
    val strip_comb: term -> term * term list
    val strip_qnt_body: string -> term -> term
    val strip_qnt_vars: string -> term -> (string * typ) list
    val strip_type: typ -> typ list * typ
    val subst_TVars: (indexname * typ) list -> term -> term
    val subst_Vars: (indexname * term) list -> term -> term
    val subst_atomic: (term * term) list -> term -> term
    val subst_atomic_types: (typ * typ) list -> term -> term
    val subst_bound: term * term -> term
    val subst_bounds: term list * term -> term
    val subst_free: (term * term) list -> term -> term
    val subst_vars:
       (indexname * typ) list * (indexname * term) list -> term -> term
    datatype term
    =
         $ of term * term
       | Abs of string * typ * term
       | Bound of int
       | Const of string * typ
       | Free of string * typ
       | Var of indexname * typ
    val term_name: term -> string
    datatype typ
    =
         TFree of string * sort
       | TVar of indexname * sort
       | Type of string * typ list
    val typ_subst_TVars: (indexname * typ) list -> typ -> typ
    val typ_subst_atomic: (typ * typ) list -> typ -> typ
    val type_of: term -> typ
    val type_of1: typ list * term -> typ
    val used_free: string -> term -> bool
    val variant_frees: term -> (string * 'a) list -> (string * 'a) list
  end
structure Term: TERM
signature LOGIC =
  sig
    val all: term -> term -> term
    val all_const: typ -> term
    val all_constraint:
       (string -> typ option) -> string * string -> term -> term
    val assum_pairs: int * term -> (term * term) list
    val assum_problems: int * term -> (term -> term) * term list * term
    val bad_fixed: string -> string
    val bad_schematic: indexname -> string
    val class_of_const: string -> class
    val close_form: term -> term
    val close_prop: (string * term) list -> term list -> term -> term
    val close_prop_constraint:
       (string -> typ option) ->
         (string * string) list -> term list -> term -> term
    val close_term: (string * term) list -> term -> term
    val combound: term * int * int -> term
    val concl_of_goal: term -> int -> term
    val conjunction: term
    val const_of_class: class -> string
    val count_prems: term -> int
    val dependent_all_constraint:
       (string -> typ option) -> string * string -> term -> term
    val dependent_all_name: string * term -> term -> term
    val dest_all_global: term -> (string * typ) * term
    val dest_arity: term -> string * sort list * class
    val dest_classrel: term -> class * class
    val dest_conjunction: term -> term * term
    val dest_conjunction_balanced: int -> term -> term list
    val dest_conjunction_list: term -> term list
    val dest_conjunctions: term -> term list
    val dest_equals: term -> term * term
    val dest_implies: term -> term * term
    val dest_of_class: term -> typ * class
    val dest_term: term -> term
    val dest_type: term -> typ
    val dummy_tfree: sort -> typ
    val flatten_params: int -> term -> term
    val forall_elim_all: term -> term * (string * typ) list
    val get_forall_ftv_permute:
       term -> term * ((string * typ) list * int list)
    val get_goal: term -> int -> term
    val goal_params: term -> int -> term * term list
    val has_meta_prems: term -> bool
    val implies: term
    val incr_indexes: string list * typ list * int -> term -> term
    val incr_indexes_same:
       string list * typ list * int -> term Same.operation
    val incr_tvar: int -> typ -> typ
    val incr_tvar_same: int -> typ Same.operation
    val is_all: term -> bool
    val is_equals: term -> bool
    val lift_abs: int -> term -> term -> term
    val lift_all: int -> term -> term -> term
    val list_all: (string * typ) list * term -> term
    val list_implies: term list * term -> term
    val list_rename_params: string list -> term -> term
    val mk_arities: arity -> term list
    val mk_arity: string * sort list * class -> term
    val mk_classrel: class * class -> term
    val mk_conjunction: term * term -> term
    val mk_conjunction_balanced: term list -> term
    val mk_conjunction_list: term list -> term
    val mk_equals: term * term -> term
    val mk_implies: term * term -> term
    val mk_of_class: typ * class -> term
    val mk_of_sort: typ * sort -> term list
    val mk_term: term -> term
    val mk_type: typ -> term
    val name_arities: arity -> string list
    val name_arity: string * sort list * class -> string
    val name_classrel: string * string -> string
    val no_prems: term -> bool
    val nth_prem: int * term -> term
    val occs: term * term -> bool
    val prems_of_goal: term -> int -> term list
    val protect: term -> term
    val protectC: term
    val rlist_abs: (string * typ) list * term -> term
    val strip_assums_concl: term -> term
    val strip_assums_hyp: term -> term list
    val strip_horn: term -> term list * term
    val strip_imp_concl: term -> term
    val strip_imp_prems: term -> term list
    val strip_params: term -> (string * typ) list
    val strip_prems: int * term list * term -> term list * term
    val true_prop: term
    val type_map: (term -> term) -> typ -> typ
    val unconstrainT: sort list -> term -> unconstrain_context * term
    type unconstrain_context =
       {atyp_map: typ -> typ,
        constraints: ((typ * class) * term) list,
        constraints_map: (sort * typ) list,
        map_atyps: typ -> typ,
        outer_constraints: (typ * class) list,
        present_map: (typ * typ) list}
    val unoverload_types_term: theory -> term -> term
    val unprotect: term -> term
    val unvarifyT_global: typ -> typ
    val unvarify_global: term -> term
    val unvarify_local_term: Proof.context -> term -> term * Proof.context
    val unvarify_types_global: term -> term
    val unvarify_types_local_term:
       Proof.context -> term -> term * Proof.context
    val varifyT_global: typ -> typ
    val varifyT_mixed_global: typ -> typ
    val varify_global: term -> term
    val varify_mixed_global: term -> term
    val varify_types_global: term -> term
  end
structure Logic: LOGIC
signature TACTICAL =
  sig
    val ALLGOALS: (int -> tactic) -> tactic
    val APPEND: tactic * tactic -> tactic
    val APPEND': ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
    val ASSERT_SUBGOAL: (int -> tactic) -> int -> tactic
    val CHANGED: tactic -> tactic
    val CHANGED_GOAL: (int -> tactic) -> int -> tactic
    val CHANGED_PROP: tactic -> tactic
    val COND: (thm -> bool) -> tactic -> tactic -> tactic
    val CONVERSION: conv -> int -> tactic
    val CSUBGOAL: (cterm * int -> tactic) -> int -> tactic
    val DETERM: tactic -> tactic
    val EVERY: tactic list -> tactic
    val EVERY': ('a -> tactic) list -> 'a -> tactic
    val EVERY1: (int -> tactic) list -> tactic
    val FILTER: (thm -> bool) -> tactic -> tactic
    val FIRST: tactic list -> tactic
    val FIRST': ('a -> tactic) list -> 'a -> tactic
    val FIRST1: (int -> tactic) list -> tactic
    val FIRSTGOAL: (int -> tactic) -> tactic
    val FIRST_APPEND': ('a -> tactic) list -> 'a -> tactic
    val HEADGOAL: (int -> tactic) -> tactic
    val ORELSE: tactic * tactic -> tactic
    val ORELSE': ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
    val PRIMITIVE: (thm -> thm) -> tactic
    val PRIMSEQ: (thm -> thm Seq.seq) -> tactic
    val RANGE: (int -> tactic) list -> int -> tactic
    val REPEAT: tactic -> tactic
    val REPEAT1: tactic -> tactic
    val REPEAT_ALL_NEW: (int -> tactic) -> int -> tactic
    val REPEAT_DETERM: tactic -> tactic
    val REPEAT_DETERM1: tactic -> tactic
    val REPEAT_DETERM_FIRST: (int -> tactic) -> tactic
    val REPEAT_DETERM_N: int -> tactic -> tactic
    val REPEAT_DETERM_SOME: (int -> tactic) -> tactic
    val REPEAT_FIRST: (int -> tactic) -> tactic
    val REPEAT_SOME: (int -> tactic) -> tactic
    val SINGLE: tactic -> thm -> thm option
    val SOLVED': (int -> tactic) -> int -> tactic
    val SOMEGOAL: (int -> tactic) -> tactic
    val SUBGOAL: (term * int -> tactic) -> int -> tactic
    val THEN: tactic * tactic -> tactic
    val THEN': ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
    val THEN_ALL_NEW: (int -> tactic) * (int -> tactic) -> int -> tactic
    val THEN_ELSE: tactic * (tactic * tactic) -> tactic
    val TRY: tactic -> tactic
    val TRYALL: (int -> tactic) -> tactic
    val all_tac: tactic
    val no_tac: tactic
    val print_tac: Proof.context -> string -> tactic
    type tactic = thm -> thm Seq.seq
  end
structure Tactical: TACTICAL
type tactic = thm -> thm Seq.seq
val FILTER = fn: (thm -> bool) -> tactic -> tactic
val REPEAT1 = fn: tactic -> tactic
val TRYALL = fn: (int -> tactic) -> tactic
val THEN = fn: tactic * tactic -> tactic
val COND = fn: (thm -> bool) -> tactic -> tactic -> tactic
val REPEAT = fn: tactic -> tactic
val ASSERT_SUBGOAL = fn: (int -> tactic) -> int -> tactic
val REPEAT_SOME = fn: (int -> tactic) -> tactic
val ORELSE' = fn: ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
val print_tac = fn: Proof.context -> string -> tactic
val REPEAT_DETERM1 = fn: tactic -> tactic
val CONVERSION = fn: conv -> int -> tactic
val EVERY = fn: tactic list -> tactic
val ORELSE = fn: tactic * tactic -> tactic
val FIRST_APPEND' = fn: ('a -> tactic) list -> 'a -> tactic
val FIRST = fn: tactic list -> tactic
val SOMEGOAL = fn: (int -> tactic) -> tactic
val REPEAT_FIRST = fn: (int -> tactic) -> tactic
val APPEND' = fn: ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
val SINGLE = fn: tactic -> thm -> thm option
val THEN_ELSE = fn: tactic * (tactic * tactic) -> tactic
val no_tac = fn: tactic
val ALLGOALS = fn: (int -> tactic) -> tactic
val THEN' = fn: ('a -> tactic) * ('a -> tactic) -> 'a -> tactic
val SUBGOAL = fn: (term * int -> tactic) -> int -> tactic
val REPEAT_DETERM = fn: tactic -> tactic
val CSUBGOAL = fn: (cterm * int -> tactic) -> int -> tactic
val APPEND = fn: tactic * tactic -> tactic
val PRIMITIVE = fn: (thm -> thm) -> tactic
val THEN_ALL_NEW = fn: (int -> tactic) * (int -> tactic) -> int -> tactic
val REPEAT_ALL_NEW = fn: (int -> tactic) -> int -> tactic
val EVERY1 = fn: (int -> tactic) list -> tactic
val FIRSTGOAL = fn: (int -> tactic) -> tactic
val RANGE = fn: (int -> tactic) list -> int -> tactic
val all_tac = fn: tactic
val FIRST1 = fn: (int -> tactic) list -> tactic
val REPEAT_DETERM_N = fn: int -> tactic -> tactic
val PRIMSEQ = fn: (thm -> thm Seq.seq) -> tactic
val CHANGED_GOAL = fn: (int -> tactic) -> int -> tactic
val TRY = fn: tactic -> tactic
val EVERY' = fn: ('a -> tactic) list -> 'a -> tactic
val HEADGOAL = fn: (int -> tactic) -> tactic
val FIRST' = fn: ('a -> tactic) list -> 'a -> tactic
val CHANGED_PROP = fn: tactic -> tactic
val REPEAT_DETERM_SOME = fn: (int -> tactic) -> tactic
val REPEAT_DETERM_FIRST = fn: (int -> tactic) -> tactic
val SOLVED' = fn: (int -> tactic) -> int -> tactic
val DETERM = fn: tactic -> tactic
val CHANGED = fn: tactic -> tactic
### theory "Draft.Set_Ext"
### 0.041s elapsed time, 0.161s cpu time, 0.000s GC time
Loading theory "Draft.Transfer_Ext" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
structure More_Simplifier:
  sig
    val asm_full_var_simplify: Proof.context -> thm -> thm
    val rewrite_simp_opt: Proof.context -> thm list option -> thm -> thm
    val rewrite_simp_opt':
       Proof.context -> (Facts.ref * Token.src list) option -> thm -> thm
    val var_simplified:
       Context.generic * Token.T list ->
         attribute * (Context.generic * Token.T list)
    val var_simplify_only: Proof.context -> thm list -> thm -> thm
  end
signature HOLOGIC =
  sig
    val Collect_const: typ -> term
    val Not: term
    val Suc_zero: term
    val Trueprop: term
    val Trueprop_conv: conv -> conv
    val add_numerals: term -> (term * typ) list -> (term * typ) list
    val all_const: typ -> term
    val bit0_const: term
    val bit1_const: term
    val boolN: string
    val boolT: typ
    val case_prod_const: typ * typ * typ -> term
    val charT: typ
    val choice_const: typ -> term
    val class_equal: string
    val class_size: string
    val code_integerT: typ
    val code_naturalT: typ
    val conj: term
    val conj_conv: conv -> conv -> conv
    val conj_elim: Proof.context -> thm -> thm * thm
    val conj_elims: Proof.context -> thm -> thm list
    val conj_intr: Proof.context -> thm -> thm -> thm
    val conjuncts: term -> term list
    val cons_const: typ -> term
    val dest_SetT: typ -> typ
    val dest_SetTFree: typ -> string * sort
    val dest_Suc: term -> term
    val dest_Trueprop: term -> term
    val dest_bin: string -> typ -> term -> term * term
    val dest_binrelT: typ -> typ * typ
    val dest_char: term -> int
    val dest_conj: term -> term list
    val dest_disj: term -> term list
    val dest_eq: term -> term * term
    val dest_exists: term -> string * typ * term
    val dest_imp: term -> term * term
    val dest_list: term -> term list
    val dest_literal: term -> string
    val dest_mem: term -> term * term
    val dest_nat: term -> int
    val dest_not: term -> term
    val dest_number: term -> typ * int
    val dest_numeral: term -> int
    val dest_prod: term -> term * term
    val dest_prodT: typ -> typ * typ
    val dest_set: term -> term list
    val dest_setT: typ -> typ
    val dest_string: term -> string
    val dest_type_definition: term -> term * term * term
    val disj: term
    val disjuncts: term -> term list
    val eq_const: typ -> term
    val eq_conv: conv -> conv -> conv
    val exists_const: typ -> term
    val flat_tupleT_paths: typ -> int list list
    val flat_tuple_paths: term -> int list list
    val flatten_tupleT: typ -> typ list
    val id_const: typ -> term
    val imp: term
    val intT: typ
    val is_binrelT: typ -> bool
    val is_binrelvarT: typ -> bool
    val is_conj: term -> bool
    val is_setT: typ -> bool
    val is_unit: term -> bool
    val is_unitT: typ -> bool
    val is_var_setT: typ -> bool
    val is_zero: term -> bool
    val listT: typ -> typ
    val list_all: (string * typ) list * term -> term
    val literalT: typ
    val mk_Collect: string * typ * term -> term
    val mk_ST:
       ((term * typ) * (string * typ) option) list ->
         term -> typ -> typ option * typ -> term
    val mk_Suc: term -> term
    val mk_Trueprop: term -> term
    val mk_UNIV: typ -> term
    val mk_all: string * typ * term -> term
    val mk_binop: string -> term * term -> term
    val mk_binrel: string -> term * term -> term
    val mk_binrelT: typ * typ -> typ
    val mk_case_prod: term -> term
    val mk_char: int -> term
    val mk_comp: term * term -> term
    val mk_conj: term * term -> term
    val mk_disj: term * term -> term
    val mk_eq: term * term -> term
    val mk_exists: string * typ * term -> term
    val mk_fst: term -> term
    val mk_imp: term * term -> term
    val mk_induct_forall: typ -> term
    val mk_list: typ -> term list -> term
    val mk_literal: string -> term
    val mk_mem: term * term -> term
    val mk_nat: int -> term
    val mk_not: term -> term
    val mk_number: typ -> int -> term
    val mk_numeral: int -> term
    val mk_obj_eq: thm -> thm
    val mk_prod: term * term -> term
    val mk_prodT: typ * typ -> typ
    val mk_ptuple: int list list -> typ -> term list -> term
    val mk_ptupleT: int list list -> typ list -> typ
    val mk_ptupleabs: int list list -> typ -> typ -> term -> term
    val mk_random: typ -> term -> term
    val mk_rel: string * (typ * typ) -> term
    val mk_return: typ -> typ -> term -> term
    val mk_set: typ -> term list -> term
    val mk_setT: typ -> typ
    val mk_snd: term -> term
    val mk_string: string -> term
    val mk_term_of: typ -> term -> term
    val mk_tuple: term list -> term
    val mk_tupleT: typ list -> typ
    val mk_type_definition_pred: typ -> typ -> term
    val mk_typerep: typ -> term
    val mk_valtermify_app: string -> (string * typ) list -> typ -> term
    val natT: typ
    val nil_const: typ -> term
    val numeral_const: typ -> term
    val one_const: term
    val pair_const: typ -> typ -> term
    val realT: typ
    val reflect_term: term -> term
    val size_const: typ -> term
    val stringT: typ
    val strip_ptuple: int list list -> term -> term list
    val strip_ptupleT: int list list -> typ -> typ list
    val strip_ptupleabs: term -> term * typ list * int list list
    val strip_tuple: term -> term list
    val strip_tupleT: typ -> typ list
    val termT: typ
    val term_of_const: typ -> term
    val tupled_lambda: term -> term -> term
    val unit: term
    val unitT: typ
    val zero: term
  end
structure HOLogic: HOLOGIC
signature TRANSFER =
  sig
    val eq_tac: Proof.context -> int -> tactic
    val fold_relator_eqs_conv: Proof.context -> conv
    val gen_frees_tac: (string * typ) list -> Proof.context -> int -> tactic
    val get_relator_domain: Proof.context -> thm list
    val get_relator_eq: Proof.context -> thm list
    val get_relator_eq_raw: Proof.context -> thm list
    val get_sym_relator_eq: Proof.context -> thm list
    val get_transfer_raw: Proof.context -> thm list
    val is_compound_lhs: Proof.context -> term -> bool
    val is_compound_rhs: Proof.context -> term -> bool
    val is_is_equality: term -> bool
    val lookup_pred_data: Proof.context -> string -> pred_data option
    val mk_bi_unique: term -> term
    val mk_pred_data: thm -> thm -> thm list -> pred_data
    val mk_rel_sc: string -> term -> term
    val mk_right_total: term -> term
    val mk_transfer_rels: thm list -> thm list
    val morph_pred_data: morphism -> pred_data -> pred_data
    type pred_data
    val pred_def: pred_data -> thm
    val pred_simps: pred_data -> thm list
    val prep_conv: conv
    val prep_transfer_domain_thm: Proof.context -> thm -> thm
    val rel_eq_onp: pred_data -> thm
    val retrieve_relator_eq: Proof.context -> term -> thm list
    val transfer_add: attribute
    val transfer_del: attribute
    val transfer_domain_add: attribute
    val transfer_domain_del: attribute
    val transfer_end_tac: Proof.context -> int -> tactic
    val transfer_prover_end_tac: Proof.context -> int -> tactic
    val transfer_prover_start_tac: Proof.context -> int -> tactic
    val transfer_prover_tac: Proof.context -> int -> tactic
    val transfer_raw_add: thm -> Context.generic -> Context.generic
    val transfer_raw_del: thm -> Context.generic -> Context.generic
    val transfer_rule_of_lhs: Proof.context -> term -> thm
    val transfer_rule_of_term: Proof.context -> bool -> term -> thm
    val transfer_start_tac: bool -> Proof.context -> int -> tactic
    val transfer_step_tac: Proof.context -> int -> tactic
    val transfer_tac: bool -> Proof.context -> int -> tactic
    val transferred_attribute: thm list -> attribute
    val unfold_relator_eqs_conv: Proof.context -> conv
    val untransferred_attribute: thm list -> attribute
    val update_pred_data:
       string -> pred_data -> Context.generic -> Context.generic
    val update_pred_simps: thm list -> pred_data -> pred_data
  end
structure Transfer: TRANSFER
### theory "Draft.Lifting_Set_Ext"
### 0.134s elapsed time, 0.512s cpu time, 0.025s GC time
Loading theory "HOL-Library.Function_Algebras" (required by "Draft.SML_ConclusionsTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
signature ETTS_WRITER =
  sig
    val increment_index: int -> int list -> int list
    val initialize: int -> int list
    val write_action: string -> int list -> int list
  end
structure ETTS_Writer: ETTS_WRITER
### theory "Draft.ETTS_Tools"
### 0.144s elapsed time, 0.551s cpu time, 0.025s GC time
Loading theory "HOL-Library.Stream" (required by "Draft.SML_ConclusionsTemplates" via "Draft.ExtrEqs")
instantiation
  fun :: (type, plus) plus
  plus_fun == plus :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, zero) zero
  zero_fun == zero_class.zero :: 'a => 'b
### theory "Draft.Transfer_Ext"
### 0.089s elapsed time, 0.338s cpu time, 0.025s GC time
Loading theory "HOL-Library.Set_Algebras" (required by "Draft.SML_ConclusionsTemplates" via "Draft.ExtrEqs" via "HOL-Library.BigO")
instantiation
  fun :: (type, times) times
  times_fun == times :: ('a => 'b) => ('a => 'b) => 'a => 'b
instantiation
  fun :: (type, one) one
  one_fun == one_class.one :: 'a => 'b
instantiation
  set :: (plus) plus
  plus_set == plus :: 'a set => 'a set => 'a set
instantiation
  set :: (times) times
  times_set == times :: 'a set => 'a set => 'a set
instantiation
  set :: (zero) zero
  zero_set == zero_class.zero :: 'a set
instantiation
  set :: (one) one
  one_set == one_class.one :: 'a set
### theory "HOL-Library.Function_Algebras"
### 0.147s elapsed time, 0.584s cpu time, 0.000s GC time
Loading theory "HOL-Library.Tree" (required by "Draft.SML_ConclusionsTemplates" via "Draft.ExtrEqs" via "Draft.Templates")
### theory "Draft.SML_Relations"
### 0.286s elapsed time, 1.116s cpu time, 0.025s GC time
Loading theory "Draft.ETTS" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions" via "Draft.SML_Introduction" via "Draft.Introduction" via "Draft.ETTS_Auxiliary")
### theory "HOL-Library.Set_Algebras"
### 0.207s elapsed time, 0.798s cpu time, 0.088s GC time
Loading theory "HOL-Library.BigO" (required by "Draft.SML_ConclusionsTemplates" via "Draft.ExtrEqs")
consts
  shift :: "'a list => 'a stream => 'a stream"
Proofs for coinductive predicate(s) "streamsp"
  Proving monotonicity ...
signature ETTS_TACTICS =
  sig
    val cond_red_tac:
       Proof.context ->
         term -> (Proof.context -> tactic) -> thm -> int -> tactic
    val id_tac: thm -> int -> tactic
    val prem_red:
       Proof.context -> term list * (Proof.context -> tactic) -> thm -> thm
  end
structure ETTS_Tactics: ETTS_TACTICS
signature ETTS_UTILITIES =
  sig
    val string_of_token_src_list: Token.src list -> string
    val term_name_of_type_name: string -> string
  end
structure ETTS_Utilities: ETTS_UTILITIES
val string_of_token_src_list = fn: Token.src list -> string
val term_name_of_type_name = fn: string -> string
signature ETTS_RI =
  sig
    val dest_rissetFree: term -> string * (string * sort)
    val dest_rissetT: typ -> string * sort
    val ftv_spec_of_rissetT_spec: string -> string * string list
    val fv_spec_of_rissetFree: string * string -> string * typ
    val is_risset: term -> bool
    val mk_Domainp_sc: term -> term -> term
    val risset_input: Proof.context -> string -> term list -> unit
    val type_of_rissetT_spec: string -> typ
  end
structure ETTS_RI: ETTS_RI
consts
  snth :: "'a stream => nat => 'a"
consts
  stake :: "nat => 'a stream => 'a list"
consts
  sdrop :: "nat => 'a stream => 'a stream"
signature ETTS_SUBSTITUTION =
  sig
    val is_sbt_data_key: Proof.context -> cterm -> bool
    val process_tts_register_sbts:
       string * string list -> Proof.context -> Proof.state
    val sbt_data_of: Proof.context -> Ctermtab.key -> thm option
  end
structure ETTS_Substitution: ETTS_SUBSTITUTION
consts
  sfilter :: "('a => bool) => 'a stream => 'a stream"
consts
  cycle :: "'a list => 'a stream"
consts
  left :: "'a tree => 'a tree"
consts
  right :: "'a tree => 'a tree"
consts
  siterate :: "('a => 'a) => 'a => 'a stream"
signature ETTS_CONTEXT =
  sig
    val amend_context_data:
       amend_ctxt_data_input_type ->
         Proof.context -> ctxt_def_type * Proof.context
    type amend_ctxt_data_input_type
    type ctxt_def_type
    val get_tts_ctxt_data: Proof.context -> ctxt_def_type
    val process_tts_context:
       amend_ctxt_data_input_type ->
         Toplevel.transition -> Toplevel.transition
    val rule_attrb: string list
    val string_of_amend_context_data_args:
       Proof.context -> amend_ctxt_data_input_type -> string
    val string_of_mpespc_opt:
       Proof.context ->
         (term list * (Proof.context -> tactic)) option -> string
    val string_of_sbrr_opt: (Facts.ref * Token.src list) option -> string
    val string_of_subst_thms: (Facts.ref * Token.src list) list -> string
    val string_of_tts_ctxt_data: Proof.context -> ctxt_def_type -> string
    val update_tts_ctxt_data:
       ctxt_def_type -> Proof.context -> Proof.context
  end
structure ETTS_Context: ETTS_CONTEXT
Found termination order: "size <*mlex*> {}"
consts
  flat :: "'a list stream => 'a stream"
Found termination order: "size <*mlex*> {}"
consts
  sinterleave :: "'a stream => 'a stream => 'a stream"
consts
  szip :: "'a stream => 'b stream => ('a * 'b) stream"
Found termination order: "size <*mlex*> {}"
consts
  smap2 :: "('a => 'b => 'c) => 'a stream => 'b stream => 'c stream"
signature ETTS_ALGORITHM =
  sig
    val dest_local_typedef_ex: term -> typ * term
    val etts_algorithm:
       Proof.context ->
         etts_output_type ->
           int list ->
             (indexname * term) list ->
               (term * term) list ->
                 (Facts.ref * Token.src list) option ->
                   (Facts.ref * Token.src list) list ->
                     (term list * (Proof.context -> tactic)) option ->
                       Token.src list ->
                         thm -> (thm * int list) * Proof.context
    val etts_fact:
       Proof.context ->
         etts_output_type ->
           int list ->
             (indexname * term) list ->
               (term * term) list ->
                 (Facts.ref * Token.src list) option ->
                   (Facts.ref * Token.src list) list ->
                     (term list * (Proof.context -> tactic)) option ->
                       Token.src list ->
                         thm list -> (thm list * int list) * Proof.context
    datatype etts_output_type = active | default | verbose
    val etts_output_type_of_string: string -> etts_output_type
    val is_active: etts_output_type -> bool
    val is_default: etts_output_type -> bool
    val is_verbose: etts_output_type -> bool
    val mk_local_typedef_ex: (string * sort) * term -> term
    val string_of_etts_output_type: etts_output_type -> string
  end
structure ETTS_Algorithm: ETTS_ALGORITHM
### theory "HOL-Library.Stream"
### 0.953s elapsed time, 3.706s cpu time, 0.340s GC time
class height = type +
  fixes height :: "'a => nat"
instantiation
  tree :: (type) height
  height_tree == height :: 'a tree => nat
signature ETTS_ACTIVE =
  sig
    val etts_indent: int Config.T
    datatype etts_thm_type
    = tts_corollary | tts_lemma | tts_proposition | tts_theorem
    val theorem_string_of_term:
       Proof.context ->
         etts_thm_type ->
           string ->
             Token.src list -> string -> Token.src list -> term -> string
  end
structure ETTS_Active: ETTS_ACTIVE
Found termination order: "size <*mlex*> {}"
signature ETTS_LEMMA =
  sig val tts_lemma: Outer_Syntax.command_keyword -> string -> unit end
structure ETTS_Lemma: ETTS_LEMMA
### theory "HOL-Library.BigO"
### 1.009s elapsed time, 3.699s cpu time, 0.796s GC time
Found termination order: "size <*mlex*> {}"
signature TTS_LEMMAS =
  sig
    val tts_lemmas:
       Proof.context ->
         ETTS_Algorithm.etts_output_type ->
           ((binding * Token.src list) *
            (thm list * (string * Token.src list))
           )
           list
             -> Proof.context * int list
  end
structure TTS_Lemmas: TTS_LEMMAS
val it = (): unit
val it = (): unit
val it = (): unit
val it = (): unit
Found termination order: "size <*mlex*> {}"
Found termination order: "size <*mlex*> {}"
### theory "Draft.ETTS"
### 1.247s elapsed time, 4.378s cpu time, 0.884s GC time
Loading theory "Draft.ETTS_Auxiliary" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions" via "Draft.SML_Introduction" via "Draft.Introduction")
Found termination order: "size <*mlex*> {}"
### theory "Draft.ETTS_Auxiliary"
### 0.106s elapsed time, 0.215s cpu time, 0.000s GC time
Loading theory "Draft.Introduction" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions" via "Draft.SML_Introduction")
Found termination order: "size <*mlex*> {}"
### theory "Draft.Introduction"
### 0.030s elapsed time, 0.060s cpu time, 0.000s GC time
Loading theory "Draft.SML_Introduction" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
Loading theory "Draft.SML_Simple_Orders" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
### theory "Draft.SML_Introduction"
### 0.026s elapsed time, 0.075s cpu time, 0.000s GC time
Loading theory "Draft.SML_Semigroups" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
Found termination order: "size <*mlex*> {}"
Found termination order: "(%p. size (fst p)) <*mlex*> {}"
locale semigroup_ow
  fixes U :: "'ag set"
    and
    f :: "'ag => 'ag => 'ag"
      (infixl \<open>\<^bold>*\<^sub>o\<^sub>w\<close> 70)
  assumes "semigroup_ow U (\<^bold>*\<^sub>o\<^sub>w)"
locale plus_ow
  fixes U :: "'ag set"
    and
    plus :: "'ag => 'ag => 'ag"
      (infixl \<open>+\<^sub>o\<^sub>w\<close> 65)
  assumes "plus_ow U (+\<^sub>o\<^sub>w)"
Found termination order: "size <*mlex*> {}"
locale times_ow
  fixes U :: "'ag set"
    and
    times :: "'ag => 'ag => 'ag"
      (infixl \<open>*\<^sub>o\<^sub>w\<close> 70)
  assumes "times_ow U (*\<^sub>o\<^sub>w)"
locale semigroup_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
  assumes "semigroup_add_ow U (+\<^sub>o\<^sub>w)"
locale semigroup_mult_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
  assumes "semigroup_mult_ow U (*\<^sub>o\<^sub>w)"
Found termination order: "(%p. size (snd p)) <*mlex*> {}"
locale cancel_semigroup_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
  assumes "cancel_semigroup_add_ow U (+\<^sub>o\<^sub>w)"
locale cancel_semigroup_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
  assumes "cancel_semigroup_add_ow U (+\<^sub>o\<^sub>w)"
locale abel_semigroup_ow
  fixes U :: "'ag set"
    and f :: "'ag => 'ag => 'ag"
  assumes "abel_semigroup_ow U (\<^bold>*\<^sub>o\<^sub>w)"
locale ab_semigroup_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
  assumes "ab_semigroup_add_ow U (+\<^sub>o\<^sub>w)"
locale ab_semigroup_mult_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
  assumes "ab_semigroup_mult_ow U (*\<^sub>o\<^sub>w)"
locale abel_semigroup_ow
  fixes U :: "'ag set"
    and f :: "'ag => 'ag => 'ag"
  assumes "abel_semigroup_ow U (\<^bold>*\<^sub>o\<^sub>w)"
locale ord_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'ao => 'ao => bool"  (infix \<open><\<^sub>o\<^sub>w\<close> 50)
Found termination order: "size <*mlex*> {}"
locale ab_semigroup_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
  assumes "ab_semigroup_add_ow U (+\<^sub>o\<^sub>w)"
locale ord_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
theorem lessThan.with_def: lessThan.with == %less u. {x. less x u}
theorem lessThan.with: ord.lessThan == lessThan.with
theorem lessThan'.with: lessThan == lessThan.with (<)
theorem atMost.with_def: atMost.with == %less_eq u. {x. less_eq x u}
theorem atMost.with: ord.atMost == atMost.with
theorem atMost'.with: atMost == atMost.with (<=)
theorem greaterThan.with_def: greaterThan.with == %less l. {x. less l x}
theorem greaterThan.with: ord.greaterThan == greaterThan.with
theorem greaterThan'.with: greaterThan == greaterThan.with (<)
theorem atLeast.with_def: atLeast.with == %less_eq l. {x. less_eq l x}
theorem atLeast.with: ord.atLeast == atLeast.with
theorem atLeast'.with: atLeast == atLeast.with (<=)
theorem
  greaterThanLessThan.with_def:
    greaterThanLessThan.with ==
    %less l u. (with less : {l<..}) Int (with less : {..<u})
theorem
  greaterThanLessThan.with:
    ord.greaterThanLessThan == greaterThanLessThan.with
theorem
  greaterThanLessThan'.with:
    greaterThanLessThan == greaterThanLessThan.with (<)
theorem
  atLeastLessThan.with_def:
    atLeastLessThan.with ==
    %less_eq less l u. (with less_eq : {l..}) Int (with less : {..<u})
theorem atLeastLessThan.with: ord.atLeastLessThan == atLeastLessThan.with
theorem
  atLeastLessThan'.with: atLeastLessThan == atLeastLessThan.with (<=) (<)
theorem
  greaterThanAtMost.with_def:
    greaterThanAtMost.with ==
    %less_eq less l u. (with less : {l<..}) Int (with less_eq : {..u})
theorem
  greaterThanAtMost.with: ord.greaterThanAtMost == greaterThanAtMost.with
theorem
  greaterThanAtMost'.with:
    greaterThanAtMost == greaterThanAtMost.with (<=) (<)
theorem
  atLeastAtMost.with_def:
    atLeastAtMost.with ==
    %less_eq l u. (with less_eq : {l..}) Int (with less_eq : {..u})
theorem atLeastAtMost.with: ord.atLeastAtMost == atLeastAtMost.with
theorem atLeastAtMost'.with: atLeastAtMost == atLeastAtMost.with (<=)
theorem min.with_def: min.with == %less_eq a b. if less_eq a b then a else b
theorem min.with: ord.min == min.with
theorem min'.with: min == min.with (<=)
theorem max.with_def: max.with == %less_eq a b. if less_eq a b then b else a
theorem max.with: ord.max == max.with
theorem max'.with: max == max.with (<=)
theorem
  lessThan_ow_def: on ?U with ?less : {..<?u} == {x. ?less x ?u & x : ?U}
theorem
  lessThan_ow.transfer:
    [| Domainp ?A = (%x. x : ?U); right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> ?A ===> rel_set ?A) (lessThan_ow ?U)
         lessThan.with
theorem
  atMost_ow_def: on ?U with ?less_eq : {..?u} == {x. ?less_eq x ?u & x : ?U}
locale ab_semigroup_mult_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
  assumes "ab_semigroup_mult_ow U (*\<^sub>o\<^sub>w)"
theorem
  atMost_ow.transfer:
    [| Domainp ?A = (%x. x : U); right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> ?A ===> rel_set ?A) (atMost_ow U)
         atMost.with
theorem
  greaterThan_ow_def: on ?U with ?less: {?l<..} == {x. ?less ?l x & x : ?U}
theorem
  greaterThan_ow.transfer:
    [| Domainp ?A = (%x. x : U); right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> ?A ===> rel_set ?A) (greaterThan_ow U)
         greaterThan.with
theorem
  atLeast_ow_def:
    on ?U with ?less_eq : {?l..} == {x. ?less_eq ?l x & x : ?U}
theorem
  atLeast_ow.transfer:
    [| Domainp ?A = (%x. x : U); right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> ?A ===> rel_set ?A) (atLeast_ow U)
         atLeast.with
### theory "HOL-Library.Tree"
### 2.094s elapsed time, 6.782s cpu time, 1.126s GC time
Loading theory "Draft.Templates" (required by "Draft.SML_ConclusionsTemplates" via "Draft.ExtrEqs")
theorem
  greaterThanLessThan_ow_def:
    on ?U with ?less : {?l<..<?u} ==
    (on ?U with ?less: {?l<..}) Int (on ?U with ?less : {..<?u})
theorem
  greaterThanLessThan_ow.transfer:
    [| Domainp ?A = (%x. x : ?U); bi_unique ?A; right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> ?A ===> ?A ===> rel_set ?A)
         (greaterThanLessThan_ow ?U) greaterThanLessThan.with
theorem
  atLeastLessThan_ow_def:
    on ?U with ?less_eq ?less : {?l..<?u} ==
    (on ?U with ?less_eq : {?l..}) Int (on ?U with ?less : {..<?u})
locale minus_ow
  fixes U :: "'ag set"
    and
    minus :: "'ag => 'ag => 'ag"
      (infixl \<open>-\<^sub>o\<^sub>w\<close> 65)
  assumes "minus_ow U (-\<^sub>o\<^sub>w)"
theorem
  atLeastLessThan_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===>
         (?A ===> ?A ===> (=)) ===> ?A ===> ?A ===> rel_set ?A)
         (atLeastLessThan_ow U) atLeastLessThan.with
theorem
  greaterThanAtMost_ow_def:
    on ?U with ?less_eq ?less : {?l<..?u} ==
    (on ?U with ?less: {?l<..}) Int (on ?U with ?less_eq : {..?u})
datatype template_term
=
     t_empty
   | template_app of template_term * template_term
   | template_hole of int
   | template_var of int
datatype sign
= equals | greater_equals | greater_than | less_equals | less_than
datatype template
=
     template_bimplication of template * template
   | template_dunno
   | template_equation of template_term * template_term
   | template_implication of template list * template
   | template_inequation of sign * template_term * template_term
   | template_negation of template
   | template_predicate of template_term
constructor t_empty: template_term
constructor template_app: template_term * template_term -> template_term
constructor template_hole: int -> template_term
constructor template_var: int -> template_term
constructor equals: sign
constructor greater_equals: sign
constructor greater_than: sign
constructor less_equals: sign
constructor less_than: sign
constructor template_bimplication: template * template -> template
constructor template_dunno: template
constructor template_equation: template_term * template_term -> template
constructor template_implication: template list * template -> template
constructor template_inequation:
   sign * template_term * template_term -> template
constructor template_negation: template -> template
constructor template_predicate: template_term -> template
val vfs = fn: term -> (indexname * typ) list * (string * typ) list
val indexOf = fn: ''a list -> ''a -> int -> int
val has_eq = fn: term -> bool
val term2template = fn:
   (indexname * typ) list -> (string * typ) list -> term -> template_term
val lemma2predicate = fn: term -> term -> template
val makeTemplatewithContext = fn: term -> term -> template
val lemma2template = fn: term -> template
val thm2template = fn: thm -> template
val tterm2string = fn: template_term -> string
val template2string = fn: template -> string
val t = "height ?t <= size ?t": thm
val th =
   Const ("HOL.Trueprop", "bool => prop") $
     (Const ("Orderings.ord_class.less_eq", "nat => nat => bool") $
       (Const ("Tree.height_class.height", "?'a tree => nat") $
         Var (("t", 0), "?'a tree")) $
       (Const ("Nat.size_class.size", "?'a tree => nat") $
         Var (("t", 0), "?'a tree"))):
   term
### theory "Draft.Templates"
### 0.064s elapsed time, 0.213s cpu time, 0.000s GC time
Loading theory "Draft.ExtrEqs" (required by "Draft.SML_ConclusionsTemplates")
locale cancel_ab_semigroup_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
  assumes
    "cancel_ab_semigroup_add_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)"
theorem
  greaterThanAtMost_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===>
         (?A ===> ?A ===> (=)) ===> ?A ===> ?A ===> rel_set ?A)
         (greaterThanAtMost_ow U) greaterThanAtMost.with
theorem
  atLeastAtMost_ow_def:
    on ?U with ?less_eq : {?l..?u} ==
    (on ?U with ?less_eq : {?l..}) Int (on ?U with ?less_eq : {..?u})
locale cancel_ab_semigroup_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
  assumes
    "cancel_ab_semigroup_add_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)"
theorem
  atLeastAtMost_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> ?A ===> ?A ===> rel_set ?A)
         (atLeastAtMost_ow U) atLeastAtMost.with
theorem
  min_ow.transfer:
    ((?A ===> ?A ===> (=)) ===> ?A ===> ?A ===> ?A) min.with min.with
theorem
  max_ow.transfer:
    ((?A ===> ?A ===> (=)) ===> ?A ===> ?A ===> ?A) max.with max.with
locale ord_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'ao => 'ao => bool"  (infix \<open><\<^sub>o\<^sub>w\<close> 50)
locale ord_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
### theory "Draft.SML_Semigroups"
### 0.938s elapsed time, 2.837s cpu time, 0.220s GC time
Loading theory "Draft.SML_Monoids" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale partial_preordering_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<^bold>\<le>\<^sub>o\<^sub>w\<close> 50)
  assumes "partial_preordering_ow U (\<^bold>\<le>\<^sub>o\<^sub>w)"
locale preordering_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<^bold>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'ao => 'ao => bool"
      (infix \<open>\<^bold><\<^sub>o\<^sub>w\<close> 50)
  assumes
    "preordering_ow U (\<^bold>\<le>\<^sub>o\<^sub>w)
      (\<^bold><\<^sub>o\<^sub>w)"
locale preorder_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
  assumes "preorder_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale ord_preorder_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes "ord_preorder_ow U\<^sub>2 le\<^sub>2 ls\<^sub>2"
locale preorder_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "preorder_pair_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 U\<^sub>2 le\<^sub>2
      ls\<^sub>2"
locale neutral_ow
  fixes U :: "'ag set"
    and z :: "'ag"  (\<open>\<^bold>1\<^sub>o\<^sub>w\<close>)
  assumes "neutral_ow U \<^bold>1\<^sub>o\<^sub>w"
theorem bdd.with_def: bdd.with == %less_eq A. EX M. ALL x:A. less_eq x M
theorem bdd.with: preordering_bdd.bdd == bdd.with
locale monoid_ow
  fixes U :: "'ag set"
    and f :: "'ag => 'ag => 'ag"
    and z :: "'ag"
  assumes
    "monoid_ow U (\<^bold>*\<^sub>o\<^sub>w) \<^bold>1\<^sub>o\<^sub>w"
theorem bdd_above.with_def: bdd_above.with == bdd.with
theorem bdd_above.with: preorder.bdd_above == bdd_above.with
theorem bdd_above'.with: bdd_above == bdd_above.with (<=)
locale zero_ow
  fixes U :: "'ag set"
    and zero :: "'ag"  (\<open>0\<^sub>o\<^sub>w\<close>)
  assumes "zero_ow U 0\<^sub>o\<^sub>w"
theorem
  bdd_below.with_def:
    bdd_below.with == %less_eq. bdd.with (%x y. less_eq y x)
theorem bdd_below.with: preorder.bdd_below == bdd_below.with
theorem bdd_below'.with: bdd_below == bdd_below.with (<=)
locale one_ow
  fixes U :: "'ag set"
    and one :: "'ag"  (\<open>1\<^sub>o\<^sub>w\<close>)
  assumes "one_ow U 1\<^sub>o\<^sub>w"
locale power_ow
  fixes U :: "'ag set"
    and one :: "'ag"  (\<open>1\<^sub>o\<^sub>w\<close>)
    and
    times :: "'ag => 'ag => 'ag"
      (infixl \<open>*\<^sub>o\<^sub>w\<close> 70)
  assumes "power_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)"
theorem
  bdd_ow_def:
    on ?U with ?less_eq : \<guillemotleft>bdd\<guillemotright> ?A ==
    EX M:?U. ALL x:?A. ?less_eq x M
theorem
  bdd_ow.transfer:
    [| Domainp ?A = (%x. x : ?U); right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> rel_set ?A ===> (=)) (bdd_ow ?U)
         bdd.with
consts
  power_with :: "'a => ('a => 'a => 'a) => 'a => nat => 'a"
locale power_ow
  fixes U :: "'ag set"
    and one :: "'ag"  (\<open>1\<^sub>o\<^sub>w\<close>)
    and
    times :: "'ag => 'ag => 'ag"
      (infixl \<open>*\<^sub>o\<^sub>w\<close> 70)
  assumes "power_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)"
theorem
  bdd_above_ow_def:
    on ?U with ?less_eq : \<guillemotleft>bdd_above\<guillemotright> ?A ==
    on ?U with ?less_eq : \<guillemotleft>bdd\<guillemotright> ?A
theorem
  bdd_above_ow.transfer:
    [| Domainp ?A = (%x. x : U); right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> rel_set ?A ===> (=)) (bdd_above_ow U)
         bdd_above.with
locale monoid_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes "monoid_add_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w"
theorem
  bdd_below_ow_def:
    on ?U with ?less_eq : \<guillemotleft>bdd_below\<guillemotright> ?a ==
    on ?U with (%x M. ?less_eq M
                       x) : \<guillemotleft>bdd\<guillemotright> ?a
theorem
  bdd_below_ow.transfer:
    [| Domainp ?A = (%x. x : U); right_total ?A |]
    ==> ((?A ===> ?A ===> (=)) ===> rel_set ?A ===> (=)) (bdd_below_ow U)
         bdd_below.with
locale monoid_mult_ow
  fixes U :: "'ag set"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes "monoid_mult_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)"
locale preorder_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
  assumes
    "preorder_ow U (\<^bold>\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale preordering_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<^bold>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'ao => 'ao => bool"
      (infix \<open>\<^bold><\<^sub>o\<^sub>w\<close> 50)
  assumes
    "preordering_ow U (\<^bold>\<le>\<^sub>o\<^sub>w)
      (\<^bold><\<^sub>o\<^sub>w)"
locale power_ow
  fixes U :: "'ag set"
    and one :: "'ag"  (\<open>1\<^sub>o\<^sub>w\<close>)
    and
    times :: "'ag => 'ag => 'ag"
      (infixl \<open>*\<^sub>o\<^sub>w\<close> 70)
  assumes "power_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)"
locale monoid_mult_ow
  fixes U :: "'ag set"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes "monoid_mult_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)"
val eqpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Var (("_dummy_", 2), "?'a"))
       ):
   term Find_Theorems.criterion
val badeqpattern = Pattern (Const ("Pure.eq", "?'a => ?'a => prop")):
   term Find_Theorems.criterion
val undefpattern =
   Pattern
    (
       Const ("HOL.Trueprop", "bool => prop") $
         (Const ("HOL.eq", "?'a => ?'a => bool") $
           Var (("_dummy_", 1), "?'a") $ Const ("HOL.undefined", "?'a"))
       ):
   term Find_Theorems.criterion
val thmpattern =
   Pattern
    (Const ("HOL.Trueprop", "bool => prop") $ Var (("_dummy_", 1), "bool")):
   term Find_Theorems.criterion
val badnames =
   ["*nitpick*", "*Nitpick*", "*full_exhaustive*", "*_def*", "Enum.finite*",
    "*Quickcheck*", "ATP*", "*Nunchaku*", "*Code*", "*BNF*", "*SMT*",
    "*.*.*"]:
   string list
val unwanted_names =
   [(false, Name "*nitpick*"), (false, Name "*Nitpick*"),
    (false, Name "*full_exhaustive*"), (false, Name "*_def*"),
    (false, Name "Enum.finite*"), (false, Name "*Quickcheck*"),
    (false, Name "ATP*"), (false, Name "*Nunchaku*"),
    (false, Name "*Code*"), (false, Name "*BNF*"), (false, Name "*SMT*"),
    (false, Name "*.*.*")]:
   (bool * term Find_Theorems.criterion) list
val has_vars = fn: term -> bool
val get_all_eqs = fn: string -> Proof.context -> (string * thm) list
val get_all_thms = fn: string -> Proof.context -> (string * thm) list
val get_noneq_thms = fn: string -> Proof.context -> (string * thm) list
val template_eqs = fn:
   string -> Proof.context -> (string * thm * template) list
val template_thms = fn:
   string -> Proof.context -> (string * thm * template) list
### theory "Draft.ExtrEqs"
### 0.653s elapsed time, 1.954s cpu time, 0.135s GC time
locale preorder_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
  assumes
    "preorder_ow U (\<^bold>\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale comm_monoid_ow
  fixes U :: "'ag set"
    and f :: "'ag => 'ag => 'ag"
    and z :: "'ag"
  assumes
    "comm_monoid_ow U (\<^bold>*\<^sub>o\<^sub>w) \<^bold>1\<^sub>o\<^sub>w"
locale comm_monoid_set_ow
  fixes U :: "'ag set"
    and f :: "'ag => 'ag => 'ag"
    and z :: "'ag"
  assumes
    "comm_monoid_set_ow U (\<^bold>*\<^sub>o\<^sub>w)
      \<^bold>1\<^sub>o\<^sub>w"
locale comm_monoid_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes "comm_monoid_add_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w"
locale dvd_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
  assumes "dvd_ow U (*\<^sub>o\<^sub>w)"
theorem dvd.with_def: dvd.with == %times b a. EX k. a = times b k
theorem dvd.with: dvd.dvd == dvd.with
theorem dvd'.with: (dvd) == dvd.with (*)
theorem
  dvd_ow'_def:
    on ?U with ?times: ?b \<guillemotleft>dvd\<guillemotright> ?a ==
    EX k:?U. ?a = ?times ?b k
theorem
  dvd_ow'.transfer:
    [| Domainp ?A = (%x. x : ?U); bi_unique ?A; right_total ?A |]
    ==> ((?A ===> ?A ===> ?A) ===> ?A ===> ?A ===> (=)) (dvd_ow' ?U)
         dvd.with
theorem
  dvd_ow''.transfer:
    bi_unique ?A2.0 ==>
    (rel_set ?A3.0 ===>
     (?A1.0 ===> ?A3.0 ===> ?A2.0) ===> ?A1.0 ===> ?A2.0 ===> (=))
     dvd_ow' dvd_ow'
locale dvd_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
  assumes "dvd_ow U (*\<^sub>o\<^sub>w)"
locale comm_monoid_mult_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
    and one :: "'ag"
  assumes "comm_monoid_mult_ow U (*\<^sub>o\<^sub>w) 1\<^sub>o\<^sub>w"
locale dvd_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
  assumes "dvd_ow U (*\<^sub>o\<^sub>w)"
locale comm_monoid_mult_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
    and one :: "'ag"
  assumes "comm_monoid_mult_ow U (*\<^sub>o\<^sub>w) 1\<^sub>o\<^sub>w"
locale cancel_comm_monoid_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes
    "cancel_comm_monoid_add_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w"
locale cancel_comm_monoid_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes
    "cancel_comm_monoid_add_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w"
### theory "Draft.SML_Monoids"
### 1.101s elapsed time, 2.635s cpu time, 0.161s GC time
Loading theory "Draft.SML_Groups" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale group_ow
  fixes U :: "'ag set"
    and f :: "'ag => 'ag => 'ag"
    and z :: "'ag"  (\<open>\<^bold>1\<^sub>o\<^sub>w\<close>)
    and inverse :: "'ag => 'ag"
  assumes
    "group_ow U (\<^bold>*\<^sub>o\<^sub>w) \<^bold>1\<^sub>o\<^sub>w
      inverse"
locale uminus_ow
  fixes U :: "'ag set"
    and uminus :: "'ag => 'ag"  (\<open>-\<^sub>o\<^sub>w _\<close> [81] 80)
  assumes "uminus_ow U uminus"
locale group_add_ow
  fixes U :: "'ag set"
    and minus :: "'ag => 'ag => 'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "group_add_ow U (-\<^sub>o\<^sub>w) (+\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w uminus"
locale group_ow
  fixes U :: "'ag set"
    and f :: "'ag => 'ag => 'ag"
    and z :: "'ag"  (\<open>\<^bold>1\<^sub>o\<^sub>w\<close>)
    and inverse :: "'ag => 'ag"
  assumes
    "group_ow U (\<^bold>*\<^sub>o\<^sub>w) \<^bold>1\<^sub>o\<^sub>w
      inverse"
locale group_add_ow
  fixes U :: "'ag set"
    and minus :: "'ag => 'ag => 'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "group_add_ow U (-\<^sub>o\<^sub>w) (+\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w uminus"
locale ab_group_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "ab_group_add_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w
      (-\<^sub>o\<^sub>w) uminus"
locale ab_group_add_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "ab_group_add_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w
      (-\<^sub>o\<^sub>w) uminus"
### theory "Draft.SML_Groups"
### 0.678s elapsed time, 1.359s cpu time, 0.047s GC time
Loading theory "Draft.SML_Semirings" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale semiring_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes "semiring_ow U (+\<^sub>o\<^sub>w) (*\<^sub>o\<^sub>w)"
locale semiring_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes "semiring_ow U (+\<^sub>o\<^sub>w) (*\<^sub>o\<^sub>w)"
locale comm_semiring_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes "comm_semiring_ow U (+\<^sub>o\<^sub>w) (*\<^sub>o\<^sub>w)"
locale mult_zero_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes "mult_zero_ow U (*\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w"
locale semiring_0_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "semiring_0_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w
      (*\<^sub>o\<^sub>w)"
locale comm_semiring_0_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "comm_semiring_0_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w
      (*\<^sub>o\<^sub>w)"
locale semiring_0_cancel_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "semiring_0_cancel_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)"
locale comm_semiring_0_cancel_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "comm_semiring_0_cancel_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)"
locale ordering_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<^bold>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'ao => 'ao => bool"
      (infix \<open>\<^bold><\<^sub>o\<^sub>w\<close> 50)
  assumes
    "ordering_ow U (\<^bold>\<le>\<^sub>o\<^sub>w)
      (\<^bold><\<^sub>o\<^sub>w)"
locale zero_neq_one_ow
  fixes U :: "'ag set"
    and one :: "'ag"  (\<open>1\<^sub>o\<^sub>w\<close>)
    and zero :: "'ag"  (\<open>0\<^sub>o\<^sub>w\<close>)
  assumes "zero_neq_one_ow U 1\<^sub>o\<^sub>w 0\<^sub>o\<^sub>w"
theorem
  of_bool.with_def: of_bool.with == %one zero p. if p then one else zero
theorem of_bool.with: zero_neq_one.of_bool == of_bool.with
theorem of_bool'.with: of_bool == of_bool.with (1::?'a) (0::?'a)
theorem
  of_bool.with.transferred.transfer:
    (?A ===> ?A ===> (=) ===> ?A) of_bool.with of_bool.with
locale order_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
  assumes "order_ow U (\<^bold>\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale zero_neq_one_ow
  fixes U :: "'ag set"
    and one :: "'ag"  (\<open>1\<^sub>o\<^sub>w\<close>)
    and zero :: "'ag"  (\<open>0\<^sub>o\<^sub>w\<close>)
  assumes "zero_neq_one_ow U 1\<^sub>o\<^sub>w 0\<^sub>o\<^sub>w"
locale zero_neq_one_ow
  fixes U :: "'ag set"
    and one :: "'ag"  (\<open>1\<^sub>o\<^sub>w\<close>)
    and zero :: "'ag"  (\<open>0\<^sub>o\<^sub>w\<close>)
  assumes "zero_neq_one_ow U 1\<^sub>o\<^sub>w 0\<^sub>o\<^sub>w"
locale ord_order_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes "ord_order_ow U\<^sub>2 le\<^sub>2 ls\<^sub>2"
locale semiring_1_ow
  fixes U :: "'ag set"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes
    "semiring_1_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)
      (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w"
theorem
  of_nat.with_def: of_nat.with == %one plus zero n. (plus one ^^ n) zero
theorem of_nat.with: semiring_1.of_nat == of_nat.with
theorem of_nat'.with: of_nat == of_nat.with (1::?'a) (+) (0::?'a)
theorem
  Nats.with_def:
    Nats.with == %one plus zero. range (of_nat.with one plus zero)
theorem Nats.with: semiring_1.Nats == Nats.with
theorem Nats'.with: \<nat> == with (1::?'a) (+) (0::?'a) : \<nat>
theorem
  of_nat_ow.transfer:
    (?A1.0 ===>
     (?A1.0 ===> ?A2.0 ===> ?A2.0) ===> ?A2.0 ===> (=) ===> ?A2.0)
     of_nat.with of_nat.with
theorem
  Nats_ow.transfer:
    (?A2.0 ===> (?A2.0 ===> ?A1.0 ===> ?A1.0) ===> ?A1.0 ===> rel_set ?A1.0)
     Nats.with Nats.with
locale semiring_1_ow
  fixes U :: "'ag set"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes
    "semiring_1_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)
      (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w"
locale preorder_order_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "preorder_order_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 U\<^sub>2 le\<^sub>2
      ls\<^sub>2"
locale semiring_1_ow
  fixes U :: "'ag set"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes
    "semiring_1_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)
      (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w"
locale order_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "order_pair_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 U\<^sub>2 le\<^sub>2
      ls\<^sub>2"
theorem
  mono.with_def:
    mono.with ?less_eq ==
    %less_eq f. ALL x y. less_eq x y --> ?less_eq (f x) (f y)
theorem mono.with: order.mono == mono.with (<=)
theorem mono'.with: mono == mono.with (<=) (<=)
theorem
  strict_mono.with_def:
    strict_mono.with ?less ==
    %less f. ALL x y. less x y --> ?less (f x) (f y)
theorem strict_mono.with: order.strict_mono == strict_mono.with (<)
theorem strict_mono'.with: strict_mono == strict_mono.with (<) (<)
theorem
  antimono.with_def:
    antimono.with ?less_eq ==
    %less_eq f. ALL x y. less_eq x y --> ?less_eq (f y) (f x)
theorem antimono.with: order.antimono == antimono.with (<=)
theorem antimono'.with: antimono == antimono.with (<=) (<=)
theorem
  monoseq.with_def:
    monoseq.with ?less_eq ==
    %X. (ALL m n. m <= n --> ?less_eq (X m) (X n)) |
        (ALL m n. m <= n --> ?less_eq (X n) (X m))
theorem monoseq.with: monoseq == monoseq.with (<=)
theorem
  mono_ow_def:
    on ?U\<^sub>2 with ?less_eq ?less_eqa : \<guillemotleft>mono\<guillemotright> ?f ==
    ALL x:?U\<^sub>2.
       ALL y:?U\<^sub>2. ?less_eqa x y --> ?less_eq (?f x) (?f y)
theorem
  mono_ow.transfer:
    [| Domainp ?B = (%x. x : ?U\<^sub>2); right_total ?B |]
    ==> ((?A ===> ?A ===> (=)) ===>
         (?B ===> ?B ===> (=)) ===> (?B ===> ?A) ===> (=))
         (mono_ow ?U\<^sub>2) mono.with
theorem
  strict_mono_ow_def:
    on ?U\<^sub>2 with ?less ?lessa : \<guillemotleft>strict_mono\<guillemotright> ?f ==
    ALL x:?U\<^sub>2. ALL y:?U\<^sub>2. ?lessa x y --> ?less (?f x) (?f y)
theorem
  strict_mono_ow.transfer:
    [| Domainp ?B = (%x. x : U\<^sub>2); right_total ?B |]
    ==> ((?A ===> ?A ===> (=)) ===>
         (?B ===> ?B ===> (=)) ===> (?B ===> ?A) ===> (=))
         (strict_mono_ow U\<^sub>2) strict_mono.with
theorem
  antimono_ow_def:
    on ?U\<^sub>2 with ?less_eq ?less_eqa : \<guillemotleft>antimono\<guillemotright> ?f ==
    ALL x:?U\<^sub>2.
       ALL y:?U\<^sub>2. ?less_eqa x y --> ?less_eq (?f y) (?f x)
theorem
  antimono_ow.transfer:
    [| Domainp ?B = (%x. x : U\<^sub>2); right_total ?B |]
    ==> ((?A ===> ?A ===> (=)) ===>
         (?B ===> ?B ===> (=)) ===> (?B ===> ?A) ===> (=))
         (antimono_ow U\<^sub>2) antimono.with
theorem
  monoseq_ow.transfer:
    [| Domainp ?B = (%x. x : U\<^sub>2); right_total ?B |]
    ==> ((?B ===> ?B ===> (=)) ===> ((=) ===> ?B) ===> (=)) monoseq.with
         monoseq.with
locale ordering_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<^bold>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'ao => 'ao => bool"
      (infix \<open>\<^bold><\<^sub>o\<^sub>w\<close> 50)
  assumes
    "ordering_ow U (\<^bold>\<le>\<^sub>o\<^sub>w)
      (\<^bold><\<^sub>o\<^sub>w)"
locale order_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
  assumes "order_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale comm_semiring_1_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
    and one :: "'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes
    "comm_semiring_1_ow U (*\<^sub>o\<^sub>w) 1\<^sub>o\<^sub>w
      (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w"
locale comm_semiring_1_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
    and one :: "'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
  assumes
    "comm_semiring_1_ow U (*\<^sub>o\<^sub>w) 1\<^sub>o\<^sub>w
      (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w"
locale semiring_1_cancel_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "semiring_1_cancel_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w)"
locale comm_semiring_1_cancel_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and times :: "'ag => 'ag => 'ag"
    and one :: "'ag"
  assumes
    "comm_semiring_1_cancel_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w) 1\<^sub>o\<^sub>w"
locale comm_semiring_1_cancel_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and minus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and times :: "'ag => 'ag => 'ag"
    and one :: "'ag"
  assumes
    "comm_semiring_1_cancel_ow U (+\<^sub>o\<^sub>w) (-\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w) 1\<^sub>o\<^sub>w"
### theory "Draft.SML_Semirings"
### 2.424s elapsed time, 4.868s cpu time, 0.224s GC time
Loading theory "Draft.SML_Rings" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale ring_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "ring_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w (-\<^sub>o\<^sub>w)
      uminus (*\<^sub>o\<^sub>w)"
locale ring_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "ring_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w (-\<^sub>o\<^sub>w)
      uminus (*\<^sub>o\<^sub>w)"
locale comm_ring_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "comm_ring_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w
      (-\<^sub>o\<^sub>w) uminus (*\<^sub>o\<^sub>w)"
locale comm_ring_ow
  fixes U :: "'ag set"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
    and times :: "'ag => 'ag => 'ag"
  assumes
    "comm_ring_ow U (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w
      (-\<^sub>o\<^sub>w) uminus (*\<^sub>o\<^sub>w)"
locale ring_1_ow
  fixes U :: "'ag set"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "ring_1_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w) (+\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w (-\<^sub>o\<^sub>w) uminus"
theorem iszero.with_def: iszero.with == %zero z. z = zero
theorem iszero.with: ring_1.iszero == iszero.with
theorem iszero'.with: iszero == iszero.with (0::?'a)
theorem
  of_int.with_def:
    of_int.with ==
    %one plus zero minus.
       map_fun Rep_Integ id
        (%(i, j).
            minus
             (with one plus zero : \<guillemotleft>of_nat\<guillemotright> i)
             (with one plus zero : \<guillemotleft>of_nat\<guillemotright> j))
theorem of_int.with: ring_1.of_int == of_int.with
theorem of_int'.with: of_int == of_int.with (1::?'a) (+) (0::?'a) (-)
theorem
  Ints.with_def:
    Ints.with ==
    %one plus zero minus. range (of_int.with one plus zero minus)
theorem Ints.with: ring_1.Ints == Ints.with
theorem Ints'.with: \<int> == with (1::?'a) (+) (0::?'a) (-) : \<int>
theorem
  diffs.with_def:
    diffs.with ?zero ?plus ?one ?times ==
    %c n. ?times
           (with ?one ?plus ?zero : \<guillemotleft>of_nat\<guillemotright> (Suc
  n))
           (c (Suc n))
theorem diffs.with: diffs == diffs.with (0::?'a) (+) (1::?'a) (*)
theorem
  iszero_ow.transfer:
    bi_unique ?A ==> (?A ===> ?A ===> (=)) iszero.with iszero.with
theorem
  of_int_ow.transfer:
    (?A2.0 ===>
     (?A2.0 ===> ?A1.0 ===> ?A1.0) ===>
     ?A1.0 ===> (?A1.0 ===> ?A1.0 ===> ?A3.0) ===> (=) ===> ?A3.0)
     of_int.with of_int.with
theorem
  Ints_ow.transfer:
    (?A1.0 ===>
     (?A1.0 ===> ?A2.0 ===> ?A2.0) ===>
     ?A2.0 ===> (?A2.0 ===> ?A2.0 ===> ?A3.0) ===> rel_set ?A3.0)
     Ints.with Ints.with
theorem
  diffs_ow.transfer:
    (?A1.0 ===>
     (?A3.0 ===> ?A1.0 ===> ?A1.0) ===>
     ?A3.0 ===>
     (?A1.0 ===> ?A2.0 ===> ?A4.0) ===>
     ((=) ===> ?A2.0) ===> (=) ===> ?A4.0)
     diffs.with diffs.with
locale ord_order_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "ord_order_ow U\<^sub>2 (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>2)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>2)"
locale ring_1_ow
  fixes U :: "'ag set"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "ring_1_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w) (+\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w (-\<^sub>o\<^sub>w) uminus"
locale ring_1_ow
  fixes U :: "'ag set"
    and one :: "'ag"
    and times :: "'ag => 'ag => 'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "ring_1_ow U 1\<^sub>o\<^sub>w (*\<^sub>o\<^sub>w) (+\<^sub>o\<^sub>w)
      0\<^sub>o\<^sub>w (-\<^sub>o\<^sub>w) uminus"
locale order_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "order_pair_ow U\<^sub>1 (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>1)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>1) U\<^sub>2
      (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>2)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>2)"
locale dense_order_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
  assumes "dense_order_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale ordering_top_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
    and top :: "'ao"  (\<open>\<^bold>\<top>\<^sub>o\<^sub>w\<close>)
  assumes
    "ordering_top_ow U (\<^bold>\<le>\<^sub>o\<^sub>w)
      (\<^bold><\<^sub>o\<^sub>w) \<^bold>\<top>\<^sub>o\<^sub>w"
locale bot_ow
  fixes U :: "'ao set"
    and bot :: "'ao"  (\<open>\<bottom>\<^sub>o\<^sub>w\<close>)
  assumes "bot_ow U \<bottom>\<^sub>o\<^sub>w"
locale bot_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and bot\<^sub>1 :: "'ao"
    and U\<^sub>2 :: "'bo set"
    and bot\<^sub>2 :: "'bo"
  assumes "bot_pair_ow U\<^sub>1 bot\<^sub>1 U\<^sub>2 bot\<^sub>2"
locale order_bot_ow
  fixes U :: "'ao set"
    and bot :: "'ao"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
  assumes
    "order_bot_ow U \<bottom>\<^sub>o\<^sub>w (\<le>\<^sub>o\<^sub>w)
      (<\<^sub>o\<^sub>w)"
locale order_bot_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and bot\<^sub>1 :: "'ao"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and bot\<^sub>2 :: "'bo"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "order_bot_pair_ow U\<^sub>1 bot\<^sub>1 le\<^sub>1 ls\<^sub>1 U\<^sub>2
      bot\<^sub>2 le\<^sub>2 ls\<^sub>2"
locale top_ow
  fixes U :: "'ao set"
    and top :: "'ao"  (\<open>\<top>\<^sub>o\<^sub>w\<close>)
  assumes "top_ow U \<top>\<^sub>o\<^sub>w"
locale top_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and top\<^sub>1 :: "'ao"
    and U\<^sub>2 :: "'bo set"
    and top\<^sub>2 :: "'bo"
  assumes "top_pair_ow U\<^sub>1 top\<^sub>1 U\<^sub>2 top\<^sub>2"
locale order_top_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
    and top :: "'ao"
  assumes
    "order_top_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      \<top>\<^sub>o\<^sub>w"
locale order_top_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and top\<^sub>1 :: "'ao"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
    and top\<^sub>2 :: "'bo"
  assumes
    "order_top_pair_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 top\<^sub>1 U\<^sub>2
      le\<^sub>2 ls\<^sub>2 top\<^sub>2"
locale ordering_top_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
    and top :: "'ao"  (\<open>\<^bold>\<top>\<^sub>o\<^sub>w\<close>)
  assumes
    "ordering_top_ow U (\<^bold>\<le>\<^sub>o\<^sub>w)
      (\<^bold><\<^sub>o\<^sub>w) \<^bold>\<top>\<^sub>o\<^sub>w"
locale order_bot_ow
  fixes U :: "'ao set"
    and bot :: "'ao"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
  assumes
    "order_bot_ow U \<bottom>\<^sub>o\<^sub>w (\<le>\<^sub>o\<^sub>w)
      (<\<^sub>o\<^sub>w)"
locale order_top_ow
  fixes U :: "'ao set"
    and le :: "'ao => 'ao => bool"
    and ls :: "'ao => 'ao => bool"
    and top :: "'ao"
  assumes
    "order_top_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      \<top>\<^sub>o\<^sub>w"
### theory "Draft.SML_Simple_Orders"
### 10.965s elapsed time, 23.433s cpu time, 1.363s GC time
Loading theory "Draft.SML_Semilattices" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
Loading theory "Draft.SML_Topological_Space" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale semilattice_ow
  fixes U :: "'al set"
    and f :: "'al => 'al => 'al"
  assumes "semilattice_ow U (\<^bold>*\<^sub>o\<^sub>w)"
locale semilattice_set_ow
  fixes U :: "'al set"
    and
    f :: "'al => 'al => 'al"
      (infixl \<open>\<^bold>*\<^sub>o\<^sub>w\<close> 70)
  assumes "semilattice_set_ow U (\<^bold>*\<^sub>o\<^sub>w)"
locale semilattice_ow
  fixes U :: "'al set"
    and f :: "'al => 'al => 'al"
  assumes "semilattice_ow U (\<^bold>*\<^sub>o\<^sub>w)"
locale semilattice_order_ow
  fixes U :: "'al set"
    and f :: "'al => 'al => 'al"
    and
    le :: "'al => 'al => bool"
      (infix \<open>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'al => 'al => bool"  (infix \<open><\<^sub>o\<^sub>w\<close> 50)
  assumes
    "semilattice_order_ow U (\<^bold>*\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale semilattice_order_set_ow
  fixes U :: "'al set"
    and f :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
  assumes
    "semilattice_order_set_ow U (\<^bold>*\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale inf_ow
  fixes U :: "'al set"
    and
    inf :: "'al => 'al => 'al"
      (infixl \<open>\<sqinter>\<^sub>o\<^sub>w\<close> 70)
  assumes "inf_ow U (\<sqinter>\<^sub>o\<^sub>w)"
locale inf_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and inf\<^sub>1 :: "'al => 'al => 'al"
    and U\<^sub>2 :: "'bl set"
    and inf\<^sub>2 :: "'bl => 'bl => 'bl"
  assumes "inf_pair_ow U\<^sub>1 inf\<^sub>1 U\<^sub>2 inf\<^sub>2"
locale comm_ring_1_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
    and one :: "'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "comm_ring_1_ow U (*\<^sub>o\<^sub>w) 1\<^sub>o\<^sub>w
      (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w (-\<^sub>o\<^sub>w) uminus"
locale comm_ring_1_ow
  fixes U :: "'ag set"
    and times :: "'ag => 'ag => 'ag"
    and one :: "'ag"
    and plus :: "'ag => 'ag => 'ag"
    and zero :: "'ag"
    and minus :: "'ag => 'ag => 'ag"
    and uminus :: "'ag => 'ag"
  assumes
    "comm_ring_1_ow U (*\<^sub>o\<^sub>w) 1\<^sub>o\<^sub>w
      (+\<^sub>o\<^sub>w) 0\<^sub>o\<^sub>w (-\<^sub>o\<^sub>w) uminus"
locale semilattice_inf_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
  assumes
    "semilattice_inf_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale topological_space_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
  assumes "topological_space_ow U \<tau>"
locale topological_space_pair_ow
  fixes U\<^sub>1 :: "'at set"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and \<tau>\<^sub>2 :: "'bt set => bool"
  assumes
    "topological_space_pair_ow U\<^sub>1 \<tau>\<^sub>1 U\<^sub>2
      \<tau>\<^sub>2"
locale topological_space_triple_ow
  fixes U\<^sub>1 :: "'at set"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and \<tau>\<^sub>2 :: "'bt set => bool"
    and U\<^sub>3 :: "'ct set"
    and \<tau>\<^sub>3 :: "'ct set => bool"
  assumes
    "topological_space_triple_ow U\<^sub>1 \<tau>\<^sub>1 U\<^sub>2
      \<tau>\<^sub>2 U\<^sub>3 \<tau>\<^sub>3"
### theory "Draft.SML_Rings"
### 6.511s elapsed time, 13.777s cpu time, 0.798s GC time
Proofs for inductive predicate(s) "generate_topology_on"
  Proving monotonicity ...
theorem closed.with_def: closed.with == %open S. open (- S)
theorem closed.with: topological_space.closed == closed.with
theorem closed'.with: closed == closed.with open
theorem
  compact.with_def:
    compact.with ==
    %open S.
       ALL C.
          Ball C open & S <= \<Union> C -->
          (EX D<=C. finite D & S <= \<Union> D)
theorem compact.with: topological_space.compact == compact.with
theorem compact'.with: compact == compact.with open
theorem
  connected.with_def:
    connected.with ==
    %open S.
       \<nexists>A B.
          open A &
          open B &
          S <= A Un B & A Int B Int S = {} & A Int S ~= {} & B Int S ~= {}
theorem connected.with: topological_space.connected == connected.with
theorem connected'.with: connected == connected.with open
theorem
  islimpt.with_def:
    islimpt.with ==
    %open x S. ALL T. x : T --> open T --> (EX y:S. y : T & y ~= x)
theorem islimpt.with: topological_space.islimpt == islimpt.with
theorem islimpt'.with: (islimpt) == islimpt.with open
theorem
  interior.with_def:
    interior.with ?open == %S. \<Union> {T. ?open T & T <= S}
theorem interior.with: interior == interior.with open
theorem
  closure.with_def:
    closure.with ?open ==
    %S. S Un {x. with ?open : x \<guillemotleft>islimpt\<guillemotright> S}
theorem closure.with: closure == closure.with open
theorem
  frontier.with_def:
    frontier.with ?open ==
    %S. (with ?open : \<guillemotleft>closure\<guillemotright> S) -
        (with ?open : \<guillemotleft>interior\<guillemotright> S)
theorem frontier.with: frontier == frontier.with open
theorem
  countably_compact.with_def:
    countably_compact.with ?open ==
    %U. ALL A.
           countable A -->
           Ball A ?open -->
           U <= \<Union> A --> (EX T<=A. finite T & U <= \<Union> T)
theorem
  countably_compact.with: countably_compact == countably_compact.with open
theorem
  closed_ow_def:
    on ?U with ?open : \<guillemotleft>closed\<guillemotright> ?S ==
    ?open (- ?S Int ?U)
theorem
  closed_ow.transfer:
    [| Domainp ?A = (%x. x : ?U); bi_unique ?A; right_total ?A |]
    ==> ((rel_set ?A ===> (=)) ===> rel_set ?A ===> (=)) (closed_ow ?U)
         closed.with
locale semilattice_inf_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and inf\<^sub>1 :: "'al => 'al => 'al"
    and le\<^sub>1 :: "'al => 'al => bool"
    and ls\<^sub>1 :: "'al => 'al => bool"
    and U\<^sub>2 :: "'bl set"
    and inf\<^sub>2 :: "'bl => 'bl => 'bl"
    and le\<^sub>2 :: "'bl => 'bl => bool"
    and ls\<^sub>2 :: "'bl => 'bl => bool"
  assumes
    "semilattice_inf_pair_ow U\<^sub>1 inf\<^sub>1 le\<^sub>1 ls\<^sub>1
      U\<^sub>2 inf\<^sub>2 le\<^sub>2 ls\<^sub>2"
locale sup_ow
  fixes U :: "'ao set"
    and
    sup :: "'ao => 'ao => 'ao"
      (infixl \<open>\<squnion>\<^sub>o\<^sub>w\<close> 70)
  assumes "sup_ow U (\<squnion>\<^sub>o\<^sub>w)"
locale sup_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and sup\<^sub>1 :: "'al => 'al => 'al"
    and U\<^sub>2 :: "'bl set"
    and sup\<^sub>2 :: "'bl => 'bl => 'bl"
  assumes "sup_pair_ow U\<^sub>1 sup\<^sub>1 U\<^sub>2 sup\<^sub>2"
theorem
  compact_ow_def:
    on ?U with ?open : \<guillemotleft>compact\<guillemotright> ?S ==
    ALL C:Pow (Pow ?U).
       Ball C ?open & ?S <= \<Union> C -->
       (EX D:Pow (Pow ?U). D <= C & finite D & ?S <= \<Union> D)
theorem
  compact_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((rel_set ?A ===> (=)) ===> rel_set ?A ===> (=)) (compact_ow U)
         compact.with
locale semilattice_sup_ow
  fixes U :: "'al set"
    and sup :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
  assumes
    "semilattice_sup_ow U (\<squnion>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
theorem
  connected_ow_def:
    on ?U with ?open : \<guillemotleft>connected\<guillemotright> ?S ==
    ~ (EX A:Pow ?U.
          EX B:Pow ?U.
             ?open A &
             ?open B &
             ?S <= A Un B &
             A Int (B Int ?S) = {} & A Int ?S ~= {} & B Int ?S ~= {})
theorem
  connected_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((rel_set ?A ===> (=)) ===> rel_set ?A ===> (=)) (connected_ow U)
         connected.with
theorem
  islimpt_ow_def:
    on ?U with ?open : ?x \<guillemotleft>islimpt\<guillemotright> ?S ==
    ALL T:Pow ?U. ?x : T --> ?open T --> (EX y:?S. y : T & y ~= ?x)
theorem
  islimpt_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((rel_set ?A ===> (=)) ===> ?A ===> rel_set ?A ===> (=))
         (islimpt_ow U) islimpt.with
locale semilattice_sup_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and sup\<^sub>1 :: "'al => 'al => 'al"
    and le\<^sub>1 :: "'al => 'al => bool"
    and ls\<^sub>1 :: "'al => 'al => bool"
    and U\<^sub>2 :: "'bl set"
    and sup\<^sub>2 :: "'bl => 'bl => 'bl"
    and le\<^sub>2 :: "'bl => 'bl => bool"
    and ls\<^sub>2 :: "'bl => 'bl => bool"
  assumes
    "semilattice_sup_pair_ow U\<^sub>1 sup\<^sub>1 le\<^sub>1 ls\<^sub>1
      U\<^sub>2 sup\<^sub>2 le\<^sub>2 ls\<^sub>2"
theorem
  interior_ow_def:
    on ?U with ?open : \<guillemotleft>interior\<guillemotright> ?S ==
    \<Union> {x. x <= ?U & ?open x & x <= ?S}
theorem
  interior_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((rel_set ?A ===> (=)) ===> rel_set ?A ===> rel_set ?A)
         (interior_ow U) interior.with
theorem
  closure_ow_def:
    on ?U with ?open : \<guillemotleft>closure\<guillemotright> ?S ==
    ?S Un
    {x: ?U.
     on ?U with ?open : x \<guillemotleft>islimpt\<guillemotright> ?S}
theorem
  closure_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((rel_set ?A ===> (=)) ===> rel_set ?A ===> rel_set ?A)
         (closure_ow U) closure.with
theorem
  frontier_ow_def:
    on ?U with ?open : \<guillemotleft>frontier\<guillemotright> ?S ==
    (on ?U with ?open : \<guillemotleft>closure\<guillemotright> ?S) -
    (on ?U with ?open : \<guillemotleft>interior\<guillemotright> ?S)
theorem
  frontier_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((rel_set ?A ===> (=)) ===> rel_set ?A ===> rel_set ?A)
         (frontier_ow U) frontier.with
locale semilattice_order_ow
  fixes U :: "'al set"
    and f :: "'al => 'al => 'al"
    and
    le :: "'al => 'al => bool"
      (infix \<open>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'al => 'al => bool"  (infix \<open><\<^sub>o\<^sub>w\<close> 50)
  assumes
    "semilattice_order_ow U (\<^bold>*\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
theorem
  countably_compact_ow_def:
    on ?U with ?open : \<guillemotleft>countably_compact\<guillemotright> ?Ua ==
    ALL A:Pow (Pow ?U).
       countable A -->
       Ball A ?open -->
       ?Ua <= \<Union> A -->
       (EX T:Pow (Pow ?U). T <= A & finite T & ?Ua <= \<Union> T)
theorem
  countably_compact_ow.transfer:
    [| Domainp ?A = (%x. x : U); bi_unique ?A; right_total ?A |]
    ==> ((rel_set ?A ===> (=)) ===> rel_set ?A ===> (=))
         (countably_compact_ow U) countably_compact.with
locale topological_space_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
  assumes "topological_space_ow U \<tau>"
class topological_space = open +
  assumes "open_UNIV": "open UNIV"
  assumes "open_Int": "!!S T. [| open S; open T |] ==> open (S Int T)"
  assumes "open_Union": "!!K. Ball K open ==> open (\<Union> K)"
locale semilattice_inf_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
  assumes
    "semilattice_inf_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale topological_space_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
  assumes "topological_space_ow U \<tau>"
locale semilattice_sup_ow
  fixes U :: "'al set"
    and sup :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
  assumes
    "semilattice_sup_ow U (\<squnion>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale semilattice_neutral_ow
  fixes U :: "'al set"
    and f :: "'al => 'al => 'al"
    and z :: "'al"
  assumes
    "semilattice_neutral_ow U (\<^bold>*\<^sub>o\<^sub>w)
      \<^bold>1\<^sub>o\<^sub>w"
locale semilattice_neutral_order_ow
  fixes U :: "'al set"
    and f :: "'al => 'al => 'al"
    and z :: "'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
  assumes
    "semilattice_neutral_order_ow U (\<^bold>*\<^sub>o\<^sub>w)
      \<^bold>1\<^sub>o\<^sub>w (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale bounded_semilattice_inf_top_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and top :: "'al"
  assumes
    "bounded_semilattice_inf_top_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w) \<top>\<^sub>o\<^sub>w"
locale bounded_semilattice_sup_bot_ow
  fixes U :: "'al set"
    and sup :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and bot :: "'al"
  assumes
    "bounded_semilattice_sup_bot_ow U (\<squnion>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w"
### theory "Draft.SML_Semilattices"
### 5.735s elapsed time, 13.254s cpu time, 3.003s GC time
Loading theory "Draft.SML_Lattices" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
Loading theory "Draft.SML_Linorders" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale linorder_ow
  fixes U :: "'a set"
    and le :: "'a => 'a => bool"
    and ls :: "'a => 'a => bool"
  assumes "linorder_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale ord_linorder_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes "ord_linorder_ow U\<^sub>2 le\<^sub>2 ls\<^sub>2"
locale preorder_linorder_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "preorder_linorder_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 U\<^sub>2
      le\<^sub>2 ls\<^sub>2"
locale order_linorder_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "order_linorder_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 U\<^sub>2 le\<^sub>2
      ls\<^sub>2"
locale lattice_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
  assumes
    "lattice_ow U (\<sqinter>\<^sub>o\<^sub>w) (\<le>\<^sub>o\<^sub>w)
      (<\<^sub>o\<^sub>w) (\<squnion>\<^sub>o\<^sub>w)"
locale linorder_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "linorder_pair_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 U\<^sub>2 le\<^sub>2
      ls\<^sub>2"
locale lattice_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and inf\<^sub>1 :: "'al => 'al => 'al"
    and le\<^sub>1 :: "'al => 'al => bool"
    and ls\<^sub>1 :: "'al => 'al => bool"
    and sup\<^sub>1 :: "'al => 'al => 'al"
    and U\<^sub>2 :: "'bl set"
    and inf\<^sub>2 :: "'bl => 'bl => 'bl"
    and le\<^sub>2 :: "'bl => 'bl => bool"
    and ls\<^sub>2 :: "'bl => 'bl => bool"
    and sup\<^sub>2 :: "'bl => 'bl => 'bl"
  assumes
    "lattice_pair_ow U\<^sub>1 inf\<^sub>1 le\<^sub>1 ls\<^sub>1 sup\<^sub>1
      U\<^sub>2 inf\<^sub>2 le\<^sub>2 ls\<^sub>2 sup\<^sub>2"
locale linorder_ow
  fixes U :: "'a set"
    and le :: "'a => 'a => bool"
    and ls :: "'a => 'a => bool"
  assumes "linorder_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale lattice_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
  assumes
    "lattice_ow U (\<sqinter>\<^sub>o\<^sub>w) (\<le>\<^sub>o\<^sub>w)
      (<\<^sub>o\<^sub>w) (\<squnion>\<^sub>o\<^sub>w)"
### theory "Draft.SML_Topological_Space"
### 7.757s elapsed time, 19.277s cpu time, 3.355s GC time
Loading theory "Draft.SML_Product_Topology" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
Loading theory "Draft.SML_Topological_Space_Countability" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale first_countable_topology_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
  assumes "first_countable_topology_ow U \<tau>"
locale ts_fct_ow
  fixes U\<^sub>1 :: "'at set"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and \<tau>\<^sub>2 :: "'bt set => bool"
  assumes "ts_fct_ow U\<^sub>1 \<tau>\<^sub>1 U\<^sub>2 \<tau>\<^sub>2"
locale first_countable_topology_pair_ow
  fixes U\<^sub>1 :: "'at set"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and \<tau>\<^sub>2 :: "'bt set => bool"
  assumes
    "first_countable_topology_pair_ow U\<^sub>1 \<tau>\<^sub>1 U\<^sub>2
      \<tau>\<^sub>2"
locale first_countable_topology_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
  assumes "first_countable_topology_ow U \<tau>"
theorem
  open_prod.with_def:
    open_prod.with ?open ?opena ==
    %S. ALL x:S.
           EX A B. ?opena A & ?open B & x : A \<times> B & A \<times> B <= S
theorem open_prod.with: open_prod_inst.open_prod == open_prod.with open open
theorem open.with: open == open_prod.with open open
theorem
  open_ow_def:
    (on ?U\<^sub>2 ?U\<^sub>1 with ?open ?opena : \<guillemotleft>open\<guillemotright> ?S
    ) ==
    ALL x:?S.
       EX A:Pow ?U\<^sub>2.
          EX B:Pow ?U\<^sub>1.
             ?opena A & ?open B & A \<times> B <= ?S & x : A \<times> B
theorem
  open_ow.transfer:
    [| Domainp ?B = (%x. x : ?U\<^sub>1); Domainp ?A = (%x. x : ?U\<^sub>2);
       bi_unique ?A; right_total ?A; bi_unique ?B; right_total ?B |]
    ==> ((rel_set ?B ===> (=)) ===>
         (rel_set ?A ===> (=)) ===> rel_set (rel_prod ?A ?B) ===> (=))
         (open_ow ?U\<^sub>2 ?U\<^sub>1) open_prod.with
locale countable_basis_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
    and B :: "'at set set"
  assumes "countable_basis_ow U \<tau> B"
locale product_topology_ow
  fixes U\<^sub>1 :: "'at set"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and \<tau>\<^sub>2 :: "'bt set => bool"
    and \<tau> :: "('at * 'bt) set => bool"
  assumes
    "product_topology_ow U\<^sub>1 \<tau>\<^sub>1 U\<^sub>2 \<tau>\<^sub>2
      \<tau>"
locale countable_basis_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
    and B :: "'at set set"
  assumes "countable_basis_ow U \<tau> B"
locale order_linorder_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "order_linorder_ow U\<^sub>1 (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>1)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>1) U\<^sub>2
      (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>2)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>2)"
locale product_topology_ow
  fixes U\<^sub>1 :: "'at set"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and \<tau>\<^sub>2 :: "'bt set => bool"
    and \<tau> :: "('at * 'bt) set => bool"
  assumes
    "product_topology_ow U\<^sub>1 \<tau>\<^sub>1 U\<^sub>2 \<tau>\<^sub>2
      \<tau>"
locale second_countable_topology_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
  assumes "second_countable_topology_ow U \<tau>"
locale second_countable_topology_ow
  fixes U :: "'at set"
    and \<tau> :: "'at set => bool"
  assumes "second_countable_topology_ow U \<tau>"
### theory "Draft.SML_Topological_Space_Countability"
### 0.644s elapsed time, 2.536s cpu time, 0.086s GC time
locale linorder_pair_ow
  fixes U\<^sub>1 :: "'ao set"
    and le\<^sub>1 :: "'ao => 'ao => bool"
    and ls\<^sub>1 :: "'ao => 'ao => bool"
    and U\<^sub>2 :: "'bo set"
    and le\<^sub>2 :: "'bo => 'bo => bool"
    and ls\<^sub>2 :: "'bo => 'bo => bool"
  assumes
    "linorder_pair_ow U\<^sub>1 (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>1)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>1) U\<^sub>2
      (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>2)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>2)"
### theory "Draft.SML_Product_Topology"
### 1.089s elapsed time, 3.870s cpu time, 0.201s GC time
locale dense_linorder_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'ao => 'ao => bool"  (infix \<open><\<^sub>o\<^sub>w\<close> 50)
  assumes "dense_linorder_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale dense_linorder_ow
  fixes U :: "'ao set"
    and
    le :: "'ao => 'ao => bool"
      (infix \<open>\<le>\<^sub>o\<^sub>w\<close> 50)
    and
    ls :: "'ao => 'ao => bool"  (infix \<open><\<^sub>o\<^sub>w\<close> 50)
  assumes "dense_linorder_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)"
locale bounded_lattice_bot_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and bot :: "'al"
  assumes
    "bounded_lattice_bot_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w"
locale bounded_lattice_bot_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and inf\<^sub>1 :: "'al => 'al => 'al"
    and le\<^sub>1 :: "'al => 'al => bool"
    and ls\<^sub>1 :: "'al => 'al => bool"
    and sup\<^sub>1 :: "'al => 'al => 'al"
    and bot\<^sub>1 :: "'al"
    and U\<^sub>2 :: "'bl set"
    and inf\<^sub>2 :: "'bl => 'bl => 'bl"
    and le\<^sub>2 :: "'bl => 'bl => bool"
    and ls\<^sub>2 :: "'bl => 'bl => bool"
    and sup\<^sub>2 :: "'bl => 'bl => 'bl"
    and bot\<^sub>2 :: "'bl"
  assumes
    "bounded_lattice_bot_pair_ow U\<^sub>1 inf\<^sub>1 le\<^sub>1 ls\<^sub>1
      sup\<^sub>1 bot\<^sub>1 U\<^sub>2 inf\<^sub>2 le\<^sub>2 ls\<^sub>2
      sup\<^sub>2 bot\<^sub>2"
### theory "Draft.SML_Linorders"
### 3.953s elapsed time, 11.629s cpu time, 0.681s GC time
Loading theory "Draft.SML_Ordered_Topological_Spaces" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale order_topology_ow
  fixes U :: "'at set"
    and le :: "'at => 'at => bool"
    and ls :: "'at => 'at => bool"
    and \<tau> :: "'at set => bool"
  assumes
    "order_topology_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w) \<tau>"
locale ts_ot_ow
  fixes U\<^sub>1 :: "'at set"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and le\<^sub>2 :: "'bt => 'bt => bool"
    and ls\<^sub>2 :: "'bt => 'bt => bool"
    and \<tau>\<^sub>2 :: "'bt set => bool"
  assumes
    "ts_ot_ow U\<^sub>1 \<tau>\<^sub>1 U\<^sub>2 le\<^sub>2 ls\<^sub>2
      \<tau>\<^sub>2"
locale order_topology_pair_ow
  fixes U\<^sub>1 :: "'at set"
    and le\<^sub>1 :: "'at => 'at => bool"
    and ls\<^sub>1 :: "'at => 'at => bool"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and le\<^sub>2 :: "'bt => 'bt => bool"
    and ls\<^sub>2 :: "'bt => 'bt => bool"
    and \<tau>\<^sub>2 :: "'bt set => bool"
  assumes
    "order_topology_pair_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 \<tau>\<^sub>1
      U\<^sub>2 le\<^sub>2 ls\<^sub>2 \<tau>\<^sub>2"
locale order_topology_ow
  fixes U :: "'at set"
    and le :: "'at => 'at => bool"
    and ls :: "'at => 'at => bool"
    and \<tau> :: "'at set => bool"
  assumes
    "order_topology_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w) \<tau>"
locale bounded_lattice_top_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and top :: "'al"
  assumes
    "bounded_lattice_top_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<top>\<^sub>o\<^sub>w"
locale bounded_lattice_top_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and inf\<^sub>1 :: "'al => 'al => 'al"
    and le\<^sub>1 :: "'al => 'al => bool"
    and ls\<^sub>1 :: "'al => 'al => bool"
    and sup\<^sub>1 :: "'al => 'al => 'al"
    and top\<^sub>1 :: "'al"
    and U\<^sub>2 :: "'bl set"
    and inf\<^sub>2 :: "'bl => 'bl => 'bl"
    and le\<^sub>2 :: "'bl => 'bl => bool"
    and ls\<^sub>2 :: "'bl => 'bl => bool"
    and sup\<^sub>2 :: "'bl => 'bl => 'bl"
    and top\<^sub>2 :: "'bl"
  assumes
    "bounded_lattice_top_pair_ow U\<^sub>1 inf\<^sub>1 le\<^sub>1 ls\<^sub>1
      sup\<^sub>1 top\<^sub>1 U\<^sub>2 inf\<^sub>2 le\<^sub>2 ls\<^sub>2
      sup\<^sub>2 top\<^sub>2"
locale linorder_topology_ow
  fixes U :: "'at set"
    and le :: "'at => 'at => bool"
    and ls :: "'at => 'at => bool"
    and \<tau> :: "'at set => bool"
  assumes
    "linorder_topology_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      \<tau>"
locale ts_lt_ow
  fixes U\<^sub>1 :: "'at set"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and le\<^sub>2 :: "'bt => 'bt => bool"
    and ls\<^sub>2 :: "'bt => 'bt => bool"
    and \<tau>\<^sub>2 :: "'bt set => bool"
  assumes
    "ts_lt_ow U\<^sub>1 \<tau>\<^sub>1 U\<^sub>2 le\<^sub>2 ls\<^sub>2
      \<tau>\<^sub>2"
locale ot_lt_ow
  fixes U\<^sub>1 :: "'at set"
    and le\<^sub>1 :: "'at => 'at => bool"
    and ls\<^sub>1 :: "'at => 'at => bool"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and le\<^sub>2 :: "'bt => 'bt => bool"
    and ls\<^sub>2 :: "'bt => 'bt => bool"
    and \<tau>\<^sub>2 :: "'bt set => bool"
  assumes
    "ot_lt_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1 \<tau>\<^sub>1 U\<^sub>2
      le\<^sub>2 ls\<^sub>2 \<tau>\<^sub>2"
locale linorder_topology_pair_ow
  fixes U\<^sub>1 :: "'at set"
    and le\<^sub>1 :: "'at => 'at => bool"
    and ls\<^sub>1 :: "'at => 'at => bool"
    and \<tau>\<^sub>1 :: "'at set => bool"
    and U\<^sub>2 :: "'bt set"
    and le\<^sub>2 :: "'bt => 'bt => bool"
    and ls\<^sub>2 :: "'bt => 'bt => bool"
    and \<tau>\<^sub>2 :: "'bt set => bool"
  assumes
    "linorder_topology_pair_ow U\<^sub>1 le\<^sub>1 ls\<^sub>1
      \<tau>\<^sub>1 U\<^sub>2 le\<^sub>2 ls\<^sub>2 \<tau>\<^sub>2"
locale linorder_topology_ow
  fixes U :: "'at set"
    and le :: "'at => 'at => bool"
    and ls :: "'at => 'at => bool"
    and \<tau> :: "'at set => bool"
  assumes
    "linorder_topology_ow U (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      \<tau>"
### theory "Draft.SML_Ordered_Topological_Spaces"
### 2.409s elapsed time, 4.977s cpu time, 0.469s GC time
locale bounded_lattice_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and bot :: "'al"
    and top :: "'al"
  assumes
    "bounded_lattice_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w
      \<top>\<^sub>o\<^sub>w"
locale bounded_lattice_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and inf\<^sub>1 :: "'al => 'al => 'al"
    and le\<^sub>1 :: "'al => 'al => bool"
    and ls\<^sub>1 :: "'al => 'al => bool"
    and sup\<^sub>1 :: "'al => 'al => 'al"
    and bot\<^sub>1 :: "'al"
    and top\<^sub>1 :: "'al"
    and U\<^sub>2 :: "'bl set"
    and inf\<^sub>2 :: "'bl => 'bl => 'bl"
    and le\<^sub>2 :: "'bl => 'bl => bool"
    and ls\<^sub>2 :: "'bl => 'bl => bool"
    and sup\<^sub>2 :: "'bl => 'bl => 'bl"
    and bot\<^sub>2 :: "'bl"
    and top\<^sub>2 :: "'bl"
  assumes
    "bounded_lattice_pair_ow U\<^sub>1 inf\<^sub>1 le\<^sub>1 ls\<^sub>1
      sup\<^sub>1 bot\<^sub>1 top\<^sub>1 U\<^sub>2 inf\<^sub>2 le\<^sub>2
      ls\<^sub>2 sup\<^sub>2 bot\<^sub>2 top\<^sub>2"
locale bounded_lattice_bot_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and bot :: "'al"
  assumes
    "bounded_lattice_bot_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w"
locale bounded_lattice_top_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and top :: "'al"
  assumes
    "bounded_lattice_top_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<top>\<^sub>o\<^sub>w"
locale bounded_lattice_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and bot :: "'al"
    and top :: "'al"
  assumes
    "bounded_lattice_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w
      \<top>\<^sub>o\<^sub>w"
locale distrib_lattice_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
  assumes
    "distrib_lattice_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w)"
locale distrib_lattice_ow
  fixes U :: "'al set"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
  assumes
    "distrib_lattice_ow U (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w)"
### theory "Draft.SML_Lattices"
### 10.363s elapsed time, 20.786s cpu time, 1.419s GC time
Loading theory "Draft.SML_Complete_Lattices" (required by "Draft.SML_ConclusionsTemplates" via "Draft.SML_Conclusions")
locale Inf_ow
  fixes U :: "'al set"
    and Inf :: "'al set => 'al"  (\<open>\<Sqinter>\<^sub>o\<^sub>w\<close>)
  assumes "Inf_ow U \<Sqinter>\<^sub>o\<^sub>w"
locale Inf_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and Inf\<^sub>1 :: "'al set => 'al"
    and U\<^sub>2 :: "'bl set"
    and Inf\<^sub>2 :: "'bl set => 'bl"
  assumes "Inf_pair_ow U\<^sub>1 Inf\<^sub>1 U\<^sub>2 Inf\<^sub>2"
locale Sup_ow
  fixes U :: "'al set"
    and Sup :: "'al set => 'al"  (\<open>\<Squnion>\<^sub>o\<^sub>w\<close>)
  assumes "Sup_ow U \<Squnion>\<^sub>o\<^sub>w"
locale Sup_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and Sup\<^sub>1 :: "'al set => 'al"
    and U\<^sub>2 :: "'bl set"
    and Sup\<^sub>2 :: "'bl set => 'bl"
  assumes "Sup_pair_ow U\<^sub>1 Sup\<^sub>1 U\<^sub>2 Sup\<^sub>2"
locale complete_lattice_ow
  fixes U :: "'al set"
    and Inf :: "'al set => 'al"
    and Sup :: "'al set => 'al"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and bot :: "'al"
    and top :: "'al"
  assumes
    "complete_lattice_ow U \<Sqinter>\<^sub>o\<^sub>w
      \<Squnion>\<^sub>o\<^sub>w (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w
      \<top>\<^sub>o\<^sub>w"
locale complete_lattice_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and Inf\<^sub>1 :: "'al set => 'al"
    and Sup\<^sub>1 :: "'al set => 'al"
    and inf\<^sub>1 :: "'al => 'al => 'al"
    and le\<^sub>1 :: "'al => 'al => bool"
    and ls\<^sub>1 :: "'al => 'al => bool"
    and sup\<^sub>1 :: "'al => 'al => 'al"
    and bot\<^sub>1 :: "'al"
    and top\<^sub>1 :: "'al"
    and U\<^sub>2 :: "'bl set"
    and Inf\<^sub>2 :: "'bl set => 'bl"
    and Sup\<^sub>2 :: "'bl set => 'bl"
    and inf\<^sub>2 :: "'bl => 'bl => 'bl"
    and le\<^sub>2 :: "'bl => 'bl => bool"
    and ls\<^sub>2 :: "'bl => 'bl => bool"
    and sup\<^sub>2 :: "'bl => 'bl => 'bl"
    and bot\<^sub>2 :: "'bl"
    and top\<^sub>2 :: "'bl"
  assumes
    "complete_lattice_pair_ow U\<^sub>1 Inf\<^sub>1 Sup\<^sub>1 inf\<^sub>1
      le\<^sub>1 ls\<^sub>1 sup\<^sub>1 bot\<^sub>1 top\<^sub>1 U\<^sub>2
      Inf\<^sub>2 Sup\<^sub>2 inf\<^sub>2 le\<^sub>2 ls\<^sub>2 sup\<^sub>2
      bot\<^sub>2 top\<^sub>2"
locale complete_lattice_ow
  fixes U :: "'al set"
    and Inf :: "'al set => 'al"
    and Sup :: "'al set => 'al"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and bot :: "'al"
    and top :: "'al"
  assumes
    "complete_lattice_ow U \<Sqinter>\<^sub>o\<^sub>w
      \<Squnion>\<^sub>o\<^sub>w (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w
      \<top>\<^sub>o\<^sub>w"
locale complete_lattice_ow
  fixes U :: "'al set"
    and Inf :: "'al set => 'al"
    and Sup :: "'al set => 'al"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and bot :: "'al"
    and top :: "'al"
  assumes
    "complete_lattice_ow U \<Sqinter>\<^sub>o\<^sub>w
      \<Squnion>\<^sub>o\<^sub>w (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w
      \<top>\<^sub>o\<^sub>w"
locale complete_lattice_ow
  fixes U :: "'al set"
    and Inf :: "'al set => 'al"
    and Sup :: "'al set => 'al"
    and inf :: "'al => 'al => 'al"
    and le :: "'al => 'al => bool"
    and ls :: "'al => 'al => bool"
    and sup :: "'al => 'al => 'al"
    and bot :: "'al"
    and top :: "'al"
  assumes
    "complete_lattice_ow U \<Sqinter>\<^sub>o\<^sub>w
      \<Squnion>\<^sub>o\<^sub>w (\<sqinter>\<^sub>o\<^sub>w)
      (\<le>\<^sub>o\<^sub>w) (<\<^sub>o\<^sub>w)
      (\<squnion>\<^sub>o\<^sub>w) \<bottom>\<^sub>o\<^sub>w
      \<top>\<^sub>o\<^sub>w"
locale complete_lattice_pair_ow
  fixes U\<^sub>1 :: "'al set"
    and Inf\<^sub>1 :: "'al set => 'al"
    and Sup\<^sub>1 :: "'al set => 'al"
    and inf\<^sub>1 :: "'al => 'al => 'al"
    and le\<^sub>1 :: "'al => 'al => bool"
    and ls\<^sub>1 :: "'al => 'al => bool"
    and sup\<^sub>1 :: "'al => 'al => 'al"
    and bot\<^sub>1 :: "'al"
    and top\<^sub>1 :: "'al"
    and U\<^sub>2 :: "'bl set"
    and Inf\<^sub>2 :: "'bl set => 'bl"
    and Sup\<^sub>2 :: "'bl set => 'bl"
    and inf\<^sub>2 :: "'bl => 'bl => 'bl"
    and le\<^sub>2 :: "'bl => 'bl => bool"
    and ls\<^sub>2 :: "'bl => 'bl => bool"
    and sup\<^sub>2 :: "'bl => 'bl => 'bl"
    and bot\<^sub>2 :: "'bl"
    and top\<^sub>2 :: "'bl"
  assumes
    "complete_lattice_pair_ow U\<^sub>1
      \<Sqinter>\<^sub>o\<^sub>w\<^sub>.\<^sub>1
      \<Squnion>\<^sub>o\<^sub>w\<^sub>.\<^sub>1
      (\<sqinter>\<^sub>o\<^sub>w\<^sub>.\<^sub>1)
      (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>1)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>1)
      (\<squnion>\<^sub>o\<^sub>w\<^sub>.\<^sub>1)
      \<bottom>\<^sub>o\<^sub>w\<^sub>.\<^sub>1
      \<top>\<^sub>o\<^sub>w\<^sub>.\<^sub>1 U\<^sub>2
      \<Sqinter>\<^sub>o\<^sub>w\<^sub>.\<^sub>2
      \<Squnion>\<^sub>o\<^sub>w\<^sub>.\<^sub>2
      (\<sqinter>\<^sub>o\<^sub>w\<^sub>.\<^sub>2)
      (\<le>\<^sub>o\<^sub>w\<^sub>.\<^sub>2)
      (<\<^sub>o\<^sub>w\<^sub>.\<^sub>2)
      (\<squnion>\<^sub>o\<^sub>w\<^sub>.\<^sub>2)
      \<bottom>\<^sub>o\<^sub>w\<^sub>.\<^sub>2
      \<top>\<^sub>o\<^sub>w\<^sub>.\<^sub>2"
### theory "Draft.SML_Complete_Lattices"
### 17.653s elapsed time, 17.999s cpu time, 0.597s GC time
Loading theory "Draft.SML_Conclusions" (required by "Draft.SML_ConclusionsTemplates")
### theory "Draft.SML_Conclusions"
### 0.949s elapsed time, 0.991s cpu time, 0.047s GC time
Loading theory "Draft.SML_ConclusionsTemplates"
val templateLemmas = []: (string * thm * template) list
### theory "Draft.SML_ConclusionsTemplates"
### 0.349s elapsed time, 0.450s cpu time, 0.000s GC time
val it = (): unit
